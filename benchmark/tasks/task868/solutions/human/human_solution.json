[
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 310\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint fac[N],inv[N],a[N],ans,n,k,r[N],b[N];\nchar ch[N]; bool vis[N];\nvoid init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[N-1]=ksm(fac[N-1],mdn-2);\n\tfor(int i=N-1;i;i--)\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%mdn*inv[n-m]%mdn;}\nint solve(int tot,int dat)\n{\n\tint cur=fac[tot],cnt=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(a[i]==a[i-1])\tcnt++;\n\t\telse\tcur=1ll*cur*inv[cnt]%mdn, cnt=1;\n\t}\n\tcur=1ll*cur*inv[cnt]%mdn;\n\tint pt=1; memset(vis,0,n+1);\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='r')\n\t\tif(pt<=tot)\tr[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot)\treturn 0; pt=1;\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='b')\n\t\tif(pt<=tot&&r[pt]<i&&a[pt]>=2)\tb[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot&&a[pt]>=2)\treturn 0; pt=1; int qwq=a[pt]-2;\n\tfor(int i=1;i<=k;i++)\tif(!vis[i])\n\t\tif(pt<=tot&&b[pt]<i&&qwq>0)\n\t\t{\n\t\t\tqwq--; if(!qwq)\tpt++,qwq=a[pt]-2;\n\t\t}\n\tif(qwq>0)\treturn 0;\n\treturn 1ll*dat*cur%mdn;\n}\nvoid dfs(int val,int x,int ful,int wei)\n{\n\tif(ful<wei)\treturn;\n\tif(!val)\treturn upd(ans,solve(x-1,C(ful,wei)));\n\tfor(int i=1;i<=min(val,a[x-1]);i++)\ta[x]=i,dfs(val-i,x+1,ful+(i>=2?2:0),wei+2*i);\n}\nint main()\n{\n\tn=read(),k=read(); init();\n\tscanf(\"%s\",ch+1); a[0]=n+1;\n\tfor(int i=1;i<=n;i++)\tdfs(i,1,n+1,0);\n\tprintf(\"%d\\n\",ans+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(max(p + 2*g, p + 2) > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(vector<int> &f) {\n    vector<int> used(K, 0);\n    vector<pii> bpos;\n\n    int pos1 = 0, pos2 = 0;\n    for(int i = (int)f.size() - 1; i >= 0; i--) {\n        if(f[i] == 0) continue;\n\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        bpos.push_back(pii(pos2, f[i] - 1));\n\n        pos1++;\n        pos2++;\n    }\n    for(int i = (int)bpos.size() - 1; i >= 0; i--) {\n        int need = bpos[i].second;\n        int pos = bpos[i].first;\n\n        for(int j = pos + 1; j < K; j++) {\n            if(need == 0) break;\n            if(!used[j]) {\n                need--;\n                used[j] = 1;\n            }\n        }\n        if(need) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + 2*f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        if(chk(f)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint N, K;\nchar S[75];\nint Fact[75], Inv[75];\nint W[75][75][75];\nbool Use[75];\nconst int MOD = 1000000007;\nint F[75], R[75], B[75];\nint V[75];\nint ind, sum = 0, x[75], sumG, prod = 1;\nint ans;\nint powerLog(int n, int p)\n{\n    int sol = 1;\n    while(p)\n    {\n        if(p % 2 == 1)\n            sol = (1LL * sol * n) % MOD;\n        p /= 2;\n        n = (1LL * n * n) % MOD;\n    }\n    return sol;\n}\nvoid Read()\n{\n    cin >> N >> K;\n    cin.get();\n    cin.getline(S + 1, 75);\n    Fact[0] = 1;\n    for(int i = 1; i <= 70; i++)\n        Fact[i] = (1LL * Fact[i - 1] * i) % MOD;\n    Inv[70] = powerLog(Fact[70], MOD - 2);\n    for(int i = 70 - 1; i >= 0; i--)\n    {\n        Inv[i] = (1LL * Inv[i + 1] * (i + 1)) % MOD;\n    }\n}\ninline void Add(int& x, int y)\n{\n    x += y;\n    if(x >= MOD)\n        x -= MOD;\n}\nint Comb(int n, int k)\n{\n    if(k > n)\n        return 0;\n    if(k == -1 && n == -1)\n        return 1;\n    if(k == -1)\n        return 0;\n    return (((1LL * Fact[n] * Inv[n - k]) % MOD) * Inv[k]) % MOD;\n}\nvoid precalcWays()\n{\n    for(int fixed = 0; fixed <= 70; fixed++)\n    {\n        for(int fixed2 = 0; fixed2 <= 70; fixed2++)\n        for(int b = 0; b <= 70; b++)\n        {\n            for(int r = 0; r + b <= 70; r++)\n            {\n                Add(W[fixed][fixed2][b + r], (1LL * Comb(r + fixed2 - 1, fixed2 - 1) * Comb(fixed + b - 1, fixed - 1) % MOD));\n            }\n        }\n    }\n}\n\nbool check(int ind)\n{\n    //sort(F + 1, F + ind + 1);\n    for(int i = 1; i <= K; i++)\n        Use[i] = 0;\n    int r = 1, b = 1;\n    for(int i = ind; i >= 1; i--)\n    {\n        while(r <= K && S[r] != 'r')\n            r++;\n\n        if(r>= K + 1)\n            return 0;\n        R[i] = r;\n        Use[r] = 1;\n        ++r;\n        if(F[i] >= 2)\n        {\n            b = max(b, R[i] + 1);\n            while(b <= K && S[b] != 'b')\n                ++b;\n\n            if(b >= K + 1)\n                return 0;\n            B[i] = b;\n            Use[b] = 1;\n            ++b;\n        }\n    }\n    int p = 1;\n    for(int i = ind; i >= 1; i--)\n    {\n        if(F[i] >= 3)\n        {\n            int nb = F[i] - 2;\n            p = max(p, B[i] + 1);\n            while(nb > 0 && p <= K)\n            {\n                if(Use[p] == 0)\n                {\n                    nb--;\n                    Use[p] = 1;\n                }\n                ++p;\n            }\n            if(nb > 0)\n                return 0;\n        }\n    }\n    return 1;\n}\ninline int Val(int x)\n{\n    if(x == 1)\n        return 1;\n    return (x - 1) * 2 - 1;\n}\nvoid genPartition(int k)\n{\n    for(int i = F[k - 1]; Val(i) + sum <= N; i++)\n    {\n        F[k] = i;\n        sum += Val(i);\n        sumG += F[k];\n        prod = Fact[k];\n        int cnt = 0;\n        for(int j = 1; j <= F[k]; j++)\n            V[j] = 0;\n        for(int j = 1; j <= k; j++)\n        {\n            V[F[j]]++;\n        }\n\n        for(int j = 1; j <= F[k]; j++)\n            prod = (1LL * Inv[V[j]] * prod) % MOD;\n        int fixed = sumG - k;\n        int fixed2 = fixed + k;\n        /*if(fixed == 0)\n            --fixed2;*/\n        if(check(k))\n        {\n            for(int j = k - 1; j + sum <= N; j++)\n            {\n                int rem = N - j - sum;\n                int w = j - k + 1;\n                int aux = (1LL * W[fixed][fixed2][rem] * Comb(w + k, k)) % MOD;\n                Add(ans, (1LL * aux * prod) % MOD);\n\n            }\n            genPartition(k + 1);\n        }\n\n        sum -= Val(i);\n        sumG -= F[k];\n    }\n}\nint main()\n{\n    F[0] = 1;\n    Read();\n    precalcWays();\n    genPartition(1);\n    cout << ans + 1<< \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nbool used[100];\nint p[100];\nint calc(){\n    int n=X.size();\n    if(n>R)return 0;\n\n    memset(used,0,sizeof(used));\n    rep(i,n)used[r[n-i]]=true;\n    int pos=B;\n    for(int i=0;i<n;i++){\n        if(X[i]==1)break;\n        while(pos>0&&b[pos]<r[n-i])pos--;\n        if(pos==0)return 0;\n        used[b[pos]]=true;\n        p[i]=pos;\n        pos--;\n    }\n    pos=0;\n    rep(i,n){\n        chmax(pos,p[i]+1);\n        rep(t,X[i]-2){\n            while(pos<N&&used[pos])pos++;\n            if(pos==N)return 0;\n            used[pos]=true;\n            pos++;\n        }\n    }\n\n    vpint ei;\n    rep(i,X.size()){\n        if(ei.size()==0||ei.back().fi!=X[i])ei.pb({X[i],1});\n        else ei.back().se++;\n    }\n\n    int latte=0;\n    int s=0;\n    for(int i=0;i<X.size();i++){\n        if(X[i]==1){\n            latte++;\n            s++;\n        }\n        else{\n            latte+=X[i]*2-3;\n            s+=X[i]*2-3+2;\n        }\n    }\n\n    int ret=0;\n    for(int k=0;latte+k<=N;k++){\n        int y=N-latte-k;\n        add(ret,nCk(y+1,n)*nCk(s-1+k,k)%mod);\n    }\n    ret=ret*fact[n]%mod;\n    rep(i,ei.size())ret=ret*inv[ei[i].se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <string>\n#include <vector>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\n/**\n * group = 1:\n *    R\n *\n * group = 2:\n *    _B_\n *    _BR\n *    RB_\n *    RBR\n *\n * group = 4:\n *    _BRBRB_\n *    _BRBRBR\n *    RBRBRB_\n *    RBRBRBR\n */\n\nconstexpr int MOD = 1e9 + 7;\n\nbool is_constructible_sequence(int k, string const & s, vector<int> const & f) {\n    int r = 0, b = 0;  // indices, 0 <= b <= r <= f.size()\n    int q = 0;\n    for (char c : s) {\n        if (c == 'r' and r < f.size()) {\n            ++ r;\n        } else if (c == 'b' and b < r) {\n            assert (f[b] >= 2);\n            q += f[b] - 2;\n            ++ b;\n        } else if (q) {\n            -- q;\n        }\n        while (b < r and f[b] == 1) {\n            ++ b;\n        }\n    }\n    return r == f.size() and b == f.size() and not q;\n}\n\nvector<vector<int> > list_constructible_sequences(int n, int k, string const & s) {\n    vector<vector<int> > fs;\n    vector<int> f;\n    function<void (int, int)> go = [&](int used, int group) {\n        if (group == 0) {\n            if (is_constructible_sequence(k, s, f)) {\n                fs.push_back(f);\n            }\n        } else {\n            go(used, group - 1);\n            int next_used = used + (not not used) + max(1, 2 * group - 3);\n            if (next_used <= n) {\n                f.push_back(group);\n                go(next_used, group);\n                f.pop_back();\n            }\n        }\n    };\n    go(0, max(2, n));\n    return fs;\n}\n\nvoid initialize_dp(int n, vector<mint<MOD> > & cur) {\n    cur.assign(n + 1, 1);\n}\nvoid step_dp(int n, int i, int f_i, vector<mint<MOD> > const & prv, vector<mint<MOD> > & cur) {\n    cur.assign(n + 1, 0);\n    if (f_i == 1) {\n        mint<MOD> acc = 0;\n        REP (j, n) {\n            cur[j + 1] += cur[j];  // use a white ball\n            int j1 = j - (i != 0);\n            if (j1 >= 0) acc += prv[j1];\n            cur[j + 1] += acc;  // use red balls\n        }\n    } else {\n        int core = max(1, f_i * 2 - 3);\n        vector<mint<MOD> > cnt(n + 1);\n        REP3 (dj, core, n + 1) {\n            for (int size : { core, core + 1, core + 1, core + 2 }) {\n                if (dj >= size) {\n                    cnt[dj] += choose<MOD>(dj - 1, size - 1);\n                }\n            }\n        }\n        REP (j, n) {\n            cur[j + 1] += cur[j];  // use a white ball\n            REP3 (dj, core, n - j + (i == 0)) {\n                cur[j + (i != 0) + dj] += cnt[dj] * prv[j];  // use red and blue balls (after a white ball)\n            }\n        }\n    }\n}\nmint<MOD> get_dp_result(int n, vector<mint<MOD> > const & cur) {\n    return cur[n];\n}\n\nmint<MOD> count_shuffled_sequence(vector<int> const & f) {\n    mint<MOD> acc = 1;\n    for (int l = 0; l < f.size(); ) {\n        int r = l;\n        while (r < f.size() and f[l] == f[r]) ++ r;\n        acc *= choose<MOD>(r, r - l);\n        l = r;\n    }\n    return acc;\n}\n\nmint<MOD> solve(int n, int k, string const & s) {\n    mint<MOD> acc = 0;\n    auto fs = list_constructible_sequences(n, k, s);\n    assert (is_sorted(ALL(fs)));\n    auto dp = vectors(n + 1, n + 1, mint<MOD>());\n    initialize_dp(n, dp[0]);\n    vector<int> prv_f;\n    for (auto const & cur_f : fs) {\n        int i = 0;\n        while (i < prv_f.size() and i < cur_f.size() and prv_f[i] == cur_f[i]) {\n            ++ i;\n        }\n        while (i < cur_f.size()) {\n            step_dp(n, i, cur_f[i], dp[i], dp[i + 1]);\n            ++ i;\n        }\n        acc += get_dp_result(n, dp[cur_f.size()]) * count_shuffled_sequence(cur_f);\n        prv_f = cur_f;\n    }\n    return acc;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    string s; cin >> s;\n    cout << solve(n, k, s).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=1005;\nint C[maxn][maxn];\nint fac[maxn],invfac[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=1LL*fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline int comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nvi apos;\nint ca=0;\nint n,k;\nint suf[75];\nvi f;\nint solve()\n{\n    if(!f.size()) return 1;\n    int need=0;\n    int p=0;\n    for(int i=f.size()-1;i>=0;i--)\n    {\n        need+=f[p]-1;\n        if(suf[apos[i]]<need) return 0;\n        p++;\n    }\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++)\n    {\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    int ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nint dfs(int r,int mx,int cc,int len=0)\n{\n    if(len+(int)f.size()-1>n) return 0;\n    int ret=1LL*solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(f.size()>=ca) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        int cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=1LL*cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    for(int i=0;i<k;i++) \n    {\n        ca+=s[i]=='r';\n        if(s[i]=='r') apos.push_back(i);\n    }\n    for(int i=k-1;i>=0;i--)\n        suf[i]=suf[i+1]+(s[i]=='b');\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nconst int MN=70;\nconst int MK=70;\nmint Co[1000][1000];\nmint C(int a,int b){\n\tassert(0<=b&&b<=a);\n\treturn Co[a][b];\n}\nmint dp[MN+1][MN+1][MN+1]={};\t//phase, the num of component already put, the sum of len (!!excluding y as!!)\nmint calc(int N,int x,int y,vector<int> canuse){\t\t//x:the num of ab~ y:the num of a\n\trep(i,MN+1) rep(j,MN+1) rep(k,MN+1) dp[i][j][k] = 0;\n//\tprintf(\"x=%d,y=%d\\n\",x,y);\n\tif(x==0&&y==0) return 1;\n\tdp[0][0][0]=1;\t\t//put y as\n\tint I=(N+1)/2;\n\tint J=x;\n\tint S=N-2*y-x+1;\n\t// show(I);\n\t// show(J);\n\t// show(S);\n\trep(i,I){\n\t\trep(j,J+1){\n\t\t\trep(s,S+1){\n\t\t\t\tfor(int k=0;j+k<=J && s+k*(i*2+1)<=S;k++){\n\t\t\t\t\tif(k>0&&canuse[j+k-1]<(s-j)/2+i*k) break;\n\t\t\t\t\tdp[i+1][j+k][s+k*(i*2+1)]+=dp[i][j][s]*C(j+y+k,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmint ret=0;\n\trep(s,S+1){\n\t\tret+=dp[I][x][s]*C(N+2*x+1,s+3*x+2*y);\n\t}\n//\tshow(ret);\n\treturn ret;\n}\nmint solve(int N,string s){\n\trep(i,1000){\n\t\tCo[i][0]=Co[i][i]=1;\n\t\tfor(int j=1;j<i;j++) Co[i][j]=Co[i-1][j-1]+Co[i-1][j];\n\t}\n\tint K=s.size();\n\tvector<int> as;\n\trep(i,K) if(s[i]=='r') as.pb(i);\n\tmint ans=0;\n\trep(x,N+1) rep(y,N+1){\n\t\tbool used[MK]={};\n\t\tint bid[MN]={};\n\t\tbool OK=1;\n\t\tif(x+y>as.size()) continue;\n\t\trep(i,x){\n\t\t\tused[as[i]]=1;\n\t\t\tbool ok=0;\n\t\t\tfor(int j=as[i]+1;j<K;j++) if(s[j]=='b'&&!used[j]){\n\t\t\t\tbid[i]=j;\n\t\t\t\tused[j]=1;\n\t\t\t\tok=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok){\n\t\t\t\tOK=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!OK) continue;\n\t\trep(i,y) used[as[x+i]]=1;\n\t\tvector<int> lefts;\n\t\tint imos[MK+1]={};\n\t\trep(i,K) imos[i+1]=imos[i]+(!used[i]);\n\t\trep(i,x) lefts.pb(imos[K]-imos[bid[x-i-1]]);\n\t\tans+=calc(N,x,y,lefts);\n\t}\n\treturn ans;\n}\n\ntypedef vector<int> vi;\nset<vi> st,nst;\nmint brute(int N,string s){\n\tvi be(N);\n\tst.insert(be);\n\tfor(char c:s){\n\t\tint x=(c=='r'?1:2);\n\t\tfor(vi v:st){\n\t\t\trep(l,N) for(int r=l;r<N;r++){\n\t\t\t\tvi nv=v;\n\t\t\t\tbool ok=1;\n\t\t\t\tfor(int i=l;i<=r;i++){\n\t\t\t\t\tif(v[i]==0&&x==2){\n\t\t\t\t\t\tok=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnv[i]=x;\n\t\t\t\t}\n\t\t\t\tif(ok) nst.insert(nv);\n\t\t\t}\n\t\t\tnst.insert(v);\n\t\t}\n\t\tst=nst;\n\t\tnst.clear();\n\t}\n\treturn st.size();\n}\n\nint main(){\n\tint N,K;\n\tstring s;\n\tcin>>N>>K>>s;\n\n\tcout<<solve(N,s)<<endl;\n//\tshow(brute(N,s));\n}"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\ninline char safe_getc()\n{\n\tregister char ch(getc());\n\twhile(!isgraph(ch)) ch = getc();\n\treturn ch;\n}\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline int inv(int x) { assert(x); return fpm(x, MOD - 2); }\n\nnamespace MATH\n{\n\tconst int n = (int) 1e5;\n\n\tint fac[n + 5], ifac[n + 5];\n\n\tinline void init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = inv(fac[n]);\n\t\tfor(int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n\n\tinline int C(int N, int M) { return N < 0 || M < 0 || N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n}\nusing MATH::fac;\nusing MATH::ifac;\nusing MATH::C;\n\nconst int MAXN = 70;\n\nint n, K;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), K = read<int>();\n\tfor(int i = 1; i <= K; ++i) s[i] = safe_getc();\n}\n\nint a[MAXN + 5];\n\ninline int check(int N)\n{\n\tstatic int pos[MAXN + 5], vis[MAXN + 5];\n\tmemset(vis, 0, sizeof vis);\n\n\tint lstr = 0;\n\tfor(int i = 1; i <= N; ++i)\n\t{\n\t\tpos[i] = K + 1;\n\t\tfor(int j = lstr + 1; j <= K; ++j) if(s[j] == 'r' && !vis[j]) { vis[lstr = pos[i] = j] = 1; break; }\n\t\tif(pos[i] == K + 1) return 0;\n\n\t\tif(a[i] > 1)\n\t\t{\n\t\t\tfor(; pos[i] <= K; ++pos[i]) if(!vis[pos[i]] && s[pos[i]] == 'b') { vis[pos[i]] = 1; break; }\n\t\t\tif(pos[i] == K + 1) return 0;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; ++i) if(a[i] > 2)\n\t{\n\t\tint cnt = 2;\n\t\tfor(int j = pos[i] + 1; cnt < a[i] && j <= K; ++j) if(!vis[j]) vis[j] = 1, ++cnt;\n\t\tif(cnt < a[i]) return 0;\n\t}\n\n\treturn 1;\n}\n\ninline int div_into(int N, int M) { return C(N + M - 1, M - 1); }\n\ninline int calc(int N, int S)\n{\n\tint res = fac[N], M = N + 1;\n\tfor(int i = 1, j; i <= N; i = j)\n\t{\n\t\tfor(j = i; j <= N && a[j] == a[i]; ++j);\n\t\tres = (LL) res * ifac[j - i] % MOD;\n\t\tM += (a[i] * 2 - 1) * (j - i);\n\t}\n\treturn (LL) res * div_into(n - S, M) % MOD;\n}\n\nint ans = 0;\n\ninline void dfs(int k, int lst, int S)\n{\n\tif(S > n) return;\n\tif(check(k)) (ans += calc(k, S)) %= MOD;\n\n\tfor(int i = 1; i <= lst; ++i) a[k + 1] = i, dfs(k + 1, i, S + (i == 1 ? 1 : i * 2 - 3) + (k > 0));\n}\n\ninline void solve()\n{\n\tans = 0, dfs(0, n, 0);\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nstring S;\nvector<int> V;\nll mo=1000000007;\nll group[71][71];\nint ML[71];\nll fact[72],factr[72],inv[72];\n\nll comb(int P_,int Q_) {\n\tstatic const int N_=1020;\n\tstatic ll C_[N_][N_];\n\t\n\tif(C_[0][0]==0) {\n\t\tint i,j;\n\t\tFOR(i,N_) C_[i][0]=C_[i][i]=1;\n\t\tfor(i=1;i<N_;i++) for(j=1;j<i;j++) C_[i][j]=(C_[i-1][j-1]+C_[i-1][j])%mo;\n\t}\n\tif(P_<0 || P_>N_ || Q_<0 || Q_>P_) return 0;\n\treturn C_[P_][Q_];\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);};\n\nmap<string,int> M[71];\nll tot;\nvector<int> G;\n\nvoid hoge(vector<int> V,vector<ll> C) {\n\tvector<int> O=V;\n\tstring T=S;\n\tint TN=T.size(),VN=V.size();\n\tvector<int> R(VN,-1);\n\t\n\tint x=0,y=0,i;\n\tFOR(i,TN) if(T[i]=='r' && x<VN) {\n\t\tR[x]=i;\n\t\tV[x]--;\n\t\tx++;\n\t\tT[i]='_';\n\t\t\n\t}\n\tif(x!=VN) return;\n\tx=0;\n\tFOR(i,TN) if(T[i]=='b') {\n\t\tif(x<VN && V[x] && i>R[x]) {\n\t\t\tV[x]--;\n\t\t\tR[x]=i;\n\t\t\tx++;\n\t\t\tT[i]='_';\n\t\t}\n\t}\n\tif(x<VN && V[x]) return;\n\t\n\tx=0;\n\tFOR(i,TN) if(T[i]!='_') {\n\t\tif(x<VN && V[x] && i>R[x]) {\n\t\t\tV[x]--;\n\t\t\tT[i]='_';\n\t\t\tif(V[x]==0) x++;\n\t\t}\n\t}\n\tif(x<VN && V[x]) return;\n\t\n\tmap<int,int> M;\n\tFORR(c,O) M[c]++;\n\t\n\tll ret=0;\n\tFOR(x,N+1) {\n\t\tint left=N-x-(V.size()-1);\n\t\tif(left<0) break;\n\t\t(ret+=C[x]*hcomb(V.size()+1,left))%=mo;\n\t}\n\t\n\t(ret*=fact[V.size()])%=mo;\n\tFORR(m,M) (ret*=factr[m.second])%=mo;\n\t\n\t(tot+=ret)%=mo;\n}\n\nvoid dfs(int L,int cur,vector<ll> C) {\n\tif(cur==0) return;\n\t// not take cur\n\tdfs(L,cur-1,C);\n\t\n\tif(L>=ML[cur]) {\n\t\tG.push_back(cur);\n\t\tvector<ll> C2(71);\n\t\tfor(int x=0;x<=70;x++) if(C[x]) {\n\t\t\tfor(int y=ML[cur];x+y<=70;y++) {\n\t\t\t\t(C2[x+y]+=C[x]*group[cur][y])%=mo;\n\t\t\t}\n\t\t}\n\t\t\n\t\thoge(G,C2);\n\t\tdfs(L-(ML[cur]+1),cur,C2);\n\t\tG.pop_back();\n\t}\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>S;\n\t\n\tinv[1]=fact[0]=factr[0]=1;\n\tfor (int i=2;i<=70;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\tfor (int i=1;i<=70;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\tfor(i=1;i<=70;i++) group[1][i]=1;\n\tML[1]=1;\n\tfor(i=2;i<=70;i++) {\n\t\tvector<int> cand={(i-1)*2-1,(i-1)*2,(i-1)*2,(i-1)*2+1};\n\t\tML[i]=(i-1)*2-1;\n\t\tFORR(l,cand) {\n\t\t\tfor(x=l;x<=70;x++) (group[i][x]+=hcomb(l,x-l))%=mo;\n\t\t}\n\t}\n\t\n\t\n\ttot=1;\n\tvector<ll> C(71);\n\tC[0]=1;\n\tdfs(N,70,C);\n\tcout<<tot<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class U> inline void chmax(T & a, U const & b) { a = max<T>(a, b); }\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline mint<MOD> operator /  (mint<MOD> other) const { return *this *  other.inv(); }\n    inline mint<MOD> operator /= (mint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (mint<MOD> other) const { return value == other.value; }\n    inline bool operator != (mint<MOD> other) const { return value != other.value; }\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\n/**\n * group = 1:\n *    R\n *\n * group = 2:\n *    _B_\n *    _BR\n *    RB_\n *    RBR\n *\n * group = 4:\n *    _BRBRB_\n *    _BRBRBR\n *    RBRBRB_\n *    RBRBRBR\n */\n\nconstexpr int MOD = 1e9 + 7;\n\nbool is_constructible_sequence(int k, string const & s, vector<int> const & f) {\n    int r = 0, b = 0;  // indices, 0 <= b <= r <= f.size()\n    int q = 0;\n    for (char c : s) {\n        if (c == 'r' and r < f.size()) {\n            ++ r;\n        } else if (c == 'b' and b < r) {\n            assert (f[b] >= 2);\n            q += f[b] - 2;\n            ++ b;\n        } else if (q) {\n            -- q;\n        }\n        while (b < r and f[b] == 1) {\n            ++ b;\n        }\n    }\n    return r == f.size() and b == f.size() and not q;\n}\n\nmint<MOD> count_generated_patterns(int n, vector<int> const & f) {\n    auto dp = vectors(f.size() + 1, n + 1, mint<MOD>());\n    dp[0][0] = 1;\n    REP (i, f.size()) {\n        REP (j, n) {\n            dp[i][j + 1] += dp[i][j];  // use white\n            int core = max(1, f[i] * 2 - 3);\n            REP3 (dj, core, n - j + (i == 0)) {\n                mint<MOD> cnt = 0;\n                if (f[i] == 1) {\n                    cnt += 1;  // R\n                } else {\n                    for (int size : { core, core + 1, core + 1, core + 2 }) {\n                        if (dj >= size) {\n                            cnt += choose<MOD>(dj - 1, size - 1);\n                        }\n                    }\n                }\n// cerr << \"f = ( \" << f << \" ): \" << \"i = \" << i << \", j = \" << j << \": \" <<\"dj = \" << dj << \" -> cnt = \" <<cnt<<endl;\n                dp[i + 1][j + (i != 0) + dj] += cnt * dp[i][j];\n            }\n        }\n    }\n    REP (j, n) {\n        dp[f.size()][j + 1] += dp[f.size()][j];  // use white\n    }\n// REP (i, f.size() + 1) {\n// REP (j, n + 1) {\n// cerr << \"f = ( \" << f << \" ): \" <<\"dp[\" << i << \"][\"<<j<<\"] = \" << dp[i][j]  << endl;\n// }\n// }\n\n    mint<MOD> shuffle = 1;\n    for (int l = 0; l < f.size(); ) {\n        int r = l;\n        while (r < f.size() and f[l] == f[r]) ++ r;\n        shuffle *= choose<MOD>(r, r - l);\n        l = r;\n    }\n\n    return shuffle * dp[f.size()][n];\n}\n\nmint<MOD> solve(int n, int k, string const & s) {\n    mint<MOD> acc = 0;\n    vector<int> f;\n    function<void (int, int)> go = [&](int used, int group) {\n        if (group == 0) {\n            if (is_constructible_sequence(k, s, f)) {\n                acc += count_generated_patterns(n, f);\n            }\n        } else {\n            go(used, group - 1);\n            int next_used = used + (not not used) + max(1, 2 * group - 3);\n            if (next_used <= n) {\n                f.push_back(group);\n                go(next_used, group);\n                f.pop_back();\n            }\n        }\n    };\n    go(0, n);\n    return acc;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    string s; cin >> s;\n    cout << solve(n, k, s).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nint qpow(int x,int k)\n{\n    int r=1;\n    while(k)\n    {\n        if(k&1)r=1ll*r*x%mod;\n        k>>=1;x=1ll*x*x%mod;\n    }\n    return r;\n}\nint C[1010][1010];\nint fac[1010],ifac[1010];\nvoid init()\n{\n    for(int i=0;i<=1000;++i)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]);\n    }\n    fac[0]=1;\n    for(int i=1;i<=1000;++i)fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[1000]=qpow(fac[1000],mod-2);\n    for(int i=999;i>=0;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint n,m;\nint tr;\nchar s[110];\nint a[110];\nbool book[77];\nbool eb[77];\nbool check(int d)\n{\n    int cr=0,crb=0;\n    for(;a[cr+1]==1&&cr+1<=d;cr++);\n    crb=d-cr;\n    memset(book,0,sizeof(book[0])*(m+3));\n    memset(eb,0,sizeof(eb[0])*(m+3));\n    int pr=0,pb=0;\n    for(int t=1;t<=crb;++t)\n    {\n        while((s[pr]!='r'||book[pr])&&pr<=m)pr++;\n        while((s[pb]!='b'||book[pb]||pb<=pr)&&pb<=m)pb++;\n        if(pr>m||pb>m)return 0;\n        book[pr]=book[pb]=1;\n        eb[pb]=1;\n    }\n    int tcr=cr;\n    for(int i=1;i<=m&&cr;++i)\n        if(!book[i]&&s[i]=='r')cr--,book[i]=1;\n    if(cr)return 0;\n    for(int i=m,p=tcr+1,cnt=0;p<=d;--i)\n    {\n        if(!book[i])cnt++;\n        if(eb[i])\n        {\n            cnt-=a[p]-2;\n            if(cnt<0)return 0;\n            p++;\n        }\n    }\n    return 1;\n}\nint ans;\nvoid calc(int d,int l)\n{\n    int s=d+1;\n    for(int i=1;i<=d;++i)\n        if(a[i]==1)s++;\n        else s+=(a[i]-1)*2+1;\n    int res=1ll*C[n-l+s-1][s-1]*fac[d]%mod;\n    for(int i=1,j;i<=d;i=j+1)\n    {\n        for(j=i;a[j+1]==a[i]&&j<d;++j);\n        res=1ll*res*ifac[j-i+1]%mod;\n    }\n    ade(ans,res);\n}\nbool dfs(int x,int la,int len,int sl)\n{\n    if(!check(x-1))return 0;\n    if(x-1>tr)return 1;\n    calc(x-1,len);\n    int nl;\n    for(int i=la;i<=m-sl;++i)\n    {\n        a[x]=i;\n        nl=len;\n        if(x!=1)nl++;\n        if(i==1)nl++;\n        else nl+=(i-1)*2-1;\n        if(nl>n)break;\n        if(!dfs(x+1,i,nl,sl+i))break;\n    }\n    return 1;\n}\nint main()\n{\n    init();\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=m;++i)tr+=(s[i]=='r');\n    dfs(1,1,0,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 75;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[MN * 2], iFac[MN * 2];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\n\nint Len;\nchar Str[MN];\nint posr[MN], nxposb[MN], rcnt;\n\nint N, Ans;\n\nint stk[MN];\ninline void Calc(int cnt, int csum) {\n\tint Sum = 0;\n\tif (!cnt) Sum = 1;\n\telse if (cnt <= rcnt) {\n\t\tstatic int vis[MN];\n\t\tfor (int i = 1; i <= cnt; ++i) vis[i] = posr[i];\n\t\tint tot = cnt, mxp = 1;\n\t\tfor (int i = 1; i <= cnt && stk[i] >= 2; ++i)\n\t\t\tmxp = vis[++tot] = nxposb[std::max(mxp, vis[i])];\n\t\tif (mxp <= Len) {\n\t\t\tstd::inplace_merge(vis + 1, vis + cnt + 1, vis + tot + 1);\n\t\t\tint nwp = Len + 1, sum = 0, now = cnt, ok = 1;\n\t\t\twhile (now && stk[now] == 1) --now;\n\t\t\tfor (int i = tot; i >= 1; --i) {\n\t\t\t\tsum += nwp - vis[i] - 1;\n\t\t\t\tif (Str[vis[i]] == 'b') {\n\t\t\t\t\tsum -= stk[now] - 2;\n\t\t\t\t\tif (sum < 0) { ok = 0; break; }\n\t\t\t\t\t--now;\n\t\t\t\t}\n\t\t\t\tnwp = vis[i];\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tSum = Fac[cnt];\n\t\t\t\tint len = 0, num = 1;\n\t\t\t\tfor (int i = 1; i <= cnt; ++i) {\n\t\t\t\t\t++len;\n\t\t\t\t\tnum += stk[i] * 2;\n\t\t\t\t\tif (i == cnt || stk[i] != stk[i + 1]) {\n\t\t\t\t\t\tSum = (LL)Sum * iFac[len] % Mod;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSum = (LL)Sum * Fac[N - csum + num] % Mod * iFac[num - 1] % Mod * iFac[N - csum + 1] % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tAns -= (Ans += Sum) >= Mod ? Mod : 0;\n}\nvoid DFS(int st, int mx, int sum) {\n\tCalc(st - 1, sum);\n\tif (sum < N) {\n\t\tstk[st] = 1;\n\t\tDFS(st + 1, 1, sum + 2);\n\t}\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (sum + i * 2 <= N + 3) {\n\t\t\tstk[st] = i;\n\t\t\tDFS(st + 1, i, sum + i * 2 - 2);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &Len, Str + 1);\n\tInit(N * 2 + 2);\n\tfor (int i = 1; i <= Len; ++i)\n\t\tif (Str[i] == 'r')\n\t\t\tposr[++rcnt] = i;\n\tint nwposb = Len + 1;\n\tnxposb[Len + 1] = Len + 1;\n\tfor (int i = Len; i >= 1; --i) {\n\t\tnxposb[i] = nwposb;\n\t\tif (Str[i] == 'b')\n\t\t\tnwposb = i;\n\t}\n\tDFS(1, (N + 3) / 2, 0);\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class U> inline void chmax(T & a, U const & b) { a = max<T>(a, b); }\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline mint<MOD> operator /  (mint<MOD> other) const { return *this *  other.inv(); }\n    inline mint<MOD> operator /= (mint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (mint<MOD> other) const { return value == other.value; }\n    inline bool operator != (mint<MOD> other) const { return value != other.value; }\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\n/**\n * group = 1:\n *    R\n *\n * group = 2:\n *    _B_\n *    _BR\n *    RB_\n *    RBR\n *\n * group = 4:\n *    _BRBRB_\n *    _BRBRBR\n *    RBRBRB_\n *    RBRBRBR\n */\n\nconstexpr int MOD = 1e9 + 7;\n\nbool is_constructible_sequence(int k, string const & s, vector<int> const & f) {\n    int r = 0, b = 0;  // indices, 0 <= b <= r <= f.size()\n    int q = 0;\n    for (char c : s) {\n        if (c == 'r' and r < f.size()) {\n            ++ r;\n        } else if (c == 'b' and b < r) {\n            assert (f[b] >= 2);\n            q += f[b] - 2;\n            ++ b;\n        } else if (q) {\n            -- q;\n        }\n        while (b < r and f[b] == 1) {\n            ++ b;\n        }\n    }\n    return r == f.size() and b == f.size() and not q;\n}\n\nvector<vector<int> > list_constructible_sequences(int n, int k, string const & s) {\n    vector<vector<int> > fs;\n    vector<int> f;\n    function<void (int, int)> go = [&](int used, int group) {\n        if (group == 0) {\n            if (is_constructible_sequence(k, s, f)) {\n                fs.push_back(f);\n            }\n        } else {\n            go(used, group - 1);\n            int next_used = used + (not not used) + max(1, 2 * group - 3);\n            if (next_used <= n) {\n                f.push_back(group);\n                go(next_used, group);\n                f.pop_back();\n            }\n        }\n    };\n    go(0, max(2, n));\n    return fs;\n}\n\nvoid initialize_dp(int n, vector<mint<MOD> > & cur) {\n    cur.assign(n + 1, 1);\n}\nvoid step_dp(int n, int i, int f_i, vector<mint<MOD> > const & prv, vector<mint<MOD> > & cur) {\n    cur.assign(n + 1, 0);\n    REP (j, n) {\n        cur[j + 1] += cur[j];  // use a white ball\n        int core = max(1, f_i * 2 - 3);\n        REP3 (dj, core, n - j + (i == 0)) {\n            mint<MOD> cnt = 0;\n            if (f_i == 1) {\n                cnt += 1;\n            } else {\n                for (int size : { core, core + 1, core + 1, core + 2 }) {\n                    if (dj >= size) {\n                        cnt += choose<MOD>(dj - 1, size - 1);\n                    }\n                }\n            }\n            cur[j + (i != 0) + dj] += cnt * prv[j];  // use red and blue balls (after a white ball)\n        }\n    }\n}\nmint<MOD> get_dp_result(int n, vector<mint<MOD> > const & cur) {\n    return cur[n];\n}\n\nmint<MOD> count_shuffled_sequence(vector<int> const & f) {\n    mint<MOD> acc = 1;\n    for (int l = 0; l < f.size(); ) {\n        int r = l;\n        while (r < f.size() and f[l] == f[r]) ++ r;\n        acc *= choose<MOD>(r, r - l);\n        l = r;\n    }\n    return acc;\n}\n\nmint<MOD> solve(int n, int k, string const & s) {\n    mint<MOD> acc = 0;\n    auto fs = list_constructible_sequences(n, k, s);\n    sort(ALL(fs));\n    auto dp = vectors(n + 1, n + 1, mint<MOD>());\n    initialize_dp(n, dp[0]);\n    vector<int> prv_f;\n    for (auto const & cur_f : fs) {\n        int i = 0;\n        while (i < prv_f.size() and i < cur_f.size() and prv_f[i] == cur_f[i]) {\n            ++ i;\n        }\n        while (i < cur_f.size()) {\n            step_dp(n, i, cur_f[i], dp[i], dp[i + 1]);\n            ++ i;\n        }\n        acc += get_dp_result(n, dp[cur_f.size()]) * count_shuffled_sequence(cur_f);\n        prv_f = cur_f;\n    }\n    return acc;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    string s; cin >> s;\n    cout << solve(n, k, s).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nint dp[111][111];\n\nint calc(){\n    /*\n    if(X[0]==1){\n        if(X.size()>R)return 0;\n        int n=X.size();\n        int y=N-(2*n+1);\n        return nCk(2*n+y,y);\n    }*/\n    int n=X.size();\n    if(n>R)return 0;\n    int nr=R-n,nb=B;\n    for(int i=0;i<X.size();i++){\n        int pos=r[R-i];\n        while(nb>0&&b[nb]<pos)nb--;\n        if(X[i]==1)continue;\n        if(nb==0)return 0;\n        while(nr>0&&r[nr]<b[nb])nr--;\n        nb--;\n        rep(t,X[i]-2){\n            if(i+1<n&&nb&&b[nb]<r[R-i-1]){\n                nb--;\n                continue;\n            }\n            if(nr){\n                nr--;\n                continue;\n            }\n            if(nb){\n                nb--;\n                continue;\n            }\n            return 0;\n        }\n    }\n\n\n    rep(i,n+1)rep(j,N+1)dp[i][j]=0;\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<N;j++){\n            if(X[i]==1){\n                for(int k=1;j+k<=N;k++)add(dp[i+1][j+k],dp[i][j]);\n            }\n            else{\n                for(int k=0;2*X[i]-3+k+j<=N;k++){\n                    add(dp[i+1][j+2*X[i]-3+k],dp[i][j]*nCk(2*X[i]-2+k,k)%mod);\n                }\n            }\n        }\n    }\n\n    int ret=0;\n    for(int i=0;i<=N;i++){\n        add(ret,dp[n][i]*nCk(N-i+1,n)%mod);\n    }\n\n    ret=ret*fact[n]%mod;\n    map<int,int>cnt;\n    rep(i,n)cnt[X[i]]++;\n    for(auto p:cnt)ret=ret*inv[p.se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n    \n    if(N>30||K>30)return 0;\n\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=750;\nint C[N][N],n,k,ans;\nint used[N],q1[N],q2[N];\nint suf[N],a[N];\nchar s[N];\nvoid init(){\n\tFor(i,0,N-1) C[i][0]=1;\n\tFor(i,1,N-1) For(j,1,i)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;\n}\nvoid solve(int S){\n\tif (!S) return ++ans,void(0);\n\tmemset(used,0,sizeof(used));\n\tint rest=S-a[1],h=0,t=*q2=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r') q1[++t]=i;\n\t\telse if (s[i]=='b'&&h!=t&&*q2!=rest)\n\t\t\tused[q1[++h]]=used[i]=1,q2[++*q2]=i;\n\t//printf(\"%d %d %d\\n\",rest,*q2,ans);\n\t//For(i,1,n) printf(\"%d \",a[i]); puts(\"\");\n\tif (*q2!=rest) return;\n\tFor(i,1,a[1])\n\t\tif (h==t) return;\n\t\telse used[q1[++h]]=1;\n\t//printf(\"%d %d %d\\n\",rest,*q2,ans);\n\t//For(i,1,n) printf(\"%d \",a[i]); puts(\"\");\n\tRep(i,k,1) suf[i]=suf[i+1]+(!used[i]);\n\tFor(i,1,S-a[1]) q2[i]=suf[q2[i]];\n\tint posi=S-a[1],sum=0,par=0;\n\tFor(i,2,n) For(j,1,a[i]){\n\t\tsum+=i-2;\n\t\tif (sum>q2[posi]) return;\n\t\t--posi; \n\t}\n\tint v=1,s=a[1];\n\tsum=a[1]+S-1;\n\tpar=S+1+a[1];\n\tFor(i,2,n){\n\t\tv=1ll*v*C[s+a[i]][s]%mo;\n\t\tsum+=a[i]*(2*i-3);\n\t\tpar+=a[i]*(2*i-1);\n\t\ts+=a[i]; \n\t}\n\tif (sum>n) return;\n\t//printf(\"%d %d %d\\n\",sum,par,v);\n\tv=1ll*v*C[n-sum+par-1][par-1]%mo;\n\tans=(ans+v)%mo;\n}\n/*\n\n*/\nvoid dfs(int x,int xx,int y,int S){\n\tif (y>x||2*max(y-1,1)>xx) return solve(S);\n\tfor (a[y]=0;x>=0&&xx>=0;++a[y],++S)\n\t\tdfs(x,xx,y+1,S),x-=y,xx-=2*max(y-1,1);\n\ta[y]=0;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tdfs(k,n+1,1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\nint ts = 0;\nvoid calc(int sz) {\n    ts++;\n    int tb = 0, tr = 0;\n    int used[77], TR[77], TB[77];\n    memset(used, 0, sizeof used);\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        used[tr] = 1;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && (ch[tb] != 'b' || used[tb])) tb++;\n            used[tb] = 1;\n            TR[i] = tr;\n            TB[i] = tb;\n        } else {\n            TR[i] = tr;\n            TB[i] = tr;\n        }\n        if(tr > K || tb > K) return;\n    }\n    for(int i = 1; i <= sz; i++) {\n        int tt = TB[i] + 1;\n        for(int j = 1; j <= X[i] - 2; j++) {\n            while(tt <= K && used[tt]) tt++;\n            if(tt > K) return;\n        }\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tot = 0) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K && max(2ll, i * 2 - 2) + tot <= n + 3; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tot + max(2ll, i * 2 - 2));\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    //printf(\"%d\\n\", ts);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n} c(150);\n\nmint res;\nint n,k;\nstring s;\nbool trk[77];\nint8_t pos[77];\nint8_t cnt[77];\n\nbool check(const vector<int>& ip, int sum) {\n    memset(trk, 0, sizeof trk);\n    memset(pos, -1, sizeof pos);\n    int m = ip.size();\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = 0; j < k; j++) {\n            if (s[j]=='r' && !trk[j]) {\n                pos[i] = j; trk[j] = true;\n                break;\n            }\n        }\n        if (pos[i] == -1) return false;\n    }\n    memset(cnt, 1, sizeof cnt);\n    for (int i = m-1; i >= 0; i--) {\n        if (ip[i] == 1) continue;\n        for (int j = pos[i]+1; j < k; j++) {\n            if (s[j]=='b' && !trk[j]) {\n                cnt[i]++;\n                pos[i]=j; trk[j] = true;\n                break;\n            }\n        }\n        if (cnt[i] != 2) return false;\n    }\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = pos[i]+1; ip[i] > cnt[i] && j < k; j++) {\n            if (!trk[j]) {\n                cnt[i]++;\n                pos[i] = j; trk[j] = true;\n            }\n        }\n        //cout << i << ','<<cnt[i]<<'\\n';\n        if (ip[i] != (int)cnt[i]) return false;\n    }\n    \n    mint coeff = c.fac[m];\n    int las = 0, len = 0;\n    for (const int& x: ip) {\n        if (x == las) len++;\n        else {\n            coeff *= c.ifac[len];\n            len = 1;\n            las = x;\n        }\n    }coeff *= c.ifac[len];\n\n    int zero = 0;\n    zero += 2;\n    for (const int& x: ip) {\n        if (x > 1) zero+=2;\n    }\n\n    if (sum == 0) {\n        res += 1; return true;\n    }\n    //dbg(ip, sum);\n    //cout << coeff << '\\n';\n    res += c.p(n+zero, sum+zero) * coeff;\n    //cout << res << \"\\n\";\n    return true;\n}\n\nvoid dfs(vector<int>& ip, int sum) {\n    check(ip, sum);\n    //dbg(ip);\n    int sta = ip.empty()? 1 : ip.back();\n    for (int i = sta; i <= n; i++) {\n        int nex_sum = sum + max(2*i-3, 1) + (ip.empty()?0:1);\n        if (nex_sum > n) break;\n        ip.emplace_back(i);\n        dfs(ip, nex_sum);\n        ip.pop_back();\n    }\n}\n\nvoid solve() {\n    cin >> n >> k;\n    cin >> s;\n    vector<int> ip;\n    dfs(ip, 0);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nint n,k;\nchar s[110];\nint nxt[110][2];\nint fac[210],inv[210];\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(long long)ans*t%Mod;\n\t\tt=(long long)t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tint N=200;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=(long long)inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\treturn (long long)fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint ans;\nint f[110],g[110],h[110];\nbool vis[110];\nvoid calc(int num)\n{\n\t//check\n\tfor(int i=1;i<=k;i++)\n\t\tvis[i]=false;\n\tint cur=nxt[1][0],cnt=0;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1&&cnt==0)\n\t\t\tcnt=num-i+1;\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;h[i]=cur;\n\t\tcur=nxt[cur+1][0];\n\t}\n\tcur=nxt[1][1];\n\tfor(int i=1;i<=num-cnt;i++)\n\t{\n\t\twhile(cur<=k&&(cur<h[i]||vis[cur]))\n\t\t\tcur=nxt[cur+1][1];\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;\n\t\tg[i]=cur;\n\t}\n\tint now=num-cnt;\n\tcur=f[now];\n\twhile(cur<=2&&now>0){\n\t\tnow--;\n\t\tcur=f[now];\n\t}\n\tfor(int i=k;i>=1;i--)\n\t\tif(!vis[i]){\n\t\t\tif(now<=0)break;\n\t\t\tif(i<g[i])return ;\n\t\t\tvis[i]=true;\n\t\t\tcur--;\n\t\t\twhile(cur<=2&&now>0){\n\t\t\t\tnow--;\n\t\t\t\tcur=f[now];\n\t\t\t}\n\t\t}\n\tif(now>0)return ;\n\tint sum=fac[num];cur=0;\n\tint cntb=0,cntr=0,cntw=num-1;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1)cntr++;\n\t\telse cntr+=f[i]-2,cntb+=f[i]-1;\n\t\tif(i==1||f[i]==f[i-1])cur++;\n\t\telse{\n\t\t\tsum=(long long)sum*inv[cur]%Mod;\n\t\t\tcur=1;\n\t\t}\n\t}\n\tsum=(long long)sum*inv[cur]%Mod;\n\tint cntB=(num-cnt)*2+1;//rbr->2(num-cnt)  ...rw->1\n\tif(cntb+cntr+cntw>n)return ;\n\tsum=(long long)sum*C(n+cntB,cntb+cntr+cntw+cntB)%Mod;\n//\tfor(int i=1;i<=num;i++)\n//\t\tprintf(\"%d \",f[i]);\n//\tprintf(\":%d\\n\",sum);\n\tans=(ans+sum)%Mod;\n\treturn ;\n}\nvoid dfs(int x,int rest,int cnt)\n{\n\tif(rest<0)return ;\n\tif(x==0){\n\t\tcalc(cnt);\n\t\treturn ;\n\t}\n\tfor(int i=0;i*x<=rest;i++)\n\t{\n\t\tif(i>0)f[cnt+i]=x;\n\t\tdfs(x-1,rest-i*(x==1?1:(2*x-3)),cnt+i);\n\t}\n\treturn ;\n}\nint main()\n{\n//\tf[1]=2;\n//\tcalc(2);\n//\tprintf(\"%d\\n\",ans);\n\t\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tnxt[k+1][0]=nxt[k+1][1]=k+1;\n\tfor(int i=k;i>=1;i--)\n\t{\n\t\tnxt[i][0]=nxt[i+1][0];\n\t\tnxt[i][1]=nxt[i+1][1];\n\t\tif(s[i]=='r')nxt[i][0]=i;\n\t\telse nxt[i][1]=i;\n\t}\n\tinit();\n\tdfs(k,k,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000, mod = 1e9 + 7;\nint N, k, tot, ans, fac[maxn + 10], ifac[maxn + 10], inv[maxn + 10];\nint a[100], pos[100], cnt[100];\nchar s[100];\nbool vis[100];\n\nvoid solve(int n) {\n\tmemset(vis, 0, sizeof vis);\n\tfor (int i = 1, p = 1; i <= n; ++i) {\n\t\tfor (; p <= k && s[p] != 'r'; ++p);\n\t\tif (p > k) return;\n\t\tvis[p] = 1;\n\t\tpos[i] = p++;\n\t}\n\tfor (int i = 1, p = 1; i <= n; ++i)\n\t\tif (a[i] >= 2) {\n\t\t\tfor (; p <= k && (p <= pos[i] || s[p] != 'b'); ++p);\n\t\t\tif (p > k) return;\n\t\t\tvis[p] = 1; pos[i] = p++;\n\t\t}\n\tfor (int i = 1, p = 1; i <= n; ++i)\n\t\tif (a[i] >= 3)\n\t\t\tfor (int j = 1; j <= a[i] - 2; ++j) {\n\t\t\t\tfor (; p <= k && (p <= pos[i] || vis[p]); ++p);\n\t\t\t\tif (p > k) return;\n\t\t\t\t++p;\n\t\t\t}\n\tint ans = fac[n];\n\tmemset(cnt, 0, sizeof cnt);\n\tfor (int i = 1; i <= n; ++i)\n\t\t++cnt[a[i]];\n\tfor (int i = 1; i <= N; ++i)\n\t\tif (cnt[i])\n\t\t\tans = 1ll * ans * ifac[cnt[i]] % mod;\n\tint x = N + 1, y = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (a[i] >= 2) x += 2;\n\t\ty += a[i] * 2;\n\t}\n\tif (x < y) return;\n\tans = 1ll * ans * fac[x] % mod;\n\tans = 1ll * ans * ifac[y] % mod;\n\tans = 1ll * ans * ifac[x - y] % mod;\n\t(tot += ans) %= mod;\n}\n\nvoid dfs(int p, int l, int mx) {\n\tsolve(p - 1);\n\tfor (int i = mx; i >= 1; --i)\n\t\tif (max(i * 2 - 3, 1) <= l) {\n\t\t\ta[p] = i;\n\t\t\tdfs(p + 1, l - max(i * 2 - 3, 1), i);\n\t\t}\n}\n\nint main() {\n\tfac[0] = ifac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = i == 1 ? 1 : mod - 1ll * (mod / i) * inv[mod % i] % mod;\n\t\tifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n\t}\n\tscanf(\"%d%d\", &N, &k);\n\tscanf(\"%s\", s + 1);\n\tdfs(1, N, N);\n\tprintf(\"%d\", tot);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(max(p + 2*g, p + 2) > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(vector<int> &f) {\n    vector<int> used(K, 0);\n    vector<pii> bpos;\n\n    int pos1 = 0, pos2 = 0;\n    for(int i = (int)f.size() - 1; i >= 0; i--) {\n        if(f[i] == 0) continue;\n\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        bpos.push_back(pii(pos2, f[i] - 1));\n\n        used[pos1] = 1;\n        used[pos2] = 1;\n\n        pos1++;\n        pos2++;\n    }\n    for(int i = (int)bpos.size() - 1; i >= 0; i--) {\n        int need = bpos[i].second;\n        int pos = bpos[i].first;\n\n        for(int j = pos + 1; j < K; j++) {\n            if(need == 0) break;\n            if(!used[j]) {\n                need--;\n                used[j] = 1;\n            }\n        }\n        if(need) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + 2*f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        if(chk(f)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <queue>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\nconst int Max_N(75);\nconst int Max_K(75);\nconst int MOD(1000000000 + 7);\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nvoid exgcd(int a, int b, int &x, int &y)\n{\n\tif (b == 0)\n\t\tx = 1, y = 0;\n\telse\n\t\texgcd(b, a % b, y, x), y -= x * (a / b);\n}\n\ninline int inverse(int a)\n{\n\tint invx, invy;\n\texgcd(a, MOD, invx, invy);\n\treturn (invx % MOD + MOD) % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nint N, K, Ans, All[Max_N], Cnt[Max_N], Fac[1001], Inv[1001];\nchar S[Max_K];\n\nbool check()\n{\n\tqueue<int> Q;\n\tint satisfy(0), need(0);\n\tfor (int i = 1;i <= K;++i)\n\t\tif (S[i] == 'r' && satisfy < All[0])\n\t\t{\n\t\t\tif (All[++satisfy])\n\t\t\t\tQ.push(All[satisfy] - 1);\n\t\t}\n\t\telse\n\t\t\tif (S[i] == 'b' && Q.empty() == false)\n\t\t\t\tneed += Q.front(), Q.pop();\n\t\t\telse\n\t\t\t\tneed = max(0, need - 1);\n\treturn satisfy == All[0] && Q.empty() && need == 0;\n}\n\nint F[2][Max_N];\n\ninline int Com(int n, int m)\n{\n\treturn 0 <= m && m <= n ? Mult(Fac[n], Mult(Inv[m], Inv[n - m])) : 0;\n}\n\nint calc()\n{\n\tmemset(Cnt, 0, sizeof(Cnt));\n\tint Ret(Fac[All[0]]);\n\tfor (int i = 1;i <= All[0];++i)\n\t\t++Cnt[All[i]];\n\tfor (int i = 0;i <= N;++i)\n\t\tRet = Mult(Ret, Inv[Cnt[i]]);\n\tint can_0(2), other(0);\n\tfor (int i = 1;i <= All[0];++i)\n\t{\n\t\tif (i + 1 <= All[0])\n\t\t\t++other;\n\t\tif (All[i] == 0)\n\t\t\t++other;\n\t\telse\n\t\t\tcan_0 += 2, other += (All[i] - 1) + All[i];\n\t}\n\treturn Mult(Ret, Com(N + can_0 - 1, can_0 + other - 1));\n}\n\nvoid dfs(int last, int less)\n{\n\tif (All[0])\n\t\tif (check())\n\t\t\tupd(Ans, calc());\n\t\telse\n\t\t\treturn;\n\tfor (int n = last, _less;n >= 0;--n)\n\t{\n\t\tif ((_less = less + (n == 0 ? 1 : n + (n - 1)) + (All[0] != 0)) > N)\n\t\t\tcontinue;\n\t\tAll[++All[0]] = n, dfs(n, _less), --All[0];\n\t}\n}\n\nint main()\n{\n\tFac[0] = 1;\n\tfor (int i = 1;i <= 1000;++i)\n\t\tFac[i] = Mult(Fac[i - 1], i);\n\tInv[1000] = inverse(Fac[1000]);\n\tfor (int i = 1000 - 1;i >= 0;--i)\n\t\tInv[i] = Mult(Inv[i + 1], i + 1);\n\tscanf(\"%d%d\", &N, &K);\n\tscanf(\"%s\", S + 1);\n\tAns = 1, dfs(N, 0), printf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n//\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep(i,1,a){\n\t\tint mn=inf;\n\t\trep(j,2,b){\n\t\t\tint diff=d[i][j]-d[i][j-1];\n\t\t\tif(diff<0||diff>mn) return puts(\"Impossible\"),0;\n\t\t\tmn=diff;\n\t\t}\n\t}\n\trep(j,1,b){\n\t\tint mn=inf;\n\t\trep(i,2,a){\n\t\t\tint diff=d[i][j]-d[i-1][j];\n\t\t\tif(diff<0||diff>mn) return puts(\"Impossible\"),0;\n\t\t\tmn=diff;\n\t\t}\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,102,200) add(i,i-1,inf+2);\n\trep(i,1,a){\n\t\trep(j,1,b){\n\t\t\tint kx=(i==a?0:d[i+1][j]-d[i][j]);\n\t\t\tint ky=(j==b?0:d[i][j+1]-d[i][j]);\n\t\t\tint idx=(!kx?s:kx),idy=(!ky?t:100+ky);\n\t\t\tint val=d[i][j]-kx*i-ky*j;\n\t\t\tadd(idx,idy,val);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"201 202\\n\");\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 610\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint fac[N],inv[N],a[N],ans,n,k,r[N],b[N];\nchar ch[N]; bool vis[N];\nvoid init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[N-1]=ksm(fac[N-1],mdn-2);\n\tfor(int i=N-1;i;i--)\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%mdn*inv[n-m]%mdn;}\nint solve(int tot,int dat)\n{\n\tint cur=fac[tot],cnt=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(a[i]==a[i-1])\tcnt++;\n\t\telse\tcur=1ll*cur*inv[cnt]%mdn,cnt=1;\n\t}\n\tcur=1ll*cur*inv[cnt]%mdn;\n\tint pt=1; memset(vis,0,n+1);\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='r')\n\t\tif(pt<=tot)\tr[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot)\treturn 0; pt=1;\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='b')\n\t\tif(pt<=tot&&r[pt]<i&&a[pt]>=2)\tb[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot&&a[pt]>=2)\treturn 0; pt=1; int qwq=a[pt]-2;\n\tfor(int i=1;i<=k;i++)\tif(!vis[i])\n\t\tif(pt<=tot&&b[pt]<i&&qwq>0)\n\t\t{\n\t\t\tqwq--; if(!qwq)\tpt++,qwq=a[pt]-2;\n\t\t}\n\tif(qwq>0)\treturn 0;\n\treturn 1ll*dat*cur%mdn;\n}\nvoid dfs(int val,int x,int ful,int wei)\n{\n\tif(ful<wei)\treturn;\n\tif(!val)\treturn upd(ans,solve(x-1,C(ful,wei)));\n\tfor(int i=1;i<=min(val,a[x-1]);i++)\ta[x]=i,dfs(val-i,x+1,ful+(i>=2?2:0),wei+2*i);\n}\nint main()\n{\n\tn=read(),k=read(); init();\n\tscanf(\"%s\",ch+1); a[0]=n+1; int flag=0;\n\tfor(int i=2;i<=k;i++)\tif(ch[i]=='b'&&ch[i-1]=='r')\tflag=1;\n\tif(n==1)\treturn puts(!k?\"1\":flag?\"3\":\"2\"),0; \n\tfor(int i=1;i<=n;i++)\tdfs(i,1,n+1,0);\n\tprintf(\"%d\\n\",(ans+1)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=233;\nconst int mod=1e9+7;\nint n,k,inv[N],jc[N],jcn[N],a[N],ans;\nchar str[N];\nint C(int x,int y){\n\treturn 1ll*jc[x]*jcn[y]%mod*jcn[x-y]%mod;\n}\nint cal(int x,int y){\n\treturn C(x+y-1,y-1);\n}\nvoid check(int y,int z){\n\tint cnt_r=0,cnt_b=0,cnt=0;\n\tfor(int i=1;i<=k;++i)\n\t\tif(str[i]=='r'&&cnt_r<y)\n\t\t\t++cnt_r,cnt_b+=(a[cnt_r]>1),cnt+=max(a[cnt_r]-2,0);\n\t\telse if(str[i]=='b'&&cnt_b)\n\t\t\t--cnt_b;\n\t\telse if(cnt)\n\t\t\t--cnt;\n\tif(cnt_r<y||cnt_b||cnt)return;\n\tint pos=y+1,res=jc[y];\n\tfor(int i=1,j=1;i<=y;i=j=j+1){\n\t\twhile(j<y&&a[j+1]==a[i])++j;\n\t\tres=1ll*res*jcn[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(a[i]+a[i]-1);\n\t}\n\tans=(ans+1ll*res*cal(n-z,pos))%mod;\n}\nvoid dfs(int x,int y,int z){\n\tif(z>n)return;check(y,z);\n\tfor(int i=x;i;--i)a[y+1]=i,dfs(i,y+1,z+(y>0)+(i>1?i+i-3:1));\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,str+1);\n\tjc[0]=jcn[0]=inv[1]=1;\n\tfor(int i=2;i<N;++i)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=1;i<N;++i)jc[i]=1ll*jc[i-1]*i%mod,jcn[i]=1ll*jcn[i-1]*inv[i]%mod;\n\tdfs(70,0,0);printf(\"%d\\n\",ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=75,mod=1e9+7;\nint n,k,a[N],use[N],posr[N],posb[N],fac[N],ifac[N],c[N*3][N*3],Ans;\nchar s[N];\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x; \n}\ninline int C(ri n,ri m){\n\treturn m<0||n<m?0:c[n][m];\n}\ninline void solve(ri cnt){\n\tri i,now,res;\n\tfor(i=1;i<=k;++i) use[i]=0;\n\tfor(i=1;i<=cnt;++i) posr[i]=posb[i]=0;\n\tnow=0;\n\tfor(i=1;i<=k&&now<cnt;++i)\n\t\tif(s[i]=='r') use[i]=1,posr[++now]=i;\n\tif(now<cnt) return;\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=2;++i){\n\t\tfor(now=max(now,posr[i]+1);now<=k&&s[now]!='b';++now);\n\t\tif(now>k) return;\n\t\tposb[i]=now;\n\t\tuse[now]=1;\n\t\t++now;\n\t}\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=3;++i){\n\t\tres=a[i]-2;\n\t\tfor(now=max(now,posb[i]+1);now<=k&&res;++now)\n\t\t\tif(!use[now])\n\t\t\t\tuse[now]=1,--res;\n\t\tif(res) return;\n\t}\n\t\n\tri j,ans=fac[cnt],c1,c2;\n\tfor(i=1;i<=cnt;i=j+1){\n\t\tfor(j=i;j+1<=cnt&&a[j+1]==a[i];++j);\n\t\tans=(ll)ans*ifac[j-i+1]%mod;\n\t}\n\tc1=n+1;\n\tc2=0;\n\tfor(i=1;i<=cnt;++i){\n\t\tif(a[i]>=2)\n\t\t\tc1+=2;\n\t\tc2+=a[i]*2;\n\t} \n\tans=(ll)ans*C(c1,c2)%mod; \n\tadd(Ans,ans);\n}\ninline void dfs(ri i,ri sum){\n\tif(i>1) solve(i-1);\n\tfor(ri j=a[i-1];j;--j)\n\t\tif(sum+j*2-(j>=2?2:0)<=n+1)\n\t\t\tdfs(i+1,sum+j*2-(j>=2?2:0));\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tri i,j,m;\n\tfac[0]=1;\n\tfor(i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=fpow(fac[n],mod-2);\n\tfor(i=n;i;--i) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tm=3*n+1;\n\tfor(i=0;i<=m;++i){\n\t\tc[i][0]=1;\n\t\tfor(j=1;j<=i;++j)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n\ta[0]=m;Ans=1;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int mod=1e9+7;\nconst int maxn=400;\n\nint C[maxn][maxn],jc[maxn],jcn[maxn],inv[maxn];\n\nint n,k;\nchar str[maxn];\n\nint len;\nint rk[maxn],tp;\n\ninline void init()\n{\n\tC[0][0]=1; REP(i,1,300)REP(j,0,i)C[i][j]=(C[i-1][j]+(j?C[i-1][j-1]:0))%mod;\n\tjc[0]=jc[1]=jcn[0]=jcn[1]=inv[1]=1;\n\tREP(i,2,300)jc[i]=(ll)i*jc[i-1]%mod,inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod,jcn[i]=(ll)jcn[i-1]*inv[i]%mod;\n\tn=read();k=read(); len=n+1>>1;\n\tscanf(\"%s\",str+1);\n\tREP(i,1,k)if(str[i]=='r')rk[++tp]=i;\n}\n\nint p[maxn];\nint tot;\nint wp[maxn],B[maxn];\n\ninline bool check()\n{\n\tstatic int vis[maxn];\n\tmemset(vis,0,sizeof(int)*(k+1));\n\n\tint now=0,num=0;\n\tDREP(i,tot,0)num+=p[i];\n\tif(num>tp)return 0;\n\tREP(i,1,num)vis[rk[i]]=1;\n\n\tint it=1;\n\tDREP(i,tot,0)\n\t{\n\t\tREP(j,1,p[i])\n\t\t{\n\t\t\tint x=rk[++now];\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\twhile(it<=k && (it<=x || vis[it] || str[it]=='r'))++it;\n\t\t\t\tif(it>k)return 0;\n\t\t\t\tvis[it]=1;\n\t\t\t}\n\t\t}\n\t}\n\n\tnow=0;\n\tit=1;\n\tDREP(i,tot,0)\n\t{\n\t\t//REP(j,1,p[i])\n\t\tint NUM=p[i];\n\t\twhile(NUM--)\n\t\t{\n\t\t\tint x=rk[++now];\n\t\t\tint tim=i-1;\n\t\t\tif(i>=2)\n\t\t\t{\n\t\t\t\twhile(tim--)\n\t\t\t\t{\n\t\t\t\t\twhile(it<=k && (it<=x || vis[it] ))++it;\n\t\t\t\t\tif(it>k)return 0;\n\t\t\t\t\tvis[it]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint ans;\n\nvoid dfs(int u,int num,int s,int wz,int N,int pro)\n{\n\tif(u==-1)\n\t{\n\t\tpro=(ll)pro*jc[num]%mod;\n\t\twz++; N+=2;\n\t\t//DREP(i,len,0)pro=(ll)pro*jcn[p[i]]%mod;\n\t\tans=(ans+(ll)pro*C[N-1][wz-1])%mod;\n\t\treturn;\n\t}\n\t//int ad=u%4==0?2:u%4==1?0:1;\n\tREP(j,0,(n-s+1)/(wp[u]+1))\n\t{\n\t\tp[u]=j;\n\t\tif(num+j<=tp && check())\n\t\t\tdfs(u-1,num+j,s+j*wp[u]+j,wz+wp[u]*j+j+(u>0?2*j:0),N+(u>0?2*j:0),(ll)pro*jcn[j]%mod);\n\t\tp[u]=0;\n\t}\n}\n\ninline void doing()\n{\n\twp[0]=1;\n\tREP(i,1,len)\n\t{\n\t\twp[++tot]=i*2-1; B[tot]=i;\n\t}\n\tdfs(tot,0,0,0,n,1);\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,K;\nstring S;\nvector<int> V;\nll mo=1000000007;\nll group[71][71];\nint ML[71];\nll fact[72],factr[72],inv[72];\n\nll comb(int P_,int Q_) {\n\tstatic const int N_=1020;\n\tstatic ll C_[N_][N_];\n\t\n\tif(C_[0][0]==0) {\n\t\tint i,j;\n\t\tFOR(i,N_) C_[i][0]=C_[i][i]=1;\n\t\tfor(i=1;i<N_;i++) for(j=1;j<i;j++) C_[i][j]=(C_[i-1][j-1]+C_[i-1][j])%mo;\n\t}\n\tif(P_<0 || P_>N_ || Q_<0 || Q_>P_) return 0;\n\treturn C_[P_][Q_];\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);};\n\nmap<string,int> M[71];\nll tot;\nvector<int> G;\n\nvoid hoge(vector<int> V,vector<ll> C) {\n\tvector<int> O=V;\n\tstring T=S;\n\tint TN=T.size(),VN=V.size();\n\tvector<int> R(VN,-1);\n\t\n\tint x=0,y=0,i;\n\tFOR(i,TN) if(T[i]=='r' && x<VN) {\n\t\tR[x]=i;\n\t\tV[x]--;\n\t\tx++;\n\t\tT[i]='_';\n\t\t\n\t}\n\tif(x!=VN) return;\n\tx=0;\n\tFOR(i,TN) if(T[i]=='b') {\n\t\tif(x<VN && V[x] && i>R[x]) {\n\t\t\tV[x]--;\n\t\t\tR[x]=i;\n\t\t\tx++;\n\t\t\tT[i]='_';\n\t\t}\n\t}\n\tif(x<VN && V[x]) return;\n\t\n\tx=0;\n\tFOR(i,TN) if(T[i]!='_') {\n\t\tif(x<VN && V[x] && i>R[x]) {\n\t\t\tV[x]--;\n\t\t\tT[i]='_';\n\t\t\tif(V[x]==0) x++;\n\t\t}\n\t}\n\tif(x<VN && V[x]) return;\n\t\n\tmap<int,int> M;\n\tFORR(c,O) M[c]++;\n\t\n\tll ret=0;\n\tFOR(x,N+1) {\n\t\tint left=N-x-(V.size()-1);\n\t\tif(left<0) break;\n\t\t(ret+=C[x]*hcomb(V.size()+1,left))%=mo;\n\t}\n\t\n\t(ret*=fact[V.size()])%=mo;\n\tFORR(m,M) (ret*=factr[m.second])%=mo;\n\t\n\t(tot+=ret)%=mo;\n}\n\nvoid dfs(int L,int cur,vector<ll> C) {\n\tif(cur==0) return;\n\t// not take cur\n\tdfs(L,cur-1,C);\n\t\n\tif(L>=ML[cur]) {\n\t\tG.push_back(cur);\n\t\tvector<ll> C2(71);\n\t\tfor(int y=ML[cur];y<=70;y++) {\n\t\t\tfor(int x=0;x+y<=70;x++) {\n\t\t\t\t(C2[x+y]+=C[x]*group[cur][y])%=mo;\n\t\t\t}\n\t\t}\n\t\t\n\t\thoge(G,C2);\n\t\tdfs(L-(ML[cur]+1),cur,C2);\n\t\tG.pop_back();\n\t}\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>K>>S;\n\t\n\tinv[1]=fact[0]=factr[0]=1;\n\tfor (int i=2;i<=70;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\tfor (int i=1;i<=70;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\tfor(i=1;i<=70;i++) group[1][i]=1;\n\tML[1]=1;\n\tfor(i=2;i<=70;i++) {\n\t\tvector<int> cand={(i-1)*2-1,(i-1)*2,(i-1)*2,(i-1)*2+1};\n\t\tML[i]=(i-1)*2-1;\n\t\tFORR(l,cand) {\n\t\t\tfor(x=l;x<=70;x++) (group[i][x]+=hcomb(l,x-l))%=mo;\n\t\t}\n\t}\n\t\n\t\n\ttot=1;\n\tvector<ll> C(71);\n\tC[0]=1;\n\tdfs(N,70,C);\n\tcout<<tot<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 1E9 + 7, N = 200;\nint power(int base, int exp) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp & 1)\n            result = 1LL * result * base % P;\n        base = 1LL * base * base % P;\n        exp >>= 1;\n    }\n    return result;\n}\nint main() {\n    array<int, 200> factorial, inv_factorial;\n    factorial[0] = 1;\n    for (int i = 1; i < N; ++i)\n        factorial[i] = 1LL * factorial[i - 1] * i % P;\n    inv_factorial[N - 1] = power(factorial[N - 1], P - 2);\n    for (int i = N - 1; i >= 1; --i)\n        inv_factorial[i - 1] = 1LL * inv_factorial[i] * i % P;\n    auto binom = [&](int n, int m) {return 1LL * factorial[n] * inv_factorial[m] % P * inv_factorial[n - m] % P;};\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    string s;\n    cin >> n >> k >> s;\n    vector<int> f;\n    int ans = 0;\n    auto work = [&]() {\n        int len = n - (int)f.size() + 1;\n        int bl = (int)f.size() + 1;\n        vector<bool> book(k);\n        vector<int> r(f.size());\n        for (int i = 0, j = 0; i < (int)f.size(); ++i) {\n            len -= max(1, 2 * f[i] - 3);\n            bl += max(1, 2 * f[i] - 3);\n            while (j < k && s[j] != 'r')\n                ++j;\n            if (j == k)\n                return;\n            book[j] = true;\n            r[i] = j++;\n        }\n        for (int i = 0, j = 0; i < (int)f.size(); ++i) {\n            if (f[i] == 1)\n                continue;\n            bl += 2;\n            j = max(j, r[i]);\n            while (j < k && (s[j] != 'b' || book[j]))\n                ++j;\n            if (j == k)\n                return;\n            book[j] = true;\n            r[i] = j++;\n        }\n        for (int i = 0, j = 0; i < (int)f.size(); ++i) {\n            for (int l = 0; l < f[i] - 2; ++l) {\n                j = max(j, r[i]);\n                while (j < k && book[j])\n                    ++j;\n                if (j == k)\n                    return;\n                r[i] = j++;\n            }\n        }\n        int result = factorial[f.size()];\n        for (int i = 0; i < (int)f.size(); ) {\n            int j = i;\n            while (j < (int)f.size() && f[i] == f[j])\n                ++j;\n            result = 1LL * result * inv_factorial[j - i] % P;\n            i = j;\n        }\n        result = 1LL * result * binom(len + bl - 1, bl - 1) % P;\n        ans = (ans + result) % P;\n    };\n    function<void(int, int)> dfs = [&](int sum, int last) {\n        work();\n        for (int i = 1; i <= last && max(2, 2 * i - 2) <= sum; ++i) {\n            f.push_back(i);\n            dfs(sum - max(2, 2 * i - 2), i);\n            f.pop_back();\n        }\n    };\n    dfs(n + 1, n + 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<map>\n#include<string>\n#include<bitset>\n\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void add(int &x,int y) {\n  ((x+=y)>=MOD)?x-=MOD:0;\n} \n\nll C[105][105];\n\nvoid pre(int n) {\n  for(int i=0;i<=n;i++) C[i][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n}\n\nint f[85][85][85],up[85];\nint sum[85];\n\nvoid dp(int n,int m,int c) {\n  memset(f,0,sizeof(f));\n  int t=m+2*c-1;\n  f[0][0][0]=1;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<=up[i]&&2*j-m+t<=n;j++) {\n      int s=f[i][j][0];\n      for(int k=1;k<=up[m]&&j+(m-i)*k<=up[m];k++) {\n      \tfor(int l=1;i+l<=m&&j+l*k<=up[i+l];l++)\n      \t  add(f[i+l][j+l*k][k],s*C[i+l][l]%MOD);\n      \tadd(s,f[i][j][k]);\n\t  }\n    }\n  for(int i=0;i<=up[m]&&2*i-m+t<=n;i++) {\n  \tint s=0;\n  \tfor(int j=0;j<=i;j++) add(s,f[m][i][j]);\n  \tif (!s) continue;\n  \tint v=2*i-m+t;\n  \tfor(int j=0;j<=2*m+2&&v+j<=n;j++)\n  \t  add(sum[v+j],s*C[m+c][c]%MOD*C[2*m+2][j]%MOD);\n  }\n}\n\nchar str[85];\n\nint q[85],lpos[85];\nbool vis[85];\n\nint main() {\n  int n,k;\n  scanf(\"%d%d%s\",&n,&k,str+1);\n  pre(100);\n  for(int i=0;2*i<=k;i++) {\n  \tmemset(vis,0,sizeof(vis));\n  \tint cnt=0;\n  \tint lx=1,rx=0;\n  \tfor(int j=1;j<=k&&cnt<i;j++)\n  \t  if (str[j]=='r') q[++rx]=j;\n  \t  else if (lx<=rx) {\n  \t  \t  vis[q[lx++]]=vis[j]=1;\n  \t  \t  lpos[++cnt]=j;\n\t\t}\n\tif (cnt<i) continue;\n\tint s=0;\n\tfor(int j=1;j<=k;j++)\n\t  if (!vis[j]&&str[j]=='r') s++;\n\tint r=1;\n\tlpos[i+1]=k+1;up[i+1]=0;\n\tfor(int j=0;j<=s;j++) {\n\t\tif (j) {\n\t\t\twhile (vis[r]||str[r]!='r') r++;\n\t\t\tvis[r]=1;\n\t\t}\n\t\tfor(int t1=i;t1>0;t1--) {\n\t\t\tup[t1]=up[t1+1];\n\t\t\tfor(int t2=lpos[t1+1]-1;t2>lpos[t1];t2--)\n\t\t\t  if (!vis[t2]) up[t1]++;\n\t\t\tup[t1]++;\n\t\t}\n\t\treverse(up+1,up+i+1);\n\t\tdp(n,i,j);\n\t}\n  }\n  int ans=0;\n  for(int i=1;i<=n;i++) add(ans,sum[i]*C[n-1][i-1]%MOD);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=1010,P=1e9+7;\nint n,m,ans,cnt;\nint a[N],b[N],c[N],d[N],f[N],p[N],fc[N],vf[N],iv[N];\nchar s[N];\nvoid ini(int n){\n\tiv[1]=fc[0]=vf[0]=1;\n\tFOR(i,2,n) iv[i]=1ll*(P-P/i)*iv[P%i]%P;\n\tFOR(i,1,n) fc[i]=1ll*fc[i-1]*i%P,vf[i]=1ll*vf[i-1]*iv[i]%P;\n}\nint C(int x,int y){return x<y?0:1ll*fc[x]*vf[x-y]%P*vf[y]%P;}\nbool work(int L,int s,int t){\n\tint r=1;\n\tFOR(i,1,m) c[i]=0,b[i]=f[i];b[L+1]=0;\n\t//FOR(i,1,L) cout<<b[i]<<' ';cout<<'\\n';\n\tFOR(i,1,m)if(!a[i] && r<=L) b[c[i]=r]--,p[r++]=i;\n\tif(b[r]) return 1;r=1;\n\tFOR(i,1,m)if( a[i] && b[r] && p[r]<i) b[c[i]=r]--,p[r++]=i;\n\tif(b[r]) return 1;r=1;\n\tFOR(i,1,m)if(!c[i] && b[r] && p[r]<i && !--b[r]) r++;\n\tint ret=fc[L];\n\tFOR(i,1,m) ret=1ll*ret*vf[d[i]]%P;\n\t(ans+=1ll*ret*C(t,2*s)%P)%=P;\n}\nvoid dfs(int x,int s,int t){\n\tif(t<2*s) return;work(x-1,s,t);\n\tFOR(i,1,min(f[x-1],m-s)) f[x]=i,d[i]++,dfs(x+1,s+i,t+2*(i>=2)),d[i]--;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,s+1);ini(1000);\n\tFOR(i,1,m) a[i]=s[i]=='b';\n\tf[0]=m;dfs(1,0,n+1);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::endl;\n\nconst int N = 75 * 10, P = 1e9 + 7;\n\ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n\nint n, m, fac[N], inv[N];\nchar str[N];\nint size[N];\n\ninline int binom(int x, int y) {\n  if (x < y || x < 0 || y < 0) return 0;\n  return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\n\nint val[N], tot;\nint ans = 1;\nint last[N];\nbool vis[N];\n\ninline bool check() {\n  for (int i = 1; i <= m; ++i)\n    vis[i] = 0, last[i] = 0;\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    while (j <= m && str[j] != 'r') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] == 1) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    while (j <= m && str[j] != 'b') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] <= 2) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    for (int k = val[i] - 2; k; --k) {\n      while (j <= m && vis[j]) ++j;\n      if (j > m) return 0;\n      vis[j] = 1, ++j;\n    }\n  }\n  return 1;\n}\n\nvoid dfs(int left, int high) {\n  if (check()) {\n    int sum = tot + 1;\n    for (int i = 1; i <= tot; ++i) {\n      sum += size[val[i]];\n      if (val[i] > 1) sum += 2;\n    }\n    int way = 1ll * binom(sum + left - 1, left);\n    way = 1ll * way * fac[tot] % P;\n    for (int i = 1, j = 1; i <= tot; i = j) {\n      while (j <= tot && val[i] == val[j])\n        ++j;\n      way = 1ll * way * inv[j - i] % P;\n    }\n    ans = (ans + way) % P;\n  }\n  for (int i = 1; i <= high; ++i) {\n    if (size[i] + 1 > left) break;\n    val[++tot] = i;\n    dfs(left - size[i] - 1, i);\n    --tot;\n  }\n}\n\nint main() {\n  for (int i = fac[0] = 1; i < N; ++i)\n    fac[i] = 1ll * fac[i - 1] * i % P;\n  inv[N - 1] = fpow(fac[N - 1], P - 2);\n  for (int i = N - 1; i; --i)\n    inv[i - 1] = 1ll * inv[i] * i % P;\n  scanf(\"%d %d %s\", &n, &m, str + 1);\n  size[1] = size[2] = 1;\n  for (int i = 3; i <= n; ++i)\n    size[i] = size[i - 1] + 2;\n  for (int i = 1; ; ++i) {\n    if (size[i] > n) break;\n    val[tot = 1] = i;\n    dfs(n - size[i], i);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll fac[10010],finv[10010];\nll comb[510][510];\nvoid make_table(){\n  for(ll i=0;i<=500;i++){\n    comb[i][0]=1;\n    comb[i][i]=1;\n  }\n  for(ll i=1;i<=500;i++)for(ll j=1;j<i;j++){\n    comb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%mod;\n  }\n}\nll N,K;\nvector<vector<ll>> fs;\nvector<ll> f;\n\nvoid dfs(ll i,ll crt,ll sum){\n  if(sum-1>N)return ;\n  if(i==N){\n    fs.push_back(f);\n    return ;\n  }\n  fs.push_back(f);\n  for(ll j=crt;j>=1;j--){\n    f.push_back(j);\n    dfs(i+1,j,sum+(j==1?1+1:(j-1)*2-1+1));\n    f.pop_back();\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,10000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,10001)finv[i]=mod_pow(fac[i],mod-2);\n  make_table();\n\n  string S;\n\n  cin>>N>>K>>S;\n\n  dfs(0,36,0);\n\n  ll res=0;\n\n  rep(i,fs.size()){\n    vector<ll> f=fs[i];\n    ll M=f.size();\n    if(M==0)continue;\n    vector<bool> used(K,false);\n    vector<ll> rs(M,-1);\n    ll rcnt=0;\n    rep(j,K){\n      if(S[j]=='r'){\n        used[j]=true;\n        rs[rcnt]=j;\n        rcnt++;\n        if(rcnt==M)break;\n      }\n    }\n    if(rcnt<M)continue;\n    vector<ll> bs(M,-1);\n    rep(j,M){\n      if(f[j]==1)continue;\n      repl(k,rs[j],K){\n        if(S[k]=='b'&&!used[k]){\n          used[k]=true;\n          bs[j]=k;\n          break;\n        }\n      }\n    }\n    bool ok=true;\n    rep(j,M){\n      if(f[j]>1&&bs[j]==-1){\n        ok=false;\n      }\n    }\n    if(!ok)continue;\n\n    rep(j,M){\n      if(f[j]<=2)continue;\n      ll rest=f[j]-2;\n      repl(k,bs[j]+1,K){\n        if(!used[k]){\n          used[k]=true; rest--;\n          if(rest==0)break;\n        }\n      }\n      if(rest!=0){\n        ok=false;\n        break;\n      }\n    }\n    if(!ok)continue;\n\n    ll rest=(N+1)-(M-1);\n    ll sel=0;\n    ll cf=fac[M],scnt=0;\n    rep(j,M){\n      if(j>0&&f[j-1]==f[j])scnt++;\n      else{\n        cf*=finv[scnt]; cf%=mod;\n        scnt=1;\n      }\n      if(f[j]==1){\n        rest--;\n        sel+=2;\n      }else{\n        rest-=(f[j]-1)*2-1;\n        sel+=(f[j]-1)*2+2;\n      }\n    }\n    cf*=finv[scnt]; cf%=mod;\n\n    if(rest+sel-1>=0&&sel>=0)res+=comb[rest+sel-1][sel]*cf%mod;\n    res%=mod;\n  }\n  res++;\n  res%=mod;\n\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nll nHr(ll n,ll r){\n\treturn nCk(n+r-1,r);\n}\n\nint n,m;\nvi a;\n\nint main(){\n\tInit();\n\tcin>>n>>m;\n\ta=vi(m);\n\tfor(int i=0;i<m;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='b') a[i]++;\n\t}\n\tll res=1;\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++){\n\t\tvi b(m),c(i);\n\t\tint A=0,B=0,C=0;\n\t\tfor(int k=0;k<m;k++){\n\t\t\tif(!a[k]&&A+B!=i) A++,b[k]=1;\n\t\t\telse if(a[k]&&A) A--,b[k]=1,c[B++]=k;\n\t\t}\n\t\tfor(int k=0;k<m;k++) if(a[k]+b[k]==0&&C<j) C++,b[k]=1;\n\t\tif(B!=i||C!=j||2*i+2*j-1>n||i+j==0) continue;\n\t\tfor(int k=0;k<i;k++){\n\t\t\tint l=c[k];\n\t\t\tc[k]=0;\n\t\t\twhile(l<m) c[k]+=1-b[l++];\n\t\t\tc[k]=min(c[k],(n-2*i-2*j+1)/2);\n\t\t}\n\t\tc.push_back(0);\n\t\treverse(c.begin(),c.end());\n\t\tvvl dp(i+1,vl(n+1));\n\t\tdp[0][0]=Div(F[i+j],F[j]);\n\t\tfor(int k=0;k<n;k++) for(int I=i;I>=0;I--) for(int J=0;J<=c[I];J++) for(int l=1;I+l<=i&&J+k*l<=c[I+l];l++){\n\t\t\tdp[I+l][J+k*l]+=Div(dp[I][J],F[l]);\n\t\t}\n\t\tfor(int k=0;k<=c[i];k++) (res+=dp[i][k]*nHr(2*k+4*i+2*j+1,n-2*k-2*i-2*j+1))%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 605;\nconst int MM = 1000000007;\n\nint C[MX][MX];\nll I[MX], FI[MX], F[MX];\nint A[MX], sz = 0;\nstring S;\nll ans = 1;\nint N, K;\nint pr[75] = {};\n\nint sum = -1, t = 2;\n\nvoid update()\n{\n\tint cnt = -1, cur = -1, red = 0;\n\tfor(char c : S){\n\t\tif( c == 'r' ) red++;\n\t\tif( cnt <= 0 && cur+1 < red ){\n\t\t\tcur++;\n\t\t\tcnt = A[cur];\n\t\t}cnt--;\n\t}\n\tif( N >= sum && (cur >= sz || cur == sz-1 && cnt <= 0));\n\telse return;\n\t\n\tll m = F[sz];\n\tfor(int i = 0; i < sz; i++) pr[A[i]] += 1;\n\tfor(int i = 0; i <= A[0]; i++){\n\t\tif(pr[i]) m = m * FI[pr[i]] % MM;\n\t\tpr[i] = 0;\n\t}\n\t\n\tans = (ans + C[t+N-1][N-sum] * m) % MM;\n}\n\nvoid dfs(int K, int mx){\n\tif( K == 0 ) return;\n\tfor(int i = mx; i >= 1; i--){\n\t\tA[sz++] = i;\n\t\tt += i >= 2 ? 2 : 0;\n\t\tsum += i == 1 ? 2 : i*2-2;\n\n\t\tupdate();\n\t\tdfs(K-i, min(i, K-i));\n\n\t\tsz--;\n\t\tt -= i >= 2 ? 2 : 0;\n\t\tsum -= i == 1 ? 2 : i*2-2;\n\t}\n}\n\nint main()\n{\n\tF[0] = FI[0] = 1;\n\tI[1] = 1;\n\tfor(int i = 2; i < MX; i++) I[i] = (MM-I[MM%i]) * (MM/i) % MM;\n\tfor(int i = 1; i < MX; i++) F[i] = F[i-1] * i % MM;\n\tfor(int i = 1; i < MX; i++) FI[i] = FI[i-1] * I[i] % MM;\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 0; i < MX; i++){\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++) C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tcin >> S;\n\tdfs(K, K);\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MOD = (int)1e9 + 7;\nconst int kN = 70 + 1;\nconst int kM = 10000;\nint n, k;\nchar s[kN];\nint Inv[kM], F[kM], Finv[kM];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return F[a] * 1LL * Finv[b] % MOD * Finv[a - b] % MOD;\n}\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nstd::vector<int> vec; // 每段B的数量\n\nint getBound(const std::vector<int> &vec)\n{\n    std::vector<int> used(k);\n    int j = 0, pa = 0;\n    for (int i = 0; i < k; ++ i) {\n        if (s[i] == 'r') {\n            if (pa < vec.size())\n                used[i] = -1, ++ pa;\n        } else if (j < pa) {\n            used[i] = 1;\n            ++ j;\n        }\n    }\n    if (j != vec.size()) return -1;\n    int left[2] = {};\n    j = 0;\n    for (int i = k - 1; i >= 0; -- i) {\n        if (used[i] == 0) {\n            left[s[i] == 'b'] ++;\n        } else if (used[i] > 0) {\n            int c = vec[j ++] - 1;\n            for (int w = 1; w >= 0; -- w) {\n                int tmp = std::min(left[w], c);\n                c -= tmp;\n                left[w] -= tmp;\n            }\n            if (c > 0) return -1;\n        }\n    }\n    return left[0];\n}\n\nint calc(const std::vector<int> &vec)\n{\n    int bound_a = getBound(vec);\n    if (bound_a < 0) return 0;\n    int ret = 0;\n    for (int a = 0; a <= bound_a; ++ a) {\n        int segc = vec.size() + a;\n        if (segc == 0) {\n            add(ret, 1); continue;\n        }\n        int pre = ret;\n        int len = a;\n        int hole = 1 + a * 2;\n        int ops = a;\n        for (int x : vec) len += x * 2 - 1, hole += x * 2 + 1 + 1, ops += x + 1;\n        if (ops > k || segc - 1 + len > n) break;\n        int coef = F[segc] * 1LL * Finv[a] % MOD;\n        for (int i = 0, j = 0; i < vec.size(); i = j ++) {\n            while (j < vec.size() && vec[j] == vec[i]) ++ j;\n            coef = coef * 1LL * Finv[j - i] % MOD;\n        }\n        add(ret, binom(n - len - segc + 1 + hole - 1, hole - 1) * 1LL * coef % MOD);\n    }\n    return ret;\n}\n\nint search(int at, int segc, int len, int ops)\n{\n    int ret = calc(vec);\n    if (ret == 0) return 0;\n    for (int i = at; ; ++ i) {\n        if (k < ops + i + 1 || n < segc + len + i * 2 - 1) break;\n        int h = vec.size();\n        for (int j = 1; ; ++ j) {\n            if (k < ops + (i + 1) * j || n < segc + j - 1 + len + (i * 2 - 1) * j) break;\n            vec.emplace_back(i);\n            add(ret, search(i + 1, segc + j, len + (i * 2 - 1) * j, ops + (i + 1) * j));\n        }\n        vec.resize(h);\n    }\n    return ret;\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kM; ++ i)\n        Inv[i] = (MOD - MOD / i) * 1LL * Inv[MOD % i] % MOD;\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kM; ++ i) {\n        F[i] = F[i - 1] * 1LL * i % MOD;\n        Finv[i] = Finv[i - 1] * 1LL * Inv[i] % MOD;\n    }\n    scanf(\"%d%d%s\", &n, &k, s);\n    printf(\"%d\\n\", search(1, 0, 0, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 610\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint fac[N],inv[N],a[N],ans,n,k,r[N],b[N];\nchar ch[N]; bool vis[N];\nvoid init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[N-1]=ksm(fac[N-1],mdn-2);\n\tfor(int i=N-1;i;i--)\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%mdn*inv[n-m]%mdn;}\nint solve(int tot,int dat)\n{\n\tint cur=fac[tot],cnt=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(a[i]==a[i-1])\tcnt++;\n\t\telse\tcur=1ll*cur*inv[cnt]%mdn,cnt=1;\n\t}\n\tcur=1ll*cur*inv[cnt]%mdn;\n\tint pt=1; memset(vis,0,n+1);\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='r')\n\t\tif(pt<=tot)\tr[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot)\treturn 0; pt=1;\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='b')\n\t\tif(pt<=tot&&r[pt]<i&&a[pt]>=2)\tb[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot&&a[pt]>=2)\treturn 0; pt=1; int qwq=a[pt]-2;\n\tfor(int i=1;i<=k;i++)\tif(!vis[i])\n\t\tif(pt<=tot&&b[pt]<i&&qwq>0)\n\t\t{\n\t\t\tqwq--; if(!qwq)\tpt++,qwq=a[pt]-2;\n\t\t}\n\tif(qwq>0)\treturn 0;\n\treturn 1ll*dat*cur%mdn;\n}\nvoid dfs(int val,int x,int ful,int wei)\n{\n\tif(ful<wei)\treturn;\n\tif(!val)\treturn upd(ans,solve(x-1,C(ful,wei)));\n\tfor(int i=1;i<=min(val,a[x-1]);i++)\ta[x]=i,dfs(val-i,x+1,ful+(i>=2?2:0),wei+2*i);\n}\nint main()\n{\n\tn=read(),k=read(); init();\n\tscanf(\"%s\",ch+1); a[0]=n+1; int flag=0,flag1=0;\n\tfor(int i=2;i<=k;i++)\tif(ch[i]=='b'&&ch[i-1]=='r')\tflag=1;\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='r')\tflag1=1;\n\tif(n==1)\treturn puts(!flag1?\"1\":flag?\"3\":\"2\"),0; \n\tfor(int i=1;i<=n;i++)\tdfs(i,1,n+1,0);\n\tprintf(\"%d\\n\",(ans+1)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 107\n\nint N, K, tot, res;\nint mch[MAX_N], pos[MAX_N], sum[MAX_N];\nint fac[MAX_N * 3], ifac[MAX_N * 3];\nchar s[MAX_N];\nbool vis[MAX_N];\n\ninline int C(int x, int y) {\n    if (y < 0 || x < y) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid init() {\n    int MX = 300;\n    fac[0] = ifac[0] = 1;\n    Rep(i, MX) fac[i] = mul(fac[i - 1], i);\n    ifac[MX] = qpow(fac[MX], MOD - 2);\n    irep(i, MX, 2) ifac[i - 1] = mul(ifac[i], i);\n    Rep(i, K) if (s[i] == 'r') {\n        pos[++tot] = i;\n        rep(j, i + 1, K) if (s[j] == 'b' && !vis[j]) {\n            mch[i] = j;\n            vis[j] = true;\n            break;\n        }\n    }\n}\n\nint tp[MAX_N];\nbool check(int cur) {\n    if (cur > tot) return false;\n    Rep(i, N + 1) sum[i] = 0;\n    int p = 1;\n    IRep(i, cur) {\n        sum[pos[i]]++;\n        if (tp[p] > 1) {\n            if (!mch[pos[i]]) return false;\n            sum[mch[pos[i]]] += tp[p] - 1;\n        }\n        p++;\n    }\n    IRep(i, K) {\n        sum[i] += sum[i + 1];\n        if (sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\n\nbool dfs(int deg, int pre, int len) {\n    if (!check(deg - 1)) return false;\n    int t = deg;\n    Lep(i, deg) t += 2 * tp[i] - 1;\n    int ans = mul(C(N - len + t - 1, t - 1), fac[deg - 1]), tmp = 1;\n    Lep(i, deg) {\n        if (tp[i] != tp[i - 1]) {\n            ans = mul(ans, ifac[tmp]);\n            tmp = 0;\n        }\n        ++tmp;\n    }\n    ans = mul(ans, ifac[tmp]);\n    // printf(\"%d:  \", ans);\n    // Lep(i, deg) printf(\"%d \", tp[i]);\n    // puts(\"\");\n    inc(res, ans);\n    if (deg > tot) return true;\n    rep(i, pre, 70) {\n        int L = len;\n        if (deg > 1) L++;\n        if (i == 1)\n            L++;\n        else\n            L += i - 2 + i - 1;\n        if (L > N) break;\n        tp[deg] = i;\n        if (!dfs(deg + 1, i, L)) break;\n    }\n    return true;\n}\n\nvoid solve() {\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N), read(K);\n    scanf(\"%s\", s + 1);\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K,C[205][205],L[75],fac[205],invfac[205],cnt;\nint sum[75][2],pos[75],tot,ans;\nchar s[75];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nbool check() {\n    if(tot < cnt) return false;\n    int R = sum[K][0] - sum[pos[cnt]][0],B = sum[K][1] - sum[pos[cnt]][1];\n    int p = 1;\n    for(int i = cnt ; i >= 1 ; --i) {\n        if(L[p] >= 2) {\n            if(!B) return false;\n            --B;\n            if(R + B < L[p] - 2) return false;\n            R -= L[p] - 2;\n            if(R < 0) {B += R,R = 0;}\n        }\n        R += sum[pos[i] - 1][0] - sum[pos[i - 1]][0];\n        B += sum[pos[i] - 1][1] - sum[pos[i - 1]][1];\n        ++p;\n    }\n    return true;\n}\nbool dfs(int pre,int dep,int len) {\n    cnt = dep;\n    if(!check()) return false;\n    int k = 1 + cnt;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] == 1) ++k;\n        else k += 2 * L[i] - 1;\n    }\n    int res = C[N - len + k - 1][k - 1];\n    res = mul(res,fac[cnt]);\n    int t = 0;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] != L[i - 1]) {\n            res = mul(res,invfac[t]);\n            t = 0;\n        }\n        ++t;\n    }\n    res = mul(res,invfac[t]);\n    update(ans,res);\n    if(dep + 1 > tot) return true;\n    for(int i = pre ; i <= 70 ; ++i) {\n        int tl = len;\n        if(dep != 0) ++tl;\n        if(i == 1 || i == 2) tl += 1;\n        else tl += i - 2 + i - 1;\n        if(tl > N) break;\n        L[dep + 1] = i;\n        if(!dfs(i,dep + 1,tl)) break;\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);read(K);\n    scanf(\"%s\",s + 1);\n    C[0][0] = 1;\n    for(int i = 1 ; i <= 200 ; ++i) {\n        C[i][0] = 1;\n        for(int j = 1 ; j <= i ; ++j) {\n            C[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n        }\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 200 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[200] = fpow(fac[200],MOD - 2);\n    for(int i = 199 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    tot = 0;\n    for(int i = 1 ; i <= K ; ++i) {\n        if(s[i] == 'r') pos[++tot] = i;\n        sum[i][0] = sum[i - 1][0];\n        sum[i][1] = sum[i - 1][1];\n        if(s[i] == 'r') sum[i][0]++;\n        else sum[i][1]++;\n    }\n    dfs(1,0,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define M(x) ((x)%1000000007)\n#define MADD(x, y) (x = M(x + (y)))\n\nint N, K;\nchar s[75];\n\nbool reach[75][75][75];\n\n// no. of ways of having used exactly\n// A red, B blue seqs up to index i\n// 0: blank, 1: red, 2: blue (last ind)\nint cnt[75][75][75][3];\n\nint main() {\n\tcin >> N >> K >> s;\n\n\treach[0][0][0] = 1;\n\tfor (int i = 0; i < K; ++i) {\n\t\tfor (int A = 0; A < 75; ++A) {\n\t\t\tfor (int B = 0; B < 75; ++B) if (reach[A][B][i]) {\n\t\t\t\tif (s[i] == 'r') {\n\t\t\t\t\treach[A+1][B][i+1] = reach[A][B][i+1] = 1;\n\t\t\t\t\tif (B) reach[A][B+1][i+1] = 1;\n\t\t\t\t\tif (A) reach[A-1][B][i+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\treach[A][B][i+1] = 1;\n\t\t\t\t\tif (A) reach[A][B+1][i+1] = 1;\n\t\t\t\t\tif (B) reach[A][B-1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcnt[0][0][0][0] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int A = 0; A < 72; ++A) {\n\t\t\tfor (int B = 0; B < 72; ++B) {\n\t\t\t\t// first, consider the case\n\t\t\t\t// that we just came from a red or blue cell.\n\t\t\t\t// we could choose to break off the current\n\t\t\t\t// red sequence here, placing a white here.\n\t\t\t\tMADD(cnt[A][B][i+1][0], M(cnt[A][B][i][1] + cnt[A][B][i][2]));\n\n\t\t\t\t// if we came from a blank, we could start a new red sequence,\n\t\t\t\t// or start a red and a blue sequence simultaneously.\n\t\t\t\tMADD(cnt[A+1][B][i+1][1], cnt[A][B][i][0]);\n\t\t\t\tMADD(cnt[A+1][B+1][i+1][2], cnt[A][B][i][0]);\n\n\t\t\t\t// if we came from a red, we could start a new blue seq here\n\t\t\t\tMADD(cnt[A][B+1][i+1][2], cnt[A][B][i][1]);\n\n\t\t\t\t// if we came from a blue, we can go back to just being red again\n\t\t\t\tMADD(cnt[A][B][i+1][1], cnt[A][B][i][2]);\n\n\t\t\t\t// if we came from red, we could just keep being red\n\t\t\t\tMADD(cnt[A][B][i+1][1], cnt[A][B][i][1]);\n\n\t\t\t\t// if we came from a blank,\n\t\t\t\t// we can just keep being blank\n\t\t\t\tMADD(cnt[A][B][i+1][0], cnt[A][B][i][0]);\n\n\t\t\t\t// if we came from blue, we could just keep being blue\n\t\t\t\tMADD(cnt[A][B][i+1][2], cnt[A][B][i][2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint tot = 0;\n\tfor (int A = 0; A < 75; ++A) {\n\t\tfor (int B = 0; B < 75; ++B) if (reach[A][B][K]) {\n\t\t\tMADD(tot, M(M(cnt[A][B][N][0] + cnt[A][B][N][1]) + cnt[A][B][N][2]));\n\t\t}\n\t}\n\n\tcout << tot << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nint qpow(int x,int k)\n{\n    int r=1;\n    while(k)\n    {\n        if(k&1)r=1ll*r*x%mod;\n        k>>=1;x=1ll*x*x%mod;\n    }\n    return r;\n}\nint C[1010][1010];\nint fac[1010],ifac[1010];\nvoid init()\n{\n    for(int i=0;i<=1000;++i)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]);\n    }\n    fac[0]=1;\n    for(int i=1;i<=1000;++i)fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[1000]=qpow(fac[1000],mod-2);\n    for(int i=999;i>=0;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint n,m;\nint tr;\nchar s[110];\nint a[110];\nbool book[77];\nbool eb[77];\nbool check(int d)\n{\n    int cr=0,crb=0;\n    for(;a[cr+1]==1&&cr+1<=d;cr++);\n    crb=d-cr;\n    memset(book,0,sizeof(book[0])*(m+3));\n    memset(eb,0,sizeof(eb[0])*(m+3));\n    int pr=0,pb=0;\n    for(int t=1;t<=crb;++t)\n    {\n        while((s[pr]!='r'||book[pr])&&pr<=m)pr++;\n        while((s[pb]!='b'||book[pb]||pb<=pr)&&pb<=m)pb++;\n        if(pr>m||pb>m)return 0;\n        book[pr]=book[pb]=1;\n        eb[pb]=1;\n    }\n    int tcr=cr;\n    for(int i=1;i<=m&&cr;++i)\n        if(!book[i]&&s[i]=='r')cr--,book[i]=1;\n    if(cr)return 0;\n    for(int i=m,p=tcr+1,cnt=0;p<=d;--i)\n    {\n        if(!book[i])cnt++;\n        if(eb[i])\n        {\n            cnt-=a[p]-2;\n            if(cnt<0)return 0;\n            p++;\n        }\n    }\n    return 1;\n}\nint ans;\nvoid calc(int d,int l)\n{\n    int s=d+1;\n    for(int i=1;i<=d;++i)\n        if(a[i]==1)s++;\n        else s+=(a[i]-1)*2+1;\n    int res=1ll*C[n-l+s-1][s-1]*fac[d]%mod;\n    for(int i=1,j;i<=d;i=j+1)\n    {\n        for(j=i;a[j+1]==a[i]&&j<d;++j);\n        res=1ll*res*ifac[j-i+1]%mod;\n    }\n    ade(ans,res);\n}\nbool dfs(int x,int la,int len,int sl)\n{\n    if(!check(x-1))return 0;\n    if(x-1>tr)return 1;\n    calc(x-1,len);\n    int nl;\n    for(int i=la;i<=m-sl;++i)\n    {\n        a[x]=i;\n        nl=len;\n        if(x!=1)nl++;\n        if(i==1)nl++;\n        else nl+=(i-1)*2-1;\n        if(nl>n)break;\n        if(!dfs(x+1,i,nl,sl+i))break;\n    }\n    return 1;\n}\nint main()\n{\n    init();\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=m;++i)tr+=(s[i]=='r');\n    dfs(1,1,0,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=1010,P=1e9+7;\nint n,m,ans,cnt;\nint a[N],b[N],c[N],d[N],f[N],p[N],fc[N],vf[N],iv[N];\nchar s[N];\nvoid ini(int n){\n\tiv[1]=fc[0]=vf[0]=1;\n\tFOR(i,2,n) iv[i]=1ll*(P-P/i)*iv[P%i]%P;\n\tFOR(i,1,n) fc[i]=1ll*fc[i-1]*i%P,vf[i]=1ll*vf[i-1]*iv[i]%P;\n}\nint C(int x,int y){return x<y?0:1ll*fc[x]*vf[x-y]%P*vf[y]%P;}\nvoid work(int L,int s,int t){\n\tint r=1;\n\tFOR(i,1,m) c[i]=0,b[i]=f[i];b[L+1]=0;\n\t//FOR(i,1,L) cout<<b[i]<<' ';cout<<'\\n';\n\tFOR(i,1,m)if(!a[i] && r<=L) b[c[i]=r]--,p[r++]=i;\n\tif(b[r]) return;r=1;\n\tFOR(i,1,m)if( a[i] && b[r] && p[r]<i) b[c[i]=r]--,p[r++]=i;\n\tif(b[r]) return;r=1;\n\tFOR(i,1,m)if(!c[i] && b[r] && p[r]<i && !--b[r]) r++;\n\tif(b[r]) return;\n\tint ret=fc[L];\n\tFOR(i,1,m) ret=1ll*ret*vf[d[i]]%P;\n\t(ans+=1ll*ret*C(t,2*s)%P)%=P;\n}\nvoid dfs(int x,int s,int t){\n\tif(t<2*s) return;work(x-1,s,t);\n\tFOR(i,1,min(f[x-1],m-s)) f[x]=i,d[i]++,dfs(x+1,s+i,t+2*(i>=2)),d[i]--;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,s+1);ini(1000);\n\tFOR(i,1,m) a[i]=s[i]=='b';\n\tf[0]=m;dfs(1,0,n+1);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\n#define left LEFT\ntypedef long long ll;\nconst int N = 510;\nconst int mod = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check()\n{\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    FOR(i, 1, k)\n    {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update()\n{\n    ll tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1)\n    {\n        for(j = i; a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % mod;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % mod;\n    if ((ans += tmp) >= mod) ans -= mod;\n}\n\nvoid dfs(int mx)\n{\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    ++tot; --left; dfs(a[tot] = 1); ++left;\n    FOR(i, 2, mx)\n    {\n        left -= i * 2 - 3;\n        dfs(a[tot] = i);\n        left += i * 2 - 3;\n    }\n    a[tot--] = 0;\n    if (tot) ++left;\n}\n\nint main()\n{\n    FOR(i, 0, 500)\n    {\n        c[i][0] = 1;\n        FOR(j, 1, 500)\n            if ((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= mod)\n                c[i][j] -= mod;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(100);\n    printf(\"%d\\n\", (ans + 1) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MOD (1000000007)\nusing namespace std;\nconst int MAXN = 105;\ntypedef long long LL;\nint N, M, A[MAXN], minLen[MAXN], Belong[MAXN], Last[MAXN],KK,LLL;\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check(vector<int> Seq)\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1])--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<int> Seq, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<int> Seq, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check(Seq))Calc(Tot, Seq, V),++KK;\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, Seq, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= 70; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, Seq, newV, 1, Tot + minLen[Len]);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N / 2, M, N, V1, V2, 0, 0);\n\tcout << (Ans + 1) % MOD;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n} c(150);\n\nmint res;\nint n,k;\nstring s;\nbool trk[77];\nint pos[77];\nint cnt[77];\n\nbool check(const vector<int>& ip, int sum) {\n    memset(trk, 0, sizeof trk);\n    memset(pos, -1, sizeof pos);\n    memset(cnt, 0, sizeof cnt);\n    int m = ip.size();\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = 0; j < k; j++) {\n            if (s[j]=='r' && !trk[j]) {\n                pos[i] = j; trk[j] = true;\n                cnt[i]++;\n                break;\n            }\n        }\n        if (pos[i] == -1) return false;\n    }\n    for (int i = m-1; i >= 0; i--) {\n        if (ip[i] == 1) continue;\n        for (int j = pos[i]+1; j < k; j++) {\n            if (s[j]=='b' && !trk[j]) {\n                cnt[i]++;\n                pos[i]=j; trk[j] = true;\n                break;\n            }\n        }\n        if (cnt[i] != 2) return false;\n    }\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = pos[i]+1; ip[i] > cnt[i] && j < k; j++) {\n            if (!trk[j]) {\n                cnt[i]++;\n                pos[i] = j; trk[j] = true;\n            }\n        }\n        //cout << i << ','<<cnt[i]<<'\\n';\n        if (ip[i] != cnt[i]) return false;\n    }\n    \n    mint coeff = c.fac[m];\n    int las = 0, len = 0;\n    for (const int& x: ip) {\n        if (x == las) len++;\n        else {\n            coeff *= c.ifac[len];\n            len = 1;\n            las = x;\n        }\n    }coeff *= c.ifac[len];\n\n    int zero = 0;\n    zero += 2;\n    for (const int& x: ip) {\n        if (x > 1) zero+=2;\n    }\n\n    //dbg(ip, sum);\n    if (sum == 0) {\n        res += 1; return true;\n    }\n    //cout << coeff << '\\n';\n    res += c.p(n+zero, sum+zero) * coeff;\n    //cout << res << \"\\n\";\n    return true;\n}\n\nvoid dfs(vector<int>& ip, int sum) {\n    check(ip, sum);\n    //dbg(ip);\n    int sta = ip.empty()? 1 : ip.back();\n    for (int i = sta; i <= k; i++) {//lim not n,\n        int nex_sum = sum + max(2*i-3, 1) + (ip.empty()?0:1);\n        if (nex_sum > n) break;\n        ip.emplace_back(i);\n        dfs(ip, nex_sum);\n        ip.pop_back();\n    }\n}\n\nvoid solve() {\n    cin >> n >> k;\n    cin >> s;\n    vector<int> ip;\n    dfs(ip, 0);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 200;\nconst ll MOD = 1e9 + 7;\n\nll sq(ll x) { return x * x % MOD; }\nll qpow(ll a, ll b) { return b ? sq(qpow(a, b / 2)) * (b & 1 ? a : 1) % MOD : 1; }\nll inv(ll x) { return qpow(x, MOD - 2); }\n\nint N, K, cnt[MAX_N];\nchar S[MAX_N];\nll fac[MAX_N], ifac[MAX_N];\nll ans;\n\nll comb(int n, int m) { return m <= n && m >= 0 ? fac[n] * ifac[n - m] % MOD * ifac[m] % MOD : 0; }\n\nbool check() {\n    int c1 = cnt[1], x = 0;\n    vector<int> seg;\n    queue<int> que;\n    for (int i = 2; i <= N + 1; i++)\n        for (int j = 1; j <= cnt[i]; j++)\n            seg.push_back(i);\n    for (int i = 1; i <= K; i++) {\n        if (S[i] == 'r') {\n            if (!seg.empty()) {\n                que.push(seg.back());\n                seg.pop_back();\n            } else if (c1) {\n                c1--;\n            } else {\n                x = max(0, x - 1);\n            }\n        } else {\n            if (!que.empty()) {\n                x += que.front() - 2;\n                que.pop();\n            } else {\n                x = max(0, x - 1);\n            }\n        }\n    }\n    return x == 0 && c1 == 0 && seg.empty() && que.empty();\n}\n\nvoid solve() {\n    if (!check()) {\n        return;\n    }\n    int x = -1, y = 1, z = 0;\n    ll c = 1;\n    for (int i = 1; i <= N + 1; i++) {\n        x += cnt[i] * max(2, i * 2 - 2);\n        if (i != 1) y += cnt[i];\n        z += cnt[i];\n        (c *= comb(z, cnt[i])) %= MOD;\n    }\n    if (x == -1) {\n        (ans += 1) %= MOD;\n        return;\n    }\n    ll res = 0;\n    for (int i = 0; i <= y * 2; i++) {\n        (res += comb(N - 1, x + i - 1) * comb(y * 2, i)) %= MOD;\n    }\n    (ans += res * c) %= MOD;\n}\n\nvoid dfs(int x, int y) {\n    if (y == N + 2) {\n        solve();\n        return;\n    }\n    int len = max(2, 2 * y - 2);\n    for (int j = 0; x + len * j <= N; j++) {\n        cnt[y] = j;\n        dfs(x + len * j, y + 1);\n    }\n}\n\nint main() {\n    fac[0] = 1;\n    for (int i = 1; i < MAX_N; i++) fac[i] = fac[i - 1] * i % MOD;\n    ifac[MAX_N - 1] = inv(fac[MAX_N - 1]);\n    for (int i = MAX_N - 1; i; i--) ifac[i - 1] = ifac[i] * i % MOD;\n    scanf(\"%d%d\", &N, &K);\n    scanf(\"%s\", S + 1);\n    dfs(-1, 1);\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint n,k,comb[233][233],tot,tot2,ma[111],mb[111];\nchar s[111];\n\nint c[111],ans,use[111];\nvoid dfs(int mx,int cnt,int sum,int coef)\n{\n\tif(cnt+sum-1>n)return;\n\tif(cnt>tot)return;\n\tif(mx==0)\n\t{\n\t\tif(cnt==0)\n\t\t{\n\t\t\tans++;if(ans>=mod)ans-=mod;\n\t\t\treturn;\n\t\t}\n\t\tif(cnt-c[1]>tot2)return;\n\t\t\n\t\tbool ok=1;int cur=0;\n\t\tmemset(use,0,sizeof(use));\n\t\tfor(int i=(n+3)>>1;i>0;i--)\n\t\t{\n\t\t\tfor(int j=1;j<=c[i];j++)\n\t\t\t{\n\t\t\t\tcur++;\n\t\t\t\tuse[ma[cur]]=1;\n\t\t\t\tuse[mb[cur]]=i-1;\n\t\t\t}\n\t\t}\n\t\tcur=0;\n\t\tfor(int i=k;i>=1&&ok;i--)\n\t\t{\n\t\t\tcur++;\n\t\t\tif(cur<use[i])ok=0;\n\t\t\telse cur-=use[i];\n\t\t}\n\t\tif(ok)\n\t\t{\n\t\t\tint have=n-cnt-sum+1,need=sum+cnt+1+(cnt-c[1])*2;\n\t\t\tans=(ans+1ll*coef*comb[have+need-1][need-1])%mod;\n\t\t}\n\t\treturn;\n\t}\n\tfor(c[mx]=0;c[mx]<=n;c[mx]++)dfs(mx-1,cnt+c[mx],sum+c[mx]*(mx==1?1:mx+mx-3),coef*1ll*comb[cnt+c[mx]][cnt]%mod);\n}\n\nint main()\n{\n\tfor(int i=0;i<233;i++)\n\t{\n\t\tcomb[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tcomb[i][j]=comb[i-1][j]+comb[i-1][j-1];\n\t\t\tif(comb[i][j]>=mod)comb[i][j]-=mod;\n\t\t}\n\t}\n\tget2(n,k);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=k;i++)if(s[i]=='r')\n\t{\n\t\tint j=i;\n\t\tfor(;j<=k;j++)if(s[j]=='b'&&!use[j])break;\n\t\ttot++;tot2+=(j<=n);\n\t\tma[tot]=i;mb[tot]=j;\n\t\tuse[j]=1;\n\t}\n\tdfs((n+3)/2,0,0,1);\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MOD (1000000007)\nusing namespace std;\nconst int MAXN = 75;\ntypedef long long LL;\nint N, M, A[MAXN], minLen[MAXN], Belong[MAXN], Last[MAXN],KK,LLL;\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check(vector<int> Seq)\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1])--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<int> Seq, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<int> Seq, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check(Seq))Calc(Tot, Seq, V),++KK;\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, Seq, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= 70; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, Seq, newV, 1, Tot + minLen[Len]);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N / 2, M, N, V1, V2, 0, 0);\n\tcout << (Ans + 1) % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int p=1000000007;\n\nint c[300][300],g[100],h[100];\nchar b[100];\nint i,j,k,l,m,n,r,s,t;\n\ninline void pre()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",b+1);\n\tfor (i=0;i<=250;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t\tif ((j==0) || (j==i))\n\t\t\t\tc[i][j]=1;\n\t\t\telse\n\t\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%p;\n\treturn;\n}\n\ninline void calc()\n{\n\tfor (i=1;i<=n;i++)\n\t\th[i]=g[i];\n\tt=0;\n\tfor (i=1,k=1,l=1;i<=m;i++)\n\t\tif ((b[i]=='r') && (h[k]>0))\n\t\t\th[k]--,k++;\n\t\telse\n\t\tif ((b[i]=='b') && (h[l]>0) && (l<k))\n\t\t\th[l]--,t=t+h[l],l++;\n\t\telse\n\t\tif (t>0)\n\t\t\tt--;\n\tif ((h[k]) || (h[l]) || (t))\n\t\treturn;\n\tr=1;\n\tfor (i=1;g[i];i=j)\n\t{\n\t\tfor (j=i;g[i]==g[j];j++);\n\t\tr=1LL*r*c[j-1][i-1]%p;\n\t\tif (g[i]==1)\n\t\t\tt=t+j-i;\n\t\telse\n\t\t\tt=t+(j-i)*(2*g[i]-3);\n\t}\n\tt=t+k-2;\n\tif (n-t<0)\n\t\treturn;\n\ts=(s+1LL*r*c[n+2*l-1][t+2*l-1])%p;\n\treturn;\n}\n\ninline void dfs(int w,int x,int y,int z)\n{\n\tif (w<0)\n\t\treturn;\n\tif (z)\n\t\tcalc();\n\tif (x)\n\t{\n\t\tg[z+1]=1,dfs(w-2,x-1,1,z+1);\n\t\tfor (int i=2;(i<=x) && (i<=y);i++)\n\t\t\tg[z+1]=i,dfs(w-2*i+2,x-i,i,z+1);\n\t\tg[z+1]=0;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tpre();\n\tdfs(n+1,m,m,0);\n\tprintf(\"%d\",(s+1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//O(NK^5) -> サンプル合わない。悲しいね。\n#include <iostream>\n#include <string>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\nint n, K;\nstring s;\nint dp[72][71][71];\t//dp[見たボールの個数][rの使用数][bの使用数] = 何通り.\nint posR[71];\t//posR[i] = i(>=0)個目のrの位置\nint lowB[71];\t//lowB[i] = i(>=0)個目のrで使用するbの個数の最低限\nint f[200][200];\t//f[i][j] = 長さiをj区間(空区間もOK)で取る方法の個数\n\nint solveF(int len, int cnt) {\n\tif (len == 0) return (cnt == 0);\n\tif (f[len][cnt] != -1) return f[len][cnt];\n\t\n\tint ret = 0;\n\tfor (int i = 0; i <= len; i++) {\n\t\tret += solveF(len - i, cnt - 1);\n\t\tret %= mod;\n\t}\n\treturn f[len][cnt] = ret;\n}\n\nsigned main() {\n\tint i, j, k;\n\t\n\tfor (i = 0; i < 200; i++) for (j = 0; j < 200; j++) f[i][j] = -1;\n\tfor (i = 0; i < 200; i++) for (j = 0; j < 200; j++) solveF(i, j);\n\t\n\tcin >> n >> K >> s;\n\t\n\tint rcnt = 0;\n\tint bcnt = 0;\n\tfor (i = 0; i < s.length(); i++) {\n\t\tif (s[i] == 'R') {\n\t\t\tposR[rcnt] = i;\n\t\t\tlowB[rcnt] = bcnt;\n\t\t\trcnt++;\n\t\t}\n\t\telse {\n\t\t\tbcnt++;\n\t\t}\n\t}\n\t\n\tdp[0][0][0] = 1;\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tfor (k = 0; k < K; k++) {\n\t\t\t\tif (dp[i][j][k] == 0) continue;\n\t\t\t\t\n\t\t\t\tint l, r, x;\n\t\t\t\tfor (l = i; l < n; l++) {\n\t\t\t\t\tfor (r = l; r <= n; r++) {\t//[l, r)を赤で塗ったのち\n\t\t\t\t\t\tfor (x = max(0LL, lowB[j] - k); x + k <= bcnt; x++) {\t//そのうち, x区間を青で塗る\n\t\t\t\t\t\t\tdp[r + 1][j + 1][k + x] += dp[i][j][k] * f[r - l][2 * x + 1];\n\t\t\t\t\t\t\tdp[r + 1][j + 1][k + x] %= mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (i = 0; i <= n + 1; i++) {\n\t\tans += dp[i][rcnt][bcnt];\n\t\tans %= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint fac[150], ifac[150], ans, n, k;\nbool del[75];\nvector<int> f, r;\nchar s[75];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nbool check() {\n\tfill(del + 1, del + 1 + k, false);\n\tfor (int i = 0; i < f.size(); ++i) del[r[i]] = true;\n\tvector<int> b(f.size());\n\tfor (int i = f.size() - 1, j = 1; i >= 0; --i)\n\t\tif (f[i] >= 2) {\n\t\t\twhile ((j < r[f.size() - 1 - i] || del[j] || s[j] == 'r') && j <= k) ++j;\n\t\t\tif (j > k) return false;\n\t\t\tb[i] = j;\n\t\t\tdel[j] = true;\n\t\t}\n\tfor (int i = f.size() - 1, j = n; i >= 0; --i)\n\t\tif (f[i] >= 3) {\n\t\t\tint cnt = f[i] - 2;\n\t\t\tfor (; cnt && j > b[i]; --j)\n\t\t\t\tif (!del[j]) del[j] = true, --cnt;\n\t\t\tif (cnt) return false;\n\t\t}\n\treturn true;\n}\n\nvoid dfs(int lst, int sum) {\n\tif (f.size() > r.size()) return;\n\tif (check()) {\n\t\tint s = n + 1, c = fac[f.size()], s1 = 0;\n\t\tfor (int i = 0, j; i < f.size(); i = j) {\n\t\t\tfor (j = i + 1; j < f.size() && f[j] == f[i]; ++j);\n\t\t\tc = 1ll * c * ifac[j - i] % P;\n\t\t\tif (f[i] > 1) s += 2 * (j - i);\n\t\t\ts1 += 2 * f[i] * (j - i);\n\t\t}\n\t\tans = (ans + 1ll * c * fac[s] % P * ifac[s1] % P * ifac[s - s1]) % P;\n\t}\n\tfor (int i = lst; (sum + max(1, i - 1)) * 2 <= n + 1; ++i) f.push_back(i), dfs(i, sum + max(1, i - 1)), f.pop_back();\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &k, s + 1);\n\tfor (int i = 1; i <= k; ++i)\n\t\tif (s[i] == 'r') r.push_back(i);\n\tfor (int i = fac[0] = 1; i <= 2 * n + 5; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[2 * n + 5] = power(fac[2 * n + 5], P - 2);\n\tfor (int i = 2 * n + 5; i; --i) ifac[i - 1] = 1ll * ifac[i] * i % P;\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[80];\nint n, K, chk[80], Loc[100], C[100], F[150], InvF[150], Mod = 1000000007;\nint D[100][100], TD[100][100]; // 한 블럭의 크기, 블럭의 개수, 쓴거의 개수\n\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint Comb(int n, int r) {\n\treturn 1ll * F[n] * InvF[r] % Mod*InvF[n - r]%Mod;\n}\nint Do(int A, int B) { // R* : A, RBxx : B\n\tint i, c1 = 0, c2 = 0, j, k, ii, jj;\n\tfor (i = 0; i < K; i++) {\n\t\tchk[i] = 0;\n\t\tif (p[i] == 'r' && c1 < B) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t\tif (p[i] == 'b' && c2 < c1) {\n\t\t\tchk[i] = 1;\n\t\t\tc2++;\n\t\t\tLoc[c2] = i;\n\t\t}\n\t}\n\tif (c1 < B || c2 < B)return 0;\n\tc1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tif (p[i] == 'r' && !chk[i] && c1 < A) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t}\n\tif (c1 < A)return 0;\n\tfor (i = 1; i <= B; i++) {\n\t\tC[B-i+1] = 0;\n\t\tfor (j = Loc[i]; j < K; j++)if (!chk[j])C[B-i+1]++;\n\t}\n\tfor (i = 0; i < 71; i++)for (j = 0; j < 71; j++)D[i][j] = TD[i][j] = 0;\n\tD[0][0] = InvF[A];\n\n\tfor (i = 0; i <= n / 2 + 1; i++) {\n\t\tfor (j = 0; j < 71; j++) {\n\t\t\tfor (k = 0; k < 71; k++) {\n\t\t\t\tif (!D[j][k])continue;\n\t\t\t\tfor (ii = 0;; ii++) {\n\t\t\t\t\tint s = (ii*i + k);\n\t\t\t\t\tif (ii+j > B || s * 2 + A + B + (A + B - 1) > n || C[j+ii] < s)break;\n\t\t\t\t\tTD[j + ii][s] = (TD[j + ii][s] + 1ll * D[j][k] * InvF[ii]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 71; j++)for (k = 0; k < 71; k++) {\n\t\t\tD[j][k] = TD[j][k];\n\t\t\tTD[j][k] = 0;\n\t\t}\n\t}\n\tint r = 0;\n\tfor (i = 0; i < 71; i++) {\n\t\tint c = (A + B + A + B - 1 + i * 2);\n\t\tint t = c + B * 2 + 2;\n\t\tif (!D[B][i] || n-c < 0)continue;\n\t\tr = (r + 1ll * D[B][i] * F[A+B] % Mod * Comb(t + (n - c) - 1, (n - c)))%Mod;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, res = 0;\n\tF[0] = 1;\n\tfor (i = 1; i <= 140; i++)F[i] = 1ll * F[i - 1] * i%Mod;\n\tfor (i = 0; i <= 140; i++)InvF[i] = Pow(F[i], Mod - 2);\n\tscanf(\"%d%d\", &n, &K);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i <= (n+1)/2; i++) {\n\t\tfor (j = 0; i + j <= (n + 1) / 2; j++) {\n\t\t\tres = (res + Do(i, j))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef long long i64;\nconst int MAX_N = 205, MOD = 1000000007;\n\ni64 fac[MAX_N], inv[MAX_N], ifac[MAX_N];\ni64 result = 0;\n\nint N, K;\nchar S[MAX_N];\n\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint tot = 0, pos[MAX_N], st[MAX_N];\n\nbool check() {\n  static bool vis[105];\n  static int posb[105];\n  memset(vis, 0, sizeof vis);\n  for (int i = 1; i <= tot; ++i)\n    if (pos[i])\n      vis[pos[i]] = 1;\n    else\n      return false;\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    j = max(j, pos[i]);\n    if (st[i] == 1) break;\n    while (j <= K && S[j] != 'b') j++;\n    if (j > K) return false;\n    vis[j] = 1;\n    posb[i] = j;\n  }\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    int cnt = st[i] - 2;\n    j = max(j, posb[i]);\n    while (cnt > 0 && j <= K) {\n      if (!vis[j]) cnt--;\n      vis[j] = 1, j++;\n    }\n    if (cnt > 0) return false;\n  }\n  return true;\n}\n\nvoid dfs(int rest, int restN, int lim) {\n  if (restN < 0 || rest < 0) return;\n  if (rest >= 0) {\n    if (!check()) return;\n    i64 now = fac[tot];\n    int cnt = 0, sum_len = 0;\n    for (int i = 1; i <= tot; ++i) {\n      if (st[i] == 1) {\n\tnow = now * ifac[tot - i + 1] % MOD;\n\tsum_len += tot - i + 1;\n\tbreak;\n      } else {\n\tint j = i, num = 0;\n\twhile (st[j + 1] == st[i]) j++;\n\tnum = j - i + 1, cnt += num, sum_len += num * (st[i] * 2 - 3);\n\tnow = now * ifac[num] % MOD;\n\ti = j;\n      }\n    }\n    assert(sum_len == N - restN);\n    i64 temp = 0;\n    for (int i = 0; i <= N - sum_len; ++i) {\n      int l = sum_len + i;\n      temp = (temp + now * binom(cnt * 2, i) % MOD * binom(N + 1, l + tot) % MOD) % MOD;\n    }\n    result = (result + temp) % MOD;\n  }\n  for (int i = lim; i; --i) {\n    st[++tot] = i;\n    dfs(rest - i, restN - max(i * 2 - 3, 1), i);\n    tot--;\n  }\n}\n\nint main() {\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i < MAX_N; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i < MAX_N; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i < MAX_N; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  \n  scanf(\"%d%d\", &N, &K);\n  scanf(\"%s\", S + 1);\n  \n  for (int i = 1, temp = 0; i <= K; ++i)\n    if (S[i] == 'r') pos[++temp] = i;\n\n  dfs(K, N, K);\n\n  printf(\"%lld\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\nconst u32 P=1e9+7;\ninline u32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\ninline u32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\ninline u32 sum(u32 a, u32 b) {return (a+=b)<P?a:a-P;}\ninline u32 dif(u32 a, u32 b) {return (a-=b)&0x80000000?a+P:a;}\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\n\nint n, k, rcnt, f[70];\nu32 ans, c[500][500], fac[500], inv[500];\nchar s[71];\nvoid search(int len, int last, int sum) {\n\tif(len>rcnt) return;\n\tint r=0, nz=0, b=0, a=0;\n\twhile(nz<len&&f[nz]==0) ++nz;\n\tnz=len-nz;\n\tfor(int i=0; i<k&&(b!=nz||a!=0); ++i) {\n\t\tif(s[i]=='r') if(r<len) ++r; else if(a) --a;\n\t\tif(s[i]=='b') if(b<r&&b<nz) ++b, a+=f[len-b]-1; else if(a) --a;\n\t}\n\tif(b==nz&&a==0) {\n\t\tint fsum=len;\n\t\tu64 q=fac[len];\n\t\tfor(int i=0, j; i<len; ++i) {\n\t\t\tfsum+=f[i];\n\t\t\tif(i==0||f[i]!=f[i-1]) j=0;\n\t\t\tq=q*inv[++j]%P;\n\t\t}\n\t\tans=(ans+q*c[n+1+2*nz][2*fsum])%P;\n\t\tif(sum) {\n\t\t\tint &F=f[len];\n\t\t\tfor(F=last; F<=sum; ++F) search(len+1, F, sum-(F?F:1));\n\t\t}\n\t}\n}\nint main() {\n\tfor(int i=0; i<500; ++i) {\n\t\tc[i][0]=c[i][i]=1;\n\t\tfor(int j=1; j<i; ++j) c[i][j]=sum(c[i-1][j-1], c[i-1][j]);\n\t}\n\tfac[0]=1;\n\tfor(int i=1; i<500; ++i) fac[i]=(u64)fac[i-1]*i%P;\n\tinv[1]=1;\n\tfor(int i=2; i<500; ++i) inv[i]=(u64)(P-P/i)*inv[P%i]%P;\n\tassert(scanf(\"%d%d%s\", &n, &k, s)==3);\n\trcnt=std::count(s, s+k, 'r');\n\tsearch(0, 0, (n+1)/2);\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=220,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,ans,a[N],s[N],pos[N],C[N][N],po[N],inv[N];\nchar ch[N];bool h[N];\nint get_nex(char c,int i){\n\tfor (;(i<=m)&&(h[i]||(ch[i]!=c));i++);\n\treturn i;\n}\nint get_n(int i){\n\tfor (;(i<=m)&&h[i];i++);\n\treturn i;\n}\nbool check(int dep){\n\tmemset(h,0,m+1);\n\tfor (int i=1;i<=dep;i++){\n\t\tpos[i]=get_nex('r',1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\tfor (int i=1;i<=dep;i++)\n\tif (a[i]>1){\n\t\tpos[i]=get_nex('b',pos[i]+1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\tfor (int i=1;i<=dep;i++)\n\tfor (int j=3;j<=a[i];j++){\n\t\tpos[i]=get_n(pos[i]+1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\treturn true;\n}\nvoid calc(int res,int r,int dep){\n\tint t=po[dep-1],s1=n+1,s2=0;\n\tfor (int i=1;i<=n;i++){\n\t\tt=(ll)t*inv[s[i]]%p;\n\t\ts1+=(i>1)*2*s[i];\n\t\ts2+=2*s[i]*i;\n\t}\n\tif ((s1<s2)||(!check(dep-1))) return;\n\tans=(ans+(ll)t*C[s1][s2])%p;\n\tfor (int i=1;i<=r;i++){\n\t\ta[dep]=i;s[i]++;\n\t\tcalc(res-i,min(i,res-i),dep+1);\n\t\ts[i]--;\n\t}\n\ta[dep]=0;\n}\nint main(){\n\tn=read();m=read();\n\tscanf(\" %s\",ch+1);\n\tC[0][0]=po[0]=inv[0]=1;\n\tfor (int i=1;i<=214;i++){\n\t\tC[i][0]=1;po[i]=(ll)po[i-1]*i%p;\n\t\tinv[i]=qpow(po[i],p-2);\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tcalc(min(n+1,m),min(n+1,m),1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[N], tmp[N], top = 0;\nchar str[K];\nlong long c[N * 5][N * 5], ans = 0ll;\n\nlong long solve () {\n\tqueue<int> que;\n\tfor (int i = 0; i < m; i++) suf[i] = 1;\n\tfor (int i = 0, j = top - 1; i < m && j >= 0; i++) {\n\t\tif (str[i] == 'r') que.push(i);\n\t\tif (stk[j] && str[i] == 'b' && !que.empty()) {\n\t\t\tsuf[que.front()] = suf[i] = 0;\n\t\t\tque.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\twhile (j >= 0 && !stk[j] && !que.empty()) {\n\t\t\tsuf[que.front()] = 0, que.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\tif (i == m - 1 && j >= 0) return 0ll;\n\t}\n\n\tsuf[m] = 0;\n\tfor (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n\tfor (int i = 0, j = 0; i < top; i++) {\n\t\tif (stk[i]) {\n\t\t\tj += stk[i] - 1;\n\t\t\tif (suf[pos[i]] < j) return 0ll;\n\t\t}\n\t}\n\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tassert(num1 + num2 - 1 <= n * 3);\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 5 i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 0; i <= n * 5; i++) {\n\t\tfor (int j = 0; j <= n * 5; j++) c[i][j] = 0ll;\n\t}\n\tfor (int i = 1; i <= n * 5; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nbool used[100];\nint p[100];\nint calc(){\n    int n=X.size();\n    if(n>R)return 0;\n\n    memset(used,0,sizeof(used));\n    for(int i=0;i<n;i++)used[r[R-i]]=true;\n    rep(i,n){\n        if(X[i]==1)break;\n        int pos=r[R-i]+1;\n        while(pos<K&&(S[pos]=='r'||used[pos]))pos++;\n        if(pos==K)return 0;\n        used[pos]=true;\n        p[i]=pos;\n    }\n    rep(i,n){\n        if(X[i]<=2)break;\n        int pos=p[i];\n        rep(t,X[i]-2){\n            while(pos<K&&used[pos])pos++;\n            if(pos==K)return 0;\n            used[pos]=true;\n            pos++;\n        }\n    }\n\n    /*\n    rep(i,n)used[r[R-i]]=true;\n    int pos=B;\n    for(int i=0;i<n;i++){\n        if(X[i]==1)break;\n        while(pos>0&&b[pos]<r[R-i])pos--;\n        if(pos==0)return 0;\n        used[b[pos]]=true;\n        p[i]=pos;\n        pos--;\n    }\n    pos=0;\n    rep(i,n){\n        chmax(pos,b[p[i]]+1);\n        rep(t,X[i]-2){\n            while(pos<N&&used[pos])pos++;\n            if(pos==N)return 0;\n            used[pos]=true;\n            pos++;\n        }\n    }\n\n    */\n\n    vpint ei;\n    rep(i,X.size()){\n        if(ei.size()==0||ei.back().fi!=X[i])ei.pb({X[i],1});\n        else ei.back().se++;\n    }\n\n    int latte=0;\n    int s=0;\n    for(int i=0;i<X.size();i++){\n        if(X[i]==1){\n            latte++;\n            s++;\n        }\n        else{\n            latte+=X[i]*2-3;\n            s+=X[i]*2-3+2;\n        }\n    }\n\n    int ret=0;\n    for(int k=0;latte+k<=N;k++){\n        int y=N-latte-k;\n        add(ret,nCk(y+1,n)*nCk(s-1+k,k)%mod);\n\n    }\n    ret=ret*fact[n]%mod;\n    rep(i,ei.size())ret=ret*inv[ei[i].se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 77,mo=1e9+7;const ll MOD=7LL*mo*mo;\nint res,mx,n,k,C[N*2][N*2],sz[N],cnt[N],f[N];char S[N];\nvoid dfs(int dep, int least){\n\tif(dep>mx){\n\t\tstatic int r[N],b[N];int extra=0;\n\t\trep(i,1,mx)r[i]=cnt[i],b[i]=0;\n\t\trep(t,1,k)\n\t\t\tif(S[t]=='r'){\n\t\t\t\tbool find=0;\n\t\t\t\tper(i,mx,1)if(r[i]){\n\t\t\t\t\tfind=1;r[i]--;b[i-1]++;break;\n\t\t\t\t}\n\t\t\t\tif(!find&&extra)extra--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbool find=0;\n\t\t\t\tper(i,mx,1)if(b[i]){\n\t\t\t\t\tfind=1;b[i]--;extra+=i-1;break;\n\t\t\t\t}\n\t\t\t\tif(!find&&extra)extra--;\n\t\t\t}\n\t\trep(i,1,mx)if(r[i]||b[i])return;if(extra)return;\n\t\tmemset(f,0,sizeof(f));int tot=0,cur=0,ans=1;f[0]=1;\n\t\tstatic int hz[N];per(i,mx,1)hz[i]=hz[i+1]+cnt[i]*sz[i];\n\t\trep(y,1,mx)if(cnt[y]){\n\t\t\tans=1LL*ans*C[cur+cnt[y]][cur]%mo;\n\t\t\tcur+=cnt[y];\n\t\t}\n\t\tint A=cur-1,B=2;if(!cur)A=0,B=1;\n\t\trep(y,1,mx)if(cnt[y]){A+=cnt[y]*sz[y];if(y>1)B+=2*cnt[y];}\n\t\tres=(res+1LL*ans*C[n+B-1][A+B-1])%mo;\n\t//\trep(i,1,mx)printf(\"%d \",cnt[i]);printf(\"-->%d\\n\",res);\n\t\treturn;\n\t}\n\tfor(int x=0;least+x*(1+sz[dep])<=n;x++)\n\t\tcnt[dep]=x,dfs(dep+1,least+x*(1+sz[dep]));\n}\nint main() {\n\tread(n);read(k);scanf(\"%s\",S+1);\n\trep(i,0,(n+3)*2){\n\t\tC[i][0]=C[i][i]=1;\n\t\trep(j,1,i-1)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\t}\n\tmx=(n+3)/2;\n\tsz[1]=1;rep(i,2,mx)sz[i]=2*i-3;\n\tdfs(1,-1);cout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[N], tmp[N], top = 0;\nchar str[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nlong long solve () {\n\tfor (int i = 0; i < m; i++) suf[i] = 1;\n\tfor (int i = top - 1; i >= 0; i--) {\n\t\tint first_r = m;\n\t\tfor (int j = m - 1; j >= 0; j--) {\n\t\t\tif (suf[j] && str[j] == 'r') first_r = j;\n\t\t}\n\t\tif (first_r >= m) return 0ll;\n\t\tif (!stk[i]) suf[pos[i] = first_r] = 0;\n\t\telse {\n\t\t\tint first_b = m;\n\t\t\tfor (int j = m - 1; j >= first_r; j--) {\n\t\t\t\tif (suf[j] && str[j] == 'b') first_b = j;\n\t\t\t}\n\t\t\tif (first_b >= m) return 0ll;\n\t\t\tsuf[first_r] = suf[pos[i] = first_b] = 0;\n\t\t}\n\t}\n\n\tsuf[m] = 0;\n\tfor (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n\tfor (int i = 0, j = 0; i < top; i++) {\n\t\tif (stk[i]) {\n\t\t\tj += stk[i] - 1;\n\t\t\tif (suf[pos[i]] < j) return 0ll;\n\t\t}\n\t}\n\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=220,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,ans,a[N],s[N],pos[N],C[N][N],po[N],inv[N];\nchar ch[N];bool h[N];\nint get_nex(char c,int i){\n\tfor (;(i<=m)&&(h[i]||(ch[i]!=c));i++);\n\treturn i;\n}\nint get_n(int i){\n\tfor (;(i<=m)&&h[i];i++);\n\treturn i;\n}\nbool check(int dep){\n\tmemset(h,0,m+1);\n\tfor (int i=1;i<=dep;i++){\n\t\tpos[i]=get_nex('r',1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\tfor (int i=1;i<=dep;i++)\n\tif (a[i]>1){\n\t\tpos[i]=get_nex('b',pos[i]+1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\tfor (int i=1;i<=dep;i++)\n\tfor (int j=3;j<=a[i];j++){\n\t\tpos[i]=get_n(pos[i]+1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\treturn true;\n}\nvoid calc(int res,int r,int dep){\n\tint t=po[dep-1],s1=n+1,s2=0;\n\tfor (int i=1;i<=n;i++){\n\t\tt=(ll)t*inv[s[i]]%p;\n\t\ts1+=(i>1)*2*s[i];\n\t\ts2+=2*s[i]*i;\n\t}\n\tif ((s1<s2)||(!check(dep-1))) return;\n\tans=(ans+(ll)t*C[s1][s2])%p;\n\tfor (int i=1;i<=r;i++){\n\t\ta[dep]=i;s[i]++;\n\t\tcalc(res-i,min(i,res-i),dep+1);\n\t\ts[i]--;\n\t}\n\ta[dep]=0;\n}\nint main(){\n\tn=read();m=read();\n\tscanf(\" %s\",ch+1);\n\tC[0][0]=po[0]=inv[0]=1;\n\tfor (int i=1;i<=214;i++){\n\t\tC[i][0]=1;po[i]=(ll)po[i-1]*i%p;\n\t\tinv[i]=qpow(po[i],p-2);\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tcalc(n,n,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 200\nchar s[MN+5];\nmint F[MN+5],R[MN+5],ans;\nint n,a[MN+5],an,b[MN+5],bn,u[MN+5],p[MN+5];\ninline mint C(int n,int m){return F[n]*R[m]*R[n-m];}\nvoid dfs(int x,int y,int z,int s0)\n{\n\tint i,j,k;\n\tmemset(u,0,sizeof(u));\n\tfor(i=j=1;i<z;++i)if(p[z-i])\n\t{\n\t\twhile(j<=bn&&b[j]<a[i])++j;\n\t\tif(j>bn)break;\n\t\tu[a[i]]=u[b[j++]]=1;\n\t}\n\tif(i==z)for(i=j=1;i<z;++i)\n\t{\n\t\tfor(k=1;k<p[z-i];++k)\n\t\t{\n\t\t\twhile(s[j]&&(j<i||u[j]))++j;\n\t\t\tif(!s[j++])break;\n\t\t}\n\t\tif(k<p[z-i])break;\n\t}\n\tif(i==z)\n\t{\n\t\tmint s=F[z-1];\n\t\tfor(i=1;i<z;s*=R[j-i],i=j)for(j=i;j<z&&p[i]==p[j];++j);\n\t\tif(2*(z-1+x)>n+2*(z-1-s0)||n+2*(z-1-s0)>141)while(true);\n\t\tans+=s*C(n+2*(z-1-s0),2*(z-1+x));\n\t}\n\tif(z<=an)for(;x+y<=an+bn-z&&x+y+s0+!y<=n/2;++y)dfs(x+y,p[z]=y,z+1,s0+!y);\n}\nint main()\n{\n\tint m,i;\n\tscanf(\"%d%d%s\",&n,&m,s+1);++n;\n\tfor(F[0]=i=1;i<=MN;++i)F[i]=F[i-1]*i;\n\tfor(R[i=MN]=~F[MN];i--;)R[i]=R[i+1]*(i+1);\n\tfor(i=1;i<=m;++i)(s[i]=='r'?a[++an]:b[++bn])=i;\n\tdfs(0,0,1,0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 510;\nconst int mod = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check()\n{\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    FOR(i, 1, k)\n    {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update()\n{\n    ll tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1)\n    {\n        for(j = i; a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % mod;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % mod;\n    if ((ans += tmp) >= mod) ans -= mod;\n}\n\nvoid dfs(int mx)\n{\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    ++tot; --left; dfs(a[tot] = 1); ++left;\n    FOR(i, 2, mx)\n    {\n        left -= i * 2 - 3;\n        dfs(a[tot] = i);\n        left += i * 2 - 3;\n    }\n    a[tot--] = 0;\n    if (tot) ++left;\n}\n\nint main()\n{\n    FOR(i, 0, 500)\n    {\n        c[i][0] = 1;\n        FOR(j, 1, 500)\n            if ((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= mod)\n                c[i][j] -= mod;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(100);\n    printf(\"%d\\n\", (ans + 1) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 75;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m; char s[MAXN];\nint dp[2][MAXN][MAXN][MAXN][4];\nbool vis[MAXN][MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"\\n%s\", s + 1);\n\tvis[0][0][0][0] = true;\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 0; j <= i; j++)\n\t\tfor (int k = 0; k <= j; k++)\n\t\tfor (int l = k; l <= i; l++) {\n\t\t\tif (!vis[i - 1][j][k][l]) continue;\n\t\t\tvis[i][j][k][l] = true;\n\t\t\tif (s[i] == 'r') {\n\t\t\t\tvis[i][j + 1][k][l] = true;\n\t\t\t\tif (k != 0) vis[i][j][k][l + 1] = true;\n\t\t\t} else {\n\t\t\t\tif (k < j) vis[i][j][k + 1][l + 1] = true;\n\t\t\t\tif (k != 0) vis[i][j][k][l + 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j <= m; j++)\n\tfor (int k = 0; k <= j; k++)\n\tfor (int l = k; l <= m; l++)\n\t\tdp[0][j][k][l][0] = vis[m][j][k][l];\n\t//state: 0 -> w, 1 -> r, 2 -> b*, 3 -> r*\n\t//j -> segments, k -> with b, l -> cntb\n\tfor (int i = 1, dest = 1, from = 0; i <= n; i++, swap(dest, from)) {\n\t\tmemset(dp[dest], 0, sizeof(dp[dest]));\n\t\tfor (int j = 0; j <= m; j++)\n\t\tfor (int k = 0; k <= m; k++)\n\t\tfor (int l = 0; l <= m; l++) {\n\t\t\tint tmp = dp[from][j][k][l][0];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 0 + w\n\t\t\tif (j) update(dp[dest][j - 1][k][l][1], tmp); // 0 + r\n\t\t\tif (j && k && l) update(dp[dest][j - 1][k - 1][l - 1][2], tmp); // 0 + b\n\t\t\t\n\t\t\ttmp = dp[from][j][k][l][1];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 1 + w\n\t\t\tupdate(dp[dest][j][k][l][1], tmp); // 1 + r\n\t\t\tif (k && l) update(dp[dest][j][k - 1][l - 1][2], tmp); // 1 + b\n\t\t\t\n\t\t\ttmp = dp[from][j][k][l][2];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 2 + w\n\t\t\tupdate(dp[dest][j][k][l][3], tmp); // 2 + r\n\t\t\tupdate(dp[dest][j][k][l][2], tmp); // 2 + b\n\t\t\t\n\t\t\ttmp = dp[from][j][k][l][3];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 3 + w\n\t\t\tupdate(dp[dest][j][k][l][3], tmp); // 3 + r\n\t\t\tif (l) update(dp[dest][j][k][l - 1][2], tmp); // 3 + b\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= 3; i++)\n\t\tupdate(ans, dp[n & 1][0][0][0][i]);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int oo = 0x3f3f3f3f;\n \ntemplate<typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48; \n    return x *= f;\n}\n\nconst int N = 200;\nconst int mo = 1e9 + 7;\n\nint n, k, ans;\nchar st[N + 5];\nbool mark[N + 5];\nint x[N + 5], y[N + 5], r[N + 5];\n\nint binom[N + 5][N + 5];\n\nvoid init() {\n    for(int i = 0; i <= N; ++i) {\n        binom[i][0] = binom[i][i] = 1;\n        for(int j = 1; j < i; ++j) {\n            binom[i][j] = (binom[i-1][j] + binom[i-1][j-1]) % mo;\n        }\n    }\n}\n\nint dp[N + 5][N + 5][N + 5];\n\nint calc(int p, int q) {\n    for(int i = 0; i <= 90; ++i) \n    for(int j = 0; j <= 90; ++j) \n    for(int t = 0; t <= 90; ++t) dp[i][j][t] = 0;\n\n    int m = n - (p+q-1) - q;\n\n    dp[0][0][0] = 1;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j <= p; ++j) {\n            for(int l = 0; l <= m; ++l) if(dp[i][j][l]) {\n                for(int t = 0; j + t <= p && l + (2*i+1) * t <= m; ++t) {\n                    if(t && y[p-j-t+1] < (l-j)/2 + t*i) {\n                        break;\n                    }\n\n                    (dp[i+1][j + t][l + (2*i+1) * t] += 1ll * binom[j + q + t][t] * dp[i][j][l] % mo) %= mo;\n                }\n            }\n        }\n    }\n\n    int res = 0;\n    for(int i = 0; i <= m; ++i) {\n        res = (res + 1ll * binom[n + 2*p + 1][i + 3*p + 2*q] * dp[m][p][i]) % mo;\n    }\n    return res;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    init();\n    read(n), read(k);\n    scanf(\"%s\", st + 1);\n\n    for(int i = 1; i <= k; ++i) \n        if(st[i] == 'r') r[++ r[0]] = i;\n\n    for(int i = 0; i <= r[0]; ++i) {\n        for(int j = 0; i+j <= r[0]; ++j) {\n\n            memset(mark, 0, sizeof mark);\n            for(int t = 1; t <= i+j; ++ t) mark[r[t]] = true;\n\n            int cur = 0, flag = 0;\n            for(int t = 1; t <= i; ++ t) {\n                chkmax(cur, r[t]);\n                while(cur <= k && (st[cur] == 'r' || mark[cur])) ++ cur;\n                if(cur > k) { flag = 1; break; }\n\n                mark[x[t] = cur] = true;\n            }\n            if(flag) continue;\n\n            for(int t = 1; t <= i; ++ t) {\n                y[t] = 0;\n                for(int l = x[t]; l <= k; ++ l) {\n                    y[t] += !mark[l];\n                }\n            }\n            ans = (ans + calc(i, j)) % mo;\n        }\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, x, n) for(int i=x;i<=n;i++)\n#define pr make_pair\n#define fi first\n#define se second\n\nconst int MOD = int(1E9) + 7;\nconst int MAX = 420000;\nconst int HASHSIZE = 1000037;\n\ninline int add(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int sub(int x, int y) {x -= y; return x < 0 ? x + MOD : x;}\ninline int mul(int x, int y) {return (int) (1LL * x * y % MOD);}\nint mpow(int b, int p) {\n\tint r; for(r=1;p;p>>=1,b=mul(b,b))\n\t\tif( p & 1 ) r = mul(r, b);\n\treturn r;\n}\n\nstruct node{\n\tint x[40], cnt;\n\tint get() {\n\t\tint h = 0;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\th = (131LL*h + x[i]) % HASHSIZE;\n\t\treturn h;\n\t}\n\tvoid print() {\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tprintf(\"%d%c\", x[i], i + 1 == cnt ? '\\n' : ' ');\n\t}\n\tbool equal(const node &b) {\n\t\tif( cnt != b.cnt ) return false;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tif( x[i] != b.x[i] ) return false;\n\t\treturn true;\n\t}\n}st[MAX + 5];\nvector<pair<node, int> >h[HASHSIZE];\nvoid insert(node a, int i) {h[a.get()].push_back(pr(a, i));}\nint search(node a) {\n\tint x = a.get();\n\tfor(unsigned i=0;i<h[x].size();i++)\n\t\tif( a.equal(h[x][i].fi) ) return h[x][i].se;\n\treturn -1;\n}\n\nint l[75], tot, N, K;\nvoid dfs(int s, node a, int x) {\n\ttot++, insert(st[tot] = a, tot);\n\tfor(int i=x;i<=N&&l[i]<=s;i++)\n\t\ta.x[a.cnt++] = i, dfs(s - l[i], a, i), a.x[--a.cnt] = i;\n}\n\nint f[MAX + 5], fct[505], ifct[505], c[505][505];\nvoid init() {\n\trep(i, 0, 500) rep(j, 0, i)\n\t\tc[i][j] = (j == 0 ? 1 : add(c[i - 1][j], c[i - 1][j - 1]));\n\tfct[0] = 1; rep(i, 1, 500) fct[i] = mul(fct[i - 1], i);\n\tifct[500] = mpow(fct[500], MOD - 2);\n\tfor(int i=499;i>=0;i--) ifct[i] = mul(ifct[i + 1], i + 1);\n\t\n\tl[1] = 2; rep(i, 2, N) l[i] = (i - 1) << 1; dfs(N, (node){}, 1);\n\trep(i, 1, tot) {\n\t\tint a = 1, b = 0, t = 1, p = 1;\n\t\trep(j, 1, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != st[i].x[j-1] )\n\t\t\t\tt = mul(t, ifct[p]), p = 1;\n\t\t\telse p++;\n\t\t}\n\t\tt = mul(t, ifct[p]);\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tb += l[st[i].x[j]];\n\t\t\tif( st[i].x[j] != 1 ) a += 2;\n\t\t}\n\t\tf[i] = mul(mul(fct[st[i].cnt], t), c[N + a - 1][a + b - 1]);\n\t}\n//\tprintf(\"%d\\n\", tot);\n}\n\nint tg[75], q[75]; char s[75];\nint main() {\n\tscanf(\"%d%d%s\", &N, &K, s + 1), N++, init();\n\t\n\tint ans = 0;\n\trep(i, 1, tot) {\n\t\tint cnt1 = 0, pos = -1;\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != 1 ) {\n\t\t\t\tpos = j;\n\t\t\t\tbreak;\n\t\t\t} else cnt1++;\n\t\t}\n\t\t\n\t\tint hd = 1, tl = 0, p = st[i].cnt - cnt1;\n\t\trep(j, 1, K) tg[j] = -1;\n\t\tfor(int j=1;p&&j<=K;j++) {\n\t\t\tif( s[j] == 'r' ) q[++tl] = j;\n\t\t\telse if( hd <= tl ) tg[q[hd++]] = 0, tg[j] = 1, p--;\n\t\t}\n\t\t\n\t\tint cnt[2] = {}; bool flag = true;\n\t\tfor(int j=K;j>=1;j--) {\n\t\t\tif( tg[j] == -1 ) cnt[s[j] == 'r' ? 0 : 1]++;\n\t\t\telse if( tg[j] == 1 ) {\n\t\t\t\tint tmp = st[i].x[pos] - 2;\n\t\t\t\twhile( cnt[1] && tmp ) cnt[1]--, tmp--;\n\t\t\t\twhile( cnt[0] && tmp ) cnt[0]--, tmp--;\n\t\t\t\tif( tmp ) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( flag && cnt[0] >= cnt1 && p == 0 ) ans = add(ans, f[i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(p + 2*g > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(int len) {\n    int pos1 = 0, pos2 = 0;\n    for(int i = 0; i < len; i++) {\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        pos1++;\n        pos2++;\n    }\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n        if(N - x - (int)f.size() + 1 < 0) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + 2*f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        int len = 0;\n        for(int i = 0; i < f.size(); i++) {\n            if(f[i] != 0) len++;\n        }\n\n        if(chk(len)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint fac[142], ifac[142], ans, n, k;\nbool del[75];\nvector<int> f, r;\nchar s[75];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nbool check() {\n\tfill(del + 1, del + 1 + k, false);\n\tfor (int i = 0; i < f.size(); ++i) del[r[i]] = true;\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 2) {\n\t\t\tint j;\n\t\t\tfor (j = r[f.size() - 1 - i] + 1; (del[j] || s[j] == 'r') && j <= k; ++j);\n\t\t\tif (j > k) return false;\n\t\t\tdel[j] = true;\n\t\t}\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 3) {\n\t\t\tint cnt = f[i] - 2;\n\t\t\tfor (int j = r[f.size() - 1 - i] + 1; cnt && j <= k; ++j)\n\t\t\t\tif (!del[j]) del[j] = true, --cnt;\n\t\t\tif (cnt) return false;\n\t\t}\n\treturn true;\n}\n\nvoid dfs(int lst, int sum) {\n\tif (f.size() > r.size()) return;\n\tif (check()) {\n\t\tint s = n + 1, c = fac[f.size()], s1 = 0;\n\t\tfor (int i = 0, j; i < f.size(); i = j) {\n\t\t\tfor (j = i + 1; j < f.size() && f[j] == f[i]; ++j);\n\t\t\tc = 1ll * c * ifac[j - i] % P;\n\t\t\tif (f[i] > 1) s += 2 * (j - i);\n\t\t\ts1 += 2 * f[i] * (j - i);\n\t\t}\n\t\tans = (ans + 1ll * c * fac[s] % P * ifac[s1] % P * ifac[s - s1]) % P;\n\t}\n\tfor (int i = lst; (sum + max(1, i - 1)) * 2 <= n + 1; ++i) f.push_back(i), dfs(i, sum + max(1, i - 1)), f.pop_back();\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &k, s + 1);\n\tfor (int i = 1, j = 1; i <= k; ++i)\n\t\tif (s[i] == 'r') r.push_back(i);\n\tfor (int i = fac[0] = 1; i <= 2 * n + 1; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[2 * n + 1] = power(fac[2 * n + 1], P - 2);\n\tfor (int i = 2 * n + 1; i; --i) ifac[i - 1] = 1ll * ifac[i] * i % P;\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define N 72\n#define mod 1000000007\nint n,m,st[N],c[N][N],dp[N][N],as,fr[N];\nchar s[N];\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint solve(int k)\n{\n\tint v1=0,v3=k,v2=k;\n\tfor(int i=1;i<=m;i++)\n\tif(s[i]=='r')\n\tif(v3>0)v3--;\n\telse v1-=v1>0;\n\telse if(v2>v3&&st[v2]>1)v1+=st[v2]-2,v2--;\n\telse v1-=v1>0;\n\tif(st[v2]>1||v3||v1)return 0;\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=fr[k];\n\tint ls=1;\n\tfor(int i=2;i<=k;i++)if(st[i]==st[i-1])ls++;\n\telse dp[0][0]=1ll*pw(fr[ls],mod-2)*dp[0][0]%mod,ls=1;\n\tdp[0][0]=1ll*pw(fr[ls],mod-2)*dp[0][0]%mod;\n\tfor(int i=1;i<=n;i++)dp[0][i]=dp[0][0];\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tfor(int j=0;j<=n;j++)\n\t\tif(dp[i-1][j])\n\t\tfor(int l=j+2*st[i]-(st[i]>1?2:0);l<=n;l++)\n\t\t{\n\t\t\tint v1=l-j-(2*st[i]-(st[i]>1?2:0)),v2=2*st[i]-1;\n\t\t\tdp[i][l]=(dp[i][l]+1ll*dp[i-1][j]*c[v1+v2-1][v2-1])%mod;\n\t\t}\n\t\tfor(int j=1;j<=n;j++)dp[i][j]=(dp[i][j]+dp[i][j-1])%mod;\n\t}\n//\tif(dp[k][n])printf(\"%d\\n\",dp[k][n]);\n\treturn dp[k][n];\n}\nvoid dfs(int d,int su)\n{\n\tif(su<=35)as=(as+solve(d-1))%mod;else return;\n\tfor(int i=st[d-1];i<=36-su;i++)st[d]=i,dfs(d+1,su+i-(i>1));\n}\nint main(){scanf(\"%d%d%s\",&n,&m,s+1);n++;for(int i=0;i<=70;i++)c[i][0]=c[i][i]=1;for(int i=2;i<=70;i++)for(int j=1;j<i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;fr[0]=1;for(int i=1;i<=70;i++)fr[i]=1ll*fr[i-1]*i%mod;st[0]=1;dfs(1,0);printf(\"%d\\n\",as);}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%1000000007\n#define mod 1000000007\n#define Mod 1000000005\n#define ll long long\n//#define file\nusing namespace std;\n\nll f[71][71][71],g[71][71][71],jc[201],Jc[201],ans;\nint d[71],n,m,i,j,k,l,x,y;\nchar a[71];\nbool bz[71];\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;};\nll C(int n,int m) {if (n<m) return 0;return jc[n]*Jc[m]%mod*Jc[n-m]%mod;}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc089F.in\",\"r\",stdin);\n\t#endif\n\t\n\tjc[0]=1;\n\tfo(i,1,200) jc[i]=jc[i-1]*i%mod;\n\tJc[200]=qpower(jc[200],Mod);\n\tfd(i,199,0) Jc[i]=Jc[i+1]*(i+1)%mod;\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1);\n\tans=1;\n\tfo(x,0,n/2)\n\t{\n\t\tfo(y,0,n)\n\t\tif (x || y)\n\t\t{\n\t\t\tmemset(bz,0,sizeof(bz));\n\t\t\tfo(i,1,x)\n\t\t\t{\n\t\t\t\tfo(j,1,m) if (!bz[j] && a[j]=='r') break;\n\t\t\t\tfo(k,j,m) if (!bz[k] && a[k]=='b') break;\n\t\t\t\tif (k>m) break;\n\t\t\t\tbz[j]=bz[k]=1;\n\t\t\t}\n\t\t\tif (k>m) continue;\n\t\t\tl=0;\n\t\t\tfo(i,1,m) if (l<y && !bz[i] && a[i]=='r') ++l,bz[i]=1;\n\t\t\tif (l<y) continue;\n\t\t\t\n\t\t\tl=0;\n\t\t\tfo(j,1,m)\n\t\t\tif (bz[j] && a[j]=='b')\n\t\t\t{\n\t\t\t\td[++l]=0;\n\t\t\t\tfo(k,j,m) d[l]+=!bz[k];\n\t\t\t}\n\t\t\t\n\t\t\tmemset(f,0,sizeof(f)),f[0][0][d[1]]=1;\n\t\t\tfo(i,0,x-1)\n\t\t\t{\n\t\t\t\tfo(j,0,d[1])\n\t\t\t\t{\n\t\t\t\t\tfd(k,d[1],0)\n\t\t\t\t\tif (f[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k>=1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tadd(f[i][j][k-1],f[i][j][k]);\n\t\t\t\t\t\t\tfo(l,1,x-i)\n\t\t\t\t\t\t\tif (j+l*k<=d[1] && k<=d[i+l])\n\t\t\t\t\t\t\tadd(f[i+l][j+l*k][k-1],f[i][j][k]*C(i+l+y,l));\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\tadd(f[x][j][k],f[i][j][k]*C(x+y,x-i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfo(j,0,d[1])\n\t\t\t{\n\t\t\t\tfo(k,0,d[1])\n\t\t\t\t{\n\t\t\t\t\tfo(l,0,n)\n\t\t\t\t\tadd(ans,f[x][j][k]*C(l+(y+2*j+x*3)-1,(y+2*j+x*3)-1)%mod*C(n-(x+y-1)-2*j-l,x+y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[N], tmp[N], top = 0;\nchar str[K];\nlong long c[N * 5][N * 5], ans = 0ll;\n\nlong long solve () {\n\tqueue<int> que;\n\tfor (int i = 0; i < m; i++) suf[i] = 1;\n\tfor (int i = 0, j = top - 1; i < m && j >= 0; i++) {\n\t\tif (str[i] == 'r') que.push(i);\n\t\tif (stk[j] && str[i] == 'b' && !que.empty()) {\n\t\t\tsuf[que.front()] = suf[i] = 0;\n\t\t\tque.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\twhile (j >= 0 && !stk[j] && !que.empty()) {\n\t\t\tsuf[que.front()] = 0, que.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\tif (i == m - 1 && j >= 0) return 0ll;\n\t}\n\n\tsuf[m] = 0;\n\tfor (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n\tfor (int i = 0, j = 0; i < top; i++) {\n\t\tif (stk[i]) {\n\t\t\tj += stk[i] - 1;\n\t\t\tif (suf[pos[i]] < j) return 0ll;\n\t\t}\n\t}\n\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tassert(num1 + num2 - 1 <= n * 3);\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 5; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 0; i <= n * 5; i++) {\n\t\tfor (int j = 0; j <= n * 5; j++) c[i][j] = 0ll;\n\t}\n\tfor (int i = 1; i <= n * 5; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void add(int &x,int y) {\n  ((x+=y)>=MOD)?x-=MOD:0;\n} \n\nll C[105][105];\n\nvoid pre(int n) {\n  for(int i=0;i<=n;i++) C[i][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n}\n\nint f[85][85][85],up[85];\nint sum[85];\n\nvoid dp(int n,int m,int c) {\n  memset(f,0,sizeof(f));\n  int t=m+2*c-1;\n  f[0][0][0]=1;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<=up[i]&&2*j-m+t<=n;j++) {\n      int s=f[i][j][0];\n      for(int k=1;k<=up[m]&&j+(m-i)*k<=up[m];k++) {\n      \tfor(int l=1;i+l<=m&&j+l*k<=up[i+l];l++)\n      \t  add(f[i+l][j+l*k][k],s*C[i+l][l]%MOD);\n      \tadd(s,f[i][j][k]);\n\t  }\n    }\n  for(int i=0;i<=up[m]&&2*i-m+t<=n;i++) {\n  \tint s=0;\n  \tfor(int j=0;j<=i;j++) add(s,f[m][i][j]);\n  \tif (!s) continue;\n  \tint v=2*i-m+t;\n  \tfor(int j=0;j<=2*m+2&&v+j<=n;j++)\n  \t  add(sum[v+j],s*C[m+c][c]%MOD*C[2*m+2][j]%MOD);\n  }\n}\n\nchar str[85];\n\nint st[85],lpos[85];\nbool vis[85];\n\nint main() {\n  int n,k;\n  scanf(\"%d%d%s\",&n,&k,str+1);\n  pre(100);\n  for(int i=0;2*i<=k;i++) {\n  \tmemset(vis,0,sizeof(vis));\n  \tint cnt=0,top=0;\n  \tfor(int j=1;j<=k&&cnt<i;j++)\n  \t  if (str[j]=='r') st[++top]=j;\n  \t  else if (top) {\n  \t  \t  vis[st[top--]]=vis[j]=1;\n  \t  \t  lpos[++cnt]=j;\n\t\t}\n\tif (cnt<i) continue;\n\tint s=0;\n\tfor(int j=1;j<=k;j++)\n\t  if (!vis[j]&&str[j]=='r') s++;\n\tint r=1;\n\tlpos[i+1]=k+1;up[i+1]=0;\n\tfor(int j=0;j<=s;j++) {\n\t\tif (j) {\n\t\t\twhile (vis[r]||str[r]!='r') r++;\n\t\t\tvis[r]=1;\n\t\t}\n\t\tfor(int t1=i;t1>0;t1--) {\n\t\t\tup[t1]=up[t1+1];\n\t\t\tfor(int t2=lpos[t1+1]-1;t2>lpos[t1];t2--)\n\t\t\t  if (!vis[t2]) up[t1]++;\n\t\t\tup[t1]++;\n\t\t}\n\t\treverse(up+1,up+i+1);\n\t\tdp(n,i,j);\n\t}\n  }\n  int ans=0;\n  for(int i=1;i<=n;i++) add(ans,sum[i]*C[n-1][i-1]%MOD);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvoid mod_inverse(int n, vector<long long>& inv, int mod)\n{\n    inv.assign(n+1, -1);\n    inv[1] = 1;\n    for(int i=2; i<=n; ++i)\n        inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n}\n\nclass FactorialCalculation\n{\nprivate:\n    const int mod;\n    vector<long long> factorial;\n    vector<long long> invFactorial;\npublic:\n    FactorialCalculation(int n, int mod) : mod(mod)\n    {\n        factorial.resize(n+1, 1);\n        invFactorial.resize(n+1, 1);\n        vector<long long> inv;\n        mod_inverse(n, inv, mod);\n        for(int i=1; i<=n; ++i){\n            factorial[i] = factorial[i-1] * i % mod;\n            invFactorial[i] = invFactorial[i-1] * inv[i] % mod;\n        }\n    }\n    long long getFactorial(int n){\n        return factorial[n];\n    }\n    long long getInvFactorial(int n){\n        return invFactorial[n];\n    }\n    long long getPermutation(int n, int r){\n        if(n < r)\n            return 0;\n        return factorial[n] * invFactorial[n-r] % mod;\n    }\n    long long getCombination(int n, int r){\n        if(n < r)\n            return 0;\n        return getPermutation(n, r) * invFactorial[r] % mod;\n    }\n    long long getHomogeneous(int n, int r){\n        return getCombination(n+r-1, r);\n    }\n};\n\nconst long long MOD = 1000000007;\nFactorialCalculation fc(200, MOD);\n\nint ballNum, opeNum; // ボールの個数、操作列の長さ\nstring opeStr; // 操作列\n\nlong long calc(const vector<int>& v)\n{\n    int n = v.size();\n    int cnt = 1;\n    int sum = 1;\n    long long ans = 1;\n    for(int i=0; i<n; ++i){\n        if(i < n - 1 && v[i] == v[i+1]){\n            ++ cnt;\n        }\n        else{\n            ans *= fc.getHomogeneous(sum, cnt);\n            ans %= MOD;\n            sum += cnt;\n            cnt = 1;\n        }\n    }\n    return ans;\n}\n\nlong long solve(const vector<int>& v)\n{\n    int size = v.size();\n    vector<int> index(size+1, -1);\n    vector<bool> check(opeNum, false);\n    for(int i=size-1; i>=0; --i){\n        index[i] = index[i+1] + 1;\n        while(index[i] < opeNum && opeStr[index[i]] != 'r')\n            ++ index[i];\n        if(index[i] == opeNum)\n            return -1;\n        check[index[i]] = true;\n    }\n    for(int i=size-1; i>=0; --i){\n        if(v[i] > 1){\n            while(index[i] < opeNum && (check[index[i]] || opeStr[index[i]] != 'b'))\n                ++ index[i];\n            if(index[i] == opeNum)\n                return -1;\n            check[index[i]] = true;\n        }\n    }\n    for(int i=size-1; i>=0; --i){\n        for(int j=3; j<=v[i]; ++j){\n            while(index[i] < opeNum && check[index[i]])\n                ++ index[i];\n            if(index[i] == opeNum)\n                return -1;\n            check[index[i]] = true;\n        }\n    }\n\n    int cnt = v.size() + 1;\n    int rest = ballNum - (v.size() - 1);\n    for(int i=0; i<size; ++i){\n        cnt += v[i] * 2 - 1;\n        rest -= max(1, v[i] * 2 - 3);\n    }\n    if(rest < 0)\n        return -1;\n\n    long long ans = fc.getHomogeneous(cnt, rest);\n    ans *= calc(v);\n    ans %= MOD;\n    return ans;\n}\n\nlong long dfs(int a, vector<int> v)\n{\n    long long ans = 0;\n    for(;;){\n        v.push_back(a);\n        long long tmp = solve(v);\n        if(tmp == -1)\n            break;\n        ans += tmp;\n        ans %= MOD;\n\n        v.pop_back();\n        ans += dfs(a+1, v);\n        ans %= MOD;\n        v.push_back(a);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> ballNum >> opeNum >> opeStr;\n\n    long long ans = dfs(1, vector<int>()) + 1;\n    ans %= MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int oo = 0x3f3f3f3f;\n \ntemplate<typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48; \n    return x *= f;\n}\n\nconst int N = 200;\nconst int mo = 1e9 + 7;\n\nint n, k, ans;\nchar st[N + 5];\nbool mark[N + 5];\nint x[N + 5], y[N + 5], r[N + 5];\n\nint binom[N + 5][N + 5];\n\nvoid init() {\n    for(int i = 0; i <= N; ++i) {\n        binom[i][0] = binom[i][i] = 1;\n        for(int j = 1; j < i; ++j) {\n            binom[i][j] = (binom[i-1][j] + binom[i-1][j-1]) % mo;\n        }\n    }\n}\n\nint dp[N + 5][N + 5][N + 5];\n\nint calc(int p, int q) {\n    memset(dp, 0, sizeof dp);\n\n    int m = n - (p+q-1) - q;\n\n    dp[0][0][0] = 1;\n    for(int i = 0; i < m; ++i) {\n        for(int j = 0; j <= p; ++j) {\n            for(int l = 0; l <= m; ++l) if(dp[i][j][l]) {\n                for(int t = 0; j + t <= p && l + (2*i+1) * t <= m; ++t) {\n                    if(t && y[p-j-t+1] < (l-j)/2 + t*i) {\n                        break;\n                    }\n\n                    (dp[i+1][j + t][l + (2*i+1) * t] += 1ll * binom[j + q + t][t] * dp[i][j][l] % mo) %= mo;\n                }\n            }\n        }\n    }\n\n    int res = 0;\n    for(int i = 0; i <= m; ++i) {\n        res = (res + 1ll * binom[n + 2*p + 1][i + 3*p + 2*q] * dp[m][p][i]) % mo;\n    }\n    return res;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    init();\n    read(n), read(k);\n    scanf(\"%s\", st + 1);\n\n    for(int i = 1; i <= k; ++i) \n        if(st[i] == 'r') r[++ r[0]] = i;\n\n    for(int i = 0; i <= r[0]; ++i) {\n        for(int j = 0; i+j <= r[0]; ++j) {\n\n            memset(mark, 0, sizeof mark);\n            for(int t = 1; t <= i+j; ++ t) mark[r[t]] = true;\n\n            int cur = 0, flag = 0;\n            for(int t = 1; t <= i; ++ t) {\n                chkmax(cur, r[t]);\n                while(cur <= k && (st[cur] == 'r' || mark[cur])) ++ cur;\n                if(cur > k) { flag = 1; break; }\n\n                mark[x[t] = cur] = true;\n            }\n            if(flag) continue;\n\n            for(int t = 1; t <= i; ++ t) {\n                y[t] = 0;\n                for(int l = x[t]; l <= k; ++ l) {\n                    y[t] += !mark[l];\n                }\n            }\n            ans = (ans + calc(i, j)) % mo;\n        }\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=500;\nint binom[Vmax][Vmax];\nvoid Init(){\n\tbinom[0][0]=1;\n\tREP(i,Vmax)REP(j,Vmax){\n\t\tif(i-1>=0)add(binom[i][j],binom[i-1][j]);\n\t\tif(j-1>=0)add(binom[i][j],binom[i][j-1]);\n\t}\n}\nint Choose(int n,int k){\n\treturn binom[n-k][k];\n}\n\nconst int Nmax=75;\nint n,k;\nstring s;\nvi t;\nint SetT(){\n\tt.resize(k,inf);\n\tint j=0,cnt=0;\n\tREP(i,k)\n\t\tif(s[i]=='r'){\n\t\t\twhile(j<k&&(j<i||s[j]=='r'))\n\t\t\t\tj++;\n\t\t\tif(j==k)\n\t\t\t\tbreak;\n\t\t\tt[i]=cnt*2;\n\t\t\tt[j]=cnt*2+1;\n\t\t\tj++;\n\t\t\tcnt++;\n\t\t}\n\treturn cnt;\n}\n\nint dp[Nmax][Nmax][Nmax];\nvi Sigma(vi num){\n\tint p=num.size(),m=num.back();\n\tZERO(dp);\n\tdp[0][0][0]=1;\n\tREP(y,m+1){\n\t\tfor(int x=p;x>=0;x--){\n\t\t\tREP(sm,m+1){\n\t\t\t\tint cur=sm;\n\t\t\t\tFOR(z,x+1,p+1){\n\t\t\t\t\tcur+=y;\n\t\t\t\t\tif(cur>num[z-1])break;\n\t\t\t\t\tadd(dp[z][y][cur],dp[x][y][sm]*Choose(p-x,z-x));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(y<m)\n\t\tREP(x,p+1)\n\t\t\tREP(sm,m+1)\n\t\t\t\tadd(dp[x][y+1][sm],dp[x][y][sm]);\n\t}\n\treturn vi(dp[p][m],dp[p][m]+m+1);\n}\n\nint hog[Nmax];\n\nint semiBuf[Nmax][Nmax];\nvoid Semiexp(int u,int p,int w){\n\tif(u==0){\n\t\tadd(hog[1],w);\n\t}else{\n\t\tadd(hog[u+p-1],w);\n\t\tadd(hog[u+p],w*2);\n\t\tadd(hog[u+p+1],w);\n\t}\n}\n\n//p==0?\nvoid Wafrelka(int p,int q){\n\tvi z(k,0);\n\t{\n\t\tint cnt=0;\n\t\tREP(i,k)\n\t\t\tif(t[i]>=p*2&&s[i]=='r'&&cnt<q){\n\t\t\t\tz[i]=1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tif(cnt<q)return;\n\t}\n\tvi num(p,0);\n\t{\n\t\tint j=0;\n\t\tfor(int i=k-1;i>=0;i--)if(j<p){\n\t\t\tif(t[i]>=p*2){\n\t\t\t\tif(z[i]==0)\n\t\t\t\t\tnum[j]++;\n\t\t\t}else if(t[i]%2){\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,1,p)\n\t\tnum[i]+=num[i-1];\n\tif(p==0)num.PB(0);\n\tvi x=Sigma(num);\n\t//cerr<<p<<\" \"<<q<<\" \"<<x<<endl;\n\tREP(i,x.size()){\n\t\tREP(j,p*2+1){\n\t\t\tint w=Choose(p+q,p);\n\t\t\tif(p>0)mult(w,Choose(i+p-1,i));\n\t\t\tmult(w,Choose(p*2,j));\n\t\t\tint used=p+i*2+j+q;\n\t\t\tif(used+(p+q-1)<=n)\n\t\t\t\tadd(semiBuf[used][p+q],w);\n\t\t}\n\t}\n}\n\nint Wo(){\n\tint res=0;\n\tFOR(i,1,n+1)\n\t\tadd(res,hog[i]*Choose(n-1,i-1));\n\treturn res;\n}\n\nsigned main(){\n\tInit();\n\tn=read(),k=read();\n\ts=readString();\n\tint cnt=SetT();\n\t//cerr<<cnt<<endl;\n\tREP(p,cnt+1)REP(q,k-p*2+1)\n\t\tWafrelka(p,q);\n\tREP(i,n+1)REP(j,n+1)\n\t\tSemiexp(i,j,semiBuf[i][j]);\n\tcout<<Wo()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[80];\nint n, K, chk[80], Loc[40], C[40], F[150], InvF[150], Mod = 1000000007;\nint D[40][40], TD[40][40]; // 한 블럭의 크기, 블럭의 개수, 쓴거의 개수\n\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint Comb(int n, int r) {\n\treturn 1ll * F[n] * InvF[r] % Mod*InvF[n - r]%Mod;\n}\n\nint Do(int A, int B) { // R* : A, RBxx : B\n\tint i, c1 = 0, c2 = 0, j, k, ii, jj;\n\tif (!A && !B)return 1;\n\tfor (i = 0; i < K; i++) {\n\t\tchk[i] = 0;\n\t\tif (p[i] == 'r' && c1 < B) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t\tif (p[i] == 'b' && c2 < c1) {\n\t\t\tchk[i] = 1;\n\t\t\tc2++;\n\t\t\tLoc[c2] = i;\n\t\t}\n\t}\n\tif (c1 < B || c2 < B)return 0;\n\tc1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tif (p[i] == 'r' && !chk[i] && c1 < A) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t}\n\tif (c1 < A)return 0;\n\tfor (i = 1; i <= B; i++) {\n\t\tC[B-i+1] = 0;\n\t\tfor (j = Loc[i]; j < K; j++)if (!chk[j])C[B-i+1]++;\n\t}\n\tfor (i = 0; i < 40; i++)for (j = 0; j < 40; j++)D[i][j] = TD[i][j] = 0;\n\tD[0][0] = InvF[A];\n\n\tfor (i = 0; i <= n / 2; i++) {\n\t\tfor (j = 0; j < 40; j++) {\n\t\t\tfor (k = 0; k < 40; k++) {\n\t\t\t\tif (!D[j][k])continue;\n\t\t\t\tfor (ii = 0;; ii++) {\n\t\t\t\t\tint s = (ii*i + k);\n\t\t\t\t\tif (ii+j > B || s * 2 + A + B + (A + B - 1) > n || C[j+ii] < s)break;\n\t\t\t\t\tTD[j + ii][s] = (TD[j + ii][s] + 1ll * D[j][k] * InvF[ii]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 40; j++)for (k = 0; k < 40; k++) {\n\t\t\tD[j][k] = TD[j][k];\n\t\t\tTD[j][k] = 0;\n\t\t}\n\t}\n\tint r = 0;\n\tfor (i = 0; i < 40; i++) {\n\t\tint c = (A + B + A + B - 1 + i * 2);\n\t\tint t = c + B * 2 + 2;\n\t\tif (!D[B][i] || n-c < 0)continue;\n\t\tr = (r + 1ll * D[B][i] * F[A+B] % Mod * Comb(t + (n - c) - 1, (n - c)))%Mod;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, res = 0;\n\tF[0] = 1;\n\tfor (i = 1; i <= 142; i++)F[i] = 1ll * F[i - 1] * i%Mod;\n\tfor (i = 0; i <= 142; i++)InvF[i] = Pow(F[i], Mod - 2);\n\tscanf(\"%d%d\", &n, &K);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i <= (n+1)/2; i++) {\n\t\tfor (j = 0; i + j <= (n + 1) / 2; j++) {\n\t\t\tres = (res + Do(i, j))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, G[77][77], H[77][77], S[77], Fac[333], Rev[333];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nll C(ll x, ll y) {\n    if(!y) return 1;\n    if(x < 0 || y < 0 || x < y) return 0;\n    return Fac[x] * Rev[y] % P * Rev[x - y] % P;\n}\n\nll calc(ll x, ll n) {\n    ll ans = 0, nw = 1;\n    for(int i = 1; i <= n; i++) {\n        nw = nw * (x - i + 1) % P;\n        add(ans, nw * Rev[i] % P * H[n][i]);\n    }\n    return ans;\n}\n\nint X[77], ans = 0;\n\nvoid calc(int sz) {\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, C(r + rw - 1, r) * C(b + bw - 1, b) % P * C(sz + (t - r - b), sz) % P * tmp % P);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int fir) {\n    if(tbr > K) return;\n    calc(x - 1);\n    while(fir <= K && ch[fir] != 'r') fir++;\n    if(fir > K) return;\n    X[x] = 1;\n    Search(x + 1, 1, tbr + 1, fir + 1);\n    while(fir <= K && ch[fir] != 'b') fir++;\n    if(fir <= K) for(int i = 2; i <= lst && i + tbr <= K; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, fir);\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    G[0][0] = 1;\n    for(int s = 0; s <= 71; s++)\n        for(int i = 0; i <= 71; i++) {\n            add(G[i + 1][s], G[i][s]);\n            for(int j = i + 2; j <= 71; j++)\n                add(G[j][s + 1], G[i][s]);\n        }\n    H[0][0] = 1;\n    for(int i = 0; i <= 71; i++)\n        for(int j = i + 1; j <= 71; j++)\n            for(int s = 0; s <= 71; s++)\n                add(H[j][s + 1], H[i][s] * Rev[j - i]);\n    int totr = 0, totb = 0;\n    for(int i = 1; i <= K; i++) if(ch[i] == 'r') {\n        totr++;\n        S[totr] = totb + totr;\n    } else totb++;\n    S[totr + 1] = K + 1;\n    for(int i = totr + 2; i < 77; i++) S[i] = K + 2;\nif(K > 10) return 0;\n    Search(1, K, 0, 1);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 610\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint fac[N],inv[N],a[N],ans,n,k,r[N],b[N];\nchar ch[N]; bool vis[N];\nvoid init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[N-1]=ksm(fac[N-1],mdn-2);\n\tfor(int i=N-1;i;i--)\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%mdn*inv[n-m]%mdn;}\nint solve(int tot,int dat)\n{\n\tint cur=fac[tot],cnt=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(a[i]==a[i-1])\tcnt++;\n\t\telse\tcur=1ll*cur*inv[cnt]%mdn,cnt=1;\n\t}\n\tcur=1ll*cur*inv[cnt]%mdn;\n\tint pt=1; memset(vis,0,n+1);\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='r')\n\t\tif(pt<=tot)\tr[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot)\treturn 0; pt=1;\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='b')\n\t\tif(pt<=tot&&r[pt]<i&&a[pt]>=2)\tb[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot&&a[pt]>=2)\treturn 0; pt=1; int qwq=a[pt]-2;\n\tfor(int i=1;i<=k;i++)\tif(!vis[i])\n\t\tif(pt<=tot&&b[pt]<i&&qwq>0)\n\t\t{\n\t\t\tqwq--; if(!qwq)\tpt++,qwq=a[pt]-2;\n\t\t}\n\tif(qwq>0)\treturn 0;\n\treturn 1ll*dat*cur%mdn;\n}\nvoid dfs(int val,int x,int ful,int wei)\n{\n\tif(ful<wei)\treturn;\n\tif(!val)\treturn upd(ans,solve(x-1,C(ful,wei)));\n\tfor(int i=1;i<=min(val,a[x-1]);i++)\ta[x]=i,dfs(val-i,x+1,ful+(i>=2?2:0),wei+2*i);\n}\nint main()\n{\n\tn=read(),k=read(); init();\n\tscanf(\"%s\",ch+1); a[0]=n+1;\n\tfor(int i=1;i<=n;i++)\tdfs(i,1,n+1,0);\n\tprintf(\"%d\\n\",(ans+1)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K,C[1005][1005],L[75],fac[1005],invfac[1005],cnt;\nint sum[75],pos[75],tot,ans,matc[75];\nchar s[75];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nbool check() {\n    if(tot < cnt) return false;\n    memset(sum,0,sizeof(sum));\n    int p = 1;\n    for(int i = cnt ; i >= 1 ; --i) {\n\tsum[pos[i]]++;\n\tif(L[p] >= 2) {\n\t    sum[matc[i]] += L[p] - 1;\n\t}\n    }\n    for(int i = K ; i >= 1 ; --i) {\n\tsum[i] += sum[i + 1];\n\tif(sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\nbool dfs(int pre,int dep,int len) {\n    cnt = dep;\n    if(!check()) return false;\n    int k = 1 + cnt;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] == 1) ++k;\n        else k += 2 * L[i] - 1;\n    }\n    int res = C[N - len + k - 1][k - 1];\n    res = mul(res,fac[cnt]);\n    int t = 0;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] != L[i - 1]) {\n            res = mul(res,invfac[t]);\n            t = 0;\n        }\n        ++t;\n    }\n    res = mul(res,invfac[t]);\n    update(ans,res);\n    if(dep + 1 > tot) return true;\n    for(int i = pre ; i <= 70 ; ++i) {\n        int tl = len;\n        if(dep != 0) ++tl;\n        if(i == 1 || i == 2) tl += 1;\n        else tl += i - 2 + i - 1;\n        if(tl > N) break;\n        L[dep + 1] = i;\n        if(!dfs(i,dep + 1,tl)) break;\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);read(K);\n    scanf(\"%s\",s + 1);\n    C[0][0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) {\n        C[i][0] = 1;\n        for(int j = 1 ; j <= i ; ++j) {\n            C[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n        }\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000] = fpow(fac[1000],MOD - 2);\n    for(int i = 999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    tot = 0;\n    for(int i = 1 ; i <= K ; ++i) {\n        if(s[i] == 'r') pos[++tot] = i;\n\tfor(int j = i + 1 ; j <= K ; ++j) {\n\t    if(s[j] == 'b' && !matc[j]) {matc[i] = j;break;}\n\t}\n    }\n    dfs(1,0,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MOD = (int)1e9 + 7;\nconst int kN = 70 + 1;\nconst int kM = 10000;\nint n, k;\nchar s[kN];\nint Inv[kM], F[kM], Finv[kM];\n\nint binom(int a, int b)\n{\n    if (b < 0 || b > a) return 0;\n    return F[a] * 1LL * Finv[b] % MOD * Finv[a - b] % MOD;\n}\n\ninline void add(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nstd::vector<int> vec; // 每段B的数量\n\nint getBound(const std::vector<int> &vec)\n{\n    std::vector<int> used(k);\n    int j = 0, pa = 0;\n    for (int i = 0; i < k; ++ i) {\n        if (s[i] == 'r') {\n            if (pa < vec.size())\n                used[i] = -1, ++ pa;\n        } else if (j < pa) {\n            used[j ++] = 1;\n        }\n    }\n    if (j != vec.size()) return -1;\n    int left[2] = {};\n    for (int i = k - 1; i >= 0; -- i) {\n        if (used[i] == 0) {\n            left[s[i] == 'b'] ++;\n        } else if (used[i] > 0) {\n            int c = vec[-- j] - 1;\n            for (int w = 1; w >= 0; -- w) {\n                int tmp = std::min(left[w], c);\n                c -= tmp;\n                left[w] -= tmp;\n            }\n            if (c > 0) return 0;\n        }\n    }\n    return left[0];\n}\n\nint calc(const std::vector<int> &vec)\n{\n    int bound_a = getBound(vec);\n    if (bound_a < 0) return 0;\n    int ret = 0;\n    for (int a = 0; a <= bound_a; ++ a) {\n        int segc = vec.size() + a;\n        if (segc == 0) {\n            add(ret, 1); continue;\n        }\n        int len = a;\n        int hole = 1 + a * 2;\n        int ops = a;\n        for (int x : vec) len += x * 2 - 1, hole += x * 2 + 1 + 1, ops += x + 1;\n        if (ops > k || segc - 1 + len > n) break;\n        int coef = F[segc] * 1LL * Finv[a] % MOD;\n        for (int i = 0, j = 0; i < vec.size(); i = j ++) {\n            while (j < vec.size() && vec[j] == vec[i]) ++ j;\n            coef = coef * 1LL * Finv[j - i] % MOD;\n        }\n        add(ret, binom(n - len - segc + 1 + hole - 1, hole - 1) * 1LL * coef % MOD);\n    }\n    return ret;\n}\n\nint search(int at, int segc, int len, int ops)\n{\n    int ret = calc(vec);\n    if (ret == 0) return 0;\n    for (int i = at; ; ++ i) {\n        if (k < ops + i + 1 || n < segc + len + i * 2 - 1) break;\n        int h = vec.size();\n        for (int j = 1; ; ++ j) {\n            if (k < ops + (i + 1) * j || n < segc + j - 1 + len + (i * 2 - 1) * j) break;\n            vec.emplace_back(i);\n            add(ret, search(i + 1, segc + j, len + (i * 2 - 1) * j, ops + (i + 1) * j));\n        }\n        vec.resize(h);\n    }\n    return ret;\n}\n\nint main()\n{\n    Inv[1] = 1;\n    for (int i = 2; i < kM; ++ i)\n        Inv[i] = (MOD - MOD / i) * 1LL * Inv[MOD % i] % MOD;\n    F[0] = Finv[0] = 1;\n    for (int i = 1; i < kM; ++ i) {\n        F[i] = F[i - 1] * 1LL * i % MOD;\n        Finv[i] = Finv[i - 1] * 1LL * Inv[i] % MOD;\n    }\n    scanf(\"%d%d%s\", &n, &k, s);\n    printf(\"%d\\n\", search(1, 0, 0, 0));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int p=1000000007;\n\nint c[300][300],g[100],h[100];\nchar b[100];\nint i,j,k,l,m,n,r,s,t;\n\ninline void pre()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",b+1);\n\tfor (i=0;i<=250;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t\tif ((j==0) || (j==i))\n\t\t\t\tc[i][j]=1;\n\t\t\telse\n\t\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%p;\n\treturn;\n}\n\ninline void calc()\n{\n\tfor (i=1;i<=n;i++)\n\t\th[i]=g[i];\n\tt=0;\n\tfor (i=1,k=1,l=1;i<=m;i++)\n\t\tif ((b[i]=='r') && (h[k]>0))\n\t\t\th[k]--,k++;\n\t\telse\n\t\tif ((b[i]=='b') && (h[l]>0) && (l<k))\n\t\t\th[l]--,t=t+h[l],l++;\n\t\telse\n\t\tif (t>0)\n\t\t\tt--;\n\tif ((h[k]) || (h[l]) || (t))\n\t\treturn;\n\tr=1;\n\tfor (i=1;g[i];i=j)\n\t{\n\t\tfor (j=i;g[i]==g[j];j++);\n\t\tr=1LL*r*c[j-1][i-1]%p;\n\t\tif (g[i]==1)\n\t\t\tt=t+j-i;\n\t\telse\n\t\t\tt=t+(j-i)*(2*g[i]-3);\n\t}\n\tt=t+k-2;\n\tif (n-t<0)\n\t\treturn;\n\ts=(s+1LL*r*c[n+2*l-1][t+2*l-1])%p;\n\treturn;\n}\n\ninline void dfs(int w,int x,int y,int z)\n{\n\tif (w<0)\n\t\treturn;\n\tif (z)\n\t\tcalc();\n\tif (x)\n\t{\n\t\tg[z+1]=1,dfs(w-1,x-1,1,z+1);\n\t\tfor (int i=2;(i<=x) && (i<=y);i++)\n\t\t\tg[z+1]=i,dfs(w-2*i+3,x-i,i,z+1);\n\t\tg[z+1]=0;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tpre();\n\tdfs(n,m,m,0);\n\tprintf(\"%d\",(s+1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=70+10,mod=1e9+7;\nint n,k,cnt[maxn],a[maxn],m,beg[maxn];\nchar s[maxn];\nbool vis[maxn];\nll ans,fac[maxn],inv[maxn],c[maxn*10][maxn*10];\n\ninline ll qpow(ll a,ll n){\n\tll res=1;\n\twhile(n){\n\t\tif(n&1ll)\n\t\t\tres=res*a%mod;\n\t\ta=a*a%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nvoid init(){\n\tfac[0]=1;\n\tfor(int i=1;i<maxn;++i)\n\t\tfac[i]=fac[i-1]*i%mod;\n\tinv[maxn-1]=qpow(fac[maxn-1],mod-2);\n\tfor(int i=maxn-1;i;--i)\n\t\tinv[i-1]=inv[i]*i%mod;\n\tfor(int i=0;i<maxn*10;++i){\n\t\tc[i][0]=1;\n\t\tfor(int j=1;j<=i;++j)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n}\nvoid judge(int rest){\n\tm=0;\n\tfor(int i=n;~i;--i)\n\t\tfor(int j=0;j<cnt[i];++j)\n\t\t\ta[m++]=i;\n\tif(m==0){\n\t\tans=(ans+1)%mod;\n\t\treturn;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0,j=0;i<m;++i){\n\t\twhile(j<k&&s[j]=='b')\n\t\t\t++j;\n\t\tif(j==k)\n\t\t\treturn;\n\t\tvis[j]=true;\n\t\tbeg[i]=++j;\n\t}\n\tfor(int i=0,j=0;i<m&&a[i]>=1;++i){\n\t\tif(j<beg[i])j=beg[i];\n\t\twhile(j<k&&(s[j]=='r'||vis[j]))\n\t\t\t++j;\n\t\tif(j==k)\n\t\t\treturn;\n\t\tvis[j]=true;\n\t\tbeg[i]=++j;\n\t}\n\tfor(int i=0,j=0;i<m&&a[i]>=2;++i){\n\t\tif(j<beg[i])j=beg[i];\n\t\tint rest=a[i]-1;\n\t\twhile(rest){\n\t\t\twhile(j<k&&vis[j])\n\t\t\t\t++j;\n\t\t\tif(j==k)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tvis[j]=true,--rest;\n\t\t}\n\t\tif(rest)\n\t\t\treturn;\n\t\t++j;\n\t}\n\tll res=fac[m];\n\tfor(int i=0;i<=n;++i)\n\t\tres=res*inv[cnt[i]]%mod;\n\tint box=1;\n\tfor(int i=0;i<m;++i)\n\t\tif(a[i])\n\t\t\tbox+=2*a[i]+2;\n\t\telse\n\t\t\tbox+=2;\n\tres=res*c[box+rest-1][rest]%mod;\n\tans=(ans+res)%mod;\n}\nvoid dfs(int pos,int rest){\n\tif(!pos){\n\t\tfor(int i=0;i*2<=rest;++i){\n\t\t\tcnt[0]=i;\n\t\t\tjudge(rest-i*2);\n\t\t}\n\t\treturn;\n\t}\n\tfor(int i=0;i*2*pos<=rest;++i)\n\t\tcnt[pos]=i,dfs(pos-1,rest-i*2*pos);\n}\n\nint main(){\n\tinit();\n\tcin>>n>>k>>s;\n\tdfs(n,n+1);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 301, mod = 1000000007;\nint n, k, ans = 0;\nchar s[N];\nint fac[N], inv[N];\n\nint f[N], m = 0, r[N], b[N], visit[N];\ninline void solve() {\n  for (int i = 1; i <= k; i++) visit[i] = 0;\n  for (int i = 1, j = 1; i <= m; i++, j++) {\n    while (j <= k && s[j] != 'r') j++;\n    if (j > k) return;\n    r[i] = j;\n    visit[j] = 1;\n  }\n  for (int i = 1, j = 1; i <= m; i++, j++) if (f[i] >= 2) {\n    j = max(j, r[i]);\n    while (j <= k && s[j] != 'b') j++;\n    if (j > k) return;\n    b[i] = j;\n    visit[j] = 1;\n  }\n  for (int i = 1, j = 1; i <= m; i++, j++) if (f[i] >= 3) {\n    int x = f[i] - 2;\n    j = max(j, b[i]);\n    while (x--) {\n      while (j <= k && visit[j]) j++;\n      if (j > k) return;\n      visit[j] = 1;\n      j++;\n    }\n  }\n  int coef = fac[m];\n  for (int i = 1, j = 0; i <= m; i++) {\n    j = f[i] != f[i - 1] ? 1 : j + 1;\n    coef = (ll) coef * fac[j - 1] % mod * inv[j] % mod;\n  }\n  int upper = n + 1, lower = 0;\n  for (int i = 1; i <= m; i++) {\n    if (f[i] >= 2) upper += 2;\n    lower += f[i] * 2;\n  }\n  if (upper < lower) return;\n  coef = (ll) coef * fac[upper] % mod * inv[lower] % mod * inv[upper - lower] % mod;\n  ans = (ans + coef) % mod;\n}\nvoid dfs(int x, int last) {\n  solve();\n  for (int i = last; i; i--) {\n    int y = (i == 1 ? 1 : 2 * i - 3) + 1;\n    if (x >= y) {\n      f[++m] = i;\n      dfs(x - y, i);\n      --m;\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d%d%s\", &n, &k, s + 1);\n  fac[0] = fac[1] = 1;\n  inv[0] = inv[1] = 1;\n  for (int i = 2; i < N; i++) {\n    fac[i] = (ll) fac[i - 1] * i % mod;\n    inv[i] = mod - (ll) mod / i * inv[mod % i] % mod;\n  }\n  for (int i = 2; i < N; i++) {\n    inv[i] = (ll) inv[i] * inv[i - 1] % mod;\n  }\n  dfs(n + 1, n);\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[N], tmp[N], top = 0;\nchar str[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nlong long solve () {\n    bool flag1 = true, flag2 = true;\n    for (int i = 0; i < m; i++) suf[i] = 1;\n    for (int i = top - 1; i >= 0; i--) {\n        int first_r = m;\n        for (int j = m - 1; j >= 0; j--) {\n            if (suf[j] && str[j] == 'r') first_r = j;\n        }\n        if (first_r >= m) flag1 = false;\n        if (!stk[i]) suf[pos[i] = first_r] = 0;\n        else {\n            int first_b = m;\n            for (int j = m - 1; j >= first_r; j--) {\n                if (suf[j] && str[j] == 'b') first_b = j;\n            }\n            if (first_b >= m) flag1 = false;\n            suf[first_r] = suf[pos[i] = first_b] = 0;\n        }\n    }\n\n    suf[m] = 0;\n    for (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n    for (int i = 0, j = 0; i < top; i++) {\n        if (stk[i]) {\n            j += stk[i] - 1;\n            if (suf[pos[i]] < j) flag1 = false;\n        }\n    }\n\n    for (int i = 0; i < m; i++) suf[i] = 1;\n    for (int i = top - 1; i >= 0; i--) {\n        int first_r = m;\n        for (int j = m - 1; j >= 0; j--) {\n            if (suf[j] && str[j] == 'r') first_r = j;\n        }\n        if (first_r >= m) flag2 = false;\n        if (!stk[i]) suf[pos[i] = first_r] = 0;\n        else {\n            int first_b = m;\n            for (int j = m - 1; j >= first_r; j--) {\n                if (suf[j] && str[j] == 'b') first_b = j;\n            }\n            if (first_b >= m) flag2 = false;\n            suf[first_r] = suf[pos[i] = first_b] = 0;\n        }\n    }\n\n    suf[m] = 0;\n    for (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n    for (int i = 0, j = 0; i < top; i++) {\n        if (stk[i]) {\n            j += stk[i] - 1;\n            if (suf[pos[i]] < j) flag2 = false;\n        }\n    }\n    if (!flag1 && !flag2) return 0ll;\n    \n    long long res = 1ll;\n    for (int i = 0; i <= n; i++) tmp[i] = 0;\n    for (int i = 0; i < top; i++) tmp[stk[i]]++;\n    for (int i = 0, j = 0; i <= n; i++) {\n        j += tmp[i];\n        res = res * c[j][tmp[i]] % mod;\n    }\n\n    int num1 = 0, num2 = 0;\n    for (int i = 0; i < top; i++) {\n        if (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n        else num1++;\n    }\n    if (top) num1 += top - 1, num2 += 2;\n    else num1++;\n    res = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n    return res;\n}\n\nvoid dfs (int mn, int total) {\n    if (mn == n + 1) ans = (ans + solve()) % mod;\n    if (mn <= n) dfs(mn + 1, total);\n    int t = mn ? mn << 1 : 2;\n    if (total + t <= n + 1) {\n        stk[top++] = mn;\n        dfs(mn, total + t);\n        top--;\n    }\n}\n\nint main () {\n    scanf(\"%d%d%s\", &n, &m, str);\n    for (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n    for (int i = 1; i <= n * 3; i++) {\n        for (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n    dfs(0, 0);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%1000000007\n#define min(a,b) (a<b?a:b)\n#define mod 1000000007\n#define Mod 1000000005\n#define ll long long\n#define N 1000\n//#define file\nusing namespace std;\n\nll f[71][71][72],jc[N+1],Jc[N+1],ans;\nint d[71],n,m,i,j,k,l,x,y;\nchar a[71];\nbool bz[71];\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;};\nll C(int n,int m) {if (n<m) return 0;return jc[n]*Jc[m]%mod*Jc[n-m]%mod;}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc089F.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\t#endif\n\t\n\tjc[0]=1;\n\tfo(i,1,N) jc[i]=jc[i-1]*i%mod;\n\tJc[N]=qpower(jc[N],Mod);\n\tfd(i,N-1,0) Jc[i]=Jc[i+1]*(i+1)%mod;\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1);\n\tans=1;\n\tfo(x,0,n)\n\t{\n\t\tfo(y,0,n)\n\t\tif (x || y)\n\t\t{\n\t\t\tmemset(bz,0,sizeof(bz)),k=l=0;\n\t\t\tfo(i,1,x)\n\t\t\t{\n\t\t\t\tfo(j,1,m) if (!bz[j] && a[j]=='r') break;\n\t\t\t\tfo(k,j,m) if (!bz[k] && a[k]=='b') break;\n\t\t\t\tif (k>m) break;\n\t\t\t\tbz[j]=bz[k]=1;\n\t\t\t}\n\t\t\tif (k>m) continue;\n\t\t\tfo(i,1,m) if (l<y && !bz[i] && a[i]=='r') ++l,bz[i]=1;\n\t\t\tif (l<y) continue;\n\t\t\t\n\t\t\tl=0;\n\t\t\tfd(j,m,1)\n\t\t\tif (bz[j] && a[j]=='b')\n\t\t\t{\n\t\t\t\td[++l]=0;\n\t\t\t\tfo(k,j,m) d[l]+=!bz[k];\n\t\t\t}\n\t\t\t\n\t\t\tmemset(f,0,sizeof(f)),f[0][0][0]=1;\n\t\t\tfo(i,0,x-1)\n\t\t\t{\n\t\t\t\tfo(j,0,d[x])\n\t\t\t\t{\n\t\t\t\t\tfo(k,0,d[x])\n\t\t\t\t\tif (f[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k<d[x]) add(f[i][j][k+1],f[i][j][k]);\n\t\t\t\t\t\tfo(l,1,x-i)\n\t\t\t\t\t\tif (j+l*k<=d[i+l])\n\t\t\t\t\t\tadd(f[i+l][j+l*k][k+1],f[i][j][k]*C(i+l+y,l));\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfo(j,0,d[x])\n\t\t\t{\n\t\t\t\tfo(k,0,d[x]+1)\n\t\t\t\t{\n\t\t\t\t\tfo(l,0,n)\n\t\t\t\t\tadd(ans,f[x][j][k]*C(l+(y+2*j+x*3)-1,(y+2*j+x*3)-1)%mod*C(n-(x+y-1)-2*j-l,x+y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007LL;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\nll num[71][71];\nll fact[10001];\nll inv_fact[10001];\nll mod_pow(ll a, ll b) {\n\tif (b == 0) return 1;\n\tif (b % 2 == 0) {\n\t\tll x = mod_pow(a, b / 2);\n\t\treturn (x*x) % MOD;\n\t}\n\treturn (a*mod_pow(a, b - 1)) % MOD;\n}\nll comb(ll n, ll k) {\n\tif (n < k) return 0;\n\tll ret = fact[n];\n\t(ret *= inv_fact[k]) %= MOD;\n\t(ret *= inv_fact[n - k]) %= MOD;\n\treturn ret;\n}\nint N, K;\nll ans;\nstring s;\nbool check(vector<int> &v) {\n\tbool used[70] = {};\n\tint pos[70];\n\tint now= 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\twhile (now < s.size()) {\n\t\t\tif (s[now] == 'r') break;\n\t\t\tnow++;\n\t\t}\n\t\tif (now == s.size()) return 0;\n\t\tused[now] = 1;\n\t\tpos[i] = now;\n\t\tnow++;\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] == 1) break;\n\t\tnow = pos[i] + 1;\n\t\twhile (now < s.size()) {\n\t\t\tif (!used[now] && s[now] == 'b') break;\n\t\t\tnow++;\n\t\t}\n\t\tif (now == s.size()) return 0;\n\t\tused[now] = 1;\n\t\tpos[i] = now;\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] <= 2) break;\n\t\tint cnt = 0;\n\t\tnow = pos[i] + 1;\n\t\twhile (now < s.size()) {\n\t\t\tif (!used[now]) {\n\t\t\t\tused[now] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt >= v[i] - 2) break;\n\t\t\tnow++;\n \t\t}\n\t\tif (now == s.size()) return 0;\n\t}\n\treturn 1;\n}\nll calc(vector<int> &v) {\n\tmap<int, int> freq;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tfreq[v[i]]++;\n\t}\n\tll ret = fact[v.size()];\n\tfor (auto p : freq) {\n\t\t(ret *= inv_fact[p.second]) %= MOD;\n\t}\n\tint x = N + 1;\n\tint y = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] >= 2) x += 2;\n\t\ty += 2 * v[i];\n\t}\n\t(ret *= comb(x, y)) %= MOD;\n\treturn ret;\n}\nvoid brute(int k, int prev, int sum, vector<int> &v) {\n\tif (sum > N) return;\n\tif (check(v)) {\n\t\t(ans += calc(v)) %= MOD;\n\t}\n\tfor (int i = min(k, prev); i >= 1; i--) {\n\t\tint m = 1;\n\t\tif (i > 1) m = i * 2 - 3;\n\t\tif (v.size() > 0) m++;\n\t\tv.push_back(i);\n\t\tbrute(k - i, i, sum + m, v);\n\t\tv.pop_back();\n\t}\n}\nint main() {\n\tfact[0] = inv_fact[0] = 1;\n\tfor (int i = 1; i <= 10000; i++) {\n\t\tfact[i] = (fact[i - 1] * i) % MOD;\n\t\tinv_fact[i] = (inv_fact[i - 1] * mod_pow(i, MOD - 2)) % MOD;\n\t}\n\tcin >> N >> K;\n\tcin >> s;\n\tvector<int> v;\n\tbrute(K, K, 0, v);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=105,mod=1e9+7,M=205;\nchar ch[N];\nll c[M][M];\nint s[N],ans,n,len,sum[N];\nll dp[N][N];\nll hf(int a,int b){\n\treturn a>=0&&b>=0?c[a+b-1][b-1]:0;\n}\ninline void add(int &a,ll b){\n\ta=(a+b)%mod;\n\t//cout<<a<<\" \"<<b<<endl;\n}\nbool vis[N];\nint sss[N];\nvoid woliekai(int x,int y){\n\tif(x+y==0){\n\t\tans++; return;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tvector<int> F,G;\n\tfor(int i=1,ff=0;i<=len;i++)if(ch[i]=='r'){\n\t\tif(F.size()<y){F.pb(i); vis[i]=1;}\n\t}else {\n\t\tif(G.size()<F.size()){G.pb(i); vis[i]=1;}\n\t\t//if(y==2)cout<<sss[i+1]<<\"faspogpoa\"<<endl;\n\t\t//assert(sss[i]+1!=len-i+2);\n\t}\n\tint X=0;\n\tFor(i,1,len)if(X<x&&!vis[i]&&ch[i]=='r'){vis[i]=1; X++;}\n\tif(X<x||G.size()<y)return;\n\tRep(i,len,1)sss[i]=sss[i+1]+1-vis[i];\n\tFor(i,1,y)sum[i]=sss[G[i-1]+1];\n\treverse(sum+1,sum+y+1);\n\t//For(i,1,y)wri(sum[i]); puts(\"gfashiognoa\"); \n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tFor(i,2,(n+3)/2){\n\t\tRep(k,y,0)Rep(j,n,0)if(dp[j][k]){\n\t\t\tint dk=k,dj=j;\n\t\t\tFor(l,1,y-k){\n\t\t\t\tdk++; dj+=i*2-3;\n\t\t\t\t//if(l==2)cout<<l<<\" \"<<sum[dk]<<\" \"<<dj<<endl;\n\t\t\t\t//assert((dj+3*dk)%2==0);\n\t\t\t\tif(sum[dk]<(dj+3*dk)/2-2*dk||dj>n)break;\n\t\t\t\t//cout<<i<<\" \"<<l<<\" \"<<dj<<\" \"<<dk<<endl;\n\t\t\t\t\n\t\t\t\tdp[dj][dk]=(dp[dj][dk]+dp[j][k]*hf(l,k+1))%mod;\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<dp[0][0]<<endl;\n\tRep(j,n,0)if(dp[j][y]){\n\t\t//cout<<hf(x,y+1)<<\" \"<<n-(x+y-1)-j<<\" \"<<x+y+1+j+2*y<<\" \"<<hf(5,2)<<endl;\n\t\tans=(ans+hf(x,y+1)*hf(n-(x+y-1)-j-x,x+y+1+j+x+2*y)%mod*dp[j][y])%mod;//x+y-1段w非空,x+j段非空,2段空,2y空 \n\t\t//cout<<dp[j][y]<<\" \"<<j<<\" \"<<y<<\" \"<<ans<< \" \"<<n-(x+y-1)-j-x<<\" \"<<x+y+1+j+x+2*y<<endl;\n\t}\n\t///if(y==2)exit(0);\n//cout<<x<<\" \"<<y<<\" \"<<ans<<endl; //exit(0);\n}\nsigned main(){\n\t//freopen(\"cover.in\",\"r\",stdin); freopen(\"cover.out\",\"w\",stdout);\n\tn=read(),len=read();\n\tFor(i,0,M-1)For(j,c[i][0]=1,i)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\tscanf(\"%s\",ch+1);\n\tFor(i,0,(n+1)/2){\n\t\tFor(j,0,(n+1)/2-i)woliekai(i,j);\n\t\t//cout<<ans<<endl;\n\t\t//For(j,1,len)wri(vis[j]); puts(\"\");\n\t}\n\tcout<<ans<<endl;\n}\n/*\n7 5\nrrbrb\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=105,mod=1e9+7;\nchar ch[N];\nll c[N][N];\nint s[N],zy[N][N][N],f[(N+3)/2][N][N/2][N],g[(N+3)/2][N][N/2][N],h[(N+3)/2][N][N/2][N],H[(N+3)/2][N][N/2][N];\nll hf(int a,int b){\n\treturn a>=0&&b>=0?c[a+b-1][b-1]:0;\n}\ninline void add(int &a,ll b){\n\ta=(a+b)%mod;\n\t//cout<<a<<\" \"<<b<<endl;\n}\nbool vis[N];\nsigned main(){\n\t//freopen(\"cover.in\",\"r\",stdin); freopen(\"cover.out\",\"w\",stdout);\n\tint n=read(),len=read(),F=0,ans=1;\n\tFor(i,0,n)For(j,c[i][0]=1,i)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\tscanf(\"%s\",ch+1);\n\tFor(xsg,0,(n+1)/2){\n\t\tF=0; \n\t\t//memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); memset(h,0,sizeof(h)); memset(H,0,sizeof(H));\n\t\tFor(i,1,len){\n\t\t\ts[i]=s[i-1];\n\t\t\tif(ch[i]=='r'&&!vis[i])F++;\n\t\t\telse if(!vis[i]&&F){s[i]++; F--;} \n\t\t}\n\t\t\n\t\tFor(i,0,len){\n\t\t\tFor(j,0,s[i]){\n\t\t\t\tFor(k,2,(n+3)/2){\n\t\t\t\t\tint dq=i+1,jb=0;\n\t\t\t\t\twhile(dq<=len){\n\t\t\t\t\t\tif(vis[dq]){dq++; continue;}\n\t\t\t\t\t\tif(s[dq]>=j+1||(jb==0&&ch[dq]=='r'))jb++;\n\t\t\t\t\t\tif(jb>=k)break; dq++;\n\t\t\t\t\t}\n\t\t\t\t\tzy[i][j][k]=dq;\n\t\t\t\t\t//if(i<=5)cout<<zy[i][j][k]<<\" \"<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\t//cout<<zy[5][1][2]<<endl;\n\t\tf[(n+3)/2][0][0][0]=1; int m=(n+1)/2,cnt=0;\n\t\tRep(i,(n+3)/2,2){\n\t\t\tFor(j,0,n-xsg)for(int k=0;k<=m-xsg&&k*(2*i-3)<=j;k++)For(l,0,len){\n\t\t\t\t\n\t\t\t\tif(f[i][j][k][l]){\n\t\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<l<<endl;\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-1)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\tadd(g[i][j+o*(2*i-1)][k+o][dq],f[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t\tif(g[i][j][k][l]){\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-2)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\tadd(h[i][j+o*(2*i-2)][k+o][dq],g[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\tg[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t\tif(h[i][j][k][l]){\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-3)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\tadd(H[i][j+o*(2*i-3)][k+o][dq],h[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\th[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t\tif(H[i][j][k][l]){\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-2)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\t//if(o==1)cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<l<<\" \"<<H[i][j][k][l]<<endl;\n\t\t\t\t\t\tadd(f[i-1][j+o*(2*i-2)][k+o][dq],H[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\tH[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout<<zy[0][1][1]<<endl;\n\t\t//cout<<f[1][2][1][2]<<\" \"<<hf(1,2)<<endl;\n\t\t//cout<<f[1][0][0][0]<<\" \"<<g[1][1][1][1]<<\" \"<<f[1][2][1][2]<<\" \"<<zy[0][0][2]<<endl;\n\t\tFor(j,0,n-xsg)For(k,0,m-xsg)For(l,0,len)if(f[1][j][k][l]){\n\t\t\t//cout<<f[1][j][k][l]<<endl;\n\t\t\tadd(g[1][j+xsg][k+xsg][l],f[1][j][k][l]*hf(xsg,k+1));\n\t\t}\n\t\tmemset(f[1],0,sizeof(f[1]));\n\t\tFor(j,0,n)For(k,0,m)For(l,0,len)if(g[1][j][k][l]){\n\t\t\tif(k){\n\t\t\t\t//cout<<k-1<<\" \"<<len<<\" \"<<l<<\" \"<<len-l<<endl;\n\t\t\t\t//For(o,k-1,n-j)cout<<hf(o-(k-1),k+1)<<\" \"<<c[n-o-1][j-1]<<endl;\n\t\t\t\tFor(o,k-1,n-j)ans=(ans+hf(o-(k-1),k+1)*g[1][j][k][l]%mod*c[n-o-1][j-1])%mod;\n\t\t\t\t//cout<<j<<\" \"<<k<<\" \"<<l<<\" \"<<g[1][j][k][l]<<\" \"<<hf(0-(k-1),k+1)<<\" \"<<c[n-0-1][j-1]<<endl;\n\t\t\t}\n\t\t}\n\t\t//cout<<ans<<endl;\n\t\tint fff=0;\n\t\t//Rep(i,len,1)cout<<(ch[i]=='r'&&!vis[i])<<endl;\n\t\tRep(i,len,1)if(ch[i]=='r'&&!vis[i]){vis[i]=1; fff=1;break;}\n\t\tif(!fff)break;\n\t\tmemset(g[1],0,sizeof(g[1]));\n\t\t\n\t}\n\tcout<<ans<<endl;\n}\n/*\n18  6\nrbrbrr\n\n34454753\n\n3 2\nrb\n\n5 1\nbr\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], suf[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nbool check () {\n\tvector<int> vec1, vec2, vec3;\n\tfor (int i = 0; i < top; i++) vec1.push_back(stk[i]);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') {\n\t\t\tif (!vec1.empty()) {\n\t\t\t\tif (vec1.back()) vec2.insert(vec2.begin(), vec1.back());\n\t\t\t\tvec1.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!vec2.empty()) {\n\t\t\t\tif (vec2.back() > 1) vec3.push_back(vec2.back() - 1);\n\t\t\t\tvec2.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn vec1.empty() && vec2.empty() && vec3.empty();\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tassert(j <= n * 3 && tmp[i] <= n * 3);\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tif (n + num2 - 1 < 0 || num1 + num2 - 1 < 0) return 0ll;\n\tif (n + num2 - 1 > n * 3 || num1 + num2 - 1 > n * 3) return 0ll;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n \n\tconstexpr static uint mod = mod_;\n \n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n \nconst int MN=70;\nconst int MK=70;\nmint Co[1000][1000];\nmint C(int a,int b){\n\tassert(0<=b&&b<=a);\n\treturn Co[a][b];\n}\nmint dp[MN+1][MN+1][MN+1]={};\t//phase, the num of component already put, the sum of len (!!excluding y as!!)\nmint calc(int N,int x,int y,vector<int> canuse){\t\t//x:the num of ab~ y:the num of a\n\trep(i,MN+1) rep(j,MN+1) rep(k,MN+1) dp[i][j][k] = 0;\n//\tprintf(\"x=%d,y=%d\\n\",x,y);\n\tif(x==0&&y==0) return 1;\n\tdp[0][0][0]=1;\t\t//put y as\n\tint I=(N+1)/2;\n\tint J=x;\n\tint S=N-2*y-x+1;\n\t// show(I);\n\t// show(J);\n\t// show(S);\n\trep(i,I){\n\t\trep(j,J+1){\n\t\t\trep(s,S+1){\n\t\t\t\tfor(int k=0;j+k<=J && s+k*(i*2+1)<=S;k++){\n\t\t\t\t\tif(k>0&&canuse[j+k-1]<(s-j)/2+i*k) break;\n\t\t\t\t\tdp[i+1][j+k][s+k*(i*2+1)]+=dp[i][j][s]*C(j+y+k,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmint ret=0;\n\trep(s,S+1){\n\t\tret+=dp[I][x][s]*C(N+2*x+1,s+3*x+2*y);\n\t}\n//\tshow(ret);\n\treturn ret;\n}\nmint solve(int N,string s){\n\trep(i,1000){\n\t\tCo[i][0]=Co[i][i]=1;\n\t\tfor(int j=1;j<i;j++) Co[i][j]=Co[i-1][j-1]+Co[i-1][j];\n\t}\n\tint K=s.size();\n\tvector<int> as;\n\trep(i,K) if(s[i]=='r') as.pb(i);\n\tmint ans=0;\n\trep(x,N+1) rep(y,N+1){\n\t\tbool used[MK]={};\n\t\tint bid[MN]={};\n\t\tbool OK=1;\n\t\tif(x+y>as.size()) continue;\n\t\trep(i,x){\n\t\t\tused[as[i]]=1;\n\t\t\tbool ok=0;\n\t\t\tfor(int j=as[i]+1;j<K;j++) if(s[j]=='b'&&!used[j]){\n\t\t\t\tbid[i]=j;\n\t\t\t\tused[j]=1;\n\t\t\t\tok=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ok){\n\t\t\t\tOK=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!OK) continue;\n\t\trep(i,y) used[as[x+i]]=1;\n\t\tvector<int> lefts;\n\t\tint imos[MK+1]={};\n\t\trep(i,K) imos[i+1]=imos[i]+(!used[i]);\n\t\trep(i,x) lefts.pb(imos[K]-imos[bid[x-i-1]]);\n\t\tans+=calc(N,x,y,lefts);\n\t}\n\treturn ans;\n}\n \ntypedef vector<int> vi;\nset<vi> st,nst;\nmint brute(int N,string s){\n\tvi be(N);\n\tst.insert(be);\n\tfor(char c:s){\n\t\tint x=(c=='r'?1:2);\n\t\tfor(vi v:st){\n\t\t\trep(l,N) for(int r=l;r<N;r++){\n\t\t\t\tvi nv=v;\n\t\t\t\tbool ok=1;\n\t\t\t\tfor(int i=l;i<=r;i++){\n\t\t\t\t\tif(v[i]==0&&x==2){\n\t\t\t\t\t\tok=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnv[i]=x;\n\t\t\t\t}\n\t\t\t\tif(ok) nst.insert(nv);\n\t\t\t}\n\t\t\tnst.insert(v);\n\t\t}\n\t\tst=nst;\n\t\tnst.clear();\n\t}\n\treturn st.size();\n}\n \nint main(){\n\tint N,K;\n\tstring s;\n\tcin>>N>>K>>s;\n \n\tcout<<solve(N,s)<<endl;\n//\tshow(brute(N,s));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define N 142\n#define mod 1000000007\nint n,m,st[N],c[N][N],as,fr[N];\nchar s[N];\nint pw(int a,int p){int as=1;while(p){if(p&1)as=1ll*as*a%mod;a=1ll*a*a%mod;p>>=1;}return as;}\nint solve(int k)\n{\n\tint v1=0,v3=k,v2=k;\n\tfor(int i=1;i<=m;i++)\n\tif(s[i]=='r')\n\tif(v3>0)v3--;\n\telse v1-=v1>0;\n\telse if(v2>v3&&st[v2]>1)v1+=st[v2]-2,v2--;\n\telse v1-=v1>0;\n\tif(st[v2]>1||v3||v1)return 0;\n\tint ls=1,v5=fr[k];\n\tfor(int i=2;i<=k;i++)if(st[i]==st[i-1])ls++;\n\telse v5=1ll*pw(fr[ls],mod-2)*v5%mod,ls=1;\n\tv5=1ll*pw(fr[ls],mod-2)*v5%mod;\n\tint s1=n+1,s2=1;\n\tfor(int i=1;i<=k;i++)s1-=2*st[i]-2*(st[i]>1),s2+=2*st[i];\n\tif(s1<0)return 0;\n\treturn 1ll*v5*c[s1+s2-1][s2-1]%mod;\n}\nvoid dfs(int d,int su)\n{\n\tif(su<=35)as=(as+solve(d-1))%mod;else return;\n\tfor(int i=st[d-1];i<=36-su;i++)st[d]=i,dfs(d+1,su+i-(i>1));\n}\nint main(){scanf(\"%d%d%s\",&n,&m,s+1);for(int i=0;i<=141;i++)c[i][0]=c[i][i]=1;for(int i=2;i<=141;i++)for(int j=1;j<i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;fr[0]=1;for(int i=1;i<=70;i++)fr[i]=1ll*fr[i-1]*i%mod;st[0]=1;dfs(1,0);printf(\"%d\\n\",as);}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"No\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=200;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);int R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,R-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tif(!cc) add(g[0][i+ii][j+1],g[0][i][j]);\n\t\t\t\telse fo(s,1,ii) add(g[cc][i+ii][j+1],g[cc][i][j]*C(ii-s+1,cc)%MOD*C(s-1,cc-1)%MOD);\n\t\t\t}\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tfo(i,0,n-S) fo(j,0,R-t)\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*C(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//线性预处理模意义\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int P = 1E9 + 7, N = 200;\nint power(int base, int exp) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp & 1)\n            result = 1LL * result * base % P;\n        base = 1LL * base * base % P;\n        exp >>= 1;\n    }\n    return result;\n}\nint main() {\n    array<int, 200> factorial, inv_factorial;\n    factorial[0] = 1;\n    for (int i = 1; i < N; ++i)\n        factorial[i] = 1LL * factorial[i - 1] * i % P;\n    inv_factorial[N - 1] = power(factorial[N - 1], P - 2);\n    for (int i = N - 1; i >= 1; --i)\n        inv_factorial[i - 1] = 1LL * inv_factorial[i] * i % P;\n    auto binom = [&](int n, int m) {return 1LL * factorial[n] * inv_factorial[m] % P * inv_factorial[n - m] % P;};\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, k;\n    string s;\n    cin >> n >> k >> s;\n    vector<int> f;\n    int ans = 0;\n    auto work = [&]() {\n        int len = n - (int)f.size() + 1;\n        int bl = (int)f.size() + 1;\n        vector<bool> book(k);\n        vector<int> r(f.size());\n        for (int i = 0, j = 0; i < (int)f.size(); ++i) {\n            len -= max(1, 2 * f[i] - 3);\n            bl += max(1, 2 * f[i] - 3);\n            while (j < k && s[j] != 'r')\n                ++j;\n            if (j == k)\n                return;\n            book[j] = true;\n            r[i] = j++;\n        }\n        for (int i = 0, j = 0; i < (int)f.size(); ++i) {\n            if (f[i] == 1)\n                continue;\n            bl += 2;\n            j = max(j, r[i]);\n            while (j < k && (s[j] != 'b' || book[j]))\n                ++j;\n            if (j == k)\n                return;\n            book[j] = true;\n            r[i] = j++;\n        }\n        for (int i = 0, j = 0; i < (int)f.size(); ++i) {\n            for (int l = 0; l < f[i] - 2; ++l) {\n                j = max(j, r[i]);\n                while (j < k && book[j])\n                    ++j;\n                if (j == k)\n                    return;\n                r[i] = j++;\n            }\n        }\n        int result = factorial[f.size()];\n        for (int i = 0; i < (int)f.size(); ) {\n            int j = i;\n            while (j < (int)f.size() && f[i] == f[j])\n                ++j;\n            result = 1LL * result * inv_factorial[j - i] % P;\n            i = j;\n        }\n        result = 1LL * result * binom(len + bl - 1, bl - 1) % P;\n        ans = (ans + result) % P;\n    };\n    function<void(int, int)> dfs = [&](int sum, int last) {\n        work();\n        for (int i = 1; i <= last && max(2, 2 * i - 2) <= sum; ++i) {\n            f.push_back(i);\n            dfs(sum - max(2, 2 * i - 2), i);\n            f.pop_back();\n        }\n    };\n    dfs(n + 1, n + 1);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = 200;\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nint N, K;\nstring s;\nll ans;\n\nint cnt = 0;\nvoid calc(V<int>& vec) { //based on blue\n\tif (vec.empty()) {\n\t\tans = (ans + 1) % MOD;\n\t\treturn ;\n\t}\n\n\tint sz = vec.size();\n\n\tV<int> us(K);\n\tV<int> piv(sz);\n\n\tint now = 0;\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\twhile (now < K && s[now] == 'b') {\n\t\t\t++now;\n\t\t}\n\t\tif (now < K) {\n\t\t\tpiv[i] = now;\n\t\t\tus[now] = 1;\n\t\t\tnow++;\n\t\t} else {\n\t\t\treturn ;\n\t\t}\n\t}\n\n\tnow = 0;\n\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\tif (x >= 2) {\n\t\t\tchmax(now, piv[i] + 1);\n\t\t\twhile (now < K && s[now] == 'r') {\n\t\t\t\t++now;\n\t\t\t}\n\t\t\tif (now < K) {\n\t\t\t\tpiv[i] = now;\n\t\t\t\tus[now] = 1;\n\t\t\t\tnow++;\n\t\t\t} else {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\n\tnow = 0;\n\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\tif (x >= 3) {\n\t\t\tx -= 2;\n\t\t\tchmax(now, piv[i] + 1);\n\t\t\trep(t, x) {\n\t\t\t\twhile (now < K && us[now]) {\n\t\t\t\t\t++now;\n\t\t\t\t}\n\t\t\t\tif (now < K) {\n\t\t\t\t\tus[now] = 1;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint need = sz - 1;\n\tint bs = 0;\n\n\tfor (int x : vec) {\n\t\tif (x == 1) {\n\t\t\t++need;\n\t\t} else {\n\t\t\t++bs;\n\t\t\tneed += x * 2 - 3;\n\t\t}\n\t}\n\n\tif (need > N) {\n\t\treturn ;\n\t}\n\n\tll coef = fact[sz];\n\t{\n\n\t\trep(i, sz) {\n\t\t\tif (i == 0 || vec[i] != vec[i-1]) {\n\t\t\t\tint c = 0;\n\t\t\t\tfor (int j = i; j < sz; ++j) {\n\t\t\t\t\tif (vec[j] == vec[i]) {\n\t\t\t\t\t\t++c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcoef = coef * ifact[c] % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\t//dump(vec);\n\t//dump(need);\n\n\tcoef = coef * comb(N - need + (need + 1 + bs * 2), need + 1 + bs * 2);\n\n\tans = (ans + coef) % MOD;\n\t++cnt;\n}\n\nvoid gen(int p, int s, V<int>& vec) {\n\tbool en = (s + ((p == 1) ? 1 : p * 2 - 3) + vec.size() > N);\n\tif (p == K + 1 || en) {\n\t\tcalc(vec);\n\t\treturn ;\n\t}\n\n\tgen(p + 1, s, vec);\n\n\tfor (; ; ) {\n\t\tif (p == 1) {\n\t\t\t++s;\n\t\t} else {\n\t\t\ts += p * 2 - 3;\n\t\t}\n\t\tif (s + vec.size() > N) {\n\t\t\tbreak;\n\t\t}\n\t\tvec.pb(p);\t\t\n\t\tgen(p + 1, s, vec);\n\t}\n\twhile (vec.size() && vec.back() == p) {\n\t\tvec.pop_back();\n\t}\n}\n\nint main() {\n\tinit();\n\n\tcin >> N >> K >> s;\n\t{\n\t\tV<int> vec;\n\t\tgen(1, 0, vec);\n\t}\n\t//dump(cnt);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 75;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m; char s[MAXN];\nint dp[MAXN][MAXN][MAXN][MAXN][4];\nbool vis[MAXN][MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"\\n%s\", s + 1);\n\tvis[0][0][0][0] = true;\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 0; j <= i; j++)\n\t\tfor (int k = 0; k <= j; k++)\n\t\tfor (int l = k; l <= i; l++) {\n\t\t\tif (!vis[i - 1][j][k][l]) continue;\n\t\t\tvis[i][j][k][l] = true;\n\t\t\tif (s[i] == 'r') {\n\t\t\t\tvis[i][j + 1][k][l] = true;\n\t\t\t\tif (k != 0) vis[i][j][k][l + 1] = true;\n\t\t\t} else {\n\t\t\t\tif (k < j) vis[i][j][k + 1][l + 1] = true;\n\t\t\t\tif (k != 0) vis[i][j][k][l + 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j <= m; j++)\n\tfor (int k = 0; k <= j; k++)\n\tfor (int l = k; l <= m; l++)\n\t\tdp[0][j][k][l][0] = vis[m][j][k][l];\n\t//state: 0 -> w, 1 -> r, 2 -> b*, 3 -> r*\n\t//j -> segments, k -> with b, l -> cntb\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j <= m; j++)\n\t\tfor (int k = 0; k <= m; k++)\n\t\tfor (int l = k; l <= m; l++) {\n\t\t\tint tmp = dp[i - 1][j][k][l][0];\n\t\t\tupdate(dp[i][j][k][l][0], tmp); // 0 + w\n\t\t\tif (j) update(dp[i][j - 1][k][l][1], tmp); // 0 + r\n\t\t\tif (j && k && l) update(dp[i][j - 1][k - 1][l - 1][2], tmp); // 0 + b\n\t\t\t\n\t\t\ttmp = dp[i - 1][j][k][l][1];\n\t\t\tupdate(dp[i][j][k][l][0], tmp); // 1 + w\n\t\t\tupdate(dp[i][j][k][l][1], tmp); // 1 + r\n\t\t\tif (k && l) update(dp[i][j][k - 1][l - 1][2], tmp); // 1 + b\n\t\t\t\n\t\t\ttmp = dp[i - 1][j][k][l][2];\n\t\t\tupdate(dp[i][j][k][l][0], tmp); // 2 + w\n\t\t\tupdate(dp[i][j][k][l][3], tmp); // 2 + r\n\t\t\tupdate(dp[i][j][k][l][2], tmp); // 2 + b\n\t\t\t\n\t\t\ttmp = dp[i - 1][j][k][l][3];\n\t\t\tupdate(dp[i][j][k][l][0], tmp); // 3 + w\n\t\t\tupdate(dp[i][j][k][l][3], tmp); // 3 + r\n\t\t\tif (l) update(dp[i][j][k][l - 1][2], tmp); // 3 + b\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= 3; i++)\n\t\tupdate(ans, dp[n][0][0][0][i]);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0;int f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 255*3;\nconst int mod = 1e9+7;\nint n,m;\nchar s[maxn];\nint ans,fac[maxn],ifac[maxn];\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(){\n\tn = read(),m = read();\n\tscanf(\"%s\",s+1);\n\tfac[0] = 1;rep(i,1,maxn) fac[i] = 1ll * fac[i-1] * i % mod;\n\tifac[maxn-1] = qpow(fac[maxn-1],mod-2);\n\tDep(i,maxn-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % mod;\n\tassert(ifac[0]==1);\n}\ninline int C(int n,int m){\n\tif(n<m||n<0) return 0;\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\n#define cal(x,y) C((x)+(y)-1,(y)-1)\ninline void add(int &x,int v){\n\tx+=v;\n\tif(x>=mod) x-=mod;\n}\nint q1[maxn],q2[maxn],suf[maxn],f[maxn][maxn];\nbool used[maxn];\nvoid solve(int S1,int S2){\n\tif(!S1&&!S2) return ++ans,void(0);\n\t*q1=*q2=0;\n\tmemset(used,0,sizeof(used));\n\tint x=0,y=0;\n\tRep(i,1,m)\n\t\tif(s[i]=='r' && x<S1+S2) q1[++x]=i; else \n\t\tif(s[i]=='b' && y<S2 && y<x) q2[++y]=i;\n\tif(y!=S2 || x!=S1+S2) return ;\n\tRep(i,1,x) used[q1[i]]=true;\n\tRep(i,1,y) used[q2[i]]=true;\n\tDep(i,m,1) suf[i]=suf[i+1]+(!used[i]);\n\tRep(i,1,S2) q2[i] = suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tRep(i,2,n)Dep(j,S2-1,0)Rep(k,2*j,n-i*(S2-j)){\n\t\tRep(l,1,min(S2-j,(n-k)/i)){\n\t\t\tif(k+i*l-2*(j+l) > q2[S2-(j+l)+1]) break;\n\t\t\tadd(f[j+l][k+i*l],1ll*ifac[l]*f[j][k]%mod);\n\t\t}\n\t}\n\tint res = 0;\n\tRep(i,0,n){\n\t\tint sum=2*S1+2*i-2*S2-1;\n\t\tint par=2*S1+2*i+1;\n\t\tif (sum&&sum<=n&&f[S2][i])\n\t\t\tadd(res,1ll*f[S2][i]*cal(n-sum,par)%mod);\n\t}res = 1ll * res * fac[S1+S2] % mod * ifac[S1] % mod;\n\tadd(ans,res);\n}\nint main(){\n\tinit(); \n\tans = 0;\n\tRep(S1,0,n)Rep(S2,0,n)solve(S1,S2);\n\twriteln(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#define MOD 1000000007\ntypedef long long ll; \ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD; \n\t\ta = a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res; \n}\nll ans, fact[305], inv[305]; \ninline ll C(int n, int m)\n{\n\treturn fact[n] * inv[m] % MOD * inv[n - m] % MOD; \n}\nint seq[305], n, k; \nchar str[305]; \ninline void work(int len, int sum)\n{\n\tint cur_one = 0, cur_two = 0, need = 0, arb = 0; \n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tif (str[i] == 'r' && cur_one < len)\n\t\t\tneed += seq[cur_one++] != 1; \n\t\telse if (str[i] == 'b' && need)\n\t\t{\n\t\t\tneed--; \n\t\t\tarb += seq[cur_two++] - 2; \n\t\t}\n\t\telse if (arb)\n\t\t\tarb--; \n\t}\n\tif (cur_one < len || need || arb)\n\t\treturn;\n\tll res = fact[len], pos = len + 1; \n\tfor (int i = 0, j = 0; i < len; i = j)\n\t{\n\t\twhile (j < len && seq[i] == seq[j])\n\t\t\tj++; \n\t\tres = res * inv[j - i] % MOD; \n\t\tpos += (j - i) * (seq[i] * 2 - 1); \n\t}\n\t(ans += res * C(n - sum + pos - 1, pos - 1)) %= MOD; \n}\nvoid dfs(int cur, int len, int sum)\n{\n\tif (sum > n)\n\t\treturn; \n\twork(len, sum); \n\tfor (int i = cur; i; i--)\n\t{\n\t\tseq[len] = i; \n\t\tdfs(i, len + 1, sum + std::max(1, i * 2 - 3) + (len != 0)); \n\t}\n}\nint main()\n{\n\t// freopen(\"ARC089-F.in\", \"r\", stdin); \n\tscanf(\"%d%d%s\", &n, &k, str); \n\tfact[0] = inv[0] = 1; \n\tfor (int i = 1; i <= 300; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD; \n\t\tinv[i] = quick_pow(fact[i], MOD - 2); \n\t}\n\tdfs(70, 0, 0); \n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nll C(ll x, ll y) {\n    if(!y) return 1;\n    if(x < 0 || y < 0 || x < y) return 0;\n    return Fac[x] * Rev[y] % P * Rev[x - y] % P;\n}\n\nvoid calc(int sz) {\n    int tb = 0, tr = 0;\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && ch[tb] != 'b') tb++;\n        }\n        if(tr > K || tb > K) return;\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, C(r + rw - 1, r) * C(b + bw - 1, b) % P * C(sz + (t - r - b), sz) % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i);\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[80];\nint n, K, chk[80], Loc[100], C[100], F[150], InvF[150], Mod = 1000000007;\nint D[100][100], TD[100][100]; // 한 블럭의 크기, 블럭의 개수, 쓴거의 개수\n\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint Comb(int n, int r) {\n\treturn 1ll * F[n] * InvF[r] % Mod*InvF[n - r]%Mod;\n}\nint Do(int A, int B) { // R* : A, RBxx : B\n\tint i, c1 = 0, c2 = 0, j, k, ii, jj;\n\tfor (i = 0; i < K; i++) {\n\t\tchk[i] = 0;\n\t\tif (p[i] == 'r' && c1 < B) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t\tif (p[i] == 'b' && c2 < c1) {\n\t\t\tchk[i] = 1;\n\t\t\tc2++;\n\t\t\tLoc[c2] = i;\n\t\t}\n\t}\n\tif (c1 < B || c2 < B)return 0;\n\tc1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tif (p[i] == 'r' && !chk[i] && c1 < A) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t}\n\tif (c1 < A)return 0;\n\tfor (i = 1; i <= B; i++) {\n\t\tC[B-i+1] = 0;\n\t\tfor (j = Loc[i]; j < K; j++)if (!chk[j])C[B-i+1]++;\n\t}\n\tfor (i = 0; i < 50; i++)for (j = 0; j < 50; j++)D[i][j] = TD[i][j] = 0;\n\tD[0][0] = InvF[A];\n\n\tfor (i = 0; i <= n / 2 + 1; i++) {\n\t\tfor (j = 0; j < 50; j++) {\n\t\t\tfor (k = 0; k < 50; k++) {\n\t\t\t\tif (!D[j][k])continue;\n\t\t\t\tfor (ii = 0;; ii++) {\n\t\t\t\t\tint s = (ii*i + k);\n\t\t\t\t\tif (ii+j > B || s * 2 + A + B + (A + B - 1) > n || C[j+ii] < s)break;\n\t\t\t\t\tTD[j + ii][s] = (TD[j + ii][s] + 1ll * D[j][k] * InvF[ii]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 40; j++)for (k = 0; k < 40; k++) {\n\t\t\tD[j][k] = TD[j][k];\n\t\t\tTD[j][k] = 0;\n\t\t}\n\t}\n\tint r = 0;\n\tfor (i = 0; i < 50; i++) {\n\t\tint c = (A + B + A + B - 1 + i * 2);\n\t\tint t = c + B * 2 + 2;\n\t\tif (!D[B][i] || n-c < 0)continue;\n\t\tr = (r + 1ll * D[B][i] * F[A+B] % Mod * Comb(t + (n - c) - 1, (n - c)))%Mod;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, res = 0;\n\tF[0] = 1;\n\tfor (i = 1; i <= 140; i++)F[i] = 1ll * F[i - 1] * i%Mod;\n\tfor (i = 0; i <= 140; i++)InvF[i] = Pow(F[i], Mod - 2);\n\tscanf(\"%d%d\", &n, &K);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i <= (n+1)/2; i++) {\n\t\tfor (j = 0; i + j <= (n + 1) / 2; j++) {\n\t\t\tres = (res + Do(i, j))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=255,Mo=1e9+7;\n\nint n,k,t,f[N],C[N][N],ans;\nchar st[N];\n\nvoid pre(int N) {\n\tfo(i,0,N) {\n\t\tC[i][0]=1;\n\t\tfo(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mo;\n\t}\n}\n\nvoid calc() {\n\tint sum=0,tr=t,tb=t;\n\tfo(i,1,k) {\n\t\tif (st[i]=='r'&&tr) tr--;\n\t\telse if (st[i]=='b'&&f[tb]>1&&tb>tr) sum+=f[tb]-2,tb--;\n\t\telse if (sum) sum--;\n\t}\n\twhile (f[tb]==1) tb--;\n\tif (tr||tb||sum) return;\n\n\tint ret=1;\n\tfor(int l=1,r=0;l<=t;l=r+1) {\n\t\twhile (r<t&&f[r+1]==f[l]) r++;\n\t\tret=(ll)ret*C[r][r-l+1]%Mo;\n\t}\n\n\tint cnt=0,ulm=0;\n\tfo(i,1,t) {\n\t\tcnt+=(f[i]==1?1:f[i]*2-3)+1;\n\t\tulm+=(f[i]==1?1:f[i]*2-3)+1;\n\t\tulm+=2*(f[i]>1);\n\t}\n\tcnt--;ulm++;\n\t(ans+=(ll)ret*C[n-cnt+ulm-1][ulm-1]%Mo)%=Mo;\n\t//fo(i,1,t) printf(\"%d \",f[i]);printf(\"%d\\n\",ans);\n}\n\nvoid dfs(int x,int y,int la) {\n\tcalc();\n\t++t;\n\tif (la==1&&x+2<=n+1&&y+1<=k) {\n\t\tf[t]=1;\n\t\tdfs(x+2,y+1,1);\n\t}\n\tfor(int i=max(la,2);;i++) {\n\t\tif (y+i>k) break;\n\t\tif (x+2*i-2>n+1) break;\n\t\tf[t]=i;\n\t\tdfs(x+2*i-2,y+i,i);\n\t}\n\tt--;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tpre(250);\n\tscanf(\"%s\",st+1);\n\tdfs(0,0,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =1000000007;\n\nmap< vector<int>, int > M;\nvector< vector<int> > Mi;\nvector<int> cnt[71];\n\nint MX =70;\n\nvoid put(vector<int> &seq, int x) {\n\tfor(int i =(int)seq.size()-1; i >= 0; i--) if(seq[i] >= x) {\n\t\tseq.insert(begin(seq)+i+1,x);\n\t\treturn;\n\t}\n\tseq.insert(begin(seq),x);\n}\n\nint get_id(vector<int> &seq) {\n\tauto it =M.find(seq);\n\tif(it == M.end()) {\n\t\tint m =M.size();\n\t\tM[seq] =m;\n\t\tMi.push_back(seq);\n\t\treturn m;\n\t}\n\treturn it->ss;\n}\n\nvoid dump(int id, int sum, cat cnt_cur) {\n\tif(id >= (int)cnt[sum].size())\n\t\tcnt[sum].resize(id+1,0);\n\tcnt[sum][id] +=cnt_cur;\n\tif(cnt[sum][id] >= mod) cnt[sum][id] -=mod;\n}\n\nvoid push(int id, int sum, cat cnt_cur) {\n\tvector<int> seq =Mi[id];\n\t// add 0\n\tint sum_nw =sum+int(!seq.empty())+1;\n\tseq.push_back(0);\n\tint id_nw =get_id(seq);\n\tif(sum_nw <= MX) dump(id_nw,sum_nw,cnt_cur);\n\t// add non-0\n\tint a =seq.size()-1;\n\tfor(int i =1; i < 100; i++) {\n\t\tif(sum_nw > MX) break;\n\t\tseq[a]++;\n\t\twhile(a > 0 && seq[a-1] < seq[a]) {\n\t\t\tswap(seq[a],seq[a-1]);\n\t\t\ta--;\n\t\t}\n\t\tid_nw =get_id(seq);\n\t\tdump(id_nw,sum_nw,cnt_cur);\n\t\tsum_nw +=2;\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\n\tMi.resize(1);\n\tM[vector<int>()] =0;\n\tcnt[0].resize(1,1);\n\tint st =0;\n\tfor(int i =0; i < MX; i++) {\n\t\tint st_nw =M.size();\n\t\tfor(int sum =MX; sum >= 0; sum--)\n\t\t\tfor(int l =st; l < (int)cnt[sum].size(); l++) if(cnt[sum][l])\n\t\t\t\tpush(l,sum,cnt[sum][l]);\n\t\tst =st_nw;\n\t}\n\tcat C[200][200];\n\tmemset(C,0,sizeof(C));\n\tfor(int i =0; i < 200; i++) {\n\t\tC[i][0] =1;\n\t\tfor(int j =1; j <= i; j++) C[i][j] =(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\n\tint N,K;\n\tstring S;\n\tcin >> N >> K >> S;\n\n\tint ans =0;\n\tfor(int sum =0; sum <= N; sum++) for(int i =0; i < (int)cnt[sum].size(); i++) {\n\t\tif(cnt[sum][i] == 0) continue;\n\t\tvector<int> seq =Mi[i];\n\n\t\tint a =0, b =0;\n\t\tbool ok =true;\n\t\tfor(int i =0; i < (int)seq.size(); i++) {\n\t\t\twhile(a < K && S[a] == 'b') {\n\t\t\t\ta++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a == K) {\n\t\t\t\tok =false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta++;\n\t\t\tb =max(b,a);\n\t\t\tfor(int j =0; j < seq[i]; j++) {\n\t\t\t\twhile(b < K && S[b] == 'r') b++;\n\t\t\t\tif(b == K) {\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tif(!ok) break;\n\t\t}\n\t\tif(!ok) continue;\n\n\t\tint buckets =seq.size()+1;\n\t\tALL_THE(seq,it) buckets +=2*(*it)+1;\n\t\tcat cnt_ins =C[N-sum+buckets-1][buckets-1];\n\n\t\tans =(ans+cnt[sum][i]*cnt_ins)%mod;\n\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=1e3+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or m<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=300+10;\n\t//------------------FIXED------------------\n\tchar str[N];int pos[N],blu[N];bool inB[N];\n\tll Bin[N];\n\tint up[N],dp[N][N][N];\n\tvoid main()\n\t{\n\t\tBin[0]=1;fo(i,1,N-1) Bin[i]=Bin[i-1]*2%MOD;\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);int ans=0;\n\t\tfo(A,0,m/2)\n\t\t{\n\t\t\tint R=0;mem(inB,0);\n\t\t\tfo(i,1,m) if(str[i]=='r')\n\t\t\t{\n\t\t\t\tif(R==A) break;\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1,pos[++R]=j,ok=1;break;}\n\t\t\t\tif(!ok) break;\n\t\t\t}if(R<A) break;\n\t\t\t\n\t\t\tfo(B,0,m)\n\t\t\t{\n\t\t\t\tint cc=0;fo(i,1,m) if(str[i]=='r') cc++,blu[i]=blu[i-1]+(cc>A+B); else blu[i]=blu[i-1]+(!inB[i]);if(cc<A+B) break;\n\t\t\t\tup[A+1]=0,pos[A+1]=m;fd(i,A,1) up[i]=up[i+1]+(blu[pos[i+1]]-blu[pos[i]])+1;reverse(up+1,up+A+1);\n\t\t\t\t\n\t\t\t\tdp[0][0][0]=1;fo(ln,1,m) fo(i,0,A) fo(S,0,up[i]) dp[ln][i][S]=0;\n\t\t\t\tfo(ln,1,m) fo(i,0,A) fo(S,0,min(up[i],up[A]-ln*(A-i))) if(dp[ln-1][i][S])\n\t\t\t\t\tfor(int ad=0;i+ad<=A and S+ad*ln<=up[i+ad];ad++)\n\t\t\t\t\t\tadd(dp[ln][i+ad][S+ad*ln],dp[ln-1][i][S]*facinv[ad]%MOD);\n\t\t\t\tfo(S,0,up[A]) if(dp[m][A][S])\n\t\t\t\t{\n\t\t\t\t\tll feikong=2*S+2*B-1,kekong=A*2+2;//隔板法\n\t\t\t\t\tadd(ans, dp[m][A][S]*C(n+kekong-1, feikong+kekong-1 )%MOD*fac[A+B]%MOD*facinv[B]%MOD );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite(ans);\n\t}\n};//����������\nsigned main()\n{\n\t#ifdef DEBUG\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//����Ԥ����ģ����\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 75\nusing namespace std;\nconst int mod = 1e9+7;\nint n,k,m,a[maxn],x[maxn],C[maxn*2][maxn*2],ans=1;\nchar s[maxn];\nvoid dfs(int d,int l,int r,bool chose){\n\tif(chose){\n\t\tint R=1,B=1,S=0;\n\t\tfor(int i=1;i<=k;i++){\n\t\t\tif(s[i]=='r') {if(R<=m) R++; else if(S) S--;}\n\t\t\tif(s[i]=='b') {if(B<R&&x[B]) S+=x[B++]-1; else if(S) S--;}\n\t\t}\n\t\tif(R>m&&(B>m||!x[B])&&!S){\n\t\t\tint ret=C[n-l+r][r];\n\t\t\tfor(int i=d+1;i<=x[1];i++) S+=a[i],ret=1ll*ret*C[S][a[i]]%mod;\n\t\t\tans=(ans+ret)%mod;\n\t\t}\n\t}\n\tif(d<0) return;\n\tint tm=m,tl=(d?2*d-1:1),tr=2*d+1;\n\tfor(int i=0;l<=n;x[++m]=d,l+=tl+(l!=0),r+=tr+1,i++) \n\t\ta[d]=i,dfs(d-1,l,r,i);\n\tm=tm;\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tfor(int i=C[0][0]=1;i<=140;i++) for(int j=C[i][0]=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\tdfs(n,0,0,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=233;\nconst int mod=1e9+7;\nint n,k,inv[N],jc[N],jcn[N],a[N],ans;\nchar str[N];\nint C(int x,int y){\n\treturn 1ll*jc[x]*jcn[y]%mod*jcn[x-y]%mod;\n}\nint cal(int x,int y){\n\treturn C(x+y-1,y-1);\n}\nvoid check(int y,int z){\n\tint lim=0;while(lim<y&&a[lim+1]>1)++lim;\n\tint cnt_r=0,cnt_b=0,cnt=0;\n\tfor(int i=1;i<=k;++i)\n\t\tif(str[i]=='r'&&cnt_r<y)\n\t\t\t++cnt_r;\n\t\telse if(str[i]=='b'&&cnt_b<min(cnt_r,lim))\n\t\t\t++cnt_b,cnt+=a[cnt_b]-2;\n\t\telse if(cnt)\n\t\t\t--cnt;\n\tif(cnt_r<y||cnt_b<lim||cnt)return;\n\tint pos=y+1,res=jc[y];\n\tfor(int i=1,j=1;i<=y;i=j=j+1){\n\t\twhile(j<y&&a[j+1]==a[i])++j;\n\t\tres=1ll*res*jcn[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(a[i]+a[i]-1);\n\t}\n\tans=(ans+1ll*res*cal(n-z,pos))%mod;\n}\nvoid dfs(int x,int y,int z){\n\tif(z>n)return;check(y,z);\n\tfor(int i=x;i;--i)a[y+1]=i,dfs(i,y+1,z+(y>0)+(i>1?i+i-3:1));\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,str+1);\n\tjc[0]=jcn[0]=inv[1]=1;\n\tfor(int i=2;i<N;++i)inv[i]=1ll*inv[mod%i]*(mod-mod/i)%mod;\n\tfor(int i=1;i<N;++i)jc[i]=1ll*jc[i-1]*i%mod,jcn[i]=1ll*jcn[i-1]*inv[i]%mod;\n\tdfs(70,0,0);printf(\"%d\\n\",ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(p + 2*g > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(int len) {\n    int pos1 = 0, pos2 = 0;\n    for(int i = 0; i < len; i++) {\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        pos1++;\n        pos2++;\n    }\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n        if(N - x - (int)f.size() < 0) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + f.size() + f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        int len = 0;\n        for(int i = 0; i < f.size(); i++) {\n            if(f[i] != 0) len++;\n        }\n\n        if(chk(len)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 75;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[MN * 2], iFac[MN * 2];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\n\nint Len;\nchar Str[MN];\nint posr[MN], nxposb[MN], rcnt;\n\nint N, Ans;\n\nint stk[MN];\ninline void Calc(int cnt, int csum) {\n\tint Sum = 0;\n\tif (!cnt) Sum = 1;\n\telse if (cnt <= rcnt) {\n\t\tstatic int vis[MN];\n\t\tfor (int i = 1; i <= cnt; ++i) vis[i] = posr[i];\n\t\tint tot = cnt, mxp = 1;\n\t\tfor (int i = 1; i <= cnt && stk[i] >= 2; ++i)\n\t\t\tmxp = vis[++tot] = nxposb[std::max(mxp, vis[i])];\n\t\tif (mxp <= Len) {\n\t\t\tstd::inplace_merge(vis + 1, vis + cnt + 1, vis + tot + 1);\n\t\t\tint nwp = Len + 1, sum = 0, now = cnt, ok = 1;\n\t\t\twhile (now && stk[now] == 1) --now;\n\t\t\tfor (int i = tot; i >= 1; --i) {\n\t\t\t\tsum += nwp - vis[i] - 1;\n\t\t\t\tif (Str[vis[i]] == 'b') {\n\t\t\t\t\tsum -= stk[now] - 2;\n\t\t\t\t\tif (sum < 0) { ok = 0; break; }\n\t\t\t\t\t--now;\n\t\t\t\t}\n\t\t\t\tnwp = vis[i];\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tSum = Fac[cnt];\n\t\t\t\tint len = 0, num = 1;\n\t\t\t\tfor (int i = 1; i <= cnt; ++i) {\n\t\t\t\t\t++len;\n\t\t\t\t\tnum += stk[i] * 2;\n\t\t\t\t\tif (i == cnt || stk[i] != stk[i + 1]) {\n\t\t\t\t\t\tSum = (LL)Sum * iFac[len] % Mod;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSum = (LL)Sum * Fac[N - csum + num] % Mod * iFac[num - 1] % Mod * iFac[N - csum + 1] % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tAns -= (Ans += Sum) >= Mod ? Mod : 0;\n}\nvoid DFS(int st, int mx, int sum) {\n\tCalc(st - 1, sum);\n\tif (sum < N) {\n\t\tstk[st] = 1;\n\t\tDFS(st + 1, 1, sum + 2);\n\t}\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (sum + i * 2 <= N + 3) {\n\t\t\tstk[st] = i;\n\t\t\tDFS(st + 1, i, sum + i * 2 - 2);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &Len, Str + 1);\n\tInit(N * 2 + 1);\n\tfor (int i = 1; i <= Len; ++i)\n\t\tif (Str[i] == 'r')\n\t\t\tposr[++rcnt] = i;\n\tint nwposb = Len + 1;\n\tnxposb[Len + 1] = Len + 1;\n\tfor (int i = Len; i >= 1; --i) {\n\t\tnxposb[i] = nwposb;\n\t\tif (Str[i] == 'b')\n\t\t\tnwposb = i;\n\t}\n\tDFS(1, (N + 3) / 2, 0);\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\nconst int M = 200000;\nll fact[M], invfact[M];\nvoid init(void) {\n  fact[0] = 1;\n  REP(i, 1, M) {\n    fact[i] = fact[i - 1] * i % mod;\n  }\n  invfact[M - 1] = powmod(fact[M - 1], mod - 2);\n  for (int i = M - 2; i >= 0; --i) {\n    invfact[i] = invfact[i + 1] * (i + 1) % mod;\n  }\n}\n\nll comb(int x, int y) {\n  if (x < 0) {\n    return y == 0 || y == x ? 1 : 1;\n  }\n  if (y < 0 || y > x) {\n    return 0;\n  }\n  long r = fact[x] * (invfact[x - y] * invfact[y] % mod) % mod;\n  return r;\n}\n\nvoid add(ll &x, ll y) {\n  x = (x + y) % mod;\n}\n\n\nint n, k;\nstring s;\n\n// This function depends on the editorial\nll match(const VI &v) {\n  int m = v.size();\n  VI r(m, -1);\n  VI b(m, -1);\n  VI used(k, 0);\n  int pos = 0;\n  REP(i, 0, m) {\n    while (pos < k && s[pos] != 'r') {\n      pos++;\n    }\n    if (pos == k) return 0;\n    r[i] = pos;\n    used[pos] = 1;\n    pos++;\n  }\n  pos = 0;\n  REP(i, 0, m) {\n    if (v[i] <= 1) break;\n    pos = max(pos, r[i] + 1);\n    while (pos < k && s[pos] != 'b') { pos++; }\n    if (pos == k) return 0;\n    b[i] = pos;\n    used[pos] = 1;\n    pos++;\n  }\n  pos = 0;\n  REP(i, 0, m) {\n    if (v[i] <= 2) break;\n    int res = v[i] - 2;\n    pos = max(pos, b[i] + 1);\n    REP(j, 0, res) {\n      while (pos < k && used[pos] == 1) { pos++; }\n      if (pos == k) return 0;\n      used[pos] = 1;\n      pos++;\n    }\n  }\n  ll tmp = fact[v.size()];\n  map<int, int> freq;\n  REP(i, 0, v.size()) {\n    freq[v[i]] += 1;\n  }\n  for (auto p: freq) {\n    tmp = tmp * invfact[p.second] % mod;\n  }\n  int x = n + 1;\n  int y = 0;\n  REP(i, 0, v.size()) {\n    if (v[i] >= 2) {\n      x += 2;\n    }\n    y += 2 * v[i];\n  }\n  if(DEBUG){\n    DEBUGP(x);\n    DEBUGP(y);\n  }\n  tmp = tmp * comb(x, y) % mod;\n  return tmp;\n}\n\nint cnt = 0;\nll tot = 0;\nvoid output(const VI &vi) {\n  cnt++;\n  if (DEBUG && n <= 10) {\n    cerr << \"out:\";\n    for (auto c: vi) cerr << \" \" << c;\n    cerr << endl;\n  }\n  ll res = match(vi);\n  add(tot, res);\n  if (DEBUG) {\n    DEBUGP(res);\n    cerr<<endl;\n  }\n}\n\n\nvoid calc(int rem, int ma, int maxlen, VI &v) {\n  if (rem < -1) return;\n  output(v);\n  if ((int) v.size() >= maxlen) return;\n  for (int i = ma; i >= 1; --i) {\n    v.push_back(i);\n    int len = i <= 1 ? 1 : 2 * i - 3;\n    calc(rem - len - 1, i, maxlen, v);\n    v.pop_back();\n  }\n}\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init();\n  cin >> n >> k;\n  cin >> s;\n  VI ret;\n  int rc = 0;\n  REP(i, 0, k) {\n    if (s[i] == 'r') rc++;\n  }\n  calc(n, k, rc, ret);\n  DEBUGP(cnt);\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll MOD = 1e9+7;\n\n// n^m%MOD を求める。O( log(m) )\nll modpow(ll n, int m){\n\tll ret=1;\n\tfor(int i=1; i<=m; i<<=1, (n*=n)%=MOD){\n\t\tif( m&i ) (ret *= n) %= MOD;\n\t}\n\treturn ret;\n}\n\n// 逆元を求める\nll modinv(ll n){\n\treturn modpow( n, MOD-2 );\n}\n\n// 階乗を求める。O(1)  準備O( n*log(n) )\n// fact[n]     : nの階乗\n// fact.inv[n] : nの階乗の逆元\nclass FACTORIAL{\npublic:\n\tvector<ll> fact, inv;\n\tFACTORIAL(int MAX_NUM): fact(MAX_NUM), inv(MAX_NUM) {\n\t\tfact[0] = inv[0] = 1;\n\t\tfor(ll i=1; i<MAX_NUM; i++){\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t\tinv[i] = modinv( fact[i] );\n\t\t}\n\t}\n\tconst ll& operator [ ] ( const int i ) const {\n\t\treturn fact[i];\n\t}\n} fact(1000006); // nの最大値を指定\n\n\n// 組み合わせ(Combinationを求める) O(1)\nll cmb(unsigned int n, unsigned int r){\n\tif( n < r ) return 0;\n\treturn fact[n] * fact.inv[r] % MOD * fact.inv[n-r] % MOD;\n}\n\n\nvector<vector<int>> vec;\nvoid dfs(vector<int> &v, int n, int last=1){\n\tvec.push_back(v);\n\tif(last <= 1 && n >= 1){\n\t\tauto _v = v;\n\t\t_v.push_back(1);\n\t\tdfs(_v, n-2, 1);\n\t}\n\tif(last <= 2 && n >= 2){\n\t\tauto _v = v;\n\t\t_v.push_back(2);\n\t\tdfs(_v, n-2, 2);\n\t}\n\tif( last <= 2 ){\n\t\tlast = 3;\n\t}\n\tfor(int i = last; i <= n; i+=2){\n\t\tauto _v = v;\n\t\t_v.push_back(i);\n\t\tdfs(_v, n-i-1, i);\n\t}\n}\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint N, K;\n\tstring s;\n\tll ans = 0;\n\n\tcin >> N >> K;\n\tcin >> s;\n\n\tvector<int> _v;\n\tdfs(_v, N);\n\t//cout << vec.size() << endl;\n\n\tfor(auto v: vec){\n\t\treverse(all(v));\n\t\tint a[70]={}, b[70]={}, c[70]={}, used[100]={};\n\n\t\t// check 1\n\t\tint pos = 0;\n\t\tif(pos < v.size()) rep(i,s.length()) if(s[i] == 'r'){\n\t\t\tused[i] = true;\n\t\t\ta[pos++] = i;\n\t\t\tif(pos >= v.size()) break;\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t// check 2\n\t\tpos = 0;\n\t\twhile(pos < v.size() && v[pos] < 2) pos++;\n\t\tif(pos < v.size()) rep(i,s.length()) if(s[i] == 'b' && a[pos] < i){\n\t\t\tused[i] = true;\n\t\t\tb[pos++] = i;\n\t\t\twhile(pos < v.size() && v[pos] < 2) pos++;\n\t\t\tif(pos >= v.size()) break;\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t// check 3\n\t\tpos = 0;\n\t\twhile(pos < v.size() && v[pos] < 3) pos++;\n\t\tif(pos < v.size()) rep(i,s.length()) if(!used[i] && b[pos] < i){\n\t\t\tused[i] = true;\n\t\t\tc[pos]++;\n\t\t\tif( c[pos] >= v[pos] / 2 ){\n\t\t\t\tpos++;\n\t\t\t\twhile(pos < v.size() && v[pos] < 3) pos++;\n\t\t\t\tif(pos >= v.size()) break;\n\t\t\t}\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t//cout << v << \"\\t\";\n\t\t// ok\n\t\tll less = N;\n\t\tfor(auto t: v) less -= t + 1;\n\t\tfor(auto t: v) if(t == 2) less++;\n\t\tif( !v.empty() ) less++;\n\t\t//cout << \"less=\" << less << \" \";\n\n\t\tll num = v.size() + 1;  // for White\n\t\tfor(auto t: v){  // for Red\n\t\t\tif(t == 1) num++;\n\t\t\telse if(t == 2) num += 2;\n\t\t\telse num += t / 2 + 2;\n\t\t}\n\t\tfor(auto t: v){  // for Blue\n\t\t\tif(t == 1) ;\n\t\t\telse if(t == 2) num += 1;\n\t\t\telse num += t / 2 + 1;\n\t\t}\n\t\t//cout << \"num=\" << num << \" \";\n\n\t\tll sum = fact[v.size()];\n\t\tll bf = -1, cnt=0;\n\t\tv.push_back(-1);\n\t\tfor(auto t: v){\n\t\t\tcnt++;\n\t\t\tif(bf != t){\n\t\t\t\t//cout << \"c=\" << cnt << \" \";\n\t\t\t\tsum = (sum * fact.inv[cnt]) % MOD;\n\t\t\t\tcnt = 0;\n\t\t\t\tbf = t;\n\t\t\t}\n\t\t}\n\t\t//cout << sum << \" \";\n\t\tsum = (sum * cmb(num + less - 1, less)) % MOD;\n\t\tans = (ans + sum) % MOD;\n\t\t//cout << \"sum=\" << sum << endl;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=1005;\nint C[maxn][maxn];\nint fac[maxn],invfac[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=1LL*fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline int comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nvi apos;\nint ca=0;\nint n,k;\nint suf[75];\nvi f;\nint solve()\n{\n    if(!f.size()) return 1;\n    int need=0,needb=0;\n    int p=0;\n    for(int i=f.size()-1;i>=0;i--)\n    {\n        need+=f[p]-1;\n        if(f[p]>1) needb++;\n        if(suf[apos[i]]+apos.size()-f.size()<need||suf[apos[i]]<needb) return 0;\n        p++;\n    }\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++)\n    {\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    int ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nint dfs(int r,int mx,int cc,int len=0)\n{\n    if(len+(int)f.size()-1>n) return 0;\n    int ret=1LL*solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(f.size()>=ca) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        int cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=1LL*cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    for(int i=0;i<k;i++) \n    {\n        ca+=s[i]=='r';\n        if(s[i]=='r') apos.push_back(i);\n    }\n    for(int i=k-1;i>=0;i--)\n        suf[i]=suf[i+1]+(s[i]=='b');\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 70;\nconst int MAXSLEN = 70;\nconst int MOD = 1000000007;\n\nint n, slen; char s[MAXSLEN + 1];\n\nbool used[MAXSLEN];\nint mxextrablue[MAXN]; // mxextrablue[i] = maximum extra blue in segments i..numwithblue-1\n\nint C[10 * MAXN + 1][10 * MAXN + 1];\nint ways[MAXN + 1][MAXSLEN + 1][MAXSLEN + 1]; // #seg, #usedextrablue, #extrablueinlast\n\nvoid inc(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\nint calc(int numwithblue, int numred) {\n\tint havered = 0, havewithblue = 0;\n\tREP(i, numwithblue) mxextrablue[i] = 0;\n\tREP(i, slen) {\n\t\tused[i] = false;\n\t\tif (s[i] == 'r'&&havewithblue + havered < numwithblue + numred) used[i] = true, ++havered;\n\t\tif (s[i] == 'b'&&havered > 0 && havewithblue < numwithblue) used[i] = true, --havered, ++havewithblue;\n\t\tif (!used[i] && havewithblue > 0) mxextrablue[havewithblue - 1]++;\n\t}\n\tfor (int i = havewithblue - 1; i > 0; --i) mxextrablue[i - 1] += mxextrablue[i];\n\tif (havered != numred || havewithblue != numwithblue) return 0;\n\t//printf(\"mxextrablue:\"); REP(i, havewithblue) printf(\" %d\", mxextrablue[i]); puts(\"\");\n\n\tint mxtotextrablue = numwithblue == 0 ? 0 : mxextrablue[0];\n\tREPE(i, numwithblue) REPE(j, mxtotextrablue) REPE(k, mxtotextrablue) ways[i][j][k] = 0;\n\tways[0][0][0] = 1;\n\tREPE(i, numwithblue) REPE(usedextrablue, mxtotextrablue) REPE(lastextrablue, mxtotextrablue) if (ways[i][usedextrablue][lastextrablue] != 0) {\n\t\t//printf(\"\\t[%d,%d,%d]=%d\\n\", i, usedextrablue, lastextrablue, ways[i][usedextrablue][lastextrablue]);\n\t\tint limextrablue = INT_MAX;\n\t\tFORE(di, 1, numwithblue - i) {\n\t\t\tint num = mxextrablue[numwithblue - i - di] - usedextrablue, den = di; if (num < 0) break;\n\t\t\tlimextrablue = min(limextrablue, num / den); if (i != 0 && limextrablue <= lastextrablue) break;\n\t\t\t//printf(\"\\t\\t%d: lim=%d\\n\", di, limextrablue);\n\t\t\tFORE(extrablue, i == 0 ? 0 : lastextrablue + 1, limextrablue) {\n\t\t\t\tint cways = (ll)ways[i][usedextrablue][lastextrablue] * C[numwithblue - i][di] % MOD;\n\t\t\t\tinc(ways[i + di][usedextrablue + di*extrablue][extrablue], cways);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\tREPE(usedextrablue, mxtotextrablue) REPE(lastextrablue, mxtotextrablue) if (ways[numwithblue][usedextrablue][lastextrablue] != 0) {\n\t\tint cways = ways[numwithblue][usedextrablue][lastextrablue];\n\t\tint nonemptywhite = numred + numwithblue > 0 ? numred + numwithblue - 1 : 1, nonemptyred = numred + usedextrablue, nonemptyblue = numwithblue + usedextrablue, canemptywhite = numred + numwithblue > 0 ? 2 : 0, canemptyred = 2 * numwithblue;\n\t\tint nonempty = nonemptywhite + nonemptyred + nonemptyblue, canempty = canemptywhite + canemptyred;\n\t\tif (nonempty > n) continue;\n\t\tint rem = n - nonempty, slots = nonempty + canempty;\n\t\tinc(ret, (ll)cways*C[rem + slots - 1][slots - 1] % MOD);\n\t\t//if (numwithblue == 2 && numred == 0) printf(\"[%d,%d]->%d\\n\", usedextrablue, lastextrablue, C[rem + slots - 1][slots - 1]);\n\t}\n\tret = (ll)ret*C[numwithblue + numred][numred] % MOD;\n\t//printf(\"calc(%d,%d)=%d\\n\", numwithblue, numred, ret);\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d%s\", &n, &slen, s);\n\tREPE(i, 10 * n) { C[i][0] = C[i][i] = 1; FOR(j, 1, i) C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD; }\n\tint ret = 0;\n\tREPE(numwithblue, n) REPE(numred, n- numwithblue) ret = (ret + calc(numwithblue, numred)) % MOD;\n\tprintf(\"%d\\n\", ret);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nint n,k;\nchar s[110];\nint nxt[110][2];\nint fac[410],inv[410];\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(long long)ans*t%Mod;\n\t\tt=(long long)t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tint N=400;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=(long long)inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\treturn (long long)fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint ans;\nint f[110],g[110],h[110];\nbool vis[110];\nvoid calc(int num)\n{\n\t//check\n\tfor(int i=1;i<=k;i++)\n\t\tvis[i]=false;\n\tint cur=nxt[1][0],cnt=0;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1&&cnt==0)\n\t\t\tcnt=num-i+1;\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;h[i]=cur;\n\t\tcur=nxt[cur+1][0];\n\t}\n\tcur=nxt[1][1];\n\tfor(int i=1;i<=num-cnt;i++)\n\t{\n\t\twhile(cur<=k&&(cur<h[i]||vis[cur]))\n\t\t\tcur=nxt[cur+1][1];\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;\n\t\tg[i]=cur;\n\t}\n\tint now=num-cnt;\n\tcur=f[now];\n\twhile(cur<=2&&now>0){\n\t\tnow--;\n\t\tcur=f[now];\n\t}\n\tfor(int i=k;i>=1;i--)\n\t\tif(!vis[i]){\n\t\t\tif(now<=0)break;\n\t\t\tif(i<g[i])return ;\n\t\t\tvis[i]=true;\n\t\t\tcur--;\n\t\t\twhile(cur<=2&&now>0){\n\t\t\t\tnow--;\n\t\t\t\tcur=f[now];\n\t\t\t}\n\t\t}\n\tif(now>0)return ;\n\tint sum=fac[num];cur=0;\n\tint cntb=0,cntr=0,cntw=num-1;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1)cntr++;\n\t\telse cntr+=f[i]-2,cntb+=f[i]-1;\n\t\tif(i==1||f[i]==f[i-1])cur++;\n\t\telse{\n\t\t\tsum=(long long)sum*inv[cur]%Mod;\n\t\t\tcur=1;\n\t\t}\n\t}\n\tsum=(long long)sum*inv[cur]%Mod;\n\tint cntB=(num-cnt)*2+1;//rbr->2(num-cnt)  ...rw->1\n\tif(cntb+cntr+cntw>n)return ;\n\tsum=(long long)sum*C(n+cntB,cntb+cntr+cntw+cntB)%Mod;\n//\tfor(int i=1;i<=num;i++)\n//\t\tprintf(\"%d \",f[i]);\n//\tprintf(\":%d\\n\",sum);\n\tans=(ans+sum)%Mod;\n\treturn ;\n}\nvoid dfs(int x,int rest,int rest2,int cnt)\n{\n\tif(rest<0)return ;\n\tif(x==0){\n\t\tcalc(cnt);\n\t\treturn ;\n\t}\n\tfor(int i=0;i*x<=rest2;i++)\n\t{\n\t\tif(i>0)f[cnt+i]=x;\n\t\tdfs(min(x-1,rest2-i*x),rest-i*(x==1?1:(2*x-3)),rest2-i*x,cnt+i);\n\t}\n\treturn ;\n}\nint main()\n{\n//\tf[1]=2;\n//\tcalc(2);\n//\tprintf(\"%d\\n\",ans);\n\t\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tnxt[k+1][0]=nxt[k+1][1]=k+1;\n\tfor(int i=k;i>=1;i--)\n\t{\n\t\tnxt[i][0]=nxt[i+1][0];\n\t\tnxt[i][1]=nxt[i+1][1];\n\t\tif(s[i]=='r')nxt[i][0]=i;\n\t\telse nxt[i][1]=i;\n\t}\n\tinit();\n\tdfs(k,n,k,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n/*\n3 4\nrbrb\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 75\n#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)\n#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)\n#define mod 1000000007\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\n\nint n,K,fac[maxn << 2],invf[maxn << 2],inv[maxn << 2];\nint C(int a,int b){ if(a<0 || b<0 || a-b<0) return 0;return fac[a] * 1ll * invf[b] % mod * invf[a-b]%mod; }\nchar s[maxn];\nvi p;int ans;\n\nvoid add(int &u,int v){ ((u+=v)>=mod)&&(u-=mod); }\nvoid sub(int &u,int v){ ((u-=v)<0) && (u+=mod); }\n\nbool check(){\n\tstatic bool vis[maxn];\n\tstatic int loc[maxn];\n\tmemset(vis,0,sizeof vis);\n\tint j=1;\n\tfor(int i=p.size()-1;i>=0 && p[i];i--){\n\t\tfor(;j <= K && s[j] != 'r';j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , loc[i] = j , j++;\n\t}\n\tj=1;\n\tfor(int i=p.size()-1;i>=0 && p[i];i--){\n\t\tj = max(j , loc[i]);\n\t\tfor(;j <= K && s[j] != 'b';j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , loc[i] = j , j++;\n\t}\n\tj=1;\n\tfor(int i=0;i<p.size() && p[i]==0;i++){\n\t\tfor(;j <= K && (s[j] != 'r' || vis[j]);j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , j++;\n\t}\n\tj=1;\n\tfor(int i=p.size()-1;i>=0 && p[i] > 1;i--){\n\t\tj = max(j , loc[i]);\n\t\trep(k,2,p[i]){\n\t\t\tfor(;j <= K && vis[j];j++);\n\t\t\tif(j > K) return 0;\n\t\t\tvis[j] = 1 , j++;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid dfs(int sz,int mx,int lim){\n\tif(sz > n) return;\n\t\n\tif(check()){\n\t\t//printf(\"@%d\\n\",p.size());\n\t\t//rep(i,0,p.size()-1) printf(\"%d%c\",p[i],\" \\n\"[i==p.size()-1]);\n\t\t//putchar('\\n');\n\t\tint sm = fac[p.size()];\n\t\tfor(int i=0,j;i<p.size();i=j){\n\t\t\tfor(j=i;j<p.size() && p[j] == p[i];j++);\n\t\t\tsm = 1ll * sm * invf[j-i] % mod;\n\t\t}\n\t\tans = (ans + 1ll * C(n-sz+mx-1,mx-1) * sm) % mod;\n\t\t//printf(\"%d %d %d %d\\n\",sm,ans,sz,mx);\n\t}\n\telse return;\n\trep(i,lim,(n-sz)/2){\n\t\tp.pb(i);\n\t\tdfs(sz+max(2*i-1,1)+(sz!=0),mx+2*i+2,i);\n\t\tp.pop_back();\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tscanf(\"%s\",s+1);\n\tfac[0] = inv[0] = inv[1] = fac[1] = invf[0] = invf[1] = 1;\n\trep(i,2,(maxn << 2) - 1) fac[i] = 1ll * fac[i-1] * i % mod , inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod,\n\t\tinvf[i] = 1ll * invf[i-1] * inv[i] % mod;\n\tdfs(0,1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 107\n\nint N, K, tot, res;\nint mch[MAX_N], pos[MAX_N], sum[MAX_N];\nint fac[MAX_N * 3], ifac[MAX_N * 3];\nchar s[MAX_N];\nbool vis[MAX_N];\n\ninline int C(int x, int y) {\n    if (y < 0 || x < y) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid init() {\n    int MX = 300;\n    fac[0] = ifac[0] = 1;\n    Rep(i, MX) fac[i] = mul(fac[i - 1], i);\n    ifac[MX] = qpow(fac[MX], MOD - 2);\n    irep(i, MX, 2) ifac[i - 1] = mul(ifac[i], i);\n    Rep(i, K) if (s[i] == 'r') {\n        pos[++tot] = i;\n        rep(j, i + 1, K) if (s[j] == 'b' && !vis[j]) {\n            mch[i] = j;\n            vis[j] = true;\n            break;\n        }\n    }\n}\n\nint tp[MAX_N];\nbool check(int cur) {\n    if (cur > tot) return false;\n    Rep(i, K) sum[i] = 0;\n    int p = 1;\n    IRep(i, cur) {\n        sum[pos[i]]++;\n        if (tp[p] > 1) {\n            if (!mch[pos[i]]) return false;\n            sum[mch[pos[i]]] += tp[p] - 1;\n        }\n        p++;\n    }\n    IRep(i, K) {\n        sum[i] += sum[i + 1];\n        if (sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\n\nbool dfs(int deg, int pre, int len) {\n    if (!check(deg - 1)) return false;\n    int t = deg;\n    Lep(i, deg) t += 2 * tp[i] - 1;\n    int ans = mul(C(N - len + t - 1, t - 1), fac[deg - 1]), tmp = 1;\n    Lep(i, deg) {\n        if (tp[i] != tp[i - 1]) {\n            ans = mul(ans, ifac[tmp]);\n            tmp = 0;\n        }\n        ++tmp;\n    }\n    ans = mul(ans, ifac[tmp]);\n    // printf(\"%d:  \", ans);\n    // Lep(i, deg) printf(\"%d \", tp[i]);\n    // puts(\"\");\n    inc(res, ans);\n    if (deg > tot) return true;\n    rep(i, pre, 70) {\n        int L = len;\n        if (deg > 1) L++;\n        if (i == 1)\n            L++;\n        else\n            L += i - 2 + i - 1;\n        if (L > N) break;\n        tp[deg] = i;\n        if (!dfs(deg + 1, i, L)) break;\n    }\n    return true;\n}\n\nvoid solve() {\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N), read(K);\n    scanf(\"%s\", s + 1);\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nll nHr(ll n,ll r){\n\treturn nCk(n+r-1,r);\n}\n\nint n,m;\nvi a;\n\nint main(){\n\tInit();\n\tcin>>n>>m;\n\ta=vi(m);\n\tfor(int i=0;i<m;i++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='b') a[i]++;\n\t}\n\tll res=1;\n\tfor(int i=0;i<=n;i++) for(int j=0;j<=n;j++){\n\t\tvi b(m),c(i);\n\t\tint A=0,B=0,C=0;\n\t\tfor(int k=0;k<m;k++){\n\t\t\tif(!a[k]&&A+B!=i) A++,b[k]=1;\n\t\t\telse if(a[k]&&A) A--,b[k]=1,c[B++]=k;\n\t\t}\n\t\tfor(int k=0;k<m;k++) if(a[k]+b[k]==0&&C<j) C++,b[k]=1;\n\t\tif(B!=i||C!=j||2*i+2*j-1>n||i+j==0) continue;\n\t\tfor(int k=0;k<i;k++){\n\t\t\tint l=c[k];\n\t\t\tc[k]=0;\n\t\t\twhile(l<m) c[k]+=1-b[l++];\n\t\t\tc[k]=min(c[k],(n-2*i-2*j+1)/2);\n\t\t}\n\t\tc.push_back(0);\n\t\treverse(c.begin(),c.end());\n\t\tvvl dp(i+1,vl(n+1));\n\t\tdp[0][0]=Div(F[i+j],F[j]);\n\t\tfor(int k=0;k<n;k++) for(int I=i;I>=0;I--) for(int J=0;J<=c[I];J++) for(int l=1;I+l<=i&&J+k*l<=c[I+l];l++){\n\t\t\tdp[I+l][J+k*l]+=Div(dp[I][J],F[l]);\n\t\t}\n\t\tfor(int k=0;k<=c[i];k++) (res+=dp[i][k]*nHr(2*k+4*i+2*j+1,n-2*k-2*i-2*j+1))%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n#define N 75\n#define ll long long\n#define mo 1000000007\nll qpow(ll x,ll y=mo-2){\n\tll r=1;\n\tfor (;y;y>>=1,x=x*x%mo)\n\t\tif (y&1)\n\t\t\tr=r*x%mo;\n\treturn r;\n}\nll fac[N*4],ifac[N*4];\nvoid initC(int n){\n\tfac[0]=1;\n\tfor (int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%mo;\n\tifac[n]=qpow(fac[n]);\n\tfor (int i=n-1;i>=0;--i)\n\t\tifac[i]=ifac[i+1]*(i+1)%mo;\n}\nll inv(int n){return ifac[n]*fac[n-1]%mo;}\nll C(int m,int n){\n\tif (m<n) return 0;\n\treturn fac[m]*ifac[n]%mo*ifac[m-n]%mo;\n}\nint n,K;\nchar str[N];\nint p[N],m;\nll ans;\nbool judge(){\n\tstatic int q[N],need[N];\n\tstatic int used[N];\n\tint head=1,tail=0;\n\tmemset(used,255,sizeof(int)*(K+1));\n\tint i=1,j=1;\n\tfor (;j<=K && i<=m && p[i]>1;++j){\n\t\tif (head<=tail && str[j]=='b')\n\t\t\tused[j]=p[i++]-2,used[q[head++]]=0;\n\t\telse if (str[j]=='r')\n\t\t\tq[++tail]=j;\n\t}\n\tif (i<=m && p[i]>1) return 0;\n\tfor (;j<=K;++j)\n\t\tif (str[j]=='r')\n\t\t\tq[++tail]=j;\n\tfor (;i<=m;++i){\n\t\tif (head>tail) return 0;\n\t\tused[q[head++]]=0;\n\t}\n\tint cnt=0;\n\tfor (int j=K;j>=1;--j){\n\t\tif (used[j]==-1)\n\t\t\tcnt++;\n\t\telse if (used[j]>0){\n\t\t\tif (cnt<used[j]) return 0;\n\t\t\tcnt-=used[j];\n\t\t}\n\t}\n\treturn 1;\n}\nll calc(){\n//\tfor (int i=1;i<=m;++i)\n//\t\tprintf(\"%d \",p[i]);\n//\tprintf(\"\\n\");\n\tif (m==0) return 1;\n\tp[m+1]=-1;\n\tll s=fac[m];\n\tfor (int i=1,j=0;i<=m;++i){\n\t\tj++;\n\t\tif (p[i]!=p[i+1]){\n\t\t\ts=s*ifac[j]%mo;\n\t\t\tj=0;\n\t\t}\n\t}\n\tll c0=2,c1=m-1;\n\tfor (int i=1;i<=m;++i){\n\t\tif (p[i]==1)\n\t\t\tc1++;\n\t\telse{\n\t\t\tc1+=2*p[i]-3;\n\t\t\tc0+=2;\n\t\t}\n\t}\n\ts=s*C((n-c1)+(c1+c0)-1,n-c1)%mo;\n//\tprintf(\"ans=%lld\\n\",s);\n\treturn s;\n}\nvoid dfs(int s,int k){\n\tif (judge())\n\t\tans+=calc();\n\tif (s==0)\n\t\treturn;\n\tfor (int i=k;i>=1;--i){\n\t\tif (s>=2*i-1+(s!=n)){\n\t\t\tp[++m]=i+1;\n\t\t\tdfs(s-(2*i-1)-(s!=n),i);\n\t\t\t--m;\n\t\t}\n\t}\n\tif (s>=1+(s!=n)){\n\t\tp[++m]=1;\n\t\tdfs(s-1-(s!=n),0);\n\t\t--m;\n\t}\n}\nint main(){\n//\tfreopen(\"in.txt\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&K,str+1);\n\tinitC(n*4);\n\tdfs(n,n);\n\tans%=mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\n#define left LEFT\ntypedef long long ll;\nconst int N = 510;\nconst int mod = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check()\n{\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    FOR(i, 1, k)\n    {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update()\n{\n    ll tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1)\n    {\n        for(j = i; a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % mod;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % mod;\n    if ((ans += tmp) >= mod) ans -= mod;\n}\n\nvoid dfs(int mx)\n{\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    ++tot; --left; dfs(a[tot] = 1); ++left;\n    FOR(i, 2, mx)\n    {\n        left -= i * 2 - 3;\n        dfs(a[tot] = i);\n        left += i * 2 - 3;\n    }\n    a[tot--] = 0;\n    if (tot) ++left;\n}\n\nint main()\n{\n    FOR(i, 0, 500)\n    {\n        c[i][0] = 1;\n        FOR(j, 1, 500)\n            if ((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= mod)\n                c[i][j] -= mod;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(100);\n    printf(\"%d\\n\", (ans + 1) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[N], tmp[N], top = 0;\nchar str[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nlong long solve () {\n\tqueue<int> que;\n\tfor (int i = 0; i < m; i++) suf[i] = 1;\n\tfor (int i = 0, j = top - 1; i < m && j >= 0; i++) {\n\t\tif (str[i] == 'r') que.push(i);\n\t\tif (!stk[j] && !que.empty()) {\n\t\t\tsuf[que.front()] = 0, que.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\tif (stk[j] && str[i] == 'b' && !que.empty()) {\n\t\t\tsuf[que.front()] = suf[i] = 0;\n\t\t\tque.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\tif (i == m - 1 && j >= 0) return 0ll;\n\t}\n\n\tsuf[m] = 0;\n\tfor (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n\tfor (int i = 0, j = 0; i < top; i++) {\n\t\tif (stk[i]) {\n\t\t\tj += stk[i] - 1;\n\t\t\tif (suf[pos[i]] < j) return 0ll;\n\t\t}\n\t}\n\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\treturn res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn 1;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =1000000007;\n\nmap< vector<int>, int > M;\nvector< vector<int> > Mi;\nvector<int> cnt[71];\n\nint MX =70;\n\nvoid put(vector<int> &seq, int x) {\n\tfor(int i =(int)seq.size()-1; i >= 0; i--) if(seq[i] >= x) {\n\t\tseq.insert(begin(seq)+i+1,x);\n\t\treturn;\n\t}\n\tseq.insert(begin(seq),x);\n}\n\nint get_id(vector<int> &seq) {\n\tauto it =M.find(seq);\n\tif(it == M.end()) {\n\t\tint m =M.size();\n\t\tM[seq] =m;\n\t\tMi.push_back(seq);\n\t\treturn m;\n\t}\n\treturn it->ss;\n}\n\nvoid dump(int id, int sum, cat cnt_cur) {\n\tif(id >= (int)cnt[sum].size())\n\t\tcnt[sum].resize(id+1,0);\n\tcnt[sum][id] +=cnt_cur;\n\tif(cnt[sum][id] >= mod) cnt[sum][id] -=mod;\n}\n\nvoid push(int id, int sum, cat cnt_cur) {\n\tvector<int> seq =Mi[id];\n\t// add 0\n\tint sum_nw =sum+int(!seq.empty())+1;\n\tseq.push_back(0);\n\tint id_nw =get_id(seq);\n\tif(sum_nw <= MX) dump(id_nw,sum_nw,cnt_cur);\n\t// add non-0\n\tint a =seq.size()-1;\n\tfor(int i =1; i < 100; i++) {\n\t\tif(sum_nw > MX) break;\n\t\tseq[a]++;\n\t\twhile(a > 0 && seq[a-1] < seq[a]) {\n\t\t\tswap(seq[a],seq[a-1]);\n\t\t\ta--;\n\t\t}\n\t\tid_nw =get_id(seq);\n\t\tdump(id_nw,sum_nw,cnt_cur);\n\t\tsum_nw +=2;\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\n\tMi.resize(1);\n\tM[vector<int>()] =0;\n\tcnt[0].resize(1,1);\n\tint st =0;\n\tfor(int i =0; i < MX; i++) {\n\t\tint st_nw =M.size();\n\t\tfor(int sum =MX; sum >= 0; sum--)\n\t\t\tfor(int l =st; l < (int)cnt[sum].size(); l++) if(cnt[sum][l])\n\t\t\t\tpush(l,sum,cnt[sum][l]);\n\t\tst =st_nw;\n\t}\n\tcat C[200][200];\n\tmemset(C,0,sizeof(C));\n\tfor(int i =0; i < 200; i++) {\n\t\tC[i][0] =1;\n\t\tfor(int j =1; j <= i; j++) C[i][j] =(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\n\tint N,K;\n\tstring S;\n\tcin >> N >> K >> S;\n\n\tint ans =0;\n\tfor(int sum =0; sum <= N; sum++) for(int i =0; i < (int)cnt[sum].size(); i++) {\n\t\tif(cnt[sum][i] == 0) continue;\n\t\tvector<int> seq =Mi[i];\n\n\t\tint a =0, b =0, c =0;\n\t\tvector<int> seqb;\n\t\tfor(int i =0; i < K; i++) {\n\t\t\tif(S[i] == 'r') {\n\t\t\t\tif(a < (int)seq.size()) {\n\t\t\t\t\tif(seq[a]) seqb.push_back(seq[a]);\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif(b > 0) b--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(c < (int)seqb.size()) {\n\t\t\t\t\tb +=seqb[c];\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tif(b > 0) b--;\n\t\t\t}\n\t\t}\n\t\tif(a < (int)seq.size() || c < (int)seqb.size() || b > 0) continue;\n\n\t\tint buckets =seq.size()+1;\n\t\tALL_THE(seq,it) buckets +=2*(*it)+1;\n\t\tcat cnt_ins =C[N-sum+buckets-1][buckets-1];\n\n\t\tans =(ans+cnt[sum][i]*cnt_ins)%mod;\n\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nconst int p=1000000007;\nstruct Z{\n\tuint x;\n\tZ(){}\n\tZ(uint a){\n\t\tx=a;\n\t}\n};\ninline uint modp(const uint x){\n\treturn x<p?x:x-p;\n}\ninline Z operator+(const Z x1, const Z x2) { return modp(x1.x+x2.x);}\ninline Z operator-(const Z x1, const Z x2) { return modp(x1.x+p-x2.x);}\ninline Z operator-(const Z x) {return x.x?p-x.x:0;}\ninline Z operator*(const Z x1, const Z x2) { return static_cast<ull>(x1.x)*x2.x%p;}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(!b){x=1;y=0;return;}\n\texgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n}\ninline Z Inv(const Z a){\n\tint x,y;\n\texgcd(p,a.x,x,y);\n\treturn y<0?y+=p:y;\n}\ninline Z operator/(const Z x1, const Z x2) { return x1*Inv(x2);}\n\ninline Z &operator++(Z &x1){x1.x==p-1?x1.x=0:++x1.x;return x1;} \ninline Z &operator--(Z &x1){x1.x?--x1.x:x1.x=p-1;return x1;}\ninline Z &operator+=(Z &x1, const Z x2) { return x1 = x1 + x2; }\ninline Z &operator-=(Z &x1, const Z x2) { return x1 = x1 - x2; }\ninline Z &operator*=(Z &x1, const Z x2) { return x1 = x1 * x2; }\ninline Z &operator/=(Z &x1, const Z x2) { return x1 = x1 / x2; }\ninline Z fpm(Z a,int b){Z c(1);for(;b;b>>=1,a*=a)if(b&1)c*=a;return c;}\nZ ans;\nint cnt=0;\nint n,k;\nint m;\nint a[75];\nint b[75];\nchar s[75];\nZ c[1005][1005];\nvoid check(){\n//\tfor(int i=1;i<=m;++i)write(a[i],i==m?'\\n':' ');\n\tint c1=1,c2=1;\n\tfor(int i=1;i<=m;++i){\n\t\tb[i]=a[i]+1;\n\t\tc1+=(a[i]+1)<<1;\n\t\tc2+=(a[i]?2:0);\n\t}\n\tif(m)++c2;\n\tint at1=m,at2=m,at3=m;\n\tfor(int i=1;i<=k;++i){\n\t\tif(s[i]=='r'){\n\t\t\tif(at1){--b[at1];--at1;}\n\t\t\telse{\n\t\t\t\twhile(at3>at2 && !b[at3])--at3;\n\t\t\t\tif(at3>at2){--b[at3];}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(at2>at1 && b[at2]){--b[at2];--at2;}\n\t\t\telse{\n\t\t\t\twhile(at3>at2 && !b[at3])--at3;\n\t\t\t\tif(at3>at2){--b[at3];}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i)if(b[i])return;\n\tZ w=c[n+c2-1][c1-1];\n\tfor(int i=1;i<=m;){\n\t\tint j=i;\n\t\twhile(j<=m && a[j]==a[i])++j;\n\t\tw*=c[j-1][j-i];\n\t\ti=j;\n\t}\n//\twrite(n,' ',c1,' ',c2,' ',c[n+c2-1][c1-1].x,'|',w.x,\",ok!\\n\");\n\tans+=w;\n/*\tfor(int i=1;i<=m;++i)write(a[i],i==m?'\\n':' ');\n\twrite('|',c1,' ',c2,'|',k+c2-1,',',c1-1,' ',c[k+c2-1][c1-1].x,'\\n');*/\n}\nvoid dfs(int x,int y){\n\tcheck();\n\tfor(;y<=x;++y){\n\t\ta[++m]=y;\n\t\tdfs(x-y,y);\n\t\t--m;\n\t}\n}\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tread(n,k);\n\tfor(int i=0;i<=1000;++i){\n\t\tc[i][0]=c[i][i]=1;\n\t\tfor(int j=1;j<i;++j)c[i][j]=c[i-1][j]+c[i-1][j-1];\n\t}\n\tread(s+1);\n\tint s=(n+1)>>1;\n\twhile(s>=0){\n\t\tdfs(s,1);\n\t\ta[++m]=0;\n\t\t--s;\n\t}\n\twrite(ans.x,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n} c(150);\n\nmint res;\nint n,k;\nstring s;\nbool trk[77];\nint pos[77];\nint cnt[77];\n\nbool check(const vector<int>& ip, int sum) {\n    memset(trk, 0, sizeof trk);\n    memset(pos, -1, sizeof pos);\n    memset(cnt, 0, sizeof cnt);\n    int m = ip.size();\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = 0; j < k; j++) {\n            if (s[j]=='r' && !trk[j]) {\n                pos[i] = j; trk[j] = true;\n                cnt[i]++;\n                break;\n            }\n        }\n        if (pos[i] == -1) return false;\n    }\n    for (int i = m-1; i >= 0; i--) {\n        if (ip[i] == 1) continue;\n        for (int j = pos[i]+1; j < k; j++) {\n            if (s[j]=='b' && !trk[j]) {\n                cnt[i]++;\n                pos[i]=j; trk[j] = true;\n                break;\n            }\n        }\n        if (cnt[i] != 2) return false;\n    }\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = pos[i]+1; ip[i] > cnt[i] && j < k; j++) {\n            if (!trk[j]) {\n                cnt[i]++;\n                pos[i] = j; trk[j] = true;\n            }\n        }\n        //cout << i << ','<<cnt[i]<<'\\n';\n        if (ip[i] != cnt[i]) return false;\n    }\n    \n    mint coeff = c.fac[m];\n    int las = 0, len = 0;\n    for (const int& x: ip) {\n        if (x == las) len++;\n        else {\n            coeff *= c.ifac[len];\n            len = 1;\n            las = x;\n        }\n    }coeff *= c.ifac[len];\n\n    int zero = 0;\n    zero += 2;\n    for (const int& x: ip) {\n        if (x > 1) zero+=2;\n    }\n\n    if (sum == 0) {\n        res += 1; return true;\n    }\n    //dbg(ip, sum);\n    //cout << coeff << '\\n';\n    res += c.p(n+zero, sum+zero) * coeff;\n    //cout << res << \"\\n\";\n    return true;\n}\n\nvoid dfs(vector<int>& ip, int sum) {\n    check(ip, sum);\n    //dbg(ip);\n    int sta = ip.empty()? 1 : ip.back();\n    for (int i = sta; i <= n; i++) {\n        int nex_sum = sum + max(2*i-3, 1) + (ip.empty()?0:1);\n        if (nex_sum > n) break;\n        ip.emplace_back(i);\n        dfs(ip, nex_sum);\n        ip.pop_back();\n    }\n}\n\nvoid solve() {\n    cin >> n >> k;\n    cin >> s;\n    vector<int> ip;\n    dfs(ip, 0);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=3600;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];\n\tbool inB[N];char str[N];\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);if(n>60) exit(0);\n\t\tg[0][0][0]=1;fo(i,1,n) fo(j,1,m) g[0][i][j]=C(i-1,j-1)*facinv[j]%MOD;\n\t\tfo(cc,1,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,m-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*( (C(ii-1,cc*2-2)+C(ii-1,cc*2-1)*2+C(ii-1,cc*2))%MOD )%MOD);\n\t\t\tfo(i,0,n) fo(j,0,m) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tll ans=0;dp[n+1][0][0][0]=1;\n\t\tfo(A,0,m)\n\t\t{\n\t\t\tint R=0;mem(inB,0);\n\t\t\tif(A) fo(i,1,m) if(str[i]=='r')\n\t\t\t{\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1,pos[++R]=j,ok=1;break;}\n\t\t\t\tif(!ok or R==A) break;//posi=被匹配的第i个蓝色\n\t\t\t}if(R<A) break;\n\t\t\t\n\t\t\tfo(B,0,m)\n\t\t\t{\n\t\t\t\tint cc=0;fo(i,1,m) if(str[i]=='r') cc++,blu[i]=blu[i-1]+(cc>A+B); else blu[i]=blu[i-1]+(!inB[i]);if(cc<A+B) break;\n\t\t\t\tfo(cnt,0,blu[m]) fo(ln,1,n) fo(st,0,A)\n\t\t\t\t{\n\t\t\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\t\t\tfo(j,1,A-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-(blu[pos[st+j]]-blu[pos[st+j-1]]))+(ln-1);\n\t\t\t\t}\n\t\t\t\tfd(ln,n,1) fo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,m) dp[ln][S][t][cnt]=0;\n\t\t\t\tfd(ln,n,1)\n\t\t\t\t{\n\t\t\t\t\tfo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,blu[m]-blu[pos[t]]) if(dp[ln+1][S][t][cnt])\n\t\t\t\t\t\tfo(j,0,A-t) if(go[cnt][ln][t][j]<=blu[m]-blu[pos[t+j]]) fo(i,0,n-S)\n\t\t\t\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],1ll*dp[ln+1][S][t][cnt]*g[ln][i][j]%MOD);\n\t\t\t\t}\n\t\t\t\tfo(S,0,n) fo(cnt,0,m) if(dp[1][S][A][cnt]) fo(S2,0,n-S) if(g[0][S2][B])\n\t\t\t\t\tadd(ans,1ll*dp[1][S][A][cnt]*g[0][S2][B]%MOD*fac[A+B]%MOD*C(n-S-S2+1,A+B)%MOD);\n\t\t\t}\n\t\t}\n\t\twrite(ans);\n\t}\n};\nsigned main()\n{\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//clock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 2333\n\t#define mod 1000000007ll\n\ttypedef long long ll;\n\ttypedef double db;\n//\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n//\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n//\tvoid file()\n//\t{\n//\t\t#ifdef NTFOrz\n//\t\tfreopen(\"a.in\",\"r\",stdin);\n//\t\t#endif\n//\t}\n//\tinline void chktime()\n//\t{\n//\t\t#ifdef NTFOrz\n//\t\tcout<<(clock()-t)/1000.0<<'\\n';\n//\t\t#endif\n//\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nll fac[sz],_fac[sz];\nvoid init(){_fac[0]=fac[0]=1;rep(i,1,sz-1) _fac[i]=inv(fac[i]=fac[i-1]*i%mod);}\nll C(int n,int m){return n>=m&&m>=0?fac[n]*_fac[m]%mod*_fac[n-m]%mod:0;}\n\nint n,m;\nchar s[sz];\nint a[sz],K;\nint vis[sz],ed[sz];\nll ans;\n\nbool check()\n{\n\trep(i,1,m) vis[i]=0;\n\tint l=1,r=1,c=0;\n\trep(i,1,K)\n\t{\n\t\tif (a[i]==1) { ++c; continue; }\n\t\twhile (l<=m&&(vis[l]||s[l]=='b')) ++l;\n\t\tchkmax(r,l+1);\n\t\twhile (r<=m&&(vis[r]||s[r]=='r')) ++r;\n\t\tif (r>m) return 0;\n\t\tvis[l]=vis[r]=1;ed[i]=r;\n\t}\n\tint cc=c;\n\trep(i,1,m) if (cc&&s[i]=='r'&&!vis[i]) vis[i]=1,--cc;\n\tif (cc) return 0;\n\tint pos=1;\n\trep(i,1,K)\n\t{\n\t\tif (a[i]==1) break;\n\t\tchkmax(pos,ed[i]);\n\t\tcc=a[i]-2;\n\t\twhile (pos<=m&&cc) cc-=(!vis[pos]),++pos;\n\t\tif (cc) return 0;\n\t}\n\treturn 1;\n}\nvoid work()\n{\n\tif (!check()) return;\n\tll ret=fac[K];\n\tfor (int l=1,r;l<=K;l=r+1)\n\t{\n\t\tfor (r=l;r<K&&a[r+1]==a[r];++r);\n\t\tret=ret*_fac[r-l+1]%mod;\n\t}\n\tint sum=K-1; rep(i,1,K) sum+=(a[i]==1?1:a[i]*2-3);\n\tint c=2; rep(i,1,K) c+=2*(a[i]!=1);\n\tret=ret*C(n+c-1,sum+c-1)%mod;\n\t(ans+=ret)%=mod;\n}\n\nvoid dfs(int m,int lst,int sum)\n{\n\tif (K-1+sum>n) return;\n\twork();\n\tdrep(i,min(m,lst),1) a[++K]=i,dfs(m-i,i,sum+(i==1?1:i*2-3)),a[K--]=0;\n}\n\nint main()\n{\n\tinit();\n\tread(n),read(m);\n\tcin>>(s+1);\n\tdfs(m,m,0);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nconstexpr lint MOD = 1000000007;\n\nvector<lint> fac, facInv, inv;\n\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\n\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\n\nint N, K;\nstring s;\n\nbool is_partition_able(vector<int> partition)\n{\n    int r_head = 0, b_head = 0;\n    int pending = 0;\n    for (auto c : s)\n    {\n        if (c == 'r')\n        {\n            if (r_head < partition.size()) r_head++;\n            else pending = max(pending-1, 0);\n        }\n        else\n        {\n            if (r_head == b_head || partition[b_head] < 2) pending = max(pending-1, 0);\n            else\n            {\n                pending += partition[b_head] - 2;\n                b_head++;\n            }\n        }\n    }\n    if (pending > 0 || (b_head < partition.size() && partition[b_head] > 1) || r_head < partition.size()) return false;\n    return true;\n}\n\n\nlint calc_for_each_partition(vector<int> &partition)\n{\n    if (!is_partition_able(partition)) return 0;\n\n    int rd = 0;\n    map<int, int> len_map;\n    for (auto v : partition)\n    {\n        len_map[v]++;\n        if (v > 1) rd += 2;\n    }\n    lint ans = nCr(N + 1 + rd, 2 * accumulate(partition.begin(), partition.end(), 0));\n    for (auto v : len_map) (ans *= facInv[v.second]) %= MOD;\n    (ans *= fac[partition.size()]) %= MOD;\n    return ans;\n}\n\n\nlint dfs(vector<int> partition_now)\n{\n    lint ans = calc_for_each_partition(partition_now);\n    int used_len = 0;\n    for (auto v : partition_now) used_len += 1 + max(v*2-3, 1);\n    // for (auto v : partition_now) used_len += v;\n    int highest = partition_now.back();\n\n    partition_now.push_back(0);\n\n    if (partition_now.size() - 1 < K) for (int l=1; l<=min(highest, N-used_len); l++)\n    {\n        partition_now.back() = l;\n        ans += dfs(partition_now);\n    }\n    return ans % MOD;\n}\n\n\n// r -> b -> (n個のrまたはb)で島を作る\n\nint main()\n{\n    cin >> N >> K >> s;\n    facInit(70*3);\n\n    lint ans = 1;\n    for (int i=1; i<=K; i++)\n    {\n        (ans += dfs(vector<int>{i})) %= MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 200;\nchar c[maxN];\nint n, k;\nint sz = 0;\nint red[maxN];\nint blue[maxN];\nint r = 1;\nint cnt1[3 * maxN];\nint cnt2[3 * maxN];\nint ans = 0;\nint LIM;\nint F = 0;\nint mark[maxN];\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint fact[2 * maxN];\nint invfact[2 * maxN];\nint inv[2 * maxN];\nint cnk(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return mult(fact[n], mult(invfact[n - k], invfact[k]));\n}\nint lstB[2 * maxN];\nbool check() {\n    memset(mark, -1, sizeof mark);\n    int ptr = 0;\n    while (ptr < sz && blue[ptr] == 0) {\n        ptr++;\n    }\n    ptr--;\n    //[0 .. ptr] - ok\n    //\n    int ptrR = sz - 1;\n    int ptrB = sz - 1;\n    for (int i = 1; i <= k; i++) {\n        if (c[i] == 'r' && ptrR >= 0) {\n            ptrR--;\n            mark[i] = 1;\n        }\n        if (c[i] == 'b' && ptrB > ptrR && ptrB > ptr) {\n            lstB[ptrB] = i;\n            ptrB--;\n            mark[i] = 1;\n        }\n    }\n    //rrrrrrrbr\n    if (ptrR != -1 || ptrB != ptr) return false;\n    int where = sz - 1;\n    int need = red[sz - 1];\n    for (int i = 1; i <= k; i++) {\n        if (need == 0) return true;\n        if (mark[i] == 1) continue;\n        if (where > ptr && lstB[where] <= i) {\n            need--;\n            if (need == 0) {\n                where--;\n                need = red[where];\n            }\n        }\n    }\n    return (need == 0 || where == ptr);\n}\nint his_cnt[maxN];\nvoid calc() {\n    if (!check()) {\n        return;\n    }\n\n    int val = fact[sz];\n    memset(his_cnt, 0, sizeof his_cnt);\n    int groups = 0;\n    int other = 0;\n    for (int i = 0; i < sz; i++) {\n        his_cnt[blue[i]]++;\n        val = mult(val, inv[his_cnt[blue[i]]]);\n        groups += blue[i] + red[i];\n        if (blue[i]) other++;\n    }\n    //so we have\n    // x_1 + ... + x_groups + y_1 + .. + y_2*other + c_1 + c_2 + p_1 + ... + p_(sz - 1) = n\n    // groups + 2 * other + sz - 1 + 2\n    int all_gr = groups + 2 * other + sz - 1 + 2;\n    ans = sum(ans, mult(val, cnk(n + all_gr - 1 - groups - (sz - 1), all_gr - 1)));\n}\nvoid gen(int pos, int total) {\n    if (total + sz - 1 > n) return;\n    if (sz > LIM) return;\n    if (pos == r) {\n        F++;\n        calc();\n        return;\n    }\n    gen(pos + 1, total);\n    if (pos == 0) {\n        red[sz] = 1;\n        blue[sz] = 0;\n        sz++;\n        gen(pos, total + 1);\n        sz--;\n    }\n    else {\n        red[sz] = cnt1[pos];\n        blue[sz] = cnt2[pos];\n        sz++;\n        gen(pos, total + red[sz - 1] + blue[sz - 1]);\n        sz--;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n    for (int i = 2; i < 2 * maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n\n    cin >> n >> k;\n    for (int i = 1; i <= k; i++) cin >> c[i];\n    LIM = (n + 1) / 2;\n    for (int d = 1; d <= n; d++) {\n        cnt1[r] = d - 1;\n        cnt2[r] = d;\n        r++;\n    }\n    gen(0, 0);\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 200;\nchar c[maxN];\nint n, k;\nint sz = 0;\nint red[maxN];\nint blue[maxN];\nint r = 1;\nint cnt1[3 * maxN];\nint cnt2[3 * maxN];\nint ans = 0;\nint LIM;\nint F = 0;\nint mark[maxN];\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint fact[2 * maxN];\nint invfact[2 * maxN];\nint inv[2 * maxN];\nint cnk(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return mult(fact[n], mult(invfact[n - k], invfact[k]));\n}\nbool check() {\n    memset(mark, -1, sizeof mark);\n    int ptr = 0;\n    int f = k;\n    while (ptr < sz && blue[ptr] == 0) {\n        if (f == 0) return false;\n        if (c[f] == 'b') {\n            f--;\n        }\n        else {\n            mark[f] = 1;\n            f--;\n            ptr++;\n        }\n    }\n    ptr--;\n    //[0 .. ptr] - ok\n    //\n    int ptrR = sz - 1;\n    int ptrB = sz - 1;\n    for (int i = 1; i <= k; i++) {\n        if (mark[i] != -1) continue;\n        if (c[i] == 'r' && ptrR > ptr) {\n            ptrR--;\n            mark[i] = 1;\n        }\n        if (c[i] == 'b' && ptrB > ptrR) {\n            ptrB--;\n            mark[i] = 1;\n        }\n    }\n    if (ptrR != ptr || ptrB != ptr) return false;\n    int where = sz - 1;\n    int need = red[sz - 1];\n    for (int i = 1; i <= k; i++) {\n        if (need == 0) return true;\n        if (mark[i] == 1) continue;\n        if (where > ptr) {\n            need--;\n            if (need == 0) {\n                where--;\n                need = red[where];\n            }\n        }\n    }\n    return (need == 0 || where == ptr);\n}\nint his_cnt[maxN];\nvoid calc() {\n    /*for (int i = 0; i < sz; i++) {\n        cout << red[i] << \" \" << blue[i] << endl;\n    }\n    cout << \"----------------------\" << endl;*/\n    if (!check()) {\n//        cout << \":(\" << endl;\n        return;\n    }\n\n    int val = fact[sz];\n    memset(his_cnt, 0, sizeof his_cnt);\n    int groups = 0;\n    int other = 0;\n    for (int i = 0; i < sz; i++) {\n        his_cnt[blue[i]]++;\n        val = mult(val, inv[his_cnt[blue[i]]]);\n        groups += blue[i] + red[i];\n        if (blue[i]) other++;\n    }\n    //so we have\n    // x_1 + ... + x_groups + y_1 + .. + y_2*other + c_1 + c_2 + p_1 + ... + p_(sz - 1) = n\n    // groups + 2 * other + sz - 1 + 2\n    int all_gr = groups + 2 * other + sz - 1 + 2;\n    ans = sum(ans, mult(val, cnk(n + all_gr - 1 - groups - (sz - 1), all_gr - 1)));\n}\nvoid gen(int pos, int total) {\n    if (total + sz - 1 > n) return;\n    if (sz > LIM) return;\n    if (pos == r) {\n        F++;\n        calc();\n        return;\n    }\n    gen(pos + 1, total);\n    if (pos == 0) {\n        red[sz] = 1;\n        blue[sz] = 0;\n        sz++;\n        gen(pos, total + 1);\n        sz--;\n    }\n    else {\n        red[sz] = cnt1[pos];\n        blue[sz] = cnt2[pos];\n        sz++;\n        gen(pos, total + red[sz - 1] + blue[sz - 1]);\n        sz--;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n    for (int i = 2; i < 2 * maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n\n    cin >> n >> k;\n    for (int i = 1; i <= k; i++) cin >> c[i];\n    LIM = (n + 1) / 2;\n    for (int d = 1; 2 * d - 1 <= n; d++) {\n        cnt1[r] = d - 1;\n        cnt2[r] = d;\n        r++;\n    }\n    gen(0, 0);\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\nconst int N=1010,P=1e9+7;\nint n,m,ans,cnt;\nint a[N],b[N],c[N],d[N],f[N],p[N],fc[N],vf[N],iv[N];\nchar s[N];\nvoid ini(int n){\n\tiv[1]=fc[0]=vf[0]=1;\n\tFOR(i,2,n) iv[i]=1ll*(P-P/i)*iv[P%i]%P;\n\tFOR(i,1,n) fc[i]=1ll*fc[i-1]*i%P,vf[i]=1ll*vf[i-1]*iv[i]%P;\n}\nint C(int x,int y){return x<y?0:1ll*fc[x]*vf[x-y]%P*vf[y]%P;}\nbool work(int L,int s,int t){\n\tint r=1;\n\tFOR(i,1,m) c[i]=0,b[i]=f[i];b[L+1]=0;\n\t//FOR(i,1,L) cout<<b[i]<<' ';cout<<'\\n';\n\tFOR(i,1,m)if(!a[i] && r<=L) b[c[i]=r]--,p[r++]=i;\n\tif(b[r]) return 1;r=1;\n\tFOR(i,1,m)if( a[i] && b[r] && p[r]<i) b[c[i]=r]--,p[r++]=i;\n\tif(b[r]) return 1;r=1;\n\tFOR(i,1,m)if(!c[i] && b[r] && p[r]<i && !--b[r]) r++;\n\tint ret=fc[L];\n\tFOR(i,1,m) ret=1ll*ret*vf[d[i]]%P;\n\t(ans+=1ll*ret*C(t,2*s)%P)%=P;\n}\nvoid dfs(int x,int s,int t){\n\tif(t<2*s) return;work(x-1,s,t);\n\tFOR(i,1,min(f[x-1],m-s)) f[x]=i,d[i]++,dfs(x+1,s+i,t+2*(i>=2)),d[i]--;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,s+1);ini(1000);\n\tFOR(i,1,m) a[i]=s[i]=='b';\n\tf[0]=m;dfs(1,0,n+1);\n\tcout<<ans<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//我永远喜欢ysgh\n#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 110;\nint n,k;\nchar s[N];\n\nconst int mod = 1e9+7;\nint fac[N<<1],ifac[N<<1];\ninline void init(){\n\tfac[0]=1;\n\tFor(i,1,200) fac[i]=1ll*fac[i-1]*i%mod;\n\tauto power=[](int a,int b){\n\t\tint ret=1;\n\t\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\t\treturn ret;\n\t};\n\tifac[200]=power(fac[200],mod-2);\n\tDow(i,199,0) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\n\nint ans,cnt,a[N],_cnt,_a[N],tot;\ninline bool check(){\n\tif (!_cnt) return 0;\n\tcnt=_cnt;\n\tFor(i,1,cnt) a[i]=_a[i];\n\treverse(a+1,a+1+cnt);\n\tint lim=0;\n\twhile (lim<cnt&&a[lim+1]>1) ++lim;\n\tint cnt_r=0,cnt_b=0,cnt_x=0;\n\tFor(i,1,k) \n\t\tif (s[i]=='r'&&cnt_r<cnt) ++cnt_r;\n\t\telse if (s[i]=='b'&&cnt_b<min(lim,cnt_r)) ++cnt_b,cnt_x+=a[cnt_b]-2;\n\t\telse if (cnt_x) --cnt_x;\n\treturn !cnt_x&&cnt_b==lim&&cnt_r==cnt;\n}\ninline int calc(int sum){\n\tauto C=[=](int n,int m){\n\t\treturn 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n\t};\n\tint ret=fac[cnt];\n\tfor (int l=1,r=1;l<=cnt;l=++r){\n\t\twhile (a[r+1]==a[l]&&r<cnt) ++r;\n\t\tret=1ll*ret*ifac[r-l+1]%mod;\n\t}\n\treturn 1ll*ret*C(n+tot-1,sum+tot-1)%mod;\n}\ninline void dfs(int sum,int last){\n\tif (check()){\n\t\tans+=calc(sum-1);\n\t\tif (ans>=mod) ans-=mod;\n\t}\n\tif (last==1&&sum+1<=n) _a[++_cnt]=1,dfs(sum+2,1),--_cnt;\n\tfor (int i=last;sum+i*2-3<=n;i++){\n\t\tif (i==1) continue;\n\t\t_a[++_cnt]=i,tot+=2;\n\t\tdfs(sum+i*2-2,i);\n\t\t--_cnt,tot-=2;\n\t}\n}\n\nint main(){\n\tn=read(),k=read(),scanf(\"%s\",s+1);\n\tinit(),tot=2,ans=1,dfs(0,1),printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\n#define left LEFT\ntypedef long long LL;\nconst int N = 510;\nconst int P = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check() {\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    rep(i, 1, k) {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update() {\n    LL tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1) {\n        for(j = i; a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % P;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % P;\n    if ((ans += tmp) >= P) ans -= P;\n}\n\nvoid dfs(int mx) {\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    ++tot; --left; dfs(a[tot] = 1); ++left;\n    rep(i, 2, mx) {\n        left -= i * 2 - 3;\n        dfs(a[tot] = i);\n        left += i * 2 - 3;\n    }\n    a[tot--] = 0;\n    if (tot) ++left;\n}\n\nint main() {\n    rep(i, 0, 500) {\n        c[i][0] = 1;\n        rep(j, 1, 500)\n            if((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= P) c[i][j] -= P;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(100);\n    printf(\"%d\\n\", (ans + 1) % P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K,C[1005][1005],L[75],fac[1005],invfac[1005],cnt;\nint sum[75],pos[75],tot,ans,matc[75];\nchar s[75];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nbool check() {\n    if(tot < cnt) return false;\n    memset(sum,0,sizeof(sum));\n    int p = 1;\n    for(int i = cnt ; i >= 1 ; --i) {\n\tsum[pos[i]]++;\n\tif(L[p] >= 2) {\n\t    if(!matc[pos[i]]) return false;\n\t    sum[matc[pos[i]]] += L[p] - 1;\n\t}\n\t++p;\n    }\n    for(int i = K ; i >= 1 ; --i) {\n\tsum[i] += sum[i + 1];\n\tif(sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\nbool dfs(int pre,int dep,int len) {\n    cnt = dep;\n    if(!check()) return false;\n    int k = 1 + cnt;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] == 1) ++k;\n        else k += 2 * L[i] - 1;\n    }\n    int res = C[N - len + k - 1][k - 1];\n    res = mul(res,fac[cnt]);\n    int t = 0;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] != L[i - 1]) {\n            res = mul(res,invfac[t]);\n            t = 0;\n        }\n        ++t;\n    }\n    res = mul(res,invfac[t]);\n    update(ans,res);\n    if(dep + 1 > tot) return true;\n    for(int i = pre ; i <= 70 ; ++i) {\n        int tl = len;\n        if(dep != 0) ++tl;\n        if(i == 1 || i == 2) tl += 1;\n        else tl += i - 2 + i - 1;\n        if(tl > N) break;\n        L[dep + 1] = i;\n        if(!dfs(i,dep + 1,tl)) break;\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);read(K);\n    scanf(\"%s\",s + 1);\n    C[0][0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) {\n        C[i][0] = 1;\n        for(int j = 1 ; j <= i ; ++j) {\n            C[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n        }\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000] = fpow(fac[1000],MOD - 2);\n    for(int i = 999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    tot = 0;\n    for(int i = 1 ; i <= K ; ++i) {\n        if(s[i] == 'r') pos[++tot] = i;\n\tfor(int j = i + 1 ; j <= K ; ++j) {\n\t    if(s[j] == 'b' && !matc[j]) {matc[i] = j;break;}\n\t}\n    }\n    dfs(1,0,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void add(int &x,int y) {\n  ((x+=y)>=MOD)?x-=MOD:0;\n} \n\nll C[105][105];\n\nvoid pre(int n) {\n  for(int i=0;i<=n;i++) C[i][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n}\n\nint f[85][85][85],up[85];\nint sum[85];\n\nvoid dp(int n,int m,int c) {\n  memset(f,0,sizeof(f));\n  int t=m+2*c-1;\n  f[0][0][0]=1;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<=up[i]&&2*j-m+t<=n;j++) {\n      int s=f[i][j][0];\n      for(int k=1;k<=up[m]&&j+(m-i)*k<=up[m];k++) {\n      \tfor(int l=1;i+l<=m&&j+l*k<=up[i+l];l++)\n      \t  add(f[i+l][j+l*k][k],s*C[i+l][l]%MOD);\n      \tadd(s,f[i][j][k]);\n\t  }\n    }\n  for(int i=0;i<=up[m]&&2*i-m+t<=n;i++) {\n  \tint s=0;\n  \tfor(int j=0;j<=i;j++) add(s,f[m][i][j]);\n  \tif (!s) continue;\n  \tint v=2*i-m+t;\n  \tfor(int j=0;j<=2*m+2&&v+j<=n;j++)\n  \t  add(sum[v+j],s*C[m+c][c]%MOD*C[2*m+2][j]%MOD);\n  }\n}\n\nchar str[85];\n\nint q[85],lpos[85];\nbool vis[85];\n\nint main() {\n  int n,k;\n  scanf(\"%d%d%s\",&n,&k,str+1);\n  pre(100);\n  for(int i=0;2*i<=k;i++) {\n  \tmemset(vis,0,sizeof(vis));\n  \tint cnt=0;\n  \tint lx=1,rx=0;\n  \tfor(int j=1;j<=k&&cnt<i;j++)\n  \t  if (str[j]=='r') q[++rx]=j;\n  \t  else if (lx<=rx) {\n  \t  \t  vis[q[lx++]]=vis[j]=1;\n  \t  \t  lpos[++cnt]=j;\n\t\t}\n\tif (cnt<i) continue;\n\tint s=0;\n\tfor(int j=1;j<=k;j++)\n\t  if (!vis[j]&&str[j]=='r') s++;\n\tint r=1;\n\tlpos[i+1]=k+1;up[i+1]=0;\n\tfor(int j=0;j<=s;j++) {\n\t\tif (j) {\n\t\t\twhile (vis[r]||str[r]!='r') r++;\n\t\t\tvis[r]=1;\n\t\t}\n\t\tfor(int t1=i;t1>0;t1--) {\n\t\t\tup[t1]=up[t1+1];\n\t\t\tfor(int t2=lpos[t1+1]-1;t2>lpos[t1];t2--)\n\t\t\t  if (!vis[t2]) up[t1]++;\n\t\t\tup[t1]++;\n\t\t}\n\t\treverse(up+1,up+i+1);\n\t\tdp(n,i,j);\n\t}\n  }\n  int ans=0;\n  for(int i=1;i<=n;i++) add(ans,sum[i]*C[n-1][i-1]%MOD);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\nconst u32 P=1e9+7;\ninline u32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\ninline u32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\ninline u32 sum(u32 a, u32 b) {return (a+=b)<P?a:a-P;}\ninline u32 dif(u32 a, u32 b) {return (a-=b)&0x80000000?a+P:a;}\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\n\nint n, k, rcnt, f[70];\nu32 ans, c[500][500], fac[500], inv[500];\nchar s[71];\nvoid search(int len, int last, int sum) {\n\tif(len>rcnt) return;\n\tint r=0, nz=0, b=0, a=0;\n\twhile(nz<len&&f[nz]==0) ++nz;\n\tnz=len-nz;\n\tfor(int i=0; i<k&&(b!=nz||a!=0); ++i) {\n\t\tif(s[i]=='r') if(r<len) ++r; else if(a) --a;\n\t\tif(s[i]=='b') if(b<r&&b<nz) ++b, a+=f[len-b]-1; else if(a) --a;\n\t}\n\tif(b==nz&&a==0) {\n\t\tint fsum=len;\n\t\tu64 q=fac[len];\n\t\tfor(int i=0, j; i<len; ++i) {\n\t\t\tfsum+=f[i];\n\t\t\tif(i==0||f[i]!=f[i-1]) j=0;\n\t\t\tq=q*inv[++j]%P;\n\t\t}\n\t\tans=(ans+q*c[n+1+2*nz][2*fsum])%P;\n\t\tif(sum>=2) {\n\t\t\tint &F=f[len];\n\t\t\tfor(F=last; F<=sum; ++F) search(len+1, F, sum-(F?F:1));\n\t\t}\n\t}\n}\nint main() {\n\tfor(int i=0; i<500; ++i) {\n\t\tc[i][0]=c[i][i]=1;\n\t\tfor(int j=1; j<i; ++j) c[i][j]=sum(c[i-1][j-1], c[i-1][j]);\n\t}\n\tfac[0]=1;\n\tfor(int i=1; i<500; ++i) fac[i]=(u64)fac[i-1]*i%P;\n\tinv[1]=1;\n\tfor(int i=2; i<500; ++i) inv[i]=(u64)(P-P/i)*inv[P%i]%P;\n\tassert(scanf(\"%d%d%s\", &n, &k, s)==3);\n\trcnt=std::count(s, s+k, 'r');\n\tsearch(0, 0, (n+1)/2);\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=110;\nconst int inf=0x3f3f3f3f;\nconst LL mod=1e9+7;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,K;\nchar str[N];\nint st[N],a[N],len,p[N];\nLL fac[N],ifac[N],C[N][N],ans;\ninline void Add(LL&x,LL y){x=x+y<mod?x+y:x+y-mod;}\ninline LL qpow(LL a,LL b)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\ninline bool check(int tot)\n{\n\tint cnt=0,cntr=tot,cntb=tot;\n\tFor(i,1,K)\n\tif(str[i]=='r')\n\t{\n\t\tif(cntr)cntr--;\n\t\telse cnt-=cnt>0;\n\t}\n\telse\n\t{\n\t\tif(cntb>cntr&&cntb&&st[cntb])cnt+=st[cntb--]-1;\n\t\telse cnt-=cnt>0;\n\t}\n\treturn !cnt&&!cntr&&(!cntb||st[cntb]==0);\n}\nLL b[N],r[N],w[N],f[N],g[N];\ninline LL CC(int a,int b)\n{\n\tif(b==0)return a==0;\n\treturn C[a+b-1][b-1];\n}\ninline LL Solve(int tot,int res)\n{\n\tint bcnt=0,rcnt=0,wcnt=0;\n\tFor(i,1,tot)\n\t{\n\t\tbcnt+=st[i];\n\t\trcnt+=st[i]+1;\n\t}\n\twcnt=tot+1;\n\tFor(i,0,res)f[i]=0;\n\tFor(i,0,res)g[i]=0;\n\t//printf(\"r:%d b:%d w:%d\\n\",rcnt,bcnt,wcnt);\n\tFor(i,0,res)\n\t\tFor(j,0,res-i)\n\t\t\tAdd(f[i+j],CC(i,rcnt)*CC(j,bcnt)%mod);\n\t//For(i,0,res)printf(\"%lld \",f[i]);puts(\"\");\n\tFor(i,0,res)\n\t\tFor(j,0,res-i)\n\t\t\tAdd(g[i+j],f[i]*CC(j,wcnt)%mod);\n\t//For(i,0,res)printf(\"%lld \",g[i]);puts(\"\");\n\t//printf(\"%lld\\n\",g[res]);\n\treturn g[res];\n}\ninline void dfs(int cnt,int res,int now,LL val)\n{\n\tif(res-max(now*2-1,1)-1<0)\n\t{\n\t\tif(check(cnt))\n\t\t{\n\t\t\t//For(i,1,cnt)printf(\"%d \",st[i]);\n\t\t\t//printf(\"res:%d\\n\",res);\n\t\t\tLL ret=Solve(cnt,res)*fac[cnt]%mod*val%mod;\n\t\t\t//printf(\"%lld\\n\",ret);\n\t\t\tAdd(ans,ret);\n\t\t}\n\t\treturn;\n\t}\n\tdfs(cnt,res,now+1,val);\n\tFor(i,1,res)\n\t{\n\t\tst[cnt+i]=now;\n\t\tint l=res-max(now*2-1,1)*i-i;\n\t\tif(l>=0)dfs(cnt+i,l,now+1,val*ifac[i]%mod);\n\t\telse break;\n\t}\n}\ninline void init(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tFor(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2);\n\trFor(i,n,2)ifac[i-1]=ifac[i]*i%mod;\n\tC[0][0]=1;\n\tFor(i,1,n)For(j,0,i)C[i][j]=(C[i-1][j]+(j?C[i-1][j-1]:0))%mod;\n}\nint main()\n{\n\tfile();\n\tread(n),read(K);\n\tinit(100);\n\tscanf(\"%s\",str+1);\n\tdfs(0,n+1,0,1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n\nstring str;\nll comb[301][301];\nint n,k;\nint group[81];\nint assign[81];\nbool used[81];\nll dp2[101][101];\nll ans;\n\nbool isvalid(int v){\n\tint len=0;\n\tfor(int i=0;i<v;i++){\n\t\tif(i!=0)len++;\n\t\tif(group[i]==1){\n\t\t\tlen++;\n\t\t}else{\n\t\t\tlen+=group[i]*2-3;\n\t\t}\n\t}\n\tif(len>n)return false;\n\tmemset(assign,0,sizeof(assign));\n\tmemset(used,false,sizeof(used));\n\tint cnt=0;\n\tfor(int i=0;i<k;i++){\n\t\tif(cnt==v)break;\n\t\tif(str[i]=='r'){\n\t\t\tassign[cnt++]=i;\n\t\t\tused[i]=true;\n\t\t}\n\t}\n\tif(cnt<v)return false;\n\tfor(int i=0;i<v;i++){\n\t\tif(group[i]>=2){\n\t\t\tbool flag=false;\n\t\t\tfor(int j=assign[i]+1;j<k;j++){\n\t\t\t\tif(str[j]=='b' && !used[j]){\n\t\t\t\t\tused[j]=true;\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)return false;\n\t\t}\n\t}\n\tfor(int i=0;i<v;i++){\n\t\tif(group[i]>=3){\n\t\t\tint rest=group[i]-2;\n\t\t\tfor(int j=assign[i]+1;j<k;j++){\n\t\t\t\tif(!used[j]){\n\t\t\t\t\tused[j]=true;\n\t\t\t\t\trest--;\n\t\t\t\t}\n\t\t\t\tif(rest==0)break;\n\t\t\t}\n\t\t\tif(rest!=0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nll dp[2][71];\n\nvoid dfs(int v,int now){\n\tif(v>0){\n\t\tif(!isvalid(v))return;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint cur=0,nxt=1;\n\t\tdp[cur][v-1]=1;\n\t\tfor(int i=0;i<v;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(group[i]==1){\n\t\t\t\t\tif(j+1<=n){\n\t\t\t\t\t\tdp[nxt][j+1]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+1]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tint pl=(group[i]-1)*2-1;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\tpl=(group[i]-1)*2;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j]*2;\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\tpl=(group[i]-1)*2+1;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur,nxt);\n\t\t\tmemset(dp[nxt],0,sizeof(dp[nxt]));\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<v;i++){\n\t\t\tprintf(\"%d \",group[i]);\n\t\t}\n\t\tprintf(\"ok\\n\");\n\t\t*/\n\t\tll pw=1;\n\t\tint len=1,rest=v;\n\t\tfor(int i=1;i<v;i++){\n\t\t\tif(group[i]==group[i-1]){\n\t\t\t\tlen++;\n\t\t\t}else{\n\t\t\t\tpw=pw*comb[rest][len]%MOD;\n\t\t\t\trest-=len;\n\t\t\t\tlen=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tll va=(dp[cur][i]*pw)%MOD;\n\t\t\t//printf(\"%lld \",dp[cur][i]);\n\t\t\tva=va*dp2[i+2][n-i]%MOD;\n\t\t\tans+=va;\n\t\t\tans%=MOD;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t//printf(\"%lld %lld\\n\",pw,ans);\n\t}\n\tfor(int i=1;i<=now;i++){\n\t\tgroup[v]=i;\n\t\tdfs(v+1,i);\n\t}\n}\n\nint main(void){\n\tcomb[0][0]=1;\n\tfor(int i=1;i<=300;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tcomb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n\t\t}\n\t\tcomb[i][0]=1;\n\t\tcomb[i][i]=1;\n\t}\n\tdp2[1][0]=1;\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tdp2[i+1][j]+=dp2[i][j];\n\t\t\tdp2[i+1][j]%=MOD;\n\t\t\tdp2[i][j+1]+=dp2[i][j];\n\t\t\tdp2[i][j+1]%=MOD;\n\t\t}\n\t}\n\tscanf(\"%d%d\",&n,&k);\n\tcin >> str;\n\tdfs(0,38);\n\tprintf(\"%lld\\n\",(ans+1LL)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int p=1000000007;\n\nint c[300][300],g[100],h[100];\nchar b[100];\nint i,j,k,l,m,n,r,s,t;\n\ninline void pre()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",b+1);\n\tfor (i=0;i<=250;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t\tif ((j==0) || (j==i))\n\t\t\t\tc[i][j]=1;\n\t\t\telse\n\t\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%p;\n\treturn;\n}\n\ninline void calc()\n{\n\tfor (i=1;i<=n;i++)\n\t\th[i]=g[i];\n\tt=0;\n\tfor (i=1,k=1,l=1;i<=n;i++)\n\t\tif ((b[i]=='r') && (h[k]>0))\n\t\t\th[k]--,k++;\n\t\telse\n\t\tif ((b[i]=='b') && (h[l]>0) && (l<k))\n\t\t\th[l]--,t=t+h[l],l++;\n\t\telse\n\t\tif (t>0)\n\t\t\tt--;\n\tif ((h[k]) || (h[l]) || (t))\n\t\treturn;\n\tr=1;\n\tfor (i=1;g[i];i=j)\n\t{\n\t\tfor (j=i;g[i]==g[j];j++);\n\t\tr=1LL*r*c[j-1][i-1]%p;\n\t\tif (g[i]==1)\n\t\t\tt=t+j-i;\n\t\telse\n\t\t\tt=t+(j-i)*(2*g[i]-3);\n\t}\n\tt=t+k-2;\n\tif (n-t<0)\n\t\treturn;\n\ts=(s+1LL*r*c[n+2*l-1][t+2*l-1])%p;\n\treturn;\n}\n\ninline void dfs(int w,int x,int y,int z)\n{\n\tif (w<0)\n\t\treturn;\n\tif (z)\n\t\tcalc();\n\tif (x)\n\t{\n\t\tg[z+1]=1,dfs(w-1,x-1,1,z+1);\n\t\tfor (int i=2;(i<=x) && (i<=y);i++)\n\t\t\tg[z+1]=i,dfs(w-2*i+3,x-i,i,z+1);\n\t\tg[z+1]=0;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tpre();\n\tdfs(n,m,m,0);\n\tprintf(\"%d\",(s+1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"No\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=5e6+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=70+10;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);\n\t\tint R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else if(R) blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,n) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tfo(s,max(1,cc),ii) add(g[cc][i+ii][j+1],g[cc][i][j]*C(ii-s+1,cc)%MOD*(cc?C(s-1,cc-1):(s==ii))%MOD);\n\t\t\t}\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tdebug(\"dp(%d,%d,%d,%d)=%d\\n\",ln+1,S,t,cnt,dp[ln+1][S][t][cnt]);\n\t\t\tfo(i,0,n-S) fo(j,0,R-t)\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tfo(S,0,n) fo(t,0,R) fo(cnt,0,m) if(dp[0][S][t][cnt])\n\t\t\tdebug(\"dp(%d,%d,%d,%d)=%d\\n\",0,S,t,cnt,dp[0][S][t][cnt]);\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*C(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//线性预处理模意义\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=75;\nint n,K,i,j,s1,s2,C[N*2][N*2],st[N],w,b,x,y,ans=1,a[N];\nchar c[N];\nvoid dfs(int d,int s,int ss,bool fl){\n\tif(fl){\n\t\tbool ff=0;\n\t\tfor(i=1,j=w,b=0;i<=K;++i){\n\t\t\tif(c[i]=='r'){if(j)b+=st[j--];else if(b && ff)--b;}\n\t\t\tif(c[i]=='b' && b)--b,ff=1;if(!b)ff=0;\n\t\t}\n\t\tif(!j && !b){\n\t\t\ts1=s-1,s2=ss+1,x=C[n-s1+s2-1][s2-1];y=0;\n\t\t\tfor(i=0;i<d;++i)y+=a[i],x=1ll*C[y][a[i]]*x%mo;\n\t\t\tans=(ans+x)%mo;\n\t\t}\n\t}\n\tif(s+(d<2?1:d*2-1)>n)return;\n\tint ow=w;\n\tfor(int i=0,j;s+i*(d<2?1:d*2-1)+i-1<=n;st[++w]=d,++i)\n\t\ta[d]=i,dfs(d+1,s+i*(d<2?1:d*2-1)+i,ss+i*(d*2+1)+i,i);\n\tw=ow;\n}\nint main(){\n\tfor(i=**C=1;i<N*2;++i)for(j=*C[i]=1;j<=i;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\tscanf(\"%d%d%s\",&n,&K,c+1);\n\tdfs(0,0,0,0);\n\tprintf(\"%d\\n\",ans%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 77;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, k;\nchar str[MX];\nll inv[MX*3], fac[MX*3], faci[MX*3];\n\nvoid init()\n{\n\tinv[0] = fac[0] = faci[0] = 1;\n\tinv[1] = fac[1] = faci[1] = 1;\n\tfor(int i=2; i<MX*3; i++)\n\t{\n\t\tinv[i] = (MOD*MOD - (MOD/i) * inv[MOD%i]) % MOD;\n\t\tfac[i] = fac[i-1] * i % MOD;\n\t\tfaci[i] = faci[i-1] * inv[i] % MOD;\n\t}\n}\n\nll binom(int x, int y)\n{\n\tif(x<0 || y<0 || x<y) return 0;\n\telse return fac[x] * faci[y] % MOD * faci[x-y] % MOD;\n}\n\nvoid input()\n{\n\tread(n), read(k);\n\tscanf(\"%s\", str+1);\n}\n\nvector<vector<int> > sta;\n\nvoid dfs(vector<int> cur)\n{\n\tint len = cur.size()-1;\n\tfor(auto i : cur)\n\t\tif(i == 0) len++;\n\t\telse len += i*2-1;\n\tif(len > n) return;\n\tsta.push_back(cur);\n\tfor(int i=0; i<=(cur.size() ? cur.back() : (n+1)/2); i++)\n\t{\n\t\tvector<int> tmp = cur;\n\t\ttmp.push_back(i);\n\t\tdfs(tmp);\n\t}\n}\n\nbool check(vector<int> s)\n{\n\tint sum[MX];\n\tfill(sum+1, sum+k+1, 1);\n\tvector<int> can;\n\tint rem = 0, r = 1, b = 1, bpos[MX];\n\tfor(int i=0; i<s.size(); i++)\n\t{\n\t\tif(s[i])\n\t\t{\n\t\t\twhile(r<=k && str[r]!='r') r++;\n\t\t\tif(r > k) return false;\n\t\t\twhile(b<=k && (str[b]!='b' || b<=r)) b++;\n\t\t\tif(b > k) return false;\n\t\t\tsum[r] = sum[b] = 0;\n\t\t\tbpos[i] = b;\n\t\t\tr++, b++;\n\t\t}\n\t}\n\tfor(int i=0; i<s.size(); i++)\n\t{\n\t\tif(!s[i])\n\t\t{\n\t\t\twhile(r<=k && str[r]!='r') r++;\n\t\t\tif(r > k) return false;\n\t\t\tsum[r] = 0;\n\t\t\tr++;\n\t\t}\n\t}\n\tfor(int i=k-1; i>=1; i--) sum[i] += sum[i+1];\n\tfor(int i=0; i<s.size(); i++) if(s[i]) can.push_back(sum[bpos[i]]);\n\treverse(can.begin(), can.end());\n\treverse(s.begin(), s.end());\n\tint tmp = 0;\n\tfor(int i=0; i<can.size(); i++)\n\t{\n\t\ttmp += (s[i]-1);\n\t\tif(tmp > can[i]) return false;\n\t}\n\treturn true;\n}\n\nll calc(vector<int> s)\n{\n\tll ret = fac[s.size()];\n\tint cnt = 1;\n\tfor(int i=1; i<s.size(); i++)\n\t\tif(s[i] != s[i-1])\n\t\t\tret = ret*faci[cnt] % MOD, cnt = 1;\n\t\telse cnt++;\n\tret = ret*faci[cnt] % MOD;\n\tint up = n+1, dn = 0;\n\tfor(auto v : s)\n\t{\n\t\tdn += 2*v+2;\n\t\tup += (v>=1)*2;\n\t}\n\treturn ret * binom(up, dn) % MOD;\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tdfs(vector<int>());\n\tfor(auto s : sta)\n\t\tif(check(s))\n\t\t\tans = (ans + calc(s)) % MOD;\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\nint ts = 0;\nvoid calc(int sz) {\n    ts++;\n    int tb = 0, tr = 0;\n    int used[77], TR[77], TB[77];\n    memset(used, 0, sizeof used);\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        used[tr] = 1;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && ch[tb] != 'b' && used[tb]) tb++;\n            used[tb] = 1;\n            TR[i] = tr;\n            TB[i] = tb;\n        } else {\n            TR[i] = tr;\n            TB[i] = tr;\n        }\n        if(tr > K || tb > K) return;\n    }\n    for(int i = 1; i <= sz; i++) {\n        int tt = TB[i] + 1;\n        for(int j = 1; j <= X[i] - 2; j++) {\n            while(tt <= K && used[tt]) tt++;\n            if(tt > K) return;\n        }\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tot = 0) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K && max(2ll, i * 2 - 2) + tot <= n + 3; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tot + max(2ll, i * 2 - 2));\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    //printf(\"%d\\n\", ts);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(max(p + 2*g, p + 2) > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(vector<int> &f) {\n    vector<int> used(K, 0);\n    vector<pii> bpos;\n\n    int pos1 = 0, pos2 = 0;\n    for(int i = (int)f.size() - 1; i >= 0; i--) {\n        if(f[i] == 0) continue;\n\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        bpos.push_back(pii(B[pos2], f[i] - 1));\n\n        used[ R[pos1] ] = 1;\n        used[ B[pos2] ] = 1;\n\n        pos1++;\n        pos2++;\n    }\n    for(int i = (int)bpos.size() - 1; i >= 0; i--) {\n        int need = bpos[i].second;\n        int pos = bpos[i].first;\n\n        for(int j = pos + 1; j < K; j++) {\n            if(need == 0) break;\n            if(!used[j]) {\n                need--;\n                used[j] = 1;\n            }\n        }\n        if(need) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + 2*f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        if(chk(f)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = 200;\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nint N, K;\nstring s;\nll ans;\n\nint cnt = 0;\nvoid calc(V<int>& vec) { //based on blue\n\tif (vec.empty()) {\n\t\tans = (ans + 1) % MOD;\n\t\treturn ;\n\t}\n\n\tint sz = vec.size();\n\n\tV<int> us(K);\n\tV<int> piv(sz);\n\n\tint now = 0;\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\twhile (now < K && s[now] == 'b') {\n\t\t\t++now;\n\t\t}\n\t\tif (now < K) {\n\t\t\tpiv[i] = now;\n\t\t\tus[now] = 1;\n\t\t\tnow++;\n\t\t} else {\n\t\t\treturn ;\n\t\t}\n\t}\n\n\tnow = 0;\n\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\tif (x >= 2) {\n\t\t\tchmax(now, piv[i] + 1);\n\t\t\twhile (now < K && s[now] == 'r') {\n\t\t\t\t++now;\n\t\t\t}\n\t\t\tif (now < K) {\n\t\t\t\tpiv[i] = now;\n\t\t\t\tus[now] = 1;\n\t\t\t\tnow++;\n\t\t\t} else {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\n\tnow = 0;\n\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\tif (x >= 3) {\n\t\t\tx -= 2;\n\t\t\tchmax(now, piv[i] + 1);\n\t\t\trep(t, x) {\n\t\t\t\twhile (now < K && us[now]) {\n\t\t\t\t\t++now;\n\t\t\t\t}\n\t\t\t\tif (now < K) {\n\t\t\t\t\tus[now] = 1;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint need = sz - 1;\n\tint bs = 0;\n\n\tfor (int x : vec) {\n\t\tif (x == 1) {\n\t\t\t++need;\n\t\t} else {\n\t\t\t++bs;\n\t\t\tneed += x * 2 - 3;\n\t\t}\n\t}\n\n\tif (need > N) {\n\t\treturn ;\n\t}\n\n\tll coef = fact[sz];\n\t{\n\n\t\trep(i, sz) {\n\t\t\tif (i == 0 || vec[i] != vec[i-1]) {\n\t\t\t\tint c = 0;\n\t\t\t\tfor (int j = i; j < sz; ++j) {\n\t\t\t\t\tif (vec[j] == vec[i]) {\n\t\t\t\t\t\t++c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcoef = coef * ifact[c] % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\t//dump(vec);\n\t//dump(need);\n\n\tcoef = coef * comb(N - need + (need + 1 + bs * 2), need + 1 + bs * 2);\n\n\tans = (ans + coef) % MOD;\n\t++cnt;\n}\n\nvoid gen(int p, int s, V<int>& vec) {\n\tif (p == K + 1 || s + p + vec.size() > N) {\n\t\tcalc(vec);\n\t\treturn ;\n\t}\n\n\tgen(p + 1, s, vec);\n\n\tfor (; s + p + vec.size() <= N; ) {\n\t\ts += p;\n\t\tvec.pb(p);\t\t\n\t\tgen(p + 1, s, vec);\n\t}\n\twhile (vec.size() && vec.back() == p) {\n\t\tvec.pop_back();\n\t}\n}\n\nint main() {\n\tinit();\n\n\tcin >> N >> K >> s;\n\t{\n\t\tV<int> vec;\n\t\tgen(1, 0, vec);\n\t}\n\t//dump(cnt);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, x, n) for(int i=x;i<=n;i++)\n#define pr make_pair\n#define fi first\n#define se second\n\nconst int MOD = int(1E9) + 7;\nconst int MAX = 420000;\n\ninline int add(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int sub(int x, int y) {x -= y; return x < 0 ? x + MOD : x;}\ninline int mul(int x, int y) {return (int) (1LL * x * y % MOD);}\nint mpow(int b, int p) {\n\tint r; for(r=1;p;p>>=1,b=mul(b,b))\n\t\tif( p & 1 ) r = mul(r, b);\n\treturn r;\n}\n\nstruct node{int x[40], cnt;}st[MAX + 5];\n\nint l[75], tot, N, K;\nvoid dfs(int s, node a, int x) {\n\tst[++tot] = a;\n\tfor(int i=x;i<=N&&l[i]<=s;i++)\n\t\ta.x[a.cnt++] = i, dfs(s - l[i], a, i), a.x[--a.cnt] = i;\n}\n\nint f[MAX + 5], fct[505], ifct[505], c[505][505];\nvoid init() {\n\trep(i, 0, 500) rep(j, 0, i)\n\t\tc[i][j] = (j == 0 ? 1 : add(c[i - 1][j], c[i - 1][j - 1]));\n\tfct[0] = 1; rep(i, 1, 500) fct[i] = mul(fct[i - 1], i);\n\tifct[500] = mpow(fct[500], MOD - 2);\n\tfor(int i=499;i>=0;i--) ifct[i] = mul(ifct[i + 1], i + 1);\n\t\n\tl[1] = 2; rep(i, 2, N) l[i] = (i - 1) << 1; dfs(N, (node){}, 1);\n\trep(i, 1, tot) {\n\t\tint a = 1, b = 0, t = 1, p = 1;\n\t\trep(j, 1, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != st[i].x[j-1] )\n\t\t\t\tt = mul(t, ifct[p]), p = 1;\n\t\t\telse p++;\n\t\t}\n\t\tt = mul(t, ifct[p]);\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tb += l[st[i].x[j]];\n\t\t\tif( st[i].x[j] != 1 ) a += 2;\n\t\t}\n\t\tf[i] = mul(mul(fct[st[i].cnt], t), c[N + a - 1][a + b - 1]);\n\t}\n//\tprintf(\"%d\\n\", tot);\n}\n\nint tg[75], q[75]; char s[75];\nint main() {\n\tscanf(\"%d%d%s\", &N, &K, s + 1), N++, init();\n\t\n\tint ans = 0;\n\trep(i, 1, tot) {\n\t\tint cnt1 = 0, pos = -1;\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != 1 ) {\n\t\t\t\tpos = j;\n\t\t\t\tbreak;\n\t\t\t} else cnt1++;\n\t\t}\n\t\t\n\t\tint hd = 1, tl = 0, p = st[i].cnt - cnt1;\n\t\trep(j, 1, K) tg[j] = -1;\n\t\tfor(int j=1;p&&j<=K;j++) {\n\t\t\tif( s[j] == 'r' ) q[++tl] = j;\n\t\t\telse if( hd <= tl ) tg[q[hd++]] = 0, tg[j] = 1, p--;\n\t\t}\n\t\t\n\t\tint cnt[2] = {}; bool flag = true;\n\t\tfor(int j=K;j>=1;j--) {\n\t\t\tif( tg[j] == -1 ) cnt[s[j] == 'r' ? 0 : 1]++;\n\t\t\telse if( tg[j] == 1 ) {\n\t\t\t\tint tmp = st[i].x[pos] - 2;\n\t\t\t\twhile( cnt[1] && tmp ) cnt[1]--, tmp--;\n\t\t\t\twhile( cnt[0] && tmp ) cnt[0]--, tmp--;\n\t\t\t\tif( tmp ) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( flag && cnt[0] >= cnt1 && p == 0 ) ans = add(ans, f[i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], suf[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nbool check () {\n\tvector<int> vec1, vec2, vec3;\n\tfor (int i = 0; i < top; i++) vec1.push_back(stk[i]);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') {\n\t\t\tif (!vec1.empty()) {\n\t\t\t\tif (vec1.back()) vec2.insert(vec2.begin(), vec1.back());\n\t\t\t\tvec1.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!vec2.empty()) {\n\t\t\t\tif (vec2.back() > 1) vec3.push_back(vec2.back() - 1);\n\t\t\t\tvec2.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn vec1.empty() && vec2.empty() && vec3.empty();\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=75;\nint C[N*5][N*5];\nint n,k,ans,used[N];\nint q1[N],q2[N],suf[N];\nint f[N][N];\nchar s[N];\nvoid init(){\n\tFor(i,0,N*5-1) C[i][0]=1;\n\tFor(i,1,N*5-1) For(j,1,i)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;\n}\nvoid solve(int S1,int S2){\n\tif (!S1&&!S2) return ++ans,void(0);\n\tif ((S1+S2)*2>n+1||S1+2*S2>k) return; \n\tmemset(used,0,sizeof(used));\n\tint h=0,t=*q2=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r') q1[++t]=i;\n\t\telse if (s[i]=='b'&&h!=t&&*q2!=S2)\n\t\t\tused[q1[++h]]=used[i]=1,q2[++*q2]=i;\n\tif (*q2!=S2) return;\n\tFor(i,1,S1)\n\t\tif (h==t) return;\n\t\telse used[q1[++h]]=1;\n\tRep(i,k,1) suf[i]=suf[i+1]+(!used[i]);\n\tFor(i,1,S2) q2[i]=suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tint upp=max(2,n);\n\tFor(i,2,upp) Rep(j,S2-1,0) For(k,2*j,upp){\n\t\tint psum=k-2*j;\n\t\tFor(l,1,min(S2-j,(upp-k)/i)){\n\t\t\tif ((psum+=i-2)>q2[S2-j-l+1]) break;\n\t\t\tf[j+l][k+i*l]=(f[j+l][k+i*l]+1ll*C[j+l][l]*f[j][k])%mo;\n\t\t}\n\t}\n\tFor(k,0,upp){\n\t\tint sum=2*S1+2*k-2*S2-1;\n\t\tint par=2*S1+2*k+1;\n\t\tif (sum&&sum<=n&&f[S2][k])\n\t\t\tans=(ans+1ll*f[S2][k]*C[n-sum+par-1][par-1]%mo*C[S2+S1][S2])%mo;\n\t}\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tFor(S1,0,n) For(S2,0,n) solve(S1,S2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"No\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=5e6+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=2e3+10;\n\t//------------------FIXED------------------\n\t\n\tvoid main()\n\t{\n\t\t\n\t}\n};//����������\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//����Ԥ����ģ����\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=205,mod=1e9+7;\nll ans,f[N],invf[N];\nll C(int n,int m)\n{\n    return f[n]*invf[n-m]%mod*invf[m]%mod;\n}\nint n,k,tot,cnt,pos[N],l[N],p[N],vv[N];\nchar s[N];\nbool vis[N];\nbool check()\n{\n    memset(vis,false,sizeof(vis[0])*(k+3));\n    memset(vv,0,sizeof(vv[0])*(k+3));\n    if(cnt>tot) return false;\n    int j=1;\n    for(int i=cnt;i>=1;i--)\n    {\n        int x=pos[j++];\n        vis[x]=true;\n        if(l[i]>=2)\n        {\n            if(!p[x]) return false;\n            vis[p[x]]=true;\n            vv[p[x]]=i;\n        }\n        else vv[x]=i;\n    }\n    int sum=0;\n    for(int i=k;i>=1;i--)\n        if(!vis[i]) sum++;\n        else if(vv[i])\n        {\n            int x=max(0,l[vv[i]]-2);\n            if(sum<x) return false;\n            sum-=x;\n        }\n    return true;\n}\nbool dfs(int mn,int dep,int len)\n{\n    cnt=dep;\n    if(!check()) return false;\n    int s=dep+1;\n    for(int i=1;i<=dep;i++)\n        if(l[i]==1) s++;\n    else s+=2*(l[i]-1)-1+2;\n    ll res=C(n-len+s-1,s-1)*f[dep]%mod;\n    int t=1;\n    for(int i=2;i<=dep;i++)\n        if(l[i]!=l[i-1]) res=res*invf[t]%mod,t=1;\n    else t++;\n    res=res*invf[t]%mod;\n    ans=(ans+res)%mod;\n    if(dep+1>tot) return true;\n    for(int i=mn;i<=k;i++)\n    {\n        int nlen=len;\n        if(dep!=0) nlen++;\n        if(i<=2) nlen++;\n        else nlen+=2*(i-1)-1;\n        if(nlen>n) break;\n        l[dep+1]=i;\n        if(!dfs(i,dep+1,nlen)) break;\n    }\n    return true;\n}\nint main()\n{\n    f[0]=invf[0]=f[1]=invf[1]=1;\n    for(int i=2;i<N;i++) f[i]=f[i-1]*i%mod,invf[i]=(mod-mod/i)*invf[mod%i]%mod;\n    for(int i=2;i<N;i++) invf[i]=invf[i-1]*invf[i]%mod;\n    scanf(\"%d%d\",&n,&k);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=k;i++)\n        if(s[i]=='r')\n    {\n        pos[++tot]=i;\n        for(int j=i+1;j<=k;j++)\n            if(!vis[j]&&s[j]=='b')\n        {\n            p[i]=j;vis[j]=true;break;\n        }\n    }\n    dfs(1,0,0);\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 141\nchar s[MN+5];\nmint F[MN+5],R[MN+5],ans;\nint n,a[MN+5],an,b[MN+5],bn,c[MN+5],u[MN+5],p[MN+5];\ninline mint C(int n,int m){return F[n]*R[m]*R[n-m];}\nvoid dfs(int x,int y,int z,int s0)\n{\n\tint i,j,k;\n\tmemset(u,0,sizeof(u));\n\tfor(i=j=1;i<z;u[a[i++]]=1)if(p[z-i])\n\t{\n\t\twhile(j<=bn&&b[j]<a[i])++j;\n\t\tif(j>bn)break;\n\t\tu[c[i]=b[j++]]=1;\n\t}\n\tif(i==z)for(i=j=1;i<z;++i)\n\t{\n\t\tfor(k=1;k<p[z-i];++k)\n\t\t{\n\t\t\twhile(s[j]&&(j<c[i]||u[j]))++j;\n\t\t\tif(!s[j++])break;\n\t\t}\n\t\tif(k<p[z-i])break;\n\t}\n\tif(i==z)\n\t{\n\t\tmint s=F[z-1];\n\t\tfor(i=1;i<z;s*=R[j-i],i=j)for(j=i;j<z&&p[i]==p[j];++j);\n\t\tans+=s*C(n+2*(z-1-s0),2*(z-1+x));\n\t}\n\tif(z<=an)for(;x+y<=an+bn-z&&x+y+s0+!y<=n/2;++y)dfs(x+y,p[z]=y,z+1,s0+!y);\n}\nint main()\n{\n\tint m,i;\n\tscanf(\"%d%d%s\",&n,&m,s+1);++n;\n\tfor(F[0]=i=1;i<=MN;++i)F[i]=F[i-1]*i;\n\tfor(R[i=MN]=~F[MN];i--;)R[i]=R[i+1]*(i+1);\n\tfor(i=1;i<=m;++i)(s[i]=='r'?a[++an]:b[++bn])=i;\n\tdfs(0,0,1,0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"No\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=5e6+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);int R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,R-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tfo(s,max(1,cc),ii) add(g[cc][i+ii][j+1],g[cc][i][j]*C(ii-s+1,cc)%MOD*(cc?C(s-1,cc-1):(s==ii))%MOD);\n\t\t\t}\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tfo(i,0,n-S) fo(j,0,R-t)\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*C(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//线性预处理模意义\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1'000'000'007;\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nint mul(int a, int b) {\n  return (int)((long long)a * b % mod);\n}\n\nint pw(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b /= 2;\n  }\n  return res;\n}\n\nint inv(int a) {\n  return pw(a, mod - 2);\n}\n\nconst int N = 79;\n\nchar t[N];\nint fact[N];\nint rfact[N];\nint c[2 * N][2 * N];\nint cnt_r[N];\nint f[N][N][N];\nint nf[N][N][N];\n\nint main() {\n  fact[0] = 1;\n  rfact[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    fact[i] = mul(fact[i - 1], i);\n    rfact[i] = inv(fact[i]);\n  }\n  memset(c, 0, sizeof c);\n  for (int i = 0; i < 2 * N; ++i) {\n    c[i][0] = 1;\n    c[i][i] = 1;\n    for (int j = 1; j < i; ++j) {\n      c[i][j] = c[i - 1][j - 1];\n      add(c[i][j], c[i - 1][j]);\n    }\n  }\n  int n, m;\n  scanf(\"%d %d %s\", &n, &m, t);\n  vector<int> need, size;\n  need.push_back(1);\n  size.push_back(1);\n  need.push_back(1);\n  size.push_back(2);\n  need.push_back(1);\n  size.push_back(2);\n  need.push_back(1);\n  size.push_back(3);\n  need.push_back(2);\n  size.push_back(3);\n  for (int i = 4; i <= n; ++i) {\n    need.push_back(i / 2);\n    size.push_back(i);\n    need.push_back((i + 1) / 2);\n    size.push_back(i);\n  }\n  vector<int> pr;\n  for (int i = 0; i < m; ++i) {\n    if (t[i] == 'r') {\n      pr.push_back(i);\n    }\n  }\n  vector<int> pb;\n  if (!pr.empty()) {\n    for (int i = pr[0] + 1; i < m; ++i) {\n      if (t[i] == 'b') {\n        pb.push_back(i);\n        break;\n      }\n    }\n    if (pb.empty()) {\n      pb.push_back(m);\n    }\n  }\n  for (int i = 1; i < (int)pr.size(); ++i) {\n    for (int j = max(pr[i], pb[i - 1]) + 1; j < m; ++j) {\n      if (t[j] == 'b') {\n        pb.push_back(j);\n        break;\n      }\n    }\n    if ((int)pb.size() < i + 1) {\n      pb.push_back(m);\n    }\n  }\n  int ans = 1;\n  for (int cnt = 1; cnt <= min(35, (int)pr.size()); ++cnt) {\n    memset(cnt_r, 0, sizeof cnt_r);\n    for (int i = 0; i < cnt; ++i) {\n      cnt_r[pr[i]] = 1;\n    }\n    for (int i = m - 2; i >= 0; --i) {\n      cnt_r[i] += cnt_r[i + 1];\n    }\n    memset(f, 0, sizeof f);\n    for (int i = 0; i <= cnt; ++i) {\n      f[i][0][i] = rfact[i];\n    }\n    for (int it = 0; it < (int)need.size(); ++it) {\n      for (int i = 0; i <= cnt; ++i) {\n        for (int j = 0; j <= m; ++j) {\n          for (int s = 0; s <= n; ++s) {\n            nf[i][j][s] = f[i][j][s];\n          }\n        }\n      }\n      for (int i = 0; i <= cnt; ++i) {\n        for (int j = 0; j <= m; ++j) {\n          for (int s = 0; s <= n; ++s) {\n            if (f[i][j][s] == 0) {\n              continue;\n            }\n            for (int k = 1; k <= n; ++k) {\n              int ni = i + k;\n              int nj = j + need[it] * k;\n              int ns = s + size[it] * k;\n              if (ni >= cnt + 1 || nj >= m + 1 || ns >= n + 1) {\n                break;\n              }\n              int pos = pb[cnt - 1 - (ni - 1)];\n              if (pos == m) {\n                break;\n              }\n              if ((m - pos) - j - cnt_r[pos] < need[it]) {\n                break;\n              }\n              add(nf[ni][nj][ns], mul(f[i][j][s], rfact[k]));\n            }\n          }\n        }\n      }\n      for (int i = 0; i <= cnt; ++i) {\n        for (int j = 0; j <= m; ++j) {\n          for (int s = 0; s <= n; ++s) {\n            f[i][j][s] = nf[i][j][s];\n          }\n        }\n      }\n    }\n    for (int j = 0; j <= m; ++j) {\n      for (int s = 0; s <= n; ++s) {\n        if (n - s >= cnt - 1) {\n          add(ans, mul(f[cnt][j][s], mul(fact[cnt], c[(n - s - (cnt - 1)) + (s + (cnt - 1) + 2) - 1][(s + (cnt - 1) + 2) - 1])));\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<tr1/unordered_map>\n#define pb push_back\n#define pii pair<int,int>\n#define SZ(x) (int)x.size()\n#ifdef __linux__\n#define getchar getchar_unlocked\n#endif\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=110;\nconst int inf=0x3f3f3f3f;\nconst LL mod=1e9+7;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,K;\nchar str[N];\nint st[N],a[N],len,p[N];\nLL fac[N],ifac[N],C[N][N],ans;\ninline void Add(LL&x,LL y){x=x+y<mod?x+y:x+y-mod;}\ninline LL qpow(LL a,LL b)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\ninline bool check(int tot)\n{\n\tint cnt=0,cntr=tot,cntb=tot;\n\tFor(i,1,K)\n\tif(str[i]=='r')\n\t{\n\t\tif(cntr)cntr--;\n\t\telse cnt-=cnt>0;\n\t}\n\telse\n\t{\n\t\tif(cntb>cntr&&cntb&&st[cntb])cnt+=st[cntb--]-1;\n\t\telse cnt-=cnt>0;\n\t}\n\treturn !cnt&&!cntr&&(!cntb||st[cntb]==0);\n}\nLL b[N],r[N],w[N],f[N],g[N];\ninline LL CC(int a,int b){return !b?!a:C[a+b-1][b-1];}\ninline LL Solve(int tot,int res)\n{\n\tint bcnt=0,rcnt=0,wcnt=0;\n\tFor(i,1,tot)bcnt+=st[i],rcnt+=st[i]+1;wcnt=tot+1;\n\tFor(i,0,res)f[i]=g[i]=0;\n\tFor(i,0,res)\n\t\tFor(j,0,res-i)\n\t\t\tAdd(f[i+j],CC(i,rcnt)*CC(j,bcnt)%mod);\n\tFor(i,0,res)\n\t\tFor(j,0,res-i)\n\t\t\tAdd(g[i+j],f[i]*CC(j,wcnt)%mod);\n\treturn g[res];\n}\ninline void dfs(int cnt,int res,int now,LL val)\n{\n\tif(res-max(now*2-1,1)-1<0)\n\t{\n\t\tif(check(cnt))Add(ans,Solve(cnt,res)*fac[cnt]%mod*val%mod);\n\t\treturn;\n\t}\n\tdfs(cnt,res,now+1,val);\n\tFor(i,1,res)\n\t{\n\t\tst[cnt+i]=now;\n\t\tint l=res-max(now*2-1,1)*i-i;\n\t\tif(l>=0)dfs(cnt+i,l,now+1,val*ifac[i]%mod);\n\t\telse break;\n\t}\n}\ninline void init(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tFor(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2);\n\trFor(i,n,2)ifac[i-1]=ifac[i]*i%mod;\n\tC[0][0]=1;\n\tFor(i,1,n)For(j,0,i)C[i][j]=(C[i-1][j]+(j?C[i-1][j-1]:0))%mod;\n}\nint main()\n{\n\tfile();\n\tread(n),read(K);\n\tinit(100);\n\tscanf(\"%s\",str+1);\n\tdfs(0,n+1,0,1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=750;\nint C[N][N],n,k,ans;\nint used[N],q1[N],q2[N];\nint suf[N],a[N];\nchar s[N];\nvoid init(){\n\tFor(i,0,N-1) C[i][0]=1;\n\tFor(i,1,N-1) For(j,1,i)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;\n}\nvoid solve(int S){\n\tif (!S) return ++ans,void(0);\n\tmemset(used,0,sizeof(used));\n\tint rest=S-a[1],h=0,t=*q2=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r') q1[++t]=i;\n\t\telse if (s[i]=='b'&&h!=t&&*q2!=rest)\n\t\t\tused[q1[++h]]=used[i]=1,q2[++*q2]=i;\n\t//printf(\"%d %d %d\\n\",rest,*q2,ans);\n\t//For(i,1,n) printf(\"%d \",a[i]); puts(\"\");\n\tif (*q2!=rest) return;\n\tFor(i,1,a[1])\n\t\tif (h==t) return;\n\t\telse used[q1[++h]]=1;\n\t//printf(\"%d %d %d\\n\",rest,*q2,ans);\n\t//For(i,1,n) printf(\"%d \",a[i]); puts(\"\");\n\tRep(i,k,1) suf[i]=suf[i+1]+(!used[i]);\n\tFor(i,1,S-a[1]) q2[i]=suf[q2[i]];\n\tint posi=S-a[1],sum=0,par=0;\n\tFor(i,2,n) For(j,1,a[i]){\n\t\tsum+=i-2;\n\t\tif (sum>q2[posi]) return;\n\t\t--posi; \n\t}\n\tint v=1,s=a[1];\n\tsum=a[1]+S-1;\n\tpar=S+1+a[1];\n\tFor(i,2,n){\n\t\tv=1ll*v*C[s+a[i]][s]%mo;\n\t\tsum+=a[i]*(2*i-3);\n\t\tpar+=a[i]*(2*i-1);\n\t\ts+=a[i]; \n\t}\n\tif (sum>n) return;\n\t//printf(\"%d %d %d\\n\",sum,par,v);\n\tv=1ll*v*C[n-sum+par-1][par-1]%mo;\n\tans=(ans+v)%mo;\n}\n/*\n\n*/\nvoid dfs(int x,int xx,int y,int S){\n\tif (y>x||2*max(y-1,1)>xx||y>n) return solve(S);\n\tfor (a[y]=0;x>=0&&xx>=0;++a[y],++S)\n\t\tdfs(x,xx,y+1,S),x-=y,xx-=2*max(y-1,1);\n\ta[y]=0;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tdfs(70,71,1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nmap<vector<char>,int> ma;\nvector<char> V,v[420010];\nint cnt,t[420010][36],n,m,f[71][420010],g[71][36][2],sum[71][36],ans,h[420010];\nchar s[110];\n\nvoid dfs(int nw)\n{\n\tma[V]=(++cnt),v[cnt]=V;\n\tfor (int i=(V.empty()?0:V[V.size()-1]); (i==0)+i+nw<=35; i++)\n\t\tV.push_back(i),dfs(i+nw+(i==0)),V.pop_back();\n}\n\nint main()\n{\n\tV.clear(),cnt=0,dfs(0);\n\tfor (int i=1,nw; i<=cnt; i++)\n\t{\n\t\tnw=0;\n\t\tfor (int j=0,sz=v[i].size(); j<sz; j++) nw+=(v[i][j]==0)+v[i][j];\n\t\tfor (int j=0; (j==0)+j+nw<=35; j++) \n\t\t{\n\t\t\tV=v[i],V.push_back(j),sort(V.begin(),V.end());\n\t\t\tt[i][j]=ma[V];\n\t\t}\n\t}\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tf[0][1]=1,g[0][0][0]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tg[i][0][0]=g[i-1][0][0],g[i][0][1]=0;\n\t\tfor (int j=1; j<=(i+1>>1); j++)\n\t\t\tg[i][j][0]=(g[i-1][j][0]+g[i-1][j][1])%mod,\n\t\t\tg[i][j][1]=(g[i-1][j][1]+g[i-1][j-1][0])%mod;\n\t}\n\tfor (int j=0; j<=(n+1>>1); j++)\n\t{\n\t\tsum[0][j]=0;\n\t\tfor (int i=1; i<=n; i++) sum[i][j]=(sum[i-1][j]+1ll*g[i][j][0]+g[i][j][1])%mod;\n\t}\n\tfor (int i=0; i<n; i++)\n\t\tfor (int k=1; k<=cnt; k++) if (f[i][k])\n\t\t\tfor (int nxt=(i==0?1:i+2),j=nxt; j<=n; j++)\n\t\t\t\tfor (int l=0; l<=(j-nxt+2>>1); l++)\n\t\t\t\t\tf[j][t[k][l]]=(f[j][t[k][l]]+1ll*f[i][k]*sum[j-nxt+1][l])%mod;\n\tfor (int j=1; j<=cnt; j++)\n\t\tfor (int i=0; i<=n; i++) h[j]=(h[j]+f[i][j]>=mod?h[j]+f[i][j]-mod:h[j]+f[i][j]);\n\tans=0;\n\tfor (int nw,p,i=1,nww; i<=cnt; i++) if (h[i])\n\t{\n\t\tnw=0,p=v[i].size(),nww=0;\n\t\tfor (int j=0; (p||nw)&&j<m; j++)\n\t\t\tif (s[j]=='r') {if (p) nw+=v[i][--p],nww+=max(v[i][p]-1,0); else if (nww&&nw) nw--,nww--;}\n\t\t\telse {if (nw) nw--;}\n\t\tif (!p&&!nw)  ans=(ans+h[i])%mod;\n\t}\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long N, K;\nlong long nr[109][109];\nlong long dp[109][109], nex[109][109];\n\nstring S;\nint LIM[109];\nbool used[109];\n\nvoid init() {\n\tfor (int i = 0; i <= 100; i++) {\n\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\tif (i == 0 || j == 0) nr[i][j] = 1;\n\t\t\telse nr[i][j] = (nr[i - 1][j] + nr[i][j - 1]) % mod;\n\t\t}\n\t}\n}\n\nlong long ncr(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\treturn nr[n - r][r];\n}\n\nlong long solve(int cnt1, int cnt2) {\n\t// ステップ 1: 前処理\n\tfor (int i = 0; i < 100; i++) { used[i] = false; LIM[i] = 0; }\n\n\t// ステップ 2: 上限文字数の計算\n\tint f1 = 0, f2 = 0; vector<int> E;\n\tfor (int i = 0; i < K; i++) {\n\t\tif (S[i] == 'r' && f1 < cnt1 + cnt2) { f1++; used[i] = true; }\n\t\tif (S[i] == 'b' && f2 < min(f1, cnt1)) { f2++; used[i] = true; E.push_back(i); }\n\t}\n\tif (f1 < cnt1 + cnt2 || f2 < cnt1) return 0;\n\tfor (int i = 0; i < cnt1; i++) {\n\t\tfor (int j = E[i] + 1; j < K; j++) {\n\t\t\tif (used[j] == false) LIM[i]++;\n\t\t}\n\t}\n\n\t// ステップ 3: 初期化\n\tfor (int i = 0; i <= 70; i++) {\n\t\tfor (int j = 0; j <= 70; j++) { dp[i][j] = 0; nex[i][j] = 0; }\n\t}\n\t\n\t// ステップ 4: DP の計算\n\tint V = N - 2 * (cnt1 + cnt2) + 1;\n\tint MaxLetter = (V / 2);\n\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= MaxLetter; i++) {\n\t\tfor (int j = 0; j <= cnt1; j++) {\n\t\t\tfor (int k = 0; k <= MaxLetter; k++) {\n\t\t\t\tif (dp[j][k] == 0) continue;\n\t\t\t\t\n\t\t\t\tint cx = j, cy = k, cnt = 0;\n\t\t\t\twhile (cx <= cnt1 && cy <= min(LIM[cnt1 - cx], MaxLetter)) {\n\t\t\t\t\tnex[cx][cy] += ncr(cx, j) * dp[j][k];\n\t\t\t\t\tnex[cx][cy] %= mod;\n\t\t\t\t\tcx += 1; cy += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= cnt1; j++) {\n\t\t\tfor (int k = 0; k <= MaxLetter; k++) {\n\t\t\t\tdp[j][k] = nex[j][k];\n\t\t\t\tnex[j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ステップ 5: 最終的な計算\n\tlong long ret = 0;\n\tfor (int i = 0; i <= MaxLetter; i++) {\n\t\tint minimal_letter = 2 * (cnt1 + cnt2) - 1 + i * 2;\n\t\tint ranged = (cnt1 + cnt2 + 1) + (cnt1 * 3 + i * 2) + cnt2;\n\t\tlong long V1 = dp[cnt1][i];\n\t\tlong long V2 = ncr(ranged + (N - minimal_letter) - 1, N - minimal_letter);\n\t\tret += (V1 * V2);\n\t\tret %= mod;\n\t}\n\n\tlong long ret2 = ncr(cnt1 + cnt2, cnt2);\n\treturn (ret * ret2) % mod;\n}\n\nint main() {\n\tcin >> N >> K >> S;\n\tinit();\n\n\tlong long Answer = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tlong long rem = solve(i, j);\n\t\t\t//cout << i << \" \" << j << \" \" << rem << endl;\n\t\t\tAnswer += rem;\n\t\t\tAnswer %= mod;\n\t\t}\n\t}\n\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modInt {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n\n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }\n\n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }\n    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }\n    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }\n\n    friend void check(modInt& a, modInt& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modInt operator+(modInt a, modInt b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modInt operator-(modInt a, modInt b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modInt operator-(const modInt& a) { return modInt(0)-a; }\n\n    friend modInt operator*(modInt a, modInt b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modInt exp(modInt a, ll p) {\n        modInt ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modInt inv(const modInt& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modInt operator/(modInt a, modInt b) { \n        check(a,b); return a*inv(b); \n    }\n};\n\ntypedef modInt<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,K, clen;\nmi comb[200][200];\nvector<vi> v;\nvi cur;\nstring s;\n\nvoid gen(int lst) {\n    // if (lst == 3) ps(\"??\");\n    v.pb(cur);\n    for (int i = lst; ; ++i) {\n        int c = clen; if (c) c ++;\n        int len = max(1,2*i-3);\n        if (c+len > N) return;\n        clen = c+len; cur.pb(i); gen(i);\n        clen = c; if (clen) clen --; cur.pop_back();\n    } \n}\n\nbool ok(vi needR) {\n    deque<int> needB; int need = 0;\n    trav(c,s) {\n        if (c == 'r') {\n            if (sz(needR)) {\n                int x = needR.back()-1; needR.pop_back();\n                if (x) needB.pb(x);\n            } else if (need) need --; \n        } else {\n            if (sz(needB)) {\n                int x = needB.front()-1; needB.pop_front();\n                need += x;\n            } else if (need) need --;\n        }\n    }\n    // ps(\"\")\n    return !sz(needR) && !sz(needB) && !need;\n}\n\nint main() {\n    comb[0][0] = 1;\n    FOR(i,1,200) {\n        comb[i][0] = 1;\n        FOR(j,1,i+1) comb[i][j] = comb[i-1][j-1]+comb[i-1][j];\n    }\n    setIO(); re(N,K,s);\n    gen(1);\n    mi ret(0);\n    trav(t,v) {\n        if (!sz(t)) ret += 1;\n        else {\n            int a = sz(t)-1, b = 0, c = sz(t)+1;\n            map<int,int> m;\n            mi zz(0);\n            // a: # at least, b: possible 1+x, c: (1+x+x^2+...)\n            trav(x,t) {\n                if (x == 1) a++, c++;\n                else a += 2*x-3, b += 2, c += 2*x-3;\n            }\n            F0R(i,b+1) {\n                // a+i numbers, (1+x+x^2+...)^{c+i}\n                zz += comb[b][i]*comb[N-(a+i)+(c+i-1)][c+i-1];\n                // ret += comb[b][i]*comb[N-(a+i)+sz(t)][sz(t)];\n            }\n            FOR(i,1,sz(t)+1) zz *= i;\n            trav(x,t)  {\n                m[x] ++;\n                zz /= m[x];\n            }\n            if (ok(t)) ret += zz;\n        }\n    }\n    ps(ret);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=75,mo=1e9+7;\nint n,k,_N;\nchar s[N];\nint cnt[N],a[N],mrk[N],f[N],st[N],t,sf[N];\nll Ans,jc[N*10],ny[N*10];\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}return ans;\n}\nll C(ll n,ll m){\n\treturn ny[m]*ny[n-m]%mo*jc[n]%mo;\n}\nint check(int n){\n\tif (n==0){\n\t\tAns++;\n\t\treturn 1;\n\t}\n\tmemset(mrk,0,sizeof mrk);\n\tmemset(f,0,sizeof f);\n\tmemset(sf,0,sizeof sf);\n\tif (!st[n])return 0;\n\tfor (int i=1;i<=n;i++){\n\t\tmrk[st[i]]=1;\n\t\tfor (int j=max(st[i],f[i-1]);s[j];j++)\n\t\t\tif (s[j]=='b'&&!mrk[j]){\n\t\t\t\tf[i]=j;\n\t\t\t\tmrk[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (a[i]==1)mrk[f[i]]=0,f[i]=0;\n\t\tif (!st[i]||!f[i]&&a[i]>1)return 0;\n\t\tif (a[i]==1)break;\n\t}\n\tfor (int i=k;i>=1;i--)\n\t\tsf[i]=sf[i+1]+(!mrk[i]);\n\tfor (int i=1;i<=n;i++)\n\t\tif (sf[f[i]]+2<a[i])return 0;\n\t\n\tll n1=1,m1=2,ans=1,sum=0;\n\tfor (int i=1;i<=_N;i++)\n\t\tsum+=cnt[i],ans=ans*ny[cnt[i]]%mo;\n\tans=ans*jc[sum]%mo;\n\tfor (int i=1;i<=n;i++)\n\t\tn1+=2*a[i],m1+=2*(a[i]>=2);\n\tans=ans*C(_N+m1-1,n1-1);\n\tAns=(Ans+ans)%mo;\n//\tcout<<ans<<endl;\n\treturn 1;\n}\nint ccnt=0;\nvoid dfs(int x,int s,int la){\n\tif (s>n+1)return;\n\tif (!check(x-1))return;\n\tfor (int i=1;i<=la;i++){\n\t\ta[x]=i;\n\t\tcnt[i]++;\n\t\tdfs(x+1,s+max(2,2*(i-1)),i);\n\t\tcnt[i]--;\n\t}\n}\nint main(){\n\tcin>>n>>k;_N=n;\n\tjc[0]=ny[0]=1;\n\tfor (int i=1;i<=700;i++)jc[i]=jc[i-1]*i%mo;\n\tny[700]=power(jc[700]);\n\tfor (int i=700;i>=1;i--)ny[i-1]=ny[i]*i%mo;\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=k;i++){\n\t\tif (s[i]=='r')st[++t]=i;\n\t}\n\tdfs(1,0,n);\n\tcout<<Ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst LL mod = 1e9 + 7;\nconst int MC = 202;\nLL fct[MC+1];\nLL invfct[MC+1];\nint N,K;\nstring s;\nvector<int> V;\nLL ans;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,MC+1){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[MC];\n\tinvfct[MC] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (invfct[MC] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,MC,0){\n\t\tinvfct[i-1] = invfct[i] * i % mod;\n\t}\n}\n\nLL comb(int x , int y){\n\tif(x < 0 || y < 0) return 0;\n\treturn invfct[x] * invfct[y] % mod * fct[x+y] % mod;\n}\n\nbool solve(int y , int z , int a , LL r , bool b){\n\tif(z > N+1 || a > N+1) return 0;\n\tif(b){\n\t\tint x = V.size();\n\t\tint itr = x - 1 , itb = x - 1;\n\t\tint p = y , q = 0;\n\t\tfor(auto c : s){\n\t\t\tif(c=='r'){\n\t\t\t\tif(itr >= 0) --itr;\n\t\t\t\telse if(p>0) --p;\n\t\t\t\telse if(q) --q;\n\t\t\t} else {\n\t\t\t\tif(itb > itr){\n\t\t\t\t\tq += V[itb]-1;\n\t\t\t\t\t--itb;\n\t\t\t\t} else if(q) --q;\n\t\t\t}\n\t\t}\n\t\tif(~itr || ~itb || p || q) return 0;\n\t\tLL w = fct[x+y] * r % mod;\n\t\tw = w * comb(N-z+1,z+2*x) % mod;\n\t\t(ans += w) %= mod;\n\t}\n\tsolve(y,z,a+1,r,0);\n\tV.PB(a);\n\tfor(int i = 1 ; solve(y,z+2*a*i,a+1,r*invfct[i]%mod,1) ; ++i) V.PB(a);\n\twhile(V.size() && *V.rbegin() == a) V.pop_back();\n\treturn 1;\n}\n\nint main(){\n\tbuild();\n\tcin >> N >> K;\n\tcin >> s;\n\tfor(int i = 0 ; solve(i,i*2,1,invfct[i],1) ; ++i);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=5e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();PRE();\n\t\tscanf(\"%s\",str+1);int R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,R-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tif(!cc) add(g[0][i+ii][j+1],g[0][i][j]);\n\t\t\t\telse fo(s,1,ii) add(g[cc][i+ii][j+1],g[cc][i][j]*Comb(ii-s+1,cc)%MOD*Comb(s-1,cc-1)%MOD);\n\t\t\t}\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tfo(i,0,n-S) fo(j,0,R-t)\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*Comb(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::main();\n\t//debug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[N], tmp[N], top = 0;\nchar str[K];\nlong long c[N * 5][N * 5], ans = 0ll;\n\nlong long solve () {\n\tqueue<int> que;\n\tfor (int i = 0; i < m; i++) suf[i] = 1;\n\tfor (int i = 0, j = top - 1; i < m && j >= 0; i++) {\n\t\tif (str[i] == 'r') que.push(i);\n\t\tif (stk[j] && str[i] == 'b' && !que.empty()) {\n\t\t\tsuf[que.front()] = suf[i] = 0;\n\t\t\tque.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\twhile (j >= 0 && !stk[j] && !que.empty()) {\n\t\t\tsuf[que.front()] = 0, que.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\tif (i == m - 1 && j >= 0) return 0ll;\n\t}\n\n\tsuf[m] = 0;\n\tfor (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n\tfor (int i = 0, j = 0; i < top; i++) {\n\t\tif (stk[i]) {\n\t\t\tj += stk[i] - 1;\n\t\t\tif (suf[pos[i]] < j) return 0ll;\n\t\t}\n\t}\n\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n  \tfor (int i = 0; i <= n * 5; i++) {\n    \tfor (int j = 0; j <= n * 5; j++) c[i][j] = 0ll;\n    }\n  \tfor (int i = 0; i <= n * 5; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 5; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\ntemplate<ll MOD, int REV = 1>\nclass ModInt {\n\tpublic:\n\tstatic bool flag[REV];\n\tstatic ll rev[REV];\n\tstatic ll pw(ll a, ll b) {\n\t\tll ans = 1; while (b) {\n\t\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\t\tans = (ans * a) % MOD, --b;\n\t\t} return ans;\n\t}\n\tll x;\n\tModInt(): x(0) {}\n\tModInt(ll x): x(x % MOD) {}\n\tModInt operator+(ModInt b) {\n\t\tModInt ans;\n\t\tans.x = x + b.x;\n\t\tif (ans.x >= MOD)\n\t\t\tans.x -= MOD;\n\t\treturn ans;\n\t}\n\tModInt &operator+=(ModInt b) {\n\t\tx += b.x;\n\t\tif (x >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt operator-(ModInt b) {\n\t\tModInt ans;\n\t\tans.x = x - b.x;\n\t\tif (ans.x < 0)\n\t\t\tans.x += MOD;\n\t\treturn ans;\n\t}\n\tModInt &operator-=(ModInt b) {\n\t\tx -= b.x;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\treturn *this;\n\t}\n\tModInt operator-() {\n\t\tModInt ans;\n\t\tif (x == 0)\n\t\t\treturn ans;\n\t\tans.x = MOD - x;\n\t\treturn ans;\n\t}\n\tModInt operator*(ModInt b) {\n\t\treturn ModInt(x * b.x);\n\t}\n\tModInt &operator*=(ModInt b) {\n\t\tx = (x * b.x) % MOD;\n\t\treturn *this;\n\t}\n\tModInt inv() {\n\t\tif (MOD >= 2) {\n\t\t\tif (x >= REV)\n\t\t\t\treturn ModInt(pw(x, MOD - 2));\n\t\t\telse {\n\t\t\t\tif (flag[x])\n\t\t\t\t\treturn rev[x];\n\t\t\t\telse {\n\t\t\t\t\tflag[x] = 1;\n\t\t\t\t\treturn rev[x] = pw(x, MOD - 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ModInt();\n\t}\n\tModInt operator/(ModInt b) {\n\t\treturn ModInt(x * b.inv().x);\n\t}\n\tModInt& operator/=(ModInt b) {\n\t\tx = (x * b.inv().x) % MOD;\n\t\treturn *this;\n\t}\n\tbool operator==(ModInt b) {\n\t\treturn x == b.x;\n\t}\n\tbool operator!=(ModInt b) {\n\t\treturn x != b.x;\n\t}\n};\n\ntemplate<ll MOD, int REV>\nbool ModInt<MOD, REV>::flag[] = {};\n\ntemplate<ll MOD, int REV>\nll ModInt<MOD, REV>::rev[] = {};\n\nconst ll MOD = 1e9 + 7;\n\nusing num = ModInt<MOD, 100>;\n\nnum ans = 0;\nconst int MX = 72;\n\nnum dp[MX][MX];\n\nstring s;\n\nstruct st {\n\tint pos;\n\tint fr;\n\tint nd;\n\tdeque<int> dq;\n\tst() {\n\t\tpos = fr = nd = 0;\n\t}\n\tint add(int sz) {\n\t\twhile (pos < s.size() && s[pos] == 'b') {\n\t\t\tif (nd) {\n\t\t\t\t--nd;\n\t\t\t\tfr += dq.front();\n\t\t\t\tdq.pop_front();\n\t\t\t}\n\t\t\telse if (fr)\n\t\t\t\t--fr;\n\t\t\t++pos;\n\t\t}\n\t\tif (pos == s.size())\n\t\t\treturn 0;\n\t\tpos += 1;\n\t\tif (sz) {\n\t\t\t++nd;\n\t\t\tdq.push_back(sz - 1);\n\t\t}\n\t\treturn 1;\n\t}\n\tint check() {\n\t\tint pos2 = pos;\n\t\tint fr2 = fr;\n\t\tint nd2 = nd;\n\t\tauto dq2 = dq;\n\t\twhile (pos2 < s.size()) {\n\t\t\tif (s[pos2] == 'r') {\n\t\t\t\tif (fr2)\n\t\t\t\t\t--fr2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nd2) {\n\t\t\t\t\t--nd2;\n\t\t\t\t\tfr2 += dq2.front();\n\t\t\t\t\tdq2.pop_front();\n\t\t\t\t}\n\t\t\t\telse if (fr2)\n\t\t\t\t\t--fr2;\n\t\t\t}\n\t\t\t++pos2;\n\t\t}\n\t\tif (nd2 || fr2)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n};\n\nint gn;\n\ndouble sum = 0;\n\n\nint Cnt;\nvector<int> stck;\n\nvoid run(int n, int cnt, int lst, int cntlst, st cur, array<num, MX> a) {\n\tif (cur.check()) {\n\t\tfor (int i = 0; i <= gn; ++i)\n\t\t\tans += a[i];\n\t}\n\telse\n\t\treturn;\n\n\tif (n >= 2) {\n\t\tfor (int i = min(lst, n / 2); i >= 0; --i) {\n\t\t\tauto cur2 = cur;\n\t\t\tif (!cur2.add(i))\n\t\t\t\tcontinue;\n\t\t\tif (lst == i)\n\t\t\t\t++cntlst;\n\t\t\telse\n\t\t\t\tcntlst = 1;\n\t\t\tarray<num, MX> b = {};\n\t\t\t//auto start = std::chrono::high_resolution_clock::now();\n\t\t\tfor (int j = 0; j <= gn; ++j) {\n\t\t\t\tif (a[j].x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int k = 2 * i; j + k <= gn; ++k)\n\t\t\t\t\tb[j + k] += a[j] * dp[i][k];\n\t\t\t}\n\t\t\tfor (int j = 0; j <= gn; ++j) {\n\t\t\t\tb[j] *= (cnt + 1);\n\t\t\t\tif (cntlst != 1)\n\t\t\t\t\tb[j] /= cntlst;\n\t\t\t}\n\t\t\t//auto end = std::chrono::high_resolution_clock::now();\n\t\t\t//sum += std::chrono::duration<ld>(end - start).count();\n\t\t\tstck.push_back(i);\n\t\t\tif (i != 0)\n\t\t\t\trun(n - 2 * i, cnt + 1, i, cntlst, cur2, b);\n\t\t\telse\n\t\t\t\trun(n - 2, cnt + 1, i, cntlst, cur2, b);\n\t\t\tstck.pop_back();\n\t\t}\n\t}\n}\n\n\nnum fc[MX * 2];\nnum bfc[MX * 2];\n\nnum cnk(int n, int k) {\n\tif (k > n)\n\t\treturn 0;\n\treturn fc[n] * bfc[k] * bfc[n - k];\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcout.setf(ios::fixed), cout.precision(20);\n\tfc[0] = 1;\n\tfor (int i = 1; i < 2 * MX; ++i)\n\t\tfc[i] = (fc[i - 1] * i);\n\tfor (int i = 0; i < 2 * MX; ++i)\n\t\tbfc[i] = fc[i].inv();\n\tint n, k;\n\tcin >> n >> k;\n\tcin >> s;\n\tn += 1;\n\tgn = n;\n\tfor (int i = 2; i < MX; ++i)\n\t\tdp[0][i] = i - 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfor (int j = i * 2; j < MX; ++j) {\n\t\t\tdp[i][j] = cnk(j - 2 * i + 2 * i + 1, 2 * i + 1);\n\t\t}\n\t}\n\trun(n, 0, n, 0, {}, {1});\n\tcout << ans.x << \"\\n\";\n\t//cerr << sum << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nlong long solve () {\n\tfor (int i = 0; i < m; i++) vis[i] = true;\n\tfor (int i = 0; i < top; i++) {\n\t\tint lst = m;\n\t\tfor (int j = m - 1, k = 0; j >= 0; j--) {\n\t\t\tif (!vis[j]) continue;\n\t\t\tif (k < stk[i] - 1) vis[j] = false, k++;\n\t\t}\n\t\tfor (int j = m - 1; j >= 0; j--) {\n\t\t\tif (!vis[j]) continue;\n\t\t\tif (stk[i] && str[j] == 'b') {\n\t\t\t\tlst = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!stk[i] && str[j] == 'r') {\n\t\t\t\tlst = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (lst >= m) return 0ll;\n\t\tvis[lst] = false;\n\t\tif (stk[i]) {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = lst; j >= 0; j--) {\n\t\t\t\tif (!vis[j]) continue;\n\t\t\t\tif (str[j] == 'r') {\n\t\t\t\t\tflag = true, vis[j] = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) return 0ll;\n\t\t}\n\t}\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nvoid calc(int sz) {\n    /*int tb = 0, tr = 0;\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && ch[tb] != 'b') tb++;\n        }\n        if(tr > K || tb > K) return;\n    }*/\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tr = 0, int tb = 0) {\n    calc(x - 1);\n    int tmpr = tr, tmpb = tb;\n    tmpr++;\n    while(tmpr <= K && ch[tmpr] != 'r') tmpr++;\n    tmpb = max(tmpb + 1, tmpr);\n    while(tmpb <= K && ch[tmpb] != 'b') tmpb++;\n    if(tmpr <= K) {\n        X[x] = 1;\n        Search(x + 1, 1, tbr + 1, tmpr, tb);\n    }\n    if(tmpb <= K) for(int i = 2; i <= lst && i + tbr <= K; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tmpr, tmpb);\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=5e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();PRE();\n\t\tscanf(\"%s\",str+1);int R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,R-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tif(!cc) add(g[0][i+ii][j+1],g[0][i][j]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tll V=Comb(ii-1,cc*2-2)+Comb(ii-1,cc*2-1)*2+Comb(ii-1,cc*2);V%=MOD;\n\t\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*V%MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfo(i,0,n) fo(j,0,R) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tfo(i,0,n-S) fo(j,0,R-t) if(go[cnt][ln][t][j]<=blu[m])\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*Comb(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::main();\n\t//debug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=75;\nint n,K,i,j,k,s1,s2,C[N*2][N*2],st[N],w,b,x,y,ans=1,a[N];\nchar c[N];\nvoid dfs(int d,int s,int ss,bool fl){\n\tif(fl){\n\t\tfor(i=1,j=k=w,b=0;i<=K;++i){\n\t\t\tif(c[i]=='r'){if(j)--j;else if(b)--b;}\n\t\t\tif(c[i]=='b'){if(k>j && st[k])b+=st[k--]-1;else if(b)--b;}\n\t\t}\n\t\tif(!j && !st[k] && !b){\n\t\t\ts1=s-1,s2=ss+1,x=C[n-s1+s2-1][s2-1];y=0;\n\t\t\tfor(i=0;i<d;++i)y+=a[i],x=1ll*C[y][a[i]]*x%mo;\n\t\t\tans=(ans+x)%mo;\n\t\t}\n\t}\n\tif(s+(d<2?1:d*2-1)>n)return;\n\tint ow=w;\n\tfor(int i=0,j;s+i*(d<2?1:d*2-1)+i-1<=n;st[++w]=d,++i)\n\t\ta[d]=i,dfs(d+1,s+i*(d<2?1:d*2-1)+i,ss+i*(d*2+1)+i,i);\n\tw=ow;\n}\nint main(){\n\tfor(i=**C=1;i<N*2;++i)for(j=*C[i]=1;j<=i;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\tscanf(\"%d%d%s\",&n,&K,c+1);\n\tdfs(0,0,0,0);\n\tprintf(\"%d\\n\",ans%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(max(p + 2*g, p + 2) > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(vector<int> &f) {\n    vector<int> used(K, 0);\n    vector<pii> bpos;\n\n    int pos1 = 0, pos2 = 0;\n    for(int i = (int)f.size() - 1; i >= 0; i--) {\n        if(f[i] == 0) continue;\n\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        bpos.push_back(pii(B[pos2], f[i] - 1));\n\n        used[ R[pos1] ] = 1;\n        used[ B[pos2] ] = 1;\n\n        pos1++;\n        pos2++;\n    }\n    for(int i = 0; i < f.size(); i++) {\n        if(f[i]) continue;\n        \n        for(int j = 0; j < K; j++) if(!used[j] && S[j] == 'r') {\n            used[j] = 1;\n            break;\n        }\n    }\n    \n    for(int i = (int)bpos.size() - 1; i >= 0; i--) {\n        int need = bpos[i].second;\n        int pos = bpos[i].first;\n\n        for(int j = pos + 1; j < K; j++) {\n            if(need == 0) break;\n            if(!used[j]) {\n                need--;\n                used[j] = 1;\n            }\n        }\n        if(need) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + 2*f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        if(chk(f)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int mod = 1e9+7;\nvector<int> V;\nint C[210][210],n,len;\nchar S[210];\nll ans;\nll fp(ll a,ll k){\n\tll ans=1;\n\tfor(;k;k>>=1,a=a*a%mod)\n\t\tif(k&1) ans=a*ans%mod;\n\treturn ans;\n}\nvoid calc(){\n\tint nd=0,k1=0,k2=0;\n\tfor(int i=1;i<=len;i++){\n\t\tif(k1<V.size()&&S[i]=='r') k1++;\n\t\telse if(k2<k1&&V[k2]>0&&S[i]=='b') nd+=V[k2++]-1;\n\t\telse if(nd) nd--;\n\t}\n\tif(nd||k1<V.size()||k2<k1&&V[k2]>0) return;\n//\tfor(auto x:V) cerr<<x<<' ';cerr<<'\\n';\n\tint used=V.size()-1,pos=used+2;\n\tfor(int i=0;i<V.size();i++) used+=max(1,V[i]*2-1),pos+=V[i]*2+1;\n\tll now=C[pos+n-used-1][n-used];\n\tll p=0,res=1;\n\tfor(int i=0;i<V.size();i++){\n\t\tif(i==0||V[i]==V[i-1]){\n\t\t\tres=res*++p%mod;\n\t\t}\n\t\telse now=now*fp(res,mod-2)%mod,res=1,p=1;\n\t\tnow=now*(i+1)%mod;\n\t}\n\tans=(ans+now*fp(res,mod-2))%mod;\n}\nvoid solve(int n,int lim){\n\tif(V.size()) calc();\n\tfor(int i=lim;~i;i--)\n\t\tif(max(1,2*i-1)<=n){\n\t\t\tif(max(1,2*i-1)==n&&V.size()) continue;\n\t\t\tV.push_back(i);\n\t\t\tsolve(n-max(2*i-1,1)-(V.size()!=1),i);\n\t\t\tV.pop_back();\n\t\t}\n}\nint main(){\n\tread(n);read(len);\n\tcin>>S+1;ans=1;\n\tfor(int i=0;i<=150;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\t}\n\tsolve(n,n);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], suf[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nbool check () {\n\tvector<int> vec1, vec2, vec3;\n\tfor (int i = 0; i < top; i++) vec1.push_back(stk[i]);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') {\n\t\t\tif (!vec1.empty()) {\n\t\t\t\tif (vec1.back()) vec2.insert(vec2.begin(), vec1.back());\n\t\t\t\tvec1.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\tvec3.back()--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!vec2.empty()) {\n\t\t\t\tif (vec2.back() > 1) vec3.push_back(vec2.back() - 1);\n\t\t\t\tvec2.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\tvec3.back()--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn vec1.empty() && vec2.empty() && vec3.empty();\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nconst int P = 1e9 + 7;\nconst int MAX = 300;\nset<vector<int>> x;\nvector<set<vector<int>>::iterator> zr,zb;\nint res = 1;\nint sil[MAX],odw[MAX];\nint newt[MAX][MAX];\nstring z;\nint n,k;\nvoid add(vector<int> ak){\n  auto pom = x.insert(ak);\n  if(pom.SE){\n    int mn = 1;\n    int sum = 0;\n    int sum2 = 0;\n    R(i,SZ(ak)){\n      sum += ak[i];\n      sum2 += ak[i] * i;\n      mn = (mn * odw[ak[i]]) % P;\n    }\n    int a = n + 2 + (sum - ak[0]) * 2 - 1;\n    int b = 2 * sum2 + 2 * sum;\n    if(a >= b){\n      res += mn * sil[sum] % P * newt[a][b] % P;\n      zr.PB(pom.FI);\n      zb.PB(pom.FI);\n    }\n  }\n}\nvoid dod(vector<int> pom,int zak){\n  R(i,SZ(pom))if(i != zak && (i == 0 || pom[i-1])){\n    if(i)pom[i-1]--;\n    pom[i]++;\n    add(pom);\n    pom[i]--;\n    if(i)pom[i-1]++;\n  }\n  if(SZ(pom) != zak){\n    if(SZ(pom))pom.back()--;\n    pom.PB(1);\n    add(pom);\n  }\n}\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = r * a % P;\n    }\n    w/=2;\n    a = a * a % P;\n  }\n  return r;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  sil[0] = 1;\n  R(i,MAX-1){\n    sil[i+1] = (i+1) * sil[i] % P;\n  }\n  R(i,MAX){\n    odw[i] = pot(sil[i],P-2);\n  }\n  R(i,MAX)R(j,i+1){\n    if(j == 0){\n      newt[i][j] = 1;\n    }else{\n      newt[i][j] = newt[i-1][j-1] + newt[i-1][j];\n      if(newt[i][j] >= P)\n        newt[i][j] -= P;\n    }\n  }\n  cin >> n >> k >> z;\n\n  auto xx = x.insert(vector<int>());\n  zr.PB(xx.FI);\n  zb.PB(xx.FI);\n  R(i,k){\n    if(z[i] == 'r'){\n      vector<set<vector<int>>::iterator> pom;\n      swap(pom,zr);\n      for(auto el:pom){\n        dod(*el,1);\n      }\n    }else{\n      vector<set<vector<int>>::iterator> pom;\n      swap(pom,zb);\n      for(auto el:pom){\n        dod(*el,0);\n      }\n    }\n  }\n  cout << res % P << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 150\n#define p 1000000007\n#define ll long long\nint a[N],b[N],c[N],d[N],e[N],m,n,x,y;char s[N];bool t[N];\ninline bool solve(int z)\n{\n    int i,j,k;\n    for(i=1;i<=m;i++)t[i]=false;\n    for(i=j=1;i<=y;d[i]=c[i]<2?0:c[i]-2,i++)i==y||c[i]!=c[i+1]?z=(ll)b[i-j+1]*z%p,j=i+1:0;\n    for(i=1,j=k=y;i<=m;i++)\n    if(s[i]=='r'&&c[j]>1)t[i]=true,j--;\n    else if(s[i]=='b'&&j<k&&c[k]>1)t[e[k--]=i]=true;\n    else if(s[i]=='r'&&c[j]==1)t[e[j--]=i]=true;\n    if(j||c[k]>1)return false;\n    for(i=1,j=y;i<=m&&j;!t[i]&&e[j]<i?d[j]--:0,i++)while(j&&!d[j])j--;\n    while(j&&!d[j])j--;\n    if(j)return false;\n    return x=(x+(ll)z*a[y])%p,true;\n}\nvoid dfs(int u,int v,int w){if(solve((ll)a[v]*b[w]%p*b[v-w]%p))for(int i=u;0<=v-w-(i==1?2:i-1<<1);i++)dfs(c[++y]=i,v+(i==1?0:2),w+(i<<1)),y--;}\nint main()\n{\n    scanf(\"%d%d%s\",&n,&m,s+1),*a=a[1]=*b=b[1]=1;\n    for(int i=2;i<N;i++)a[i]=(ll)a[i-1]*i%p,b[i]=(ll)(p-p/i)*b[p%i]%p;\n    for(int i=2;i<N;i++)b[i]=(ll)b[i]*b[i-1]%p;\n    dfs(1,n+1,0),printf(\"%d\\n\",x);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint n,k;\nchar s[81];\nbool vis[81];\nbool book[81];\nint a[81];\nbool check(int m)\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(book,0,sizeof(book));\n\tint cnt=0;\n\tfor(int i=1;i<=m&&a[i]==1;i++)cnt++;\n\tint nowr=1,nowb=1;\n\tfor(int i=1;i<=m-cnt;i++)\n\t{\n\t\twhile(nowr<=k&&(vis[nowr]||s[nowr]!='r'))nowr++;\n\t\twhile(nowb<=k&&(vis[nowr]||s[nowb]!='b'||nowb<=nowr))nowb++;\n\t\tif(nowr>k||nowb>k)return false;\n\t\tvis[nowr]=true;\n\t\tvis[nowb]=true;\n\t\tbook[nowb]=true;\n\t}\n\tint tmp=cnt;\n\tfor(int i=1;i<=k&&tmp;i++)\n\t\tif(!vis[i]&&s[i]=='r'){\n\t\t\tvis[i]=true;\n\t\t\ttmp--;\n\t\t}\n\tif(tmp)return false;\n\tint now=cnt+1,num=0;\n\tfor(int i=k;i>=1&&now<=m;i--)\n\t{\n\t\tif(!vis[i])num++;\n\t\tif(book[i]){\n\t\t\tnum-=a[now]-2;\n\t\t\tif(num<0)return false;\n\t\t\tnow++;\n\t\t}\n\t}\n\treturn true;\n}\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%Mod;\n\t\tt=1ll*t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint ans;\nint fac[510],inv[510];\nvoid init()\n{\n\tint N=500;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\tif(x<0||y<0||x-y<0)return 0;\n\treturn 1ll*fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nvoid solve(int m,int len)\n{\n\tint s=0;//block-1\n\tfor(int i=1;i<=m;i++)\n\t\ts+=a[i]*2;\n\tint res=1ll*C(n-len+s,s)*fac[m]%Mod;\n\tfor(int i=1,j;i<=m;i=j)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&a[j]==a[i])j++;\n\t\tres=1ll*res*inv[j-i]%Mod;\n\t}\n\tans=(ans+res)%Mod;\n\treturn ;\n}\nbool dfs(int m,int lst,int sum,int len)\n{\n\tif(len>n)return false;\n\tif(!check(m-1))return false;\n\tsolve(m-1,len);\n\tfor(a[m]=lst;a[m]<=k-sum;a[m]++)\n\t{\n\t\tint tlen=len;\n\t\tif(m>1)tlen++;\n\t\tif(a[m]==1)tlen++;\n\t\telse tlen+=(a[m]-1)*2-1;\n\t\tif(!dfs(m+1,a[m],sum+a[m],tlen))\n\t\t\tbreak;\n\t}\n\treturn true;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tdfs(1,1,0,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=5e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();PRE();\n\t\tscanf(\"%s\",str+1);int R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,R-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tif(!cc) add(g[0][i+ii][j+1],g[0][i][j]);\n\t\t\t\telse fo(s,1,ii) add(g[cc][i+ii][j+1],g[cc][i][j]*Comb(ii-s+1,cc)%MOD*Comb(s-1,cc-1)%MOD);\n\t\t\t}\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tfo(i,0,n-S) fo(j,0,R-t)\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*Comb(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::main();\n\t//debug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nint dp[111][111];\n\nint calc(){\n    /*\n    if(X[0]==1){\n        if(X.size()>R)return 0;\n        int n=X.size();\n        int y=N-(2*n+1);\n        return nCk(2*n+y,y);\n    }*/\n    int n=X.size();\n    int nr=R-n,nb=B;\n    for(int i=0;i<X.size();i++){\n        int pos=r[R-i];\n        while(nb>0&&b[nb]<pos)nb--;\n        if(X[i]==1)continue;\n        if(nb==0)return 0;\n        while(nr>0&&r[nr]<b[nb])nr--;\n        nb--;\n        rep(t,X[i]-2){\n            if(i+1<n&&nb&&b[nb]<r[R-i-1]){\n                nb--;\n                continue;\n            }\n            if(nr){\n                nr--;\n                continue;\n            }\n            if(nb){\n                nb--;\n                continue;\n            }\n            return 0;\n        }\n    }\n\n\n    rep(i,n+1)rep(j,N+1)dp[i][j]=0;\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<N;j++){\n            if(X[i]==1){\n                for(int k=1;j+k<=N;k++)add(dp[i+1][j+k],dp[i][j]);\n            }\n            else{\n                for(int k=0;2*X[i]-3+k+j<=N;k++){\n                    add(dp[i+1][j+2*X[i]-3+k],dp[i][j]*nCk(2*X[i]-2+k,k)%mod);\n                }\n            }\n        }\n    }\n\n    int ret=0;\n    for(int i=0;i<=N;i++){\n        add(ret,dp[n][i]*nCk(N-i+1,n)%mod);\n    }\n\n    ret=ret*fact[n]%mod;\n    map<int,int>cnt;\n    rep(i,n)cnt[X[i]]++;\n    for(auto p:cnt)ret=ret*inv[p.se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()==R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[N], tmp[N], top = 0;\nchar str[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nlong long solve () {\n\tqueue<int> que;\n\tfor (int i = 0; i < m; i++) suf[i] = 1;\n\tfor (int i = 0, j = top - 1; i < m && j >= 0; i++) {\n\t\tif (str[i] == 'r') que.push(i);\n\t\tif (stk[j] && str[i] == 'b' && !que.empty()) {\n\t\t\tsuf[que.front()] = suf[i] = 0;\n\t\t\tque.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\twhile (j >= 0 && !stk[j] && !que.empty()) {\n\t\t\tsuf[que.front()] = 0, que.pop();\n\t\t\tpos[j--] = i;\n\t\t}\n\t\tif (i == m - 1 && j >= 0) return 0ll;\n\t}\n\n\tsuf[m] = 0;\n\tfor (int i = m - 1; i >= 0; i--) suf[i] += suf[i + 1];\n\tfor (int i = 0, j = 0; i < top; i++) {\n\t\tif (stk[i]) {\n\t\t\tj += stk[i] - 1;\n\t\t\tif (suf[pos[i]] < j) return 0ll;\n\t\t}\n\t}\n\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 107\n\nint N, K, tot, res;\nint mch[MAX_N], pos[MAX_N], sum[MAX_N];\nint fac[MAX_N * 3], ifac[MAX_N * 3];\nchar s[MAX_N];\nbool vis[MAX_N];\n\ninline int C(int x, int y) {\n    if (y < 0 || x < y) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid init() {\n    int MX = 300;\n    fac[0] = ifac[0] = 1;\n    Rep(i, MX) fac[i] = mul(fac[i - 1], i);\n    ifac[MX] = qpow(fac[MX], MOD - 2);\n    irep(i, MX, 2) ifac[i - 1] = mul(ifac[i], i);\n    Rep(i, K) if (s[i] == 'r') {\n        pos[++tot] = i;\n        rep(j, i + 1, K) if (s[j] == 'b' && !vis[j]) {\n            mch[i] = j;\n            vis[j] = true;\n            break;\n        }\n    }\n}\n\nint tp[MAX_N];\nbool check(int cur) {\n    if (cur > tot) return false;\n    Rep(i, N) sum[i] = 0;\n    int p = 1;\n    IRep(i, cur) {\n        sum[pos[i]]++;\n        if (tp[p] > 1) {\n            if (!mch[pos[i]]) return false;\n            sum[mch[pos[i]]] += tp[p] - 1;\n        }\n        p++;\n    }\n    IRep(i, K) {\n        sum[i] += sum[i + 1];\n        if (sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\n\nbool dfs(int deg, int pre, int len) {\n    if (!check(deg - 1)) return false;\n    int t = deg;\n    Lep(i, deg) t += 2 * tp[i] - 1;\n    int ans = mul(C(N - len + t - 1, t - 1), fac[deg - 1]), tmp = 1;\n    Lep(i, deg) {\n        if (tp[i] != tp[i - 1]) {\n            ans = mul(ans, ifac[tmp]);\n            tmp = 0;\n        }\n        ++tmp;\n    }\n    ans = mul(ans, ifac[tmp]);\n    // printf(\"%d:  \", ans);\n    // Lep(i, deg) printf(\"%d \", tp[i]);\n    // puts(\"\");\n    inc(res, ans);\n    if (deg > tot) return true;\n    rep(i, pre, 70) {\n        int L = len;\n        if (deg > 1) L++;\n        if (i == 1)\n            L++;\n        else\n            L += i - 2 + i - 1;\n        if (L > N) break;\n        tp[deg] = i;\n        if (!dfs(deg + 1, i, L)) break;\n    }\n    return true;\n}\n\nvoid solve() {\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N), read(K);\n    scanf(\"%s\", s + 1);\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=200;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],pp[N],suf[N],blu[N],after[N][3];\n\tbool inB[N];char str[N];\n\t\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\t\n\tint sum[N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);\n\t\tg[0][0][0]=1;fo(i,1,n) fo(j,1,m) g[0][i][j]=C(i-1,j-1)*facinv[j]%MOD;\n\t\tfo(cc,1,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,m-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*( (C(ii-1,cc*2-2)+C(ii-1,cc*2-1)*2+C(ii-1,cc*2))%MOD )%MOD);\n\t\t\tfo(i,0,n) fo(j,0,m) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tll ans=0;dp[n+1][0][0][0]=1;\n\t\tfo(MA,0,m)\n\t\t{\n\t\t\tint R=0;mem(inB,0);\n\t\t\tfo(i,1,m) if(str[i]=='r')\n\t\t\t{\n\t\t\t\tif(R==MA) break;\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1,pos[++R]=j,ok=1;break;}\n\t\t\t\tif(!ok) break;pp[R]=i;\n\t\t\t}\n\t\t\tif(R<MA) break;\n\t\t\t\n\t\t\tfo(B,0,m)\n\t\t\t{\n\t\t\t\tint cc=0;fo(i,1,m) if(str[i]=='r') cc++,blu[i]=blu[i-1]+(cc>MA+B); else blu[i]=blu[i-1]+(!inB[i]);\n\t\t\t\tif(cc<R+B) break;\n\t\t\t\tfo(cnt,0,m) fo(ln,1,n) fo(st,0,R)\n\t\t\t\t{\n\t\t\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-(blu[pos[st+j]]-blu[pos[st+j-1]-1]))+(ln-1);\n\t\t\t\t}\n\t\t\t\tfd(ln,n,1) fo(S,0,n) fo(A,0,min(R,S/ln)) fo(cnt,0,m) dp[ln][S][A][cnt]=0;\n\t\t\t\tfd(ln,n,1)\n\t\t\t\t{\n\t\t\t\t\tfo(S,0,n) fo(A,0,min(R,S/ln)) fo(cnt,0,m) if(dp[ln+1][S][A][cnt])\n\t\t\t\t\t\tfo(j,0,R-A) if(go[cnt][ln][A][j]<=blu[m]-blu[pos[A]]) fo(i,0,n-S)\n\t\t\t\t\t\t\tadd(dp[ln][S+i][A+j][go[cnt][ln][A][j]],1ll*dp[ln+1][S][A][cnt]*g[ln][i][j]%MOD);\n\t\t\t\t}\n\t\t\t\tfo(S,0,n) fo(cnt,0,blu[m]-blu[pos[R]]) if(dp[1][S][R][cnt])\n\t\t\t\t\tfo(S2,0,n-S) if(g[0][S2][B])\n\t\t\t\t\t\tadd(ans,1ll*dp[1][S][R][cnt]*g[0][S2][B]%MOD*fac[R+B]%MOD*C(n-S-S2+1,R+B)%MOD);\n\t\t\t}\n\t\t}\n\t\twrite(ans);\n\t}\n};//����������\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//����Ԥ����ģ����\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}\n/*\n7 7\nrbrrrbb\n\n9 6\nrrrbbb\n\n5 5\nrrrbb\n\n7 4\nrbrb\n\n5 4\nrrbb\n\n3 3\nrbr\n\n70 70\nbbrbrrbbrrbbbbrbbrbrrbbrrbbrbrrbrbrbbbbrbbrbrrbbrrbbbbrbbrbrrbbrrbbbbr\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%1000000007\n#define mod 1000000007\n#define Mod 1000000005\n#define ll long long\n#define N 1000\n//#define file\nusing namespace std;\n\nll f[71][71][71],g[71][71][71],jc[N+1],Jc[N+1],ans;\nint d[71],n,m,i,j,k,l,x,y;\nchar a[71];\nbool bz[71];\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;};\nll C(int n,int m) {if (n<m) return 0;return jc[n]*Jc[m]%mod*Jc[n-m]%mod;}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc089F.in\",\"r\",stdin);\n\t#endif\n\t\n\tjc[0]=1;\n\tfo(i,1,N) jc[i]=jc[i-1]*i%mod;\n\tJc[N]=qpower(jc[N],Mod);\n\tfd(i,N-1,0) Jc[i]=Jc[i+1]*(i+1)%mod;\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1);\n\tans=1;\n\tfo(x,0,n/2)\n\t{\n\t\tfo(y,0,n)\n\t\tif (x || y)\n\t\t{\n\t\t\tmemset(bz,0,sizeof(bz));\n\t\t\tfo(i,1,x)\n\t\t\t{\n\t\t\t\tfo(j,1,m) if (!bz[j] && a[j]=='r') break;\n\t\t\t\tfo(k,j,m) if (!bz[k] && a[k]=='b') break;\n\t\t\t\tif (k>m) break;\n\t\t\t\tbz[j]=bz[k]=1;\n\t\t\t}\n\t\t\tif (k>m) continue;\n\t\t\tl=0;\n\t\t\tfo(i,1,m) if (l<y && !bz[i] && a[i]=='r') ++l,bz[i]=1;\n\t\t\tif (l<y) continue;\n\t\t\t\n\t\t\tl=0;\n\t\t\tfo(j,1,m)\n\t\t\tif (bz[j] && a[j]=='b')\n\t\t\t{\n\t\t\t\td[++l]=0;\n\t\t\t\tfo(k,j,m) d[l]+=!bz[k];\n\t\t\t}\n\t\t\t\n\t\t\tmemset(f,0,sizeof(f)),f[0][0][d[1]]=1;\n\t\t\tfo(i,0,x-1)\n\t\t\t{\n\t\t\t\tfo(j,0,d[1])\n\t\t\t\t{\n\t\t\t\t\tfd(k,d[1],0)\n\t\t\t\t\tif (f[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k>=1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tadd(f[i][j][k-1],f[i][j][k]);\n\t\t\t\t\t\t\tfo(l,1,x-i)\n\t\t\t\t\t\t\tif (j+l*k<=d[1] && k<=d[i+l])\n\t\t\t\t\t\t\tadd(f[i+l][j+l*k][k-1],f[i][j][k]*C(i+l+y,l));\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\tadd(f[x][j][k],f[i][j][k]*C(x+y,x-i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfo(j,0,d[1])\n\t\t\t{\n\t\t\t\tfo(k,0,d[1])\n\t\t\t\t{\n\t\t\t\t\tfo(l,0,n)\n\t\t\t\t\tadd(ans,f[x][j][k]*C(l+(y+2*j+x*3)-1,(y+2*j+x*3)-1)%mod*C(n-(x+y-1)-2*j-l,x+y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long N, K;\nlong long nr[209][109];\nlong long dp[209][109], nex[209][209];\n\nstring S;\nint LIM[209];\nbool used[209];\n\nvoid init() {\n\tfor (int i = 0; i <= 200; i++) {\n\t\tfor (int j = 0; j <= 200; j++) {\n\t\t\tif (i == 0 || j == 0) nr[i][j] = 1;\n\t\t\telse nr[i][j] = (nr[i - 1][j] + nr[i][j - 1]) % mod;\n\t\t}\n\t}\n}\n\nlong long ncr(int n, int r) {\n\tif (r < 0 || n < r) return 0;\n\treturn nr[n - r][r];\n}\n\nlong long solve(int cnt1, int cnt2) {\n\t// ステップ 1: 前処理\n\tfor (int i = 0; i < 200; i++) { used[i] = false; LIM[i] = 0; }\n\n\t// ステップ 2: 上限文字数の計算\n\tint f1 = 0, f2 = 0; vector<int> E;\n\tfor (int i = 0; i < K; i++) {\n\t\tif (S[i] == 'r' && f1 < cnt1 + cnt2) { f1++; used[i] = true; }\n\t\tif (S[i] == 'b' && f2 < min(f1, cnt1)) { f2++; used[i] = true; E.push_back(i); }\n\t}\n\tif (f1 < cnt1 + cnt2 || f2 < cnt1) return 0;\n\tfor (int i = 0; i < cnt1; i++) {\n\t\tfor (int j = E[i] + 1; j < K; j++) {\n\t\t\tif (used[j] == false) LIM[i]++;\n\t\t}\n\t}\n\n\t// ステップ 3: 初期化\n\tfor (int i = 0; i <= 70; i++) {\n\t\tfor (int j = 0; j <= 70; j++) { dp[i][j] = 0; nex[i][j] = 0; }\n\t}\n\t\n\t// ステップ 4: DP の計算\n\tint V = N - 2 * (cnt1 + cnt2) + 1;\n\tint MaxLetter = (V / 2);\n\n\tdp[0][0] = 1;\n\tfor (int i = 0; i <= MaxLetter; i++) {\n\t\tfor (int j = 0; j <= cnt1; j++) {\n\t\t\tfor (int k = 0; k <= MaxLetter; k++) {\n\t\t\t\tif (dp[j][k] == 0) continue;\n\t\t\t\t\n\t\t\t\tint cx = j, cy = k, cnt = 0;\n\t\t\t\twhile (cx <= cnt1 && cy <= min(LIM[cnt1 - cx], MaxLetter)) {\n\t\t\t\t\tnex[cx][cy] += ncr(cx, j) * dp[j][k];\n\t\t\t\t\tnex[cx][cy] %= mod;\n\t\t\t\t\tcx += 1; cy += i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= cnt1; j++) {\n\t\t\tfor (int k = 0; k <= MaxLetter; k++) {\n\t\t\t\tdp[j][k] = nex[j][k];\n\t\t\t\tnex[j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t// ステップ 5: 最終的な計算\n\tlong long ret = 0;\n\tfor (int i = 0; i <= MaxLetter; i++) {\n\t\tint minimal_letter = 2 * (cnt1 + cnt2) - 1 + i * 2;\n\t\tint ranged = (cnt1 + cnt2 + 1) + (cnt1 * 3 + i * 2) + cnt2;\n\t\tlong long V1 = dp[cnt1][i];\n\t\tlong long V2 = ncr(ranged + (N - minimal_letter) - 1, N - minimal_letter);\n\t\tret += (V1 * V2);\n\t\tret %= mod;\n\t}\n\n\tlong long ret2 = ncr(cnt1 + cnt2, cnt2);\n\treturn (ret * ret2) % mod;\n}\n\nint main() {\n\tcin >> N >> K >> S;\n\tinit();\n\n\tlong long Answer = 0;\n\tfor (int i = 0; i <= N; i++) {\n\t\tfor (int j = 0; j <= N; j++) {\n\t\t\tlong long rem = solve(i, j);\n\t\t\t//cout << i << \" \" << j << \" \" << rem << endl;\n\t\t\tAnswer += rem;\n\t\t\tAnswer %= mod;\n\t\t}\n\t}\n\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define div _zzd001\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=75*2,mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n,k;\nint C[N][N];\nchar s[N];\nvector <int> div;\nint ans=0;\nint cr=0,cb=0;\nvoid Solve(){\n//\tans++;\n//\toutarr(div,0,(int)div.size()-1);\n\tint nr=0,nb=0;\n\tfor (auto i : div)\n\t\tnr++,nb+=i>1;\n\tif (nr>cr||nb>cb)\n\t\treturn;\n\tstatic int a[N],rem[N];\n\tclr(a),clr(rem);\n\tint m=div.size();\n\tFor(i,0,m-1)\n\t\ta[i+1]=div[i];\n\treverse(a+1,a+m+1);\n\tint pp=0;\n\tFor(i,1,m)\n\t\tif (a[i]>1)\n\t\t\tpp=i;\n\tint need=0,p=0,sp=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r'&&p<m){\n\t\t\tp++;\n\t\t}\n\t\telse if (s[i]=='b'){\n\t\t\tif (sp<min(p,pp)){\n\t\t\t\tneed+=a[++sp]-2;\n\t\t\t}\n\t\t\telse if (need>0)\n\t\t\t\tneed--;\n\t\t}\n\t\telse if (need>0){\n\t\t\tneed--;\n\t\t}\n\tif (need>0||sp<pp)\n\t\treturn;\n\tstatic int dp[N];\n\tstatic int cs[4]={0,0,1,0};\n\tclr(dp);\n\tdp[0]=1;\n\tfor (auto i : div){\n\t\tFod(j,n,0){\n\t\t\tif (!dp[j])\n\t\t\t\tcontinue;\n\t\t\tFod(k,3,1){\n\t\t\t\tif (j+i*2-k+1>n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (i==1&&k>1)\n\t\t\t\t\tcontinue;\n\t\t\t\tAdd(dp[j+i*2-k+1],Add(dp[j]<<cs[k]));\n\t\t\t}\n\t\t\tdp[j]=0;\n\t\t}\n\t}\n\tint tmp=0;\n//\toutarr(dp,0,n);\n\tFor(i,0,n)\n\t\tif (dp[i])\n\t\t\tAdd(tmp,(LL)dp[i]*C[n][i]%mod);\n\tint las=1;\n\ta[m+1]=-1;\n\tint s=0;\n\tFor(i,2,m+1){\n\t\tif (a[i]!=a[i-1]){\n\t\t\tint len=i-las;\n\t\t\tlas=i;\n\t\t\ttmp=(LL)tmp*C[s+=len][len]%mod;\n\t\t}\n\t}\n//\toutval(tmp);\n\tAdd(ans,tmp);\n}\nvoid dfs(int rem,int n,int now,int flag){\n\tif (n<0)\n\t\treturn;\n\tif (flag)\n\t\tSolve();\n\tif (rem>=now){\n\t\tdiv.pb(now);\n\t\tdfs(rem-now,n-max(1,now*2-3)-1,now,1);\n\t\tdiv.pop_back();\n\t\tdfs(rem,n,now+1,0);\n\t}\n}\nint main(){\n\tFor(i,0,N-1)\n\t\tC[i][0]=1;\n\tFor(i,1,N-1)\n\t\tFor(j,1,i)\n\t\t\tC[i][j]=Add(C[i-1][j-1]+C[i-1][j]);\n\tn=read()+1,k=read();\n\tcin>>(s+1);\n\tFor(i,1,k)\n\t\tif (s[i]=='r')\n\t\t\tcr++;\n\t\telse\n\t\t\tcb++;\n\tdiv.clear();\n\tdfs(k,n,1,1);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\ntemplate<ll MOD, int REV = 1>\nclass ModInt {\n\tpublic:\n\tstatic bool flag[REV];\n\tstatic ll rev[REV];\n\tstatic ll pw(ll a, ll b) {\n\t\tll ans = 1; while (b) {\n\t\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\t\tans = (ans * a) % MOD, --b;\n\t\t} return ans;\n\t}\n\tll x;\n\tModInt(): x(0) {}\n\tModInt(ll x): x(x % MOD) {}\n\tModInt operator+(ModInt b) {\n\t\tModInt ans;\n\t\tans.x = x + b.x;\n\t\tif (ans.x >= MOD)\n\t\t\tans.x -= MOD;\n\t\treturn ans;\n\t}\n\tModInt &operator+=(ModInt b) {\n\t\tx += b.x;\n\t\tif (x >= MOD)\n\t\t\tx -= MOD;\n\t\treturn *this;\n\t}\n\tModInt operator-(ModInt b) {\n\t\tModInt ans;\n\t\tans.x = x - b.x;\n\t\tif (ans.x < 0)\n\t\t\tans.x += MOD;\n\t\treturn ans;\n\t}\n\tModInt &operator-=(ModInt b) {\n\t\tx -= b.x;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\treturn *this;\n\t}\n\tModInt operator-() {\n\t\tModInt ans;\n\t\tif (x == 0)\n\t\t\treturn ans;\n\t\tans.x = MOD - x;\n\t\treturn ans;\n\t}\n\tModInt operator*(ModInt b) {\n\t\treturn ModInt(x * b.x);\n\t}\n\tModInt &operator*=(ModInt b) {\n\t\tx = (x * b.x) % MOD;\n\t\treturn *this;\n\t}\n\tModInt inv() {\n\t\tif (MOD >= 2) {\n\t\t\tif (x >= REV)\n\t\t\t\treturn ModInt(pw(x, MOD - 2));\n\t\t\telse {\n\t\t\t\tif (flag[x])\n\t\t\t\t\treturn rev[x];\n\t\t\t\telse {\n\t\t\t\t\tflag[x] = 1;\n\t\t\t\t\treturn rev[x] = pw(x, MOD - 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ModInt();\n\t}\n\tModInt operator/(ModInt b) {\n\t\treturn ModInt(x * b.inv().x);\n\t}\n\tModInt& operator/=(ModInt b) {\n\t\tx = (x * b.inv().x) % MOD;\n\t\treturn *this;\n\t}\n\tbool operator==(ModInt b) {\n\t\treturn x == b.x;\n\t}\n\tbool operator!=(ModInt b) {\n\t\treturn x != b.x;\n\t}\n};\n\ntemplate<ll MOD, int REV>\nbool ModInt<MOD, REV>::flag[] = {};\n\ntemplate<ll MOD, int REV>\nll ModInt<MOD, REV>::rev[] = {};\n\nconst ll MOD = 1e9 + 7;\n\nusing num = ModInt<MOD, 100>;\n\nnum ans = 0;\nconst int MX = 72;\n\nnum dp[MX][MX];\n\nstring s;\n\nstruct st {\n\tint pos;\n\tint fr;\n\tint nd;\n\tst() {\n\t\tpos = fr = nd = 0;\n\t}\n\tint add(int sz) {\n\t\twhile (pos < s.size() && s[pos] == 'b') {\n\t\t\tif (nd)\n\t\t\t\t--nd;\n\t\t\telse if (fr)\n\t\t\t\t--fr;\n\t\t\t++pos;\n\t\t}\n\t\tif (pos == s.size())\n\t\t\treturn 0;\n\t\tpos += 1;\n\t\tif (sz) {\n\t\t\t++nd;\n\t\t\tfr += sz - 1;\n\t\t}\n\t\treturn 1;\n\t}\n\tint check() {\n\t\tint pos2 = pos;\n\t\tint fr2 = fr;\n\t\tint nd2 = nd;\n\t\twhile (pos2 < s.size()) {\n\t\t\tif (s[pos2] == 'r') {\n\t\t\t\tif (fr2)\n\t\t\t\t\t--fr2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (nd2)\n\t\t\t\t\t--nd2;\n\t\t\t\telse if (fr2)\n\t\t\t\t\t--fr2;\n\t\t\t}\n\t\t\t++pos2;\n\t\t}\n\t\tif (nd2 || fr2)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n};\n\nint gn;\n\ndouble sum = 0;\n\n\nint Cnt;\n\nvoid run(int n, int cnt, int lst, int cntlst, st cur, array<num, MX> a) {\n\tif (cur.check()) {\n\t\tfor (int i = 0; i <= gn; ++i)\n\t\t\tans += a[i];\n\t}\n\telse\n\t\treturn;\n\n\tif (n >= 2) {\n\t\tfor (int i = min(lst, n / 2); i >= 0; --i) {\n\t\t\tauto cur2 = cur;\n\t\t\tif (!cur2.add(i))\n\t\t\t\tcontinue;\n\t\t\tif (lst == i)\n\t\t\t\t++cntlst;\n\t\t\telse\n\t\t\t\tcntlst = 1;\n\t\t\tarray<num, MX> b = {};\n\t\t\t//auto start = std::chrono::high_resolution_clock::now();\n\t\t\tfor (int j = 0; j <= gn; ++j) {\n\t\t\t\tif (a[j].x == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (int k = 2 * i; j + k <= gn; ++k)\n\t\t\t\t\tb[j + k] += a[j] * dp[i][k];\n\t\t\t}\n\t\t\tfor (int j = 0; j <= gn; ++j) {\n\t\t\t\tb[j] *= (cnt + 1);\n\t\t\t\tif (cntlst != 1)\n\t\t\t\t\tb[j] /= cntlst;\n\t\t\t}\n\t\t\t//auto end = std::chrono::high_resolution_clock::now();\n\t\t\t//sum += std::chrono::duration<ld>(end - start).count();\n\t\t\tif (i != 0)\n\t\t\t\trun(n - 2 * i, cnt + 1, i, cntlst, cur2, b);\n\t\t\telse\n\t\t\t\trun(n - 2, cnt + 1, i, cntlst, cur2, b);\n\t\t}\n\t}\n}\n\n\nnum fc[MX * 2];\nnum bfc[MX * 2];\n\nnum cnk(int n, int k) {\n\tif (k > n)\n\t\treturn 0;\n\treturn fc[n] * bfc[k] * bfc[n - k];\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcout.setf(ios::fixed), cout.precision(20);\n\tfc[0] = 1;\n\tfor (int i = 1; i < 2 * MX; ++i)\n\t\tfc[i] = (fc[i - 1] * i);\n\tfor (int i = 0; i < 2 * MX; ++i)\n\t\tbfc[i] = fc[i].inv();\n\tint n, k;\n\tcin >> n >> k;\n\tcin >> s;\n\tn += 1;\n\tgn = n;\n\tfor (int i = 2; i < MX; ++i)\n\t\tdp[0][i] = i - 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfor (int j = i * 2; j < MX; ++j) {\n\t\t\tdp[i][j] = cnk(j - 2 * i + 2 * i + 1, 2 * i + 1);\n\t\t}\n\t}\n\trun(n, 0, n, 0, {}, {1});\n\tcout << ans.x << \"\\n\";\n\t//cerr << sum << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=75;\nint n,K,i,j,s1,s2,C[N*2][N*2],st[N],w,b,x,y,ans=1,a[N];\nchar c[N];\nvoid dfs(int d,int s,int ss,bool fl){\n\tif(fl){\n\t\tfor(i=1,j=w,b=0;i<=K;++i){\n\t\t\tif(c[i]=='r'){if(j)b+=st[j--];else if(b)--b;}\n\t\t\tif(c[i]=='b' && b)--b;\n\t\t}\n\t\tif(!j && !b){\n\t\t\ts1=s-1,s2=ss+1,x=C[n-s1+s2-1][s2-1];y=0;\n\t\t\tfor(i=0;i<d;++i)y+=a[i],x=1ll*C[y][a[i]]*x%mo;\n\t\t\tans=(ans+x)%mo;\n\t\t}\n\t}\n\tif(s+(d<2?1:d*2-1)>n)return;\n\tint ow=w;\n\tfor(int i=0,j;s+i*(d<2?1:d*2-1)+i-1<=n;st[++w]=d,++i)\n\t\ta[d]=i,dfs(d+1,s+i*(d<2?1:d*2-1)+i,ss+i*(d*2+1)+i,i);\n\tw=ow;\n}\nint main(){\n\tfor(i=**C=1;i<N*2;++i)for(j=*C[i]=1;j<=i;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\tscanf(\"%d%d%s\",&n,&K,c+1);\n\tdfs(0,0,0,0);\n\tprintf(\"%d\\n\",ans%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int p=1000000007;\n\nint c[300][300],g[100],h[100];\nchar b[100];\nint i,j,k,l,m,n,r,s,t;\n\ninline void pre()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",b+1);\n\tfor (i=0;i<=250;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t\tif ((j==0) || (j==i))\n\t\t\t\tc[i][j]=1;\n\t\t\telse\n\t\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%p;\n\treturn;\n}\n\ninline void calc()\n{\n\tfor (i=1;i<=n;i++)\n\t\th[i]=g[i];\n\tt=0;\n\tfor (i=1,k=1,l=1;i<=m;i++)\n\t\tif ((b[i]=='r') && (h[k]>0))\n\t\t\th[k]--,k++;\n\t\telse\n\t\tif ((b[i]=='b') && (h[l]>0) && (l<k))\n\t\t\th[l]--,t=t+h[l],l++;\n\t\telse\n\t\tif (t>0)\n\t\t\tt--;\n\tif ((h[k]) || (h[l]) || (t))\n\t\treturn;\n\tr=1;\n\tfor (i=1;g[i];i=j)\n\t{\n\t\tfor (j=i;g[i]==g[j];j++);\n\t\tr=1LL*r*c[j-1][i-1]%p;\n\t\tif (g[i]==1)\n\t\t\tt=t+j-i;\n\t\telse\n\t\t\tt=t+(j-i)*(2*g[i]-3);\n\t}\n\tt=t+k-2;\n\tif (n-t<0)\n\t\treturn;\n\ts=(s+1LL*r*c[n+2*l-1][t+2*l-1])%p;\n\treturn;\n}\n\ninline void dfs(int w,int x,int y,int z)\n{\n\tif (w<0)\n\t\treturn;\n\tif (z)\n\t\tcalc();\n\tif (x)\n\t{\n\t\tg[z+1]=1,dfs(w-2,x-1,1,z+1);\n\t\tfor (int i=2;(i<=x) && (i<=y);i++)\n\t\t\tg[z+1]=i,dfs(w-2*i+2,x-i,i,z+1);\n\t\tg[z+1]=0;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tpre();\n\tdfs(n+1,m,m,0);\n\tprintf(\"%d\",(s+1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=75,mo=1e9+7;\nint n,k,_N;\nchar s[N];\nint cnt[N],a[N],mrk[N],f[N],st[N],t,sf[N];\nll Ans,jc[N*10],ny[N*10];\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}return ans;\n}\nll C(ll n,ll m){\n\treturn ny[m]*ny[n-m]%mo*jc[n]%mo;\n}\nint check(int n){\n\tif (n==0){\n\t\tAns++;\n\t\treturn 1;\n\t}\n\tmemset(mrk,0,sizeof mrk);\n\tmemset(f,0,sizeof f);\n\tmemset(sf,0,sizeof sf);\n\tif (!st[n])return 0;\n\tfor (int i=1;i<=n;i++){\n\t\tmrk[st[i]]=1;\n\t\tif (a[i]==1)break;\n\t\tfor (int j=max(st[i],f[i-1]);s[j];j++)\n\t\t\tif (s[j]=='b'){\n\t\t\t\tf[i]=j;\n\t\t\t\tmrk[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!f[i])return 0;\n\t}\n\tfor (int i=k;i>=1;i--)\n\t\tsf[i]=sf[i+1]+(!mrk[i]);\n\tint s1=0;\n\tfor (int i=n;i>=1;i--){\n\t\ts1+=max(0,a[i]-2);\n\t\tif (sf[f[i]]<s1)return 0;\n\t}\n\tll n1=1,m1=2,ans=1,sum=0;\n\tfor (int i=1;i<=_N;i++)\n\t\tsum+=cnt[i],ans=ans*ny[cnt[i]]%mo;\n\tans=ans*jc[sum]%mo;\n\tfor (int i=1;i<=n;i++)\n\t\tn1+=2*a[i],m1+=2*(a[i]>=2);\n\tans=ans*C(_N+m1-1,n1-1);\n\tAns=(Ans+ans)%mo;\n\treturn 1;\n}\nint ccnt=0;\nvoid dfs(int x,int s,int la){\n\tif (s>n+1)return;\n\tcheck(x-1);\n\tfor (int i=1;i<=la;i++){\n\t\ta[x]=i;\n\t\tcnt[i]++;\n\t\tdfs(x+1,s+max(2,2*(i-1)),i);\n\t\tcnt[i]--;\n\t}\n}\nint main(){\n\tcin>>n>>k;_N=n;\n\tjc[0]=ny[0]=1;\n\tfor (int i=1;i<=700;i++)jc[i]=jc[i-1]*i%mo;\n\tny[700]=power(jc[700]);\n\tfor (int i=700;i>=1;i--)ny[i-1]=ny[i]*i%mo;\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=k;i++){\n\t\tif (s[i]=='r')st[++t]=i;\n\t}\n\tdfs(1,0,n+1);\n\tcout<<Ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=3600;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];\n\tbool inB[N];char str[N];\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);\n\t\tg[0][0][0]=1;fo(i,1,n) fo(j,1,m) g[0][i][j]=C(i-1,j-1)*facinv[j]%MOD;\n\t\tfo(cc,1,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,m-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*( (C(ii-1,cc*2-2)+C(ii-1,cc*2-1)*2+C(ii-1,cc*2))%MOD )%MOD);\n\t\t\tfo(i,0,n) fo(j,0,m) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tll ans=0;dp[n+1][0][0][0]=1;\n\t\tfo(A,0,m)\n\t\t{\n\t\t\tint R=0;mem(inB,0);\n\t\t\tif(A) fo(i,1,m) if(str[i]=='r')\n\t\t\t{\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1,pos[++R]=j,ok=1;break;}\n\t\t\t\tif(!ok or R==A) break;//posi=被匹配的第i个蓝色\n\t\t\t}if(R<A) break;\n\t\t\t\n\t\t\tfo(B,0,m)\n\t\t\t{\n\t\t\t\tint cc=0;fo(i,1,m) if(str[i]=='r') cc++,blu[i]=blu[i-1]+(cc>A+B); else blu[i]=blu[i-1]+(!inB[i]);if(cc<A+B) break;\n\t\t\t\tfo(cnt,0,blu[m]) fo(ln,1,n) fo(st,0,A)\n\t\t\t\t{\n\t\t\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\t\t\tfo(j,1,A-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-(blu[pos[st+j]]-blu[pos[st+j-1]]))+(ln-1);\n\t\t\t\t}\n\t\t\t\tfd(ln,n,1) fo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,m) dp[ln][S][t][cnt]=0;\n\t\t\t\tfd(ln,n,1)\n\t\t\t\t{\n\t\t\t\t\tfo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,blu[m]-blu[pos[t]]) if(dp[ln+1][S][t][cnt])\n\t\t\t\t\t\tfo(j,0,A-t) if(go[cnt][ln][t][j]<=blu[m]-blu[pos[t+j]]) fo(i,0,n-S)\n\t\t\t\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],1ll*dp[ln+1][S][t][cnt]*g[ln][i][j]%MOD);\n\t\t\t\t}\n\t\t\t\tfo(S,0,n) fo(cnt,0,m) if(dp[1][S][A][cnt]) fo(S2,0,n-S) if(g[0][S2][B])\n\t\t\t\t\tadd(ans,1ll*dp[1][S][A][cnt]*g[0][S2][B]%MOD*fac[A+B]%MOD*C(n-S-S2+1,A+B)%MOD);\n\t\t\t}\n\t\t}\n\t\twrite(ans);\n\t}\n};\nsigned main()\n{\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=200;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N],after[N][2];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tbool inB[N];\n\t\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);\n\t\tint R=0,gg=0;fo(i,1,m) {\n\t\t\tblu[i]=blu[i-1];\n\t\t\tif(str[i]=='b') blu[i]+=!inB[i],after[0][0]++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tafter[0][1]++;if(gg) continue;\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1;ok=1;break;} if(!ok) {gg=1;continue;}\n\t\t\t\tpos[++R]=i;fo(j,i+1,m) after[R][str[j]=='r']+=!inB[j];\n\t\t\t}\n\t\t}\n\t\tfo(cnt,0,m) fo(ln,1,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+(ln-1);\n\t\t}\n\t\tg[0][0][0]=1;fo(i,1,n) fo(j,1,m) g[0][i][j]=C(i-1,j-1)*facinv[j]%MOD;\n\t\tfo(cc,1,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,R-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*( (C(ii-1,cc*2-2)+C(ii-1,cc*2-1)*2+C(ii-1,cc*2))%MOD )%MOD);\n\t\t\tfo(i,0,n) fo(j,0,R) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,1) fo(S,0,n) fo(A,0,R) fo(cnt,0,m) if(dp[ln+1][S][A][cnt])\n\t\t\tfo(i,0,n-S) fo(j,0,R-A) if(go[cnt][ln][A][j]<=m)\n\t\t\t\tadd(dp[ln][S+i][A+j][go[cnt][ln][A][j]],1ll*dp[ln+1][S][A][cnt]*g[ln][i][j]%MOD);\n\t\tll ans=0;\n\t\tfo(S,0,n) fo(A,0,R) fo(cnt,0,m) if(dp[1][S][A][cnt])\n\t\t\tfo(S2,0,n-S) fo(B,0,m) if(g[0][S2][B])\n\t\t\t{\n\t\t\t\tint V=1ll*dp[1][S][A][cnt]*g[0][S2][B]%MOD*fac[A+B]%MOD*C(n-S-S2+1,A+B)%MOD;\n\t\t\t\tint b=after[A][0],r=after[A][1];\n\t\t\t\tif(r>=B and b+r-B>=cnt) add(ans,V);\n\t\t\t}\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//线性预处理模意义\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nvoid ade(int& x,int y){x+=y;if(x>=mod)x-=mod;}\nint add(int x,int y){return x+y<mod?x+y:x+y-mod;}\nint qpow(int x,int k)\n{\n    int r=1;\n    while(k)\n    {\n        if(k&1)r=1ll*r*x%mod;\n        k>>=1;x=1ll*x*x%mod;\n    }\n    return r;\n}\nint C[1010][1010];\nint fac[1010],ifac[1010];\nvoid init()\n{\n    for(int i=0;i<=1000;++i)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]);\n    }\n    fac[0]=1;\n    for(int i=1;i<=1000;++i)fac[i]=1ll*fac[i-1]*i%mod;\n    ifac[1000]=qpow(fac[1000],mod-2);\n    for(int i=999;i>=0;--i)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;\n}\nint n,m;\nint tr;\nchar s[110];\nint a[110];\nbool book[77];\nbool eb[77];\nbool check(int d)\n{\n    int cr=0,crb=0;\n    for(;a[cr+1]==1&&cr+1<=d;cr++);\n    crb=d-cr;\n    memset(book,0,sizeof(book[0])*(m+3));\n    memset(eb,0,sizeof(eb[0])*(m+3));\n    int pr=0,pb=0;\n    for(int t=1;t<=crb;++t)\n    {\n        while((s[pr]!='r'||book[pr])&&pr<=m)pr++;\n        while((s[pb]!='b'||book[pb]||pb<=pr)&&pb<=m)pb++;\n        if(pr>m||pb>m)return 0;\n        book[pr]=book[pb]=1;\n        eb[pb]=1;\n    }\n    int tcr=cr;\n    for(int i=1;i<=m&&cr;++i)\n        if(!book[i]&&s[i]=='r')cr--,book[i]=1;\n    if(cr)return 0;\n    for(int i=m,p=tcr+1,cnt=0;p<=d;--i)\n    {\n        if(!book[i])cnt++;\n        if(eb[i])\n        {\n            cnt-=a[p]-2;\n            if(cnt<0)return 0;\n            p++;\n        }\n    }\n    return 1;\n}\nint ans;\nvoid calc(int d,int l)\n{\n    int s=d+1;\n    for(int i=1;i<=d;++i)\n        if(a[i]==1)s++;\n        else s+=(a[i]-1)*2+1;\n    int res=1ll*C[n-l+s-1][s-1]*fac[d]%mod;\n    for(int i=1,j;i<=d;i=j+1)\n    {\n        for(j=i;a[j+1]==a[i]&&j<d;++j);\n        res=1ll*res*ifac[j-i+1]%mod;\n    }\n    ade(ans,res);\n}\nbool dfs(int x,int la,int len,int sl)\n{\n    if(!check(x-1))return 0;\n    if(x-1>tr)return 1;\n    calc(x-1,len);\n    int nl;\n    for(int i=la;i<=m-sl;++i)\n    {\n        a[x]=i;\n        nl=len;\n        if(x!=1)nl++;\n        if(i==1)nl++;\n        else nl+=(i-1)*2-1;\n        if(nl>n)break;\n        if(!dfs(x+1,i,nl,sl+i))break;\n    }\n    return 1;\n}\nint main()\n{\n    init();\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=m;++i)tr+=(s[i]=='r');\n    dfs(1,1,0,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 75;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint fac[MAXN], inv[MAXN], invn[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nchar s[MAXN];\nint n, m, p[MAXN], q[MAXN], r[MAXN], sum[MAXN];\nunordered_map <int, int> dp[MAXN][MAXN][MAXN];\nint split(int x, int y) {\n\tif (y > x) return 0;\n\telse return binom(x - 1, y - 1);\n}\ninline int Hash(int x, int y) {\n\treturn x * MAXN + y;\n}\nint getdp(int lft, int pos, int opt, int last, int cnt) {\n\tif (pos == 0) return lft <= 1;\n\tif (last > opt + 1) return 0;\n\tif ((last + 1) * pos > lft) return 0;\n\tif (last * pos > opt + sum[pos]) return 0;\n\tif (dp[lft][pos][opt].count(Hash(last, cnt))) {\n\t\treturn dp[lft][pos][opt][Hash(last, cnt)];\n\t}\n\tint &ans = dp[lft][pos][opt][Hash(last, cnt)];\n\tans = getdp(lft, pos, opt, last + 1, 0);\n\tif (last == 0) {\n\t\tif (lft >= 2) {\n\t\t\tupdate(ans, 1ll * invn[cnt + 1] * \n\t\t\t                  getdp(lft - 2, pos - 1, opt + r[pos] + (q[pos] != 0), last, cnt + 1) % P);\n\t\t}\n\t} else if (q[pos] != 0) {\n\t\tint base = 2 * last;\n\t\tif (lft >= base) {\n\t\t\tupdate(ans, 1ll * invn[cnt + 1] *\n\t\t\t                  getdp(lft - base, pos - 1, opt + r[pos] + 1 - last, last, cnt + 1) % P);\n\t\t}\n\t\tif (lft >= base + 1) {\n\t\t\tupdate(ans, 2ll * invn[cnt + 1] *\n\t\t\t                  getdp(lft - base - 1, pos - 1, opt + r[pos] + 1 - last, last, cnt + 1) % P);\n\t\t}\n\t\tif (lft >= base + 2) {\n\t\t\tupdate(ans, 1ll * invn[cnt + 1] *\n\t\t\t                  getdp(lft - base - 2, pos - 1, opt + r[pos] + 1 - last, last, cnt + 1) % P);\n\t\t}\n\t}\n\treturn ans;\n}\nint func(int cnt) {\n\tstatic bool vis[MAXN]; int lft = 0;\n\tmemset(vis, false, sizeof(vis));\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] == 'r' && lft != cnt) {\n\t\t\tp[++lft] = i, q[lft] = 0;\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = i; j <= m; j++)\n\t\t\t\tif (!vis[j] && s[j] == 'b') {\n\t\t\t\t\tvis[j] = true;\n\t\t\t\t\tq[lft] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\tif (lft != cnt) return 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tr[i] = 0;\n\t\tfor (int j = q[i - 1] + 1; j <= q[i] - 1; j++)\n\t\t\tr[i] += !vis[j];\n\t\tsum[i] = sum[i - 1] + r[i] + vis[p[i]] + vis[q[i]];\n\t}\n\tint cmt = 0;\n\tfor (int i = m; i >= 1; i--)\n\t\tif (vis[i]) break;\n\t\telse cmt++;\n\tfor (int i = 0; i < MAXN; i++)\n\tfor (int j = 0; j < MAXN; j++)\n\tfor (int k = 0; k < MAXN; k++)\n\t\tdp[i][j][k].clear();\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tupdate(ans, 1ll * (getdp(i, cnt, cmt, 0, 0) + getdp(i + 1, cnt, cmt, 0, 0)) * split(n, i) % P);\n\treturn 1ll * ans * fac[cnt] % P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"\\n%s\", s + 1);\n\tint ans = 0;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= max(n, m); i++) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\t\tinv[i] = power(fac[i], P - 2);\n\t\tinvn[i] = power(i, P - 2);\n\t}\n\tfor (int i = 0; i <= m; i++)\n\t\tupdate(ans, func(i));\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,k,cnt; ll ans=1;\nll fac[155],inv[155],f[75],nxt[75][2],now[2],a[75],b[75];\nchar s[75];\nbool vis[75];\n\nll mod(ll x){return x>=cys?x-cys:x;}\nll C(ll x,ll y){return x<y?0:fac[x]*inv[y]%cys*inv[x-y]%cys;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nll getans(){\n\tmemset(vis,0,sizeof(vis));\n\tint pl=0,num=0;\n\tfor(int i=1;i<=cnt;i++) if(f[i]==1) num++;\n\tfor(int i=1;i<=cnt;i++){\n\t\tpl=nxt[pl][0];\n\t\tif(pl>k) return 0;\n\t\ta[i]=pl,vis[pl]=1;\n\t}\n\tfor(int i=1;i<=cnt-num;i++){\n\t\tint tmp=nxt[a[i]][1];\n\t\twhile(vis[tmp]) tmp=nxt[tmp][1];\n\t\tif(tmp>k) return 0;\n\t\tb[i]=tmp,vis[tmp]=1;\n\t}\n\tint now=cnt-num,pcnt=f[now];\n\twhile(f[now]==2) now--,pcnt=f[now];\n\tfor(int i=k;i>=1;i--){\n\t\tif(vis[i]) continue;\n\t\tif(i<b[now]) return 0;\n\t\tpcnt--;\n\t\tif(pcnt==2) now--,pcnt=f[now];\n\t\tif(!now) break;\n\t}\n\tif(pcnt>2) return 0;\n\tint rnum=num,bnum=0,wnum=cnt-1,all=n;\n\tfor(int i=1;i<=cnt-num;i++) rnum+=f[i]-2,bnum+=f[i]-1;\n\tall-=rnum+bnum+wnum;\n\tif(all<0) return 0;\n\tll res=fac[cnt],lst=1;\n\tfor(int i=1;i<=cnt;i++) if(f[i]!=f[i-1]&&i>1) res=res*inv[i-lst]%cys,lst=i;\n\tres=res*inv[cnt+1-lst]%cys;\n\treturn res*C(all+rnum+bnum+wnum+(cnt-num)*2+1,rnum+bnum+wnum+(cnt-num)*2+1)%cys;\n}\n\nvoid dfs(int now,int sum,int all,bool tp){\n\tif(all>n) return;\n\tif(!tp) ans=mod(ans+getans());\n\tif(!sum||!now) return;\n\tfor(int i=0;i<=sum/now;i++){\n\t\tdfs(min(now-1,sum-i*now),sum-i*now,all+i*(now==1?1:2*now-3),i==0?1:0);\n\t\tf[++cnt]=now;\n\t}\n\tcnt-=sum/now+1;\n}\n\nint main(){\n\tn=readint(); k=readint();\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=150;i++) fac[i]=fac[i-1]*i%cys;\n\tinv[150]=qpow(fac[150],cys-2);\n\tfor(int i=149;i>=1;i--) inv[i]=inv[i+1]*(i+1)%cys;\n\tscanf(\"%s\",s+1);\n\tnow[0]=now[1]=k+1;\n\tfor(int i=k;i>=0;i--){\n\t\tnxt[i][0]=now[0],nxt[i][1]=now[1];\n\t\tif(s[i]=='r') now[0]=i;\n\t\telse now[1]=i;\n\t}\n\tdfs(k,k,0,1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nchar s[75];int n,K,ans,a[75],p[305],inv[305];\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid Check(int num,int sum)\n{\n\tint pos=num+1,res=p[num],rnum=0,leftr=0,nxt=0,left=0;\n\tfor(int i=1;i<=K;++i)\n\t\tif(s[i]=='r') rnum<num?leftr+=(a[++rnum]>1):(left?--left:0);\n\t\telse leftr?(--leftr,left+=a[++nxt]-2):(left?--left:0);\n\tif(left||rnum<num||leftr) return;\n\tfor(int i=1,j;i<=num;i=j+1)\n\t{\n\t\tfor(j=i;j<num&&a[j+1]==a[i];++j);\n\t\tres=1LL*res*inv[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(a[i]*2-1);\n\t}\n\tans=(ans+1LL*res*C(n-sum+pos-1,pos-1))%mod;\n}\nvoid dfs(int x,int num,int sum)\n{\n\tif(sum>n) return;Check(num,sum);\n\tfor(int i=x;i;--i) a[num+1]=i,dfs(i,num+1,sum+(i>1?i*2-3:1)+(num>0));\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&K,s+1);\n\tp[0]=inv[0]=p[1]=inv[1]=1;\n\tfor(int i=2;i<=300;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=300;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod; \n\tdfs(n,0,0);cout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 107\n\nint N, K, tot, res;\nint mch[MAX_N], pos[MAX_N], sum[MAX_N];\nint fac[MAX_N * 3], ifac[MAX_N * 3];\nchar s[MAX_N];\nbool vis[MAX_N];\n\ninline int C(int x, int y) {\n    if (y < 0 || x < y) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid init() {\n    int MX = 300;\n    fac[0] = ifac[0] = 1;\n    Rep(i, MX) fac[i] = mul(fac[i - 1], i);\n    ifac[MX] = qpow(fac[MX], MOD - 2);\n    irep(i, MX, 2) ifac[i - 1] = mul(ifac[i], i);\n    Rep(i, K) if (s[i] == 'r') {\n        pos[++tot] = i;\n        rep(j, i + 1, K) if (s[j] == 'b' && !vis[j]) {\n            mch[i] = j;\n            vis[j] = true;\n            break;\n        }\n    }\n}\n\nint tp[MAX_N];\nbool check(int cur) {\n    if (cur > tot) return false;\n    Rep(i, N + 1) sum[i] = 0;\n    int p = 1;\n    IRep(i, cur) {\n        sum[pos[i]]++;\n        if (tp[p] > 1) {\n            if (!mch[pos[i]]) return false;\n            sum[mch[pos[i]]] += tp[p] - 1;\n        }\n        p++;\n    }\n    IRep(i, K) {\n        sum[i] += sum[i + 1];\n        if (sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\n\nbool dfs(int deg, int pre, int len) {\n    if (!check(deg - 1)) return false;\n    int t = deg;\n    Lep(i, deg) t += 2 * tp[i] - 1;\n    int ans = mul(C(N - len + t - 1, t - 1), fac[deg - 1]), tmp = 1;\n    Lep(i, deg) {\n        if (tp[i] != tp[i - 1]) {\n            ans = mul(ans, ifac[tmp]);\n            tmp = 0;\n        }\n        ++tmp;\n    }\n    ans = mul(ans, ifac[tmp]);\n    printf(\"%d:  \", ans);\n    Lep(i, deg) printf(\"%d \", tp[i]);\n    puts(\"\");\n    inc(res, ans);\n    if (deg > tot) return true;\n    rep(i, pre, 70) {\n        int L = len;\n        if (deg > 1) L++;\n        if (i == 1)\n            L++;\n        else\n            L += i - 2 + i - 1;\n        if (L > N) break;\n        tp[deg] = i;\n        if (!dfs(deg + 1, i, L)) break;\n    }\n    return true;\n}\n\nvoid solve() {\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n    read(N), read(K);\n    scanf(\"%s\", s + 1);\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 71 , P = 1e9 + 7 , M = 400;\ninline void pp(int &x,int d) {if((x+=d)>=P)x-=P;}\ninline int mul(int a,int b) {return ll(a)*b%P;}\nint n , K , dp[N][N] , fac[M] , ifac[M];\nstring s;\ninline int comb(int a,int b) {\n  return mul(fac[a] , mul(ifac[b] , ifac[a-b]));\n}\n\nint main() {\n  rep(i,0,M) fac[i] = i ? mul(fac[i - 1] , i) : 1;\n  rep(i,0,M) ifac[i] = i >= 2 ? P - mul(P / i , ifac[P % i]) : 1;\n  rep(i,1,M) ifac[i] = mul(ifac[i - 1] , ifac[i]);\n  cin >> n >> K >> s;\n  int ans = 0;\n  for(int a = 0;a <= K;++a)\n    for(int ab = 0;ab * 2 + a <= K;++ab) {\n      if(a == 0 && ab == 0) {\n        ans++;\n        continue;\n      }\n      int cnt_a = 0 , cnt_ab = 0;\n      vi sum(ab);\n      for(auto ch : s) {\n        if(ch == 'r') {\n          if(cnt_a + cnt_ab < a + ab)\n            cnt_a ++;\n          else if(cnt_ab)\n            sum[ab - cnt_ab]++;\n        } else {\n          if(cnt_ab < ab && cnt_a)\n            cnt_a-- , cnt_ab ++;\n          else if(cnt_ab)\n            sum[ab - cnt_ab]++;\n        }\n      }\n      if(ab != cnt_ab || a != cnt_a)\n        break;\n      rep(i,1,sz(sum)) sum[i] += sum[i-1];\n      memset(dp , 0 , sizeof(dp));\n      dp[0][0] = mul(fac[a + ab] , ifac[a]);\n      for(int add = 0;add * 2 < n;++add)\n        for(int cnt_ab = ab;cnt_ab >= 0;--cnt_ab)\n          for(int used = ab ? sum.back() : 0;used >= 0;--used) if(dp[cnt_ab][used]) {\n            for(int add_ab = 1;cnt_ab + add_ab <= ab &&\n                used + add * add_ab <= sum[cnt_ab + add_ab - 1];++add_ab) {\n              pp(dp[cnt_ab + add_ab][used + add * add_ab] , mul(dp[cnt_ab][used] , ifac[add_ab]));\n            }\n          }\n      rep(used,0,(ab ? sum.back() : 0) + 1) {\n        int need = (ab + used * 2 + a) + (ab + a - 1);\n        int remain = n - need;\n        if(remain < 0)\n          continue;\n        int position = (ab * 3 + used * 2 + a) + (ab + a + 1);\n        pp(ans , mul(dp[ab][used] , comb(remain + position - 1 , remain)));\n      }\n    }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nconst int mod = 1'000'000'007;\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nint mul(int a, int b) {\n  return (int)((long long)a * b % mod);\n}\n\nint pw(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b % 2 == 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b /= 2;\n  }\n  return res;\n}\n\nint inv(int a) {\n  return pw(a, mod - 2);\n}\n\nconst int N = 79;\n\nchar t[N];\nint fact[N];\nint rfact[N];\nint c[2 * N][2 * N];\nint cnt_r[N];\nint f[N][N][N];\nint nf[N][N][N];\n\nint main() {\n  fact[0] = 1;\n  rfact[0] = 1;\n  for (int i = 1; i < N; ++i) {\n    fact[i] = mul(fact[i - 1], i);\n    rfact[i] = inv(fact[i]);\n  }\n  memset(c, 0, sizeof c);\n  for (int i = 0; i < 2 * N; ++i) {\n    c[i][0] = 1;\n    c[i][i] = 1;\n    for (int j = 1; j < i; ++j) {\n      c[i][j] = c[i - 1][j - 1];\n      add(c[i][j], c[i - 1][j]);\n    }\n  }\n  int n, m;\n  scanf(\"%d %d %s\", &n, &m, t);\n  vector<int> need, size;\n  need.push_back(1);\n  size.push_back(1);\n  need.push_back(1);\n  size.push_back(2);\n  need.push_back(1);\n  size.push_back(2);\n  need.push_back(1);\n  size.push_back(3);\n  need.push_back(2);\n  size.push_back(3);\n  for (int i = 4; i <= n; ++i) {\n    need.push_back(i / 2);\n    size.push_back(i);\n    \n    need.push_back((i + 1) / 2);\n    size.push_back(i);\n  }\n  vector<int> pr;\n  for (int i = 0; i < m; ++i) {\n    if (t[i] == 'r') {\n      pr.push_back(i);\n    }\n  }\n  vector<int> pb;\n  if (!pr.empty()) {\n    for (int i = pr[0] + 1; i < m; ++i) {\n      if (t[i] == 'b') {\n        pb.push_back(i);\n        break;\n      }\n    }\n    if (pb.empty()) {\n      pb.push_back(m);\n    }\n  }\n  for (int i = 1; i < (int)pr.size(); ++i) {\n    for (int j = max(pr[i], pb[i - 1]) + 1; j < m; ++j) {\n      if (t[j] == 'b') {\n        pb.push_back(j);\n        break;\n      }\n    }\n    if ((int)pb.size() < i + 1) {\n      pb.push_back(m);\n    }\n  }\n  int ans = 1;\n  for (int cnt = 1; cnt <= min(35, (int)pr.size()); ++cnt) {\n    memset(cnt_r, 0, sizeof cnt_r);\n    for (int i = 0; i < cnt; ++i) {\n      cnt_r[pr[i]] = 1;\n    }\n    for (int i = m - 2; i >= 0; --i) {\n      cnt_r[i] += cnt_r[i + 1];\n    }\n    memset(f, 0, sizeof f);\n    for (int i = 0; i <= cnt; ++i) {\n      f[i][0][i] = rfact[i];\n    }\n    for (int it = 0; it < (int)need.size(); ++it) {\n      for (int i = 0; i <= cnt; ++i) {\n        for (int j = 0; j <= m; ++j) {\n          for (int s = 0; s <= n; ++s) {\n            nf[i][j][s] = f[i][j][s];\n          }\n        }\n      }\n      for (int i = 0; i <= cnt; ++i) {\n        for (int j = 0; j <= m; ++j) {\n          for (int s = 0; s <= n; ++s) {\n            if (f[i][j][s] == 0) {\n              continue;\n            }\n            for (int k = 1; k <= n; ++k) {\n              int ni = i + k;\n              int nj = j + need[it] * k;\n              int ns = s + size[it] * k;\n              if (ni >= cnt + 1 || nj >= m + 1 || ns >= n + 1) {\n                break;\n              }\n              int pos = pb[cnt - 1 - (ni - 1)];\n              if (pos == m) {\n                break;\n              }\n              if ((m - pos) - j - need[it] * (k - 1) - cnt_r[pos] < need[it]) {\n                break;\n              }\n              add(nf[ni][nj][ns], mul(f[i][j][s], rfact[k]));\n            }\n          }\n        }\n      }\n      for (int i = 0; i <= cnt; ++i) {\n        for (int j = 0; j <= m; ++j) {\n          for (int s = 0; s <= n; ++s) {\n            f[i][j][s] = nf[i][j][s];\n          }\n        }\n      }\n    }\n    for (int j = 0; j <= m; ++j) {\n      for (int s = 0; s <= n; ++s) {\n        if (n - s >= cnt - 1) {\n          add(ans, mul(f[cnt][j][s], mul(fact[cnt], c[(n - s - (cnt - 1)) + (s + (cnt - 1) + 2) - 1][(s + (cnt - 1) + 2) - 1])));\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 200;\nchar c[maxN];\nint n, k;\nint sz = 0;\nint red[maxN];\nint blue[maxN];\nint r = 1;\nint cnt1[3 * maxN];\nint cnt2[3 * maxN];\nint ans = 0;\nint LIM;\nint F = 0;\nint mark[maxN];\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint fact[2 * maxN];\nint invfact[2 * maxN];\nint inv[2 * maxN];\nint cnk(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return mult(fact[n], mult(invfact[n - k], invfact[k]));\n}\nbool check() {\n    memset(mark, -1, sizeof mark);\n    int ptr = 0;\n    int f = k;\n    while (ptr < sz && blue[ptr] == 0) {\n        if (f == 0) return false;\n        if (c[f] == 'b') {\n            f--;\n        }\n        else {\n            mark[f] = 1;\n            f--;\n            ptr++;\n        }\n    }\n    ptr--;\n    //[0 .. ptr] - ok\n    //\n    int ptrR = sz - 1;\n    int ptrB = sz - 1;\n    for (int i = 1; i <= k; i++) {\n        if (mark[i] != -1) continue;\n        if (c[i] == 'r' && ptrR > ptr) {\n            ptrR--;\n            mark[i] = 1;\n        }\n        if (c[i] == 'b' && ptrB > ptrR) {\n            ptrB--;\n            mark[i] = 1;\n        }\n    }\n    if (ptrR != ptr || ptrB != ptr) return false;\n    int where = sz - 1;\n    int need = red[sz - 1];\n    for (int i = 1; i <= k; i++) {\n        if (need == 0) return true;\n        if (mark[i] == 1) continue;\n        if (where > ptr) {\n            need--;\n            if (need == 0) {\n                where--;\n                need = red[where];\n            }\n        }\n    }\n    return (need == 0 || where == ptr);\n}\nint his_cnt[maxN];\nvoid calc() {\n    if (!check()) {\n        return;\n    }\n\n    int val = fact[sz];\n    memset(his_cnt, 0, sizeof his_cnt);\n    int groups = 0;\n    int other = 0;\n    for (int i = 0; i < sz; i++) {\n        his_cnt[blue[i]]++;\n        val = mult(val, inv[his_cnt[blue[i]]]);\n        groups += blue[i] + red[i];\n        if (blue[i]) other++;\n    }\n    //so we have\n    // x_1 + ... + x_groups + y_1 + .. + y_2*other + c_1 + c_2 + p_1 + ... + p_(sz - 1) = n\n    // groups + 2 * other + sz - 1 + 2\n    int all_gr = groups + 2 * other + sz - 1 + 2;\n    ans = sum(ans, mult(val, cnk(n + all_gr - 1 - groups - (sz - 1), all_gr - 1)));\n}\nvoid gen(int pos, int total) {\n    if (total + sz - 1 > n) return;\n    if (sz > LIM) return;\n    if (pos == r) {\n        F++;\n        calc();\n        return;\n    }\n    gen(pos + 1, total);\n    if (pos == 0) {\n        red[sz] = 1;\n        blue[sz] = 0;\n        sz++;\n        gen(pos, total + 1);\n        sz--;\n    }\n    else {\n        red[sz] = cnt1[pos];\n        blue[sz] = cnt2[pos];\n        sz++;\n        gen(pos, total + red[sz - 1] + blue[sz - 1]);\n        sz--;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n    for (int i = 2; i < 2 * maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n\n    cin >> n >> k;\n    for (int i = 1; i <= k; i++) cin >> c[i];\n    LIM = (n + 1) / 2;\n    for (int d = 1; d <= n; d++) {\n        cnt1[r] = d - 1;\n        cnt2[r] = d;\n        r++;\n    }\n    gen(0, 0);\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint C[310][310],jc[310],jcv[310];\nint n,k,ans;\nchar s[100];\nint p[100],pos[100];\nbool used[100];\nint CNT;\nvoid calc(int m)\n{\n\t++CNT;\n//\tprintf(\"%d:\",m);\n//\tfor(int i=1;i<=m;++i)printf(\"%d \",p[i]);printf(\"\\n\");\n\tmemset(used+1,0,n);\n\tfor(int i=1,last=1;i<=m;++i)\n\t{\n\t\twhile(last<=k&&s[last]!='r')++last;\n\t\tif(last>k)return;\n\t\tpos[i]=last;used[last]=1;++last;\n\t}\n\tfor(int i=1,last=1;i<=m;++i)\n\t\tif(p[i]>=2)\n\t\t{\n\t\t\tif(last<=pos[i])last=pos[i]+1;\n\t\t\twhile(last<=k&&s[last]!='b')++last;\n\t\t\tif(last>k)return;\n\t\t\tpos[i]=last;used[last]=1;++last;\n\t\t}\n\tfor(int i=1,last=1;i<=m;++i)\n\t\tif(p[i]>2)\n\t\t{\n\t\t\tif(last<=pos[i])last=pos[i]+1;\n\t\t\tint d=p[i]-2;\n\t\t\twhile(d)\n\t\t\t{\n\t\t\t\twhile(last<=k&&used[last])++last;\n\t\t\t\tif(last>k)return;\n\t\t\t\t--d;++last;\n\t\t\t}\t\t\t\n\t\t}\n\tint res=jc[m],up=n-m+1,dn=m+1;\n\tfor(int i=1,r;i<=m;i=r+1)\n\t{\n\t\tr=i;\n\t\twhile(r<m&&p[r+1]==p[i])++r;\n\t\tres=1ll*res*jcv[r-i+1]%mod;\n\t}\n\tfor(int i=1;i<=m;++i)up-=p[i]==1?1:2*p[i]-3,dn+=2*p[i]-1;\n\tres=1ll*res*C[up+dn-1][dn-1]%mod;\n\tadd(ans,res);\n//\tprintf(\"%d:\",m);\n//\tfor(int i=1;i<=m;++i)printf(\"%d \",p[i]);printf(\"\\n\");\n//\tprintf(\"%d %d %d\\n\",up,dn,res);\n}\nvoid dfs(int w,int res,int last,int sum)\n{\n\tcalc(w-1);\n//\tprintf(\"%d %d %d\\n\",w,res,last);\n\tif(!res)return;\n\tfor(int i=min(last,res);i;--i)\n\t\tif(sum+1+(i==1?1:2*i-3)<=n)p[w]=i,dfs(w+1,res-i,i,sum+1+(i==1?1:2*i-3));\n}\nint main()\n{\n\tfor(int i=0;i<=300;++i)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;++j)C[i][j]=pl(C[i-1][j-1],C[i-1][j]);\n\t}\n\tjc[0]=1;\n\tfor(int i=1;i<=300;++i)jc[i]=1ll*jc[i-1]*i%mod;\n\tjcv[300]=kpow(jc[300],mod-2);\n\tfor(int i=300;i;--i)jcv[i-1]=1ll*jcv[i]*i%mod;\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tdfs(1,k,k,-1);\n\tprintf(\"%d\",ans);\n//\tprintf(\"\\n%d\",CNT);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define add(a,b) a=((a)+(b))%1000000007\n#define mod 1000000007\n#define Mod 1000000005\n#define ll long long\n#define N 1000\n//#define file\nusing namespace std;\n\nll f[71][71][71],g[71][71][71],jc[N+1],Jc[N+1],ans;\nint d[71],n,m,i,j,k,l,x,y;\nchar a[71];\nbool bz[71];\n\nll qpower(ll a,int b) {ll ans=1; while (b) {if (b&1) ans=ans*a%mod;a=a*a%mod;b>>=1;} return ans;};\nll C(int n,int m) {if (n<m) return 0;return jc[n]*Jc[m]%mod*Jc[n-m]%mod;}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc089F.in\",\"r\",stdin);\n\t#endif\n\t\n\tjc[0]=1;\n\tfo(i,1,N) jc[i]=jc[i-1]*i%mod;\n\tJc[N]=qpower(jc[N],Mod);\n\tfd(i,N-1,0) Jc[i]=Jc[i+1]*(i+1)%mod;\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",a+1);\n\tans=1;\n\tfo(x,0,n)\n\t{\n\t\tfo(y,0,n)\n\t\tif (x || y)\n\t\t{\n\t\t\tmemset(bz,0,sizeof(bz));\n\t\t\tfo(i,1,x)\n\t\t\t{\n\t\t\t\tfo(j,1,m) if (!bz[j] && a[j]=='r') break;\n\t\t\t\tfo(k,j,m) if (!bz[k] && a[k]=='b') break;\n\t\t\t\tif (k>m) break;\n\t\t\t\tbz[j]=bz[k]=1;\n\t\t\t}\n\t\t\tif (k>m) continue;\n\t\t\tl=0;\n\t\t\tfo(i,1,m) if (l<y && !bz[i] && a[i]=='r') ++l,bz[i]=1;\n\t\t\tif (l<y) continue;\n\t\t\t\n\t\t\tl=0;\n\t\t\tfo(j,1,m)\n\t\t\tif (bz[j] && a[j]=='b')\n\t\t\t{\n\t\t\t\td[++l]=0;\n\t\t\t\tfo(k,j,m) d[l]+=!bz[k];\n\t\t\t}\n\t\t\t\n\t\t\tmemset(f,0,sizeof(f)),f[0][0][d[1]]=1;\n\t\t\tfo(i,0,x-1)\n\t\t\t{\n\t\t\t\tfo(j,0,d[1])\n\t\t\t\t{\n\t\t\t\t\tfd(k,d[1],0)\n\t\t\t\t\tif (f[i][j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k>=1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tadd(f[i][j][k-1],f[i][j][k]);\n\t\t\t\t\t\t\tfo(l,1,x-i)\n\t\t\t\t\t\t\tif (j+l*k<=d[1] && k<=d[i+l])\n\t\t\t\t\t\t\tadd(f[i+l][j+l*k][k-1],f[i][j][k]*C(i+l+y,l));\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\tadd(f[x][j][k],f[i][j][k]*C(x+y,x-i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfo(j,0,d[1])\n\t\t\t{\n\t\t\t\tfo(k,0,d[1])\n\t\t\t\t{\n\t\t\t\t\tfo(l,0,n)\n\t\t\t\t\tadd(ans,f[x][j][k]*C(l+(y+2*j+x*3)-1,(y+2*j+x*3)-1)%mod*C(n-(x+y-1)-2*j-l,x+y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint fac[150], ifac[150], ans, n, k;\nbool del[75];\nvector<int> f, r;\nchar s[75];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nbool check() {\n\tfill(del + 1, del + 1 + k, false);\n\tfor (int i = 0; i < f.size(); ++i) del[r[i]] = true;\n\tvector<int> b(f.size());\n\tfor (int i = 0; i < f.size(); ++i)\n\t\tif (f[i] >= 2) {\n\t\t\tint j;\n\t\t\tfor (j = r[f.size() - 1 - i] + 1; (del[j] || s[j] == 'r') && j <= k; ++j);\n\t\t\tif (j > k) return false;\n\t\t\tb[i] = j;\n\t\t\tdel[j] = true;\n\t\t}\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 3) {\n\t\t\tint cnt = f[i] - 2;\n\t\t\tfor (int j = b[i] + 1; cnt && j <= k; ++j)\n\t\t\t\tif (!del[j]) del[j] = true, --cnt;\n\t\t\tif (cnt) return false;\n\t\t}\n\treturn true;\n}\n\nvoid dfs(int lst, int sum) {\n\tif (f.size() > r.size()) return;\n\tif (check()) {\n\t\tint s = n + 1, c = fac[f.size()], s1 = 0;\n\t\tfor (int i = 0, j; i < f.size(); i = j) {\n\t\t\tfor (j = i + 1; j < f.size() && f[j] == f[i]; ++j);\n\t\t\tc = 1ll * c * ifac[j - i] % P;\n\t\t\tif (f[i] > 1) s += 2 * (j - i);\n\t\t\ts1 += 2 * f[i] * (j - i);\n\t\t}\n\t\tans = (ans + 1ll * c * fac[s] % P * ifac[s1] % P * ifac[s - s1]) % P;\n\t}\n\tfor (int i = lst; (sum + max(1, i - 1)) * 2 <= n + 1; ++i) f.push_back(i), dfs(i, sum + max(1, i - 1)), f.pop_back();\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &k, s + 1);\n\tfor (int i = 1; i <= k; ++i)\n\t\tif (s[i] == 'r') r.push_back(i);\n\tfor (int i = fac[0] = 1; i <= 2 * n + 5; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[2 * n + 5] = power(fac[2 * n + 5], P - 2);\n\tfor (int i = 2 * n + 5; i; --i) ifac[i - 1] = 1ll * ifac[i] * i % P;\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint fac[142], ifac[142], ans, n, k;\nbool del[75];\nvector<int> f, r;\nchar s[75];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nbool check() {\n\tfill(del + 1, del + 1 + k, false);\n\tfor (int i = 0; i < f.size(); ++i) del[r[i]] = true;\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 2) {\n\t\t\tint j;\n\t\t\tfor (j = r[f.size() - 1 - i] + 1; (del[j] || s[j] == 'r') && j <= k; ++j);\n\t\t\tif (j > k) return false;\n\t\t\tdel[j] = true;\n\t\t}\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 3) {\n\t\t\tint cnt = f[i] - 2;\n\t\t\tfor (int j = r[f.size() - 1 - i] + 1; cnt && j <= k; ++j)\n\t\t\t\tif (!del[j]) del[j] = true, --cnt;\n\t\t\tif (cnt) return false;\n\t\t}\n\treturn true;\n}\n\nvoid dfs(int lst, int sum) {\n\tif (f.size() > r.size()) return;\n\tif (check()) {\n\t\tint s = n + 1, c = fac[f.size()], s1 = 0;\n\t\tfor (int i = 0, j; i < f.size(); i = j) {\n\t\t\tfor (j = i + 1; j < f.size() && f[j] == f[i]; ++j);\n\t\t\tc = 1ll * c * ifac[j - i] % P;\n\t\t\tif (f[i] > 1) s += 2 * (j - i);\n\t\t\ts1 += 2 * f[i] * (j - i);\n\t\t}\n\t\tans = (ans + 1ll * c * fac[s] % P * ifac[s1] % P * ifac[s - s1]) % P;\n\t}\n\tfor (int i = lst; (sum + max(1, i - 1)) * 2 <= n + 1; ++i) f.push_back(i), dfs(i, sum + max(1, i - 1)), f.pop_back();\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &k, s + 1);\n\tfor (int i = 1, j = 1; i <= k; ++i)\n\t\tif (s[i] == 'r') r.push_back(i);\n\tfor (int i = fac[0] = 1; i <= 2 * n + 2; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[2 * n + 2] = power(fac[2 * n + 2], P - 2);\n\tfor (int i = 2 * n + 2; i; --i) ifac[i - 1] = 1ll * ifac[i] * i % P;\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 150\n#define p 1000000007\n#define ll long long\nint a[N],b[N],c[N],d[N],e[N],m,n,x,y;char s[N];bool t[N];\ninline bool solve(int z)\n{\n    int i,j,k;\n    for(i=1;i<=m;i++)t[i]=false;\n    for(i=j=1;i<=y;d[i]=c[i]<2?0:c[i]-2,i++)i==y||c[i]!=c[i+1]?z=(ll)b[i-j+1]*z%p,j=i+1:0;\n    for(i=1,j=k=y;i<=m;i++)\n    if(s[i]=='r'&&c[j]>1)t[i]=true,j--;\n    else if(s[i]=='b'&&j<k&&c[k]>1)t[e[k--]=i]=true;\n    else if(s[i]=='r'&&c[j]==1)t[e[j--]=i]=true;\n    if(j||c[k]>1)return false;\n    for(i=1,j=y;i<=m&&j;!t[i]&&e[j]<i?d[j]--:0,i++)while(j&&!d[j])j--;\n    while(j&&!d[j])j--;\n    if(j)return false;\n    return x=(x+(ll)z*a[y])%p,true;\n}\nvoid dfs(int u,int v,int w){if(solve((ll)a[v]*b[w]%p*b[v-w]%p))for(int i=u;0<=v-w-(i==1?2:i-1<<1);i++)dfs(c[++y]=i,v+(i==1?0:2),w+(i<<1)),y--;}\nint main()\n{\n    scanf(\"%d%d%s\",&n,&m,s+1),*a=a[1]=*b=b[1]=1;\n    for(int i=2;i<=(n<<1|1);i++)a[i]=(ll)a[i-1]*i%p,b[i]=(ll)(p-p/i)*b[p%i]%p;\n    for(int i=2;i<=(n<<1|1);i++)b[i]=(ll)b[i]*b[i-1]%p;\n    dfs(1,n+1,0),printf(\"%d\\n\",x);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 200\nchar s[MN+5];\nmint F[MN+5],R[MN+5],ans;\nint n,a[MN+5],an,b[MN+5],bn,u[MN+5],p[MN+5];\ninline mint C(int n,int m){return F[n]*R[m]*R[n-m];}\nvoid dfs(int x,int y,int z,int s0)\n{\n\tint i,j,k;\n\tmemset(u,0,sizeof(u));\n\tfor(i=j=1;i<z;++i)if(p[z-i])\n\t{\n\t\twhile(j<=bn&&b[j]<a[i])++j;\n\t\tif(j>bn)break;\n\t\tu[a[i]]=u[b[j++]]=1;\n\t}\n\tif(i==z)for(i=j=1;i<z;++i)\n\t{\n\t\tfor(k=1;k<p[z-i];++k)\n\t\t{\n\t\t\twhile(s[j]&&(j<i||u[j]))++j;\n\t\t\tif(!s[j++])break;\n\t\t}\n\t\tif(k<p[z-i])break;\n\t}\n\tif(i==z)\n\t{\n\t\tmint s=F[z-1];\n\t\tfor(i=1;i<z;s*=R[j-i],i=j)for(j=i;j<z&&p[i]==p[j];++j);\n\t\tif(2*(z-1+x)>n+2*(z-1-s0)||n+2*(z-1-s0)>140)while(true);\n\t\tans+=s*C(n+2*(z-1-s0),2*(z-1+x));\n\t}\n\tif(z<=an)for(;x+y<=an+bn-z&&x+y+s0+!y<=n/2;++y)dfs(x+y,p[z]=y,z+1,s0+!y);\n}\nint main()\n{\n\tint m,i;\n\tscanf(\"%d%d%s\",&n,&m,s+1);++n;\n\tfor(F[0]=i=1;i<=MN;++i)F[i]=F[i-1]*i;\n\tfor(R[i=MN]=~F[MN];i--;)R[i]=R[i+1]*(i+1);\n\tfor(i=1;i<=m;++i)(s[i]=='r'?a[++an]:b[++bn])=i;\n\tdfs(0,0,1,0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define maxn 1005\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\nll ans;\nint n, k;\nchar s[maxn];\nint f[maxn];\nll c[maxn][maxn], fac[maxn], inv[maxn];\n\nll quickpow(ll p, ll k)\n{\n\tll res = 1;\n\twhile (k)\n\t{\n\t\tif (k & 1)\n\t\t\tres = (res * p) % mod;\n\t\tp = (p * p) % mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\nvoid check(int len, int low)\n{\n\tint cnt1 = 0, cnt2 = 0, temp1 = 0, temp2 = 0;\n\tfor (int i = 1; i <= k; i++)\n\t{\n\t\tif (s[i] == 'r' && cnt1 < len)\n\t\t{\n\t\t\tcnt1++;\n\t\t\ttemp1 += (f[cnt1] != 1);\n\t\t}\n\t\telse if (s[i] == 'b' && temp1)\n\t\t{\n\t\t\ttemp1--;\n\t\t\tcnt2++;\n\t\t\ttemp2 += (f[cnt2] - 2);\n\t\t}\n\t\telse if (temp2)\n\t\t\ttemp2--;\n\t}\n\n\tif (cnt1 < len || temp1 || temp2) return;\n\n\n\tll res = fac[len];\n\tfor (int i = 1; i <= len; i++)\n\t{\n\t\tint j = i;\n\t\twhile (f[j + 1] == f[i] && j < len) j++;\n\t\tres = (res * inv[j - i + 1]) % mod;\n\t\ti = j;\n\t}\n\tll sz = len + 1;\n\tfor (int i = 1; i <= len; i++) sz += (f[i] * 2 - 1);\n\n\tans += (res * c[n - low + sz - 1][sz - 1]) % mod;\n\tans %= mod;\n}\nvoid dfs(int now, int len, int low)\n{\n\tif (low > n) return;\n\tcheck(len - 1, low);\n\tfor (int i = now; i >= 1; i--)\n\t{\n\t\tf[len] = i;\n\t\tdfs(i, len + 1, low + (max(2 * i - 3, 1)) + (len != 1));\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%s\", &n, &k, s + 1);\n\tfor (int i = 0; i <= 300; i++)\n\t{\n\t\tc[i][0] = c[i][i] = 1;\n\t\tfor (int j = 1; j <= i - 1; j++)\n\t\t\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;\n\t}\n\tinv[0] = fac[0] = 1;\n\tfor (int i = 1; i <= 300; i++)\n\t\tfac[i] = (fac[i - 1] * i) % mod, inv[i] = (quickpow(fac[i], mod - 2));\n\tdfs(70, 1, 0);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=75;\nint C[N*5][N*5];\nint n,k,ans,used[N];\nint q1[N],q2[N],suf[N];\nint f[N][N];\nchar s[N];\nvoid init(){\n\tFor(i,0,N*5-1) C[i][0]=1;\n\tFor(i,1,N*5-1) For(j,1,i)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;\n}\nvoid solve(int S1,int S2){\n\tif (!S1&&!S2) return ++ans,void(0);\n\tif ((S1+S2)*2>n+1||S1+2*S2>k) return; \n\tmemset(used,0,sizeof(used));\n\tint h=0,t=*q2=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r') q1[++t]=i;\n\t\telse if (s[i]=='b'&&h!=t&&*q2!=S2)\n\t\t\tused[q1[++h]]=used[i]=1,q2[++*q2]=i;\n\tif (*q2!=S2) return;\n\tFor(i,1,S1)\n\t\tif (h==t) return;\n\t\telse used[q1[++h]]=1;\n\tRep(i,k,1) suf[i]=suf[i+1]+(!used[i]);\n\tFor(i,1,S2) q2[i]=suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tint upp=max(2,n);\n\tFor(i,2,upp) Rep(j,S2-1,0) For(k,0,upp-(S2-j)*i){\n\t\tint psum=k-2*j;\n\t\tFor(l,1,min(S2-j,(upp-k)/i)){\n\t\t\tif ((psum+=i-2)>suf[S2-j-l+1]) break;\n\t\t\tf[j+l][k+i*l]=(f[j+l][k+i*l]+1ll*C[j+l][l]*f[j][k])%mo;\n\t\t}\n\t}\n\tFor(k,0,upp){\n\t\tint sum=2*S1+2*k-2*S2-1;\n\t\tint par=2*S1+1+2*k;\n\t\tif (sum&&sum<=n&&f[S2][k])\n\t\t\tans=(ans+1ll*f[S2][k]*C[n-sum+par-1][par-1]%mo*C[S2+S1][S2])%mo;\n\t}\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tFor(S1,0,n) For(S2,0,n) solve(S1,S2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 210\n#define mo 1000000007 \nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char ch=getchar();int fh=1;\n\twhile (ch<'0'||ch>'9'){if (ch=='-')fh=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\tx*=fh;\n}\nint m,n,a[N],f[N],nb,b[N],c[N];\nll jie[N],nj[N],ans;\nll po(ll x,ll y){ll z=1;while (y){if (y%2)z=x*z%mo;x=x*x%mo;y/=2;}return z;}\nll C(int x,int y){return (jie[x]*nj[y]%mo)*nj[x-y]%mo;}\nvoid chk(){\n\tnb=0;memset(b,0,sizeof(b));\n\tfor (int i=(n+1)/2;i>=0;i--)\n\t\tfor (int j=1;j<=f[i];j++)b[++nb]=i;\n\tfor (int i=1,n0=0,n1=0;i<=m;i++){\n\t\tc[i]=0;\n\t\tif (a[i]==0){n0++;if (n0<=nb)c[i]=n0;\n\t\t}else if (n1<n0){n1++;if (b[n1])c[i]=n1;}\n\t\tif (i==m&&(n0<nb||b[n1+1]))return ;\n\t}\n\tfor (int i=1,ne=0;i<=m;i++){\n\t\tif (!c[i])ne=max(0,ne-1);\n\t\telse if (a[i])ne+=b[c[i]]-1;\n\t\tif (i==m&&ne) return ;\n\t}\n\tll x1=1,n0=2,n1=nb-1;\n\tif (nb==0) n0--,n1++;\n\tfor (int i=1;i<=nb;i++)if (b[i])n0+=2,n1+=b[i]*2-1;else n1++;\n\tfor (int i=0;i<=(n+1)/2;i++){x1=x1*C(nb,f[i])%mo;nb-=f[i];}\n\tans=(ans+x1*C(n+n0-1,n0+n1-1))%mo;\n}\nvoid fen(int x,int no){\n\tint ne=max(2,no*2);\n\tif (no>n+1)chk();\n\telse for (int i=0;i<=x/ne;i++){f[no]=i;fen(x-i*ne,no+1);}\n}\nint main(){\n\tread(n);read(m);\n\tjie[0]=1;for (int i=1;i<=200;i++)jie[i]=jie[i-1]*i%mo;\n\tnj[200]=po(jie[200],mo-2);for (int i=199;i>=0;i--)nj[i]=nj[i+1]*(i+1)%mo;\n\tfor (int i=1;i<=m;i++){char ch=getchar();while (ch!='b'&&ch!='r')ch=getchar();a[i]=(ch=='b');}\n\tfen(n+1,0);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(p + 2*g > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(int len) {\n    int pos1 = 0, pos2 = 0;\n    for(int i = 0; i < len; i++) {\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        pos1++;\n        pos2++;\n    }\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + f.size() + f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        int len = 0;\n        for(int i = 0; i < f.size(); i++) {\n            if(f[i] != 0) len++;\n        }\n\n        if(chk(len)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n#define N 75\n#define ll long long\n#define mo 1000000007\nll qpow(ll x,ll y=mo-2){\n\tll r=1;\n\tfor (;y;y>>=1,x=x*x%mo)\n\t\tif (y&1)\n\t\t\tr=r*x%mo;\n\treturn r;\n}\nll fac[N*4],ifac[N*4];\nvoid initC(int n){\n\tfac[0]=1;\n\tfor (int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%mo;\n\tifac[n]=qpow(fac[n]);\n\tfor (int i=n-1;i>=0;--i)\n\t\tifac[i]=ifac[i+1]*(i+1)%mo;\n}\nll inv(int n){return ifac[n]*fac[n-1]%mo;}\nll C(int m,int n){\n\tif (m<n) return 0;\n\treturn fac[m]*ifac[n]%mo*ifac[m-n]%mo;\n}\nint n,K;\nchar str[N];\nint p[N],m;\nll ans;\nbool judge(){\n\tstatic int q[N],need[N];\n\tstatic int used[N];\n\tint head=1,tail=0;\n\tmemset(used,255,sizeof(int)*(K+1));\n\tint i=1,j=1;\n\tfor (;j<=K && i<=m && p[i]>1;++j){\n\t\tif (head<=tail && str[j]=='b')\n\t\t\tused[j]=p[i++]-2,used[q[head++]]=0;\n\t\telse if (str[j]=='r')\n\t\t\tq[++tail]=j;\n\t}\n\tif (i<=m && p[i]>1) return 0;\n\tfor (;j<=K;++j)\n\t\tif (str[j]=='r')\n\t\t\tq[++tail]=j;\n\tfor (;i<=m;++i){\n\t\tif (head>tail) return 0;\n\t\tused[q[head++]]=0;\n\t}\n\tint cnt=0;\n\tfor (int j=K;j>=1;--j){\n\t\tif (used[j]==-1)\n\t\t\tcnt++;\n\t\telse if (used[j]>0){\n\t\t\tif (cnt<used[j]) return 0;\n\t\t\tcnt-=used[j];\n\t\t}\n\t}\n\treturn 1;\n}\nll calc(){\n//\tfor (int i=1;i<=m;++i)\n//\t\tprintf(\"%d \",p[i]);\n//\tprintf(\"\\n\");\n\tif (m==0) return 1;\n\tp[m+1]=-1;\n\tll s=fac[m];\n\tfor (int i=1,j=0;i<=m;++i){\n\t\tj++;\n\t\tif (p[i]!=p[i+1]){\n\t\t\ts=s*ifac[j]%mo;\n\t\t\tj=0;\n\t\t}\n\t}\n\tll c0=2,c1=m-1;\n\tfor (int i=1;i<=m;++i){\n\t\tif (p[i]==1)\n\t\t\tc1++;\n\t\telse{\n\t\t\tc1+=2*p[i]-3;\n\t\t\tc0+=2;\n\t\t}\n\t}\n\ts=s*C((n-c1)+(c1+c0)-1,n-c1)%mo;\n//\tprintf(\"ans=%lld\\n\",s);\n\treturn s;\n}\nvoid dfs(int s,int k){\n\tif (judge())\n\t\tans+=calc();\n\tif (s==0)\n\t\treturn;\n\tfor (int i=k;i>=1;--i){\n\t\tif (s>=2*i-1+(s!=n)){\n\t\t\tp[++m]=i+1;\n\t\t\tdfs(s-(2*i-1)-(s!=n),i);\n\t\t\t--m;\n\t\t}\n\t}\n\tif (s>=2){\n\t\tp[++m]=1;\n\t\tdfs(s-2,0);\n\t\t--m;\n\t}\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&K,str+1);\n\tinitC(n*4);\n\tdfs(n,n);\n\tans%=mo;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=1e9+7;\nconst int maxn=210;\nlong long fac[maxn],inv[maxn];\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nchar str[maxn];\nint stk[maxn],top;\nint n,m;\nbool check(int x){\n\tstatic bool vis[maxn];\n\tstatic int ps[maxn];\n\tfor(int i=1;i<=m;i++)\n\t\tvis[i]=0;\n\tint p=0,cnt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(cnt>=top) break;\n\t\tif(str[i]=='r'){\n\t\t\tif(p<i) p=i;\n\t\t\twhile(p<=m&&(vis[p]||str[p]=='r'))\n\t\t\t\tp++;\n\t\t\tif(p>m) return 0;\n\t\t\tcnt++;\n\t\t\tps[cnt]=p;\n\t\t\tvis[i]=vis[p]=1;\n\t\t}\n\t}\n\tif(cnt!=top) return 0;\n\tcnt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(cnt>=x) break;\n\t\tif(str[i]=='r'&&!vis[i]){\n\t\t\tvis[i]=1;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt!=x) return 0;\n\tp=m;\n\tfor(int i=top;i>=1;i--){\n\t\tcnt=0;\n\t\twhile(p>=ps[i]&&cnt<stk[i]/2){\n\t\t\tif(!vis[p]) cnt++;\n\t\t\tp--;\n\t\t}\n\t\tif(cnt!=stk[i]/2) return 0;\n\t}\n\treturn 1;\n}\nlong long sum[maxn][maxn];\nvoid solve(int res,long long val,int num){\n\tlong long fas;\n\tint tot=0;\n\tfor(int i=1;i<=top;i++) tot+=stk[i];\n\tfor(int i=0;i<=res;i++){\n\t\tif(tot+top+i*2>n+1) break;\n\t\tif(!check(i)) break;\n\t\tfas=fac[num+i]*val%md*inv[i]%md;\n\t\t(sum[tot+top+i*2][top]+=fas)%=md;\n//\t\tprintf(\"%d %d\\n\",tot+top+i*2,top);\n\t}\n}\nvoid dfs(int res,int las,long long val,int num){\n\tsolve(res,val,num);\n\tres--;\n\tint ttp;\n\tfor(int i=1;i<=res&&i<=las;i+=2){\n\t\tttp=top;\n\t\tfor(int j=1;res-i*j>=0;j++){\n\t\t\tstk[++top]=i;\n\t\t\tdfs(res-i*j,i-1,val*inv[j]%md,num+j);\n\t\t}\n\t\ttop=ttp;\n\t}\n}\nlong long C[maxn][maxn];\nint main(){\n//\tfreopen(\"F.in\",\"r\",stdin);\n//\tfreopen(\"F.out\",\"w\",stdout);\n\tfac[0]=1;\n\tfor(int i=1;i<=100;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[100]=powd(fac[100],md-2);\n\tfor(int i=100;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tC[0][0]=C[1][0]=C[1][1]=1;\n\tfor(int i=2;i<=100;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%md;\n\t}\n\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\tdfs(n+1,n,1,0);\n\tlong long ans=0,st=0;\n\tfor(int i=0;i<=n+1;i++){\n\t\tfor(int j=0;j<=n+1;j++){\n\t\t\tif(!sum[i][j]) continue;\n\t\t\tst=0;\n\t\t\tfor(int k=0;k<=j*2;k++){\n\t\t\t\tif(i+k<=n+1){\n\t\t\t\t\tans=(ans+C[n+1][i+k]*C[j*2][k]%md*sum[i][j])%md;\n\t\t\t\t\tst+=C[n+1][i+k]*C[j*2][k]%md*sum[i][j];\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"No\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=5e6+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=70+10;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);int R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='b')blu[i]++;else pos[++R]=i;}\nif(n>20) exit(1);\n\t\tfo(cnt,0,n) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,n) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tfo(s,max(1,cc),ii) add(g[cc][i+ii][j+1],g[cc][i][j]*C(ii-s+1,cc)%MOD*(cc?C(s-1,cc-1):(s==ii))%MOD);\n\t\t\t}\n\t\t}\n\t\tdp[n+1][0][0][0]=1;//cnt=n+1表示空\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,n) fo(cnt,0,n) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tdebug(\"dp(%d,%d,%d,%d)=%d\\n\",ln+1,S,t,cnt,dp[ln+1][S][t][cnt]);\n\t\t\tfo(i,0,n-S) fo(j,0,n-t) add(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t\t//fo(i,0,n-S) fo(j,0,(S+i)/max(1,ln)-t) add(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t}\n\t\tfo(S,0,n) fo(t,0,S) fo(cnt,0,n) if(dp[0][S][t][cnt])\n\t\t\tdebug(\"dp(%d,%d,%d,%d)=%d\\n\",0,S,t,cnt,dp[0][S][t][cnt]);\n\t\tll ans=0;fo(S,0,n) fo(t,0,n) fo(cnt,0,n) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*C(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//线性预处理模意义\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(int i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int inf = 2147483647;\nconst int N = 1001, M = 3e2 + 1;\nconst int mod = 1e9 + 7;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI LL read() {\n\tLL x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nI int pow_mod(reg a, reg k) {reg ans = 1; for(; k; k >>= 1, a = (LL)a * a % mod) if(k & 1) ans = (LL)ans * a % mod; return ans;}\n\nchar ss[N];\nint C[N][N], pos[N], s[N], up[N], jc[N], inv[N], f[M][M][M];\nbool v[N];\n\nint main() {\n\treg n = read(), m = read();\n\tscanf(\"%s\", ss + 1);\n\tjc[0] = 1; fo(i, 1, N - 1) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[N - 1] = pow_mod(jc[N - 1], mod - 2); fd(i, N - 1, 1) inv[i - 1] = (LL)inv[i] * i % mod;\n\tC[0][0] = 1; fo(i, 1, N - 1) {\n\t\tC[i][0] = 1; fo(j, 1, i) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n\t} int ans = 0;\n\tfo(A, 0, m / 2) {\n\t\tmemset(v, 0, sizeof(v));\n\t\treg R = 0;\n\t\tfo(i, 1, m) if(ss[i] == 'r'){\n\t\t\tif(R == A) break;\n\t\t\tbool bk = 0; fo(j, i + 1, m) if(ss[j] == 'b' && !v[j]) {v[j] = 1, pos[++R] = j, bk = 1; break;}\n\t\t\tif(!bk) break;\n\t\t} if(R < A) break;\n\t\tfo(B, 0, m) {\n\t\t\treg z = 0;\n\t\t\tfo(i, 1, m) if(ss[i] == 'r') z++, s[i] = s[i - 1] + (z > A + B); else s[i] = s[i - 1] + (!v[i]);\n\t\t\tif(z < A + B) break;\n\t\t\tup[A + 1] = 0, pos[A + 1] = m; fd(i, A, 1) up[i] = up[i + 1] + (s[pos[i + 1]] - s[pos[i]] + 1);\n\t\t\treverse(up + 1, up + A + 1);\n\t\t\tf[0][0][0] = 1; fo(i, 1, m) fo(j, 0, A) fo(S, 0, up[j]) f[i][j][S] = 0;\n\t\t\tfo(i, 1, m) fo(j, 0, A) fo(S, 0, _min(up[j], up[A] - i * (A - j))) if(f[i - 1][j][S]) {\n\t\t\t\tfor(reg k = 0; j + k <= A && S + k * i <= up[j + k]; k++)\n\t\t\t\t\tf[i][j + k][S + k * i] = (f[i][j + k][S + k * i] + (LL)f[i - 1][j][S] * inv[k]) % mod;\n\t\t\t} fo(S, 0, up[A]) if(f[m][A][S]){\n\t\t\t\tint c = (LL)f[m][A][S] * jc[A + B] % mod * inv[B] % mod;\n\t\t\t\tint H1 = 2 * S + 2 * B, H2 = A * 2;\n\t\t\t\tint ga = H1 - 1, gb = H1 + H2;\n\t\t\t\tans = (ans + (LL)c * C[n - ga + gb][gb]) % mod;\n\t\t\t}\n\t\t}\n\t} pr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K,C[1005][1005],L[75],fac[1005],invfac[1005],cnt;\nint sum[75][2],pos[75],tot,ans;\nchar s[75];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nbool check() {\n    if(tot < cnt) return false;\n    int R = sum[K][0] - sum[pos[cnt]][0],B = sum[K][1] - sum[pos[cnt]][1];\n    int p = 1;\n    for(int i = cnt ; i >= 1 ; --i) {\n        if(L[p] >= 2) {\n            if(!B) return false;\n            --B;\n            if(R + B < L[p] - 2) return false;\n            R -= L[p] - 2;\n            if(R < 0) {B += R,R = 0;}\n        }\n        R += sum[pos[i] - 1][0] - sum[pos[i - 1]][0];\n        B += sum[pos[i] - 1][1] - sum[pos[i - 1]][1];\n        ++p;\n    }\n    return true;\n}\nbool dfs(int pre,int dep,int len) {\n    cnt = dep;\n    if(!check()) return false;\n    int k = 1 + cnt;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] == 1) ++k;\n        else k += 2 * L[i] - 1;\n    }\n    int res = C[N - len + k - 1][k - 1];\n    res = mul(res,fac[cnt]);\n    int t = 0;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] != L[i - 1]) {\n            res = mul(res,invfac[t]);\n            t = 0;\n        }\n        ++t;\n    }\n    res = mul(res,invfac[t]);\n    update(ans,res);\n    if(dep + 1 > tot) return true;\n    for(int i = pre ; i <= 70 ; ++i) {\n        int tl = len;\n        if(dep != 0) ++tl;\n        if(i == 1 || i == 2) tl += 1;\n        else tl += i - 2 + i - 1;\n        if(tl > N) break;\n        L[dep + 1] = i;\n        if(!dfs(i,dep + 1,tl)) break;\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);read(K);\n    scanf(\"%s\",s + 1);\n    C[0][0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) {\n        C[i][0] = 1;\n        for(int j = 1 ; j <= i ; ++j) {\n            C[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n        }\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000] = fpow(fac[1000],MOD - 2);\n    for(int i = 999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    tot = 0;\n    for(int i = 1 ; i <= K ; ++i) {\n        if(s[i] == 'r') pos[++tot] = i;\n        sum[i][0] = sum[i - 1][0];\n        sum[i][1] = sum[i - 1][1];\n        if(s[i] == 'r') sum[i][0]++;\n        else sum[i][1]++;\n    }\n    dfs(1,0,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include<bits/stdc++.h>\n    using namespace std;\n    const long long mod=1000000007;\n    const long long inf=mod*mod;\n    const long long d2=(mod+1)/2;\n    const double EPS=1e-6;\n    const double PI=acos(-1.0);\n    int ABS(int a){return max(a,-a);}\n    long long ABS(long long a){return max(a,-a);}\n    char in[110];\n    int R[110];\n    int bl[110];\n    int used[110];\n    int lim[110];\n    int sz;\n    long long C[210][210];\n    long long fact[110];\n    long long inv[110];\n    long long finv[110];\n    int now[110];\n     \n    long long dp[110][110][110];\n    long long calc(int x,int y,int a){\n    \tfor(int i=0;i<80;i++)for(int j=0;j<80;j++)for(int k=0;k<80;k++)dp[i][j][k]=0;\n    \tdp[0][0][0]=1;\n    \tint n=a-y-(x+y-1);\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<=x;j++){\n    \t\t\tfor(int k=0;k<=n;k++){\n    \t\t\t\tif(!dp[i][j][k])continue;\n    \t\t\t\tfor(int l=0;j+l<=x&&k+l*(2*i+1)<=n;l++){\n    \t\t\t\t\tif(l&&lim[x-l-j]<(k-j)/2+l*i)break;\n    \t\t\t\t\tdp[i+1][j+l][k+l*(2*i+1)]=(dp[i][j][k]*C[j+l+y][l]+dp[i+1][j+l][k+l*(2*i+1)])%mod;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tlong long ret=0;\n    \tfor(int i=0;i<=n;i++){\n    \t\tret=(ret+C[n+3*x+2*y][n-i]*dp[n][x][i])%mod;\n    \t}\n    \t//printf(\"%d %d %d: %lld\\n\",x,y,a,ret);\n    \treturn ret;\n    }\n    int main(){\n    \tC[0][0]=1;\n    \tfor(int i=0;i<205;i++){\n    \t\tfor(int j=0;j<=i;j++){\n    \t\t\tC[i+1][j]=(C[i+1][j]+C[i][j])%mod;\n    \t\t\tC[i+1][j+1]=(C[i+1][j+1]+C[i][j])%mod;\n    \t\t}\n    \t}\n    \tint a,b;scanf(\"%d%d\",&a,&b);\n    \t//n=a;\n    \tfact[0]=finv[0]=inv[1]=1;\n    \tfor(int i=2;i<110;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n    \tfor(int i=1;i<110;i++){\n    \t\tfact[i]=fact[i-1]*i%mod;\n    \t\tfinv[i]=finv[i-1]*inv[i]%mod;\n    \t}\n    \tscanf(\"%s\",in);\n    \tlong long ret=0;\n    \tfor(int i=0;i<b;i++){\n    \t\tif(in[i]=='r'){\n    \t\t\tR[sz++]=i;\n    \t\t}\n    \t}\n    \tfor(int i=0;i<=sz;i++){\n    \t\tfor(int j=0;i+j<=sz;j++){\n    \t\t\tfor(int k=0;k<b;k++)used[k]=lim[k]=0;\n    \t\t\tfor(int k=0;k<i+j;k++)used[R[k]]=1;\n    \t\t\tbool dame=false;\n    \t\t\tfor(int k=0;k<i;k++){\n    \t\t\t\tbool ok=false;\n    \t\t\t\tfor(int l=R[k];l<b;l++){\n    \t\t\t\t\tif(!used[l]&&in[l]=='b'){\n    \t\t\t\t\t\tok=true;used[l]=1;bl[k]=l;break;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\tif(!ok){dame=true;break;}\n    \t\t\t}\n    \t\t\tif(dame)continue;\n    \t\t//\tprintf(\"%d %d\\n\",i,j);\n    \t\t\tfor(int k=0;k<i;k++){\n    \t\t\t\tfor(int l=bl[k]+1;l<b;l++){\n    \t\t\t\t\tif(!used[l])lim[k]++;\n    \t\t\t\t}\n    \t\t\t}\n     \n    \t\t\tret=(ret+calc(i,j,a))%mod;\n    \t\t}\n    \t}\n    \tprintf(\"%lld\\n\",ret);\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nint dp[111][111];\n\nint calc(){\n    /*\n    if(X[0]==1){\n        if(X.size()>R)return 0;\n        int n=X.size();\n        int y=N-(2*n+1);\n        return nCk(2*n+y,y);\n    }*/\n    int n=X.size();\n    if(n>R)return 0;\n    int nr=R-n,nb=B;\n    for(int i=0;i<X.size();i++){\n        int pos=r[R-i];\n        while(nb>0&&b[nb]<pos)nb--;\n        if(X[i]==1)continue;\n        if(nb==0)return 0;\n        while(nr>0&&r[nr]<b[nb])nr--;\n        nb--;\n        rep(t,X[i]-2){\n            if(i+1<n&&nb&&b[nb]<r[R-i-1]){\n                nb--;\n                continue;\n            }\n            if(nr){\n                nr--;\n                continue;\n            }\n            if(nb){\n                nb--;\n                continue;\n            }\n            return 0;\n        }\n    }\n\n\n    rep(i,n+1)rep(j,N+1)dp[i][j]=0;\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<N;j++){\n            if(X[i]==1){\n                for(int k=1;j+k<=N;k++)add(dp[i+1][j+k],dp[i][j]);\n            }\n            else{\n                for(int k=0;2*X[i]-3+k+j<=N;k++){\n                    add(dp[i+1][j+2*X[i]-3+k],dp[i][j]*nCk(2*X[i]-2+k,k)%mod);\n                }\n            }\n        }\n    }\n\n    int ret=0;\n    for(int i=0;i<=N;i++){\n        add(ret,dp[n][i]*nCk(N-i+1,n)%mod);\n    }\n\n    ret=ret*fact[n]%mod;\n    map<int,int>cnt;\n    rep(i,n)cnt[X[i]]++;\n    for(auto p:cnt)ret=ret*inv[p.se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n    \n    if(N>30||K>30)assert(0);\n\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\n#define left LEFT\ntypedef long long ll;\nconst int N = 510;\nconst int mod = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check()\n{\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    FOR(i, 1, k)\n    {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update()\n{\n    ll tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1)\n    {\n        for(j = i; a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % mod;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % mod;\n    if ((ans += tmp) >= mod) ans -= mod;\n}\n\nvoid dfs(int mx)\n{\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    ++tot; --left; dfs(a[tot] = 1); ++left;\n    FOR(i, 2, mx)\n    {\n        left -= i * 2 - 3;\n        dfs(a[tot] = i);\n        left += i * 2 - 3;\n    }\n    a[tot--] = 0;\n    if (tot) ++left;\n}\n\nint main()\n{\n    FOR(i, 0, 500)\n    {\n        c[i][0] = 1;\n        FOR(j, 1, 500)\n            if ((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= mod)\n                c[i][j] -= mod;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(100);\n    printf(\"%d\\n\", (ans + 1) % mod);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 140\nchar s[MN+5];\nmint F[MN+5],R[MN+5],ans;\nint n,a[MN+5],an,b[MN+5],bn,u[MN+5],p[MN+5];\ninline mint C(int n,int m){return F[n]*R[m]*R[n-m];}\nvoid dfs(int x,int y,int z,int s0)\n{\n\tint i,j,k;\n\tmemset(u,0,sizeof(u));\n\tfor(i=j=1;i<z;++i)if(p[z-i])\n\t{\n\t\twhile(j<=bn&&b[j]<a[i])++j;\n\t\tif(j>bn)break;\n\t\tu[a[i]]=u[b[j++]]=1;\n\t}\n\tif(i==z)for(i=j=1;i<z;++i)\n\t{\n\t\tfor(k=1;k<p[z-i];++k)\n\t\t{\n\t\t\twhile(s[j]&&(j<i||u[j]))++j;\n\t\t\tif(!s[j++])break;\n\t\t}\n\t\tif(k<p[z-i])break;\n\t}\n\tif(i==z)\n\t{\n\t\tmint s=F[z-1];\n\t\tfor(i=1;i<z;s*=R[j-i],i=j)for(j=i;j<z&&p[i]==p[j];++j);\n\t\tans+=s*C(n+2*(z-1-s0),2*(z-1+x));\n\t}\n\tif(z<=an)for(;x+y<=an+bn-z&&x+y+s0+!y<=n/2;++y)dfs(x+y,p[z]=y,z+1,s0+!y);\n}\nint main()\n{\n\tint m,i;\n\tscanf(\"%d%d%s\",&n,&m,s+1);++n;\n\tfor(F[0]=i=1;i<=MN;++i)F[i]=F[i-1]*i;\n\tfor(R[i=MN]=~F[MN];i--;)R[i]=R[i+1]*(i+1);\n\tfor(i=1;i<=m;++i)(s[i]=='r'?a[++an]:b[++bn])=i;\n\tdfs(0,0,1,0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nint N, K;\nchar S[111];\nint D[111];\nMint ans;\nvoid calc(const VI &v) {\n    memset(D, -1, sizeof D);\n    int cnt = 0;\n    REP (k, K) {\n\tif (S[k] == 'r' && cnt < (int)v.size()) {\n\t    D[k] = cnt++;\n\t}\n    }\n    if (cnt < (int)v.size()) return;\n\n    int b_size = 0;\n    EACH (e, v) if (*e > 0) b_size++;\n\n    int ma = -1;\n    cnt = 0;\n    REP (k, K) {\n\tamax(ma, D[k]);\n\tif (S[k] == 'b' && cnt < b_size && cnt <= ma) {\n\t    D[k] = cnt++;\n\t}\n    }\n    if (cnt < b_size) return;\n\n    int idx = 0;\n    ma = -1;\n    cnt = 0;\n    REP (k, K) {\n\tif (S[k] == 'b' && D[k] != -1) amax(ma, D[k]);\n\telse if (D[k] == -1 && idx < (int)v.size() && v[idx] >= 2 && idx <= ma) {\n\t    cnt++;\n\t    if (v[idx] == cnt + 1) {\n\t\tidx++;\n\t\tcnt = 0;\n\t    }\n\t}\n    }\n    if (idx < (int)v.size() && v[idx] >= 2) return;\n\n    Mint tmp;\n    if (v.empty()) {\n\ttmp = 1;\n    } else {\n\tMint x = fact[v.size()];\n\tfor (int i=0; i<(int)v.size();) {\n\t    int j = i;\n\t    while (j < (int)v.size() && v[i] == v[j]) j++;\n\t    x *= fact_inv[j-i];\n\t    i = j;\n\t}\n\n\tint use_len = v.size()-1;\n\tint color_cnt = v.size()+1;\n\tREP (i, v.size()) {\n\t    if (v[i] == 0) {\n\t\tuse_len++;\n\t\tcolor_cnt++;\n\t    } else {\n\t\tuse_len += v[i]*2 - 1;\n\t\tcolor_cnt += v[i]*2 + 1;\n\t    }\n\t}\n\n\tint rest = N - use_len;\n\tassert(rest >= 0);\n\ttmp = nCk(rest + color_cnt - 1, rest) * x;\n    }\n\n    ans += tmp;\n}\n\nvoid rec(int len, VI &v) {\n    calc(v);\n    int high;\n    if (len) {\n\thigh = v.back();\n    } else {\n\thigh = N;\n    }\n\n    v.push_back(0);\n    REP (i, high+1) {\n\tint add = 0;\n\tadd += (i? i*2-1: 1);\n\tif (v.size()) add += 1;\n\tif (len + add > N) break;\n\tv.back() = i;\n\trec(len+add, v);\n    }\n    v.pop_back();\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d%s\", &N, &K, S);\n    VI v;\n    rec(0, v);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nmap<vector<char>,int> ma;\nvector<char> V,v[420010];\nint cnt,t[420010][36],n,m,f[71][420010],g[71][36][2],sum[71][36],ans,h[420010];\nchar s[110];\n\nvoid dfs(int nw)\n{\n\tma[V]=(++cnt),v[cnt]=V;\n\tfor (int i=(V.empty()?0:V[V.size()-1]); (i==0)+i+nw<=35; i++)\n\t\tV.push_back(i),dfs(i+nw+(i==0)),V.pop_back();\n}\n\nint main()\n{\n\tV.clear(),cnt=0,dfs(0);\n\tfor (int i=1,nw; i<=cnt; i++)\n\t{\n\t\tnw=0;\n\t\tfor (int j=0,sz=v[i].size(); j<sz; j++) nw+=(v[i][j]==0)+v[i][j];\n\t\tfor (int j=0; (j==0)+j+nw<=35; j++) \n\t\t{\n\t\t\tV=v[i],V.push_back(j),sort(V.begin(),V.end());\n\t\t\tt[i][j]=ma[V];\n\t\t}\n\t}\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tf[0][1]=1,g[0][0][0]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tg[i][0][0]=g[i-1][0][0],g[i][0][1]=0;\n\t\tfor (int j=1; j<=(i+1>>1); j++)\n\t\t\tg[i][j][0]=(g[i-1][j][0]+g[i-1][j][1])%mod,\n\t\t\tg[i][j][1]=(g[i-1][j][1]+g[i-1][j-1][0])%mod;\n\t}\n\tfor (int j=0; j<=(n+1>>1); j++)\n\t{\n\t\tsum[0][j]=0;\n\t\tfor (int i=1; i<=n; i++) sum[i][j]=(sum[i-1][j]+1ll*g[i][j][0]+g[i][j][1])%mod;\n\t}\n\tfor (int i=0; i<n; i++)\n\t\tfor (int k=1; k<=cnt; k++) if (f[i][k])\n\t\t\tfor (int nxt=(i==0?1:i+2),j=nxt; j<=n; j++)\n\t\t\t\tfor (int l=0; l<=(j-nxt+2>>1); l++)\n\t\t\t\t\tf[j][t[k][l]]=(f[j][t[k][l]]+1ll*f[i][k]*sum[j-nxt+1][l])%mod;\n\tfor (int j=1; j<=cnt; j++)\n\t\tfor (int i=0; i<=n; i++) h[j]=(h[j]+f[i][j]>=mod?h[j]+f[i][j]-mod:h[j]+f[i][j]);\n\tans=0;\n\tfor (int nw,p,i=1,nww,pp; i<=cnt; i++) if (h[i])\n\t{\n\t\tnw=0,p=v[i].size(),nww=0,pp=v[i].size();\n\t\tfor (int j=0; (p||nw)&&j<m; j++)\n\t\t\tif (s[j]=='r') \n\t\t\t{\n\t\t\t\tif (p) nw+=v[i][--p];\n\t\t\t\telse if (nww&&nw) nw--,nww--;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nw) \n\t\t\t\t{\n\t\t\t\t\tnw--;\n\t\t\t\t\tif (p<pp) nww+=max(v[i][--pp]-1,0);\n\t\t\t\t}\n\t\t\t}\n\t\tif (!p&&!nw)  ans=(ans+h[i])%mod;\n\t}\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 75\n#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)\n#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)\n#define mod 1000000007\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\n\nint n,K,fac[maxn << 2],invf[maxn << 2],inv[maxn << 2];\nint C(int a,int b){ if(a<0 || b<0 || a-b<0) return 0;return fac[a] * 1ll * invf[b] % mod * invf[a-b]%mod; }\nchar s[maxn];\nvi p;int ans;\n\nbool check(){\n\tstatic bool vis[maxn];\n\tstatic int loc[maxn];\n\tmemset(vis,0,sizeof vis);\n\tint j=1;\n\tfor(int i=p.size()-1;i>=0 && p[i];i--){\n\t\tfor(;j <= K && s[j] != 'r';j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , loc[i] = j , j++;\n\t}\n\tj=1;\n\tfor(int i=p.size()-1;i>=0 && p[i];i--){\n\t\tj = max(j , loc[i]);\n\t\tfor(;j <= K && s[j] != 'b';j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , loc[i] = j , j++;\n\t}\n\tj=1;\n\tfor(int i=0;i<p.size() && p[i]==0;i++){\n\t\tfor(;j <= K && (s[j] != 'r' || vis[j]);j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , j++;\n\t}\n\tj=1;\n\tfor(int i=p.size()-1;i>=0 && p[i] > 1;i--){\n\t\tj = max(j , loc[i]);\n\t\trep(k,2,p[i]){\n\t\t\tfor(;j <= K && vis[j];j++);\n\t\t\tif(j > K) return 0;\n\t\t\tvis[j] = 1 , j++;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid dfs(int sz,int mx,int lim){\n\tif(sz > n) return;\n\tif(check()){\n\t\tint sm = fac[p.size()];\n\t\tfor(int i=0,j;i<p.size();i=j){\n\t\t\tfor(j=i;j<p.size() && p[j] == p[i];j++);\n\t\t\tsm = 1ll * sm * invf[j-i] % mod;\n\t\t}\n\t\tans = (ans + 1ll * C(n-sz+mx-1,mx-1) * sm) % mod;\n\t\t//printf(\"%d %d %d %d\\n\",sm,ans,sz,mx);\n\t}\n\telse return;\n\trep(i,lim,(n-sz+1)/2){\n\t\tp.pb(i);\n\t\tdfs(sz+max(2*i-1,1)+(sz!=0),mx+2*i+2,i);\n\t\tp.pop_back();\n\t}\n}\n\nint main(){//freopen(\"1.in\",\"r\",stdin);//freopen(\"2.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&K);\n\tscanf(\"%s\",s+1);\n\tfac[0] = inv[0] = inv[1] = fac[1] = invf[0] = invf[1] = 1;\n\trep(i,2,(maxn << 2) - 1) fac[i] = 1ll * fac[i-1] * i % mod , inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod,\n\t\tinvf[i] = 1ll * invf[i-1] * inv[i] % mod;\n\tdfs(0,1,0);\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 200;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nint N, K;\nchar S[111];\nint D[111];\nMint ans;\nvoid calc(const VI &v) {\n    memset(D, -1, sizeof D);\n    int cnt = 0;\n    REP (k, K) {\n\tif (S[k] == 'r' && cnt < (int)v.size()) {\n\t    D[k] = cnt++;\n\t}\n    }\n    if (cnt < (int)v.size()) return;\n\n    int b_size = 0;\n    EACH (e, v) if (*e > 0) b_size++;\n\n    int ma = -1;\n    cnt = 0;\n    REP (k, K) {\n\tamax(ma, D[k]);\n\tif (S[k] == 'b' && cnt < b_size && cnt <= ma) {\n\t    D[k] = cnt++;\n\t}\n    }\n    if (cnt < b_size) return;\n\n    int idx = 0;\n    ma = -1;\n    cnt = 0;\n    REP (k, K) {\n\tif (S[k] == 'b' && D[k] != -1) amax(ma, D[k]);\n\telse if (D[k] == -1 && idx < (int)v.size() && v[idx] >= 2 && idx <= ma) {\n\t    cnt++;\n\t    if (v[idx] == cnt + 1) {\n\t\tidx++;\n\t\tcnt = 0;\n\t    }\n\t}\n    }\n    if (idx < (int)v.size() && v[idx] >= 2) return;\n\n    Mint x = fact[v.size()];\n    for (int i=0; i<(int)v.size();) {\n\tint j = i;\n\twhile (j < (int)v.size() && v[i] == v[j]) j++;\n\tx *= fact_inv[j-i];\n\ti = j;\n    }\n\n    Mint tmp;\n    if (v.empty()) {\n\ttmp = 1;\n    } else {\n\tint use_len = v.size()-1;\n\tint color_cnt = v.size()+1;\n\tREP (i, v.size()) {\n\t    if (v[i] == 0) {\n\t\tuse_len++;\n\t\tcolor_cnt++;\n\t    } else {\n\t\tuse_len += v[i]*2 - 1;\n\t\tcolor_cnt += v[i]*2 + 1;\n\t    }\n\t}\n\n\tint rest = N - use_len;\n\tassert(rest >= 0);\n\ttmp = nCk(rest + color_cnt - 1, rest) * x;\n    }\n\n    ans += tmp;\n}\n\nvoid rec(int len, VI &v) {\n    calc(v);\n    int high;\n    if (len) {\n\thigh = v.back();\n    } else {\n\thigh = N;\n    }\n\n    v.push_back(0);\n    REP (i, high+1) {\n\tint add = 0;\n\tadd += (i? i*2-1: 1);\n\tif (v.size()) add += 1;\n\tif (len + add > N) break;\n\tv.back() = i;\n\trec(len+add, v);\n    }\n    v.pop_back();\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d%s\", &N, &K, S);\n    VI v;\n    rec(0, v);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000, mod = 1e9 + 7;\nint N, k, tot, ans, fac[maxn + 10], ifac[maxn + 10], inv[maxn + 10];\nint a[100], pos[100], cnt[100];\nchar s[100];\nbool vis[100];\n\nvoid solve(int n) {\n\tmemset(vis, 0, sizeof vis);\n\tfor (int i = 1, p = 1; i <= n; ++i) {\n\t\tfor (; p <= k && s[p] != 'r'; ++p);\n\t\tif (p > k) return;\n\t\tvis[p] = 1;\n\t\tpos[i] = p++;\n\t}\n\tfor (int i = 1, p = 1; i <= n; ++i)\n\t\tif (a[i] >= 2) {\n\t\t\tfor (; p <= k && (p <= pos[i] || s[p] != 'b'); ++p);\n\t\t\tif (p > k) return;\n\t\t\tvis[p] = 1; pos[i] = p++;\n\t\t}\n\tfor (int i = 1, p = 1; i <= n; ++i)\n\t\tif (a[i] >= 3)\n\t\t\tfor (int j = 1; j <= a[i] - 2; ++j) {\n\t\t\t\tfor (; p <= k && (p <= pos[i] || vis[p]); ++p);\n\t\t\t\tif (p > k) return;\n\t\t\t\t++p;\n\t\t\t}\n\tint ans = fac[n];\n\tmemset(cnt, 0, sizeof cnt);\n\tfor (int i = 1; i <= n; ++i)\n\t\t++cnt[a[i]];\n\tfor (int i = 1; i <= N; ++i)\n\t\tif (cnt[i])\n\t\t\tans = 1ll * ans * ifac[cnt[i]] % mod;\n\tint x = N + 1, y = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (a[i] >= 2) x += 2;\n\t\ty += a[i] * 2;\n\t}\n\tif (x < y) return;\n\tans = 1ll * ans * fac[x] % mod;\n\tans = 1ll * ans * ifac[y] % mod;\n\tans = 1ll * ans * ifac[x - y] % mod;\n\t(tot += ans) %= mod;\n}\n\nvoid dfs(int p, int l, int mx) {\n\tsolve(p - 1);\n\tfor (int i = mx; i >= 1; --i)\n\t\tif (max(i * 2 - 3, 1) <= l) {\n\t\t\ta[p] = i;\n\t\t\tdfs(p + 1, l - max(i * 2 - 3, 1), i);\n\t\t}\n}\n\nint main() {\n\tfac[0] = ifac[0] = 1;\n\tfor (int i = 1; i <= maxn; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tinv[i] = i == 1 ? 1 : mod - 1ll * (mod / i) * inv[mod % i] % mod;\n\t\tifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;\n\t}\n\tscanf(\"%d%d\", &N, &k);\n\tscanf(\"%s\", s + 1);\n\tdfs(1, N, N * 2);\n\tprintf(\"%d\", tot);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=75;\nconst int mod=1e9+7;\nint n,k;\nchar s[maxn];\nint nxt[maxn][2],pos0[maxn],pos1[maxn],lim[maxn],fac[maxn*2],ifac[maxn*2];\nint dp[maxn][maxn][maxn];\nbool del[maxn];\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*max(n,k);i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,2*max(n,k))ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tnxt[k][0]=nxt[k][1]=k;\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(s[i]=='r')nxt[i][0]=i,nxt[i][1]=nxt[i+1][1];\n\t\telse nxt[i][0]=nxt[i+1][0],nxt[i][1]=i;\n\t}\n\tint ans=0;\n\trep(i,k+1)rep(s,k+1){\n\t\tbool ok=true;\n\t\tint last0=-1,last1=-1;\n\t\trep(j,k)del[j]=false;\n\t\trep(j,i){\n\t\t\tpos0[j]=nxt[last0+1][0];\n\t\t\tpos1[j]=nxt[max(last1+1,pos0[j])][1];\n\t\t\tif(pos0[j]==k||pos1[j]==k){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdel[pos0[j]]=del[pos1[j]]=true;\n\t\t\tlast0=pos0[j];last1=pos1[j];\n\t\t}\n\t\tif(!ok)continue;\n\t\tint last=-1;\n\t\trep(j,s){\n\t\t\tint cur0=nxt[last+1][0];\n\t\t\twhile(cur0<k&&del[cur0])cur0=nxt[cur0+1][0];\n\t\t\tif(cur0==k){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdel[cur0]=true;\n\t\t}\n\t\tif(!ok)continue;\n\t\trep(j,i){\n\t\t\tlim[i-j]=0;\n\t\t\tfor(int p=pos1[j]+1;p<k;p++)if(!del[p])lim[i-j]++;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0][0]=1;\n\t\trep(j,i+1)rep(p,k+1)rep(q,k+1){\n\t\t\tint cur=dp[j][p][q];\n\t\t\tif(!cur)continue;\n\t\t\trep(t,k+1){\n\t\t\t\tif(q+t*p>lim[j+t])break;\n\t\t\t\tAdd(dp[j+t][p+1][q+t*p],1LL*cur*ifac[t]%mod);\n\t\t\t}\n\t\t}\n\t\trep(q,k+1){\n\t\t\tint cur=dp[i][k][q];\n\t\t\tif(!cur)continue;\n\t\t\tint now=q*2+i;\n\t\t\tint coef=1LL*cur*fac[i+s]%mod*ifac[s]%mod;\n\t\t\trep(p,n-s-now+1){\n\t\t\t\tint cur;\n\t\t\t\tif(now+2*i+s==0&&p==0)cur=1;\n\t\t\t\telse cur=1LL*C(p+(now+2*i+s-1),now+2*i+s-1)*C(n-s-now-p+1,i+s)%mod;\n\t\t\t\tAdd(ans,1LL*coef*cur%mod);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 80;\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint fastpow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint li[MAXN];\nchar buf[MAXN];\nint n, K, ans;\nconst int MAXS = 300;\nint tl[MAXN], C[MAXS][MAXS];\nint fac[MAXN], inv[MAXN];\nvoid dfs(int S, int rest, int can, int lst) {\n\tif (rest < 0) return ;\n\tmemcpy(tl + 1, li + 1, S << 2);\n\tint cur1 = 1, cur2 = 1, cur3 = 1;\n\tfor (int i = 1; i <= K; ++i) {\n\t\tbool ok = false;\n\t\tif (cur1 <= S && buf[i] == 'r') {\n\t\t\t++cur1; ok = true;\n\t\t}\n\t\twhile (cur2 < cur1 && tl[cur2] == 0) ++cur2;\n\t\tif (!ok && cur2 + 1 <= cur1 && buf[i] == 'b') {\n\t\t\t--tl[cur2++]; ok = true;\n\t\t}\n\t\twhile (cur2 < cur1 && tl[cur2] == 0) ++cur2;\n\t\tif (!ok && cur3 < cur2 && tl[cur3]) --tl[cur3];\n\t\twhile (cur3 < cur2 && tl[cur3] == 0) ++cur3;\n\t}\n\tif (cur3 <= S) return ;\n\tint tx = mul(C[can + rest - 1][can - 1], fac[S]);\n\tstatic int hav[MAXN];\n\tmemset(hav, 0, n + 1 << 2);\n\tfor (int i = 1; i <= S; ++i) ++hav[li[i]];\n\tfor (int i = 0; i <= n; ++i) if (hav[i]) tx = mul(tx, inv[hav[i]]);\n\treduce(ans += tx - mod);\n\tfor (int i = lst; ~i; --i) {\n\t\tli[S + 1] = i;\n\t\tdfs(S + 1, rest - std::max(i, 1) * 2 + (S == 0), can + (i + 1) * 2, i);\n\t}\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tfor (int i = 0; i != MAXS; ++i) {\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\treduce(C[i][j] = C[i - 1][j] + C[i - 1][j - 1] - mod);\n\t}\n\tstd::cin >> n >> K >> buf + 1;\n\tinv[0] = inv[1] = fac[0] = fac[1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tinv[i] = mul(inv[mod % i], mod - mod / i);\n\t\tfac[i] = mul(fac[i - 1], i);\n\t}\n\tfor (int i = 2; i <= n; ++i) inv[i] = mul(inv[i - 1], inv[i]);\n\tdfs(0, n, 1, n);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=150,P=1e9+7;\nint n,m,top,ans,st[N],fac[N],ifac[N],inv[N],beg[N];\nchar s[N];\nbool vis[N];\nint C(int k1,int k2){\n\tif(k1<0||k2<0||k1-k2<0)return 0;\n\treturn 1LL*fac[k1]*ifac[k2]%P*ifac[k1-k2]%P;\n}\nbool chk(){\n\trep(i,1,m)vis[i]=0;\n\tint ntop=top;\n\trep(i,1,ntop)beg[i]=0;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='r')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t\tbeg[i]=beg[i];\n\t}\n\twhile(ntop&&st[ntop]==1)--ntop;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='b')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t}\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\trep(_,1,st[i]-2){\n\t\t\twhile(beg[i]<=m&&vis[beg[i]])++beg[i];\n\t\t\tif(beg[i]>m)return 0;\n\t\t\t++beg[i];\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int num,int mn,int mx,int ntop){\n\tif(!num){\n\t\tif(!chk())return;\n\t\trep(i,1,top){\n\t\t\tD(\"%d \",st[i]);\n\t\t}\n\t\tD(\"\\n\");\n\t\tD(\">>> %d %d\\n\",mn,mx);\n\t\tint ans=C(n-mn+mx-1,mx-1);\n\t\twhile(ntop){\n\t\t\tint x=st[ntop];\n\t\t\tint t=0;\n\t\t\twhile(st[ntop]==x)++t,--ntop;\n\t\t\tans=1LL*ans*C(ntop+t,t)%P;\n\t\t}\n\t\t(::ans+=ans)%=P;\n\t\treturn;\n\t}\n\twhile(1){\n\t\tdfs(num-1,mn,mx,ntop);\n\t\ttop=ntop;\n\t\tmn+=(num==1?1:2*num-3)+!!mn;\n\t\tif(mn>n)return;\n\t\tmx+=2*num;\n\t\tst[++top]=num;\n\t\t++ntop;\n\t}\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<N;++i)fac[i]=1LL*fac[i-1]*i%P,inv[i]=1LL*(P-P/i)*inv[P%i]%P,ifac[i]=1LL*ifac[i-1]*inv[i]%P;\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tdfs(n,0,1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nnamespace Shi_Jian_Shi_Jian_Yan_Zhen_Li_De_Wei_Yi_Biao_Zhun____________________By_a_Believer\n{\n\ttypedef long long ll;\n\tconst int N=72,M=2333,MOD=1000000007;\n\tinline void inc(int a,int &b){b=(a+b)%MOD;}\n\tinline ll inv(int x){return x==1?1:(-(MOD/x)*inv(MOD%x)%MOD);}\n\n\tint fact[M];\n\tint C[M][M];\n\n\tvoid initialize()\n\t{\n\t\tfor(int i=0;i<M;i++)C[i][0]=1;\n\t\tfor(int i=1;i<M;i++)\n\t\t\tfor(int j=1;j<M;j++)\n\t\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n\t\tfact[0]=1;\n\t\tfor(int i=1;i<M;i++)fact[i]=(ll)fact[i-1]*i%MOD;\n\t}\n\n\tchar s[N];\n\tint n,m,ans;\n\n#define ml(x) (std::max(1,((x)-1)*2-1))\n\n\tint f[N];\n\n\tbool check(int tot)\n\t{\n\t\tint cnt=0,ind=tot,dni=tot;\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(s[i]=='r')\n\t\t\t{\n\t\t\t\tif(ind)ind--;\n\t\t\t\telse cnt-=cnt>0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(dni && dni>ind && f[dni]>1)\n\t\t\t\t{\n\t\t\t\t\tcnt+=f[dni]-2;\n\t\t\t\t\tdni--;\n\t\t\t\t}\n\t\t\t\telse cnt-=cnt>0;\n\t\t\t}\n\t\treturn !ind && (!dni || f[dni]==1) && !cnt;\n\t}\n\n\tint calc(int tot)\n\t{\n\t\tint ret=fact[tot],tmp=0,cnt=0,fk=0;\n\t\tfor(int i=1;i<=tot;i++)\n\t\t{\n\t\t\tcnt+=ml(f[i]),fk+=f[i]*2-1;\n\t\t\ttmp++;\n\t\t\tif(i==tot || f[i]!=f[i+1])\n\t\t\t\tret=(ll)ret*inv(fact[tmp])%MOD,tmp=0;\n\t\t}\n\t\tcnt+=tot?tot-1:0,fk+=tot+1;\n\t\t\n\t\tret=((ll)ret*C[n-cnt+fk-1][fk-1]%MOD+MOD)%MOD;\n\n//\t\tprintf(\"cnt = %d , fk = %d\\n\",n-cnt,fk);\n//\t\tprintf(\"ret = %d\\n\",ret);\n\n\t\treturn ret;\n\t}\n\n\tvoid dfs(int p=0,int x=1,int len=n)\n\t{\n\t\t\n\t\tif(check(p))inc(calc(p),ans);\n\n\t\tint &y=f[p+1];\n\t\tfor(y=x;ml(y)<=len;y++)\n\t\t\tdfs(p+1,y,std::max(len-ml(y)-1,0));\n\t}\n\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tscanf(\"%s\",s+1);\n\t\tans=0,dfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n\nint main()\n{\n\tShi_Jian_Shi_Jian_Yan_Zhen_Li_De_Wei_Yi_Biao_Zhun____________________By_a_Believer::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=250;\nll C[maxn][maxn];\nll fac[maxn],invfac[maxn];\nll dp[maxn][maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline ll comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nint n,k;\nvi f;\nll solve()\n{\n    if(!f.size()) return 1;\n    vi len(f.size());\n    int p=f.size()-1,p2=f.size()-1;\n    for(int i=0;i<s.length();i++)\n    {\n        if(s[i]=='r')\n        {\n            if(p>=0)\n            {\n                len[p]++;\n                p--;\n            }\n            else{\n                while(p2>=0&&len[p2]==f[p2]) p2--;\n                if(p2<0) break;\n                len[p2]++;\n            }\n        }\n        else{\n            while(p2>=0&&len[p2]==f[p2]) p2--;\n            if(p2<0) break;\n            if(len[p2]) len[p2]++;\n        }\n    }\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++) \n    {\n        if(f[i]!=len[i]) return 0;\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    ll ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nll dfs(int r,int mx,int cc,int len=0)\n{\n    ll ret=solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(len+r/2-1>n) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        ll cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=305,M=1e9+7;\nchar s[N];\nint n,K,ans,a[N],fac[N],inv[N];\nint C(int x,int y){\n\treturn fac[x]*inv[y]%M*inv[x-y]%M;\n}\nvoid Check(int num,int sum){\n\tint pos=num+1,res=fac[num],rnum=0,leftr=0,nxt=0,left=0;\n\tfor (int i=1;i<=K;i++)\n\t\tif (s[i]=='r'){\n\t\t\tif (rnum<num)leftr+=a[++rnum]>1;\n\t\t\telse if (left)left--;\n\t\t}\n\t\telse {\n\t\t\tif (leftr)leftr--,left+=a[++nxt]-2;\n\t\t\telse if (left)left--;\n\t\t}\n\tif (left||rnum<num||leftr) return;\n\tfor (int i=1,j=1;i<=num;i=j){\n\t\twhile (j<=num&&a[j]==a[i])j++;\n\t\t(res*=inv[j-i])%=M;\n\t\tpos+=(j-i)*(a[i]*2-1);\n\t}\n\t(ans+=res*C(n-sum+pos-1,pos-1))%=M;\n}\nvoid dfs(int x,int num,int sum){\n\tif (sum>n)return;\n\tCheck(num,sum);\n\tfor (int i=x;i;i--){\n\t\ta[num+1]=i;\n\t\tdfs(i,num+1,sum+(i>1?i*2-3:1)+(num>0));\n\t}\n}\nint ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld%lld%s\",&n,&K,s+1);\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*i%M,inv[i]=ksm(fac[i],M-2);\n\tdfs(70,0,0); \n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 75;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[MN * 4], iFac[MN * 4];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\n\nint Len;\nchar Str[MN];\nint posr[MN], nxposb[MN], rcnt;\n\nint N, Ans;\n\nint stk[MN];\ninline void Calc(int cnt, int csum) {\n\tint Sum = 0;\n\tif (!cnt) Sum = 1;\n\telse if (cnt <= rcnt) {\n\t\tstatic int vis[MN];\n\t\tfor (int i = 1; i <= cnt; ++i) vis[i] = posr[i];\n\t\tint tot = cnt, mxp = 1;\n\t\tfor (int i = 1; i <= cnt && stk[i] >= 2; ++i)\n\t\t\tmxp = vis[++tot] = nxposb[std::max(mxp, vis[i])];\n\t\tif (mxp <= Len) {\n\t\t\tstd::inplace_merge(vis + 1, vis + cnt + 1, vis + tot + 1);\n\t\t\tint nwp = Len + 1, sum = 0, now = cnt, ok = 1;\n\t\t\tfor (int i = tot; i >= 1; --i) {\n\t\t\t\tsum += nwp - vis[i] - 1;\n\t\t\t\tif (Str[vis[i]] == 'r') {\n\t\t\t\t\tif (stk[now] >= 2) sum -= stk[now] - 2;\n\t\t\t\t\tif (sum < 0) { ok = 0; break; }\n\t\t\t\t\t--now;\n\t\t\t\t}\n\t\t\t\tnwp = vis[i];\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tSum = Fac[cnt];\n\t\t\t\tint len = 0, num = 1;\n\t\t\t\tfor (int i = 1; i <= cnt; ++i) {\n\t\t\t\t\t++len;\n\t\t\t\t\tnum += stk[i] * 2;\n\t\t\t\t\tif (i == cnt || stk[i] != stk[i + 1]) {\n\t\t\t\t\t\tSum = (LL)Sum * iFac[len] % Mod;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSum = (LL)Sum * Fac[N - csum + num] % Mod * iFac[num - 1] % Mod * iFac[N - csum + 1] % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tAns -= (Ans += Sum) >= Mod ? Mod : 0;\n}\nvoid DFS(int st, int mx, int sum) {\n\tCalc(st - 1, sum);\n\tif (sum < N) {\n\t\tstk[st] = 1;\n\t\tDFS(st + 1, 1, sum + 2);\n\t}\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (sum + i * 2 <= N + 3) {\n\t\t\tstk[st] = i;\n\t\t\tDFS(st + 1, i, sum + i * 2 - 2);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &Len, Str + 1);\n\tInit(N * 4);\n\tfor (int i = 1; i <= Len; ++i)\n\t\tif (Str[i] == 'r')\n\t\t\tposr[++rcnt] = i;\n\tint nwposb = Len + 1;\n\tnxposb[Len + 1] = Len + 1;\n\tfor (int i = Len; i >= 1; --i) {\n\t\tnxposb[i] = nwposb;\n\t\tif (Str[i] == 'b')\n\t\t\tnwposb = i;\n\t}\n\tDFS(1, (N + 3) / 2, 0);\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=75;\nint C[N*5][N*5];\nint n,k,ans,used[N];\nint q1[N],q2[N],suf[N];\nint f[N][N];\nchar s[N];\nvoid init(){\n\tFor(i,0,N*5-1) C[i][0]=1;\n\tFor(i,1,N*5-1) For(j,1,i)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;\n}\nvoid solve(int S1,int S2){\n\tif (!S1&&!S2) return ++ans,void(0);\n\tif ((S1+S2)*2>n+1||S1+2*S2>k) return; \n\tmemset(used,0,sizeof(used));\n\tint h=0,t=*q2=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r') q1[++t]=i;\n\t\telse if (s[i]=='b'&&h!=t&&*q2!=S2)\n\t\t\tused[q1[++h]]=used[i]=1,q2[++*q2]=i;\n\tif (*q2!=S2) return;\n\tFor(i,1,S1)\n\t\tif (h==t) return;\n\t\telse used[q1[++h]]=1;\n\tRep(i,k,1) suf[i]=suf[i+1]+(!used[i]);\n\tFor(i,1,S2) q2[i]=suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tint upp=max(2,n)+1;\n\tFor(i,2,upp) Rep(j,S2-1,0) For(k,2*j,upp-i*(S2-j)){\n\t\tint psum=k-2*j;\n\t\tFor(l,1,min(S2-j,(upp-k)/i)){\n\t\t\tif ((psum+=i-2)>q2[S2-j-l+1]) break;\n\t\t\tf[j+l][k+i*l]=(f[j+l][k+i*l]+1ll*C[j+l][l]*f[j][k])%mo;\n\t\t}\n\t}\n\tFor(k,0,upp){\n\t\tint sum=2*S1+2*k-2*S2-1;\n\t\tint par=2*S1+2*k+1;\n\t\tif (sum&&sum<=n&&f[S2][k])\n\t\t\tans=(ans+1ll*f[S2][k]*C[n-sum+par-1][par-1]%mo*C[S2+S1][S2])%mo;\n\t}\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tFor(S1,0,n) For(S2,0,n) solve(S1,S2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define cri const register int\n#define re register\nusing namespace std;\nconst int mod=1e9+7;\ninline int qpow(int a,int b,int ans=1){\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint fac[201],inv[201],n,k,nxt[77],v[77],vv[77],ans,num,len[77],R[77];\nchar s[77];\ninline int C(cri x,cri y){\n\treturn x<y||x<0||y<0?0:1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\ninline char check(cri p){\n\tmemset(v,0,sizeof v);memset(vv,0,sizeof vv);\n\tfor(int i=p,l=1;i;i--,l++){\n\t\tif(l>num) return 0;\n\t\tv[R[l]]=1;\n\t\tif(len[i]>=2){\n\t\t\tif(!nxt[l]) return 0;\n\t\t\tv[nxt[l]]=1;vv[nxt[l]]=i;\n\t\t}\n\t}\n\tfor(int i=k,sum=0;i;i--){\n\t\tif(!v[i]) sum++;\n\t\telse if(vv[i]){\n\t\t\tsum-=max(0,len[vv[i]]-2);\n\t\t\tif(sum<0) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\nchar dfs(cri p,cri mn,cri LEN){\n\tif(LEN>n||!check(p)) return 0;\n\tint s=p+1;\n\tfor(int i=1;i<=p;i++) s+=2*len[i]-1;\n\tint tmp=1ll*C(n-LEN+s-1,s-1)*fac[p]%mod,t=0;\n\tfor(int i=1;i<=p;i++,t++) \n\t\tif(len[i]!=len[i-1]) tmp=1ll*tmp*inv[t]%mod,t=0;\n\tans=(ans+1ll*tmp*inv[t])%mod;\n\tif(p==num) return 1;\n\tfor(int i=mn;i<=k;i++) \n\t\tif(!dfs(p+1,len[p+1]=i,LEN+(p!=0)+(i<=2?1:i*2-3))) break;\n\treturn 1;\n}\nint main(){\n\tcin>>n>>k;\n\tscanf(\"%s\",s+1);\n\tfor(int i=fac[0]=1;i<=200;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[200]=qpow(fac[200],mod-2);\n\tfor(int i=200;i;i--) inv[i-1]=1ll*inv[i]*i%mod;\n\tfor(int i=1;i<=k;i++) if(s[i]=='r')\n\t\tfor(int j=(R[++num]=i,i+1);j<=k;j++) if(!v[j]&&s[j]=='b'){\n\t\t\tnxt[num]=j;v[j]=1;break;\n\t\t}\n\tdfs(0,1,0);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nint n,m,k,a[75],len[75],tmp[75],st[75];\nll ans,fact[205],inv[205];\nchar s[75];\nbool flag[75];\nqueue<int>q;\nll quick_pow(ll x,ll a)\n{\n\tll ans=1;\n\twhile(a)\n\t{\n\t\tif(a&1)ans=ans*x%MOD;\n\t\tx=x*x%MOD;\n\t\ta>>=1;\n\t}\n\treturn ans;\n}\nbool check()\n{\n\tmemset(flag,0,sizeof(flag));\n\twhile(!q.empty())q.pop();\n\tint tot=0;\n\tfor(int i=m;i;i--)\n\t{\n\t\tfor(int j=1;j<=a[i];j++)\n\t\t  tmp[++tot]=i-1;\n\t}\n\tint now=1;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tif(s[i]=='r')\n\t\t{\n\t\t\tq.push(i);\n\t\t}\n\t\tif(s[i]=='b')\n\t\t{\n\t\t\tif(now<=tot&&!q.empty())\n\t\t\t{\n\t\t\t\tst[now]=i;\n\t\t\t\tflag[q.front()]=flag[i]=1;\n\t\t\t\tq.pop();\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t}\n\tif(now<=tot)return 0;\n\tfor(int i=1;i<=a[0];i++)\n\t{\n\t\tif(q.empty())return 0;\n\t\tflag[q.front()]=1;\n\t\tq.pop();\n\t}\n\tnow=1;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\twhile(now<=st[i])now++;\n\t\tfor(int j=1;j<=tmp[i];j++)\n\t\t{\n\t\t\twhile(flag[now])now++;\n\t\t\tif(now>k)return 0;\n\t\t\tflag[now]=1;\n\t\t}\n\t}\n\treturn 1;\n}\nll solve()\n{\n\tif(!check())return 0;\n\tint l=n,tot=0;\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\tl-=a[i]*(len[i]+1);\n\t\ttot+=a[i];\n\t\ttot+=a[i]*(2*i+1);\n\t}\n\tl++;\n\tll ans=fact[l+tot]*inv[l]%MOD*inv[tot]%MOD;\n\ttot=0;\n\tfor(int i=0;i<=m;i++)\n\t{\n\t\ttot+=a[i];\n\t\tans=ans*inv[a[i]]%MOD;\n\t}\n\treturn ans*fact[tot];\n}\nvoid dfs(int step,int rest)\n{\n\tif(step>m)\n\t{\n\t\tans=(ans+solve())%MOD;\n\t\treturn;\n\t}\n\tfor(a[step]=0;a[step]*len[step]+a[step]<=rest;a[step]++)\n\t  dfs(step+1,rest-a[step]*len[step]-a[step]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=200;i++)fact[i]=fact[i-1]*i%MOD;\n\tinv[200]=quick_pow(fact[200],MOD-2);\n\tfor(int i=200;i>=1;i--)inv[i-1]=inv[i]*i%MOD;\n\tlen[0]=len[1]=1;\n\tm=2;\n\twhile(2*m-1<=n)\n\t{\n\t\tlen[m]=2*m-1;\n\t\tm++;\n\t}\n\tm--;\n\tdfs(0,n+1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=75,mod=1e9+7;\nint n,k,a[N],use[N],posr[N],posb[N],fac[N],ifac[N],c[N*3][N*3],Ans;\nchar s[N];\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x; \n}\ninline int C(ri n,ri m){\n\treturn m<0||n<m?0:c[n][m];\n}\n//int tmp;\n//int mx;\ninline void solve(ri cnt){\n//\tmx=max(mx,cnt);\n//\t++tmp;\n\n//\tprintf(\"cnt = %d\\n\",cnt);\n//\tfor(ri i=1;i<=cnt;++i) printf(\"%d \",a[i]);\n//\tputs(\"\");\n\t\n//\treturn;\n\t\n\tri i,now,res;\n\tfor(i=1;i<=k;++i) use[i]=0;\n\tfor(i=1;i<=cnt;++i) posr[i]=posb[i]=0;\n\tnow=0;\n\tfor(i=1;i<=k&&now<cnt;++i)\n\t\tif(s[i]=='r') use[i]=1,posr[++now]=i;\n\tif(now<cnt) return;\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=2;++i){\n\t\tfor(now=max(now,posr[i]+1);now<=k&&s[now]!='b';++now);\n\t\tif(now>k) return;\n\t\tposb[i]=now;\n\t\tuse[now]=1;\n\t\t++now;\n\t}\n\t\n//\tprintf(\"cnt = %d\\n\",cnt);\n//\tfor(ri i=1;i<=cnt;++i) printf(\"%d \",a[i]);\n//\tputs(\"\");\n\t\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=3;++i){\n\t\tres=a[i]-2;\n\t\tfor(now=max(now,posb[i]+1);now<=k&&res;++now)\n\t\t\tif(!use[now])\n\t\t\t\tuse[now]=1,--res;\n\t\tif(res) return;\n\t}\n\t\n//\tprintf(\"cnt = %d\\n\",cnt);\n//\tfor(ri i=1;i<=cnt;++i) printf(\"%d \",a[i]);\n//\tputs(\"\");\n\t\n\tri j,ans=fac[cnt],c1,c2;\n\tfor(i=1;i<=cnt;i=j+1){\n\t\tfor(j=i;j+1<=cnt&&a[j+1]==a[i];++j);\n\t\tans=(ll)ans*ifac[j-i+1]%mod;\n\t}\n//\tprintf(\"ans = %d\\n\",ans);\n\tc1=n+1;\n\tc2=0;\n\tfor(i=1;i<=cnt;++i){\n\t\tif(a[i]>=2)\n\t\t\tc1+=2;\n\t\tc2+=a[i]*2;\n\t}\n//\tmx=max(mx,c1);\n//\tprintf(\"c1 = %d c2 = %d\\n\",c1,c2); \n\tans=(ll)ans*C(c1,c2)%mod;\n//\tprintf(\"ans = %d\\n\",ans); \n\tadd(Ans,ans);\n}\ninline void dfs(ri i,ri sum){\n\tif(i>1) solve(i-1);\n\tfor(ri j=a[i-1];j;--j)\n\t\tif(sum+j*2-(j>=2?2:0)<=n+1)\n\t\t\ta[i]=j,\n\t\t\tdfs(i+1,sum+j*2-(j>=2?2:0));\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tri i,j,m;\n\tfac[0]=1;\n\tfor(i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=fpow(fac[n],mod-2);\n\tfor(i=n;i;--i) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tm=3*n+1;\n\tfor(i=0;i<=m;++i){\n\t\tc[i][0]=1;\n\t\tfor(j=1;j<=m;++j)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n\ta[0]=n;Ans=1;\n\tdfs(1,0);\n//\tprintf(\"mx = %d m = %d\\n\",mx,m);\n//\tprintf(\"tmp = %d\\n\",tmp);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=75,mo=1e9+7;\nint n,k,_N;\nchar s[N];\nint cnt[N],a[N],mrk[N],f[N],st[N],t,sf[N];\nll Ans,jc[N*10],ny[N*10];\nll power(ll a,ll b=mo-2){\n\tll ans=1;\n\twhile (b){\n\t\tif (b&1)ans=ans*a%mo;\n\t\ta=a*a%mo;\n\t\tb>>=1;\n\t}return ans;\n}\nll C(ll n,ll m){\n//\tif (n<m||m<0)return 0;\n\tassert(n>=m);\n\tassert(m>=0);\n\treturn ny[m]*ny[n-m]%mo*jc[n]%mo;\n}\nint check(int n){\n\tif (n==0){\n\t\tAns++;\n\t\treturn 1;\n\t}\n\tmemset(mrk,0,sizeof mrk);\n\tmemset(f,0,sizeof f);\n\tmemset(sf,0,sizeof sf);\n\tif (!st[n])return 0;\n\tfor (int i=1;i<=n;i++)mrk[st[i]]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tif (a[i]==1)break;\n\t\tfor (int j=max(st[i],f[i-1])+1;s[j];j++)\n\t\t\tif (s[j]=='b'){\n\t\t\t\tf[i]=j;\n\t\t\t\tmrk[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!f[i])return 0;\n\t}\n\tfor (int i=k;i>=1;i--)\n\t\tsf[i]=sf[i+1]+(!mrk[i]);\n\tint s1=0;\n\tfor (int i=n;i>=1;i--){\n\t\ts1+=max(0,a[i]-2);\n\t\tif (sf[f[i]]<s1)return 0;\n\t}\n\tll n1=1,m1=2,ans=1,sum=0;\n\tfor (int i=1;i<=_N;i++)\n\t\tsum+=cnt[i],ans=ans*ny[cnt[i]]%mo;\n\tans=ans*jc[sum]%mo;\n\tfor (int i=1;i<=n;i++)\n\t\tn1+=2*a[i],m1+=2*(a[i]>=2);\n\tans=ans*C(_N+m1-1,n1-1);\n\tAns=(Ans+ans)%mo;\n\treturn 1;\n}\nint ccnt=0;\nvoid dfs(int x,int s,int la){\n\tif (s>n+1)return;\n\tif (!check(x-1))return;\n\tfor (int i=1;i<=la;i++){\n\t\ta[x]=i;\n\t\tcnt[i]++;\n\t\tdfs(x+1,s+max(2,2*(i-1)),i);\n\t\tcnt[i]--;\n\t}\n}\nint main(){\n\tcin>>n>>k;_N=n;\n\tjc[0]=ny[0]=1;\n\tfor (int i=1;i<=700;i++)jc[i]=jc[i-1]*i%mo;\n\tny[700]=power(jc[700]);\n\tfor (int i=700;i>=1;i--)ny[i-1]=ny[i]*i%mo;\n\tscanf(\"%s\",s+1);\n\tfor (int i=1;i<=k;i++){\n\t\tif (s[i]=='r')st[++t]=i;\n\t}\n\tdfs(1,0,n+1);\n\tcout<<Ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int N = 71;\nconst int N2 = 36;\nconst int M = 200;\nconst int MOD = (int)1e9 + 7;\n\nint fact[N], inv_fact[N], binom[M][M], n, m, dp[N2][N2];\nchar s[N];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"F.in\", \"r\", stdin);\n#endif\n    fact[0] = inv_fact[0] = inv_fact[1] = 1;\n    for (int i = 2; i < N; ++ i) {\n        inv_fact[i] = 1LL * (MOD - MOD / i) * inv_fact[MOD % i] % MOD;\n    }\n    for (int i = 1; i < N; ++ i) {\n        fact[i] = 1LL * i * fact[i - 1] % MOD;\n        inv_fact[i] = 1LL * inv_fact[i] * inv_fact[i - 1] % MOD;\n    }\n    for (int i = 0; i < M; ++ i) {\n        binom[i][0] = 1;\n        for (int j = 1; j <= i; ++ j) {\n            binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % MOD;\n        }\n    }\n    scanf(\"%d%d%s\", &n, &m, s);\n    int result = 1;\n    for (int ab = 0; ab * 2 <= m; ++ ab) {\n        for (int a = !ab; ab * 2 + a <= m; ++ a) {\n            std::vector<int> sz(ab);\n            int cnt_ab = 0, cnt_a = 0;\n            for (int i = 0; i < m; ++ i) {\n                if (s[i] == 'r') { // A\n                    if (cnt_ab + cnt_a < ab + a) {\n                        cnt_a ++;\n                    } else if (cnt_ab) {\n                        sz[ab - cnt_ab] ++;\n                    }\n                } else {\n                    if (cnt_a && cnt_ab < ab) {\n                        cnt_a --;\n                        cnt_ab ++;\n                    } else if (cnt_ab) {\n                        sz[ab - cnt_ab] ++;\n                    }\n                }\n            }\n            if (cnt_ab != ab || cnt_a != a) {\n                continue;\n            }\n            for (int i = 1; i < ab; ++ i) {\n                sz[i] += sz[i - 1];\n            }\n            memset(dp, 0, sizeof(dp));\n            dp[0][0] = 1LL * fact[ab + a] * inv_fact[a] % MOD;\n            for (int q = 0; 2 * q - 1 <= n; ++ q) {\n                for (int cnt = ab; cnt >= 0; -- cnt) {\n                    for (int used = (n + 1 >> 1) - cnt; used >= 0; -- used) {\n                        for (int k = 1; cnt + k <= ab && (cnt + k + used + k * q << 1) - 1 <= n && used + k * q <= sz[cnt + k - 1]; ++ k) {\n                            update(dp[cnt + k][used + k * q], 1LL * dp[cnt][used] * inv_fact[k] % MOD);\n                        }\n                    }\n                }\n            }\n            for (int used = (n + 1 >> 1) - ab; used >= 0; -- used) {\n                int parts = ab + a;\n                int occ = (used * 2 + ab) + a + (parts - 1);\n                int balls = n - occ;\n                int boxes = (2 * used + 3 * ab) + a + (parts + 1);\n                update(result, 1LL * binom[balls + boxes - 1][boxes - 1] * dp[ab][used] % MOD);\n            }\n        }\n    }\n    printf(\"%d\\n\", result);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7;\ninline int inc(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline void add(int &x, int y) {y += x; x = y >= MOD ? y - MOD : y;}\ninline int mul(int x, int y) {return (ll)x * y % MOD;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nstring s;\nint n, k;\n\n\n#define N n\n#define K k\nbool C(vector<int> &v) {\n\tbool used[70] = {};\n\tint pos[70];\n\tint now= 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\twhile (now < s.size()) {\n\t\t\tif (s[now] == 'r') break;\n\t\t\tnow++;\n\t\t}\n\t\tif (now == s.size()) return 0;\n\t\tused[now] = 1;\n\t\tpos[i] = now;\n\t\tnow++;\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] == 1) break;\n\t\tnow = pos[i] + 1;\n\t\twhile (now < s.size()) {\n\t\t\tif (!used[now] && s[now] == 'b') break;\n\t\t\tnow++;\n\t\t}\n\t\tif (now == s.size()) return 0;\n\t\tused[now] = 1;\n\t\tpos[i] = now;\n\t}\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (v[i] <= 2) break;\n\t\tint cnt = 0;\n\t\tnow = pos[i] + 1;\n\t\twhile (now < s.size()) {\n\t\t\tif (!used[now]) {\n\t\t\t\tused[now] = 1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif (cnt >= v[i] - 2) break;\n\t\t\tnow++;\n \t\t}\n\t\tif (now == s.size()) return 0;\n\t}\n\treturn 1;\n}\n\nbool check(vector<int> &v)\n{\n\tstatic int pos[75], use[75];\n\tmemset(pos, 0, sizeof pos);\n\tmemset(use, 0, sizeof use);\n\tint now = 0;\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\twhile (now < k)\n\t\t{\n\t\t\tif (s[now] == 'r') break;\n\t\t\tnow ++;\n\t\t}\n\t\tif (now == k) return 0;\n\t\tpos[i] = now, use[now] = 1;\n\t\tnow ++;\n\t}\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\tif (v[i] < 2) continue;\n\t\tnow = pos[i] + 1;\n\t\twhile (now < k)\n\t\t{\n\t\t\tif (!use[now] && s[now] == 'b') break;\n\t\t\tnow ++;\n\t\t}\n\t\tif (now == k) return 0;\n\t\tuse[now] = 1, pos[i] = now;\n\t\tnow ++;\n\t}\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\tif (v[i] < 3) continue;\n\t\tint cnt = 0;\n\t\tnow = pos[i] + 1;\n\t\twhile (now < k)\n\t\t{\n\t\t\tif (!use[now])\n\t\t\t{\n\t\t\t\t++ cnt, use[now] = 1;\n\t\t\t\tif (cnt + 2 == v[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow ++;\n\t\t}\n\t\tif (now == k) return 0;\n\t}\n\treturn 1;\n}\n\nint fac[205], ifac[205];\n\ninline int binom(int x, int y)\n{\n\tif (y > x || y < 0) return 0;\n\treturn mul(mul(fac[x], ifac[y]), ifac[x - y]);\n}\n\nint Getans(vector<int> &v)\n{\n\tif (v.empty()) return 1;\n\tif (v.size() == 1)\n\t{\n\t\tif (v[0] == 1) return binom(n + 1, 2);\n\t\telse return binom(n + 3, v[0] * 2);\n\t}\n\tstatic int buc[75];\n\tmemset(buc, 0, sizeof buc);\n\tfor (int i = 0; i < v.size(); i ++)\n\t\tbuc[v[i]] ++;\n\tint res = fac[v.size()];\n\tfor (int i = 1; i <= n; i ++)\n\t\tres = mul(res, ifac[buc[i]]);\n\tint num = n + 1, pos = 0;\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\tpos += v[i] * 2;\n\t\tif (v[i] >= 2) num += 2;\n\t}\n\treturn mul(res, binom(num, pos));\n}\n\nint ans;\nvoid dfs(int now, int remain, int pre, vector<int> &v)\n{\n\tif (check(v)) add(ans, Getans(v));\n\tfor (int i = min(remain, pre); i >= 1; i --)\n\t{\n\t\tint cnt = i == 1 ? 1 : ((i - 1) * 2 - 1); // BR...RB\n\t\tif (now + cnt + max(0, (int)v.size() - 1) > n) continue;\n\t\tv.push_back(i);\n\t\tdfs(now + cnt, remain - i, i, v);\n\t\tv.pop_back();\n\t}\n}\n\nint main()\n{\n\tcin >> n >> k >> s;\n\tfac[0] = ifac[0] = 1;\n\tfor (int i = 1; i <= 200; i ++) fac[i] = mul(fac[i - 1], i);\n\tifac[200] = qpow(fac[200], MOD - 2);\n\tfor (int i = 200; i >= 1; i --) ifac[i - 1] = mul(ifac[i], i);\n\tvector<int> foo(0); ans = 0;\n\tdfs(0, k, k, foo);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nint n,k;\nchar s[110];\nint nxt[110][2];\nint fac[410],inv[410];\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(long long)ans*t%Mod;\n\t\tt=(long long)t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tint N=400;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=(long long)inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\treturn (long long)fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint ans;\nint f[110],g[110],h[110];\nbool vis[110];\nvoid calc(int num)\n{\n\t//check\n\tfor(int i=1;i<=k;i++)\n\t\tvis[i]=false;\n\tint cur=nxt[1][0],cnt=0;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1&&cnt==0)\n\t\t\tcnt=num-i+1;\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;h[i]=cur;\n\t\tcur=nxt[cur+1][0];\n\t}\n\tcur=nxt[1][1];\n\tfor(int i=1;i<=num-cnt;i++)\n\t{\n\t\twhile(cur<=k&&(cur<h[i]||vis[cur]))\n\t\t\tcur=nxt[cur+1][1];\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;\n\t\tg[i]=cur;\n\t}\n\tint now=num-cnt;\n\tcur=f[now];\n\twhile(cur<=2&&now>0){\n\t\tnow--;\n\t\tcur=f[now];\n\t}\n\tfor(int i=k;i>=1;i--)\n\t\tif(!vis[i]){\n\t\t\tif(now<=0)break;\n\t\t\tif(i<g[i])return ;\n\t\t\tvis[i]=true;\n\t\t\tcur--;\n\t\t\twhile(cur<=2&&now>0){\n\t\t\t\tnow--;\n\t\t\t\tcur=f[now];\n\t\t\t}\n\t\t}\n\tif(now>0)return ;\n\tint sum=fac[num];cur=0;\n\tint cntb=0,cntr=0,cntw=num-1;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1)cntr++;\n\t\telse cntr+=f[i]-2,cntb+=f[i]-1;\n\t\tif(i==1||f[i]==f[i-1])cur++;\n\t\telse{\n\t\t\tsum=(long long)sum*inv[cur]%Mod;\n\t\t\tcur=1;\n\t\t}\n\t}\n\tsum=(long long)sum*inv[cur]%Mod;\n\tint cntB=(num-cnt)*2+1;//rbr->2(num-cnt)  ...rw->1\n\tif(cntb+cntr+cntw>n)return ;\n\tsum=(long long)sum*C(n+cntB,cntb+cntr+cntw+cntB)%Mod;\n//\tfor(int i=1;i<=num;i++)\n//\t\tprintf(\"%d \",f[i]);\n//\tprintf(\":%d\\n\",sum);\n\tans=(ans+sum)%Mod;\n\treturn ;\n}\nvoid dfs(int x,int rest,int rest2,int cnt)\n{\n\tif(rest<0)return ;\n\tif(x==0){\n\t\tcalc(cnt);\n\t\treturn ;\n\t}\n\tfor(int i=0;i*x<=rest2;i++)\n\t{\n\t\tif(i>0)f[cnt+i]=x;\n\t\tdfs(x-1,rest-i*(x==1?1:(2*x-3)),rest2-i*x,cnt+i);\n\t}\n\treturn ;\n}\nint main()\n{\n//\tf[1]=2;\n//\tcalc(2);\n//\tprintf(\"%d\\n\",ans);\n\t\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tnxt[k+1][0]=nxt[k+1][1]=k+1;\n\tfor(int i=k;i>=1;i--)\n\t{\n\t\tnxt[i][0]=nxt[i+1][0];\n\t\tnxt[i][1]=nxt[i+1][1];\n\t\tif(s[i]=='r')nxt[i][0]=i;\n\t\telse nxt[i][1]=i;\n\t}\n\tinit();\n\tdfs(k,n,k,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n/*\n3 4\nrbrb\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K,C[1005][1005],L[75],fac[1005],invfac[1005],cnt;\nint sum[75],pos[75],tot,ans,matc[75];\nchar s[75];\nbool vis[75];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nbool check() {\n    if(tot < cnt) return false;\n    memset(sum,0,sizeof(sum));\n    int p = 1;\n    for(int i = cnt ; i >= 1 ; --i) {\n\tsum[pos[i]]++;\n\tif(L[p] >= 2) {\n\t    if(!matc[pos[i]]) return false;\n\t    sum[matc[pos[i]]] += L[p] - 1;\n\t}\n\t++p;\n    }\n    for(int i = K ; i >= 1 ; --i) {\n\tsum[i] += sum[i + 1];\n\tif(sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\nbool dfs(int pre,int dep,int len) {\n    cnt = dep;\n    if(!check()) return false;\n    int k = 1 + cnt;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] == 1) ++k;\n        else k += 2 * L[i] - 1;\n    }\n    int res = C[N - len + k - 1][k - 1];\n    res = mul(res,fac[cnt]);\n    int t = 0;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] != L[i - 1]) {\n            res = mul(res,invfac[t]);\n            t = 0;\n        }\n        ++t;\n    }\n    res = mul(res,invfac[t]);\n    update(ans,res);\n    if(dep + 1 > tot) return true;\n    for(int i = pre ; i <= 70 ; ++i) {\n        int tl = len;\n        if(dep != 0) ++tl;\n        if(i == 1 || i == 2) tl += 1;\n        else tl += i - 2 + i - 1;\n        if(tl > N) break;\n        L[dep + 1] = i;\n        if(!dfs(i,dep + 1,tl)) break;\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);read(K);\n    scanf(\"%s\",s + 1);\n    C[0][0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) {\n        C[i][0] = 1;\n        for(int j = 1 ; j <= i ; ++j) {\n            C[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n        }\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000] = fpow(fac[1000],MOD - 2);\n    for(int i = 999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    tot = 0;\n    for(int i = 1 ; i <= K ; ++i) {\n        if(s[i] == 'r') {\n\t    pos[++tot] = i;\n\t\n\t    for(int j = i + 1 ; j <= K ; ++j) {\n\t\tif(s[j] == 'b' && !vis[j]) {matc[i] = j;vis[j] = 1;break;}\n\t    }\n\t}\n    }\n    dfs(1,0,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 500;\nconst int mod = 1e9 + 7;\n\nint n, k, ans;\nint a[N], vis[N], c[N][N];\nlong long fac[N], inv[N], fav[N];\nchar s[N];\n\nvoid check(int len, int num) {\n\tmemset(vis, 0, sizeof(vis));\n\tint p1 = 1, p2 = 1, p3 = 1;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tif (s[i] == 'r') {\n\t\t\tif (p1 <= len) vis[p1++] = 1;\n\t\t\telse {\n\t\t\t\twhile (p3 <= len && vis[p3] == a[p3]) ++p3;\n\t\t\t\tvis[p3]++;\n\t\t\t}\n\t\t}\n\t\telse if (s[i] == 'b') {\n\t\t\twhile (p2 <= len && (vis[p2] >= 2 || a[p2] == 1)) ++p2;\n\t\t\tif (p2 <= len && vis[p2] == 1) vis[p2++] = 2;\n\t\t\telse {\n\t\t\t\twhile (p3 <= len && vis[p3] == a[p3]) ++p3;\n\t\t\t\tvis[p3]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= len; ++i)\n\t\tif (vis[i] != a[i]) return;\n\tlong long mul = fac[len], cnt = len + 1;\n\tfor (int i = 1, j; i <= len; i = j + 1) {\n\t\tj = i;\n\t\twhile (a[j] == a[j + 1] && j < len) ++j;\n\t\tmul = mul * fav[j - i + 1] % mod;\n\t\tcnt += (j - i + 1) * (a[i] * 2 - 1);\n\t}\n\tmul = mul * c[n - num + cnt - 1][cnt - 1] % mod;\n\tans += mul;\n\tif (ans >= mod) ans -= mod;\n}\n\nvoid dfs(int x, int len, int num) {\n\tif (num > n) return;\n\tcheck(len, num);\n\tfor (int i = 1; i <= x; ++i) {\n\t\ta[len + 1] = i;\n\t\tdfs(i, len + 1, num + (i > 1 ? i * 2 - 3 : 1) + (len > 0));\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &k);\n\tscanf(\"%s\", s + 1);\n\tc[0][0] = 1;\n\tfor (int i = 1; i < N; ++i) {\n\t\tc[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tfac[0] = fav[0] = inv[0] = 1;\n\tfac[1] = fav[1] = inv[1] = 1;\n\tfor (int i = 2; i < N; ++i) {\n\t\tinv[i] = - mod / i * inv[mod % i] % mod + mod;\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tfav[i] = fav[i - 1] * inv[i] % mod;\n\t}\n\tdfs(k, 0, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint f[2][72][72],t;\n//f[i][j][k]\n//i:上次选的lenb；j:r段数；k:∑b\nchar S[72];\nint to[72],pre[72],Sr[72],fact[1010],ifact[1010];\nint C(int n,int m){return 1ll*fact[n]*ifact[n-m]%mod*ifact[m]%mod;}\nint Ins(int n,int m){\n\tif(!m)return 1;\n\tif(!n)return 0;\n\treturn C(n+m-1,n-1);\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),K=gi(),m=0;\n\tscanf(\"%s\",S+1);\n\tfor(int i=1;i<=K;++i)Sr[i]=Sr[i-1]+(S[i]=='r');\n\tfor(int i=1,j=1;i<=K;++i)\n\t\tif(S[i]=='r'){\n\t\t\twhile(j<=K&&(j<=i||S[j]=='r'))++j;\n\t\t\tto[++m]=K-j;if(j>K)to[m]=-1e9;++j;\n\t\t\tpre[m]=Sr[std::min(j,K)-1];\n\t\t}\n\tfact[0]=1;for(int i=1;i<=1000;++i)fact[i]=1ll*fact[i-1]*i%mod;\n\tifact[1000]=pow(fact[1000],mod-2);for(int i=1000;i;--i)ifact[i-1]=1ll*ifact[i]*i%mod;\n\tint ans=1;\n\tfor(int d=1;d<=m&&d<=n;++d){\n\t\tfor(int o0=0;o0<=m;++o0){\n\t\t\tmemset(f,0,sizeof f);\n\t\t\tf[t][o0][0]=ifact[o0];\n\t\t\tfor(int i=1;i<=n;++i){\n\t\t\t\tmemset(f[!t],0,sizeof f[!t]);\n\t\t\t\tfor(int j=0;j<=d;++j)\n\t\t\t\t\tfor(int k=0;k<=n;++k)\n\t\t\t\t\t\tif(f[t][j][k])\n\t\t\t\t\t\t\tfor(int o=0,nj=j,nk=k;nj<=d&&nk<=n;++o,++nj,nk+=i){\n\t\t\t\t\t\t\t\tif(o&&to[d-nj+1]-std::max(0,d-pre[d-nj+1])-(nj-1-o0)<nk-nj+o0)break;\n\t\t\t\t\t\t\t\tinc(f[!t][nj][nk],1ll*ifact[o]%mod*f[t][j][k]%mod);\n\t\t\t\t\t\t\t}\n\t\t\t\tt^=1;\n\t\t\t}\n\t\t\tfor(int k=0;k<=n;++k)\n\t\t\t\tif(f[t][d][k]){\n\t\t\t\t\tint res=0;\n\t\t\t\t\tfor(int p=d-1;p<=n-k*2+d-o0*2;++p)\n\t\t\t\t\t\tinc(res,1ll*f[t][d][k]*Ins(d+1,p-d+1)%mod*Ins(k*2+d,n-k*2+d-p-o0*2)%mod);\n\t\t\t\t\tinc(ans,res=1ll*fact[d]*res%mod);\n\t\t\t\t\t//fprintf(stderr,\"%d %d %d %d %d\\n\",o0,d,k,f[t][d][k],res);\n\t\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint cnt = 0, N, K, fac[109], inv[109], c[109][109], cntRB[109][109], cntWRB[109][109], oldDp[109], currDp[109], ways[420009];\nchar sir[109];\nbool dp[420009];\nvector < int > curr, arrs[420009], edge[420009][2];\nvector < pair < int, int > > sons[420009];\nmap < vector < int >, int > mp;\nvector < int > cc[2];\nconst int mod = 1e9 + 7;\n\nint add (int x, int y) {int ans = x + y; if (ans >= mod) ans -= mod; return ans;}\nint subtract (int x, int y) {if (x >= y) return x - y; return x - y + mod;}\nint mul (int x, int y) {return 1LL * x * y % mod;}\nvoid adto (int &x, int y) {x += y; if (x >= mod) x -= mod;}\n\nint power (int a, int b)\n{\n    int p = 1;\n    for (int i=0; (1<<i) <= b; i++)\n    {\n        if (b & (1 << i)) p = mul (p, a);\n        a = mul (a, a);\n    }\n    return p;\n}\n\nvoid back (int lst, int sum, int papa)\n{\n    if (sum <= N)\n    {\n        /*for (auto j : curr)\n            printf (\"%d \", j);\n        printf (\"\\n\");*/\n        mp[curr] = ++cnt, arrs[cnt] = curr;\n        sons[papa].push_back ({cnt, lst});\n    }\n    if (sum > N) return ;\n    int aux = cnt;\n    for (int i=lst;; i++)\n    {\n        int ad = (curr.empty () ? 0 : 1) + (i == 0 ? 1 : 2 * i - 1);\n        if (ad + sum > N) break;\n        curr.push_back (i), back (i, sum + ad, aux);\n        curr.erase (curr.begin () + curr.size () - 1);\n    }\n}\n\nvoid print (int id, string s) {printf (\"[\");for (auto j : arrs[id]) printf (\"%d\", j); printf (\"]%s\", s.c_str ());}\n\nvoid buildTransitionGraph ()\n{\n    for (int id = 1; id <= cnt; id ++)\n        for (int type = 0; type < 2; type ++)\n        {\n            if (type == 0)\n            {\n                ///Red, add 0 or increase non zero by 1\n                vector < int > curr;\n                curr.push_back (0);\n                for (auto it : arrs[id])\n                    curr.push_back (it);\n                if (mp.count (curr))\n                    edge[id][type].push_back (mp[curr]);\n\n                curr = arrs[id];\n                for (int i=0; i<curr.size (); i++)\n                    if ((i == curr.size () - 1 || curr[i] != curr[i + 1]) && curr[i] > 0)\n                    {\n                        curr[i] ++;\n                        if (mp.count (curr))\n                            edge[id][type].push_back (mp[curr]);\n                        curr[i] --;\n                    }\n            }\n            else\n            {\n                ///Blue, add 1 to anything\n                vector < int > curr = arrs[id];\n                for (int i=0; i<curr.size (); i++)\n                    if (i == curr.size () - 1 || curr[i] != curr[i + 1])\n                    {\n                        curr[i] ++;\n                        if (mp.count (curr))\n                            edge[id][type].push_back (mp[curr]);\n                        curr[i] --;\n                    }\n            }\n        }\n/*    for (int id = 1; id<=cnt; id++)\n    {\n        print (id, \": \");\n        for (int type = 0; type < 2; type ++, printf (\" | \"))\n            for (auto j : edge[id][type])\n                print (j, \", \");\n        printf (\"\\n\");\n    }*/\n}\n\nvoid buildDp ()\n{\n    dp[1] = 1;\n    cc[0].push_back (1), cc[1].push_back (1);\n    for (int i=1; i<=K; i++)\n    {\n        int type = (sir[i] == 'b');\n        vector < int > newCC;\n        for (auto j : cc[type])\n            for (auto k : edge[j][type])\n                if (dp[k] == 0)\n                    dp[k] = 1, newCC.push_back (k);\n        cc[type].clear ();\n        for (int j=0; j<2; j++)\n            for (auto k : newCC)\n                cc[j].push_back (k);\n    }\n}\n\nvoid binomialCoefficients ()\n{\n    c[0][0] = 1;\n    for (int i=1; i<=100; i++)\n    {\n        c[i][0] = 1;\n        for (int j=1; j<=i; j++)\n            c[i][j] = add (c[i - 1][j - 1], c[i - 1][j]);\n    }\n    fac[0] = 1;\n    for (int i=1; i<=100; i++)\n        fac[i] = mul (fac[i - 1], i);\n    for (int i=0; i<=100; i++)\n        inv[i] = power (fac[i], mod - 2);\n}\n\nvoid computeCntRB ()\n{\n    for (int l=1; l<=N; l++)\n    {\n        cntRB[l][0] = 1;\n        for (int i=1; 2 * i - 1 <= l; i++)\n            cntRB[l][i] = c[l + 1][2 * i];\n    }\n    for (int l=1; l<=N; l++)\n        for (int j=0; j<=N; j++)\n            for (int k=1; k<l; k++)\n                adto (cntWRB[l][j], cntRB[l - k][j]);\n}\n\nint getCount (int id)\n{\n    if (id == 1) return 1;\n    vector < int > curr = arrs[id];\n    ///compute dp\n    /*for (int i=1; i<=N; i++)\n        currDp[i] = add (cntWRB[i][curr[0]], cntRB[i][curr[0]]);///can even have no white\n    for (int currStep = 1; currStep < curr.size (); currStep ++)\n    {\n        int l = curr[currStep];\n        memcpy (oldDp, currDp, sizeof (currDp));\n        memset (currDp, 0, sizeof (currDp));\n        for (int i=1; i<=N; i++)\n            if (oldDp[i] != 0)\n                for (int j=2 * l; i + j<=N; j++)\n                    adto (currDp[i + j], mul (oldDp[i], cntWRB[j][l]));///must have a white to separate\n    }*/\n    ///number of anagrams\n    int prms = fac[curr.size ()];\n    for (int i=0; i<curr.size (); i++)\n    {\n        int j;\n        for (j=i; j<curr.size (); j++)\n            if (curr[j] != curr[i]) break;\n        j --;\n        ///[i, j]\n        prms = mul (prms, inv[j - i + 1]);\n        ///\n        i = j;\n    }\n    return mul (ways[id], prms);\n}\n\nvoid dfs (int node)\n{\n    if (node == 1)\n    {\n        for (auto pp : sons[node])\n        {\n            int l = pp.second, id = pp.first;\n            for (int i=1; i<=N; i++)\n                currDp[i] = add (cntWRB[i][l], cntRB[i][l]);///can even have no white\n            dfs (id);\n        }\n        return ;\n    }\n    int oldDp[109];\n    memcpy (oldDp, currDp, sizeof (currDp));\n    for (auto pp : sons[node])\n        {\n            int l = pp.second, id = pp.first;\n            memset (currDp, 0, sizeof (currDp));\n            for (int i=1; i<=N; i++)\n                if (oldDp[i] != 0)\n                    for (int j=2 * l; i + j<=N; j++)\n                        adto (currDp[i + j], mul (oldDp[i], cntWRB[j][l]));///must have a white to separate\n            dfs (id);\n            memcpy (currDp, oldDp, sizeof (oldDp));\n        }\n    ways[node] = 0;\n    for (int i=1; i<=N; i++)\n        adto (ways[node], currDp[i]);\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d %d\\n\", &N, &K);\nscanf (\"%s\", sir + 1);\nback (0, 0, 0);\nbuildTransitionGraph ();\nbuildDp ();\nbinomialCoefficients ();\ncomputeCntRB ();\ndfs (1);\nint ans = 0;\nfor (int i=1; i<=cnt; i++)\n    if (dp[i])\n    {\n        int curr = getCount (i);\n//        print (i, \" -> \"), printf (\"%d\\n\", curr);\n        adto (ans, curr);\n    }\nprintf (\"%d\\n\", ans);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nint dp[111][111];\n\nint calc(){\n    /*\n    if(X[0]==1){\n        if(X.size()>R)return 0;\n        int n=X.size();\n        int y=N-(2*n+1);\n        return nCk(2*n+y,y);\n    }*/\n    int n=X.size();\n    if(n>R)return 0;\n    int nr=R-n,nb=B;\n    for(int i=0;i<X.size();i++){\n        int pos=r[R-i];\n        while(nb>0&&b[nb]<pos)nb--;\n        if(X[i]==1)continue;\n        if(nb==0)return 0;\n        while(nr>0&&r[nr]<b[nb])nr--;\n        nb--;\n        rep(t,X[i]-2){\n            if(i+1<n&&nb&&b[nb]<r[R-i-1]){\n                nb--;\n                continue;\n            }\n            if(nr){\n                nr--;\n                continue;\n            }\n            if(nb){\n                nb--;\n                continue;\n            }\n            return 0;\n        }\n    }\n    vpint ei;\n    rep(i,X.size()){\n        if(ei.size()==0||ei.back().fi!=X[i])ei.pb({X[i],1});\n        else ei.back().se++;\n    }\n\n    int latte=0;\n    int s=0;\n    for(int i=0;i<X.size();i++){\n        if(X[i]==1){\n            latte++;\n            s++;\n        }\n        else{\n            latte+=X[i]*2-3;\n            s+=X[i]*2-3+2;\n        }\n    }\n\n    int ret=0;\n    for(int k=0;latte+k<=N;k++){\n        int y=N-latte-k;\n        add(ret,nCk(y+1,n)*nCk(s-1+k,k)%mod);\n    }\n    ret=ret*fact[n]%mod;\n    rep(i,ei.size())ret=ret*inv[ei[i].se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, F[77][77][77][77], G[77][77], H[77][77], S[77], Fac[77], Rev[77];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nll C(ll x, ll y) {\n    if(x < 0 || y < 0 || x < y) return 0;\n    return Fac[x] * Rev[y] % P * Rev[x - y] % P;\n}\n\nll calc(ll x, ll n) {\n    ll ans = 0, nw = 1;\n    for(int i = 1; i <= n; i++) {\n        nw = nw * (x - i + 1) % P;\n        add(ans, nw * Rev[i] % P * H[n][i]);\n    }\n    return ans;\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 77; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 76; i >= 0; i--) Rev[i] = i == 76 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    G[0][0] = 1;\n    for(int s = 0; s <= 71; s++)\n        for(int i = 0; i <= 71; i++) {\n            add(G[i + 1][s], G[i][s]);\n            for(int j = i + 2; j <= 71; j++)\n                add(G[j][s + 1], G[i][s]);\n        }\n    //for(int i = 0; i <= 71; i++)\n    //    for(int j = 1; j <= 71; j++) add(G[i][j], G[i][j - 1]);\n    H[0][0] = 1;\n    for(int i = 0; i <= 71; i++)\n        for(int j = i + 1; j <= 71; j++)\n            for(int s = 0; s <= 71; s++)\n                add(H[j][s + 1], H[i][s] * Rev[j - i]);\n    int totr = 0, totb = 0;\n    for(int i = 1; i <= K; i++) if(ch[i] == 'r') {\n        totr++;\n        S[totr] = totb + totr;\n    } else totb++;\n    S[totr + 1] = K + 1;\n    for(int i = totr + 2; i < 77; i++) S[i] = K + 2;\n    F[0][K][0][S[1] - 1] = 1;\n    for(int i = 0; i <= n; i++)\n        for(int p = 0; p <= K/* && p <= i / 2*/; p++)\n            for(int k = 0; k <= i; k++)\n                for(int t = 0; t <= K; t++) if(F[i][p][k][t]) {\n                    int nw = F[i][p][k][t];\n                    //add(F[i + 1][p][k][t], nw);\n                    for(int j = 1; j <= n; j++)\n                        for(int s = 0; s < p; s++) {\n                            int w = t;\n                            for(int J = 1; i + (j + 1) * J <= n + 1; J++) {\n                                w = max(w + (s + 1), S[k + 1 + J] - 1);\n                                if(w > K) break;\n                                if(J >= 2) {\n                                    J++;\n                                    J--;\n                                }\n                                add(F[i + (j + 1) * J][s][k + J][w], nw * calc(G[j + 1][s], J));\n                            }\n                        }\n                }\n    ll ans = 0;\n    for(int i = 0; i <= n + 1; i++)\n        for(int p = 0; p <= K; p++)\n            for(int k = 0; k <= n + 1; k++)\n                for(int t = 0; t <= K; t++) if(F[i][p][k][t]) {\n                    t++;\n                    t--;\n                    add(ans, F[i][p][k][t] * Fac[n + 1 - i + k] % P * Rev[n + 1 - i]);\n                }\n    /*for(int i = 0; i <= n; i++)\n        for(int k = 0; k <= i && k <= K; k++)\n            for(int r = k; r <= totr; r++)\n                for(int b = S[r]; b <= totb; b++) if(F[i][k][r][b]) {\n                    int nw = F[i][k][r][b];\n                    add(F[i + 1][k][r][b], nw);\n                    for(int j = i + 2; j <= n + 1; j++) {\n                        for(int rr = 0; r + rr <= totr; rr++) {\n                            for(int bb = 0; b + bb <= totb; bb++) {\n                                if(bb == 0) {\n                                    add(F[j][k + 1][r + rr + 1][b], nw);\n                                } else {\n                                    add(F[j][k + 1][r + rr + 1][b + bb], nw * G[j - i][bb + rr + 1]);\n                                }\n                            }\n                        }\n                    }\n                }\n    int ans = 0;\n    for(int i = 0; i <= K + 1; i++) add(ans, F[n + 1][i][totr][totb]);*/\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar s[128];\nbool vis[128];\nint a[128];\nint wz[128];\nint num[128];\nint n,k;\nint jc[512],injc[512];\nint answer=0;\nbool sol(int m)\n{\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tvis[i]=false;\n\t}\n\tint now=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\twhile(s[now]=='b'||vis[now])\n\t\t{\n\t\t\tnow++;\n\t\t\tif(now==k)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\twz[i]=now;\n\t\tvis[now]=true;\n\t}\n\tnow=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\twhile(s[now]=='r'||vis[now]||now<wz[i])\n\t\t{\n\t\t\tnow++;\n\t\t\tif(now==k)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\twz[i]=now;\n\t\tvis[now]=true;\n\t}\n\tnow=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(a[i]<=2)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint rm=a[i]-2;\n\t\twhile(rm--)\n\t\t{\n\t\t\twhile(vis[now]||now<wz[i])\n\t\t\t{\n\t\t\t\tnow++;\n\t\t\t\tif(now==k)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twz[i]=now;\n\t\t\tvis[now]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tnum[i]=0;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tnum[a[i]]++;\n\t}\n\tint ans=jc[m];\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tans=(long long)ans*injc[num[i]]%1000000007;\n\t}\n\tint nums=m+1;\n\tint nume=2;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(a[i]==1)\n\t\t{\n\t\t\tnums++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnume+=2;\n\t\t\tnums+=(a[i]<<1)-1;\n\t\t}\n\t}\n\tint u=n+nume-1;\n\tint d=nums-1;\n\tif(d>u)\n\t{\n\t\treturn false;\n\t}\n\tans=(long long)ans*jc[u]%1000000007;\n\tans=(long long)ans*injc[d]%1000000007;\n\tans=(long long)ans*injc[u-d]%1000000007;\n\tanswer+=ans;\n\tif(answer>=1000000007)\n\t{\n\t\tanswer-=1000000007;\n\t}\n\treturn true;\n}\nvoid dfs(int wz,int mx,int rm)\n{\n\tif(!sol(wz))\n\t{\n\t\treturn;\n\t}\n\tif(mx>rm)\n\t{\n\t\tmx=rm;\n\t}\n\tfor(int i=1;i<=mx;i++)\n\t{\n\t\ta[wz]=i;\n\t\tdfs(wz+1,i,rm-i);\n\t}\n}\nint main()\n{\n\tinjc[1]=1;\n\tfor(int i=2;i<=300;i++)\n\t{\n\t\tinjc[i]=(long long)1000000007/i*injc[1000000007%i]%1000000007;\n\t\tinjc[i]=1000000007-injc[i];\n\t}\n\tjc[0]=1;\n\tinjc[0]=1;\n\tfor(int i=1;i<=300;i++)\n\t{\n\t\tjc[i]=(long long)jc[i-1]*i%1000000007;\n\t\tinjc[i]=(long long)injc[i-1]*injc[i]%1000000007;\n\t}\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s);\n\tdfs(0,k,k);\n\tprintf(\"%d\\n\",answer);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, G[77][77], H[77][77], S[77], Fac[333], Rev[333];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nll C(ll x, ll y) {\n    if(!y) return 1;\n    if(x < 0 || y < 0 || x < y) return 0;\n    return Fac[x] * Rev[y] % P * Rev[x - y] % P;\n}\n\nll calc(ll x, ll n) {\n    ll ans = 0, nw = 1;\n    for(int i = 1; i <= n; i++) {\n        nw = nw * (x - i + 1) % P;\n        add(ans, nw * Rev[i] % P * H[n][i]);\n    }\n    return ans;\n}\n\nint X[77], ans = 0;\n\nvoid calc(int sz) {\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    int tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, C(r + rw - 1, r) * C(b + bw - 1, b) % P * C(sz + (t - r - b), sz) % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int fir) {\n    if(tbr > K) return;\n    calc(x - 1);\n    while(fir <= K && ch[fir] != 'r') fir++;\n    if(fir > K) return;\n    X[x] = 1;\n    Search(x + 1, 1, tbr + 1, fir + 1);\n    while(fir <= K && ch[fir] != 'b') fir++;\n    if(fir <= K) for(int i = 2; i <= lst && i + tbr <= K; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, fir);\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    G[0][0] = 1;\n    for(int s = 0; s <= 71; s++)\n        for(int i = 0; i <= 71; i++) {\n            add(G[i + 1][s], G[i][s]);\n            for(int j = i + 2; j <= 71; j++)\n                add(G[j][s + 1], G[i][s]);\n        }\n    H[0][0] = 1;\n    for(int i = 0; i <= 71; i++)\n        for(int j = i + 1; j <= 71; j++)\n            for(int s = 0; s <= 71; s++)\n                add(H[j][s + 1], H[i][s] * Rev[j - i]);\n    int totr = 0, totb = 0;\n    for(int i = 1; i <= K; i++) if(ch[i] == 'r') {\n        totr++;\n        S[totr] = totb + totr;\n    } else totb++;\n    S[totr + 1] = K + 1;\n    for(int i = totr + 2; i < 77; i++) S[i] = K + 2;\n    Search(1, K, 0, 1);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int p=1000000007;\n\nint c[300][300],g[100],h[100];\nchar b[100];\nint i,j,k,l,m,n,r,s,t;\n\ninline void pre()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",b+1);\n\tfor (i=0;i<=250;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t\tif ((j==0) || (j==i))\n\t\t\t\tc[i][j]=1;\n\t\t\telse\n\t\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%p;\n\treturn;\n}\n\ninline void calc()\n{\n\tfor (i=1;i<=n;i++)\n\t\th[i]=g[i];\n\tt=0;\n\tfor (i=1,k=1,l=1;i<=n;i++)\n\t\tif ((b[i]=='r') && (h[k]>0))\n\t\t\th[k]--,k++;\n\t\telse\n\t\tif ((b[i]=='b') && (h[l]>0) && (l<k))\n\t\t\th[l]--,t=t+h[l],l++;\n\t\telse\n\t\tif (t>0)\n\t\t\tt--;\n\tif ((h[k]) || (h[l]) || (t))\n\t\treturn;\n\tr=1;\n\tfor (i=1;g[i];i=j)\n\t{\n\t\tfor (j=i;g[i]==g[j];j++);\n\t\tr=1LL*r*c[j-1][i-1]%p;\n\t\tif (g[i]==1)\n\t\t\tt=t+j-i;\n\t\telse\n\t\t\tt=t+(j-i)*(2*g[i]-3);\n\t}\n\tt=t+k-2;\n\tif (n-t<0)\n\t\treturn;\n\ts=(s+1LL*r*c[n+2*l-1][t+2*l-1])%p;\n\treturn;\n}\n\ninline void dfs(int w,int x,int y,int z)\n{\n\tif (w<0)\n\t\treturn;\n\tif (w<=n)\n\t\tcalc();\n\tif (x)\n\t{\n\t\tg[z+1]=1,dfs(w-2,x-1,1,z+1);\n\t\tfor (int i=2;(i<=x) && (i<=y);i++)\n\t\t\tg[z+1]=i,dfs(w-2*i+2,x-i,i,z+1);\n\t\tg[z+1]=0;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tpre();\n\tdfs(n+1,m,m,0);\n\tprintf(\"%d\",(s+1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define M(x) ((x)%1000000007)\n#define MADD(x, y) (x = M(x + (y)))\n\nint N, K;\nchar s[75];\n\nbool reach[75][75][75];\n\n// no. of ways of having used exactly\n// A red, B blue seqs up to index i\n// 0: blank, 1: red, 2: blue (last ind)\nint cnt[75][75][75][4];\n\nint main() {\n\tcin >> N >> K >> s;\n\n\treach[0][0][0] = 1;\n\tfor (int i = 0; i < K; ++i) {\n\t\tfor (int A = 0; A < 75; ++A) {\n\t\t\tfor (int B = 0; B < 75; ++B) if (reach[A][B][i]) {\n\t\t\t\tif (s[i] == 'r') {\n\t\t\t\t\treach[A+1][B][i+1] = reach[A][B][i+1] = 1;\n\t\t\t\t\tif (B) reach[A][B+1][i+1] = 1;\n\t\t\t\t\tif (A) reach[A-1][B][i+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\treach[A][B][i+1] = 1;\n\t\t\t\t\tif (A) reach[A][B+1][i+1] = 1;\n\t\t\t\t\tif (B) reach[A][B-1][i+1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcnt[0][0][0][0] = 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int A = 0; A < 72; ++A) {\n\t\t\tfor (int B = 0; B < 72; ++B) {\n\t\t\t\t// first, consider the case\n\t\t\t\t// that we just came from a red or blue cell.\n\t\t\t\t// we could choose to break off the current\n\t\t\t\t// red sequence here, placing a white here.\n\t\t\t\tMADD(cnt[A][B][i+1][0], M(cnt[A][B][i][1] + cnt[A][B][i][2]));\n\n\t\t\t\t// if we came from a blank, we could start a new red sequence,\n\t\t\t\t// or start a red and a blue sequence simultaneously.\n\t\t\t\tMADD(cnt[A+1][B][i+1][1], cnt[A][B][i][0]);\n\t\t\t\tMADD(cnt[A+1][B+1][i+1][2], cnt[A][B][i][0]);\n\n\t\t\t\t// if we came from a red, we could start a new blue seq here\n\t\t\t\tMADD(cnt[A][B+1][i+1][2], cnt[A][B][i][1]);\n\n\t\t\t\t// if we came from a blue, we can go back to just being red again\n\t\t\t\tMADD(cnt[A][B][i+1][1], cnt[A][B][i][2]);\n\n\t\t\t\t// if we came from red, we could just keep being red\n\t\t\t\tMADD(cnt[A][B][i+1][1], cnt[A][B][i][1]);\n\n\t\t\t\t// if we came from a blank,\n\t\t\t\t// we can just keep being blank\n\t\t\t\tMADD(cnt[A][B][i+1][0], cnt[A][B][i][0]);\n\n\t\t\t\t// if we came from blue, we could just keep being blue\n\t\t\t\tMADD(cnt[A][B][i+1][2], cnt[A][B][i][2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint tot = 0;\n\tfor (int A = 0; A < 75; ++A) {\n\t\tfor (int B = 0; B < 75; ++B) if (reach[A][B][K]) {\n\t\t\tMADD(tot, M(M(cnt[A][B][N][0] + cnt[A][B][N][1]) + cnt[A][B][N][2]));\n\t\t}\n\t}\n\n\tcout << tot << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 70 + 10,mod = 1e9 + 7;\n\nint a[N],vis[N],fac[N << 1],inv[N << 1],Pos[N];\nchar str[N];\n\nint n,k,ans = 0;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int A,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * A % mod;\n\t\tA = 1ll * A * A % mod,b /= 2;\n\t}\n\treturn res;\n}\n\ninline int C(int A,int B) {\n\treturn 1ll * fac[A] * inv[B] % mod * inv[A - B] % mod;\n}\n\ninline void Calc(int len,int sum) {\n\tmemset(vis,0,sizeof(vis)),memset(Pos,0,sizeof(Pos));\n\tint lasr = 0,lasb = 0;\n\tFor(i,1,len) {\n\t\tint pos = 0;\n\t\tFor(j,lasr + 1,k) if(!vis[j] && str[j] == 'r') {\n\t\t\tvis[j] = true;\n\t\t\tpos = lasr = j;break;\n\t\t}\n\t\tif(!pos) return;\n\t\tif(a[i] < 2) continue;\n\t\tFor(j,max(pos,lasb) + 1,k) if(!vis[j] && str[j] == 'b') {\n\t\t\tvis[j] = true;\n\t\t\tPos[i] = lasb = j;break;\n\t\t}\n\t\tif(!Pos[i]) return;\n\t}\n\tint Las = 0;\n\tFor(i,1,len) {\n\t\tif(a[i] < 3) continue;\n\t\tint cnt = 0;\n\t\tFor(j,max(Pos[i],Las) + 1,k) {\n\t\t\tif(!vis[j]) cnt++,vis[j] = true;\n\t\t\tLas = j;\n\t\t\tif(cnt == a[i] - 2) break;\n\t\t}\n\t\tif(cnt < a[i] - 2) return;\n\t}\n\tint Inv = fac[len],tot = len + 1;\n\tfor(int i = 1,j = 1;i <= len;i = j + 1) {\n\t\tfor(j = i;j < len && a[j + 1] == a[i];j++);\n\t\tInv = 1ll * Inv * inv[j - i + 1] % mod;\n\t\ttot += (j - i + 1) * (a[i] * 2 - 1);\n\t}\n\tans = (ans + 1ll * Inv * C(n - sum + tot - 1,tot - 1)) % mod;\n}\n\ninline void dfs(int res,int Mn,int cur) {\n\tif(res < 0) return;\n\tCalc(cur - 1,n - res);\n\tif(res == 0) return;\n\tFor(i,1,min(res + 1,Mn)) a[cur] = i,dfs(res - (i == 1 ? 1 : i * 2 - 3) - (cur > 1),i,cur + 1);\n}\n\ninline void init(int Lim) {\n\tfac[0] = 1;\n\tFor(i,1,Lim) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[Lim] = fpm(fac[Lim],mod - 2);\n\tFordown(i,Lim,1) inv[i - 1] = 1ll * inv[i] * i % mod;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"ARC089F.in\",\"r\",stdin);\n\tfreopen(\"ARC089F.out\",\"w\",stdout);\n#endif\n\n\tn = read(),k = read();\n\tinit(150);\n\tscanf(\"%s\",str + 1);\n\n\tdfs(n,70,1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\ninline char safe_getc()\n{\n\tregister char ch(getc());\n\twhile(!isgraph(ch)) ch = getc();\n\treturn ch;\n}\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline int inv(int x) { assert(x); return fpm(x, MOD - 2); }\n\nnamespace MATH\n{\n\tconst int n = (int) 1e5;\n\n\tint fac[n + 5], ifac[n + 5];\n\n\tinline void init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = inv(fac[n]);\n\t\tfor(int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n\n\tinline int C(int N, int M) { return N < 0 || M < 0 || N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n}\nusing MATH::fac;\nusing MATH::ifac;\nusing MATH::C;\n\nconst int MAXN = 70;\n\nint n, K;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), K = read<int>();\n\tfor(int i = 1; i <= K; ++i) s[i] = safe_getc();\n}\n\nint a[MAXN + 5];\n\ninline int check(int N)\n{\n\tstatic int pos[MAXN + 5], vis[MAXN + 5];\n\tmemset(vis, 0, sizeof vis);\n\n\tint lstr = 0;\n\tfor(int i = 1; i <= N; ++i)\n\t{\n\t\tpos[i] = K + 1;\n\t\tfor(int j = lstr + 1; j <= K; ++j) if(s[j] == 'r' && !vis[j]) { vis[lstr = pos[i] = j] = 1; break; }\n\t\tif(pos[i] == K + 1) return 0;\n\n\t\tif(a[i] > 1)\n\t\t{\n\t\t\tfor(; pos[i] <= K; ++pos[i]) if(!vis[pos[i]] && s[pos[i]] == 'b') { vis[pos[i]] = 1; break; }\n\t\t\tif(pos[i] == K + 1) return 0;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; ++i) if(a[i] > 2)\n\t{\n\t\tint cnt = 2;\n\t\tfor(int j = pos[i] + 1; cnt < a[i] && j <= K; ++j) if(!vis[j]) vis[j] = 1, ++cnt;\n\t\tif(cnt < a[i]) return 0;\n\t}\n\n\treturn 1;\n}\n\ninline int div_into(int N, int M) { return C(N + M - 1, M - 1); }\n\ninline int calc(int N, int S)\n{\n\tint res = fac[N], M = N + 1;\n\tfor(int i = 1, j; i <= N; i = j)\n\t{\n\t\tfor(j = i; j <= N && a[j] == a[i]; ++j);\n\t\tres = (LL) res * ifac[j - i] % MOD;\n\t\tM += (a[i] * 2 - 1) * (j - i);\n\t}\n\treturn (LL) res * div_into(n - S, M) % MOD;\n}\n\nint ans = 0;\n\ninline void dfs(int k, int lst, int S)\n{\n\tif(S > n) return;\n\tif(check(k)) (ans += calc(k, S)) %= MOD;\n\n\tfor(int i = 1; i <= lst; ++i) a[k + 1] = i, dfs(k + 1, i, S + (i == 1 ? 1 : i * 2 - 3) + (k > 0));\n}\n\ninline void solve()\n{\n\tans = 0, dfs(0, K, 0);\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 610\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint ksm(int bs,int mi)\n{\n\tint ans=1;\n\twhile(mi)\n\t{\n\t\tif(mi&1)\tans=1ll*ans*bs%mdn;\n\t\tbs=1ll*bs*bs%mdn; mi>>=1;\n\t}\n\treturn ans;\n}\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint fac[N],inv[N],a[N],ans,n,k,r[N],b[N];\nchar ch[N]; bool vis[N];\nvoid init()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++)\tfac[i]=1ll*fac[i-1]*i%mdn;\n\tinv[N-1]=ksm(fac[N-1],mdn-2);\n\tfor(int i=N-1;i;i--)\tinv[i-1]=1ll*inv[i]*i%mdn;\n}\nint C(int n,int m){return n<m?0:1ll*fac[n]*inv[m]%mdn*inv[n-m]%mdn;}\nint solve(int tot,int dat)\n{\n\tint cur=fac[tot],cnt=0;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(a[i]==a[i-1])\tcnt++;\n\t\telse\tcur=1ll*cur*inv[cnt]%mdn,cnt=1;\n\t}\n\tcur=1ll*cur*inv[cnt]%mdn;\n\tint pt=1; memset(vis,0,n+1);\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='r')\n\t\tif(pt<=tot)\tr[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot)\treturn 0; pt=1;\n\tfor(int i=1;i<=k;i++)\tif(ch[i]=='b')\n\t\tif(pt<=tot&&r[pt]<i&&a[pt]>=2)\tb[pt]=i,pt++,vis[i]=1;\n\tif(pt<=tot&&a[pt]>=2)\treturn 0; pt=1; int qwq=a[pt]-2;\n\tfor(int i=1;i<=k;i++)\tif(!vis[i])\n\t\tif(pt<=tot&&b[pt]<i&&qwq>0)\n\t\t{\n\t\t\tqwq--; if(!qwq)\tpt++,qwq=a[pt]-2;\n\t\t}\n\tif(qwq>0)\treturn 0;\n\treturn 1ll*dat*cur%mdn;\n}\nvoid dfs(int val,int x,int ful,int wei)\n{\n\tif(ful<wei-1)\treturn;\n\tif(!val)\treturn upd(ans,solve(x-1,C(ful,wei)));\n\tfor(int i=1;i<=min(val,a[x-1]);i++)\ta[x]=i,dfs(val-i,x+1,ful+(i>=2?2:0),wei+2*i);\n}\nint main()\n{\n\tn=read(),k=read(); init();\n\tscanf(\"%s\",ch+1); a[0]=2*n;\n\tfor(int i=1;i<=n;i++)\tdfs(i,1,n+1,0);\n\tprintf(\"%d\\n\",(ans+1)%mdn);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nchar s[75];int n,K,ans,a[75],p[605],inv[605];\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid Check(int num,int sum)\n{\n\tint pos=num+1,res=p[num],rnum=0,leftr=0,nxt=0,left=0;\n\tfor(int i=1;i<=K;++i)\n\t\tif(s[i]=='r') rnum<num?leftr+=(a[++rnum]>1):(left?--left:0);\n\t\telse leftr?(--leftr,left+=a[++nxt]-2):(left?--left:0);\n\tif(left||rnum<num||leftr) return;\n\tfor(int i=1,j;i<=num;i=j+1)\n\t{\n\t\tfor(j=i;j<num&&a[j+1]==a[i];++j);\n\t\tres=1LL*res*inv[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(a[i]*2-1);\n\t}\n\tans=(ans+1LL*res*C(n-sum+pos-1,pos-1))%mod;\n}\nvoid dfs(int x,int num,int sum)\n{\n\tif(sum>n) return;Check(num,sum);\n\tfor(int i=x;i;--i) a[num+1]=i,dfs(i,num+1,sum+(i>1?i*2-3:1)+(num>0));\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&K,s+1);\n\tp[0]=inv[0]=p[1]=inv[1]=1;\n\tfor(int i=2;i<=600;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=600;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod; \n\tdfs(n,0,0);cout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=1005;\nint C[maxn][maxn];\nint fac[maxn],invfac[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=1LL*fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline int comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nint ca=0;\nint n,k;\nvi f;\nint solve()\n{\n    if(!f.size()) return 1;\n    vi len(f.size());\n    int p=f.size()-1,p2=f.size()-1;\n    for(int i=0;i<s.length();i++)\n    {\n        if(s[i]=='r')\n        {\n            if(p>=0)\n            {\n                len[p]++;\n                p--;\n            }\n            else{\n                while(p2>=0&&len[p2]==f[p2]) p2--;\n                if(p2<0) break;\n                len[p2]++;\n            }\n        }\n        else{\n            while(p2>=0&&len[p2]==f[p2]) p2--;\n            if(p2<0) break;\n            if(len[p2]) len[p2]++;\n        }\n    }\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++) \n    {\n        if(f[i]!=len[i]) return 0;\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    int ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nint dfs(int r,int mx,int cc,int len=0)\n{\n    if(len>n) return 0;\n    int ret=1LL*solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(f.size()>=ca) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        int cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=1LL*cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    for(int i=0;i<k;i++) ca+=s[i]=='r';\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 600;\nconst int MOD = 1e9 + 7;\n \nint n, k, tot = 0, _left, a[N]; \nll ans = 0, c[N][N]; \n\ninline ll add( ll a, ll b ) { ll ret = a + b; if( ret > MOD ) ret -= MOD; return ret; }\n\ninline void init_c( int size ) \n{\n\tfor( int i = 0; i <= size; i ++ )\n\t{\n\t\tc[i][0] = 1;\n\t\tfor( int j = 1; j <= i; j ++ )\n\t\t\tc[i][j] = add( c[i-1][j], c[i-1][j-1] );\n//\t\tprintf( \"C(5, 3) = %lld\\n\", c[5][3] );\n\t}\n} \n\nstring opt;\n\ninline bool check()\n{\n\tif( !tot ) return false;\n\t\n\tint now1 = 1, now2 = 1, c = 0;\n\t// now1: 红色生成到的段\n\t// now2: 蓝色生成到的段 \n\t// c: 剩余需要的 划分成段的 数量 \n\t\n\tfor( int i = 1; i <= k; i ++ )\n\t{\n\t\tif( now1 > tot && a[now2] <= 1 && !c ) return true;\n\t\t// 优先生成新的段 \n\t\tif( now1 <= tot && opt[i-1] == 'r' ) ++ now1;\n\t\t// 优先满足大的 \n\t\t// 如果a[now2] <= 1 说明对于所有的 i >= now2, 都满足a[i] <= 1 \n\t\telse if( now2 < now1 && a[now2] > 1 && opt[i-1] == 'b')\t\n\t\t\tc += a[now2] - 2, now2 ++;\n\t\t// 如果蓝色和红色都不需要生成新的段，则用来填补以前的段 \n\t\telse if( c ) c --;\n\t}\n\t\n\treturn now1 > tot && a[now2] <= 1 && !c; \n}\n\ninline void update()\n{\n\tll res = 1; int num = tot + 1;\n\t\n\tint next = 1;\n\tfor( int i = 1; i <= tot; i = next + 1 )\n\t{\n\t\tnext = i; \n\t\twhile( a[next+1] == a[i] )\n\t\t\tnext ++;\n\t\t\n\t\tres = res * c[next][i-1] %MOD;\n\t\t// 相当于在 i 个空中插入 next-i+1 个相同的球 \n\t\tnum += ( next - i + 1 ) * ( ( a[i] << 1 ) -1 );\n\t} \n\t\n\tres = res * c[num-1+_left][num-1] %MOD;\n\tans = add( ans, res );\n\t\n//\tprintf( \"[UPD] left:%d, num:%d, res:%lld\\n\", _left, num, res );\n}\n\nvoid dfs( int u ) \n// 有序的枚举 \n{\n\tif( _left < 0 ) return;\n\tif( check() ) update();\n\n\tif( tot ) _left --; tot ++;\n\t\n\t_left --; dfs( a[tot] = 1 ); _left ++;\n\t\n\tfor( int i = 2; i <= u; i ++ )\n\t{\n\t\t_left -= ( i << 1 ) - 3;\n\t\tdfs( a[tot] = i ); \n\t\t_left += ( i << 1 ) - 3; \n\t}\n\t\n\ta[tot--] = 0;\n\tif( tot ) _left ++;\n}\n \nint main()\n{\n\tscanf( \"%d%d\", &n, &k );\n\tinit_c( 500 );\n\t\n\tcin>> opt;\n\t_left = n; dfs( 100 );\n\t\n\tprintf( \"%lld\\n\", add( ans, 1 ) );\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::endl;\n\nconst int N = 75 * 2, P = 1e9 + 7;\n\ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n\nint n, m, fac[N], inv[N];\nchar str[N];\nint size[N];\n\ninline int binom(int x, int y) {\n  if (x < y || x < 0 || y < 0) return 0;\n  return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\n\nint val[N], tot;\nint ans = 1;\nint last[N];\nbool vis[N];\n\ninline bool check() {\n  for (int i = 1; i <= m; ++i)\n    vis[i] = 0, last[i] = 0;\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    while (j <= m && str[j] != 'r') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] == 1) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    while (j <= m && str[j] != 'b') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] <= 2) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    for (int k = val[i] - 2; k; --k) {\n      while (j <= m && vis[j]) ++j;\n      if (j > m) return 0;\n      vis[j] = 1, ++j;\n    }\n  }\n  return 1;\n}\n\nvoid dfs(int left, int high) {\n  if (check()) {\n    int sum = tot + 1;\n    for (int i = 1; i <= tot; ++i) {\n      sum += size[val[i]];\n      if (val[i] > 1) sum += 2;\n    }\n    int way = 1ll * binom(sum + left - 1, left);\n    way = 1ll * way * fac[tot] % P;\n    for (int i = 1, j = 1; i <= tot; i = j) {\n      while (j <= tot && val[i] == val[j])\n        ++j;\n      way = 1ll * way * inv[j - i] % P;\n    }\n    ans = (ans + way) % P;\n  }\n  for (int i = 1; i <= high; ++i) {\n    if (size[i] + 1 > left) break;\n    val[++tot] = i;\n    dfs(left - size[i] - 1, i);\n    --tot;\n  }\n}\n\nint main() {\n  for (int i = fac[0] = 1; i < N; ++i)\n    fac[i] = 1ll * fac[i - 1] * i % P;\n  inv[N - 1] = fpow(fac[N - 1], P - 2);\n  for (int i = N - 1; i; --i)\n    inv[i - 1] = 1ll * inv[i] * i % P;\n  scanf(\"%d %d %s\", &n, &m, str + 1);\n  size[1] = size[2] = 1;\n  for (int i = 3; i <= n; ++i)\n    size[i] = size[i - 1] + 2;\n  for (int i = 1; ; ++i) {\n    if (size[i] > n) break;\n    val[tot = 1] = i;\n    dfs(n - size[i], i);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MOD (1000000007)\nusing namespace std;\nconst int MAXN = 105;\ntypedef long long LL;\nint N, M, A[MAXN], minLen[MAXN], Belong[MAXN], Last[MAXN],KK,LLL;\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check(vector<int> Seq)\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1])--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<int> Seq, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<int> Seq, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check(Seq))Calc(Tot, Seq, V),++KK;\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, Seq, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= 70; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, Seq, newV, 1, Tot + minLen[Len]);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N, M, N, V1, V2, 0, 0);\n\tcout << (Ans + 1) % MOD;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\n\nint N, K;\nstring S;\nint dp1[72][72][2];\nint T[72][72];\nint nCr[201][201];\nvector<int> black, white;\nint dp2[2][72][72][72];\nint wh_ptr[72], gain[72];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  nCr[0][0] = 1;\n  for (int i=1; i<=200; i++) {\n    nCr[i][0] = 1;\n    for (int j=1; j<=200; j++) nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j])%MOD;\n  }\n\n  cin >> N >> K >> S;\n  rep(i, K) {\n    if (S[i] == 'r') black.pb(i);\n    else white.pb(i);\n  }\n  if (black.empty()) {\n    cout << 1 << \"\\n\";\n    return 0;\n  }\n  rep(i, max(N, K)+1) gain[i] = -INF, wh_ptr[i] = white.size();\n  int head = 0;\n  rep(i, black.size()) {\n    int g = 0;\n    while (head < white.size() && white[head] < black[i]) {\n      head++, g++;\n    }\n    if (head == white.size()) {\n      break;\n    }\n    head++;\n    wh_ptr[i] = head;\n    gain[i] = g;\n  }\n\n  dp1[0][0][0] = 1;\n  for (int len=0; len<N; len++) {\n    rep(num, N+1) {\n      rep(last, 2) {\n        add(dp1[len+1][num][0], dp1[len][num][last]); // ○\n        add(dp1[len+1][num+(last==0)][1], dp1[len][num][last]); // ●\n      }\n    }\n  }\n  rep(len, N+1) rep(num, N+1) if (num>0) T[len][num-1] = (dp1[len][num][0]+dp1[len][num][1])%MOD;\n\n  dp2[0][0][0][0] = 1;\n  for (int star=N; star>=0; star--) {\n    for (int len=N; len>=1; len--) {\n      if (T[len][star] == 0) continue;\n\n      rep(i, N+1) rep(j, N+1) rep(k, N+1) dp2[1][i][j][k] = dp2[0][i][j][k];\n      rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n        if (dp2[0][groups][sum][now] == 0) continue;\n        int cur = now;\n        int val = (1LL*dp2[0][groups][sum][now]*T[len][star])%MOD;\n        for (int num=1; groups+num<=min(N, (int)black.size()) && sum+num*len<=N; num++) {\n          cur = max(cur-gain[groups+num-1], 0) + star;\n          if (cur > N) continue;\n          add(dp2[1][groups+num][sum+num*len][cur], (1LL*val*nCr[groups+1-1+num][num])%MOD);\n          val = (1LL*val*T[len][star])%MOD;\n        }\n      }\n      swap(dp2[0], dp2[1]);\n    }\n  }\n  rep(i, N+1) rep(j, N+1) rep(k, N+1) dp2[1][i][j][k] = 0;\n  rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n    int gain = 0;\n    if (groups > 0) gain = white.size() - wh_ptr[groups-1];\n    int cur = max(now-gain, 0);\n    add(dp2[1][groups][sum][cur], dp2[0][groups][sum][now]);\n  }\n  swap(dp2[0], dp2[1]);\n\n  for (int len=N; len>=1; len--) {\n    rep(i, N+1) rep(j, N+1) rep(k, N+1) dp2[1][i][j][k] = dp2[0][i][j][k];\n    rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n      if (dp2[0][groups][sum][now] == 0) continue;\n      int cur = now;\n      int val = (1LL*dp2[0][groups][sum][now])%MOD;\n      for (int num=1; groups+num<=min(N, (int)black.size()) && sum+num*len<=N; num++) {\n        add(dp2[1][groups+num][sum+num*len][cur], (1LL*val*nCr[groups+1-1+num][num])%MOD);\n      }\n    }\n    swap(dp2[0], dp2[1]);\n  }\n\n  int s = 1; // all white\n  for (int groups=1; groups<=N; groups++) rep(sum, N+1) rep(cur, N+1) {\n    if (dp2[0][groups][sum][cur] == 0) continue;\n\n    if (groups > black.size()) continue;\n    int gain = black.size() - groups;\n    if (gain < cur) continue;\n\n    int yo = N-sum;\n    if (yo < groups-1) continue;\n    yo -= groups-1;\n    add(s, (1LL*nCr[yo+groups][yo]*dp2[0][groups][sum][cur])%MOD);\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\nint ts = 0;\nvoid calc(int sz) {\n    ts++;\n    int tb = 0, tr = 0;\n    int used[77], TR[77], TB[77];\n    memset(used, 0, sizeof used);\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        used[tr] = 1;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && (ch[tb] != 'b' || used[tb])) tb++;\n            used[tb] = 1;\n            TR[i] = tr;\n            TB[i] = tb;\n        } else {\n            TR[i] = tr;\n            TB[i] = tr;\n        }\n        if(tr > K || tb > K) return;\n    }\n    for(int i = 1; i <= sz; i++) {\n        int tt = TB[i];\n        for(int j = 1; j <= X[i] - 2; j++) {\n            tt++;\n            while(tt <= K && used[tt]) tt++;\n            if(tt > K) return;\n        }\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tot = 0) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K && max(2ll, i * 2 - 2) + tot <= n + 3; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tot + max(2ll, i * 2 - 2));\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    //printf(\"%d\\n\", ts);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =1000000007;\n\nmap< vector<int>, int > M;\nvector< vector<int> > Mi;\nvector<int> cnt[71];\n\nint MX =70;\n\nvoid put(vector<int> &seq, int x) {\n\tfor(int i =(int)seq.size()-1; i >= 0; i--) if(seq[i] >= x) {\n\t\tseq.insert(begin(seq)+i+1,x);\n\t\treturn;\n\t}\n\tseq.insert(begin(seq),x);\n}\n\nint get_id(vector<int> &seq) {\n\tauto it =M.find(seq);\n\tif(it == M.end()) {\n\t\tint m =M.size();\n\t\tM[seq] =m;\n\t\tMi.push_back(seq);\n\t\treturn m;\n\t}\n\treturn it->ss;\n}\n\nvoid dump(int id, int sum, cat cnt_cur) {\n\tif(id >= (int)cnt[sum].size())\n\t\tcnt[sum].resize(id+1,0);\n\tcnt[sum][id] +=cnt_cur;\n\tif(cnt[sum][id] >= mod) cnt[sum][id] -=mod;\n}\n\nvoid push(int id, int sum, cat cnt_cur) {\n\tvector<int> seq =Mi[id];\n\t// add 0\n\tint sum_nw =sum+int(!seq.empty())+1;\n\tseq.push_back(0);\n\tint id_nw =get_id(seq);\n\tif(sum_nw <= MX) dump(id_nw,sum_nw,cnt_cur);\n\t// add non-0\n\tint a =seq.size()-1;\n\tfor(int i =1; i < 100; i++) {\n\t\tif(sum_nw > MX) break;\n\t\tseq[a]++;\n\t\twhile(a > 0 && seq[a-1] < seq[a]) {\n\t\t\tswap(seq[a],seq[a-1]);\n\t\t\ta--;\n\t\t}\n\t\tid_nw =get_id(seq);\n\t\tdump(id_nw,sum_nw,cnt_cur);\n\t\tsum_nw +=2;\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\n\tMi.resize(1);\n\tM[vector<int>()] =0;\n\tcnt[0].resize(1,1);\n\tint st =0;\n\tfor(int i =0; i < MX; i++) {\n\t\tint st_nw =M.size();\n\t\tfor(int sum =MX; sum >= 0; sum--)\n\t\t\tfor(int l =st; l < (int)cnt[sum].size(); l++) if(cnt[sum][l])\n\t\t\t\tpush(l,sum,cnt[sum][l]);\n\t\tst =st_nw;\n\t}\n\tcat C[200][200];\n\tmemset(C,0,sizeof(C));\n\tfor(int i =0; i < 200; i++) {\n\t\tC[i][0] =1;\n\t\tfor(int j =1; j <= i; j++) C[i][j] =(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\n\tint N,K;\n\tstring S;\n\tcin >> N >> K >> S;\n\n\tint ans =0;\n\tfor(int sum =0; sum <= N; sum++) for(int i =0; i < (int)cnt[sum].size(); i++) {\n\t\tif(cnt[sum][i] == 0) continue;\n\t\tvector<int> seq =Mi[i];\n\n\t\tint a =0, b =0, c =0;\n\t\tvector<int> seqb;\n\t\tfor(int i =0; i < K; i++) {\n\t\t\tif(S[i] == 'r') {\n\t\t\t\tif(a < (int)seq.size()) {\n\t\t\t\t\tif(seq[a]) seqb.push_back(seq[a]);\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif(b > 0) b--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(c < (int)seqb.size()) {\n\t\t\t\t\tb +=seqb[c];\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tif(b > 0) b--;\n\t\t\t}\n\t\t}\n\t\tif(a < (int)seq.size() || c < (int)seqb.size() || b > 0) continue;\n\n\t\tint buckets =seq.size()+1;\n\t\tALL_THE(seq,it) buckets +=2*(*it)+1;\n\t\tcat cnt_ins =C[N-sum+buckets-1][buckets-1];\n\n\t\tans =(ans+cnt[sum][i]*cnt_ins)%mod;\n\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nint n,k;\nchar s[110];\nint nxt[110][2];\nint fac[210],inv[210];\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(long long)ans*t%Mod;\n\t\tt=(long long)t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tint N=200;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=(long long)inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\treturn (long long)fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint ans;\nint f[110],g[110],h[110];\nbool vis[110];\nvoid calc(int num)\n{\n\t//check\n\tfor(int i=1;i<=k;i++)\n\t\tvis[i]=false;\n\tint cur=nxt[1][0],cnt=0;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1&&cnt==0)\n\t\t\tcnt=num-i+1;\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;h[i]=cur;\n\t\tcur=nxt[cur+1][0];\n\t}\n\tcur=nxt[1][1];\n\tfor(int i=1;i<=num-cnt;i++)\n\t{\n\t\twhile(cur<=k&&(cur<h[i]||vis[cur]))\n\t\t\tcur=nxt[cur+1][1];\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;\n\t\tg[i]=cur;\n\t}\n\tint now=num-cnt;\n\tcur=f[now];\n\twhile(cur<=2&&now>0){\n\t\tnow--;\n\t\tcur=f[now];\n\t}\n\tfor(int i=k;i>=1;i--)\n\t\tif(!vis[i]){\n\t\t\tif(now<=0)break;\n\t\t\tif(i<g[i])return ;\n\t\t\tvis[i]=true;\n\t\t\tcur--;\n\t\t\twhile(cur<=2&&now>0){\n\t\t\t\tnow--;\n\t\t\t\tcur=f[now];\n\t\t\t}\n\t\t}\n\tif(now>0)return ;\n\tint sum=fac[num];cur=0;\n\tint cntb=0,cntr=0,cntw=num-1;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1)cntr++;\n\t\telse cntr+=f[i]-2,cntb+=f[i]-1;\n\t\tif(i==1||f[i]==f[i-1])cur++;\n\t\telse{\n\t\t\tsum=(long long)sum*inv[cur]%Mod;\n\t\t\tcur=1;\n\t\t}\n\t}\n\tsum=(long long)sum*inv[cur]%Mod;\n\tint cntB=(num-cnt)*2+1;//rbr->2(num-cnt)  ...rw->1\n\tif(cntb+cntr+cntw>n)return ;\n\tsum=(long long)sum*C(n+cntB,cntb+cntr+cntw+cntB)%Mod;\n//\tfor(int i=1;i<=num;i++)\n//\t\tprintf(\"%d \",f[i]);\n//\tprintf(\":%d\\n\",sum);\n\tans=(ans+sum)%Mod;\n\treturn ;\n}\nvoid dfs(int x,int rest,int rest2,int cnt)\n{\n\tif(rest<0)return ;\n\tif(x==0){\n\t\tcalc(cnt);\n\t\treturn ;\n\t}\n\tfor(int i=0;i*x<=rest2;i++)\n\t{\n\t\tif(i>0)f[cnt+i]=x;\n\t\tdfs(x-1,rest-i*(x==1?1:(2*x-3)),rest2-i*x,cnt+i);\n\t}\n\treturn ;\n}\nint main()\n{\n//\tf[1]=2;\n//\tcalc(2);\n//\tprintf(\"%d\\n\",ans);\n\t\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tnxt[k+1][0]=nxt[k+1][1]=k+1;\n\tfor(int i=k;i>=1;i--)\n\t{\n\t\tnxt[i][0]=nxt[i+1][0];\n\t\tnxt[i][1]=nxt[i+1][1];\n\t\tif(s[i]=='r')nxt[i][0]=i;\n\t\telse nxt[i][1]=i;\n\t}\n\tinit();\n\tdfs(k,n,k,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nint dp[111][111];\nint table[100][100][100];\nint calc(){\n    /*\n    if(X[0]==1){\n        if(X.size()>R)return 0;\n        int n=X.size();\n        int y=N-(2*n+1);\n        return nCk(2*n+y,y);\n    }*/\n    int n=X.size();\n    if(n>R)return 0;\n    int nr=R-n,nb=B;\n    for(int i=0;i<X.size();i++){\n        int pos=r[R-i];\n        while(nb>0&&b[nb]<pos)nb--;\n        if(X[i]==1)continue;\n        if(nb==0)return 0;\n        while(nr>0&&r[nr]<b[nb])nr--;\n        nb--;\n        rep(t,X[i]-2){\n            if(i+1<n&&nb&&b[nb]<r[R-i-1]){\n                nb--;\n                continue;\n            }\n            if(nr){\n                nr--;\n                continue;\n            }\n            if(nb){\n                nb--;\n                continue;\n            }\n            return 0;\n        }\n    }\n\n    vpint ei;\n    rep(i,X.size()){\n        if(ei.size()==0||ei.back().fi!=X[i])ei.pb({X[i],1});\n        else ei.back().se++;\n    }\n    rep(i,ei.size()+1)rep(j,N+1)dp[i][j]=0;\n    dp[0][0]=1;\n    for(int i=0;i<ei.size();i++){\n        for(int j=0;j<=N;j++){\n            if(ei[i].fi==1){\n                for(int k=ei[i].se;j+k<=N;k++)add(dp[i+1][j+k],dp[i][j]*table[ei[i].fi][ei[i].se][k]%mod);\n            }\n            else{\n                for(int k=ei[i].se*(ei[i].fi*2-3);j+k<=N;k++)add(dp[i+1][j+k],dp[i][j]*table[ei[i].fi][ei[i].se][k]%mod);\n            }\n        }\n    }\n\n\n    int ret=0;\n    for(int i=0;i<=N;i++){\n        add(ret,dp[ei.size()][i]*nCk(N-i+1,n)%mod);\n    }\n\n    ret=ret*fact[n]%mod;\n    rep(i,ei.size())ret=ret*inv[ei[i].se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    for(int i=1;i<=77;i++){\n        table[i][0][0]=1;\n        for(int j=0;j<77;j++){\n            for(int k=0;k<77;k++){\n                if(i==1){\n                    for(int l=1;k+l<=77;l++)add(table[i][j+1][k+l],table[i][j][k]);\n                }\n                else{\n                    for(int l=0;2*i-3+k+l<=77;l++){\n                        add(table[i][j+1][k+2*i-3+l],table[i][j][k]*nCk(2*i-2+l,l)%mod);\n                    }\n                }\n            }\n        }\n    }\n\n    cin>>N>>K;\n    cin>>S;\n\n   // if(N>30||K>30)assert(0);\n\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint fac[150], ifac[150], ans, n, k;\nbool del[75];\nvector<int> f, r;\nchar s[75];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nbool check() {\n\tfill(del + 1, del + 1 + k, false);\n\tfor (int i = 0; i < f.size(); ++i) del[r[i]] = true;\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 2) {\n\t\t\tint j;\n\t\t\tfor (j = r[f.size() - 1 - i] + 1; (del[j] || s[j] == 'r') && j <= k; ++j);\n\t\t\tif (j > k) return false;\n\t\t\tdel[j] = true;\n\t\t}\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 3) {\n\t\t\tint cnt = f[i] - 2;\n\t\t\tfor (int j = r[f.size() - 1 - i] + 1; cnt && j <= k; ++j)\n\t\t\t\tif (!del[j]) del[j] = true, --cnt;\n\t\t\tif (cnt) return false;\n\t\t}\n\treturn true;\n}\n\nvoid dfs(int lst, int sum) {\n\tif (f.size() > r.size()) return;\n\tif (check()) {\n\t\tint s = n + 1, c = fac[f.size()], s1 = 0;\n\t\tfor (int i = 0, j; i < f.size(); i = j) {\n\t\t\tfor (j = i + 1; j < f.size() && f[j] == f[i]; ++j);\n\t\t\tc = 1ll * c * ifac[j - i] % P;\n\t\t\tif (f[i] > 1) s += 2 * (j - i);\n\t\t\ts1 += 2 * f[i] * (j - i);\n\t\t}\n\t\tans = (ans + 1ll * c * fac[s] % P * ifac[s1] % P * ifac[s - s1]) % P;\n\t}\n\tfor (int i = lst; (sum + max(1, i - 1)) * 2 <= n + 1; ++i) f.push_back(i), dfs(i, sum + max(1, i - 1)), f.pop_back();\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &k, s + 1);\n\tfor (int i = 1, j = 1; i <= k; ++i)\n\t\tif (s[i] == 'r') r.push_back(i);\n\tfor (int i = fac[0] = 1; i <= 2 * n + 5; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[2 * n + 5] = power(fac[2 * n + 5], P - 2);\n\tfor (int i = 2 * n + 5; i; --i) ifac[i - 1] = 1ll * ifac[i] * i % P;\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nstruct edge { int v, w; };\nconst int INF = INT_MAX / 2;\nconst int MOD = 1e9 + 7;\nconst ll e18 = 1e18;\n\nll dp[72][71][71][36], C[200][200], unko[200][200];\n\nll H(int x, int y) {\n\tif (!y) return !x;\n\treturn C[x - 1][y - 1];\n}\n\nint main() {\n\trep(x, 200) {\n\t\tC[x][0] = 1;\n\t\tfor (int y = 1; y <= x; y++)\n\t\t\tC[x][y] = (C[x - 1][y - 1] + C[x - 1][y]) % MOD;\n\t}\n\tfor (int d = 1; d < 100; d++)\n\t\tfor (int b = 1; b <= (d + 1) / 2; b++)\n\t\t\tfor (int r = b - 1; r <= b + 1; r++)\n\t\t\t\tif (b + r <= d) {\n\t\t\t\t\tunko[d][b] = (unko[d][b] + H(d, b + r)) % MOD;\n\t\t\t\t\tif (b == r) unko[d][b] = (unko[d][b] + H(d, b + r)) % MOD;\n\t\t\t\t}\n\tint N, M; cin >> N >> M;\n\tstring s; cin >> s;\n\tint R = 0, L = 0;\n\trep(j, M) {\n\t\tif (s[j] == 'r') R++;\n\t\tif (s[j] == \"rb\"[L % 2]) L++;\n\t}\n\tL /= 2;\n\tdp[0][0][0][0] = 1;\n\trep(i, N + 1) rep(r, R + 1) rep(s, M + 1) rep(l, L + 1) {\n\t\tll z = dp[i][r][s][l];\n\t\tif (!z) continue;\n\t\tdp[i + 1][r][s][l] = (dp[i + 1][r][s][l] + z) % MOD;\n\t\tif (r == R) continue;\n\t\tfor (int d = 1; i + d <= N; d++) {\n\t\t\tint j = i + d + 1;\n\t\t\tif (s + 1 <= M)\n\t\t\t\tdp[j][r + 1][s + 1][l] = (dp[j][r + 1][s + 1][l] + z) % MOD;\n\t\t\tif (l == L) continue;\n\t\t\tfor (int b = 1; b <= (d + 1) / 2 && s + b + 1 <= M; b++)\n\t\t\t\tdp[j][r + 1][s + b + 1][l + 1] = (dp[j][r + 1][s + b + 1][l + 1] + z * unko[d][b]) % MOD;\n\t\t}\n\t}\n\tll ans = 0;\n\trep(r, R + 1) rep(s, M + 1) rep(l, L + 1)\n\t\tans = (ans + dp[N + 1][r][s][l]) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=75,mod=1e9+7;\nchar ch[N];\nll c[N][N];\nint s[N],zy[N][N][N],f[(N+3)/2][N][N/2][N],g[(N+3)/2][N][N/2][N],h[(N+3)/2][N][N/2][N],H[(N+3)/2][N][N/2][N];\nll hf(int a,int b){\n\treturn a>=0&&b>=0?c[a+b-1][b-1]:0;\n}\ninline void add(int &a,ll b){\n\ta=(a+b)%mod;\n\t//cout<<a<<\" \"<<b<<endl;\n}\nbool vis[N];\nsigned main(){\n\t//freopen(\"cover.in\",\"r\",stdin); freopen(\"cover.out\",\"w\",stdout);\n\tint n=read(),len=read(),F=0,ans=1;\n\tFor(i,0,n)For(j,c[i][0]=1,i)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\tscanf(\"%s\",ch+1);\n\tFor(xsg,0,(n+1)/2){\n\t\tF=0; \n\t\t//memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); memset(h,0,sizeof(h)); memset(H,0,sizeof(H));\n\t\tFor(i,1,len){\n\t\t\ts[i]=s[i-1];\n\t\t\tif(ch[i]=='r'&&!vis[i])F++;\n\t\t\telse if(!vis[i]&&F){s[i]++; F--;} \n\t\t}\n\t\t\n\t\tFor(i,0,len){\n\t\t\tFor(j,0,s[i]){\n\t\t\t\tFor(k,2,(n+3)/2){\n\t\t\t\t\tint dq=i+1,jb=0;\n\t\t\t\t\twhile(dq<=len){\n\t\t\t\t\t\tif(vis[dq]){dq++; continue;}\n\t\t\t\t\t\tif(s[dq]>=j+1||(jb==0&&ch[dq]=='r'))jb++;\n\t\t\t\t\t\tif(jb>=k)break; dq++;\n\t\t\t\t\t}\n\t\t\t\t\tzy[i][j][k]=dq;\n\t\t\t\t\t//if(i<=5)cout<<zy[i][j][k]<<\" \"<<i<<\" \"<<j<<\" \"<<k<<endl;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\t//cout<<zy[5][1][2]<<endl;\n\t\tf[(n+3)/2][0][0][0]=1; int m=(n+1)/2,cnt=0;\n\t\tRep(i,(n+3)/2,2){\n\t\t\tFor(j,0,n-xsg)for(int k=0;k<=m-xsg&&k*(2*i-3)<=j;k++)For(l,0,len){\n\t\t\t\t\n\t\t\t\tif(f[i][j][k][l]){\n\t\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<l<<endl;\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-1)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\tadd(g[i][j+o*(2*i-1)][k+o][dq],f[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\tf[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t\tif(g[i][j][k][l]){\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-2)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\tadd(h[i][j+o*(2*i-2)][k+o][dq],g[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\tg[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t\tif(h[i][j][k][l]){\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-3)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\tadd(H[i][j+o*(2*i-3)][k+o][dq],h[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\th[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t\tif(H[i][j][k][l]){\n\t\t\t\t\tint dq=l;\n\t\t\t\t\tfor(int o=0;j+o*(2*i-2)+xsg*2+k+o-1<=n&&k+o+xsg<=m&&dq<=len;o++){cnt++;\n\t\t\t\t\t\t//if(o==1)cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<l<<\" \"<<H[i][j][k][l]<<endl;\n\t\t\t\t\t\tadd(f[i-1][j+o*(2*i-2)][k+o][dq],H[i][j][k][l]*hf(o,k+1));\n\t\t\t\t\t\tdq=zy[dq][k+o][i];\n\t\t\t\t\t}\n\t\t\t\t\tH[i][j][k][l]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout<<zy[0][1][1]<<endl;\n\t\t//cout<<f[1][2][1][2]<<\" \"<<hf(1,2)<<endl;\n\t\t//cout<<f[1][0][0][0]<<\" \"<<g[1][1][1][1]<<\" \"<<f[1][2][1][2]<<\" \"<<zy[0][0][2]<<endl;\n\t\tFor(j,0,n-xsg)For(k,0,m-xsg)For(l,0,len)if(f[1][j][k][l]){\n\t\t\t//cout<<f[1][j][k][l]<<endl;\n\t\t\tadd(g[1][j+xsg][k+xsg][l],f[1][j][k][l]*hf(xsg,k+1));\n\t\t}\n\t\tmemset(f[1],0,sizeof(f[1]));\n\t\tFor(j,0,n)For(k,0,m)For(l,0,len)if(g[1][j][k][l]){\n\t\t\tif(k){\n\t\t\t\t//cout<<k-1<<\" \"<<len<<\" \"<<l<<\" \"<<len-l<<endl;\n\t\t\t\t//For(o,k-1,n-j)cout<<hf(o-(k-1),k+1)<<\" \"<<c[n-o-1][j-1]<<endl;\n\t\t\t\tFor(o,k-1,n-j)ans=(ans+hf(o-(k-1),k+1)*g[1][j][k][l]%mod*c[n-o-1][j-1])%mod;\n\t\t\t\t//cout<<j<<\" \"<<k<<\" \"<<l<<\" \"<<g[1][j][k][l]<<\" \"<<hf(0-(k-1),k+1)<<\" \"<<c[n-0-1][j-1]<<endl;\n\t\t\t}\n\t\t}\n\t\t//cout<<ans<<endl;\n\t\tint fff=0;\n\t\t//Rep(i,len,1)cout<<(ch[i]=='r'&&!vis[i])<<endl;\n\t\tRep(i,len,1)if(ch[i]=='r'&&!vis[i]){vis[i]=1; fff=1;break;}\n\t\tif(!fff)break;\n\t\tmemset(g[1],0,sizeof(g[1]));\n\t\t\n\t}\n\tcout<<ans<<endl;\n}\n/*\n70 68\nrbrrbbrrbbbbrbbrbrrbbrrbbrbrrbrbrbbbbrbbrbrrbbrrbbbbrbbrbrrbbrrbbbbr\n3 2\nrb\n\n5 1\nbr\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\nnamespace IO{\n    const int L=1<<15;char ibuf[L|1],*iS=ibuf,*iT=ibuf,obuf[L|1],*oS=obuf,*oT=obuf+L,c,st[66];int tp=0,f;\n    inline char gc(){if(iS==iT) iT=(iS=ibuf)+fread(ibuf,sizeof(char),L,stdin);return (*iS++);}\n    inline void flush(){fwrite(obuf,sizeof(char),oS-obuf,stdout);oS = obuf;}\n    inline void pc(char c){*oS++=c;if(oS==oT) flush();}\n    inline ll read(){ll x=0;f=1,c=gc();for(;!isdigit(c);c=gc())if(c=='-')f=-1;for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c&15);return x*f;}\n    inline void write(ll x){if(!x) pc('0');if(x<0) pc('-'),x=-x;while(x) st[++tp]=x%10+'0',x/=10;while(tp) pc(st[tp--]);}\n    inline void writeln(ll x){write(x);pc('\\n');}\n    struct IOflusher{~IOflusher(){flush();}}_ioflusher_;\n}using IO::read;using IO::write;using IO::writeln;using IO::gc;using IO::pc;\nconst int maxn = 70*3;\nconst int mod = 1e9+7;\nint n,m;\nchar s[maxn];\nint ans,fac[maxn],ifac[maxn];\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(){\n\tn = read(),m = read();\n\tscanf(\"%s\",s+1);\n\tfac[0] = 1;rep(i,1,maxn) fac[i] = 1ll * fac[i-1] * i % mod;\n\tifac[maxn-1] = qpow(fac[maxn-1],mod-2);\n\tDep(i,maxn-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % mod;\n\tassert(ifac[0]==1);\n}\ninline int C(int n,int m){\n\tif(n<m||n<0) return 0;\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\n#define cal(x,y) C((x)+(y)-1,(y)-1)\ninline void add(int &x,int v){\n\tx+=v;\n\tif(x>=mod) x-=mod;\n}\nint q1[maxn],q2[maxn],suf[maxn],f[maxn][maxn];\nbool used[maxn];\nvoid solve(int S1,int S2){\n\tif(!S1&&!S2) return ++ans,void(0);\n\tif((S1+S2)*2>n+1 || S1+2*S2>m) return ;\n\t*q1=*q2=0;\n\tmemset(used,0,sizeof(used));\n\tint x=0,y=0;\n\tRep(i,1,m)\n\t\tif(s[i]=='r' && x<S1+S2) q1[++x]=i; else \n\t\tif(s[i]=='b' && y<S2 && y<x) q2[++y]=i;\n\tif(y!=S2 || x!=S1+S2) return ;\n\tRep(i,1,x) used[q1[i]]=true;\n\tRep(i,1,y) used[q2[i]]=true;\n\tDep(i,m,1) suf[i]=suf[i+1]+(!used[i]);\n\tRep(i,1,S2) q2[i] = suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tint limit = max(2,n)+1;\n\tRep(i,2,limit)Dep(j,S2-1,0)Rep(k,2*j,limit-i*(S2-j)){\n\t\tRep(l,1,min(S2-j,(limit-k)/i)){\n\t\t\tif(k+i*l-2*(j+l) > q2[S2-(j+l)+1]) break;\n\t\t\tadd(f[j+l][k+i*l],1ll*ifac[l]*f[j][k]%mod);\n\t\t}\n\t}\n\tint res = 0;\n\tRep(i,0,limit){\n\t\tint sum=2*S1+2*i-2*S2-1;\n\t\tint par=2*S1+2*i+1;\n\t\tif (sum>=0&&sum<=n&&f[S2][i])\n\t\t\tadd(res,1ll*f[S2][i]*cal(n-sum,par)%mod);\n\t}res = 1ll * res * fac[S1+S2] % mod * ifac[S1] % mod;\n\tadd(ans,res);\n}\nint main(){\n\tinit(); \n\tans = 0;\n\tRep(S1,0,n)Rep(S2,0,n)solve(S1,S2);\n\twriteln(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 210;\nconst int mod = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check()\n{\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    FOR(i, 1, k)\n    {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update()\n{\n    ll tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1)\n    {\n        for(j = i; j < tot && a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % mod;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % mod;\n    if ((ans += tmp) >= mod) ans -= mod;\n}\n\nvoid dfs(int mx)\n{\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    --left; dfs(a[++tot] = 1); ++left; --tot;\n    FOR(i, 2, mx)\n    {\n        left -= i * 2 - 3;\n        dfs(a[++tot] = i);\n        left += i * 2 - 3; --tot;\n    }\n    a[tot] = 0;\n    if (tot) ++left;\n}\n\nint main()\n{\n    FOR(i, 0, 200)\n    {\n        c[i][0] = 1;\n        FOR(j, 1, 200)\n            if ((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= mod)\n                c[i][j] -= mod;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(n);\n    printf(\"%d\\n\", ans + 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 210;\nconst int mod = 1e9 + 7;\n\ntypedef long long LL;\n\nint frac[N], inv[N], n, k;\n\ninline int Pow(int x, int y) {\n    int res = 1;\n    for (; y; y >>= 1, x = (LL)x * x % mod) if (y & 1) res = (LL)res * x % mod;\n    return res;\n}\n\ninline int C(int n, int r) {\n    return (LL)frac[n] * inv[r] % mod * inv[n - r] % mod;\n}\n\nchar s[N];\n\nvector<int> zjk;\n\ninline bool check() {\n    vector<int> R = zjk, B, T; \n    for (int i = 1; i <= k; i++) {\n        if (R.size() + B.size() + T.size() == 0) return true;\n        if (s[i] == 'r') {\n            if (R.size()) {\n                int t = R.back(); R.pop_back();\n                if (t > 1) B.insert(B.begin(), t - 1);\n            } else if (T.size()) {\n                (*T.rbegin())--;\n                if (!T.back()) T.pop_back();\n            }\n        } else {\n            if (B.size()) {\n                int t = B.back(); B.pop_back();\n                if (t > 1) T.push_back(t - 1);\n            } else if (T.size()) {\n                (*T.rbegin())--;\n                if (!T.back()) T.pop_back();\n            }\n        }\n    }\n    return R.size() + B.size() + T.size() == 0;\n}\n\nint res = 0;\n\nvoid dfs(int mn, int mx, int lst) {\n    if (mn > n) return;\n//    cout << \"dfs: \" << mn << ' ' << mx << ' ' << lst << endl;\n//    cout << \"zjk: \";\n//    for (auto t : zjk) cout << t << ' ';\n//    cout << endl;\n    if (!check()) return;\n    int w = (LL)C(n - mn + mx - 1, mx - 1) * frac[zjk.size()] % mod;\n    for (int i = 0; i < zjk.size(); i++) {\n        int j = i;\n        while (j + 1 < zjk.size() && zjk[j + 1] == zjk[j]) j++;\n        w = (LL)w * inv[j - i + 1] % mod, i = j;\n    }\n//    cout << res << ' ' << w << endl;\n    res = (res + w) % mod;\n    for (int i = lst; mn + max(1, 2 * i - 1) <= n; i++) \n        zjk.push_back(i + 1), dfs(mn + max(1, 2 * i - 1) + (zjk.size() != 1), mx + (i + 1) * 2, i), zjk.pop_back();\n}\n\nint main() {\n    scanf(\"%d%d%s\", &n, &k, s + 1), frac[0] = inv[0] = 1;\n    for (int i = 1; i <= 200; i++) frac[i] = (LL)frac[i - 1] * i % mod, inv[i] = Pow(frac[i], mod - 2);\n    dfs(0, 1, 0);\n    printf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=1e3+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=300+10;\n\t//------------------FIXED------------------\n\tchar str[N];int pos[N],blu[N];bool inB[N];\n\tll Bin[N];\n\tint up[N],dp[N][N][N];\n\tvoid main()\n\t{\n\t\tBin[0]=1;fo(i,1,N-1) Bin[i]=Bin[i-1]*2%MOD;\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);int ans=0;\n\t\tfo(A,0,m)\n\t\t{\n\t\t\tint R=0;mem(inB,0);\n\t\t\tfo(i,1,m) if(str[i]=='r')\n\t\t\t{\n\t\t\t\tif(R==A) break;\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1,pos[++R]=j,ok=1;break;}\n\t\t\t\tif(!ok) break;\n\t\t\t}if(R<A) break;\n\t\t\t\n\t\t\tfo(B,0,m)\n\t\t\t{\n\t\t\t\tint cc=0;fo(i,1,m) if(str[i]=='r') cc++,blu[i]=blu[i-1]+(cc>A+B); else blu[i]=blu[i-1]+(!inB[i]);if(cc<A+B) break;\n\t\t\t\tup[A+1]=0,pos[A+1]=m;fd(i,A,1) up[i]=up[i+1]+(blu[pos[i+1]]-blu[pos[i]])+1;reverse(up+1,up+A+1);\n\t\t\t\t\n\t\t\t\tdp[0][0][0]=1;fo(ln,1,m) fo(i,0,A) fo(S,0,up[i]) dp[ln][i][S]=0;\n\t\t\t\tfo(ln,1,m) fo(i,0,A) fo(S,0,min(up[i],up[A]-ln*(A-i))) if(dp[ln-1][i][S])\n\t\t\t\t\tfor(int ad=0;i+ad<=A and S+ad*ln<=up[i+ad];ad++)\n\t\t\t\t\t\tadd(dp[ln][i+ad][S+ad*ln],dp[ln-1][i][S]*facinv[ad]%MOD);\n\t\t\t\tfo(S,0,up[A]) if(dp[m][A][S]) fo(i,0,A) fo(j,0,A-i)\n\t\t\t\t{\n\t\t\t\t\tll V=Bin[A-i-j]*C(A,i)%MOD*C(A-i,j)%MOD*facinv[B]%MOD*fac[A+B]%MOD*dp[m][A][S]%MOD;\n\t\t\t\t\tadd(ans, V*( C(n-1,(S*2-i+j)+(A+B+B-1)-1)+C(n-1,(S*2-i+j)+(A+B+B)-1)*2+C(n-1,(S*2-i+j)+(A+B+B+1)-1) )%MOD );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twrite(ans);\n\t}\n};//����������\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//����Ԥ����ģ����\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}\n/*\n3 3\nrbr\n \n5 4\nrrbb\n \n7 4\nrbrb\n \n5 5\nrrrbb\n\n7 7\nrbrrrbb\n \n9 6\nrrrbbb\n\n50 50\nbbrbrrbbrbbrbrrbbrrbbrbrrbbrrbbrbrrbbrbrbrbrrbbrbr\n \n70 70\nbbrbrrbbrrbbbbrbbrbrrbbrrbbrbrrbrbrbbbbrbbrbrrbbrrbbbbrbbrbrrbbrrbbbbr\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nconst int MX = 605;\nconst int MM = 1000000007;\n\nint C[MX][MX];\nll I[MX], FI[MX], F[MX];\nint A[MX], sz = 0;\nstring S;\nll ans = 1;\nint N, K;\nint pr[75] = {};\n\nint sum = -1, t = 2;\n\nvoid update()\n{\n\tif( N < sum ) return;\n\tint cnt = 0, red = 0, blue = 0;\n\tfor(char c : S){\n\t\tif( c == 'r' ){\n\t\t\tif( red < sz) red++;\n\t\t\telse cnt -= cnt>0;\n\t\t}\n\t\telse{\n\t\t\tif( blue < red && A[blue] >= 2 ) cnt += A[blue++]-2;\n\t\t\telse cnt -= cnt>0;\n\t\t}\n\t}\n\tif(cnt || red != sz || A[blue] >= 2) return;\n\n\tll m = F[sz];\n\tfor(int i = 0; i < sz; i++) pr[A[i]] += 1;\n\tfor(int i = 0; i <= A[0]; i++){\n\t\tif(pr[i]) m = m * FI[pr[i]] % MM;\n\t\tpr[i] = 0;\n\t}\n\n\tans = (ans + C[t+N-1][N-sum] * m) % MM;\n}\n\nvoid dfs(int K, int mx){\n\tif( K == 0 ) return;\n\tfor(int i = mx; i >= 1; i--){\n\t\tA[sz++] = i;\n\t\tt += i >= 2 ? 2 : 0;\n\t\tsum += i == 1 ? 2 : i*2-2;\n\n\t\tupdate();\n\t\tdfs(K-i, min(i, K-i));\n\n\t\tA[--sz] = 0;\n\t\tt -= i >= 2 ? 2 : 0;\n\t\tsum -= i == 1 ? 2 : i*2-2;\n\t}\n}\n\nint main()\n{\n\tF[0] = FI[0] = 1;\n\tI[1] = 1;\n\tfor(int i = 2; i < MX; i++) I[i] = (MM-I[MM%i]) * (MM/i) % MM;\n\tfor(int i = 1; i < MX; i++) F[i] = F[i-1] * i % MM;\n\tfor(int i = 1; i < MX; i++) FI[i] = FI[i-1] * I[i] % MM;\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 0; i < MX; i++){\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1; j <= i; j++) C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MM;\n\t}\n\tcin >> S;\n\tdfs(K, K);\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#define MOD 1000000007\n#define C(n, m) (fact[n] * inv[m] % MOD * inv[(n) - (m)] % MOD)\ntypedef long long ll; \ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD; \n\t\ta = a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res; \n}\nint seq[75], n, k;\nchar str[75]; \nll ans, fact[305], inv[305]; \ninline void work(int len, int sum)\n{\n\tint one = 0, two = 0, need = 0, rem = 0; \n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tif (str[i] == 'r' && one < len)\n\t\t\tneed += seq[one++] != 1; \n\t\telse if (str[i] == 'b' && need)\n\t\t{\n\t\t\tneed--; \n\t\t\trem += seq[two++] - 2; \n\t\t}\n\t\telse\n\t\t\trem -= !!rem; \n\t}\n\tif (one < len || need || rem)\n\t\treturn; \n\tll res = fact[len], cnt = len + 1; \n\tfor (int i = 0, j = 0; i < len; i = j)\n\t{\n\t\twhile (j < len && seq[i] == seq[j])\n\t\t\tj++; \n\t\tres = res * inv[j - i] % MOD; \n\t\tcnt += (j - i) * (seq[i] * 2 - 1); \n\t}\n\t(ans += res * C(n - sum + cnt - 1, cnt - 1)) %= MOD; \n}\nvoid dfs(int mx, int len, int cur)\n{\n\tif (cur > n)\n\t\treturn; \n\twork(len, cur); \n\tfor (int i = mx; i; i--)\n\t{\n\t\tseq[len] = i; \n\t\tdfs(i, len + 1, cur + std::max(i * 2 - 3, 1) + !!len); \n\t}\n}\nint main()\n{\n\t// freopen(\"ARC089-F.in\", \"r\", stdin); \n\tfact[0] = inv[0] = 1; \n\tfor (int i = 1; i < 305; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD; \n\t\tinv[i] = quick_pow(fact[i], MOD - 2); \n\t}\n\tscanf(\"%d%d%s\", &n, &k, str);\n\tdfs(70, 0, 0); \n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=75;\nconst int mod=1e9+7;\nint n,k;\nchar s[maxn];\nint nxt[maxn][2],pos0[maxn],pos1[maxn],lim[maxn],fac[maxn*2],ifac[maxn*2];\nint dp[maxn][maxn][maxn];\nbool del[maxn];\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=2*max(n,k);i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,2*max(n,k))ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tnxt[k][0]=nxt[k][1]=k;\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(s[i]=='r')nxt[i][0]=i,nxt[i][1]=nxt[i+1][1];\n\t\telse nxt[i][0]=nxt[i+1][0],nxt[i][1]=i;\n\t}\n\tint ans=0;\n\trep(i,k+1){\n\t\tbool ok=true;\n\t\tint last0=-1,last1=-1;\n\t\trep(j,k)del[j]=false;\n\t\trep(j,i){\n\t\t\tpos0[j]=nxt[last0+1][0];\n\t\t\tpos1[j]=nxt[max(last1+1,pos0[j])][1];\n\t\t\tif(pos0[j]==k||pos1[j]==k){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdel[pos0[j]]=del[pos1[j]]=true;\n\t\t\tlast0=pos0[j];last1=pos1[j];\n\t\t}\n\t\tif(!ok)continue;\n\t\trep(j,i){\n\t\t\tlim[i-j]=0;\n\t\t\tfor(int p=pos1[j]+1;p<k;p++)if(!del[p])lim[i-j]++;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0][0]=1;\n\t\trep(j,i+1)rep(p,k+1)rep(q,k+1){\n\t\t\tint cur=dp[j][p][q];\n\t\t\tif(!cur)continue;\n\t\t\trep(t,k+1){\n\t\t\t\tif(q+t*p>lim[j+t])break;\n\t\t\t\tAdd(dp[j+t][p+1][q+t*p],1LL*cur*ifac[t]%mod);\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int j=(i==0?0:(pos0[0]+1));j<k;j++)\n\t\t\tif(!del[j]&&s[j]=='r')sum++;\n\t\trep(q,k+1){\n\t\t\tint cur=dp[i][k][q];\n\t\t\tif(!cur)continue;\n\t\t\tint now=q*2+i,csum=min(sum,(i==0?k:lim[i])-q);\n\t\t\trep(j,csum+1){\n\t\t\t\tint coef=1LL*cur*fac[i+j]%mod*ifac[j]%mod;\n\t\t\t\trep(p,n-j-now+1){\n\t\t\t\t\tint cur;\n\t\t\t\t\tif(now+2*i+j==0&&p==0)cur=1;\n\t\t\t\t\telse cur=1LL*C(p+(now+2*i+j-1),now+2*i+j-1)*C(n-j-now-p+1,i+j)%mod;\n\t\t\t\t\tAdd(ans,1LL*coef*cur%mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =1000000007;\n\nmap< vector<int>, int > M;\nvector< vector<int> > Mi;\nvector<int> cnt[36][3];\nvector<int> cnt_nw[36][3];\n\nvoid put(vector<int> &seq, int x) {\n\tfor(int i =(int)seq.size()-1; i >= 0; i--) if(seq[i] >= x) {\n\t\tseq.insert(begin(seq)+i+1,x);\n\t\treturn;\n\t}\n\tseq.insert(begin(seq),x);\n}\n\nint get_id(vector<int> &seq) {\n\tauto it =M.find(seq);\n\tif(it == M.end()) {\n\t\tint m =M.size();\n\t\tM[seq] =m;\n\t\tMi.push_back(seq);\n\t\treturn m;\n\t}\n\treturn it->ss;\n}\n\nvoid dump(int id, int v_cur, int open_st, cat cnt_cur) {\n\tif(id >= (int)cnt_nw[v_cur][open_st].size())\n\t\tcnt_nw[v_cur][open_st].resize(id+1,0);\n\tcnt_nw[v_cur][open_st][id] +=cnt_cur;\n\tif(cnt_nw[v_cur][open_st][id] >= mod) cnt_nw[v_cur][open_st][id] -=mod;\n}\n\nint CNT =0;\n\nvoid push(int id, int v_cur, int open_st, cat cnt_cur) {\n\tCNT++;\n\tif(open_st == 0) {\n\t\t// white\n\t\tdump(id,0,0,cnt_cur);\n\t\t// red\n\t\tdump(id,0,1,cnt_cur);\n\t\t// blue\n\t\tdump(id,0,2,cnt_cur);\n\t}\n\tif(open_st == 1) {\n\t\t// white\n\t\tvector<int> seq =Mi[id];\n\t\tput(seq,v_cur);\n\t\tint id_nw =get_id(seq);\n\t\tdump(id_nw,0,0,cnt_cur);\n\t\t// red\n\t\tdump(id,v_cur,1,cnt_cur);\n\t\t// blue\n\t\tdump(id,v_cur,2,cnt_cur);\n\t}\n\tif(open_st == 2) {\n\t\t// white\n\t\tvector<int> seq =Mi[id];\n\t\tput(seq,v_cur+1);\n\t\tint id_nw =get_id(seq);\n\t\tdump(id_nw,0,0,cnt_cur);\n\t\t// red\n\t\tdump(id,v_cur+1,1,cnt_cur);\n\t\t// blue\n\t\tdump(id,v_cur,2,cnt_cur);\n\t}\n\t\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N,K;\n\tstring S;\n\tcin >> N >> K >> S;\n\tMi.resize(1);\n\tM[vector<int>()] =0;\n\tcnt[0][0].resize(1,1);\n\tint CNT2 =0;\n\tfor(int i =N; i > 0; i--) {\n\t\tfor(int j =0; j <= 35; j++) for(int k =0; k < 3; k++)\n\t\t\tfor(int l =0; l < (int)cnt[j][k].size(); l++)\n\t\t\t\tpush(l,j,k,cnt[j][k][l]);\n\t\tfor(int j =0; j <= 35; j++) for(int k =0; k < 3; k++) {\n\t\t\tcnt[j][k].resize(cnt_nw[j][k].size());\n\t\t\tfor(int l =0; l < (int)cnt_nw[j][k].size(); l++) {\n\t\t\t\tcnt[j][k][l] =cnt_nw[j][k][l];\n\t\t\t\tcnt_nw[j][k][l] =0;\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<int,cat> cnt0;\n\tfor(int j =0; j <= 35; j++) for(int k =0; k < 3; k++)\n\t\tfor(int l =0; l < (int)cnt[j][k].size(); l++) if(cnt[j][k][l]) {\n\t\tvector<int> seq =Mi[l];\n\t\tint v_cur =j;\n\t\tif(k == 2) v_cur++;\n\t\tif(k != 0) put(seq,v_cur);\n\t\tint id =get_id(seq);\n\t\tcnt0[id] +=cnt[j][k][l];\n\t\tif(cnt0[id] >= mod) cnt0[id] -=mod;\n\t}\n\tcout << cnt0.size() << \".\\n\";\n\n\tint ans =0;\n\tALL_THE(cnt0,it) {\n\t\tvector<int> seq =Mi[it->ff];\n\t\tint a =0, b =0;\n\t\tbool ok =true;\n\t\tfor(int i =0; i < (int)seq.size(); i++) {\n\t\t\twhile(a < K && S[a] == 'b') {\n\t\t\t\ta++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a == K) {\n\t\t\t\tok =false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta++;\n\t\t\tb =max(b,a);\n\t\t\tfor(int j =0; j < seq[i]; j++) {\n\t\t\t\twhile(b < K && S[b] == 'r') b++;\n\t\t\t\tif(b == K) {\n\t\t\t\t\tok =false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tif(!ok) break;\n\t\t}\n\t\tif(!ok) continue;\n\t\tans +=it->ss;\n\t\tif(ans >= mod) ans -=mod;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nint N, K;\nchar S[111];\n\nbool ok(int r, int b, int x) {\n    int u = 0;\n    REP (i, K) {\n\tif (S[i] == 'r') {\n\t    if (r) { r--; u++; }\n\t    else if (x) x--;\n\t} else if (S[i] == 'b') {\n\t    if (b && u) { b--; u--; }\n\t    else if (x) x--;\n\t}\n    }\n    return r == 0 && b == 0 && x == 0;\n}\n\nMint buf[2][72][72][72][4];\nMint (*cur)[72][72][4] = buf[0];\nMint (*nxt)[72][72][4] = buf[1];\n\nvoid MAIN() {\n    scanf(\"%d%d%s\", &N, &K, S);\n\n    cur[0][0][0][0] = 1;\n\n    REP (i, N) {\n\tmemset(nxt, 0, sizeof buf[0]);\n\tREP (r, i+1) REP (b, i+1) REP (x, i+1) {\n\t    nxt[r][b][x][0] += cur[r][b][x][0];\n\t    nxt[r+1][b][x][1] += cur[r][b][x][0];\n\t    nxt[r+1][b+1][x][2] += cur[r][b][x][0];\n\n\t    nxt[r][b][x][0] += cur[r][b][x][1];\n\t    nxt[r][b][x][1] += cur[r][b][x][1];\n\t    nxt[r][b+1][x][2] += cur[r][b][x][1];\n\n\t    nxt[r][b][x][0] += cur[r][b][x][2];\n\t    nxt[r][b][x][2] += cur[r][b][x][2];\n\t    nxt[r][b][x][3] += cur[r][b][x][2];\n\n\t    nxt[r][b][x][0] += cur[r][b][x][3];\n\t    nxt[r][b][x+1][2] += cur[r][b][x][3];\n\t    nxt[r][b][x][3] += cur[r][b][x][3];\n\t}\n\tswap(cur, nxt);\n    }\n\n    Mint ans = 0;\n    REP (r, N+1) REP (b, N+1) REP (x, N+1) REP (c, 4) {\n\tMint v = cur[r][b][x][c];\n\tif (v.x == 0) continue;\n\tassert(r >= b);\n\tif (ok(r, b, x)) {\n\t    ans += v;\n\t}\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\nconst int M = 200000;\nll fact[M], invfact[M];\nvoid init(void) {\n  fact[0] = 1;\n  REP(i, 1, M) {\n    fact[i] = fact[i - 1] * i % mod;\n  }\n  invfact[M - 1] = powmod(fact[M - 1], mod - 2);\n  for (int i = M - 2; i >= 0; --i) {\n    invfact[i] = invfact[i + 1] * (i + 1) % mod;\n  }\n}\n\nll comb(int x, int y) {\n  if (x < 0) {\n    return y == 0 || y == x ? 1 : 1;\n  }\n  if (y < 0 || y > x) {\n    return 0;\n  }\n  long r = fact[x] * (invfact[x - y] * invfact[y] % mod) % mod;\n  return r;\n}\n\nvoid add(ll &x, ll y) {\n  x = (x + y) % mod;\n}\n\n\nint n, k;\nstring s;\n\nll match(const VI &v) {\n  int m = v.size();\n  VI r(m, -1);\n  VI used(k, 0);\n  int pos = 0;\n  REP(i, 0, m) {\n    while (pos < k && s[pos] != 'r') {\n      pos++;\n    }\n    if (pos == k) return 0;\n    r[i] = pos;\n    used[pos] = 1;\n    pos++;\n  }\n  pos = 0;\n  REP(i, 0, m) {\n    if (v[i] <= 1) break;\n    pos = max(pos, r[i] + 1);\n    while (pos < k && s[pos] != 'b') { pos++; }\n    if (pos == k) return 0;\n    used[pos] = 1;\n    pos++;\n  }\n  pos = 0;\n  REP(i, 0, m) {\n    if (v[i] <= 2) break;\n    int res = v[i] - 2;\n    REP(j, 0, res) {\n      while (pos < k && used[pos] == 1) { pos++; }\n      if (pos == k) return 0;\n      used[pos] = 1;\n      pos++;\n    }\n  }\n  ll tmp = fact[v.size()];\n  map<int, int> freq;\n  REP(i, 0, v.size()) {\n    freq[v[i]] += 1;\n  }\n  for (auto p: freq) {\n    tmp = tmp * invfact[p.second] % mod;\n  }\n  int x = n + 1;\n  int y = 0;\n  REP(i, 0, v.size()) {\n    if (v[i] >= 2) {\n      x += 2;\n    }\n    y += 2 * v[i];\n  }\n  if(DEBUG){\n    DEBUGP(x);\n    DEBUGP(y);\n  }\n  tmp = tmp * comb(x, y) % mod;\n  return tmp;\n}\n\nint cnt = 0;\nll tot = 0;\nvoid output(const VI &vi) {\n  cnt++;\n  if (DEBUG && n <= 10) {\n    cerr << \"out:\";\n    for (auto c: vi) cerr << \" \" << c;\n    cerr << endl;\n  }\n  ll res = match(vi);\n  add(tot, res);\n  if (DEBUG) {\n    DEBUGP(res);\n    cerr<<endl;\n  }\n}\n\n\nvoid calc(int rem, int ma, int maxlen, VI &v) {\n  if (rem < -1) return;\n  output(v);\n  if ((int) v.size() >= maxlen) return;\n  for (int i = ma; i >= 1; --i) {\n    v.push_back(i);\n    int len = i <= 1 ? 1 : 2 * i - 3;\n    calc(rem - len - 1, i, maxlen, v);\n    v.pop_back();\n  }\n}\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init();\n  cin >> n >> k;\n  cin >> s;\n  VI ret;\n  int rc = 0;\n  REP(i, 0, k) {\n    if (s[i] == 'r') rc++;\n  }\n  calc(n, k - rc, rc, ret);\n  DEBUGP(cnt);\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nint n,k;\nint C[555][555];\nint inv[555];\nchar seq[75];\nint mat[75],fact[555];\nint pos[75],cnt;\nint ln[75];\nint ans;\nconst int mod = 1000000007;\n\nint qpow(int base,int tms)\n{\n\tint tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * 1ll * base % mod;\n\t\tbase = base * 1ll * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nbool chk(int cn)\n{\n\tstatic int sum[75]; memset(sum,0,sizeof(sum));\n\tfor(int i = cn;i >= 1; -- i)\n\t{\n\t\tif(!pos[i]) return false;\n\t\tsum[pos[i]] ++;\n\t\tif(ln[cn - i + 1] >= 2)\n\t\t{\n\t\t\tif(!mat[pos[i]]) return false;\n\t\t\tsum[mat[pos[i]]] += ln[cn - i + 1] - 1;\n\t\t}\n\t}\n\tfor(int i = k;i >= 1; -- i)\n\t{\n\t\tsum[i] += sum[i + 1];\n\t\tif(sum[i] > k - i + 1) return false;\n\t}\n\treturn true;\n}\n\nbool dfs(int mi,int cnt,int mus)\n{\n\tif(!chk(cnt)) return false;\n\tint k = cnt + 1;\n\tfor(int i = 1;i <= cnt; ++ i)\n\t\tk += 2 * ln[i] - 1;\n\tint as = C[n - mus + k - 1][k - 1];\n\tif(k > 500) cerr << k << endl; \n\tint p = 0;\n\tfor(int i = 1;i <= cnt; ++ i)\n\t{\n\t\tif(ln[i] != ln[i - 1])\n\t\t\tas = as * 1ll * inv[p] % mod,p = 0;\n\t\tp ++;\n\t}\n\tas = as * 1ll * inv[p] % mod;\n\tas = as * 1ll * fact[cnt] % mod;\n\tans = (ans + as) % mod;\n\tfor(int i = mi;i <= 70; ++ i)\n\t{\n\t\tln[cnt + 1] = i;\n\t\tint nw = mus;\n\t\tif(cnt) nw ++;\n\t\tnw += i <= 2 ? 1 : 2 * i - 3;\n\t\tif(nw > n) break;\n\t\tif(!dfs(i,cnt + 1,nw)) break;\n\t}\n\treturn true;\n}\n\nsigned main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tscanf(\"%s\",seq + 1);\n\tint po = 1;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tif(seq[i] == 'r')\n\t\t{\n\t\t\tpo = max(po,i);\n\t\t\twhile(po <= n && seq[po] != 'b') po ++;\n\t\t\tif(po <= n)\n\t\t\t\tmat[i] = po ++;\n\t\t\tpos[++ cnt] = i;\n\t\t}\n\t}\n\tC[0][0] = 1;\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tint pre = 1;\n\tfor(int i = 1;i <= 550; ++ i)\n\t{\n\t\tpre = pre * 1ll * i % mod;\n\t\tfact[i] = pre;\n\t\tinv[i] = qpow(pre,mod - 2);\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1;j <= i; ++ j)\n\t\t\tC[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n\t}\n\tdfs(1,0,0);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], suf[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nbool check () {\n\tvector<int> vec1, vec2, vec3;\n\tfor (int i = 0; i < top; i++) vec1.push_back(stk[i]);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') {\n\t\t\tif (!vec1.empty()) {\n\t\t\t\tif (vec1.back()) vec2.push_back(vec1.back());\n\t\t\t\tvec1.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\tvec3.back()--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!vec2.empty()) {\n\t\t\t\tif (vec2.back() > 1) vec3.push_back(vec2.back() - 1);\n\t\t\t\tvec2.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\tvec3.back()--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn vec1.empty() && vec2.empty() && vec3.empty();\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 510;\nconst int mod = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check()\n{\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    FOR(i, 1, k)\n    {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update()\n{\n    ll tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1)\n    {\n        for(j = i; j < tot && a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % mod;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % mod;\n    if ((ans += tmp) >= mod) ans -= mod;\n}\n\nvoid dfs(int mx)\n{\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    ++tot; --left; dfs(a[tot] = 1); ++left;\n    FOR(i, 2, mx)\n    {\n        left -= i * 2 - 3;\n        dfs(a[tot] = i);\n        left += i * 2 - 3;\n    }\n    a[tot--] = 0;\n    if (tot) ++left;\n}\n\nint main()\n{\n    FOR(i, 0, 500)\n    {\n        c[i][0] = 1;\n        FOR(j, 1, 500)\n            if ((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= mod)\n                c[i][j] -= mod;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(n);\n    printf(\"%d\\n\", ans + 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define inver(a) power(a,mod-2)\nusing namespace std;\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;}\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=1000+5;\nconst int maxk=70+5;\nint n,k;\nint an;\nint r[maxk],b[maxk];\nint fac[maxn];\nint inv[maxn];\nint num[maxk];\nbool vis[maxk];\nchar s[maxk];\nvector<int> a; \ninline int add(int x) {return x>=mod?x-mod:x;}\nll power(ll x,ll y)\n{\n\tll re=1;\n\twhile(y)\n\t{\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\ninline int binom(int x,int y)\n{\n\treturn (ll)fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nbool check()\n{\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0,j=1;i<a.size();++i)\n\t{\n\t\twhile(j<=k&&s[j]!='r') ++j; if(j>k) return 0;\n\t\tr[i]=j,vis[j++]=1;\n\t}\n\tfor(int i=0,j=1;i<a.size();++i) if(a[i]>=2)\n\t{\n\t\tCmax(j,r[i]+1);\n\t\twhile(j<=k&&s[j]!='b') ++j; if(j>k) return 0;\n\t\tb[i]=j,vis[j++]=1;\n\t}\n\tfor(int i=0,j=1;i<a.size();++i) if(a[i]>=3)\n\t{\n\t\tCmax(j,b[i]+1);\n\t\tint T=a[i]-2; while(T--)\n\t\t{\n\t\t\twhile(j<=k&&vis[j]) ++j; if(j>k) return 0;\n\t\t\tvis[j++]=1;\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int rest,int las)\n{\n\tif(check())\n\t{\n\t\tint v=a.size()+1;\n\t\tfor(int i=0;i<a.size();++i)\n\t\t{\n\t\t\tv+=num[a[i]];\n\t\t\tif(a[i]>1) v+=2;\n\t\t}\n\t\tint re=(ll)binom(rest+v-1,rest)*fac[a.size()]%mod;\n\t\tfor(int i=0,j;i<a.size();i=j)\n\t\t{\n\t\t\tj=i; while(j<a.size()&&a[j]==a[i]) ++j;\n\t\t\tre=(ll)re*inv[j-i]%mod;\n\t\t}\n\t\tan=add(an+re);\n\t}\n\tfor(int i=1;i<=las;++i)\n\t{\n\t\tif(num[i]+1>rest) break;\n\t\ta.push_back(i);\n\t\tdfs(rest-num[i]-1,i);\n\t\ta.pop_back();\n\t}\n}\nvoid init(int n)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfac[i]=(ll)fac[i-1]*i%mod;\n\t}\n\tinv[n]=inver(fac[n]);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tinv[i-1]=(ll)inv[i]*i%mod;\n\t}\n}\nint sol()\n{\n\tinit(1000);\n\tan=1;\n\tnum[1]=1;\n\tnum[2]=1;\n\tfor(int i=3;i<=70;++i) num[i]=num[i-1]+2;\n\tfor(int i=1;;++i)\n\t{\n\t\tif(num[i]>n) break;\n\t\ta.push_back(i);\n\t\tdfs(n-num[i],i);\n\t\ta.pop_back();\n\t}\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tprintf(\"%d\\n\",sol());\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\n\nint N, K;\nstring S;\nint dp1[72][72][2];\nint T[72][72];\nint nCr[201][201];\nvector<int> black, white;\nint dp2[2][72][72][72];\nint wh_ptr[72], gain[72];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  nCr[0][0] = 1;\n  for (int i=1; i<=200; i++) {\n    nCr[i][0] = 1;\n    for (int j=1; j<=200; j++) nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j])%MOD;\n  }\n\n  cin >> N >> K >> S;\n  rep(i, K) {\n    if (S[i] == 'r') black.pb(i);\n    else white.pb(i);\n  }\n  if (black.empty()) {\n    cout << 1 << \"\\n\";\n    return 0;\n  }\n  rep(i, max(N, K)+1) gain[i] = -INF, wh_ptr[i] = white.size();\n  int head = 0;\n  rep(i, black.size()) {\n    int g = 0;\n    while (head < white.size() && white[head] < black[i]) {\n      head++, g++;\n    }\n    if (head == white.size()) {\n      break;\n    }\n    head++;\n    wh_ptr[i] = head;\n    gain[i] = g;\n  }\n\n  dp1[0][0][0] = 1;\n  for (int len=0; len<N; len++) {\n    rep(num, N+1) {\n      rep(last, 2) {\n        add(dp1[len+1][num][0], dp1[len][num][last]); // ○\n        add(dp1[len+1][num+(last==0)][1], dp1[len][num][last]); // ●\n      }\n    }\n  }\n  rep(len, N+1) rep(num, N+1) if (num>0) T[len][num-1] = (dp1[len][num][0]+dp1[len][num][1])%MOD;\n\n  dp2[0][0][0][0] = 1;\n  for (int star=N; star>=0; star--) {\n    for (int len=N; len>=1; len--) {\n      if (T[len][star] == 0) continue;\n\n      rep(i, N+1) rep(j, N+1) rep(k, N+1) dp2[1][i][j][k] = dp2[0][i][j][k];\n      rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n        if (dp2[0][groups][sum][now] == 0) continue;\n        int cur = now;\n        int val = (1LL*dp2[0][groups][sum][now]*T[len][star])%MOD;\n        for (int num=1; groups+num<=min(N, (int)black.size()) && sum+num*len<=N; num++) {\n          cur = max(cur-gain[groups+num-1], 0) + star;\n          if (cur > N) break;\n          add(dp2[1][groups+num][sum+num*len][cur], (1LL*val*nCr[groups+1-1+num][num])%MOD);\n          val = (1LL*val*T[len][star])%MOD;\n        }\n      }\n      swap(dp2[0], dp2[1]);\n\n      /*\n      rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n        if (dp2[0][groups][sum][now] == 0) continue;\n        int cur = now;\n        int val = (1LL*dp2[0][groups][sum][now]*T[len][star])%MOD;\n        for (int num=1; groups+num<=min(N, (int)black.size()) && sum+num*len<=N; num++) {\n          cur = max(cur-gain[groups+num-1], 0) + star;\n          if (cur > N) continue;\n          add(dp2[1][groups+num][sum+num*len][cur], (1LL*val*nCr[groups+1-1+num][num])%MOD);\n          val = (1LL*val*T[len][star])%MOD;\n        }\n      }\n      */\n    }\n  }\n  rep(i, N+1) rep(j, N+1) rep(k, N+1) dp2[1][i][j][k] = 0;\n  rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n    int gain = 0;\n    if (groups > 0) gain = white.size() - wh_ptr[groups-1];\n    int cur = max(now-gain, 0);\n    add(dp2[1][groups][sum][cur], dp2[0][groups][sum][now]);\n  }\n  swap(dp2[0], dp2[1]);\n\n  for (int len=N; len>=1; len--) {\n    rep(i, N+1) rep(j, N+1) rep(k, N+1) dp2[1][i][j][k] = dp2[0][i][j][k];\n    rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n      if (dp2[0][groups][sum][now] == 0) continue;\n      int cur = now;\n      int val = (1LL*dp2[0][groups][sum][now])%MOD;\n      for (int num=1; groups+num<=min(N, (int)black.size()) && sum+num*len<=N; num++) {\n        add(dp2[1][groups+num][sum+num*len][cur], (1LL*val*nCr[groups+1-1+num][num])%MOD);\n      }\n    }\n    swap(dp2[0], dp2[1]);\n  }\n\n  int s = 1; // all white\n  for (int groups=1; groups<=N; groups++) rep(sum, N+1) rep(cur, N+1) {\n    if (dp2[0][groups][sum][cur] == 0) continue;\n\n    if (groups > black.size()) continue;\n    int gain = black.size() - groups;\n    if (gain < cur) continue;\n\n    int yo = N-sum;\n    if (yo < groups-1) continue;\n    yo -= groups-1;\n    add(s, (1LL*nCr[yo+groups][yo]*dp2[0][groups][sum][cur])%MOD);\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int MAXN = 73;\ntypedef long long LL;\nconst LL MOD = 1000000007;\nint N, M, minLen[MAXN], Belong[MAXN], Last[MAXN];\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\nvector<int> Seq;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check()\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1] && Size)--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check())Calc(Tot, V);\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= N; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, newV, 1, Tot + minLen[Len]);\n\tSeq.pop_back();\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N / 2 + 1, M, N, V2, 0, 0);\n\tcout << (Ans + 1) % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 141\nchar s[MN+5];\nmint F[MN+5],R[MN+5],ans;\nint n,a[MN+5],an,b[MN+5],bn,u[MN+5],p[MN+5];\ninline mint C(int n,int m){return F[n]*R[m]*R[n-m];}\nvoid dfs(int x,int y,int z,int s0)\n{\n\tint i,j,k;\n\tmemset(u,0,sizeof(u));\n\tfor(i=j=1;i<z;u[a[i++]]=1)if(p[z-i])\n\t{\n\t\twhile(j<=bn&&b[j]<a[i])++j;\n\t\tif(j>bn)break;\n\t\tu[b[j++]]=1;\n\t}\n\tif(i==z)for(i=j=1;i<z;++i)\n\t{\n\t\tfor(k=1;k<p[z-i];++k)\n\t\t{\n\t\t\twhile(s[j]&&(j<i||u[j]))++j;\n\t\t\tif(!s[j++])break;\n\t\t}\n\t\tif(k<p[z-i])break;\n\t}\n\tif(i==z)\n\t{\n\t\tmint s=F[z-1];\n\t\tfor(i=1;i<z;s*=R[j-i],i=j)for(j=i;j<z&&p[i]==p[j];++j);\n\t\tans+=s*C(n+2*(z-1-s0),2*(z-1+x));\n\t}\n\tif(z<=an)for(;x+y<=an+bn-z&&x+y+s0+!y<=n/2;++y)dfs(x+y,p[z]=y,z+1,s0+!y);\n}\nint main()\n{\n\tint m,i;\n\tscanf(\"%d%d%s\",&n,&m,s+1);++n;\n\tfor(F[0]=i=1;i<=MN;++i)F[i]=F[i-1]*i;\n\tfor(R[i=MN]=~F[MN];i--;)R[i]=R[i+1]*(i+1);\n\tfor(i=1;i<=m;++i)(s[i]=='r'?a[++an]:b[++bn])=i;\n\tdfs(0,0,1,0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint exp(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) {\n    return exp(x, mod - 2);\n}\nint fact[500], invf[500];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, K;\nstring S;\nvector<int> R, B;\n\nstruct Group {\n    vector<int> f;\n};\nvector<Group> group;\nGroup tmp;\n\nvoid dfs(int p, int g, int f) {\n    if(p >= N) {\n        group.push_back(tmp);\n        return;\n    }\n    if(f) {\n        group.push_back(tmp);\n    }\n    if(max(p + 2*g, p + 2) > N + 1) return;\n\n    dfs(p, g + 1, 0);\n\n    if(max(p + 2*g, p + 2) <= N + 1) {\n        tmp.f.push_back(g);\n        dfs(max(p + 2*g, p + 2), g, 1);\n        tmp.f.pop_back();\n    }\n}\n\nbool chk(int len) {\n    int pos1 = 0, pos2 = 0;\n    for(int i = 0; i < len; i++) {\n        while(pos2 < B.size() && R[pos1] > B[pos2]) pos2++;\n\n        if(pos2 == B.size()) return false;\n        pos1++;\n        pos2++;\n    }\n    return true;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 500; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 500; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> K >> S;\n\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'r') R.push_back(i);\n        else B.push_back(i);\n    }\n\n    dfs(0, 0, 1);\n\n    int ans = 0;\n    for(int g = 0; g < group.size(); g++) {\n        vector<int> f = group[g].f;\n\n        int sum = 0;\n        int x = 0;\n        for(int i = 0; i < f.size(); i++) {\n            sum += f[i];\n\n            if(f[i] == 0) x++;\n            else x += 2*f[i] - 1;\n        }\n\n        if(f.size() > R.size()) continue;\n        if(sum + f.size() > K) continue;\n\n        int t = fact[ f.size() ];\n\n        int cnt = 0;\n        for(int i = 0; i < f.size(); i++) {\n            cnt++;\n            if(i == f.size() - 1 || f[i] != f[i + 1]) {\n                t = 1LL * t * invf[cnt] % mod;\n                cnt = 0;\n            }\n        }\n\n        t = 1LL * t * H(2*sum + 2*f.size() + 1, N - x - (int)f.size() + 1) % mod;\n\n        int len = 0;\n        for(int i = 0; i < f.size(); i++) {\n            if(f[i] != 0) len++;\n        }\n\n        if(chk(len)) {\n            ans += t;\n            ans %= mod;\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\nvpint ei;\nint dp[111][111];\nint table[100][100][100];\nint calc(){\n    /*\n    if(X[0]==1){\n        if(X.size()>R)return 0;\n        int n=X.size();\n        int y=N-(2*n+1);\n        return nCk(2*n+y,y);\n    }*/\n    X.clear();\n    rep(i,ei.size())rep(j,ei[i].se)X.pb(ei[i].fi);\n\n    int n=X.size();\n    if(n>R)return 0;\n    int nr=R-n,nb=B;\n    for(int i=0;i<X.size();i++){\n        int pos=r[R-i];\n        while(nb>0&&b[nb]<pos)nb--;\n        if(X[i]==1)continue;\n        if(nb==0)return 0;\n        while(nr>0&&r[nr]<b[nb])nr--;\n        nb--;\n        rep(t,X[i]-2){\n            if(i+1<n&&nb&&b[nb]<r[R-i-1]){\n                nb--;\n                continue;\n            }\n            if(nr){\n                nr--;\n                continue;\n            }\n            if(nb){\n                nb--;\n                continue;\n            }\n            return 0;\n        }\n    }\n\n    int ret=0;\n    for(int i=0;i<=N;i++){\n        add(ret,dp[ei.size()][i]*nCk(N-i+1,n)%mod);\n    }\n\n    ret=ret*fact[n]%mod;\n    rep(i,ei.size())ret=ret*inv[ei[i].se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    for(int i=1;i<ei.back().fi;i++){\n        for(int j=1;;j++){\n            int nn=n+j;\n            if(i==1)nn+=j;\n            else nn+=(2*i-3)*j;\n\n            int nk=k+i*j;\n            if(nn>N||nk>K)break;\n            for(int k=0;k<=N;k++)dp[ei.size()+1][k]=0;\n            for(int k=0;k<N;k++){\n                if(i==1)for(int l=j;k+l<=N;l++)add(dp[ei.size()+1][k+l],dp[ei.size()][k]*table[i][j][l]%mod);\n                else for(int l=(2*i-3)*j;k+l<=N;l++)add(dp[ei.size()+1][k+l],dp[ei.size()][k]*table[i][j][l]%mod);\n            }\n            ei.pb({i,j});\n            dfs(nn,nk);\n            ei.pop_back();\n        }\n    }\n\n    /*\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }*/\n}\n\nsigned main(){\n    for(int i=1;i<=77;i++){\n        table[i][0][0]=1;\n        for(int j=0;j<77;j++){\n            for(int k=0;k<77;k++){\n                if(i==1){\n                    for(int l=1;k+l<=77;l++)add(table[i][j+1][k+l],table[i][j][k]);\n                }\n                else{\n                    for(int l=0;2*i-3+k+l<=77;l++){\n                        add(table[i][j+1][k+2*i-3+l],table[i][j][k]*nCk(2*i-2+l,l)%mod);\n                    }\n                }\n            }\n        }\n    }\n\n    cin>>N>>K;\n    cin>>S;\n\n   // if(N>30||K>30)assert(0);\n\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        if(i==1){\n            for(int j=1;j<=N;j++){\n                for(int k=0;k<=N;k++)dp[1][k]=table[i][j][k];\n                ei.pb({1,j});\n                dfs(2*j-1,j);\n                ei.pop_back();\n            }\n        }\n        else{\n            for(int j=1;(2*i-3)*j+j-1<=N;j++){\n                for(int k=0;k<=N;k++)dp[1][k]=table[i][j][k];\n                ei.pb({i,j});\n                dfs((2*i-3)*j+j-1,i*j);\n                ei.pop_back();\n            }\n        }\n    }\n\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nchar in[110];\nint R[110];\nint bl[110];\nint used[110];\nint lim[110];\nint sz;\nlong long C[210][210];\nlong long fact[110];\nlong long inv[110];\nlong long finv[110];\nint now[110];\n \nlong long dp[110][110][110];\nlong long calc(int x,int y,int a){\n\tfor(int i=0;i<80;i++)for(int j=0;j<80;j++)for(int k=0;k<80;k++)dp[i][j][k]=0;\n\tdp[0][0][0]=1;\n\tint n=a-y-(x+y-1);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=x;j++){\n\t\t\tfor(int k=0;k<=n;k++){\n\t\t\t\tif(!dp[i][j][k])continue;\n\t\t\t\tfor(int l=0;j+l<=x&&k+l*(2*i+1)<=n;l++){\n\t\t\t\t\tif(l&&lim[x-l-j]<(k-j)/2+l*i)break;\n\t\t\t\t\tdp[i+1][j+l][k+l*(2*i+1)]=(dp[i][j][k]*C[j+l+y][l]+dp[i+1][j+l][k+l*(2*i+1)])%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<=n;i++){\n\t\tret=(ret+C[n+3*x+2*y][n-i]*dp[n][x][i])%mod;\n\t}\n\t//printf(\"%d %d %d: %lld\\n\",x,y,a,ret);\n\treturn ret;\n}\nint main(){\n\tC[0][0]=1;\n\tfor(int i=0;i<205;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tC[i+1][j]=(C[i+1][j]+C[i][j])%mod;\n\t\t\tC[i+1][j+1]=(C[i+1][j+1]+C[i][j])%mod;\n\t\t}\n\t}\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\t//n=a;\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<110;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfor(int i=1;i<110;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n\tscanf(\"%s\",in);\n\tlong long ret=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(in[i]=='r'){\n\t\t\tR[sz++]=i;\n\t\t}\n\t}\n\tfor(int i=0;i<=sz;i++){\n\t\tfor(int j=0;i+j<=sz;j++){\n\t\t\tfor(int k=0;k<b;k++)used[k]=lim[k]=0;\n\t\t\tfor(int k=0;k<i+j;k++)used[R[k]]=1;\n\t\t\tbool dame=false;\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(int l=R[k];l<b;l++){\n\t\t\t\t\tif(!used[l]&&in[l]=='b'){\n\t\t\t\t\t\tok=true;used[l]=1;bl[k]=l;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!ok){dame=true;break;}\n\t\t\t}\n\t\t\tif(dame)continue;\n\t\t//\tprintf(\"%d %d\\n\",i,j);\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tfor(int l=bl[k]+1;l<b;l++){\n\t\t\t\t\tif(!used[l])lim[k]++;\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tret=(ret+calc(i,j,a))%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 75;\nchar c[maxN];\nint n, k;\nint sz = 0;\nint red[maxN];\nint blue[maxN];\nint r = 1;\nint cnt1[3 * maxN];\nint cnt2[3 * maxN];\nint ans = 0;\nint LIM;\nint F = 0;\nint mark[maxN];\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint fact[2 * maxN];\nint invfact[2 * maxN];\nint inv[2 * maxN];\nint cnk(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return mult(fact[n], mult(invfact[n - k], invfact[k]));\n}\nbool check() {\n    memset(mark, -1, sizeof mark);\n    int ptr = 0;\n    int f = k;\n    while (ptr < sz && blue[ptr] == 0) {\n        if (f == 0) return false;\n        if (c[f] == 'b') {\n            f--;\n        }\n        else {\n            mark[f] = 1;\n            f--;\n            ptr++;\n        }\n    }\n    ptr--;\n    //[0 .. ptr] - ok\n    //\n    int ptrR = sz - 1;\n    int ptrB = sz - 1;\n    for (int i = 1; i <= k; i++) {\n        if (mark[i] != -1) continue;\n        if (c[i] == 'r' && ptrR > ptr) {\n            ptrR--;\n            mark[i] = 1;\n        }\n        if (c[i] == 'b' && ptrB > ptrR) {\n            ptrB--;\n            mark[i] = 1;\n        }\n    }\n    if (ptrR != ptr || ptrB != ptr) return false;\n    int where = sz - 1;\n    int need = red[sz - 1];\n    for (int i = 1; i <= k; i++) {\n        if (need == 0) return true;\n        if (mark[i] == 1) continue;\n        if (where > ptr) {\n            need--;\n            if (need == 0) {\n                where--;\n                need = red[where];\n            }\n        }\n    }\n    return (need == 0 || where == ptr);\n}\nint his_cnt[maxN];\nvoid calc() {\n    /*for (int i = 0; i < sz; i++) {\n        cout << red[i] << \" \" << blue[i] << endl;\n    }\n    cout << \"----------------------\" << endl;*/\n    if (!check()) {\n//        cout << \":(\" << endl;\n        return;\n    }\n\n    int val = fact[sz];\n    memset(his_cnt, 0, sizeof his_cnt);\n    int groups = 0;\n    int other = 0;\n    for (int i = 0; i < sz; i++) {\n        his_cnt[blue[i]]++;\n        val = mult(val, inv[his_cnt[blue[i]]]);\n        groups += blue[i] + red[i];\n        if (blue[i]) other++;\n    }\n    //so we have\n    // x_1 + ... + x_groups + y_1 + .. + y_2*other + c_1 + c_2 + p_1 + ... + p_(sz - 1) = n\n    // groups + 2 * other + sz - 1 + 2\n    int all_gr = groups + 2 * other + sz - 1 + 2;\n    ans = sum(ans, mult(val, cnk(n + all_gr - 1 - groups - (sz - 1), all_gr - 1)));\n}\nvoid gen(int pos, int total) {\n    if (total + sz - 1 > n) return;\n    if (sz > LIM) return;\n    if (pos == r) {\n        F++;\n        calc();\n        return;\n    }\n    gen(pos + 1, total);\n    if (pos == 0) {\n        red[sz] = 1;\n        blue[sz] = 0;\n        sz++;\n        gen(pos, total + 1);\n        sz--;\n    }\n    else {\n        red[sz] = cnt1[pos];\n        blue[sz] = cnt2[pos];\n        sz++;\n        gen(pos, total + red[sz - 1] + blue[sz - 1]);\n        sz--;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n    for (int i = 2; i < 2 * maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n\n    cin >> n >> k;\n    for (int i = 1; i <= k; i++) cin >> c[i];\n    LIM = (n + 1) / 2;\n    for (int d = 1; 2 * d - 1 <= n; d++) {\n        cnt1[r] = d - 1;\n        cnt2[r] = d;\n        r++;\n    }\n    gen(0, 0);\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nconstexpr lint MOD = 1000000007;\n\nvector<lint> fac, facInv, inv;\n\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\n\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\n\nint N, K;\nstring s;\n\nbool is_partition_able(vector<int> partition)\n{\n    int r_head = 0, b_head = 0;\n    int pending = 0;\n    for (auto c : s)\n    {\n        if (c == 'r')\n        {\n            if (r_head < partition.size()) r_head++;\n            else pending = max(pending-1, 0);\n        }\n        else\n        {\n            if (r_head == b_head || partition[b_head] < 2) pending = max(pending-1, 0);\n            else\n            {\n                pending += partition[b_head] - 2;\n                b_head++;\n            }\n        }\n    }\n    if (pending > 0 || (b_head < partition.size() && partition[b_head] > 1) || r_head < partition.size()) return false;\n    return true;\n}\n\n\nlint calc_for_each_partition(vector<int> &partition)\n{\n    if (!is_partition_able(partition)) return 0;\n\n    int rd = 0;\n    map<int, int> len_map;\n    for (auto v : partition)\n    {\n        len_map[v]++;\n        if (v > 1) rd += 2;\n    }\n    lint ans = nCr(N + 1 + rd, 2 * accumulate(partition.begin(), partition.end(), 0));\n    for (auto v : len_map) (ans *= facInv[v.second]) %= MOD;\n    (ans *= fac[partition.size()]) %= MOD;\n    return ans;\n}\n\n\nlint dfs(vector<int> partition_now)\n{\n    lint ans = calc_for_each_partition(partition_now);\n    int used_len = 0;\n    for (auto v : partition_now) used_len += 1 + max(v*2-3, 1);\n    int highest = partition_now.back();\n\n    partition_now.push_back(0);\n\n    if (partition_now.size() - 1 < K) for (int l=1; l<=min(highest, K-used_len); l++)\n    {\n        partition_now.back() = l;\n        ans += dfs(partition_now);\n    }\n    return ans % MOD;\n}\n\n\n// r -> b -> (n個のrまたはb)で島を作る\n\nint main()\n{\n    cin >> N >> K >> s;\n    facInit(70*3);\n\n    lint ans = 1;\n    for (int i=1; i<=K; i++)\n    {\n        (ans += dfs(vector<int>{i})) %= MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int mod=1e9+7;\nconst int maxn=400;\n\nint C[maxn][maxn],jc[maxn],jcn[maxn],inv[maxn];\n\nint n,k;\nchar str[maxn];\n\nint len;\nint rk[maxn],tp;\n\ninline void init()\n{\n\tC[0][0]=1; REP(i,1,300)REP(j,0,i)C[i][j]=(C[i-1][j]+(j?C[i-1][j-1]:0))%mod;\n\tjc[0]=jc[1]=jcn[0]=jcn[1]=inv[1]=1;\n\tREP(i,2,300)jc[i]=(ll)i*jc[i-1]%mod,inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod,jcn[i]=(ll)jcn[i-1]*inv[i]%mod;\n\tn=read();k=read(); len=n+1>>1;\n\tscanf(\"%s\",str+1);\n\tREP(i,1,k)if(str[i]=='r')rk[++tp]=i;\n}\n\nint p[maxn];\nint tot;\nint wp[maxn],B[maxn];\n\ninline bool check()\n{\n\tstatic int vis[maxn],RK[maxn];\n\tmemset(vis,0,sizeof(int)*(k+1));\n\n\tint now=0,num=0;\n\tDREP(i,tot,0)num+=p[i];\n\tif(num>tp)return 0;\n\tREP(i,1,num)vis[rk[i]]=1;\n\n\tint it=1;\n\tDREP(i,tot,0)\n\t{\n\t\tREP(j,1,p[i])\n\t\t{\n\t\t\tint x=rk[++now];\n\t\t\tif(i>=1)\n\t\t\t{\n\t\t\t\twhile(it<=k && (it<=x || vis[it] || str[it]=='r'))++it;\n\t\t\t\tif(it>k)return 0;\n\t\t\t\tRK[now]=it;\n\t\t\t\tvis[it]=1;\n\t\t\t}else RK[now]=x;\n\t\t}\n\t}\n\n\tnow=0;\n\tit=1;\n\tDREP(i,tot,0)\n\t{\n\t\tint NUM=p[i];\n\t\twhile(NUM--)\n\t\t{\n\t\t\tint x=RK[++now];\n\t\t\tint tim=i-1;\n\t\t\tif(i>=2)\n\t\t\t{\n\t\t\t\twhile(tim--)\n\t\t\t\t{\n\t\t\t\t\twhile(it<=k && (it<=x || vis[it] ))++it;\n\t\t\t\t\tif(it>k)return 0;\n\t\t\t\t\tvis[it]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\n\nint ans;\n\nvoid dfs(int u,int num,int s,int wz,int N,int pro)\n{\n\tif(u==-1)\n\t{\n\t\tpro=(ll)pro*jc[num]%mod;\n\t\twz++; N+=2;\n\t\t//DREP(i,len,0)pro=(ll)pro*jcn[p[i]]%mod;\n\t\tans=(ans+(ll)pro*C[N-1][wz-1])%mod;\n\t\treturn;\n\t}\n\t//int ad=u%4==0?2:u%4==1?0:1;\n\tREP(j,0,(n-s+1)/(wp[u]+1))\n\t{\n\t\tp[u]=j;\n\t\tif(num+j<=tp && check())\n\t\t\tdfs(u-1,num+j,s+j*wp[u]+j,wz+wp[u]*j+j+(u>0?2*j:0),N+(u>0?2*j:0),(ll)pro*jcn[j]%mod);\n\t\tp[u]=0;\n\t}\n}\n\ninline void doing()\n{\n\twp[0]=1;\n\tREP(i,1,len)\n\t{\n\t\twp[++tot]=i*2-1; B[tot]=i;\n\t}\n\tdfs(tot,0,0,0,n,1);\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=150,P=1e9+7;\nint n,m,top,ans,st[N],fac[N],ifac[N],inv[N],beg[N];\nchar s[N];\nbool vis[N];\nint C(int k1,int k2){\n\tif(k1<0||k2<0||k1-k2<0)return 0;\n\treturn 1LL*fac[k1]*ifac[k2]%P*ifac[k1-k2]%P;\n}\nbool chk(){\n\trep(i,1,m)vis[i]=0;\n\tint ntop=top;\n\trep(i,1,ntop)beg[i]=0;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='r')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t\tbeg[i]=beg[i];\n\t}\n\twhile(ntop&&st[ntop]==1)--ntop;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='b')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t}\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\trep(_,1,st[i]-2){\n\t\t\twhile(beg[i]<=m&&vis[beg[i]])++beg[i];\n\t\t\tif(beg[i]>m)return 0;\n\t\t\t++beg[i];\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int num,int mn,int mx,int ntop){\n\tif(!num){\n\t\tif(!chk())return;\n\t\trep(i,1,top){\n\t\t\tD(\"%d \",st[i]);\n\t\t}\n\t\tD(\"\\n\");\n\t\tD(\">>> %d %d\\n\",mn,mx);\n\t\tint ans=C(n-mn+mx-1,mx-1);\n\t\twhile(ntop){\n\t\t\tint x=st[ntop];\n\t\t\tint t=0;\n\t\t\twhile(st[ntop]==x)++t,--ntop;\n\t\t\tans=1LL*ans*C(ntop+t,t)%P;\n\t\t}\n\t\t(::ans+=ans)%=P;\n\t\treturn;\n\t}\n\twhile(1){\n\t\tdfs(num-1,mn,mx,ntop);\n\t\ttop=ntop;\n\t\tmn+=(num==1?1:2*num-3)+!!mn;\n\t\tif(mn>n)return;\n\t\tmx+=2*num;\n\t\tst[++top]=num;\n\t\t++ntop;\n\t}\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<N;++i)fac[i]=1LL*fac[i-1]*i%P,inv[i]=1LL*(P-P/i)*inv[P%i]%P,ifac[i]=1LL*ifac[i-1]*inv[i]%P;\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tdfs(n+2,0,1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n/*\n1 35\nrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbr\n\n3\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define cri const register int\n#define re register\nusing namespace std;\nconst int mod=1e9+7;\ninline int qpow(int a,int b,int ans=1){\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint fac[201],inv[201],n,k,nxt[77],v[77],vv[77],ans,num,len[77],R[77];\nchar s[77];\ninline int C(cri x,cri y){\n\treturn x<y||x<0||y<0?0:1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\ninline char check(cri p){\n\tmemset(v,0,sizeof v);memset(vv,0,sizeof vv);\n\tfor(int i=p,l=1;i;i--,l++){\n\t\tif(l>num) return 0;\n\t\tv[R[l]]=1;\n\t\tif(len[i]>=2){\n\t\t\tif(!nxt[l]) return 0;\n\t\t\tv[nxt[l]]=1;\n\t\t}\n\t\tvv[R[l]]=i;\n\t}\n\tfor(int i=k,sum=0;i;i--){\n\t\tif(!v[i]) sum++;\n\t\telse if(vv[i]){\n\t\t\tsum-=max(0,len[vv[i]]-2);\n\t\t\tif(sum<0) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\nchar dfs(cri p,cri mn,cri LEN){\n\tif(LEN>n||!check(p)) return 0;\n\tint s=p+1;\n\tfor(int i=1;i<=p;i++) s+=2*len[i]-1;\n\tint tmp=1ll*C(n-LEN+s-1,s-1)*fac[p]%mod,t=0;\n\tfor(int i=1;i<=p;i++,t++) \n\t\tif(len[i]!=len[i-1]) tmp=1ll*tmp*inv[t]%mod,t=0;\n\tans=(ans+1ll*tmp*inv[t])%mod;\n\tif(p==num) return 1;\n\tfor(int i=mn;i<=k;i++) \n\t\tif(!dfs(p+1,len[p+1]=i,LEN+(p!=0)+(i<=2?1:i*2-3))) break;\n\treturn 1;\n}\nint main(){\n\tcin>>n>>k;\n\tscanf(\"%s\",s+1);\n\tfor(int i=fac[0]=1;i<=200;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[200]=qpow(fac[200],mod-2);\n\tfor(int i=200;i;i--) inv[i-1]=1ll*inv[i]*i%mod;\n\tfor(int i=1;i<=k;i++) if(s[i]=='r')\n\t\tfor(int j=(R[++num]=i,i+1);j<=k;j++) if(!v[j]&&s[j]=='b'){\n\t\t\tnxt[num]=j;v[j]=1;break;\n\t\t}\n\tdfs(0,1,0);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 255\n#define ll long long\n#define mod 1000000007\nint n, k, ans, g, Ga, Gb;\nint c[N][N], S[N];\nchar s[N];\nvoid Calc()\n{\n\tint ga = g, gb = g, tot = 0;\n\tfor (int i = 1; i <= k; i++)\n\t\tif (s[i] == 'r' && ga)\n\t\t\tga--;\n\t\telse\n\t\t\tif (s[i] == 'b' && gb > ga && S[gb] > 1)\n\t\t\t\ttot += S[gb] - 2, gb--;\n\t\t\telse\n\t\t\t\tif (tot)\n\t\t\t\t\ttot--;\n\tfor (; S[gb] == 1;)gb--;\n\tif (ga || gb || tot)\n\t\treturn;\n\ttot = 1;\n\tfor (int i = 1, j = 0; i <= g; i = j + 1)\n\t{\n\t\tfor (; j < g && S[j + 1] == S[i];)j++;\n\t\ttot = (ll)tot * c[j][j - i + 1] % mod;\n\t}\n\tga = Ga - 1;\n\tgb = Gb + Ga;\n\tans = ((ll)tot * c[n - ga + gb][gb] + ans) % mod;\n}\nvoid Find(int m, int w, int len)\n{\n\tCalc();\n\t++g;\n\tint la = Ga, lb = Gb;\n\tfor (int i = len; m + (i == 1 ? 2 : i * 2 - 2) <= n + 1 && w + i <= k; i++)\n\t{\n\t\tGa = la + (i == 1 ? 2 : i * 2 - 2), Gb = lb + (i > 1) * 2, S[g] = i;\n\t\tFind(m + (i == 1 ? 2 : i * 2 - 2), w + i, i);\n\t}\n\t--g;\n}\nint main()\n{\n\tscanf(\"%d%d\\n%s\", &n, &k, s + 1);\n\tfor (int i = 0; i <= 250; i++)\n\t{\n\t\tc[i][0] = 1;\n\t\tfor (int j = 1; j <= i; j++)\n\t\t\tc[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tFind(0, 0, 1);\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define div _zzd001\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=75*2,mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n,k;\nint C[N][N];\nchar s[N];\nvector <int> div;\nint ans=0;\nint cr=0,cb=0;\nvoid Solve(){\n//\tans++;\n//\toutarr(div,0,(int)div.size()-1);\n\tint nr=0,nb=0;\n\tfor (auto i : div)\n\t\tnr++,nb+=i>1;\n\tif (nr>cr||nb>cb)\n\t\treturn;\n\tstatic int a[N];\n\tclr(a);\n\tint m=div.size();\n\tFor(i,0,m-1)\n\t\ta[i+1]=div[i];\n\tint ccb=0,p=0,mc=0;\n\treverse(a+1,a+m+1);\n\tFor(i,1,k){\n\t\tif (s[i]=='r')\n\t\t\tccb+=a[++p]-1;\n\t\telse\n\t\t\tccb--;\n\t\tif (ccb<0){\n\t\t\tmc-=ccb;\n\t\t\tccb=0;\n\t\t}\n\t}\n\tint r=k-ccb;\n\tfor (auto i : div)\n\t\tr-=i;\n\tif (r<0)\n\t\treturn;\n\tstatic int dp[N];\n\tstatic int cs[4]={0,0,1,0};\n\tclr(dp);\n\tdp[0]=1;\n\tfor (auto i : div){\n\t\tFod(j,n,0){\n\t\t\tFod(k,3,1){\n\t\t\t\tif (j+i*2-k+1>n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (i==1&&k>1)\n\t\t\t\t\tcontinue;\n\t\t\t\tAdd(dp[j+i*2-k+1],Add(dp[j]<<cs[k]));\n\t\t\t}\n\t\t\tdp[j]=0;\n\t\t}\n\t}\n\tint tmp=0;\n\tFor(i,0,n)\n\t\tif (dp[i])\n\t\t\tAdd(tmp,(LL)dp[i]*C[n][i]%mod);\n\tint las=1;\n\ta[m+1]=-1;\n\tint s=0;\n\tFor(i,2,m+1){\n\t\tif (a[i]!=a[i-1]){\n\t\t\tint len=i-las;\n\t\t\tlas=i;\n\t\t\ttmp=(LL)tmp*C[s+=len][len]%mod;\n\t\t}\n\t}\n\tAdd(ans,tmp);\n}\nvoid dfs(int rem,int n,int now,int flag){\n\tif (n<0)\n\t\treturn;\n\tif (flag)\n\t\tSolve();\n\tif (rem>=now){\n\t\tdiv.pb(now);\n\t\tdfs(rem-now,n-max(1,now*2-3)-1,now,1);\n\t\tdiv.pop_back();\n\t\tdfs(rem,n,now+1,0);\n\t}\n}\nint main(){\n\tFor(i,0,N-1)\n\t\tC[i][0]=1;\n\tFor(i,1,N-1)\n\t\tFor(j,1,i)\n\t\t\tC[i][j]=Add(C[i-1][j-1]+C[i-1][j]);\n\tn=read()+1,k=read();\n\tcin>>(s+1);\n\tFor(i,1,k)\n\t\tif (s[i]=='r')\n\t\t\tcr++;\n\t\telse\n\t\t\tcb++;\n\tdiv.clear();\n\tdfs(k,n,1,1);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 75;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint fac[MAXN], inv[MAXN], invn[MAXN];\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint binom(int x, int y) {\n\tif (y > x) return 0;\n\telse return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nchar s[MAXN];\nint n, m, p[MAXN], q[MAXN], r[MAXN], sum[MAXN];\nunordered_map <int, int> dp[MAXN][MAXN][MAXN][2];\nint split(int x, int y) {\n\tif (y > x) return 0;\n\telse return binom(x - 1, y - 1);\n}\nint Hash(int x, int y) {\n\treturn x * MAXN + y;\n}\nint getdp(int lft, int pos, int opt, int last, int cnt, bool type) {\n\tif (pos == 0) return 1;\n\tif (last > opt + 1) return 0;\n\tif ((last + 1) * pos > lft) return 0;\n\tif (last * pos > opt + sum[pos]) return 0;\n\tif (dp[lft][pos][opt][type].count(Hash(last, cnt))) {\n\t\treturn dp[lft][pos][opt][type][Hash(last, cnt)];\n\t}\n\tint &ans = dp[lft][pos][opt][type][Hash(last, cnt)];\n\tif (lft) {\n\t\tif (type) ans = getdp(lft - 1, pos, opt, last, cnt, type);\n\t\telse ans = 0;\n\t} else return ans = 0;\n\tupdate(ans, getdp(lft, pos, opt, last + 1, 0, false));\n\tif (last == 0) {\n\t\tfor (int i = 2; i <= lft; i++)\n\t\t\tupdate(ans, 1ll * invn[cnt + 1] * \n\t\t\t\t\t  getdp(lft - i, pos - 1, opt + r[pos] + (q[pos] != 0), last, cnt + 1, true) % P);\n\t} else if (q[pos] != 0) {\n\t\tfor (int i = 2 * last; i <= lft; i++)\n\t\t\tupdate(ans, 1ll * invn[cnt + 1] * (split(i - 1, 2 * last - 1) + 2ll * split(i - 1, 2 * last) + split(i - 1, 2 * last + 1)) % P *\n\t\t\t\t\t  getdp(lft - i, pos - 1, opt + r[pos] + 1 - last, last, cnt + 1, true) % P);\n\t}\n\treturn ans;\n}\nint func(int cnt) {\n\tstatic bool vis[MAXN]; int lft = 0;\n\tmemset(vis, false, sizeof(vis));\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] == 'r' && lft != cnt) {\n\t\t\tp[++lft] = i, q[lft] = 0;\n\t\t\tvis[i] = true;\n\t\t\tfor (int j = i; j <= m; j++)\n\t\t\t\tif (!vis[j] && s[j] == 'b') {\n\t\t\t\t\tvis[j] = true;\n\t\t\t\t\tq[lft] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\tif (lft != cnt) return 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tr[i] = 0;\n\t\tfor (int j = q[i - 1] + 1; j <= q[i] - 1; j++)\n\t\t\tr[i] += !vis[j];\n\t\tsum[i] = sum[i - 1] + r[i] + vis[p[i]] + vis[q[i]];\n\t}\n\tint cmt = 0;\n\tfor (int i = m; i >= 1; i--)\n\t\tif (vis[i]) break;\n\t\telse cmt++;\n\tfor (int i = 0; i < MAXN; i++)\n\tfor (int j = 0; j < MAXN; j++)\n\tfor (int k = 0; k < MAXN; k++) {\n\t\tdp[i][j][k][0].clear();\n\t\tdp[i][j][k][1].clear();\n\t}\n\treturn 1ll * getdp(n + 1, cnt, cmt, 0, 0, true) * fac[cnt] % P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"\\n%s\", s + 1);\n\tint ans = 0;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= max(n, m); i++) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % P;\n\t\tinv[i] = power(fac[i], P - 2);\n\t\tinvn[i] = power(i, P - 2);\n\t}\n\tfor (int i = 0; i <= m; i++) {\n\t\tupdate(ans, func(i));\n\t}\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MOD (1000000007)\nusing namespace std;\nconst int MAXN = 75;\ntypedef long long LL;\nint N, M, A[MAXN], minLen[MAXN], Belong[MAXN], Last[MAXN],KK,LLL;\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check(vector<int> Seq)\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1])--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<int> Seq, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<int> Seq, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check(Seq))Calc(Tot, Seq, V),++KK;\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, Seq, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= 70; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, Seq, newV, 1, Tot + minLen[Len]);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N / 2, M, N, V1, V2, 0, 0);\n\tcout << Ans + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nint dp[77][77];\n\nint calc(){\n    /*\n    if(X[0]==1){\n        if(X.size()>R)return 0;\n        int n=X.size();\n        int y=N-(2*n+1);\n        return nCk(2*n+y,y);\n    }*/\n    int n=X.size();\n    int nr=R-n,nb=B;\n    for(int i=0;i<X.size();i++){\n        int pos=r[R-i];\n        while(nb>0&&b[nb]<pos)nb--;\n        if(X[i]==1)continue;\n        if(nb==0)return 0;\n        while(nr>0&&r[nr]<b[nb])nr--;\n        nb--;\n        rep(t,X[i]-2){\n            if(i+1<n&&nb&&b[nb]<r[R-i-1]){\n                nb--;\n                continue;\n            }\n            if(nr){\n                nr--;\n                continue;\n            }\n            if(nb){\n                nb--;\n                continue;\n            }\n            return 0;\n        }\n    }\n\n\n    rep(i,n+1)rep(j,N+1)dp[i][j]=0;\n    dp[0][0]=1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<N;j++){\n            if(X[i]==1){\n                for(int k=1;j+k<=N;k++)add(dp[i+1][j+k],dp[i][j]);\n            }\n            else{\n                for(int k=0;2*X[i]-3+k+j<=N;k++){\n                    add(dp[i+1][j+2*X[i]-3+k],dp[i][j]*nCk(2*X[i]-2+k,k)%mod);\n                }\n            }\n        }\n    }\n\n    int ret=0;\n    for(int i=0;i<=N;i++){\n        add(ret,dp[n][i]*nCk(N-i+1,n)%mod);\n    }\n\n    ret=ret*fact[n]%mod;\n    map<int,int>cnt;\n    rep(i,n)cnt[X[i]]++;\n    for(auto p:cnt)ret=ret*inv[p.se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()==R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 200;\nconst ll MOD = 1e9 + 7;\n\nll sq(ll x) { return x * x % MOD; }\nll qpow(ll a, ll b) { return b ? sq(qpow(a, b / 2)) * (b & 1 ? a : 1) % MOD : 1; }\nll inv(ll x) { return qpow(x, MOD - 2); }\n\nint N, K, cnt[MAX_N];\nchar S[MAX_N];\nll fac[MAX_N], ifac[MAX_N];\nll ans;\n\nll comb(int n, int m) { return m <= n && m >= 0 ? fac[n] * ifac[n - m] % MOD * ifac[m] % MOD : 0; }\n\nbool check() {\n    int c1 = cnt[1], x = 0;\n    vector<int> seg;\n    queue<int> que;\n    for (int i = 2; i <= N; i++)\n        for (int j = 1; j <= cnt[i]; j++)\n            seg.push_back(i);\n    for (int i = 1; i <= K; i++) {\n        if (S[i] == 'r') {\n            if (!seg.empty()) {\n                que.push(seg.back());\n                seg.pop_back();\n            } else if (c1) {\n                c1--;\n            } else {\n                x = max(0, x - 1);\n            }\n        } else {\n            if (!que.empty()) {\n                x += que.front() - 2;\n                que.pop();\n            } else {\n                x = max(0, x - 1);\n            }\n        }\n    }\n    return x == 0 && c1 == 0 && seg.empty() && que.empty();\n}\n\nvoid solve() {\n    if (!check()) {\n        return;\n    }\n    int x = -1, y = 1, z = 0;\n    ll c = 1;\n    for (int i = 1; i <= N; i++) {\n        x += cnt[i] * max(2, i * 2 - 2);\n        if (i != 1) y += cnt[i];\n        z += cnt[i];\n        (c *= comb(z, cnt[i])) %= MOD;\n    }\n    if (x == -1) {\n        (ans += 1) %= MOD;\n        return;\n    }\n    ll res = 0;\n    for (int i = 0; i <= y * 2; i++) {\n        (res += comb(N - 1, x + i - 1) * comb(y * 2, i)) %= MOD;\n    }\n    (ans += res * c) %= MOD;\n}\n\nvoid dfs(int x, int y) {\n    if (y == N + 1) {\n        solve();\n        return;\n    }\n    int len = max(2, 2 * y - 2);\n    for (int j = 0; x + len * j <= N; j++) {\n        cnt[y] = j;\n        dfs(x + len * j, y + 1);\n    }\n}\n\nint main() {\n    fac[0] = 1;\n    for (int i = 1; i < MAX_N; i++) fac[i] = fac[i - 1] * i % MOD;\n    ifac[MAX_N - 1] = inv(fac[MAX_N - 1]);\n    for (int i = MAX_N - 1; i; i--) ifac[i - 1] = ifac[i] * i % MOD;\n    scanf(\"%d%d\", &N, &K);\n    scanf(\"%s\", S + 1);\n    dfs(-1, 1);\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(int i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int inf = 2147483647;\nconst int N = 1001, M = 3e2 + 1;\nconst int mod = 1e9 + 7;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI LL read() {\n\tLL x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nI int pow_mod(reg a, reg k) {reg ans = 1; for(; k; k >>= 1, a = (LL)a * a % mod) if(k & 1) ans = (LL)ans * a % mod; return ans;}\n\nchar ss[N];\nint C[N][N], pos[N], s[N], up[N], jc[N], inv[N], f[M][M][M];\nbool v[N];\n\nint main() {\n\treg n = read(), m = read();\n\tscanf(\"%s\", ss + 1);\n\tjc[0] = 1; fo(i, 1, N - 1) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[N - 1] = pow_mod(jc[N - 1], mod - 2); fd(i, N - 1, 1) inv[i - 1] = (LL)inv[i] * i % mod;\n\tC[0][0] = 1; fo(i, 1, N - 1) {\n\t\tC[i][0] = 1; fo(j, 1, i) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;\n\t} int ans = 0;\n\tfo(A, 0, m / 2) {\n\t\tmemset(v, 0, sizeof(v));\n\t\treg R = 0;\n\t\tfo(i, 1, m) if(ss[i] == 'r'){\n\t\t\tif(R == A) break;\n\t\t\tbool bk = 0; fo(j, i + 1, m) if(ss[j] == 'b' && !v[j]) {v[j] = 1, pos[++R] = j, bk = 1; break;}\n\t\t\tif(!bk) break;\n\t\t} if(R < A) break;\n\t\tfo(B, 0, m / 2) {\n\t\t\treg z = 0;\n\t\t\tfo(i, 1, m) if(ss[i] == 'r') z++, s[i] = s[i - 1] + (z > A + B); else s[i] = s[i - 1] + (!v[i]);\n\t\t\tif(z < A + B) break;\n\t\t\tup[A + 1] = 0, pos[A + 1] = m; fd(i, A, 1) up[i] = up[i + 1] + (s[pos[i + 1]] - s[pos[i]] + 1);\n\t\t\treverse(up + 1, up + A + 1);\n\t\t\tf[0][0][0] = 1; fo(i, 1, m) fo(j, 0, A) fo(S, 0, up[j]) f[i][j][S] = 0;\n\t\t\tfo(i, 1, m) fo(j, 0, A) fo(S, 0, _min(up[j], up[A] - i * (A - j))) if(f[i - 1][j][S]) {\n\t\t\t\tfor(reg k = 0; j + k <= A && S + k * i <= up[j + k]; k++)\n\t\t\t\t\tf[i][j + k][S + k * i] = (f[i][j + k][S + k * i] + (LL)f[i - 1][j][S] * inv[k]) % mod;\n\t\t\t} fo(S, 0, up[A]) if(f[m][A][S]){\n\t\t\t\tint c = (LL)f[m][A][S] * jc[A + B] % mod * inv[B] % mod;\n\t\t\t\tint H1 = 2 * S + 2 * B, H2 = A * 2;\n\t\t\t\tint ga = H1 - 1, gb = H1 + H2;\n\t\t\t\tans = (ans + (LL)c * C[n - ga + gb][gb]) % mod;\n\t\t\t}\n\t\t}\n\t} pr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<algorithm>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<iomanip>\n#include<utility>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define rg register\n#define il inline\n#define lch(x) ((x)<<1)\n#define rch(x) ((x)<<1^1)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define rep0(i,n) for(register int i=0;i<(n);++i)\n#define per0(i,n) for(register int i=(n)-1;i>=0;--i)\n#define rep(i,st,ed) for(register int i=(st);i<=(ed);++i)\n#define per(i,ed,st) for(register int i=(ed);i>=(st);--i)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef double dbl;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> il T qmin(const T &a,const T &b){return a<b?a:b;}\ntemplate<typename T> il T qmax(const T &a,const T &b){return a>b?a:b;}\ntemplate<typename T> il void getmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<typename T> il void getmax(T &a,const T &b){if(a<b) a=b;}\nil void fileio(string s){\n\tfreopen((s+\".in\").c_str(),\"r\",stdin);\n\tfreopen((s+\".out\").c_str(),\"w\",stdout);\n}\n\nconst int inf=(int)1e9+7;\nconst ll linf=(ll)1e17+7;\nconst int N=12,M=1000006;\n\nint d[N][N],a,b;\nint x[M],y[M],c[M],m;\n\nil void add(int xx,int yy,int cc){\n\t++m;\n\tx[m]=xx,y[m]=yy,c[m]=cc;\n}\n\nint main(){\n\tfileio(\"test\");\n\tscanf(\"%d%d\",&a,&b);\n\trep(i,1,a) rep(j,1,b) scanf(\"%d\",d[i]+j);\n\trep(i,1,a){\n\t\tint mn=inf;\n\t\trep(j,2,b){\n\t\t\tint diff=d[i][j]-d[i][j-1];\n\t\t\tif(diff<0||diff>mn) return puts(\"Impossible\"),0;\n\t\t\tmn=diff;\n\t\t}\n\t}\n\trep(j,1,b){\n\t\tint mn=inf;\n\t\trep(i,2,a){\n\t\t\tint diff=d[i][j]-d[i-1][j];\n\t\t\tif(diff<0||diff>mn) return puts(\"Impossible\"),0;\n\t\t\tmn=diff;\n\t\t}\n\t}\n\tint s=201,t=202;\n\tadd(s,1,inf+1);\n\trep(i,1,99) add(i,i+1,inf+1);\n\tadd(101,t,inf+2);\n\trep(i,102,200) add(i,i-1,inf+2);\n\trep(i,1,a){\n\t\trep(j,1,b){\n\t\t\tint kx=(i==a?0:d[i+1][j]-d[i][j]);\n\t\t\tint ky=(j==b?0:d[i][j+1]-d[i][j]);\n\t\t\tint idx=(!kx?s:kx),idy=(!ky?t:100+ky);\n\t\t\tint val=d[i][j]-kx*i-ky*j;\n\t\t\tadd(idx,idy,val);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tprintf(\"202\\n\");\n\trep(i,1,m){\n\t\tif(c[i]<=inf) printf(\"%d %d %d\\n\",x[i],y[i],c[i]);\n\t\telse printf(\"%d %d %c\\n\",x[i],y[i],c[i]==inf+1?'X':'Y');\n\t}\n\tprintf(\"201 202\\n\");\n\treturn 0;\t\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=750;\nint C[N][N],n,k,ans;\nint used[N],q1[N],q2[N];\nint suf[N],a[N];\nchar s[N];\nvoid init(){\n\tFor(i,0,N-1) C[i][0]=1;\n\tFor(i,1,N-1) For(j,1,i)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;\n}\nvoid solve(int S){\n\tif (!S) return ++ans,void(0);\n\tmemset(used,0,sizeof(used));\n\tint rest=S-a[1],h=0,t=*q2=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r') q1[++t]=i;\n\t\telse if (s[i]=='b'&&h!=t&&*q2!=rest)\n\t\t\tused[q1[++h]]=used[i]=1,q2[++*q2]=i;\n\t//printf(\"%d %d %d\\n\",rest,*q2,ans);\n\t//For(i,1,n) printf(\"%d \",a[i]); puts(\"\");\n\tif (*q2!=rest) return;\n\tFor(i,1,a[1])\n\t\tif (h==t) return;\n\t\telse used[q1[++h]]=1;\n\t//printf(\"%d %d %d\\n\",rest,*q2,ans);\n\t//For(i,1,max(n,k)) printf(\"%d \",a[i]); puts(\"\");\n\tRep(i,k,1) suf[i]=suf[i+1]+(!used[i]);\n\tFor(i,1,S-a[1]) q2[i]=suf[q2[i]];\n\tint posi=S-a[1],sum=0,par=0;\n\tFor(i,2,n) For(j,1,a[i]){\n\t\tsum+=i-2;\n\t\tif (sum>q2[posi]) return;\n\t\t--posi; \n\t}\n\tint v=1,s=a[1];\n\tsum=a[1]+S-1;\n\tpar=S+1+a[1];\n\tFor(i,2,max(2,n)){\n\t\tv=1ll*v*C[s+a[i]][s]%mo;\n\t\tsum+=a[i]*(2*i-3);\n\t\tpar+=a[i]*(2*i-1);\n\t\ts+=a[i]; \n\t}\n\tif (sum>n) return;\n\t//printf(\"%d %d %d\\n\",sum,par,v);\n\tv=1ll*v*C[n-sum+par-1][par-1]%mo;\n\tans=(ans+v)%mo;\n}\n/*\n\n*/\nvoid dfs(int x,int xx,int y,int S){\n\tif (y>x||2*max(y-1,1)>xx) return solve(S);\n\tfor (a[y]=0;x>=0&&xx>=0;++a[y],++S)\n\t\tdfs(x,xx,y+1,S),x-=y,xx-=2*max(y-1,1);\n\ta[y]=0;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tdfs(k,n+1,1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n40 4\nrrbb\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\nconst int MAXN = 300;\nconst int mod = 1e9 + 7;\n\nint n, k;\nstring str;\nlint fact[MAXN], invf[MAXN];\n\nlint ipow(int x, int p){\n\tlint ret = 1, piv = x;\n\twhile(p){\n\t\tif(p & 1) ret = ret * piv % mod;\n\t\tpiv = piv * piv % mod;\n\t\tp >>= 1;\n\t}\n\treturn ret;\n}\n\nlint bino(int x, int y){\n\tif(x < y) return 0;\n\treturn fact[x] * (invf[y] * invf[x-y] % mod) % mod;\n}\n\nint f(int x){ return 2 * max(x - 1, 1); }\n\nint solve(vector<int> v){\n\tint sum = 0;\n\tint ptr = 0;\n\treverse(v.begin(), v.end());\n\tqueue<int> que;\n\tfor(auto &i : str){\n\t\tif(i == 'r'){\n\t\t\tif(ptr < v.size()){\n\t\t\t\tif(v[ptr] > 1){\n\t\t\t\t\tque.push(v[ptr] - 2);\n\t\t\t\t}\n\t\t\t\tptr++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(sum) sum--;\n\t\t\t}\n\t\t}\n\t\tif(i == 'b'){\n\t\t\tif(!que.empty()){\n\t\t\t\tsum += que.front();\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t\telse if(sum) sum--;\n\t\t}\n\t}\n\tif(ptr != v.size() || sum || que.size()) return 0;\n\tif(v.empty()) return 1;\n\tlint ret = fact[v.size()];\n\tfor(int i=0; i<v.size(); ){\n\t\tint e = i;\n\t\twhile(e < v.size() && v[i] == v[e]) e++;\n\t\tret *= invf[e - i];\n\t\tret %= mod;\n\t\ti = e;\n\t}\n\t{\n\t\tint canZero = 2;\n\t\tint canAny = v.size() + 1;\n\t\tfor(int i=0; i<v.size(); i++){\n\t\t\tcanAny += 2 * v[i] - 1;\n\t\t\tcanZero += (v[i] > 1) * 2;\n\t\t}\n\t\tret *= bino(n + canZero - 1, canAny - 1);\n\t}\n\treturn ret % mod;\n}\n\nvector<vector<int> > canon;\n\nvoid dfs(int x, int l, vector<int> v){\n\tcanon.push_back(v);\n\tfor(int i=l; x + f(i) <= n; i++){\n\t\tv.push_back(i);\n\t\tdfs(x + f(i), i, v);\n\t\tv.pop_back();\n\t}\n}\n\nint main(){\n\tfact[0] = invf[0] = 1;\n\tfor(int i=1; i<MAXN; i++){\n\t\tfact[i] = fact[i-1] * i % mod;\n\t\tinvf[i] = ipow(fact[i], mod - 2);\n\t}\n\tcin >> n >> k >> str;\n\tvector<int> v;\n\tdfs(-1, 1, v);\n\tlint ret = 0;\n\tfor(auto &i : canon){\n\t\tret += solve(i);\n\t}\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\nusing namespace std;\nconst int N=255,mo=1e9+7;\nint n,k,ans,g,Ga,Gb;\nint c[N][N],st[N];\nchar s[N];\nvoid calc(){\n\tint ga=g,gb=g,tot=0;\n\tfo(i,1,k)\n\t\tif(s[i]=='r'&&ga)--ga;else\n\t\tif(s[i]=='b'&&gb>ga&&st[gb]>1)tot+=st[gb]-2,--gb;else\n\t\tif(tot)--tot;\n\tfor(;st[gb]==1;)--gb;\n\tif(ga||gb||tot)return;\n\ttot=1;\n\tfor(int i=1,j=0;i<=g;i=j+1){\n\t\tfor(;j<g&&st[j+1]==st[i];)++j;\n\t\ttot=(ll)tot*c[j][j-i+1]%mo;\n\t}\n\tga=Ga-1;gb=Gb+Ga;\n\tans=((ll)tot*c[n-ga+gb][gb]+ans)%mo;\n}\nvoid find(int _n,int _k,int len){\n\tcalc();\n\t++g;\n\tint la=Ga,lb=Gb;\n\tfor(int i=len;_n+(i==1?2:i*2-2)<=n+1&&_k+i<=k;++i)\n\t\tGa=la+(i==1?2:i*2-2),Gb=lb+(i>1)*2,st[g]=i,find(_n+(i==1?2:i*2-2),_k+i,i);\n\t--g;\n}\nint main(){\n\tscanf(\"%d%d\\n%s\",&n,&k,s+1);\n\tfo(i,0,250){\n\t\tc[i][0]=1;\n\t\tfo(j,1,i)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mo;\n\t}\n\tfind(0,0,1);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    inline modint &operator ^= (ll b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    inline friend modint operator ^ (modint a, ll b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int NP = 1e6 + 7;\nmodint p[NP], v[NP], vp[NP];\ninline void init(int n) {\n  p[0] = v[0] = 1;\n  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n  vp[n] = 1 / p[n];\n  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n}\ninline modint binom(int n, int m) {\n  return n < m ? 0 : p[n] * vp[m] * vp[n-m];\n}\n\nint n, k;\nstring s;\nmodint ans;\n\ninline bool pd(vi p) {\n\tvector<bool> v(k, 0);\n\tvi t(p.size(), -1);\n\tfor (ui i = 0; i < p.size(); i++) {\n\t\twhile (++t[i] < k && (v[t[i]] || s[t[i]] == 'b'));\n\t\tif (t[i] == k) return 0;\n\t\tv[t[i]] = 1;\n\t}\n\twhile (p.size() && p.back() == 1) p.pop_back();\n\tfor (ui i = 0; i < p.size(); i++) {\n\t\twhile (++t[i] < k && (v[t[i]] || s[t[i]] == 'r'));\n\t\tif (t[i] == k) return 0;\n\t\tv[t[i]] = 1;\n\t}\n\twhile (p.size() && p.back() == 2) p.pop_back();\n\tfor (ui i = 0; i < p.size(); i++)\n\t\tfor (int j = 2; j < p[i]; j++) {\n\t\t\twhile (++t[i] < k && v[t[i]]);\n\t\t\tif (t[i] == k) return 0;\n\t\t\tv[t[i]] = 1;\n\t\t}\n\treturn 1;\n}\n\nvoid dfs(int o, int l, int r, vi p) {\n\tif (!o) {\n\t\tif (!pd(p)) return;\n\t\tmodint now = binom(n - l + r - 1, r - 1);\n\t\twhile (p.size()) {\n\t\t\tint t = 0, x = p.back();\n\t\t\twhile (p.size() && p.back() == x) ++t, p.pop_back();\n\t\t\tnow *= binom(p.size() + t, t); \n\t\t}\n//\t\tdebug(\"l = %d, r = %d\\n\", l, r);\n//\t\tfor (int x : p) debug(\"%d \", x);\n//\t\tdebug(\"\\n%d\\n\", now.x);\n\t\treturn ans += now, void();\n\t}\n\twhile (1) {\n\t\tdfs(o - 1, l, r, p);\n\t\tl += (o == 1 ? 1 : 2 * o - 3) + (l != 0);\n\t\tif (l > n) return;\n\t\tr += 2 * o;\n\t\tp.pb(o);\n\t}\n}\n\nint main() {\n\trd(n, k), rds(s);\n\tinit(1e6);\n\tvi p;\n\tdfs((n + 3) >> 1, 0, 1, p);\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Tenshi ni Fureta yo!\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return *(cur == ed ? ed = buffer + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur = buffer : cur)++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\n// END tpl.\n\ninline char safe_getc()\n{\n\tregister char ch(getc());\n\twhile(!isgraph(ch)) ch = getc();\n\treturn ch;\n}\n\nconst int MOD = (int) 1e9 + 7;\n\ninline int fpm(int x, int y)\n{\n\tint res = 1;\n\tfor(; y; y >>= 1, x = (LL) x * x % MOD) if(y & 1) res = (LL) res * x % MOD;\n\treturn res;\n}\n\ninline int inv(int x) { assert(x); return fpm(x, MOD - 2); }\n\nnamespace MATH\n{\n\tconst int n = (int) 1e5;\n\n\tint fac[n + 5], ifac[n + 5];\n\n\tinline void init()\n\t{\n\t\tfac[0] = 1;\n\t\tfor(int i = 1; i <= n; ++i) fac[i] = (LL) fac[i - 1] * i % MOD;\n\t\tifac[n] = inv(fac[n]);\n\t\tfor(int i = n - 1; i >= 0; --i) ifac[i] = (LL) ifac[i + 1] * (i + 1) % MOD;\n\t}\n\n\tinline int C(int N, int M) { return N < 0 || M < 0 || N < M ? 0 : (LL) fac[N] * ifac[N - M] % MOD * ifac[M] % MOD; }\n}\nusing MATH::fac;\nusing MATH::ifac;\nusing MATH::C;\n\nconst int MAXN = 70;\n\nint n, K;\n\nchar s[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), K = read<int>();\n\tfor(int i = 1; i <= K; ++i) s[i] = safe_getc();\n}\n\nint a[MAXN + 5];\n\ninline int check(int N)\n{\n\tstatic int pos[MAXN + 5], vis[MAXN + 5];\n\tmemset(vis, 0, sizeof vis);\n\n\tint lstr = 0;\n\tfor(int i = 1; i <= N; ++i)\n\t{\n\t\tpos[i] = n + 1;\n\t\tfor(int j = lstr + 1; j <= n; ++j) if(s[j] == 'r') { vis[lstr = pos[i] = j] = 1; break; }\n\t\tif(pos[i] == n + 1) return 0;\n\n\t\tif(a[i] > 1)\n\t\t{\n\t\t\tfor(; pos[i] <= n; ++pos[i]) if(!vis[pos[i]] && s[pos[i]] == 'b') { vis[pos[i]] = 1; break; }\n\t\t\tif(pos[i] == n + 1) return 0;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= N; ++i) if(a[i] > 2)\n\t{\n\t\tint cnt = 2;\n\t\tfor(int j = pos[i]; cnt < a[i] && j <= n; ++j) if(!vis[j] && s[j] == 'b') vis[j] = 1, ++cnt;\n\t\tif(cnt < a[i]) return 0;\n\t}\n\n\treturn 1;\n}\n\ninline int div_into(int N, int M) { return C(N + M - 1, M - 1); }\n\ninline int calc(int N, int S)\n{\n\tint res = fac[N], M = N + 1;\n\tfor(int i = 1, j; i <= N; i = j)\n\t{\n\t\tfor(j = i; j <= N && a[j] == a[i]; ++j);\n\t\tres = (LL) res * ifac[j - i] % MOD;\n\t\tM += (a[i] * 2 - 1) * (j - i);\n\t}\n\treturn (LL) res * div_into(n - S, M) % MOD;\n}\n\nint ans = 0;\n\ninline void dfs(int k, int lst, int S)\n{\n\tif(S > n) return;\n\tif(check(k)) (ans += calc(k, S)) %= MOD;\n\n\tfor(int i = lst; i >= 1; --i) a[k + 1] = i, dfs(k + 1, i, S + (i == 1 ? 1 : i * 2 - 3) + (k > 0));\n}\n\ninline void solve()\n{\n\tans = 0, dfs(0, n, 0);\n\tprintf(\"%d\\n\", (ans + MOD) % MOD);\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tMATH::init();\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=280+5;\nconst int MOD=1e9+7;\nint mo(int x,int y)\n{\n\treturn x+y>=MOD?x+y-MOD:x+y;\n}\nint mu(int x,int y)\n{\n\treturn 1ll*x*y%MOD;\n}\nint sub(int x,int y)\n{\n\treturn x<y?x-y+MOD:x-y;\n}\nint ksm(int x,int y)\n{\n\tint res=1;\n\tfor(;y;y>>=1,x=mu(x,x))\n\tif(y&1) res=mu(res,x);\n\treturn res;\n}\nint N,K;\nchar S[MAXN];\nint st[MAXN],ans,jc[MAXN],jcn[MAXN],pos[MAXN],posb[MAXN],sz[MAXN];\nint C(int n,int m)\n{\n\treturn n<m?0:mu(jc[n],mu(jcn[n-m],jcn[m]));\n}\nbool used[MAXN];\nbool checkans(int n,int M)\n{\n\tfor(int i=1;i<=K;i++)\n\t\tused[i]=0;\n\tint R=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(R<=K&&(used[R]||S[R]=='b')) R++;\n\t\tif(R>K) return 0;\n\t\tused[R]=1;\n\t\tpos[i]=R;\n\t}\n\tR=1;\n\tfor(int i=1;i<=n;i++)\n\tif(st[i]<2) break;\n\telse \n\t{\n\t\twhile(R<=K&&(used[R]||S[R]=='r'||R<=pos[i])) R++;\n\t\tif(R>K) return 0;\n\t\tused[R]=1;\n\t\tposb[i]=R;\n\t}\n\tR=1;\n\tfor(int i=1;i<=n;i++)\n\tif(st[i]<=2) break;\n\telse \n\t{\n\t\tint c=3;\n\t\twhile(c<=st[i])\n\t\t{\n\t\t\twhile(R<=K&&(used[R]||R<=pos[i])) R++;\n\t\t\tif(R>K) return 0;\n\t\t\tused[R]=1;\n\t\t\tc++;\n\t\t}\n\t}\n\tint v=0,d=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t//\tfprintf(stderr,\"%d%c\",st[i],\" \\n\"[i=x=n]);\n\t\t sz[st[i]]++;\n\t\t M=max(M,st[i]);\n\t\t v+=(st[i]>=2)?2:0;\n\t\td+=st[i]*2;\n\t\t\n\t}\n\tint res=1,t=0;\n\tfor(int i=1;i<=M;i++)\n\t\tres=mu(res,jcn[sz[i]]),t+=sz[i],sz[i]=0;\n\tres=mu(res,jc[t]);\n\tif(N+1+v<d) return 0;\n\tans=mo(ans,mu(res,C(N+1+v,d)));\n\tif(!C(N+1+v,d)) fprintf(stderr,\"err\");\n//\tfprintf(stderr,\"cntans:%d %d %d %d\\n\",ans,t,v,d);\n\t\n\treturn 1;\n\t\n}\nint cs=0;\nvoid Div(int dep,int last,int v)\n{\n\tif(!checkans(dep-1,v)) return;\n//\tcs++;\n\tif(v>last) v=last;\n\tfor(int i=1;i<=v;i++)\n\t{\n\t\tst[dep]=i;\n\t\tDiv(dep+1,last-i,i);\n\t}\n}\n\t\nint main()\n{\n\tscanf(\"%d%d\",&N,&K);\n\tscanf(\"%s\",S+1);\n\tfor(int i=jc[0]=1;i<=N*4;i++)\n\t\tjc[i]=mu(jc[i-1],i);\n\tjcn[N*4]=ksm(jc[N*4],MOD-2);\n\tfor(int i=N*4;i;i--)\n\t\tjcn[i-1]=mu(jcn[i],i);\n\tDiv(1,max(K,N),max(K,N));\n\tprintf(\"%d\\n\",ans);\n//\tprintf(\"%d\\n\",cs);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0;int f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 255*3;\nconst int mod = 1e9+7;\nint n,m;\nchar s[maxn];\nint ans,fac[maxn],ifac[maxn];\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(){\n\tn = read(),m = read();\n\tscanf(\"%s\",s+1);\n\tfac[0] = 1;rep(i,1,maxn) fac[i] = 1ll * fac[i-1] * i % mod;\n\tifac[maxn-1] = qpow(fac[maxn-1],mod-2);\n\tDep(i,maxn-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % mod;\n\tassert(ifac[0]==1);\n}\ninline int C(int n,int m){\n\tif(n<m||n<0) return 0;\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\n#define cal(x,y) C((x)+(y)-1,(y)-1)\ninline void add(int &x,int v){\n\tx+=v;\n\tif(x>=mod) x-=mod;\n}\nint q1[maxn],q2[maxn],suf[maxn],f[maxn][maxn];\nbool used[maxn];\nvoid solve(int S1,int S2){\n\tif(!S1&&!S2) return ++ans,void(0);\n\tif((S1+S2)*2>n || S1+2*S2>m) return ;\n\t*q1=*q2=0;\n\tmemset(used,0,sizeof(used));\n\tint x=0,y=0;\n\tRep(i,1,m)\n\t\tif(s[i]=='r' && x<S1+S2) q1[++x]=i; else \n\t\tif(s[i]=='b' && y<S2 && y<x) q2[++y]=i;\n\tif(y!=S2 || x!=S1+S2) return ;\n\tRep(i,1,x) used[q1[i]]=true;\n\tRep(i,1,y) used[q2[i]]=true;\n\tDep(i,m,1) suf[i]=suf[i+1]+(!used[i]);\n\tRep(i,1,S2) q2[i] = suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tRep(i,2,n)Dep(j,S2-1,0)Rep(k,2*j,n-i*(S2-j)){\n\t\tRep(l,1,min(S2-j,(n-k)/i)){\n\t\t\tif(k+i*l-2*(j+l) > q2[S2-(j+l)+1]) break;\n\t\t\tadd(f[j+l][k+i*l],1ll*ifac[l]*f[j][k]%mod);\n\t\t}\n\t}\n\tint res = 0;\n\tRep(i,0,n){\n\t\tint sum=2*S1+2*i-2*S2-1;\n\t\tint par=2*S1+2*i+1;\n\t\tif (sum&&sum<=n&&f[S2][i])\n\t\t\tadd(res,1ll*f[S2][i]*cal(n-sum,par)%mod);\n\t}res = 1ll * res * fac[S1+S2] % mod * ifac[S1] % mod;\n\tadd(ans,res);\n}\nint main(){\n\tinit(); \n\tif(n==1){\n\t\tint l=0,r=0;\n\t\tDep(i,m,1) if(s[i]=='r') l=i;\n\t\tRep(i,1,m) if(s[i]=='b') r=i;\n\t\tif(l<r) puts(\"3\"); else if(l) puts(\"2\"); else puts(\"1\");\n\t\treturn 0;\n\t}\n\tans = 0;\n\tRep(S1,0,n)Rep(S2,0,n)solve(S1,S2);\n\twriteln(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint n,k;\nchar s[81];\nbool vis[81];\nint a[81];\nbool check(int m)\n{\n\tfor(int i=1;i<=k;i++)vis[i]=0;\n\tint cnt=0;\n\tfor(int i=1;i<=m&&a[i]==1;i++)cnt++;\n\tint nowr=1,nowb=1;\n\tfor(int i=1;i<=m-cnt&&nowr<=k&&nowb<=k;i++)\n\t{\n\t\twhile(nowr<=k&&(vis[nowr]||s[nowr]!='r'))nowr++;\n\t\twhile(nowb<=k&&(vis[nowr]||s[nowb]!='b'||nowb<=nowr))nowb++;\n\t\tif(nowb<=k){\n\t\t\tvis[nowr]=true;\n\t\t\tvis[nowb]=true;\n\t\t}\n\t}\n\tif(nowb>k)return false;\n\tint tmp=cnt;\n\tfor(int i=1;i<=k&&tmp;i++)\n\t\tif(!vis[i]&&s[i]=='r'){\n\t\t\tvis[i]=true;\n\t\t\ttmp--;\n\t\t}\n\tif(tmp)return false;\n\tint now=cnt+1,num=0;\n\tfor(int i=k;i>=1&&now<=m;i--)\n\t{\n\t\tif(!vis[i])cnt++;\n\t\telse if(s[i]=='b'){\n\t\t\tcnt-=a[now]-2;\n\t\t\tif(cnt<0)return false;\n\t\t\tnow++;\n\t\t}\n\t}\n\treturn true;\n}\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%Mod;\n\t\tt=1ll*t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint ans;\nint fac[510],inv[510];\nvoid init()\n{\n\tint N=500;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\tif(x<0||y<0||x-y<0)return 0;\n\treturn 1ll*fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nvoid solve(int m,int len)\n{\n\tint s=0;//block-1\n\tfor(int i=1;i<=m;i++)\n\t\ts+=a[i]*2;\n\tint res=1ll*C(n-len+s,s)*fac[m]%Mod;\n\tfor(int i=1,j;i<=m;i=j)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&a[j]==a[i])j++;\n\t\tres=1ll*res*inv[j-i]%Mod;\n\t}\n\tans=(ans+res)%Mod;\n\treturn ;\n}\nbool dfs(int m,int lst,int sum,int len)\n{\n\tif(len>n)return false;\n\tif(!check(m-1))return false;\n\tsolve(m-1,len);\n\tfor(a[m]=lst;a[m]<=k-sum;a[m]++)\n\t{\n\t\tint tlen=len;\n\t\tif(m>1)tlen++;\n\t\tif(a[m]==1)tlen++;\n\t\telse tlen+=(a[m]-1)*2-1;\n\t\tif(!dfs(m+1,a[m],sum+a[m],tlen))\n\t\t\tbreak;\n\t}\n\treturn true;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tdfs(1,1,0,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar(‘\\n‘)\n#define space putchar(‘ ‘)\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < ‘0‘ || c > ‘9‘) {\n    if(c == ‘-‘) f = -1;\n    c = getchar();\n    }\n    while(c >= ‘0‘ && c <= ‘9‘) {\n    res = res * 10 + c - ‘0‘;\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar(‘-‘);}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar(‘0‘ + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K,C[1005][1005],L[75],fac[1005],invfac[1005],cnt;\nint sum[75],pos[75],tot,ans,matc[75];\nchar s[75];\nbool vis[75];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nbool check() {\n    if(tot < cnt) return false;\n    memset(sum,0,sizeof(sum));\n    int p = 1;\n    for(int i = cnt ; i >= 1 ; --i) {\n    sum[pos[i]]++;\n    if(L[p] >= 2) {\n        if(!matc[pos[i]]) return false;\n        sum[matc[pos[i]]] += L[p] - 1;\n    }\n    ++p;\n    }\n    for(int i = K ; i >= 1 ; --i) {\n    sum[i] += sum[i + 1];\n    if(sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\nbool dfs(int pre,int dep,int len) {\n    cnt = dep;\n    if(!check()) return false;\n    int k = 1 + cnt;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] == 1) ++k;\n        else k += 2 * L[i] - 1;\n    }\n    int res = C[N - len + k - 1][k - 1];\n    res = mul(res,fac[cnt]);\n    int t = 0;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] != L[i - 1]) {\n            res = mul(res,invfac[t]);\n            t = 0;\n        }\n        ++t;\n    }\n    res = mul(res,invfac[t]);\n    update(ans,res);\n    if(dep + 1 > tot) return true;\n    for(int i = pre ; i <= 70 ; ++i) {\n        int tl = len;\n        if(dep != 0) ++tl;\n        if(i == 1 || i == 2) tl += 1;\n        else tl += i - 2 + i - 1;\n        if(tl > N) break;\n        L[dep + 1] = i;\n        if(!dfs(i,dep + 1,tl)) break;\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);read(K);\n    scanf(\"%s\",s + 1);\n    C[0][0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) {\n        C[i][0] = 1;\n        for(int j = 1 ; j <= i ; ++j) {\n            C[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n        }\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000] = fpow(fac[1000],MOD - 2);\n    for(int i = 999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    tot = 0;\n    for(int i = 1 ; i <= K ; ++i) {\n        if(s[i] == ‘r‘) {\n        pos[++tot] = i;\n    \n        for(int j = i + 1 ; j <= K ; ++j) {\n        if(s[j] == ‘b‘ && !vis[j]) {matc[i] = j;vis[j] = 1;break;}\n        }\n    }\n    }\n    dfs(1,0,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\n#define unittest_name_helper(counter) unittest_ ## counter\n#define unittest_name(counter) unittest_name_helper(counter)\n#define unittest __attribute__((constructor)) void unittest_name(__COUNTER__) ()\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class U> inline void chmax(T & a, U const & b) { a = max<T>(a, b); }\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, int(xs.size()) - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\n\ntemplate <int32_t MOD>\nstruct mint {\n    int64_t value;  // faster than int32_t a little\n    mint() = default;  // value is not initialized\n    mint(int64_t value_) : value(value_) {}  // assume value is in proper range\n    inline mint<MOD> operator + (mint<MOD> other) const { int64_t c = this->value + other.value; return mint<MOD>(c >= MOD ? c - MOD : c); }\n    inline mint<MOD> operator - (mint<MOD> other) const { int64_t c = this->value - other.value; return mint<MOD>(c <    0 ? c + MOD : c); }\n    inline mint<MOD> operator * (mint<MOD> other) const { int64_t c = this->value * int64_t(other.value) % MOD; return mint<MOD>(c < 0 ? c + MOD : c); }\n    inline mint<MOD> & operator += (mint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }\n    inline mint<MOD> & operator -= (mint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }\n    inline mint<MOD> & operator *= (mint<MOD> other) { this->value = this->value * int64_t(other.value) % MOD; if (this->value < 0) this->value += MOD; return *this; }\n    inline mint<MOD> operator - () const { return mint<MOD>(this->value ? MOD - this->value : 0); }\n    mint<MOD> pow(uint64_t k) const {\n        mint<MOD> x = *this, y = 1;\n        for (; k; k >>= 1) {\n            if (k & 1) y *= x;\n            x *= x;\n        }\n        return y;\n    }\n    mint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime\n    inline mint<MOD> operator /  (mint<MOD> other) const { return *this *  other.inv(); }\n    inline mint<MOD> operator /= (mint<MOD> other)       { return *this *= other.inv(); }\n    inline bool operator == (mint<MOD> other) const { return value == other.value; }\n    inline bool operator != (mint<MOD> other) const { return value != other.value; }\n};\ntemplate <int32_t MOD> ostream & operator << (ostream & out, mint<MOD> n) { return out << n.value; }\n\ntemplate <int32_t MOD>\nmint<MOD> fact(int n) {\n    static vector<mint<MOD> > memo(1, 1);\n    while (n >= memo.size()) {\n        memo.push_back(memo.back() * mint<MOD>(memo.size()));\n    }\n    return memo[n];\n}\ntemplate <int32_t PRIME>\nmint<PRIME> inv_fact(int n) {\n    static vector<mint<PRIME> > memo;\n    if (memo.size() <= n) {\n        int l = memo.size();\n        int r = n * 1.3 + 100;\n        memo.resize(r);\n        memo[r - 1] = fact<PRIME>(r - 1).inv();\n        for (int i = r - 2; i >= l; -- i) {\n            memo[i] = memo[i + 1] * (i + 1);\n        }\n    }\n    return memo[n];\n}\n\ntemplate <int32_t MOD>\nmint<MOD> choose(int n, int r) {\n    assert (0 <= r and r <= n);\n    return fact<MOD>(n) * inv_fact<MOD>(n - r) * inv_fact<MOD>(r);\n}\n\n\n/**\n * group = 1:\n *    R\n *\n * group = 2:\n *    _B_\n *    _BR\n *    RB_\n *    RBR\n *\n * group = 4:\n *    _BRBRB_\n *    _BRBRBR\n *    RBRBRB_\n *    RBRBRBR\n */\n\nconstexpr int MOD = 1e9 + 7;\n\nbool is_constructible_sequence(int k, string const & s, vector<int> const & f) {\n    int r = 0, b = 0;  // indices, 0 <= b <= r <= f.size()\n    int q = 0;\n    for (char c : s) {\n        if (c == 'r' and r < f.size()) {\n            ++ r;\n        } else if (c == 'b' and b < r) {\n            assert (f[b] >= 2);\n            q += f[b] - 2;\n            ++ b;\n        } else if (q) {\n            -- q;\n        }\n        while (b < r and f[b] == 1) {\n            ++ b;\n        }\n    }\n    return r == f.size() and b == f.size() and not q;\n}\n\nmint<MOD> count_generated_patterns(int n, vector<int> const & f) {\n    auto dp = vectors(f.size() + 1, n + 1, mint<MOD>());\n    dp[0][0] = 1;\n    REP (i, f.size()) {\n        REP (j, n) {\n            dp[i][j + 1] += dp[i][j];  // use white\n            int core = max(1, f[i] * 2 - 3);\n            REP3 (dj, core, n - j + (i == 0)) {\n                mint<MOD> cnt = 0;\n                if (f[i] == 1) {\n                    cnt += 1;  // R\n                } else {\n                    for (int size : { core, core + 1, core + 1, core + 2 }) {\n                        if (dj >= size) {\n                            cnt += choose<MOD>(dj - 1, size - 1);\n                        }\n                    }\n                }\n// cerr << \"f = ( \" << f << \" ): \" << \"i = \" << i << \", j = \" << j << \": \" <<\"dj = \" << dj << \" -> cnt = \" <<cnt<<endl;\n                dp[i + 1][j + (i != 0) + dj] += cnt * dp[i][j];\n            }\n        }\n    }\n    REP (j, n) {\n        dp[f.size()][j + 1] += dp[f.size()][j];  // use white\n    }\n// REP (i, f.size() + 1) {\n// REP (j, n + 1) {\n// cerr << \"f = ( \" << f << \" ): \" <<\"dp[\" << i << \"][\"<<j<<\"] = \" << dp[i][j]  << endl;\n// }\n// }\n\n    mint<MOD> shuffle = 1;\n    for (int l = 0; l < f.size(); ) {\n        int r = l;\n        while (r < f.size() and f[l] == f[r]) ++ r;\n        shuffle *= choose<MOD>(r, r - l);\n        l = r;\n    }\n\n    return shuffle * dp[f.size()][n];\n}\n\nmint<MOD> solve(int n, int k, string const & s) {\n    mint<MOD> acc = 0;\n    vector<int> f;\n    function<void (int, int)> go = [&](int used, int group) {\n        if (group == 0) {\n            if (is_constructible_sequence(k, s, f)) {\n                acc += count_generated_patterns(n, f);\n            }\n        } else {\n            go(used, group - 1);\n            int next_used = used + (not not used) + max(1, 2 * group - 3);\n            if (next_used <= n) {\n                f.push_back(group);\n                go(next_used, group);\n                f.pop_back();\n            }\n        }\n    };\n    go(0, max(2, n));\n    return acc;\n}\n\nint main() {\n    int n, k; cin >> n >> k;\n    string s; cin >> s;\n    cout << solve(n, k, s).value << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define FOR(i, l, r) for(int i = l; i <= r; ++i)\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 210;\nconst int mod = 1e9 + 7;\n\nint n, k, ans, tot, left, a[N], c[N][N];\nchar s[N];\n\nbool check()\n{\n    if (!tot) return 0;\n    int now1 = 1, now2 = 1, c = 0;\n    FOR(i, 1, k)\n    {\n        if (!(now1 <= tot || a[now2] > 1 || c)) break;\n        if (now1 <= tot && s[i] == 'r') ++now1; else\n        if (now2 < now1 && a[now2] > 1 && s[i] == 'b') c += a[now2++] - 2;\n        else if (c) --c;\n    }\n    return !(now1 <= tot || a[now2] > 1 || c);\n}\n\nvoid update()\n{\n    ll tmp = 1, num = tot + 1;\n    for(int i = 1, j; i <= tot; i = j + 1)\n    {\n        for(j = i; j < tot && a[j + 1] == a[i]; ++j);\n        tmp = tmp * c[j][i - 1] % mod;\n        num += (j - i + 1) * (a[i] * 2 - 1);\n    }\n    tmp = tmp * c[num + left - 1][num - 1] % mod;\n    if ((ans += tmp) >= mod) ans -= mod;\n}\n\nvoid dfs(int mx)\n{\n    if (left < 0) return;\n    if (check()) update();\n\n    if (tot) --left;\n    ++tot; --left; dfs(a[tot] = 1); ++left;\n    FOR(i, 2, mx)\n    {\n        left -= i * 2 - 3;\n        dfs(a[tot] = i);\n        left += i * 2 - 3;\n    }\n    a[tot--] = 0;\n    if (tot) ++left;\n}\n\nint main()\n{\n    FOR(i, 0, 200)\n    {\n        c[i][0] = 1;\n        FOR(j, 1, 200)\n            if ((c[i][j] = c[i - 1][j] + c[i - 1][j - 1]) >= mod)\n                c[i][j] -= mod;\n    }\n\n    scanf(\"%d%d%s\", &n, &k, s + 1);\n    left = n; dfs(n);\n    printf(\"%d\\n\", ans + 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define int long long\n\n#define left __left__\n\nconst int N=70+10;\n\nconst int A=520;\n\nconst int MOD=1000000007;\n\nint n,k;\n\nchar s[N];\n\nint C[A][A];\n\nvoid prework()\n{\n\tint i,j;\n\tfor(i=0;i<A;++i)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(j=1;j<=i;++j)\n\t\t\tif((C[i][j]=C[i-1][j-1]+C[i-1][j])>=MOD)\n\t\t\t\tC[i][j]-=MOD;\n\t}\n}\n\nint ans;\n\nint B[N],ed,left;\n\nbool valid()\n{\n\tif(!ed)\n\t\treturn false;\n\tint i,j=1,jj=1,c=0;\n\tfor(i=1;i<=k&&(j<=ed||B[jj]>1||c);++i)\n\t{\n\t\tif(j<=ed&&s[i]=='r')\n\t\t\t++j;\n\t\telse if(jj<j&&B[jj]>1&&s[i]=='b')\n\t\t\tc+=B[jj++]-2;\n\t\telse if(c)\n\t\t\t--c;\n\t}\n\treturn !(j<=ed||B[jj]>1||c);\n}\n\nvoid update()\n{\n\tint i,j,res(1),em(0);\n\tfor(i=1;i<=ed;i=j+1)\n\t{\n\t\tfor(j=i;B[j+1]==B[i];++j);\n\t\tres=res*C[j][i-1]%MOD;\n\t\tem+=(j-i+1)*((B[i]<<1)-1);\n\t}\n\tem+=ed+1;\n\tres=res*C[em-1+left][em-1]%MOD;\n\tif((ans+=res)>=MOD)\n\t\tans-=MOD;\n}\n\nvoid dfs(int lim)\n{\n\tif(left<0)\n\t\treturn;\n\tif(valid())\n\t\tupdate();\n\tif(ed)\n\t\t--left;\n\t++ed;--left;\n\tdfs(B[ed]=1);\n\t++left;\n\tfor(int i=2;i<=lim;++i)\n\t{\n\t\tleft-=(i<<1)-3;\n\t\tdfs(B[ed]=i);\n\t\tleft+=(i<<1)-3;\n\t}\n\tB[ed--]=0;\n\tif(ed)\n\t\t++left;\n}\n\nsigned main()\n{\n\tscanf(\"%lld%lld%s\",&n,&k,s+1);\n\tprework();\n\tleft=n;dfs(233);\n\tprintf(\"%lld\",(ans+1)%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 100001919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\n\nint N, K;\nstring S;\nint nCr[201][201];\nvector<int> black, white;\nint dp[2][100][100][100];\nint wh_ptr[100], gain[100];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  nCr[0][0] = 1;\n  for (int i=1; i<=200; i++) {\n    nCr[i][0] = 1;\n    for (int j=1; j<=200; j++) nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j])%MOD;\n  }\n\n  cin >> N >> K >> S;\n  rep(i, K) {\n    if (S[i] == 'r') black.pb(i);\n    else white.pb(i);\n  }\n  if (black.empty()) {\n    cout << 1 << \"\\n\";\n    return 0;\n  }\n  rep(i, max(N, K)+1) gain[i] = -INF, wh_ptr[i] = white.size();\n  int head = 0;\n  rep(i, black.size()) {\n    int g = 0;\n    while (head < white.size() && white[head] < black[i]) head++, g++;\n    if (head == white.size()) break;\n    head++;\n    wh_ptr[i] = head;\n    gain[i] = g;\n  }\n\n  dp[0][0][0][0] = 1;\n  for (int len=N; len>=1; len--) if (len%2) rep(left, 2) rep(right, 2) {\n    int star = (len-1)/2;\n    rep(i, N+1) rep(j, N+1) rep(k, N+1) dp[1][i][j][k] = dp[0][i][j][k];\n    rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n      if (dp[0][groups][sum][now] == 0) continue;\n      int cur = now;\n      for (int num=1; groups+num<=min(N, (int)black.size()) && sum+num*(len+left+right)<=N; num++) {\n        if (gain[groups+num-1] == -INF) continue;\n        cur = max(cur-gain[groups+num-1], 0) + star;\n        if (cur > N) break;\n        add(dp[1][groups+num][sum+num*(len+left+right)][cur], (1LL*dp[0][groups][sum][now]*nCr[groups+num][num])%MOD);\n      }\n    }\n    swap(dp[0], dp[1]);\n  }\n\n  rep(i, N+1) rep(j, N+1) rep(k, N+1) dp[1][i][j][k] = 0;\n  rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n    int gain = 0;\n    if (groups > 0) gain = white.size() - wh_ptr[groups-1];\n    int cur = max(now-gain, 0);\n    add(dp[1][groups][sum][cur], dp[0][groups][sum][now]);\n  }\n  swap(dp[0], dp[1]);\n\n  rep(i, N+1) rep(j, N+1) rep(k, N+1) dp[1][i][j][k] = dp[0][i][j][k];\n  rep(groups, N+1) rep(sum, N+1) rep(now, N+1) {\n    if (dp[0][groups][sum][now] == 0) continue;\n    int cur = now;\n    int val = (1LL*dp[0][groups][sum][now])%MOD;\n    for (int num=1; groups+num<=min(N, (int)black.size()) && sum+num<=N; num++) {\n      add(dp[1][groups+num][sum+num][cur], (1LL*val*nCr[groups+num][num])%MOD);\n    }\n  }\n  swap(dp[0], dp[1]);\n\n  int s = 1;\n  for (int groups=1; groups<=N; groups++) rep(sum, N+1) rep(cur, N+1) {\n    if (dp[0][groups][sum][cur] == 0) continue;\n    assert(sum>=1);\n\n    if (groups > black.size()) continue;\n    int gain = black.size() - groups;\n    if (gain < cur) continue;\n\n    int yo = N-sum;\n    if (yo < groups-1) continue;\n    yo -= groups-1;\n    //cout<<\"dp[groups=\"<<groups<<\"][sum=\"<<sum<<\"][cur=\"<<cur<<\"] = \"<<dp[0][groups][sum][cur]<<\", yo=\"<<yo<<\"\\n\";\n    for (int w=0; w<=yo; w++) {\n      int val = (1LL*nCr[w+groups][w]*dp[0][groups][sum][cur])%MOD;\n      val = (1LL*val*nCr[sum-1+(yo-w)][sum-1])%MOD;\n      add(s, val);\n      //cout<<\"w=\"<<w<<\": add \"<<yo-w<<\" to tonari, val=\"<<val<<\"\\n\";\n    }\n  }\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nconst int MAXN = 73;\ntypedef long long LL;\nconst LL MOD = 1000000007;\nint N, M, minLen[MAXN], Belong[MAXN], Last[MAXN];\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\nvector<int> Seq;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check()\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1] && Size)--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check())Calc(Tot, V);\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= N; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, newV, 1, Tot + minLen[Len]);\n\tSeq.pop_back();\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N / 2 + 1, M, N, V2, 0, 0);\n\tcout << (Ans + 1) % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\nint N,K;\nint C[1005][1005], fac[1005], inv[1005];\nint L[75];\nint tot;\nqueue<int> Q;\nint nextt[75], que[75];\nint vis[75];\n\nint qpow(int a, int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b&1) res=res*a%mod;\n\t\tb>>=1;\n\t\ta=a*a%mod;\n\t}\n\treturn res;\n}\nvoid init() {\n\tC[0][0] = 1;\n\tfor(int i = 1 ; i <= 1000 ; i++) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1 ; j <= i ; j++) {\n\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t\t\tC[i][j] %= mod;\n\t\t}\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1 ; i <= 1000 ; i++) fac[i] = fac[i - 1]*i%mod;\n\tinv[1000] = qpow(fac[1000],mod-2);\n\tfor(int i = 999 ; i >= 0 ; i--) inv[i] = inv[i + 1]*(i + 1)%mod;\n}\n\nbool check(int cnt) {\n\tif(tot < cnt) return false;\n\tint sum[75];\n\tmemset(sum,0,sizeof(sum));\n\tint p = 1;\n\tfor(int i = cnt ; i >= 1 ; i--) {\n\t\tsum[que[i]]++;\n\t\tif(L[p] >= 2) {\n\t\t\tif(nextt[que[i]]==0) return false;\n\t\t\tsum[nextt[que[i]]] += L[p] - 1;\n\t\t}\n\t\tp++;\n\t}\n\tfor(int i = K ; i >= 1 ; i--) {\n\t\tsum[i] += sum[i + 1];\n\t}\n\tfor(int i = K; i >= 1; i--) {\n\t\tif(sum[i] > K - i + 1) return false;\n\t}\n\treturn true;\n}\n\nint ans=0;\nbool dfs(int pre,int dep,int len) {\n\tif(len > N) return false;\n\tif(!check(dep)) return false;\n\t\n\tint k = dep + 1;\n\tfor(int i = 1 ; i <= dep ; i++) {\n\t\tif(L[i] == 1) k++;\n\t\telse k += 2 * L[i] - 1;\n\t}\n\tint cnt = C[N + k - len  - 1][k - 1] * fac[dep]%mod;\n\t\n\tint count = 1;\n\t\n\tfor(int i = 2 ; i <= dep ; i++) {\n\t\tif(L[i] != L[i - 1]) {\n\t\t\tcnt = cnt * inv[count] % mod;\n\t\t\tcount = 0;\n\t\t}\n\t\tcount++;\n\t}\n\t\n\tcnt = cnt * inv[count]%mod;\n\tans += cnt;\n\tans %= mod;\n\tans = (ans + mod)%mod;\n\t\n\t\n\tif(dep >= tot) return true;\n\tfor(int i = pre ; i <= 70 ; i++) {\n\t\tint tmp = len;\n\t\tif(dep != 0) tmp++;\n\t\tif(i == 1 || i == 2) tmp++;\n\t\telse tmp += 2 * i - 3;\n\t\tL[dep + 1] = i;\n\t\tif(!dfs(i,dep + 1,tmp)) break;\n\t}\n\treturn true;\n}\n\nchar s[75];\nsigned main() {\n\tinit();\n\tcin >> N >> K;\n\tscanf(\"%s\",s + 1);\n\ttot = 0;\n\tfor(int i = 1 ; i <= K ; i++) {\n\t\tif(s[i] == 'r') {\n\t\t\tque[++tot] = i;\n\t\t\tfor(int j = i ; j <= K ; j++) {\n\t\t\t\tif(s[j] == 'b' && !vis[j]) {\n\t\t\t\t\tnextt[i] = j;\n\t\t\t\t\tvis[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1,0,0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll MOD = 1e9+7;\n\n// n^m%MOD を求める。O( log(m) )\nll modpow(ll n, int m){\n\tll ret=1;\n\tfor(int i=1; i<=m; i<<=1, (n*=n)%=MOD){\n\t\tif( m&i ) (ret *= n) %= MOD;\n\t}\n\treturn ret;\n}\n\n// 逆元を求める\nll modinv(ll n){\n\treturn modpow( n, MOD-2 );\n}\n\n// 階乗を求める。O(1)  準備O( n*log(n) )\n// fact[n]     : nの階乗\n// fact.inv[n] : nの階乗の逆元\nclass FACTORIAL{\npublic:\n\tvector<ll> fact, inv;\n\tFACTORIAL(int MAX_NUM): fact(MAX_NUM), inv(MAX_NUM) {\n\t\tfact[0] = inv[0] = 1;\n\t\tfor(ll i=1; i<MAX_NUM; i++){\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t\tinv[i] = modinv( fact[i] );\n\t\t}\n\t}\n\tconst ll& operator [ ] ( const int i ) const {\n\t\treturn fact[i];\n\t}\n} fact(1000006); // nの最大値を指定\n\n\n// 組み合わせ(Combinationを求める) O(1)\nll cmb(unsigned int n, unsigned int r){\n\tif( n < r ) return 0;\n\treturn fact[n] * fact.inv[r] % MOD * fact.inv[n-r] % MOD;\n}\n\n\nvector<vector<int>> vec;\nvoid dfs(vector<int> &v, int n, int last=1){\n\tvec.push_back(v);\n\tif(last <= 1 && n >= 1){\n\t\tauto _v = v;\n\t\t_v.push_back(1);\n\t\tdfs(_v, n-2, 1);\n\t}\n\tif(last <= 2 && n >= 1){\n\t\tauto _v = v;\n\t\t_v.push_back(2);\n\t\tdfs(_v, n-2, 2);\n\t}\n\tif( last <= 2 ){\n\t\tlast = 3;\n\t}\n\tfor(int i = last; i <= n; i+=2){\n\t\tauto _v = v;\n\t\t_v.push_back(i);\n\t\tdfs(_v, n-i-1, i);\n\t}\n}\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint N, K;\n\tstring s;\n\tll ans = 0;\n\n\tcin >> N >> K;\n\tcin >> s;\n\n\tvector<int> _v;\n\tdfs(_v, N);\n\t//cout << vec.size() << endl;\n\n\tfor(auto v: vec){\n\t\treverse(all(v));\n\t\tint a[70]={}, b[70]={}, c[70]={}, used[100]={};\n\n\t\t// check 1\n\t\tint pos = 0;\n\t\tif(pos < v.size()) rep(i,s.length()) if(s[i] == 'r'){\n\t\t\tused[i] = true;\n\t\t\ta[pos++] = i;\n\t\t\tif(pos >= v.size()) break;\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t// check 2\n\t\tpos = 0;\n\t\twhile(pos < v.size() && v[pos] < 2) pos++;\n\t\tif(pos < v.size()) rep(i,s.length()) if(s[i] == 'b' && a[pos] < i){\n\t\t\tused[i] = true;\n\t\t\tb[pos++] = i;\n\t\t\twhile(pos < v.size() && v[pos] < 2) pos++;\n\t\t\tif(pos >= v.size()) break;\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t// check 3\n\t\tpos = 0;\n\t\twhile(pos < v.size() && v[pos] < 3) pos++;\n\t\tif(pos < v.size()) rep(i,s.length()) if(!used[i] && b[pos] < i){\n\t\t\tused[i] = true;\n\t\t\tc[pos]++;\n\t\t\tif( c[pos] >= v[pos] / 2 ){\n\t\t\t\tpos++;\n\t\t\t\twhile(pos < v.size() && v[pos] < 3) pos++;\n\t\t\t\tif(pos >= v.size()) break;\n\t\t\t}\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t//cout << v << \"\\t\";\n\t\t// ok\n\t\tll less = N;\n\t\tfor(auto t: v) less -= t + 1;\n\t\tfor(auto t: v) if(t == 2) less++;\n\t\tif( !v.empty() ) less++;\n\t\t//cout << \"less=\" << less << \" \";\n\n\t\tll num = v.size() + 1;  // for White\n\t\tfor(auto t: v){  // for Red\n\t\t\tif(t == 1) num++;\n\t\t\telse if(t == 2) num += 2;\n\t\t\telse num += t / 2 + 2;\n\t\t}\n\t\tfor(auto t: v){  // for Blue\n\t\t\tif(t == 1) ;\n\t\t\telse if(t == 2) num += 1;\n\t\t\telse num += t / 2 + 1;\n\t\t}\n\t\t//cout << \"num=\" << num << \" \";\n\n\t\tll sum = fact[v.size()];\n\t\tll bf = -1, cnt=0;\n\t\tv.push_back(-1);\n\t\tfor(auto t: v){\n\t\t\tcnt++;\n\t\t\tif(bf != t){\n\t\t\t\t//cout << \"c=\" << cnt << \" \";\n\t\t\t\tsum = (sum * fact.inv[cnt]) % MOD;\n\t\t\t\tcnt = 0;\n\t\t\t\tbf = t;\n\t\t\t}\n\t\t}\n\t\t//cout << sum << \" \";\n\t\tsum = (sum * cmb(num + less - 1, less)) % MOD;\n\t\tans = (ans + sum) % MOD;\n\t\t//cout << \"sum=\" << sum << endl;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], suf[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 5][N * 5], ans = 0ll;\n\nbool check () {\n\tvector<int> vec1, vec2, vec3;\n\tfor (int i = 0; i < top; i++) vec1.push_back(stk[i]);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') {\n\t\t\tif (!vec1.empty()) {\n\t\t\t\tif (vec1.back()) vec2.insert(vec2.begin(), vec1.back());\n\t\t\t\tvec1.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!vec2.empty()) {\n\t\t\t\tif (vec2.back() > 1) vec3.push_back(vec2.back() - 1);\n\t\t\t\tvec2.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn vec1.empty() && vec2.empty() && vec3.empty();\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tassert(j <= n * 3 && tmp[i] <= n * 3);\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tif (n + num2 - 1 < 0 || num1 + num2 - 1 < 0) return 0ll;\n\tif (n + num2 - 1 > n * 5 || num1 + num2 - 1 > n * 5) return 0ll;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 5; i++) {\n\t\tfor (int j = 0; j <= n * 5; j++) c[i][j] = 0ll;\n\t}\n\tfor (int i = 0; i <= n * 5; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 5; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=75,mod=1e9+7;\nint n,k,a[N],use[N],posr[N],posb[N],fac[N],ifac[N],c[N*3][N*3],Ans;\nchar s[N];\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x; \n}\ninline int C(ri n,ri m){\n\treturn m<0||n<m?0:c[n][m];\n}\ninline void solve(ri cnt){\n\tri i,now,res;\n\tfor(i=1;i<=k;++i) use[i]=0;\n\tfor(i=1;i<=cnt;++i) posr[i]=posb[i]=0;\n\tnow=0;\n\tfor(i=1;i<=k&&now<cnt;++i)\n\t\tif(s[i]=='r') use[i]=1,posr[++now]=i;\n\tif(now<cnt) return;\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=2;++i){\n\t\tfor(now=max(now,posr[i]+1);now<=k&&s[now]!='b';++now);\n\t\tif(now>k) return;\n\t\tposb[i]=now;\n\t\tuse[now]=1;\n\t\t++now;\n\t}\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=3;++i){\n\t\tres=a[i]-2;\n\t\tfor(now=max(now,posb[i]+1);now<=k&&res;++now)\n\t\t\tif(!use[now])\n\t\t\t\tuse[now]=1,--res;\n\t\tif(res) return;\n\t}\n\t\n\tri j,ans=fac[cnt],c1,c2;\n\tfor(i=1;i<=cnt;i=j+1){\n\t\tfor(j=i;j+1<=cnt&&a[j+1]==a[i];++j);\n\t\tans=(ll)ans*ifac[j-i+1]%mod;\n\t}\n\tc1=n+1;\n\tc2=0;\n\tfor(i=1;i<=cnt;++i){\n\t\tif(a[i]>=2)\n\t\t\tc1+=2;\n\t\tc2+=a[i]*2;\n\t}\n\tans=(ll)ans*C(c1,c2)%mod; \n\tadd(Ans,ans);\n}\ninline void dfs(ri i,ri sum){\n\tif(i>1) solve(i-1);\n\tfor(ri j=a[i-1];j;--j)\n\t\tif(sum+j*2-(j>=2?2:0)<=n+1)\n\t\t\ta[i]=j,\n\t\t\tdfs(i+1,sum+j*2-(j>=2?2:0));\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tri i,j,m;\n\tfac[0]=1;\n\tfor(i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=fpow(fac[n],mod-2);\n\tfor(i=n;i;--i) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tm=3*n+1;\n\tfor(i=0;i<=m;++i){\n\t\tc[i][0]=1;\n\t\tfor(j=1;j<=i;++j)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n\ta[0]=n;Ans=1;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst LL mod = 1e9 + 7;\nconst int MC = 202;\nLL fct[MC+1];\nLL invfct[MC+1];\nint N,K;\nstring s;\nvector<int> V;\nLL ans;\n\nvoid build(){\n\tfct[0] = fct[1] = 1;\n\trepp(i,2,MC+1){\n\t\tfct[i] = fct[i-1] * i % mod;\n\t}\n\tLL x = fct[MC];\n\tinvfct[MC] = 1;\n\tfor(int i = mod - 2 ; i > 0 ; i >>= 1){\n\t\tif(i % 2 == 1) (invfct[MC] *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t}\n\trepm(i,MC,0){\n\t\tinvfct[i-1] = invfct[i] * i % mod;\n\t}\n}\n\nLL comb(int x , int y){\n\tif(x < 0 || y < 0) return 0;\n\treturn invfct[x] * invfct[y] % mod * fct[x+y] % mod;\n}\n\nbool solve(int y , int z , int a , LL r , bool b){\n\tif(z > N+1 || a > N) return 0;\n\tif(b){\n\t\tint x = V.size();\n\t\tint itr = x - 1 , itb = x - 1;\n\t\tint p = y , q = 0;\n\t\tfor(auto c : s){\n\t\t\tif(c=='r'){\n\t\t\t\tif(itr >= 0) --itr;\n\t\t\t\telse if(p>0) --p;\n\t\t\t\telse if(q) --q;\n\t\t\t} else {\n\t\t\t\tif(itb > itr){\n\t\t\t\t\tq += V[itb]-1;\n\t\t\t\t\t--itb;\n\t\t\t\t} else if(q) --q;\n\t\t\t}\n\t\t}\n\t\tif(~itr || ~itb || p || q) return 0;\n\t\tLL w = fct[x+y] * r % mod;\n\t\tw = w * comb(N-z+1,z+2*x) % mod;\n\t\t(ans += w) %= mod;\n\t}\n\tsolve(y,z,a+1,r,0);\n\tV.PB(a);\n\tfor(int i = 1 ; solve(y,z+2*a*i,a+1,r*invfct[i]%mod,1) ; ++i) V.PB(a);\n\twhile(V.size() && *V.rbegin() == a) V.pop_back();\n\treturn 1;\n}\n\nint main(){\n\tbuild();\n\tcin >> N >> K;\n\tcin >> s;\n\tfor(int i = 0 ; solve(i,i*2,1,invfct[i],1) ; ++i);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=150,P=1e9+7;\nint n,m,top,ans,st[N],fac[N],ifac[N],inv[N],beg[N];\nchar s[N];\nbool vis[N];\nint C(int k1,int k2){\n\tif(k1<0||k2<0||k1-k2<0)return 0;\n\treturn 1LL*fac[k1]*ifac[k2]%P*ifac[k1-k2]%P;\n}\nbool chk(){\n\trep(i,1,m)vis[i]=0;\n\tint ntop=top;\n\trep(i,1,ntop)beg[i]=0;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='r')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t\tbeg[i]=beg[i];\n\t}\n\twhile(ntop&&st[ntop]==1)--ntop;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='b')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t}\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\trep(_,1,st[i]-2){\n\t\t\twhile(beg[i]<=m&&vis[beg[i]])++beg[i];\n\t\t\tif(beg[i]>m)return 0;\n\t\t\tvis[beg[i]]=1;\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int num,int mn,int mx,int ntop){\n\tif(!num){\n\t\tif(!chk())return;\n\t\trep(i,1,top){\n\t\t\tD(\"%d \",st[i]);\n\t\t}\n\t\tD(\"\\n\");\n\t\tD(\">>> %d %d\\n\",mn,mx);\n\t\tint ans=C(n-mn+mx-1,mx-1);\n\t\twhile(ntop){\n\t\t\tint x=st[ntop];\n\t\t\tint t=0;\n\t\t\twhile(st[ntop]==x)++t,--ntop;\n\t\t\tans=1LL*ans*C(ntop+t,t)%P;\n\t\t}\n\t\t(::ans+=ans)%=P;\n\t\treturn;\n\t}\n\twhile(1){\n\t\tdfs(num-1,mn,mx,ntop);\n\t\ttop=ntop;\n\t\tmn+=(num==1?1:2*num-3)+!!mn;\n\t\tif(mn>n)return;\n\t\tmx+=2*num;\n\t\tst[++top]=num;\n\t\t++ntop;\n\t}\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<N;++i)fac[i]=1LL*fac[i-1]*i%P,inv[i]=1LL*(P-P/i)*inv[P%i]%P,ifac[i]=1LL*ifac[i-1]*inv[i]%P;\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tdfs(n+3,0,1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n/*\n1 35\nrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbr\n\n3\n*/\n\n/*\n30 35\nrrrrrrrrrrrrrrrrrbbbbbbbbbbbbbbbbbb\n\n130653412\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,k,cnt; ll ans=1;\nll fac[155],inv[155],f[75],nxt[75][2],now[2],a[75],b[75];\nchar s[75];\nbool vis[75];\n\nll mod(ll x){return x>=cys?x-cys:x;}\nll C(ll x,ll y){return x<y?0:fac[x]*inv[y]%cys*inv[x-y]%cys;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nll getans(){\n\tmemset(vis,0,sizeof(vis));\n\tint pl=0,num=0;\n\tfor(int i=1;i<=cnt;i++) if(f[i]==1) num++;\n\tfor(int i=1;i<=cnt;i++){\n\t\tpl=nxt[pl][0];\n\t\tif(pl>k) return 0;\n\t\ta[i]=pl,vis[pl]=1;\n\t}\n\tfor(int i=1;i<=cnt-num;i++){\n\t\tint tmp=nxt[a[i]][1];\n\t\twhile(vis[tmp]) tmp=nxt[tmp][1];\n\t\tif(tmp>k) return 0;\n\t\tb[i]=tmp,vis[tmp]=1;\n\t}\n\tint now=cnt-num,pcnt=f[now];\n\twhile(f[now]==2) now--,pcnt=f[now];\n\tfor(int i=k;i>=1;i--){\n\t\tif(vis[i]) continue;\n\t\tif(i<b[now]) return 0;\n\t\tpcnt--;\n\t\tif(pcnt==2) now--,pcnt=f[now];\n\t\tif(!now) break;\n\t}\n\tif(pcnt>2) return 0;\n\tint rnum=num,bnum=0,wnum=cnt-1,all=n;\n\tfor(int i=1;i<=cnt-num;i++) rnum+=f[i]-2,bnum+=f[i]-1;\n\tall-=rnum+bnum+wnum;\n\tif(all<0) return 0;\n\tll res=fac[cnt],lst=1;\n\tfor(int i=1;i<=cnt;i++) if(f[i]!=f[i-1]&&i>1) res=res*inv[i-lst]%cys,lst=i;\n\tres=res*inv[cnt+1-lst]%cys;\n\treturn res*C(all+rnum+bnum+wnum+(cnt-num)*2+1,rnum+bnum+wnum+(cnt-num)*2+1)%cys;\n}\n\nvoid dfs(int now,int sum,int all,bool tp){\n\tif(all>n) return;\n\tif(!tp) ans=mod(ans+getans());\n\tif(!sum||!now) return;\n\tfor(int i=0;i<=sum/now;i++){\n\t\tdfs(min(now-1,sum-i*now),sum-i*now,all+i*(now==1?1:2*now-3),i==0?1:0);\n\t\tf[++cnt]=now;\n\t}\n\tcnt-=sum/now+1;\n}\n\nint main(){\n\tn=readint(); k=readint();\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=150;i++) fac[i]=fac[i-1]*i%cys;\n\tinv[150]=qpow(fac[150],cys-2);\n\tfor(int i=149;i>=1;i--) inv[i]=inv[i+1]*(i+1)%cys;\n\tscanf(\"%s\",s+1);\n\tnow[0]=now[1]=k+1;\n\tfor(int i=k;i>=0;i--){\n\t\tnxt[i][0]=now[0],nxt[i][1]=now[1];\n\t\tif(s[i]=='r') now[0]=i;\n\t\telse now[1]=i;\n\t}\n\tdfs(n,n,0,1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint n,k;\nchar s[110];\nbool vis[110];\nbool book[110];\nint a[110];\nbool check(int m)\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(book,0,sizeof(book));\n\tint cnt=0;\n\tfor(int i=1;i<=m&&a[i]==1;i++)cnt++;\n\tint nowr=1,nowb=1;\n\tfor(int i=1;i<=m-cnt;i++)\n\t{\n\t\twhile(nowr<=k&&(vis[nowr]||s[nowr]!='r'))nowr++;\n\t\twhile(nowb<=k&&(vis[nowb]||s[nowb]!='b'||nowb<=nowr))nowb++;\n\t\tif(nowr>k||nowb>k)return false;\n\t\tvis[nowr]=true;\n\t\tvis[nowb]=true;\n\t\tbook[nowb]=true;\n\t}\n\tint tmp=cnt;\n\tfor(int i=1;i<=k&&tmp;i++)\n\t\tif(!vis[i]&&s[i]=='r'){\n\t\t\tvis[i]=true;\n\t\t\ttmp--;\n\t\t}\n\tif(tmp)return false;\n\tint now=cnt+1,num=0;\n\tfor(int i=k;now<=m;i--)\n\t{\n\t\tif(!vis[i])num++;\n\t\tif(book[i]){\n\t\t\tnum-=a[now]-2;\n\t\t\tif(num<0)return false;\n\t\t\tnow++;\n\t\t}\n\t}\n\treturn true;\n}\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%Mod;\n\t\tt=1ll*t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint ans;\nint fac[2010],inv[2010];\nvoid init()\n{\n\tint N=2000;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\tif(x<0||y<0||x-y<0)return 0;\n\treturn 1ll*fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nvoid solve(int m,int len)\n{\n\tint s=m+1;//block-1\n\tfor(int i=1;i<=m;i++)\n\t\tif(a[i]==1)s++;\n\t\telse s+=(a[i]-1)*2+1;\n\tint res=1ll*C(n-len+s-1,s-1)*fac[m]%Mod;\n\tfor(int i=1,j;i<=m;i=j)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&a[j]==a[i])j++;\n\t\tres=1ll*res*inv[j-i]%Mod;\n\t}\n\tans=(ans+res)%Mod;\n\treturn ;\n}\nint cntr;\nbool dfs(int m,int lst,int sum,int len)\n{\n\tif(!check(m-1))return false;\n\tif(m-1>cntr)return true;\n\tsolve(m-1,len);\n\tfor(a[m]=lst;a[m]<=k-sum;a[m]++)\n\t{\n\t\tint tlen=len;\n\t\tif(m>1)tlen++;\n\t\tif(a[m]==1)tlen++;\n\t\telse tlen+=(a[m]-1)*2-1;\n\t\tif(tlen>n)break;\n\t\tif(!dfs(m+1,a[m],sum+a[m],tlen))\n\t\t\tbreak;\n\t}\n\treturn true;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=k;i++)\n\t\tif(s[i]=='r')cntr++;\n\tdfs(1,1,0,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 77;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, k;\nchar str[MX];\nll inv[MX*3], fac[MX*3], faci[MX*3];\n\nvoid init()\n{\n\tinv[0] = fac[0] = faci[0] = 1;\n\tinv[1] = fac[1] = faci[1] = 1;\n\tfor(int i=2; i<MX*3; i++)\n\t{\n\t\tinv[i] = (MOD*MOD - (MOD/i) * inv[MOD%i]) % MOD;\n\t\tfac[i] = fac[i-1] * i % MOD;\n\t\tfaci[i] = faci[i-1] * inv[i] % MOD;\n\t}\n}\n\nll binom(int x, int y)\n{\n\tif(x<0 || y<0 || x<y) return 0;\n\telse return fac[x] * faci[y] % MOD * faci[x-y] % MOD;\n}\n\nvoid input()\n{\n\tread(n), read(k);\n\tscanf(\"%s\", str+1);\n}\n\nvector<vector<int> > sta;\n\nvoid dfs(vector<int> cur)\n{\n\tint len = cur.size()-1;\n\tfor(auto i : cur)\n\t\tif(i == 0) len++;\n\t\telse len += i*2-1;\n\tif(len > n) return;\n\tsta.push_back(cur);\n\tfor(int i=0; i<=(cur.size() ? cur.back() : (n+1)/2); i++)\n\t{\n\t\tvector<int> tmp = cur;\n\t\ttmp.push_back(i);\n\t\tdfs(tmp);\n\t}\n}\n\nbool check(vector<int> s)\n{\n\tint sum[MX];\n\tfill(sum+1, sum+k+1, 1);\n\tvector<int> can;\n\tint rem = 0, r = 1, b = 1, bpos[MX];\n\tfor(int i=0; i<s.size(); i++)\n\t{\n\t\tif(s[i])\n\t\t{\n\t\t\twhile(r<=k && str[r]!='r') r++;\n\t\t\tif(r > k) return false;\n\t\t\twhile(b<=k && (str[b]!='b' || b<=r)) b++;\n\t\t\tif(b > k) return false;\n\t\t\tsum[r] = sum[b] = 0;\n\t\t\tbpos[i] = b;\n\t\t\tr++, b++;\n\t\t}\n\t}\n\tfor(int i=0; i<s.size(); i++)\n\t{\n\t\tif(!s[i])\n\t\t{\n\t\t\twhile(r<=k && str[r]!='r') r++;\n\t\t\tif(r > k) return false;\n\t\t\tsum[r] = 0;\n\t\t\tr++;\n\t\t}\n\t}\n\tfor(int i=k-1; i>=1; i--) sum[i] += sum[i+1];\n\tfor(int i=0; i<s.size(); i++) if(s[i]) can.push_back(sum[bpos[i]]);\n\treverse(can.begin(), can.end());\n\twhile(s.size() && !s.back()) s.pop_back();\n\treverse(s.begin(), s.end());\n\tint tmp = 0;\n\tfor(int i=0; i<can.size(); i++)\n\t{\n\t\ttmp += max(s[i]-1, 0);\n\t\tif(tmp > can[i]) return false;\n\t}\n\treturn true;\n}\n\nll calc(vector<int> s)\n{\n\tll ret = fac[s.size()];\n\tint cnt = 1;\n\tfor(int i=1; i<s.size(); i++)\n\t\tif(s[i] != s[i-1])\n\t\t\tret = ret*faci[cnt] % MOD, cnt = 1;\n\t\telse cnt++;\n\tret = ret*faci[cnt] % MOD;\n\tint up = n+1, dn = 0;\n\tfor(auto v : s)\n\t{\n\t\tdn += 2*v+2;\n\t\tup += (v>=1)*2;\n\t}\n\treturn ret * binom(up, dn) % MOD;\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tdfs(vector<int>());\n\tfor(auto s : sta)\n\t\tif(check(s))\n\t\t\tans = (ans + calc(s)) % MOD;\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=75,Mo=1e9+7;\n\nint n,k,t,f[N],C[N<<1][N<<1],ans;\nchar st[N];\n\nvoid calc() {\n\tint sum=0,tr=t,tb=t;\n\tfo(i,1,k) {\n\t\tif (st[i]=='r'&&tr) tr--;\n\t\telse if (st[i]=='b'&&f[tb]>1&&tb>tr) sum+=f[tb]-2,tb--;\n\t\telse if (sum) sum--;\n\t}\n\twhile (f[tb]==1) tb--;\n\tif (tr||tb||sum) return;\n\n\tint ret=1;\n\tfor(int l=1,r=0;l<=t;l=r+1) {\n\t\twhile (r<t&&f[r+1]==f[l]) r++;\n\t\tret=(ll)ret*C[r][r-l+1]%Mo;\n\t}\n\n\tint cnt=0,ulm=0;\n\tfo(i,1,t) {\n\t\tcnt+=(f[i]==1?1:f[i]*2-3)+1;\n\t\tulm+=(f[i]==1?1:f[i]*2-3)+1;\n\t\tulm+=2*(f[i]>1);\n\t}\n\tcnt--;ulm++;\n\t(ans+=(ll)ret*C[n-cnt+ulm-1][ulm-1]%Mo)%=Mo;\n\t//fo(i,1,t) printf(\"%d \",f[i]);printf(\"%d\\n\",ans);\n}\n\nvoid dfs(int x,int y,int la) {\n\tcalc();\n\t++t;\n\tif (la==1&&x+2<=n+1&&y+1<=k) {\n\t\tf[t]=1;\n\t\tdfs(x+2,y+1,1);\n\t}\n\tfor(int i=max(la,2);;i++) {\n\t\tif (y+i>k) break;\n\t\tif (x+2*i-2>n+1) break;\n\t\tf[t]=i;\n\t\tdfs(x+2*i-2,y+i,i);\n\t}\n\tt--;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tfo(i,0,n<<1) {\n\t\tC[i][0]=1;\n\t\tfo(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mo;\n\t}\n\tscanf(\"%s\",st+1);\n\tdfs(0,0,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1000000007;\nint N,K;\nint C[400][400], fac[400], inv[400];\nint L[75];\nint tot;\nqueue<int> Q;\nint nextt[75], que[75];\nint vis[75];\n\nll qpow(ll a, ll b) {\n\tll res = 1;\n\twhile(b) {\n\t\tif(b&1) res=res*a%mod;\n\t\tb>>=1;\n\t\ta=a*a%mod;\n\t}\n\treturn res;\n}\nvoid init() {\n\tC[0][0] = 1;\n\tfor(int i = 1 ; i <= 250 ; i++) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1 ; j <= i ; j++) {\n\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t\t\tC[i][j] %= mod;\n\t\t}\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1 ; i <= 250 ; i++) fac[i] = fac[i - 1]*i%mod;\n\tinv[250] = qpow(fac[250],mod-2);\n\tfor(int i = 249 ; i >= 0 ; i--) inv[i] = inv[i + 1]*(i + 1)%mod;\n}\n\nbool check(int cnt) {\n\tif(tot < cnt) return false;\n\tint sum[75];\n\tmemset(sum,0,sizeof(sum));\n\tint p = 1;\n\tfor(int i = cnt ; i >= 1 ; i--) {\n\t\tsum[que[i]]++;\n\t\tif(L[p] >= 2) {\n\t\t\tif(nextt[que[i]]==0) return false;\n\t\t\tsum[nextt[que[i]]] += L[p] - 1;\n\t\t}\n\t\tp++;\n\t}\n\tfor(int i = K ; i >= 1 ; i--) {\n\t\tsum[i] += sum[i + 1];\n\t}\n\tfor(int i = K; i >= 1; i--) {\n\t\tif(sum[i] > K - i + 1) return false;\n\t}\n\treturn true;\n}\n\nint ans=0;\nbool dfs(int pre,int dep,int len) {\n\tif(len > N) return false;\n\tif(!check(dep)) return false;\n\t\n\tint k = dep + 1;\n\tfor(int i = 1 ; i <= dep ; i++) {\n\t\tif(L[i] == 1) k++;\n\t\telse k += 2 * L[i] - 1;\n\t}\n\tint cnt = C[N + k - len  - 1][k - 1] * fac[dep]%mod;\n\t\n\tint count = 1;\n\t\n\tfor(int i = 2 ; i <= dep ; i++) {\n\t\tif(L[i] != L[i - 1]) {\n\t\t\tcnt = cnt * inv[count] % mod;\n\t\t\tcount = 0;\n\t\t}\n\t\tcount++;\n\t}\n\t\n\tcnt = cnt * inv[count]%mod;\n\tans += cnt;\n\tans %= mod;\n\tans = (ans + mod)%mod;\n\t\n\t\n\tif(dep >= tot) return true;\n\tfor(int i = pre ; i <= N ; i++) {\n\t\tint tmp = len;\n\t\tif(dep != 0) tmp++;\n\t\tif(i == 1 || i == 2) tmp++;\n\t\telse tmp += 2 * i - 3;\n\t\tL[dep + 1] = i;\n\t\tif(!dfs(i,dep + 1,tmp)) break;\n\t}\n\treturn true;\n}\n\nchar s[75];\nsigned main() {\n\tinit();\n\tcin >> N >> K;\n\tscanf(\"%s\",s + 1);\n\ttot = 0;\n\tfor(int i = 1 ; i <= K ; i++) {\n\t\tif(s[i] == 'r') {\n\t\t\tque[++tot] = i;\n\t\t\tfor(int j = i ; j <= K ; j++) {\n\t\t\t\tif(s[j] == 'b' && !vis[j]) {\n\t\t\t\t\tnextt[i] = j;\n\t\t\t\t\tvis[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1,0,0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =1000000007;\n\nmap< vector<int>, int > M;\nvector< vector<int> > Mi;\nvector<int> cnt[71];\n\nint MX =70;\n\nvoid put(vector<int> &seq, int x) {\n\tfor(int i =(int)seq.size()-1; i >= 0; i--) if(seq[i] >= x) {\n\t\tseq.insert(begin(seq)+i+1,x);\n\t\treturn;\n\t}\n\tseq.insert(begin(seq),x);\n}\n\nint get_id(vector<int> &seq) {\n\tauto it =M.find(seq);\n\tif(it == M.end()) {\n\t\tint m =M.size();\n\t\tM[seq] =m;\n\t\tMi.push_back(seq);\n\t\treturn m;\n\t}\n\treturn it->ss;\n}\n\nvoid dump(int id, int sum, cat cnt_cur) {\n\tif(id >= (int)cnt[sum].size())\n\t\tcnt[sum].resize(id+1,0);\n\tcnt[sum][id] +=cnt_cur;\n\tif(cnt[sum][id] >= mod) cnt[sum][id] -=mod;\n}\n\nvoid push(int id, int sum, cat cnt_cur) {\n\tvector<int> seq =Mi[id];\n\t// add 0\n\tint sum_nw =sum+int(!seq.empty())+1;\n\tseq.push_back(0);\n\tint id_nw =get_id(seq);\n\tif(sum_nw <= MX) dump(id_nw,sum_nw,cnt_cur);\n\t// add non-0\n\tint a =seq.size()-1;\n\tfor(int i =1; i < 100; i++) {\n\t\tif(sum_nw > MX) break;\n\t\tseq[a]++;\n\t\twhile(a > 0 && seq[a-1] < seq[a]) {\n\t\t\tswap(seq[a],seq[a-1]);\n\t\t\ta--;\n\t\t}\n\t\tid_nw =get_id(seq);\n\t\tdump(id_nw,sum_nw,cnt_cur);\n\t\tsum_nw +=2;\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\n\tMi.resize(1);\n\tM[vector<int>()] =0;\n\tcnt[0].resize(1,1);\n\tint st =0;\n\tfor(int i =0; i < MX; i++) {\n\t\tint st_nw =M.size();\n\t\tfor(int sum =MX; sum >= 0; sum--)\n\t\t\tfor(int l =st; l < (int)cnt[sum].size(); l++) if(cnt[sum][l])\n\t\t\t\tpush(l,sum,cnt[sum][l]);\n\t\tst =st_nw;\n\t}\n\tcat C[200][200];\n\tmemset(C,0,sizeof(C));\n\tfor(int i =0; i < 200; i++) {\n\t\tC[i][0] =1;\n\t\tfor(int j =1; j <= i; j++) C[i][j] =(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\n\tint N,K;\n\tstring S;\n\tcin >> N >> K >> S;\n\n\tint ans =0;\n\tfor(int sum =0; sum <= N; sum++) for(int i =0; i < (int)cnt[sum].size(); i++) {\n\t\tif(cnt[sum][i] == 0) continue;\n\t\tvector<int> seq =Mi[i];\n\n\t\tint a =0, b =0, c =0;\n\t\tfor(int i =0; i < K; i++) {\n\t\t\tif(S[i] == 'r') {\n\t\t\t\tif(a < (int)seq.size()) {\n\t\t\t\t\tb +=seq[a];\n\t\t\t\t\tc++;\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif(b > c) b--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(b > 0) {\n\t\t\t\t\tb--;\n\t\t\t\t\tif(c > 0) c--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(a < (int)seq.size() || b > 0) continue;\n\n\t\tint buckets =seq.size()+1;\n\t\tALL_THE(seq,it) buckets +=2*(*it)+1;\n\t\tcat cnt_ins =C[N-sum+buckets-1][buckets-1];\n\n\t\tans =(ans+cnt[sum][i]*cnt_ins)%mod;\n\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\ntypedef long long i64;\nconst int MAX_N = 205, MOD = 1000000007;\n\ni64 fac[MAX_N], inv[MAX_N], ifac[MAX_N];\ni64 result = 0;\n\nint N, K;\nchar S[MAX_N];\n\ni64 binom(int n, int m) {\n  if (n < m) return 0;\n  return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;\n}\n\nint tot = 0, pos[MAX_N], st[MAX_N];\n\nbool check() {\n  static bool vis[105];\n  static int posb[105];\n  memset(vis, 0, sizeof vis);\n  for (int i = 1; i <= tot; ++i)\n    if (pos[i])\n      vis[pos[i]] = 1;\n    else\n      return false;\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    j = max(j, pos[i]);\n    if (st[i] == 1) break;\n    while (j <= K && S[j] != 'b') j++;\n    if (j > K) return false;\n    vis[j] = 1, j++;\n    posb[i] = j;\n  }\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    int cnt = st[i] - 2;\n    j = max(j, posb[i]);\n    while (cnt > 0 && j <= K) {\n      if (!vis[j]) cnt--;\n      vis[j] = 1, j++;\n    }\n    if (cnt > 0) return false;\n  }\n  return true;\n}\n\nvoid dfs(int rest, int restN, int lim) {\n  if (restN < 0 || rest < 0) return;\n  if (rest >= 0) {\n    if (!check()) return;\n    i64 now = fac[tot];\n    int cnt = 0, sum_len = 0;\n    for (int i = 1; i <= tot; ++i) {\n      if (st[i] == 1) {\n\tnow = now * ifac[tot - i + 1] % MOD;\n\tsum_len += tot - i + 1;\n\tbreak;\n      } else {\n\tint j = i, num = 0;\n\twhile (st[j + 1] == st[i]) j++;\n\tnum = j - i + 1, cnt += num, sum_len += num * (st[i] * 2 - 3);\n\tnow = now * ifac[num] % MOD;\n\ti = j;\n      }\n    }\n    assert(sum_len == N - restN);\n    i64 temp = 0;\n    for (int i = 0; i <= N - sum_len; ++i) {\n      int l = sum_len + i;\n      temp = (temp + now * binom(cnt * 2, i) % MOD * binom(N + 1, l + tot) % MOD) % MOD;\n    }\n    result = (result + temp) % MOD;\n  }\n  for (int i = lim; i; --i) {\n    st[++tot] = i;\n    dfs(rest - i, restN - max(i * 2 - 3, 1), i);\n    tot--;\n  }\n}\n\nint main() {\n  fac[0] = ifac[0] = inv[1] = 1;\n  for (int i = 1; i < MAX_N; ++i) fac[i] = fac[i - 1] * i % MOD;\n  for (int i = 2; i < MAX_N; ++i) inv[i] = -(MOD / i) * inv[MOD % i] % MOD;\n  for (int i = 1; i < MAX_N; ++i) ifac[i] = ifac[i - 1] * inv[i] % MOD;\n  \n  scanf(\"%d%d\", &N, &K);\n  scanf(\"%s\", S + 1);\n  \n  for (int i = 1, temp = 0; i <= K; ++i)\n    if (S[i] == 'r') pos[++temp] = i;\n\n  dfs(K, N, K);\n\n  printf(\"%lld\\n\", (result + MOD) % MOD);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 75;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[MN * 3], iFac[MN * 3];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\n\nint Len;\nchar Str[MN];\nint posr[MN], nxposb[MN], rcnt;\n\nint N, Ans;\n\nint stk[MN];\ninline void Calc(int cnt, int csum) {\n\tint Sum = 0;\n\tif (!cnt) Sum = 1;\n\telse if (cnt <= rcnt) {\n\t\tstatic int vis[MN];\n\t\tfor (int i = 1; i <= cnt; ++i) vis[i] = posr[i];\n\t\tint tot = cnt, mxp = 1;\n\t\tfor (int i = 1; i <= cnt && stk[i] >= 2; ++i)\n\t\t\tmxp = vis[++tot] = nxposb[std::max(mxp, vis[i])];\n\t\tif (mxp <= Len) {\n\t\t\tstd::inplace_merge(vis + 1, vis + cnt + 1, vis + tot + 1);\n\t\t\tint nwp = Len + 1, sum = 0, now = cnt, ok = 1;\n\t\t\tfor (int i = tot; i >= 1; --i) {\n\t\t\t\tsum += nwp - vis[i] - 1;\n\t\t\t\tif (Str[vis[i]] == 'r') {\n\t\t\t\t\tif (stk[now] >= 2) sum -= stk[now] - 2;\n\t\t\t\t\tif (sum < 0) { ok = 0; break; }\n\t\t\t\t\t--now;\n\t\t\t\t}\n\t\t\t\tnwp = vis[i];\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tSum = Fac[cnt];\n\t\t\t\tint len = 0, num = 1;\n\t\t\t\tfor (int i = 1; i <= cnt; ++i) {\n\t\t\t\t\t++len;\n\t\t\t\t\tnum += stk[i] * 2;\n\t\t\t\t\tif (i == cnt || stk[i] != stk[i + 1]) {\n\t\t\t\t\t\tSum = (LL)Sum * iFac[len] % Mod;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSum = (LL)Sum * Fac[N - csum + num] % Mod * iFac[num - 1] % Mod * iFac[N - csum + 1] % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tAns -= (Ans += Sum) >= Mod ? Mod : 0;\n}\nvoid DFS(int st, int mx, int sum) {\n\tCalc(st - 1, sum);\n\tif (sum < N) {\n\t\tstk[st] = 1;\n\t\tDFS(st + 1, 1, sum + 2);\n\t}\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (sum + i * 2 <= N + 3) {\n\t\t\tstk[st] = i;\n\t\t\tDFS(st + 1, i, sum + i * 2 - 2);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &Len, Str + 1);\n\tInit(N * 3);\n\tfor (int i = 1; i <= Len; ++i)\n\t\tif (Str[i] == 'r')\n\t\t\tposr[++rcnt] = i;\n\tint nwposb = Len + 1;\n\tnxposb[Len + 1] = Len + 1;\n\tfor (int i = Len; i >= 1; --i) {\n\t\tnxposb[i] = nwposb;\n\t\tif (Str[i] == 'b')\n\t\t\tnwposb = i;\n\t}\n\tDFS(1, (N + 3) / 2, 0);\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int mo=1000000007;\nconst int N=75;\nint C[N*5][N*5];\nint n,k,ans,used[N];\nint q1[N],q2[N],suf[N];\nint f[N][N];\nchar s[N];\nvoid init(){\n\tFor(i,0,N*5-1) C[i][0]=1;\n\tFor(i,1,N*5-1) For(j,1,i)\n\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;\n}\nvoid solve(int S1,int S2){\n\tif (!S1&&!S2) return ++ans,void(0);\n\tif ((S1+S2)*2>n+1||S1+2*S2>k) return; \n\tmemset(used,0,sizeof(used));\n\tint h=0,t=*q2=0;\n\tFor(i,1,k)\n\t\tif (s[i]=='r') q1[++t]=i;\n\t\telse if (s[i]=='b'&&h!=t&&*q2!=S2)\n\t\t\tused[q1[++h]]=used[i]=1,q2[++*q2]=i;\n\tif (*q2!=S2) return;\n\tFor(i,1,S1)\n\t\tif (h==t) return;\n\t\telse used[q1[++h]]=1;\n\tRep(i,k,1) suf[i]=suf[i+1]+(!used[i]);\n\tFor(i,1,S2) q2[i]=suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tFor(i,2,n) Rep(j,S2-1,0) For(k,0,n){\n\t\tint psum=k-2*j;\n\t\tFor(l,1,min(S2-j,(n-k)/i)){\n\t\t\tif ((psum+=i-2)>suf[S2-j-l+1]) break;\n\t\t\tf[j+l][k+i*l]=(f[j+l][k+i*l]+1ll*C[j+l][l]*f[j][k])%mo;\n\t\t}\n\t}\n\tFor(k,0,n){\n\t\tint sum=2*S1+2*k-2*S2-1;\n\t\tint par=2*S1+1+2*k;\n\t\tif (sum&&sum<=n&&f[S2][k])\n\t\t\tans=(ans+1ll*f[S2][k]*C[n-sum+par-1][par-1]%mo*C[S2+S1][S2])%mo;\n\t}\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tFor(S1,0,n) For(S2,0,n) solve(S1,S2);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =1000000007;\n\nmap< vector<int>, int > M;\nvector< vector<int> > Mi;\nvector<int> cnt[71];\n\nint MX =70;\n\nvoid put(vector<int> &seq, int x) {\n\tfor(int i =(int)seq.size()-1; i >= 0; i--) if(seq[i] >= x) {\n\t\tseq.insert(begin(seq)+i+1,x);\n\t\treturn;\n\t}\n\tseq.insert(begin(seq),x);\n}\n\nint get_id(vector<int> &seq) {\n\tauto it =M.find(seq);\n\tif(it == M.end()) {\n\t\tint m =M.size();\n\t\tM[seq] =m;\n\t\tMi.push_back(seq);\n\t\treturn m;\n\t}\n\treturn it->ss;\n}\n\nvoid dump(int id, int sum, cat cnt_cur) {\n\tif(id >= (int)cnt[sum].size())\n\t\tcnt[sum].resize(id+1,0);\n\tcnt[sum][id] +=cnt_cur;\n\tif(cnt[sum][id] >= mod) cnt[sum][id] -=mod;\n}\n\nvoid push(int id, int sum, cat cnt_cur) {\n\tvector<int> seq =Mi[id];\n\t// add 0\n\tint sum_nw =sum+int(!seq.empty())+1;\n\tseq.push_back(0);\n\tint id_nw =get_id(seq);\n\tif(sum_nw <= MX) dump(id_nw,sum_nw,cnt_cur);\n\t// add non-0\n\tint a =seq.size()-1;\n\tfor(int i =1; i < 100; i++) {\n\t\tif(sum_nw > MX) break;\n\t\tseq[a]++;\n\t\twhile(a > 0 && seq[a-1] < seq[a]) {\n\t\t\tswap(seq[a],seq[a-1]);\n\t\t\ta--;\n\t\t}\n\t\tid_nw =get_id(seq);\n\t\tdump(id_nw,sum_nw,cnt_cur);\n\t\tsum_nw +=2;\n\t}\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\n\tMi.resize(1);\n\tM[vector<int>()] =0;\n\tcnt[0].resize(1,1);\n\tint st =0;\n\tfor(int i =0; i < MX; i++) {\n\t\tint st_nw =M.size();\n\t\tfor(int sum =MX; sum >= 0; sum--)\n\t\t\tfor(int l =st; l < (int)cnt[sum].size(); l++) if(cnt[sum][l])\n\t\t\t\tpush(l,sum,cnt[sum][l]);\n\t\tst =st_nw;\n\t}\n\tcat C[200][200];\n\tmemset(C,0,sizeof(C));\n\tfor(int i =0; i < 200; i++) {\n\t\tC[i][0] =1;\n\t\tfor(int j =1; j <= i; j++) C[i][j] =(C[i-1][j]+C[i-1][j-1])%mod;\n\t}\n\n\tint N,K;\n\tstring S;\n\tcin >> N >> K >> S;\n\n\tint ans =0;\n\tfor(int sum =0; sum <= N; sum++) for(int i =0; i < (int)cnt[sum].size(); i++) {\n\t\tif(cnt[sum][i] == 0) continue;\n\t\tvector<int> seq =Mi[i];\n\n\t\tint a =0, b =0;\n\t\tfor(int i =0; i < K; i++) {\n\t\t\tif(S[i] == 'r') {\n\t\t\t\tif(a < (int)seq.size()) {\n\t\t\t\t\tb +=seq[a];\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif(b > 0) b--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(b > 0) b--;\n\t\t\t}\n\t\t}\n\t\tif(a < (int)seq.size() || b > 0) continue;\n\n\t\tint buckets =seq.size()+1;\n\t\tALL_THE(seq,it) buckets +=2*(*it)+1;\n\t\tcat cnt_ins =C[N-sum+buckets-1][buckets-1];\n\n\t\tans =(ans+cnt[sum][i]*cnt_ins)%mod;\n\t}\n\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=3600;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];\n\tbool inB[N];char str[N];\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);\n\t\tg[0][0][0]=1;fo(i,1,n) fo(j,1,m) g[0][i][j]=C(i-1,j-1)*facinv[j]%MOD;\n\t\tfo(cc,1,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,m-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*( (C(ii-1,cc*2-2)+C(ii-1,cc*2-1)*2+C(ii-1,cc*2))%MOD )%MOD);\n\t\t\tfo(i,0,n) fo(j,0,m) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tll ans=0;dp[n+1][0][0][0]=1;\n\t\tfo(A,0,m)\n\t\t{\n\t\t\tint R=0;mem(inB,0);\n\t\t\tif(A) fo(i,1,m) if(str[i]=='r')\n\t\t\t{\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1,pos[++R]=j,ok=1;break;}\n\t\t\t\tif(!ok or R==A) break;//posi=被匹配的第i个蓝色\n\t\t\t}if(R<A) break;\n\t\t\t\n\t\t\tfo(B,0,m)\n\t\t\t{\n\t\t\t\tint cc=0;fo(i,1,m) if(str[i]=='r') cc++,blu[i]=blu[i-1]+(cc>A+B); else blu[i]=blu[i-1]+(!inB[i]);if(cc<A+B) break;\n\t\t\t\tfo(cnt,0,blu[m]) fo(ln,1,n) fo(st,0,A)\n\t\t\t\t{\n\t\t\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\t\t\tfo(j,1,A-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-(blu[pos[st+j]]-blu[pos[st+j-1]]))+(ln-1);\n\t\t\t\t}\n\t\t\t\tfd(ln,n,1) fo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,m) dp[ln][S][t][cnt]=0;\n\t\t\t\tfd(ln,n,1)\n\t\t\t\t{\n\t\t\t\t\tfo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,blu[m]-blu[pos[t]]) if(dp[ln+1][S][t][cnt])\n\t\t\t\t\t\tfo(j,0,A-t) if(go[cnt][ln][t][j]<=blu[m]-blu[pos[t+j]]) fo(i,0,n-S)\n\t\t\t\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],1ll*dp[ln+1][S][t][cnt]*g[ln][i][j]%MOD);\n\t\t\t\t}\n\t\t\t\tfo(S,0,n) fo(cnt,0,m) if(dp[1][S][A][cnt]) fo(S2,0,n-S) if(g[0][S2][B])\n\t\t\t\t\tadd(ans,1ll*dp[1][S][A][cnt]*g[0][S2][B]%MOD*fac[A+B]%MOD*C(n-S-S2+1,A+B)%MOD);\n\t\t\t}\n\t\t}\n\t\twrite(ans);\n\t}\n};\nsigned main()\n{\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define maxn 1005\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nll ans;\nint n,k;\nchar s[maxn];\nint f[maxn];\nll c[maxn][maxn],fac[maxn],inv[maxn];\nll quickpow(ll p,ll k)\n{\n\tll res=1;\n\twhile(k)\n\t{\n\t\tif(k&1)\n\t\t\tres=(res*p)%mod;\n\t\tp=(p*p)%mod;\n\t\tk>>=1;\n\t}\n\treturn res;\n}\nvoid check(int len,int low)\n{\n\tint cnt1=0,cnt2=0,temp1=0,temp2=0;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tif(s[i]=='r' && cnt1<len)\n\t\t{\n\t\t\tcnt1++;\n\t\t\ttemp1+=(f[cnt1]!=1);\n\t\t}\n\t\telse if(s[i]=='b' && temp1)\n\t\t{\n\t\t\ttemp1--;\n\t\t\tcnt2++;\n\t\t\ttemp2+=(f[cnt2]-2);\n\t\t}\n\t\telse if(temp2)\n\t\t\ttemp2--;\n\t}\n\n//\tcerr<<len<<\" \"<<cnt1<<\" \"<<temp1<<\" \"<<temp2<<endl;\n\tif(cnt1<len || temp1 || temp2)\n\t\treturn;\n\n//\tcerr<<\"+1\"<<endl;\n\n\tll res=fac[len];\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tint j=i;\n\t\twhile(f[j+1]==f[i] && j<len) j++;\n\t\tres=(res*inv[j-i+1])%mod;\n\t\ti=j;\n\t}\n//\tcerr<<\"+2\"<<endl;\n\tll sz=len+1;\n\tfor(int i=1;i<=len;i++)\n\t\tsz+=(f[i]*2-1);\n\n//\tcerr<<len<<\" \"<<n<<' '<<sz<<\" \"<<low<<\" \"<<n-(low-sz+1)<<endl;\n\n\tans+=(res*c[n-low+sz-1][sz-1])%mod;\n\tans%=mod;\n}\nvoid dfs(int now,int len,int low)\n{\n//\tcerr<<now<<\" \"<<len<<\" \"<<low<<endl;\n\tif(low>n) return;\n//\tcerr<<now<<\" \"<<len<<\" \"<<low<<endl;\n\tcheck(len-1,low);\n\tfor(int i=now;i>=1;i--)\n\t{\n\t\tf[len]=i;\n\t\tdfs(i,len+1,low+(max(2*i-3,1))+(len!=1));\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tfor(int i=0;i<=300;i++)\n\t{\n\t\tc[i][0]=c[i][i]=1;\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n\tinv[0]=fac[0]=1;\n\tfor(int i=1;i<=300;i++)\n\t\tfac[i]=(fac[i-1]*i)%mod,inv[i]=(quickpow(fac[i],mod-2));\n\tdfs(70,1,0);\n\tprintf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\n#define SIZE 100000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nll dp[100][100][100];\nint main()\n{\n\tint num, kai;\n\tscanf(\"%d%d\", &num, &kai);\n\tstring s;\n\tcin >> s;\n\tinvinit();\n\tll ans = 0;\n\tfor (int p = 0; p <= kai / 2; p++)\n\t{\n\t\tfor (int q = 0; q <= kai - p * 2; q++)\n\t\t{\n\t\t\tif (p + q + (p + q - 1)>num)continue;\n\t\t\tint d[100];\n\t\t\tfill(d, d + 100, 0);\n\t\t\tqueue<int>que;\n\t\t\tint np = 0;\n\t\t\tfor (int i = 0; i < s.size(); i++)\n\t\t\t{\n\t\t\t\tif (np == p)break;\n\t\t\t\tif (s[i] == 'r')que.push(i);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (que.empty())continue;\n\t\t\t\t\tint z = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\td[z] = 1, d[i] = 2;\n\t\t\t\t\tnp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (np != p)continue;\n\t\t\tint nq = 0;\n\t\t\tfor (int i = 0; i < s.size(); i++)\n\t\t\t{\n\t\t\t\tif (nq == q)break;\n\t\t\t\tif (d[i] == 0 && s[i] == 'r')d[i] = 3, nq++;\n\t\t\t}\n\t\t\tif (nq != q)continue;\n\t\t\t//printf(\"%d %d \", p, q);\n\t\t\t//for (int i = 0; i < kai; i++)printf(\"%d\", d[i]); printf(\"\\n\");\n\t\t\tvector<int>v;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = s.size() - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif (d[i] == 0)cnt++;\n\t\t\t\tif (d[i] == 2)v.push_back(cnt);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= v.size(); i++)for (int j = 0; j <= cnt + 1; j++)for (int k = 0; k <= cnt + 1; k++)dp[i][j][k] = 0;\n\t\t\tdp[0][0][0] = 1;\n\t\t\tfor (int i = 0; i <= v.size(); i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j <= cnt; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k <= cnt; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[i][j][k] == 0)continue;\n\t\t\t\t\t\tdp[i][j][k + 1] = (dp[i][j][k + 1] + dp[i][j][k]) % mod;\n\t\t\t\t\t\tfor (int l = 1; i + l <= v.size(); l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (v[i + l - 1] < j + k*l)break;\n\t\t\t\t\t\t\tdp[i + l][j + k*l][k + 1] = (dp[i + l][j + k*l][k + 1] + dp[i][j][k] * com(i + l, l)) % mod;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll t[100];\n\t\t\tfor (int i = 0; i <= cnt; i++)t[i] = dp[v.size()][i][cnt + 1];\n\t\t\t//for (int i = 0; i <= cnt; i++)printf(\" %lld\", t[i]); printf(\"\\n\");\n\t\t\tll sum = 0;\n\t\t\tfor (int i = 0; i <= cnt; i++)\n\t\t\t{\n\t\t\t\tint ned = q + p + 2 * i + (p + q - 1);\n\t\t\t\tint add = q + 3 * p + 2 * i + (p + q + 1);\n\t\t\t\tif (ned > num)continue;\n\t\t\t\tsum += t[i] * com(num - ned + add - 1, add - 1);\n\t\t\t\tsum %= mod;\n\t\t\t}\n\t\t\t//printf(\" %lld\\n\", sum);\n\t\t\tans = (ans + sum*com(p + q, p)) % mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void add(int &x,int y) {\n  ((x+=y)>=MOD)?x-=MOD:0;\n} \n\nll C[105][105];\n\nvoid pre(int n) {\n  for(int i=0;i<=n;i++) C[i][0]=1;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n}\n\nint f[85][85][85],up[85];\nint sum[85];\n\nvoid dp(int n,int m,int c) {\n  memset(f,0,sizeof(f));\n  int t=m+2*c-1;\n  f[0][0][0]=1;\n  for(int i=0;i<m;i++)\n    for(int j=0;j<=up[i]&&2*j-m+t<=n;j++) {\n      int s=f[i][j][0];\n      for(int k=1;k<=up[m]&&j+(m-i)*k<=up[m];k++) {\n      \tfor(int l=1;i+l<=m&&j+l*k<=up[i+l];l++)\n      \t  add(f[i+l][j+l*k][k],s*C[i+l][l]%MOD);\n      \tadd(s,f[i][j][k]);\n\t  }\n    }\n  for(int i=0;i<=up[m]&&2*i-m+t<=n;i++) {\n  \tint s=0;\n  \tfor(int j=0;j<=i;j++) add(s,f[m][i][j]);\n  \tif (!s) continue;\n  \tint v=2*i-m+t;\n  \tfor(int j=0;j<=2*m+2&&v+j<=n;j++)\n  \t  add(sum[v+j],s*C[m+c][c]%MOD*C[2*m+2][j]%MOD);\n  }\n}\n\nchar str[85];\n\nint st[85],lpos[85];\nbool vis[85];\n\nint main() {\n  int n,k;\n  scanf(\"%d%d%s\",&n,&k,str+1);\n  pre(100);\n  for(int i=0;2*i<=k;i++) {\n  \tmemset(vis,0,sizeof(vis));\n  \tint cnt=0,top=0;\n  \tfor(int j=1;j<=k&&cnt<i;j++)\n  \t  if (str[j]=='r') st[++top]=j;\n  \t  else if (top) {\n  \t  \t  vis[st[top--]]=vis[j]=1;\n  \t  \t  lpos[++cnt]=j;\n\t\t}\n\tif (cnt<i) continue;\n\tint s=0;\n\tfor(int j=1;j<=k;j++)\n\t  if (!vis[j]&&str[j]=='r') s++;\n\tint r=1;\n\tlpos[i+1]=k+1;up[i+1]=0;\n\tfor(int j=0;j<=s;j++) {\n\t\tif (j) {\n\t\t\twhile (vis[r]||str[r]!='r') r++;\n\t\t\tvis[r]=1;\n\t\t}\n\t\tfor(int t1=i;t1>0;t1--) {\n\t\t\tup[t1]=up[t1+1];\n\t\t\tfor(int t2=lpos[t1+1]-1;t2>lpos[t1];t2--)\n\t\t\t  if (!vis[t2]) up[t1]++;\n\t\t\tup[t1]++;\n\t\t}\n\t\treverse(up+1,up+i+1);\n\t\tdp(n,i,j);\n\t}\n  }\n  int ans=0;\n  for(int i=1;i<=n;i++) add(ans,sum[i]*C[n-1][i-1]%MOD);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint n,k,comb[233][233],tot,tot2,ma[111],mb[111];\nchar s[111];\n\nint c[111],ans,use[111];\nvoid dfs(int mx,int cnt,int sum,int coef)\n{\n\tif(cnt+sum-1>n)return;\n\tif(cnt>tot)return;\n\tif(mx==0)\n\t{\n\t\tif(cnt==0)\n\t\t{\n\t\t\tans++;if(ans>=mod)ans-=mod;\n\t\t\treturn;\n\t\t}\n\t\tif(cnt-c[1]>tot2)return;\n\t\t\n\t\tbool ok=1;int cur=0;\n\t\tmemset(use,0,sizeof(use));\n\t\tfor(int i=(n+3)>>1;i>0;i--)\n\t\t{\n\t\t\tfor(int j=1;j<=c[i];j++)\n\t\t\t{\n\t\t\t\tcur++;\n\t\t\t\tuse[ma[cur]]=1;\n\t\t\t\tuse[mb[cur]]=i-1;\n\t\t\t}\n\t\t}\n\t\tcur=0;\n\t\tfor(int i=k;i>=1&&ok;i--)\n\t\t{\n\t\t\tcur++;\n\t\t\tif(cur<use[i])ok=0;\n\t\t\telse cur-=use[i];\n\t\t}\n\t\tif(ok)\n\t\t{\n\t\t\tint have=n-cnt-sum+1,need=sum+cnt+1+(cnt-c[1])*2;\n\t\t\tans=(ans+1ll*coef*comb[have+need-1][need-1])%mod;\n\t\t}\n\t\treturn;\n\t}\n\tfor(c[mx]=0;c[mx]<=n;c[mx]++)dfs(mx-1,cnt+c[mx],sum+c[mx]*(mx==1?1:mx+mx-3),coef*1ll*comb[cnt+c[mx]][cnt]%mod);\n}\n\nint main()\n{\n\tfor(int i=0;i<233;i++)\n\t{\n\t\tcomb[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tcomb[i][j]=comb[i-1][j]+comb[i-1][j-1];\n\t\t\tif(comb[i][j]>=mod)comb[i][j]-=mod;\n\t\t}\n\t}\n\tget2(n,k);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=k;i++)if(s[i]=='r')\n\t{\n\t\tint j=i;\n\t\tfor(;j<=k;j++)if(s[j]=='b'&&!use[j])break;\n\t\ttot++;tot2+=(j<=k);\n\t\tma[tot]=i;mb[tot]=j;\n\t\tuse[j]=1;\n\t}\n\tdfs((n+3)/2,0,0,1);\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::endl;\n\nconst int N = 75 * 10, P = 1e9 + 7;\n\ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n\nint n, m, fac[N], inv[N];\nchar str[N];\nint size[N];\n\ninline int binom(int x, int y) {\n  if (x < y || x < 0 || y < 0) return 0;\n  return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\n\nint val[N], tot;\nint ans = 1;\nint last[N];\nbool vis[N];\n\ninline bool check() {\n  for (int i = 1; i <= m; ++i)\n    vis[i] = 0, last[i] = 0;\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    while (j <= m && str[j] != 'r') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] == 1) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    while (j <= m && str[j] != 'b') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] <= 2) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    for (int k = val[i] - 2; k; --k) {\n      while (j <= m && vis[j]) ++j;\n      if (j > m) return 0;\n      vis[j] = 1, ++j;\n    }\n  }\n  return 1;\n}\n\nvoid dfs(int left, int high) {\n  if (check()) {\n    int sum = tot + 1;\n    for (int i = 1; i <= tot; ++i) {\n      sum += size[val[i]];\n      if (val[i] > 1) sum += 2;\n    }\n    int way = 1ll * binom(sum + left - 1, left);\n    way = 1ll * way * fac[tot] % P;\n    for (int i = 1, j = 1; i <= tot; i = j) {\n      while (j <= tot && val[i] == val[j])\n        ++j;\n      way = 1ll * way * inv[j - i] % P;\n    }\n    ans = (ans + way) % P;\n  }\n  for (int i = 1; i <= high; ++i) {\n    if (size[i] + 1 > left) break;\n    val[++tot] = i;\n    dfs(left - size[i] - 1, i);\n    --tot;\n  }\n}\n\nint main() {\n  for (int i = fac[0] = 1; i < N; ++i)\n    fac[i] = 1ll * fac[i - 1] * i % P;\n  inv[N - 1] = fpow(fac[N - 1], P - 2);\n  for (int i = N - 1; i; --i)\n    inv[i - 1] = 1ll * inv[i] * i % P;\n  scanf(\"%d %d %s\", &n, &m, str + 1);\n  size[1] = size[2] = 1;\n  for (int i = 3; i < N; ++i)\n    size[i] = size[i - 1] + 2;\n  for (int i = 1; ; ++i) {\n    if (size[i] > n) break;\n    val[tot = 1] = i;\n    dfs(n - size[i], i);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MOD (1000000007)\nusing namespace std;\nconst int MAXN = 105;\ntypedef long long LL;\nint N, M, A[MAXN], minLen[MAXN], Belong[MAXN], Last[MAXN],KK,LLL;\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check(vector<int> Seq)\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1])--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<int> Seq, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<int> Seq, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check(Seq))Calc(Tot, Seq, V),++KK;\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, Seq, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= 70; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, Seq, newV, 1, Tot + minLen[Len]);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N / 2, M, N, V1, V2, 0, 0);\n\tcout << (Ans + 1) % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD> struct ModInt {\n    static const unsigned static_MOD = MOD;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000;\nMint inv[MAX+1], fact[MAX+1], fact_inv[MAX+1];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i=2; i<=MAX; i++) inv[i] = inv[MOD%i] * (MOD-MOD/i);\n\n    fact[0] = fact_inv[0] = 1;\n    for (int i=1; i<=MAX; i++) {\n\tfact[i] = fact[i-1] * i;\n\tfact_inv[i] = fact_inv[i-1] * inv[i];\n    }\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nint N, K;\nchar S[211];\nint D[211];\nMint ans;\nvoid calc(const VI &v) {\n    memset(D, -1, sizeof D);\n    int cnt = 0;\n    REP (k, K) {\n\tif (S[k] == 'r' && cnt < (int)v.size()) {\n\t    D[k] = cnt++;\n\t}\n    }\n    if (cnt < (int)v.size()) return;\n\n    int b_size = 0;\n    EACH (e, v) if (*e >= 1) b_size++;\n\n    int ma = -1;\n    cnt = 0;\n    REP (k, K) {\n\tamax(ma, D[k]);\n\tif (S[k] == 'b' && cnt < b_size && cnt <= ma) {\n\t    D[k] = cnt++;\n\t}\n    }\n    if (cnt < b_size) return;\n\n    int idx = 0;\n    ma = -1;\n    cnt = 0;\n    REP (k, K) {\n\tif (S[k] == 'b' && D[k] != -1) amax(ma, D[k]);\n\telse if (D[k] == -1 && idx < (int)v.size() && v[idx] >= 2 && idx <= ma) {\n\t    cnt++;\n\t    if (v[idx] == cnt + 1) {\n\t\tidx++;\n\t\tcnt = 0;\n\t    }\n\t}\n    }\n    if (idx < (int)v.size() && v[idx] >= 2) return;\n\n    Mint tmp = 0;\n    if (v.empty()) {\n\ttmp = 1;\n    } else {\n\tMint x = fact[v.size()];\n\tfor (int i=0; i<(int)v.size();) {\n\t    int j = i;\n\t    while (j < (int)v.size() && v[i] == v[j]) j++;\n\t    x *= fact_inv[j-i];\n\t    i = j;\n\t}\n\n\tint use_len = v.size()-1;\n\tint color_cnt = v.size()+1;\n\tREP (i, v.size()) {\n\t    if (v[i] == 0) {\n\t\tuse_len++;\n\t\tcolor_cnt++;\n\t    } else {\n\t\tuse_len += v[i]*2 - 1;\n\t\tcolor_cnt += v[i]*2 + 1;\n\t    }\n\t}\n\n\tint rest = N - use_len;\n\tif (rest < 0) exit(-1);\n\tassert(rest >= 0);\n\ttmp = nCk(rest + color_cnt - 1, rest) * x;\n    }\n\n    ans += tmp;\n}\n\nvoid rec(int len, VI &v) {\n    calc(v);\n    int high;\n    if (len) {\n\thigh = v.back();\n    } else {\n\thigh = N;\n    }\n\n    v.push_back(0);\n    REP (i, high+1) {\n\tint add = 0;\n\tadd += (i? i*2-1: 1);\n\tif (v.size() > 1u) add += 1;\n\tif (len + add > N) break;\n\tv.back() = i;\n\trec(len+add, v);\n    }\n    v.pop_back();\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d%s\", &N, &K, S);\n    VI v;\n    rec(0, v);\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\nint n,k;\nchar str[1111];\ntypedef long long ll;\ncpnst ll mod=1e9+7;\nll C[1111][1111],fac[1111];\nvoid precalc()\n{\n\tregister int i,ii;\n\tC[0][0]=1;\n\tfor(i=fac[0]=1;i<=1000;i++)fac[i]=fac[i-1]*i%mod,C[i][0]=C[i][i]=1;\n\tfor(i=1;i<=1000;i++)\n\t\tfor(ii=1;ii<i;ii++)C[i][ii]=(C[i-1][ii-1]+C[i-1][ii])%mod;\n}\nll ans=0;\nint siz[1111];\nbool vis[1111];\nbool eraser()\n{for(register int i=1;i<=k;i++)if(!vis[i])if(str[i]=='r')return vis[i]=1;return 0;}\nvoid cover(register int p,int s)\n{for(;s;p++)if(!vis[p])vis[p]=1,s--;}\nbool elim(int ss)\n{\n\tint R=0;\n\tint ff=0;\n\tfor(register int i=k;i;i--)\n\t{\n\t\tif(!vis[i])R++;\n\t\tif(R>=ss-1)if(!vis[i])if(str[i]=='b')ff=i;\n\t\tif(ff)if(!vis[i])if(str[i]=='r')return cover(ff,ss-1),vis[i]=1;\n\t}return 0;\n}\nint locatr(int x)\n{while(x<=k&&(str[x]!='r'||vis[x]))x++;return x;}\nint locatb(int x)\n{while(x<=k&&(str[x]!='b'||vis[x]))x++;return x;}\nint Rs[11111];\nbool valid(int T)\n{\n\tif(!T)return 1;\n\tregister int i;\n\tfor(i=1;i<=k+1;i++)vis[i]=0,Rs[i]=0;\n\tint cc=0;\n\tfor(i=T;i;i--)\n\t\tif(siz[i]>1)cc++;\n\tint x=locatr(1),y=locatb(x);\n\tfor(i=1;i<=cc;i++)\n\t{\n\t\tif(y==k+1)return 0;\n\t\tvis[x]=1,vis[y]=1,Rs[y+1]+=siz[i]-2,x=locatr(x+1),y=locatb(y+1);\n\t\tif(y<x)y=locatb(x);\n\t}for(i=1;i<=T;i++)\n\t\tif(siz[i]==1)\n\t\t\tif(!eraser())return 0;\n\tint ss=0,EE=0;\n\tfor(i=k+1;i;i--)\n\t{\n\t\tss+=Rs[i];\n\t\tif(ss>EE)return 0;\n\t\tEE+=!vis[i-1];\n\t}return 1;\n}\nll concen(int T)\n{\n\tregister int i,ii;\n\tll ret=1,G=T;\n\tfor(i=1;i<=T;i=ii+1)\n\t{\n\t\tfor(ii=i;ii<T&&siz[ii]==siz[ii+1];ii++);\n\t\t(ret*=C[G][ii-i+1])%=mod,G-=ii-i+1;\n\t}return ret;\n}\nll solve(int T,int res)\n{\n\tif(!T)return 1;\n\tregister int i;\n\tll SS=T+1;\n\tfor(i=1;i<=T;i++)SS+=2*siz[i]-1;\n\treturn C[SS+res-1][res]*concen(T);\n}\nvoid dfs(int dep=1,int prev=k,int sum=0)\n{\n\tif(sum>n)return;\n\tif(!valid(dep-1))return;\n\t(ans+=solve(dep-1,n-sum))%=mod;\n\tregister int i;\n\tif(dep^1)sum++;\n\tfor(i=prev;i;i--)siz[dep]=i,dfs(dep+1,i,sum+(i<<1)-3+(i==1)*2);\n}\nint main()\n{precalc(),scanf(\"%d%d%s\",&n,&k,str+1),dfs(),printf(\"%lld\\n\",ans);}\n/*\nJust go for it.\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint n,k;\nchar s[81];\nbool vis[81];\nbool book[81];\nint a[81];\nbool check(int m)\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(book,0,sizeof(book));\n\tint cnt=0;\n\tfor(int i=1;i<=m&&a[i]==1;i++)cnt++;\n\tint nowr=1,nowb=1;\n\tfor(int i=1;i<=m-cnt;i++)\n\t{\n\t\twhile(nowr<=k&&(vis[nowr]||s[nowr]!='r'))nowr++;\n\t\twhile(nowb<=k&&(vis[nowr]||s[nowb]!='b'||nowb<=nowr))nowb++;\n\t\tif(nowr>k||nowb>k)return false;\n\t\tvis[nowr]=true;\n\t\tvis[nowb]=true;\n\t\tbook[nowb]=true;\n\t}\n\tint tmp=cnt;\n\tfor(int i=1;i<=k&&tmp;i++)\n\t\tif(!vis[i]&&s[i]=='r'){\n\t\t\tvis[i]=true;\n\t\t\ttmp--;\n\t\t}\n\tif(tmp)return false;\n\tint now=cnt+1,num=0;\n\tfor(int i=k;i>=1&&now<=m;i--)\n\t{\n\t\tif(!vis[i])num++;\n\t\tif(book[i]){\n\t\t\tnum-=a[now]-2;\n\t\t\tif(cnt<0)return false;\n\t\t\tnow++;\n\t\t}\n\t}\n\treturn true;\n}\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%Mod;\n\t\tt=1ll*t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint ans;\nint fac[510],inv[510];\nvoid init()\n{\n\tint N=500;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\tif(x<0||y<0||x-y<0)return 0;\n\treturn 1ll*fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nvoid solve(int m,int len)\n{\n\tint s=0;//block-1\n\tfor(int i=1;i<=m;i++)\n\t\ts+=a[i]*2;\n\tint res=1ll*C(n-len+s,s)*fac[m]%Mod;\n\tfor(int i=1,j;i<=m;i=j)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&a[j]==a[i])j++;\n\t\tres=1ll*res*inv[j-i]%Mod;\n\t}\n\tans=(ans+res)%Mod;\n\treturn ;\n}\nbool dfs(int m,int lst,int sum,int len)\n{\n\tif(len>n)return false;\n\tif(!check(m-1))return false;\n\tsolve(m-1,len);\n\tfor(a[m]=lst;a[m]<=k-sum;a[m]++)\n\t{\n\t\tint tlen=len;\n\t\tif(m>1)tlen++;\n\t\tif(a[m]==1)tlen++;\n\t\telse tlen+=(a[m]-1)*2-1;\n\t\tif(!dfs(m+1,a[m],sum+a[m],tlen))\n\t\t\tbreak;\n\t}\n\treturn true;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tdfs(1,1,0,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=1 +117;\nconst int MM=1 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\nconst int mod=1e9+7;\nint k,n;\nLL fact[4*NN]={};\nLL rev[4*NN]={};\nchar s[NN]={};\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=a*ret%mod;\n\treturn ret;\n}\nLL comp(int n,int m){\n\treturn fact[n]*rev[m]%mod*rev[n-m]%mod;\n}\nvoid prefact(int n){\n\tfact[0]=1;\n\tfor(int i=1;i<=n;++i)fact[i]=fact[i-1]*i%mod;\n\trev[n]=ksm(fact[n],mod-2);\n\tfor(int i=n;i>=1;--i){\n\t\trev[i-1]=rev[i]*i%mod;\n\t}\n}\nint seq[NN][2]={},scnt=0;\nLL ans=0;\nint len[NN]={};\nint pos[NN]={};\nbool used[NN]={};\nint rcnt=0;\nint bcnt=0;\nvoid calc(){\n\tint tp=0;\n\tfor(int i=1;i<=k;++i)used[i]=0;\n\tfor(int i=1;i<=scnt;++i){\n\t\tfor(int j=1;j<=seq[i][1];++j){\n\t\t\tlen[++tp]=seq[i][0];\n\t\t\tpos[tp]=0;\n\t\t}\n\t}\n\tint now=1;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!used[i]&&s[i]=='r'&&now<=tp&&pos[now]<i){\n\t\t\t--len[now],pos[now]=i,++now,used[i]=1;\n\t\t}\n\t}\n\tif(now!=tp+1)return ;\n\tnow=1;\n\twhile(now<=tp&&!len[now])++now;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!used[i]&&s[i]=='b'&&now<=tp&&pos[now]<i){\n\t\t\t--len[now],pos[now]=i,used[i]=1;\n\t\t\t++now;\n\t\t\twhile(now<=tp&&!len[now])++now;\n\t\t}\n\t}\n\tif(now!=tp+1)return ;\n\tnow=1;\n\twhile(now<=tp&&!len[now])++now;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!used[i]&&now<=tp&&pos[now]<i){\n\t\t\t--len[now],pos[now]=i,used[i]=1;\n\t\t\twhile(now<=tp&&!len[now])++now;\n\t\t}\n\t}\n\tif(now!=tp+1)return ;\n\tint les=tp-1;\n\tif(tp==0)les=1;\n\tint seg=tp+1;\n\tLL ad=fact[tp];\n\tfor(int i=1;i<=scnt;++i){\n\t\tad=ad*rev[seq[i][1]]%mod;\n\t\tint l=seq[i][0];\n\t\tfor(int j=1;j<=seq[i][1];++j){\n\t\t\tif(l==1)les+=1;\n\t\t\telse les+=2*l-3;\n\t\t\tseg+=2*l-1;\n\t\t}\n\t}\n\tif(les>n)return ;\n\t//for(int i=1;i<=scnt;++i)cerr<<seq[i][0]<<\":\"<<seq[i][1]<<endl;\n\t//cerr<<endl;\n\t//cerr<<ad<<\" \"<<seg<<\" \"<<n-les<<endl;\n\tad=ad*comp(n-les+seg-1,n-les)%mod;\n\tans=(ans+ad)%mod;\n}\nint all=-1;\nint TEST=0;\nvoid dfs(int rem,int now){\n\tif(all>n)return ;\n\tif(now==0){\n\t\tcalc();\n\t\t//for(int i=1;i<=scnt;++i)cerr<<seq[i][0]<<\":\"<<seq[i][1]<<endl;\n\t\t//cerr<<endl;\n\t\treturn ;\n\t}\n\tfor(int i=0;i*now<=rem;++i){\n\t\tif(i){\n\t\t\t++scnt;\n\t\t\tseq[scnt][0]=now;\n\t\t\tseq[scnt][1]=i;\n\t\t\tif(now==1)all+=i;\n\t\t\telse all+=i*(2*now-3);\n\t\t\tall+=i;\n\t\t}\n\t\tdfs(rem-i*now,now-1);\n\t\tif(i){\n\t\t\t--scnt;\n\t\t\tif(now==1)all-=i;\n\t\t\telse all-=i*(2*now-3);\n\t\t\tall-=i;\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tk=read();\n\tprefact(4*k+n+10);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=k;++i)\n\t\tif(s[i]=='r')rcnt++;\n\t\telse bcnt++;\n\tdfs(k,k);\n\tprintf(\"%lld\\n\",ans);\n\t//cerr<<TEST<<endl;\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 200;\nchar c[maxN];\nint n, k;\nint sz = 0;\nint red[maxN];\nint blue[maxN];\nint r = 1;\nint cnt1[3 * maxN];\nint cnt2[3 * maxN];\nint ans = 0;\nint LIM;\nint F = 0;\nint mark[maxN];\nconst int mod = (int)1e9 + 7;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint fact[2 * maxN];\nint invfact[2 * maxN];\nint inv[2 * maxN];\nint cnk(int n, int k) {\n    if (n < k || k < 0) return 0;\n    return mult(fact[n], mult(invfact[n - k], invfact[k]));\n}\nbool check() {\n    memset(mark, -1, sizeof mark);\n    int ptr = 0;\n    while (ptr < sz && blue[ptr] == 0) {\n        ptr++;\n    }\n    ptr--;\n    //[0 .. ptr] - ok\n    //\n    int ptrR = sz - 1;\n    int ptrB = sz - 1;\n    for (int i = 1; i <= k; i++) {\n        if (c[i] == 'r' && ptrR >= 0) {\n            ptrR--;\n            mark[i] = 1;\n        }\n        if (c[i] == 'b' && ptrB > ptrR && ptrB > ptr) {\n            ptrB--;\n            mark[i] = 1;\n        }\n    }\n    //rrrrrrrbr\n    if (ptrR != -1 || ptrB != ptr) return false;\n    int where = sz - 1;\n    int need = red[sz - 1];\n    for (int i = 1; i <= k; i++) {\n        if (need == 0) return true;\n        if (mark[i] == 1) continue;\n        if (where > ptr) {\n            need--;\n            if (need == 0) {\n                where--;\n                need = red[where];\n            }\n        }\n    }\n    return (need == 0 || where == ptr);\n}\nint his_cnt[maxN];\nvoid calc() {\n    if (!check()) {\n        return;\n    }\n\n    int val = fact[sz];\n    memset(his_cnt, 0, sizeof his_cnt);\n    int groups = 0;\n    int other = 0;\n    for (int i = 0; i < sz; i++) {\n        his_cnt[blue[i]]++;\n        val = mult(val, inv[his_cnt[blue[i]]]);\n        groups += blue[i] + red[i];\n        if (blue[i]) other++;\n    }\n    //so we have\n    // x_1 + ... + x_groups + y_1 + .. + y_2*other + c_1 + c_2 + p_1 + ... + p_(sz - 1) = n\n    // groups + 2 * other + sz - 1 + 2\n    int all_gr = groups + 2 * other + sz - 1 + 2;\n    ans = sum(ans, mult(val, cnk(n + all_gr - 1 - groups - (sz - 1), all_gr - 1)));\n}\nvoid gen(int pos, int total) {\n    if (total + sz - 1 > n) return;\n    if (sz > LIM) return;\n    if (pos == r) {\n        F++;\n        calc();\n        return;\n    }\n    gen(pos + 1, total);\n    if (pos == 0) {\n        red[sz] = 1;\n        blue[sz] = 0;\n        sz++;\n        gen(pos, total + 1);\n        sz--;\n    }\n    else {\n        red[sz] = cnt1[pos];\n        blue[sz] = cnt2[pos];\n        sz++;\n        gen(pos, total + red[sz - 1] + blue[sz - 1]);\n        sz--;\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n    for (int i = 2; i < 2 * maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n\n    cin >> n >> k;\n    for (int i = 1; i <= k; i++) cin >> c[i];\n    LIM = (n + 1) / 2;\n    for (int d = 1; d <= n; d++) {\n        cnt1[r] = d - 1;\n        cnt2[r] = d;\n        r++;\n    }\n    gen(0, 0);\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\nint ts = 0;\nvoid calc(int sz) {\n    ts++;\n    int tb = 0, tr = 0;\n    int used[77], TR[77], TB[77];\n    memset(used, 0, sizeof used);\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        used[tr] = 1;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && (ch[tb] != 'b' || used[tb])) tb++;\n            used[tb] = 1;\n            TR[i] = tr;\n            TB[i] = tb;\n        } else {\n            TR[i] = tr;\n            TB[i] = tr;\n        }\n        if(tr > K || tb > K) return;\n    }\n    for(int i = 1; i <= sz; i++) {\n        int tt = TB[i];\n        for(int j = 1; j <= X[i] - 2; j++) {\n            while(tt <= K && used[tt]) tt++;\n            used[tt] = 1;\n            if(tt > K) return;\n        }\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tot = 0) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K && max(2ll, i * 2 - 2) + tot <= n + 3; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tot + max(2ll, i * 2 - 2));\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    //printf(\"%d\\n\", ts);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;\nusing std::endl;\n\nconst int N = 75 * 10, P = 1e9 + 7;\n\ninline int fpow(int x, int y) {\n  int ret = 1;\n  for ( ; y; y >>= 1, x = 1ll * x * x % P)\n    if (y & 1) ret = 1ll * ret * x % P;\n  return ret;\n}\n\nint n, m, fac[N], inv[N];\nchar str[N];\nint size[N];\n\ninline int binom(int x, int y) {\n  if (x < y || x < 0 || y < 0) return 0;\n  return 1ll * fac[x] * inv[y] % P * inv[x - y] % P;\n}\n\nint val[N], tot;\nint ans = 1;\nint last[N];\nbool vis[N];\n\ninline bool check() {\n  for (int i = 1; i <= m; ++i)\n    vis[i] = 0, last[i] = 0;\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    while (j <= m && str[j] != 'r') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] == 1) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    while (j <= m && str[j] != 'b') ++j;\n    if (j > m) return 0;\n    last[i] = j, vis[j] = 1;\n    ++j;\n  }\n\n  for (int i = 1, j = 1; i <= tot; ++i) {\n    if (val[i] <= 2) continue;\n    if (j <= last[i]) j = last[i] + 1;\n    for (int k = val[i] - 2; k; --k) {\n      while (j <= m && vis[j]) ++j;\n      if (j > m) return 0;\n      vis[j] = 1, ++j;\n    }\n  }\n  return 1;\n}\n\nvoid dfs(int left, int high) {\n  if (check()) {\n    int sum = tot + 1;\n    for (int i = 1; i <= tot; ++i) {\n      sum += size[val[i]];\n      if (val[i] > 1) sum += 2;\n    }\n    int way = 1ll * binom(sum + left - 1, left);\n    way = 1ll * way * fac[tot] % P;\n    for (int i = 1, j = 1; i <= tot; i = j) {\n      while (j <= tot && val[i] == val[j])\n        ++j;\n      way = 1ll * way * inv[j - i] % P;\n    }\n    ans = (ans + way) % P;\n  }\n  for (int i = 1; i <= high; ++i) {\n    if (size[i] + 1 > left) break;\n    val[++tot] = i;\n    dfs(left - size[i] - 1, i);\n    --tot;\n  }\n}\n\nint main() {\n  for (int i = fac[0] = 1; i < N; ++i)\n    fac[i] = 1ll * fac[i - 1] * i % P;\n  inv[N - 1] = fpow(fac[N - 1], P - 2);\n  for (int i = N - 1; i; --i)\n    inv[i - 1] = 1ll * inv[i] * i % P;\n  scanf(\"%d %d %s\", &n, &m, str + 1);\n  size[1] = size[2] = 1;\n  for (int i = 3; i < N; ++i)\n    size[i] = size[i - 1] + 2;\n  for (int i = 1; ; ++i) {\n    if (size[i] > n) break;\n    val[tot = 1] = i;\n    dfs(n - size[i], i);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=1005;\nint C[maxn][maxn];\nint fac[maxn],invfac[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=1LL*fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline int comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nvi apos;\nint ca=0;\nint n,k;\nvi f;\nint solve()\n{\n    if(!f.size()) return 1;\n    int tot=0;\n    for(int i=0;i<f.size();i++)\n    {\n        //dbg(i,apos[i],f[f.size()-i-1]);\n        if(k-apos[i]<f[f.size()-i-1]) return 0;\n        tot+=f[i];\n    }\n    if(tot>k) return 0;\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++)\n    {\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    int ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nint dfs(int r,int mx,int cc,int len=0)\n{\n    if(len+(int)f.size()-1>n) return 0;\n    int ret=1LL*solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(f.size()>=ca) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        int cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=1LL*cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    for(int i=0;i<k;i++) \n    {\n        ca+=s[i]=='r';\n        if(s[i]=='r') apos.push_back(i);\n    }\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=1000000007;\nint n,k,cnt; ll ans=1;\nll fac[155],inv[155],f[75],nxt[75][2],now[2],a[75],b[75];\nchar s[75];\nbool vis[75];\n\nll mod(ll x){return x>=cys?x-cys:x;}\nll C(ll x,ll y){return x<y?0:fac[x]*inv[y]%cys*inv[x-y]%cys;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nll getans(){\n\tmemset(vis,0,sizeof(vis));\n\tint pl=0,num=0;\n\tfor(int i=1;i<=cnt;i++) if(f[i]==1) num++;\n\tfor(int i=1;i<=cnt;i++){\n\t\tpl=nxt[pl][0];\n\t\tif(pl>k) return 0;\n\t\ta[i]=pl,vis[pl]=1;\n\t}\n\tfor(int i=1;i<=cnt-num;i++){\n\t\tint tmp=nxt[a[i]][1];\n\t\twhile(vis[tmp]) tmp=nxt[tmp][1];\n\t\tif(tmp>k) return 0;\n\t\tb[i]=tmp,vis[tmp]=1;\n\t}\n\tint now=cnt-num,pcnt=f[now];\n\twhile(f[now]==2) now--,pcnt=f[now];\n\tfor(int i=k;i>=1;i--){\n\t\tif(vis[i]) continue;\n\t\tif(i<b[now]) return 0;\n\t\tpcnt--;\n\t\tif(pcnt==2) now--,pcnt=f[now];\n\t\tif(!now) break;\n\t}\n\tif(pcnt>2) return 0;\n\tint rnum=num,bnum=0,wnum=cnt-1,all=n;\n\tfor(int i=1;i<=cnt-num;i++) rnum+=f[i]-2,bnum+=f[i]-1;\n\tall-=rnum+bnum+wnum;\n\tif(all<0) return 0;\n\tll res=fac[cnt],lst=1;\n\tfor(int i=1;i<=cnt;i++) if(f[i]!=f[i-1]&&i>1) res=res*inv[i-lst]%cys,lst=i;\n\tres=res*inv[cnt+1-lst]%cys;\n\treturn res*C(all+rnum+bnum+wnum+(cnt-num)*2+1,rnum+bnum+wnum+(cnt-num)*2+1)%cys;\n}\n\nvoid dfs(int now,int sum,int all,bool tp){\n\tif(all>n) return;\n\tif(!tp) ans=mod(ans+getans());\n\tif(!sum||!now) return;\n\tfor(int i=0;i<=sum/now;i++){\n\t\tdfs(min(now-1,sum-i*now),sum-i*now,all+i*(now==1?1:2*now-3),i==0?1:0);\n\t\tf[++cnt]=now;\n\t}\n\tcnt-=sum/now+1;\n}\n\nint main(){\n\tn=readint(); k=readint();\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=150;i++) fac[i]=fac[i-1]*i%cys;\n\tinv[150]=qpow(fac[150],cys-2);\n\tfor(int i=149;i>=1;i--) inv[i]=inv[i+1]*(i+1)%cys;\n\tscanf(\"%s\",s+1);\n\tnow[0]=now[1]=k+1;\n\tfor(int i=k;i>=0;i--){\n\t\tnxt[i][0]=now[0],nxt[i][1]=now[1];\n\t\tif(s[i]=='r') now[0]=i;\n\t\telse now[1]=i;\n\t}\n\tdfs(n,k,0,1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=75;\nconst int mod=1e9+7;\nint n,k;\nchar s[maxn];\nint nxt[maxn][2],pos0[maxn],pos1[maxn],lim[maxn],fac[1005],ifac[1005];\nint dp[maxn][maxn][maxn];\nbool del[maxn];\nvoid Add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\nint C(int a,int b){\n\tif(a<b||a<0||b<0)return 0;\n\treturn 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;\n}\n\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s);\n\tfac[0]=fac[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<=1000;i++){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tifac[i]=1LL*ifac[mod%i]*(mod-mod/i)%mod;\n\t}\n\tREP(i,1000)ifac[i]=1LL*ifac[i-1]*ifac[i]%mod;\n\tnxt[k][0]=nxt[k][1]=k;\n\tfor(int i=k-1;i>=0;i--){\n\t\tif(s[i]=='r')nxt[i][0]=i,nxt[i][1]=nxt[i+1][1];\n\t\telse nxt[i][0]=nxt[i+1][0],nxt[i][1]=i;\n\t}\n\tint ans=0;\n\trep(i,k+1){\n\t\tbool ok=true;\n\t\tint last0=-1,last1=-1;\n\t\trep(j,k)del[j]=false;\n\t\trep(j,i){\n\t\t\tpos0[j]=nxt[last0+1][0];\n\t\t\tpos1[j]=nxt[max(last1+1,pos0[j])][1];\n\t\t\tif(pos0[j]==k||pos1[j]==k){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdel[pos0[j]]=del[pos1[j]]=true;\n\t\t\tlast0=pos0[j];last1=pos1[j];\n\t\t}\n\t\tif(!ok)continue;\n\t\trep(j,i){\n\t\t\tlim[i-j]=0;\n\t\t\tfor(int p=pos1[j]+1;p<k;p++)if(!del[p])lim[i-j]++;\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0][0]=1;\n\t\trep(j,i+1)rep(p,k+1)rep(q,k+1){\n\t\t\tint cur=dp[j][p][q];\n\t\t\tif(!cur)continue;\n\t\t\trep(t,k+1){\n\t\t\t\tif(q+t*p>lim[j+t])break;\n\t\t\t\tAdd(dp[j+t][p+1][q+t*p],1LL*cur*ifac[t]%mod);\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int j=(i==0?0:(pos0[0]+1));j<k;j++)\n\t\t\tif(!del[j]&&s[j]=='r')sum++;\n\t\trep(q,k+1){\n\t\t\tint cur=dp[i][k][q];\n\t\t\tif(!cur)continue;\n\t\t\tint now=q*2+i,csum=min(sum,(i==0?k:lim[i])-q);\n\t\t\trep(j,csum+1){\n\t\t\t\tint coef=1LL*cur*fac[i+j]%mod*ifac[j]%mod;\n\t\t\t\trep(p,n-j-now+1){\n\t\t\t\t\tint cur;\n\t\t\t\t\tif(now+2*i+j==0&&p==0)cur=1;\n\t\t\t\t\telse cur=1LL*C(p+(now+2*i+j-1),now+2*i+j-1)*C(n-j-now-p+1,i+j)%mod;\n\t\t\t\t\tAdd(ans,1LL*coef*cur%mod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 301, mod = 1000000007;\nint n, k, ans = 0;\nchar s[N];\nint fac[N], inv[N];\n\nint f[N], m = 0, r[N], b[N], visit[N];\ninline void solve() {\n  for (int i = 1; i <= k; i++) visit[i] = 0;\n  for (int i = 1, j = 1; i <= m; i++, j++) {\n    while (j <= k && s[j] != 'r') j++;\n    if (j > k) return;\n    r[i] = j;\n    visit[j] = 1;\n  }\n  for (int i = 1, j = 1; i <= m; i++, j++) if (f[i] >= 2) {\n    j = max(j, r[i]);\n    while (j <= k && s[j] != 'b') j++;\n    if (j > k) return;\n    b[i] = j;\n    visit[j] = 1;\n  }\n  for (int i = 1, j = 1; i <= m; i++) if (f[i] >= 3) {\n    int x = f[i] - 2;\n    j = max(j, b[i]);\n    while (x--) {\n      while (j <= k && visit[j]) j++;\n      if (j > k) return;\n      visit[j] = 1;\n      j++;\n    }\n  }\n  int coef = fac[m];\n  for (int i = 1, j = 0; i <= m; i++) {\n    j = f[i] != f[i - 1] ? 1 : j + 1;\n    coef = (ll) coef * fac[j - 1] % mod * inv[j] % mod;\n  }\n  int upper = n + 1, lower = 0;\n  for (int i = 1; i <= m; i++) {\n    if (f[i] >= 2) upper += 2;\n    lower += f[i] * 2;\n  }\n  if (upper < lower) return;\n  coef = (ll) coef * fac[upper] % mod * inv[lower] % mod * inv[upper - lower] % mod;\n  ans = (ans + coef) % mod;\n}\nvoid dfs(int x, int last) {\n  solve();\n  for (int i = last; i; i--) {\n    int y = (i == 1 ? 1 : 2 * i - 3) + 1;\n    if (x >= y) {\n      f[++m] = i;\n      dfs(x - y, i);\n      --m;\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d%d%s\", &n, &k, s + 1);\n  fac[0] = fac[1] = 1;\n  inv[0] = inv[1] = 1;\n  for (int i = 2; i < N; i++) {\n    fac[i] = (ll) fac[i - 1] * i % mod;\n    inv[i] = mod - (ll) mod / i * inv[mod % i] % mod;\n  }\n  for (int i = 2; i < N; i++) {\n    inv[i] = (ll) inv[i] * inv[i - 1] % mod;\n  }\n  dfs(n + 1, n + 1);\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 77;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, k;\nchar str[MX];\nll inv[MX*3], fac[MX*3], faci[MX*3];\n\nvoid init()\n{\n\tinv[0] = fac[0] = faci[0] = 1;\n\tinv[1] = fac[1] = faci[1] = 1;\n\tfor(int i=2; i<MX*3; i++)\n\t{\n\t\tinv[i] = (MOD*MOD - (MOD/i) * inv[MOD%i]) % MOD;\n\t\tfac[i] = fac[i-1] * i % MOD;\n\t\tfaci[i] = faci[i-1] * inv[i] % MOD;\n\t}\n}\n\nll binom(int x, int y)\n{\n\tif(x<0 || y<0 || x<y) return 0;\n\telse return fac[x] * faci[y] % MOD * faci[x-y] % MOD;\n}\n\nvoid input()\n{\n\tread(n), read(k);\n\tscanf(\"%s\", str+1);\n}\n\nvector<vector<int> > sta;\n\nvoid dfs(vector<int> cur)\n{\n\tint len = cur.size()-1;\n\tfor(auto i : cur)\n\t\tif(i == 0) len++;\n\t\telse len += i*2-1;\n\tif(len > n) return;\n\tsta.push_back(cur);\n\tfor(int i=0; i<=(cur.size() ? cur.back() : (n+1)/2); i++)\n\t{\n\t\tvector<int> tmp = cur;\n\t\ttmp.push_back(i);\n\t\tdfs(tmp);\n\t}\n}\n\nbool check(vector<int> s)\n{\n\tint sum[MX];\n\tfill(sum+1, sum+k+1, 1);\n\tvector<int> can;\n\tint rem = 0, r = 1, b = 1, bpos[MX];\n\tfor(int i=0; i<s.size(); i++)\n\t{\n\t\tif(s[i])\n\t\t{\n\t\t\twhile(r<=k && str[r]!='r') r++;\n\t\t\tif(r > k) return false;\n\t\t\twhile(b<=k && (str[b]!='b' || b<=r)) b++;\n\t\t\tif(b > k) return false;\n\t\t\tsum[r] = sum[b] = 0;\n\t\t\tbpos[i] = b;\n\t\t\tr++, b++;\n\t\t}\n\t}\n\tfor(int i=0; i<s.size(); i++)\n\t{\n\t\tif(!s[i])\n\t\t{\n\t\t\twhile(r<=k && str[r]!='r') r++;\n\t\t\tif(r > k) return false;\n\t\t\tsum[r] = 0;\n\t\t\tr++;\n\t\t}\n\t}\n\tfor(int i=k-1; i>=1; i--) sum[i] += sum[i+1];\n\tfor(int i=0; i<s.size(); i++) if(s[i]) can.push_back(sum[bpos[i]]);\n\treverse(can.begin(), can.end());\n\treverse(s.begin(), s.end());\n\tint tmp = 0;\n\tfor(int i=0; i<can.size(); i++)\n\t{\n\t\ttmp += max(s[i]-1, 0);\n\t\tif(tmp > can[i]) return false;\n\t}\n\treturn true;\n}\n\nll calc(vector<int> s)\n{\n\tll ret = fac[s.size()];\n\tint cnt = 1;\n\tfor(int i=1; i<s.size(); i++)\n\t\tif(s[i] != s[i-1])\n\t\t\tret = ret*faci[cnt] % MOD, cnt = 1;\n\t\telse cnt++;\n\tret = ret*faci[cnt] % MOD;\n\tint up = n+1, dn = 0;\n\tfor(auto v : s)\n\t{\n\t\tdn += 2*v+2;\n\t\tup += (v>=1)*2;\n\t}\n\treturn ret * binom(up, dn) % MOD;\n}\n\nvoid work()\n{\n\tll ans = 0;\n\tdfs(vector<int>());\n\tfor(auto s : sta)\n\t\tif(check(s))\n\t\t\tans = (ans + calc(s)) % MOD;\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0;int f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 255*3;\nconst int mod = 1e9+7;\nint n,m;\nchar s[maxn];\nint ans,fac[maxn],ifac[maxn];\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(){\n\tn = read(),m = read();\n\tscanf(\"%s\",s+1);\n\tfac[0] = 1;rep(i,1,maxn) fac[i] = 1ll * fac[i-1] * i % mod;\n\tifac[maxn-1] = qpow(fac[maxn-1],mod-2);\n\tDep(i,maxn-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % mod;\n\tassert(ifac[0]==1);\n}\ninline int C(int n,int m){\n\tif(n<m||n<0) return 0;\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\n#define cal(x,y) C((x)+(y)-1,(y)-1)\ninline void add(int &x,int v){\n\tx+=v;\n\tif(x>=mod) x-=mod;\n}\nint q1[maxn],q2[maxn],suf[maxn],f[maxn][maxn];\nbool used[maxn];\nvoid solve(int S1,int S2){\n\tif(!S1&&!S2) return ++ans,void(0);\n\t*q1=*q2=0;\n\tmemset(used,0,sizeof(used));\n\tint x=0,y=0;\n\tRep(i,1,m)\n\t\tif(s[i]=='r' && x<S1+S2) q1[++x]=i; else \n\t\tif(s[i]=='b' && y<S2 && y<x) q2[++y]=i;\n\tif(y!=S2 || x!=S1+S2) return ;\n\tRep(i,1,x) used[q1[i]]=true;\n\tRep(i,1,y) used[q2[i]]=true;\n\tDep(i,m,1) suf[i]=suf[i+1]+(!used[i]);\n\tRep(i,1,S2) q2[i] = suf[q2[i]];\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tRep(i,2,n)Dep(j,S2-1,0)Rep(k,2*j,n-i*(S2-j)){\n\t\tRep(l,1,min(S2-j,(n-k)/i)){\n\t\t\tif(k+i*l-2*(j+l) > q2[S2-(j+l)+1]) break;\n\t\t\tadd(f[j+l][k+i*l],1ll*ifac[l]*f[j][k]%mod);\n\t\t}\n\t}\n\tint res = 0;\n\tRep(i,0,n){\n\t\tint sum=2*S1+2*i-2*S2-1;\n\t\tint par=2*S1+2*i+1;\n\t\tadd(res,1ll*f[S2][i]*cal(n-sum,par)%mod);\n\t}res = 1ll * res * fac[S1+S2] % mod * ifac[S1] % mod;\n\tadd(ans,res);\n}\nint main(){\n\tinit(); \n\tans = 0;\n\tRep(S1,0,n)Rep(S2,0,n)solve(S1,S2);\n\twriteln(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=220,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint qpow(int x,int k){\n\tint t=1;\n\tfor (;k;k>>=1){\n\t\tif (k&1) t=(ll)t*x%p;\n\t\tx=(ll)x*x%p;\n\t}\n\treturn t;\n}\nint n,m,ans,a[N],s[N],pos[N],C[N][N],po[N],inv[N];\nchar ch[N];bool h[N];\nint get_nex(char c,int i){\n\tfor (;(i<=m)&&(h[i]||(ch[i]!=c));i++);\n\treturn i;\n}\nint get_n(int i){\n\tfor (;(i<=m)&&h[i];i++);\n\treturn i;\n}\nbool check(int dep){\n\tmemset(h,0,m+1);\n\tfor (int i=1;i<=dep;i++){\n\t\tpos[i]=get_nex('r',1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\tfor (int i=1;i<=dep;i++)\n\tif (a[i]>1){\n\t\tpos[i]=get_nex('b',pos[i]+1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\tfor (int i=1;i<=dep;i++)\n\tfor (int j=3;j<=a[i];j++){\n\t\tpos[i]=get_n(pos[i]+1);\n\t\tif (pos[i]>m) return false;\n\t\th[pos[i]]=1;\n\t}\n\treturn true;\n}\nvoid calc(int res,int r,int dep){\n\tint t=po[dep-1],s1=n+1,s2=0;\n\tfor (int i=1;i<=min(n+1,m);i++){\n\t\tt=(ll)t*inv[s[i]]%p;\n\t\ts1+=(i>1)*2*s[i];\n\t\ts2+=2*s[i]*i;\n\t}\n\tif ((s1<s2)||(!check(dep-1))) return;\n\tans=(ans+(ll)t*C[s1][s2])%p;\n\tfor (int i=1;i<=r;i++){\n\t\ta[dep]=i;s[i]++;\n\t\tcalc(res-i,min(i,res-i),dep+1);\n\t\ts[i]--;\n\t}\n\ta[dep]=0;\n}\nint main(){\n\tn=read();m=read();\n\tscanf(\" %s\",ch+1);\n\tC[0][0]=po[0]=inv[0]=1;\n\tfor (int i=1;i<=214;i++){\n\t\tC[i][0]=1;po[i]=(ll)po[i-1]*i%p;\n\t\tinv[i]=qpow(po[i],p-2);\n\t\tfor (int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;\n\t}\n\tcalc(min(n+1,m),min(n+1,m),1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar(‘\\n‘)\n#define space putchar(‘ ‘)\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\nconst int MOD = 1000000007;\nint N,K,C[1005][1005],L[75],fac[1005],invfac[1005],cnt;\nint sum[75],pos[75],tot,ans,matc[75];\nchar s[75];\nbool vis[75];\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n\tx = inc(x,y);\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nbool check() {\n\tif(tot < cnt) return false;\n\tmemset(sum,0,sizeof(sum));\n\tint p = 1;\n\tfor(int i = cnt ; i >= 1 ; --i) {\n\t\tsum[pos[i]]++;\n\t\tif(L[p] >= 2) {\n\t\t\tif(!matc[pos[i]]) return false;\n\t\t\tsum[matc[pos[i]]] += L[p] - 1;\n\t\t}\n\t\t++p;\n\t}\n\tfor(int i = K ; i >= 1 ; --i) {\n\t\tsum[i] += sum[i + 1];\n\t\tif(sum[i] > K - i + 1) return false;\n\t}\n\treturn true;\n}\nbool dfs(int pre,int dep,int len) {\n\tcnt = dep;\n\tif(!check()) return false;\n\tint k = 1 + cnt;\n\tfor(int i = 1 ; i <= cnt ; ++i) {\n\t\tif(L[i] == 1) ++k;\n\t\telse k += 2 * L[i] - 1;\n\t}\n\tint res = C[N - len + k - 1][k - 1];\n\tres = mul(res,fac[cnt]);\n\tint t = 0;\n\tfor(int i = 1 ; i <= cnt ; ++i) {\n\t\tif(L[i] != L[i - 1]) {\n\t\t\tres = mul(res,invfac[t]);\n\t\t\tt = 0;\n\t\t}\n\t\t++t;\n\t}\n\tres = mul(res,invfac[t]);\n\tupdate(ans,res);\n\tif(dep + 1 > tot) return true;\n\tfor(int i = pre ; i <= 70 ; ++i) {\n\t\tint tl = len;\n\t\tif(dep != 0) ++tl;\n\t\tif(i == 1 || i == 2) tl += 1;\n\t\telse tl += i - 2 + i - 1;\n\t\tif(tl > N) break;\n\t\tL[dep + 1] = i;\n\t\tif(!dfs(i,dep + 1,tl)) break;\n\t}\n\treturn true;\n}\nvoid Solve() {\n\tcin >> N >> K;\n\tscanf(\"%s\",s + 1);\n\tC[0][0] = 1;\n\tfor(int i = 1 ; i <= 1000 ; ++i) {\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1 ; j <= i ; ++j) {\n\t\t\tC[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n\t\t}\n\t}\n\tfac[0] = 1;\n\tfor(int i = 1 ; i <= 1000 ; ++i) fac[i] = mul(fac[i - 1],i);\n\tinvfac[1000] = fpow(fac[1000],MOD - 2);\n\tfor(int i = 999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n\ttot = 0;\n\tfor(int i = 1 ; i <= K ; ++i) {\n\t\tif(s[i] == 'r') {\n\t\t\tpos[++tot] = i;\n\n\t\t\tfor(int j = i + 1 ; j <= K ; ++j) {\n\t\t\t\tif(s[j] == 'b' && !vis[j]) {\n\t\t\t\t\tmatc[i] = j;\n\t\t\t\t\tvis[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1,0,0);\n\tcout << ans << endl;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef std::vector <int> vector;\ntypedef long long ll;\nconst int N = 162, mod = 1000000007;\n\nint n, len, ans = 0;\nint fact[N], inv[N], finv[N], C[N][N];\nint a[N], b[N];\nvector rem[N][N];\n\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nvoid init() {\n\tint i, j;\n\tfor (inv[1] = 1, i = 2; i < N; ++i) inv[i] = ll(mod - mod / i) * inv[mod % i] % mod;\n\tfor (*C[0] = i = 1; i < N; ++i)\n\t\tfor (*C[i] = j = 1; j <= i; ++j) add(C[i][j] = C[i - 1][j], C[i - 1][j - 1]);\n}\n\nvoid dfs(int dep, int last, int cur, int n_r, int prod) {\n\tint i, s = 0, nxt = cur + 2, n_rb = dep - n_r;\n\tvector &U = rem[n_r][n_rb];\n\tif (U.empty()) return;\n\tfor (i = n_rb - 1; i >= 0; --i)\n\t\tif ((s += a[i] - 1) > U[n_rb - i]) return;\n\tans = (ans + (ll)prod * C[n + 1 + n_rb * 2][(s + n_rb * 2 + n_r) * 2]) % mod;\n\tprod = prod * (dep + 1ll) % mod;\n\tif (nxt <= n + 1)\n\t\ta[dep] = 0, b[dep] = (last ? 0 : b[dep - 1]) + 1,\n\t\tdfs(dep + 1, 0, nxt, n_r + 1, (ll)prod * inv[b[dep]] % mod);\n\tfor (i = 1; i <= last && nxt <= n + 1; ++i, nxt += 2)\n\t\ta[dep] = i, b[dep] = (i == last ? b[dep - 1] : 0) + 1,\n\t\tdfs(dep + 1, i, nxt, n_r, (ll)prod * inv[b[dep]] % mod);\n}\n\nint main() {\n\tint i, j, k, n_B, c_R, c_RB, poi[N];\n\tint h, t, que[N];\n\tbool used[N]; char s[N];\n\tscanf(\"%d%d%s\", &n, &len, s), init();\n\tn_B = std::count(s, s + len, 98);\n\tfor (i = 0; i <= len; ++i)\n\t\tfor (j = 0; j <= n_B; ++j) {\n\t\t\tc_R = c_RB = h = t = 0, memset(used, false, len);\n\t\t\tfor (k = 0; k < len && c_RB < j; ++k)\n\t\t\t\tif (s[k] == 114) que[t++] = k;\n\t\t\t\telse if (h != t) used[ poi[c_RB++] = k ] = used[ que[h++] ] = true;\n\t\t\tfor (k = 0; k < len && c_R < i; ++k)\n\t\t\t\tif (!used[k] && s[k] == 114) ++c_R, used[k] = true;\n\t\t\tif (c_RB < j || c_R < i) continue;\n\t\t\tvector &res = rem[i][j];\n\t\t\tres.reserve(j + 1), res.EB(0);\n\t\t\tfor (t = 0, k = len - 1; k >= 0 && c_RB; --k)\n\t\t\t\tif (t += !used[k], k == poi[c_RB - 1]) res.EB(t), --c_RB;\n\t\t\tassert((int)res.size() == j + 1);\n\t\t}\n\tdfs(0, INT_MAX, 0, 0, 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n \nconst int p=1000000007;\n \nint c[300][300],g[100],h[100];\nchar b[100];\nint i,j,k,l,m,n,r,s,t;\n \ninline void pre()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",b+1);\n\tfor (i=0;i<=250;i++)\n\t\tfor (j=0;j<=i;j++)\n\t\t\tif ((j==0) || (j==i))\n\t\t\t\tc[i][j]=1;\n\t\t\telse\n\t\t\t\tc[i][j]=(c[i-1][j]+c[i-1][j-1])%p;\n\treturn;\n}\n \ninline void calc()\n{\n\tfor (i=1;i<=n;i++)\n\t\th[i]=g[i];\n\tt=0;\n\tfor (i=1,k=1,l=1;i<=m;i++)\n\t\tif ((b[i]=='r') && (h[k]>0))\n\t\t\th[k]--,k++;\n\t\telse\n\t\tif ((b[i]=='b') && (h[l]>0) && (l<k))\n\t\t\th[l]--,t=t+h[l],l++;\n\t\telse\n\t\tif (t>0)\n\t\t\tt--;\n\tif ((h[k]) || (h[l]) || (t))\n\t\treturn;\n\tr=1;\n\tfor (i=1;g[i];i=j)\n\t{\n\t\tfor (j=i;g[i]==g[j];j++);\n\t\tr=1LL*r*c[j-1][i-1]%p;\n\t\tif (g[i]==1)\n\t\t\tt=t+j-i;\n\t\telse\n\t\t\tt=t+(j-i)*(2*g[i]-3);\n\t}\n\tt=t+k-2;\n\tif (n-t<0)\n\t\treturn;\n\ts=(s+1LL*r*c[n+2*l-1][t+2*l-1])%p;\n\treturn;\n}\n \ninline void dfs(int w,int x,int y,int z)\n{\n\tif (w<0)\n\t\treturn;\n\tif (z)\n\t\tcalc();\n\tif (x)\n\t{\n\t\tg[z+1]=1,dfs(w-2,x-1,1,z+1);\n\t\tfor (int i=2;(i<=x) && (i<=y);i++)\n\t\t\tg[z+1]=i,dfs(w-2*i+2,x-i,i,z+1);\n\t\tg[z+1]=0;\n\t}\n\treturn;\n}\n \nint main()\n{\n\tpre();\n\tdfs(n+1,m,m,0);\n\tprintf(\"%d\",(s+1)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 75;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[1005], iFac[1005];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\n\nint Len;\nchar Str[MN];\nint posr[MN], nxposb[MN], rcnt;\n\nint N, Ans;\n\nint stk[MN];\ninline void Calc(int cnt, int csum) {\n\tint Sum = 0;\n\tif (!cnt) Sum = 1;\n\telse if (cnt <= rcnt) {\n\t\tstatic int vis[MN];\n\t\tfor (int i = 1; i <= cnt; ++i) vis[i] = posr[i];\n\t\tint tot = cnt, mxp = 1;\n\t\tfor (int i = 1; i <= cnt && stk[i] >= 2; ++i)\n\t\t\tmxp = vis[++tot] = nxposb[std::max(mxp, vis[i])];\n\t\tif (mxp <= Len) {\n\t\t\tstd::inplace_merge(vis + 1, vis + cnt + 1, vis + tot + 1);\n\t\t\tint nwp = Len + 1, sum = 0, now = cnt, ok = 1;\n\t\t\tfor (int i = tot; i >= 1; --i) {\n\t\t\t\tsum += nwp - vis[i] - 1;\n\t\t\t\tif (Str[vis[i]] == 'r') {\n\t\t\t\t\tif (stk[now] >= 2) sum -= stk[now] - 2;\n\t\t\t\t\tif (sum < 0) { ok = 0; break; }\n\t\t\t\t\t--now;\n\t\t\t\t}\n\t\t\t\tnwp = vis[i];\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tSum = Fac[cnt];\n\t\t\t\tint len = 0, num = 1;\n\t\t\t\tfor (int i = 1; i <= cnt; ++i) {\n\t\t\t\t\t++len;\n\t\t\t\t\tnum += stk[i] * 2;\n\t\t\t\t\tif (i == cnt || stk[i] != stk[i + 1]) {\n\t\t\t\t\t\tSum = (LL)Sum * iFac[len] % Mod;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSum = (LL)Sum * Fac[N - csum + num] % Mod * iFac[num - 1] % Mod * iFac[N - csum + 1] % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tAns -= (Ans += Sum) >= Mod ? Mod : 0;\n}\nvoid DFS(int st, int mx, int sum) {\n\tCalc(st - 1, sum);\n\tif (sum < N) {\n\t\tstk[st] = 1;\n\t\tDFS(st + 1, 1, sum + 2);\n\t}\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (sum + i * 2 <= N + 3) {\n\t\t\tstk[st] = i;\n\t\t\tDFS(st + 1, i, sum + i * 2 - 2);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &Len, Str + 1);\n\tInit(1000);\n\tfor (int i = 1; i <= Len; ++i)\n\t\tif (Str[i] == 'r')\n\t\t\tposr[++rcnt] = i;\n\tint nwposb = Len + 1;\n\tnxposb[Len + 1] = Len + 1;\n\tfor (int i = Len; i >= 1; --i) {\n\t\tnxposb[i] = nwposb;\n\t\tif (Str[i] == 'b')\n\t\t\tnwposb = i;\n\t}\n\tDFS(1, (N + 3) / 2, 0);\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nchar s[75];int n,K,ans,a[75],p[305],inv[305];\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid Check(int num,int sum)\n{\n\tint pos=num+1,res=p[num],rnum=0,leftr=0,nxt=0,left=0;\n\tfor(int i=1;i<=K;++i)\n\t\tif(s[i]=='r') rnum<num?leftr+=(a[++rnum]>1):(left?--left:0);\n\t\telse leftr?(--leftr,left+=a[++nxt]-2):(left?--left:0);\n\tif(left||rnum<num||leftr) return;\n\tfor(int i=1,j;i<=num;i=j+1)\n\t{\n\t\tfor(j=i;j<num&&a[j+1]==a[i];++j);\n\t\tres=1LL*res*inv[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(a[i]*2-1);\n\t}\n\tans=(ans+1LL*res*C(n-sum+pos-1,pos-1))%mod;\n}\nvoid dfs(int x,int num,int sum)\n{\n\tif(sum>n) return;Check(num,sum);\n\tfor(int i=x;i;--i) a[num+1]=i,dfs(i,num+1,sum+(i>1?i*2-3:1)+(num>0));\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&K,s+1);\n\tp[0]=inv[0]=p[1]=inv[1]=1;\n\tfor(int i=2;i<=300;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=300;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod; \n\tdfs(70,0,0);cout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nmap<vector<char>,int> ma;\nvector<char> V,v[420010];\nint cnt,t[420010][36],n,m,f[71][420010],g[71][36][2],sum[71][36],ans,h[420010];\nchar s[110];\n\nvoid dfs(int nw)\n{\n\tma[V]=(++cnt),v[cnt]=V;\n\tfor (int i=(V.empty()?0:V[V.size()-1]); (i==0)+i+nw<=35; i++)\n\t\tV.push_back(i),dfs(i+nw+(i==0)),V.pop_back();\n}\n\nint main()\n{\n\tV.clear(),cnt=0,dfs(0);\n\tfor (int i=1,nw; i<=cnt; i++)\n\t{\n\t\tnw=0;\n\t\tfor (int j=0,sz=v[i].size(); j<sz; j++) nw+=(v[i][j]==0)+v[i][j];\n\t\tfor (int j=0; (j==0)+j+nw<=35; j++) \n\t\t{\n\t\t\tV=v[i],V.push_back(j),sort(V.begin(),V.end());\n\t\t\tt[i][j]=ma[V];\n\t\t}\n\t}\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tf[0][1]=1,g[0][0][0]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tg[i][0][0]=g[i-1][0][0],g[i][0][1]=0;\n\t\tfor (int j=1; j<=(i+1>>1); j++)\n\t\t\tg[i][j][0]=(g[i-1][j][0]+g[i-1][j][1])%mod,\n\t\t\tg[i][j][1]=(g[i-1][j][1]+g[i-1][j-1][0])%mod;\n\t}\n\tfor (int j=0; j<=(n+1>>1); j++)\n\t{\n\t\tsum[0][j]=0;\n\t\tfor (int i=1; i<=n; i++) sum[i][j]=(sum[i-1][j]+1ll*g[i][j][0]+g[i][j][1])%mod;\n\t}\n\tfor (int i=0; i<n; i++)\n\t\tfor (int k=1; k<=cnt; k++) if (f[i][k])\n\t\t\tfor (int nxt=(i==0?1:i+2),j=nxt; j<=n; j++)\n\t\t\t\tfor (int l=0; l<=(j-nxt+2>>1); l++)\n\t\t\t\t\tf[j][t[k][l]]=(f[j][t[k][l]]+1ll*f[i][k]*sum[j-nxt+1][l])%mod;\n\tfor (int j=1; j<=cnt; j++)\n\t\tfor (int i=0; i<=n; i++) h[j]=(h[j]+f[i][j]>=mod?h[j]+f[i][j]-mod:h[j]+f[i][j]);\n\tans=0;\n\tfor (int nw,p,i=1,nww,pp; i<=cnt; i++) if (h[i])\n\t{\n\t\tnw=0,p=v[i].size(),nww=0,pp=v[i].size();\n\t\tfor (int j=0; (p||nw)&&j<m; j++)\n\t\t\tif (s[j]=='r') \n\t\t\t{\n\t\t\t\tif (p) nw+=v[i][--p];\n\t\t\t\telse if (nww&&nw) nw--,nww--;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nw) \n\t\t\t\t{\n\t\t\t\t\tnw--;\n\t\t\t\t\tif (p<pp) nww+=max(v[i][--pp]-1,0); else nww--;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!p&&!nw) ans=(ans+h[i])%mod;\n\t}\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 107\n\nint N, K, tot, res;\nint mch[MAX_N], pos[MAX_N], sum[MAX_N];\nint fac[MAX_N * 3], ifac[MAX_N * 3];\nchar s[MAX_N];\nbool vis[MAX_N];\n\ninline int C(int x, int y) {\n    if (y < 0 || x < y) return 0;\n    return mul(fac[x], mul(ifac[y], ifac[x - y]));\n}\n\nvoid init() {\n    int MX = 300;\n    fac[0] = ifac[0] = 1;\n    Rep(i, MX) fac[i] = mul(fac[i - 1], i);\n    ifac[MX] = qpow(fac[MX], MOD - 2);\n    irep(i, MX, 2) ifac[i - 1] = mul(ifac[i], i);\n    Rep(i, K) if (s[i] == 'r') {\n        pos[++tot] = i;\n        rep(j, i + 1, K) if (s[j] == 'b' && !vis[j]) {\n            mch[i] = j;\n            vis[j] = true;\n            break;\n        }\n    }\n}\n\nint tp[MAX_N];\nbool check(int cur) {\n    if (cur > tot) return false;\n    Rep(i, N + 1) sum[i] = 0;\n    int p = 1;\n    IRep(i, cur) {\n        sum[pos[i]]++;\n        if (tp[p] > 1) {\n            if (!mch[pos[i]]) return false;\n            sum[mch[pos[i]]] += tp[p] - 1;\n        }\n        p++;\n    }\n    IRep(i, K) {\n        sum[i] += sum[i + 1];\n        if (sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\n\nbool dfs(int deg, int pre, int len) {\n    if (!check(deg - 1)) return false;\n    int t = deg;\n    Lep(i, deg) t += 2 * tp[i] - 1;\n    int ans = mul(C(N - len + t - 1, t - 1), fac[deg - 1]), tmp = 1;\n    Lep(i, deg) {\n        if (tp[i] != tp[i - 1]) {\n            ans = mul(ans, ifac[tmp]);\n            tmp = 0;\n        }\n        ++tmp;\n    }\n    ans = mul(ans, ifac[tmp]);\n    printf(\"%d:  \", ans);\n    Lep(i, deg) printf(\"%d \", tp[i]);\n    puts(\"\");\n    inc(res, ans);\n    if (deg > tot) return true;\n    rep(i, pre, 70) {\n        int L = len;\n        if (deg > 1) L++;\n        if (i == 1)\n            L++;\n        else\n            L += i - 2 + i - 1;\n        if (L > N) break;\n        tp[deg] = i;\n        if (!dfs(deg + 1, i, L)) break;\n    }\n    return true;\n}\n\nvoid solve() {\n    dfs(1, 1, 0);\n    printf(\"%d\\n\", res);\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n    FIN(\"5.in\");\n    FOUT(\"1.out\");\n#endif\n    read(N), read(K);\n    scanf(\"%s\", s + 1);\n    init();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, x, n) for(int i=x;i<=n;i++)\n#define pr make_pair\n#define fi first\n#define se second\n\nconst int MOD = int(1E9) + 7;\nconst int MAX = 420000;\nconst int HASHSIZE = 1000037;\n\ninline int add(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int sub(int x, int y) {x -= y; return x < 0 ? x + MOD : x;}\ninline int mul(int x, int y) {return (int) (1LL * x * y % MOD);}\nint mpow(int b, int p) {\n\tint r; for(r=1;p;p>>=1,b=mul(b,b))\n\t\tif( p & 1 ) r = mul(r, b);\n\treturn r;\n}\n\nstruct node{\n\tint x[40], cnt;\n\tint get() {\n\t\tint h = 0;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\th = (131LL*h + x[i]) % HASHSIZE;\n\t\treturn h;\n\t}\n\tvoid print() {\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tprintf(\"%d%c\", x[i], i + 1 == cnt ? '\\n' : ' ');\n\t}\n\tbool equal(const node &b) {\n\t\tif( cnt != b.cnt ) return false;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tif( x[i] != b.x[i] ) return false;\n\t\treturn true;\n\t}\n}st[MAX + 5];\nvector<pair<node, int> >h[HASHSIZE];\nvoid insert(node a, int i) {h[a.get()].push_back(pr(a, i));}\nint search(node a) {\n\tint x = a.get();\n\tfor(unsigned i=0;i<h[x].size();i++)\n\t\tif( a.equal(h[x][i].fi) ) return h[x][i].se;\n\treturn -1;\n}\n\nint l[75], tot, N, K;\nvoid dfs(int s, node a, int x) {\n\ttot++, insert(st[tot] = a, tot);\n\tfor(int i=x;i<=N&&l[i]<=s;i++)\n\t\ta.x[a.cnt++] = i, dfs(s - l[i], a, i), a.x[--a.cnt] = i;\n}\n\nint f[MAX + 5], fct[505], ifct[505], c[505][505];\nvoid init() {\n\trep(i, 0, 500) rep(j, 0, i)\n\t\tc[i][j] = (j == 0 ? 1 : add(c[i - 1][j], c[i - 1][j - 1]));\n\tfct[0] = 1; rep(i, 1, 500) fct[i] = mul(fct[i - 1], i);\n\tifct[500] = mpow(fct[500], MOD - 2);\n\tfor(int i=499;i>=0;i--) ifct[i] = mul(ifct[i + 1], i + 1);\n\t\n\tl[1] = 2; rep(i, 2, N) l[i] = (i - 1) << 1; dfs(N, (node){}, 1);\n\trep(i, 1, tot) {\n\t\tint a = 1, b = 0, t = 1, p = 1;\n\t\trep(j, 1, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != st[i].x[j-1] )\n\t\t\t\tt = mul(t, ifct[p]), p = 1;\n\t\t\telse p++;\n\t\t}\n\t\tt = mul(t, ifct[p]);\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tb += l[st[i].x[j]];\n\t\t\tif( st[i].x[j] != 1 ) a += 2;\n\t\t}\n\t\tf[i] = mul(mul(fct[st[i].cnt], t), c[N + a - 1][a + b - 1]);\n\t}\n//\tprintf(\"%d\\n\", tot);\n}\n\nint tg[75], q[75]; char s[75];\nint main() {\n\tscanf(\"%d%d%s\", &N, &K, s + 1), N++, init();\n\t\n\tint ans = 0;\n\trep(i, 1, tot) {\n\t\tint cnt1 = 0, pos = -1;\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != 1 ) {\n\t\t\t\tpos = j;\n\t\t\t\tbreak;\n\t\t\t} else cnt1++;\n\t\t}\n\t\t\n\t\tint hd = 1, tl = 0, p = st[i].cnt - cnt1;\n\t\trep(j, 1, K) tg[j] = -1;\n\t\tfor(int j=1;p&&j<=K;j++) {\n\t\t\tif( s[j] == 'r' ) q[++tl] = j;\n\t\t\telse if( hd <= tl ) tg[q[hd++]] = 0, tg[j] = 1, p--;\n\t\t}\n\t\t\n\t\tint cnt[2] = {}; bool flag = true;\n\t\tfor(int j=K;j>=1;j--) {\n\t\t\tif( tg[j] == -1 ) cnt[s[j] == 'r' ? 0 : 1]++;\n\t\t\telse if( tg[j] == 1 ) {\n\t\t\t\tint tmp = st[i].x[pos] - 2;\n\t\t\t\twhile( cnt[1] && tmp ) cnt[1]--, tmp--;\n\t\t\t\twhile( cnt[0] && tmp ) cnt[0]--, tmp--;\n\t\t\t\tif( tmp ) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( flag && cnt[0] >= cnt1 && p == 0 ) ans = add(ans, f[i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef std::vector <int> vector;\ntypedef long long ll;\nconst int N = 162, mod = 1000000007;\n\nint n, len, ans = 0;\nint fact[N], inv[N], finv[N], C[N][N];\nint a[N], b[N];\nvector rem[N][N];\n\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\nll PowerMod(ll a, int n, ll c = 1) {for (; n; n >>= 1, a = a * a % mod) if (n & 1) c = c * a % mod; return c;}\n\nvoid init() {\n\tint i, j;\n\tfor (inv[1] = 1, i = 2; i < N; ++i) inv[i] = ll(mod - mod / i) * inv[mod % i] % mod;\n\tfor (*C[0] = i = 1; i < N; ++i)\n\t\tfor (*C[i] = j = 1; j <= i; ++j) add(C[i][j] = C[i - 1][j], C[i - 1][j - 1]);\n}\n\nvoid dfs(int dep, int last, int cur, int n_r, int prod) {\n\tint i, s = 0, nxt = cur + 2, n_rb = dep - n_r;\n\tvector &U = rem[n_r][n_rb];\n\tif (U.empty()) return;\n\tfor (i = n_rb - 1; i >= 0; --i)\n\t\tif ((s += a[i] - 1) > U[n_rb - i]) return;\n\tans = (ans + (ll)prod * C[n + 1 + n_rb * 2][(s + n_rb * 2 + n_r) * 2]) % mod;\n\tprod = prod * (dep + 1ll) % mod;\n\tif (nxt <= n + 1)\n\t\ta[dep] = 0, b[dep] = (last ? 0 : b[dep - 1]) + 1,\n\t\tdfs(dep + 1, 0, nxt, n_r + 1, (ll)prod * inv[b[dep]] % mod);\n\tfor (i = 1; i <= last && nxt <= n + 1; ++i, nxt += 2)\n\t\ta[dep] = i, b[dep] = (i == last ? b[dep - 1] : 0) + 1,\n\t\tdfs(dep + 1, i, nxt, n_r, (ll)prod * inv[b[dep]] % mod);\n}\n\nint main() {\n\tint i, j, k, n_B, c_R, c_RB, top, stack[N], poi[N];\n\tbool used[N]; char s[N];\n\tscanf(\"%d%d%s\", &n, &len, s), init();\n\tn_B = std::count(s, s + len, 98);\n\tfor (i = 0; i <= len; ++i)\n\t\tfor (j = 0; j <= n_B; ++j) {\n\t\t\tc_R = c_RB = top = 0, memset(used, false, len);\n\t\t\tfor (k = 0; k < len && c_RB < j; ++k)\n\t\t\t\tif (s[k] == 114) stack[top++] = k;\n\t\t\t\telse if (top) used[ poi[c_RB++] = k ] = used[stack[--top]] = true;\n\t\t\tfor (k = 0; k < len && c_R < i; ++k)\n\t\t\t\tif (!used[k] && s[k] == 114) ++c_R, used[k] = true;\n\t\t\tif (c_RB < j || c_R < i) continue;\n\t\t\tvector &res = rem[i][j];\n\t\t\tres.reserve(j + 1), res.EB(0);\n\t\t\tfor (top = 0, k = len - 1; k >= 0 && c_RB; --k)\n\t\t\t\tif (top += !used[k], k == poi[c_RB - 1]) res.EB(top), --c_RB;\n\t\t\tassert((int)res.size() == j + 1);\n\t\t}\n\tdfs(0, INT_MAX, 0, 0, 1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ri register int\nconst int N=75,mod=1e9+7;\nint n,k,a[N],use[N],posr[N],posb[N],fac[N],ifac[N],c[N*3][N*3],Ans;\nchar s[N];\ninline int fpow(ri a,ri b){\n\tri ans=1;\n\tfor(;b;b>>=1,a=(ll)a*a%mod)\n\t\tif(b&1) ans=(ll)ans*a%mod;\n\treturn ans;\n}\ninline void add(int &x,ri y){\n\tx=(x+=y)>=mod?x-mod:x; \n}\ninline int C(ri n,ri m){\n\treturn m<0||n<m?0:c[n][m];\n}\ninline void solve(ri cnt){\n\tri i,now,res;\n\tfor(i=1;i<=k;++i) use[i]=0;\n\tfor(i=1;i<=cnt;++i) posr[i]=posb[i]=0;\n\tnow=0;\n\tfor(i=1;i<=k&&now<cnt;++i)\n\t\tif(s[i]=='r') use[i]=1,posr[++now]=i;\n\tif(now<cnt) return;\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=2;++i){\n\t\tfor(now=max(now,posr[i]+1);now<=k&&s[now]!='b';++now);\n\t\tif(now>k) return;\n\t\tposb[i]=now;\n\t\tuse[now]=1;\n\t\t++now;\n\t}\n\tnow=0;\n\tfor(i=1;i<=cnt&&a[i]>=3;++i){\n\t\tres=a[i]-2;\n\t\tfor(now=max(now,posb[i]+1);now<=k&&res;++now)\n\t\t\tif(!use[now])\n\t\t\t\tuse[now]=1,--res;\n\t\tif(res) return;\n\t}\n\t\n\tri j,ans=fac[cnt],c1,c2;\n\tfor(i=1;i<=cnt;i=j+1){\n\t\tfor(j=i;j+1<=cnt&&a[j+1]==a[i];++j);\n\t\tans=(ll)ans*ifac[j-i+1]%mod;\n\t}\n\tc1=n+1;\n\tc2=0;\n\tfor(i=1;i<=cnt;++i){\n\t\tif(a[i]>=2)\n\t\t\tc1+=2;\n\t\tc2+=a[i]*2;\n\t} \n\tans=(ll)ans*C(c1,c2)%mod; \n\tadd(Ans,ans);\n}\ninline void dfs(ri i,ri sum){\n\tif(i>1) solve(i-1);\n\tfor(ri j=a[i-1];j;--j)\n\t\tif(sum+j*2-(j>=2?2:0)<=n+1)\n\t\t\ta[i]=j,\n\t\t\tdfs(i+1,sum+j*2-(j>=2?2:0));\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tri i,j,m;\n\tfac[0]=1;\n\tfor(i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod;\n\tifac[n]=fpow(fac[n],mod-2);\n\tfor(i=n;i;--i) ifac[i-1]=(ll)ifac[i]*i%mod;\n\tm=3*n+1;\n\tfor(i=0;i<=m;++i){\n\t\tc[i][0]=1;\n\t\tfor(j=1;j<=i;++j)\n\t\t\tc[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;\n\t}\n\ta[0]=m;Ans=1;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 301, mod = 1000000007;\nint n, k, ans = 0;\nchar s[N];\nint fac[N], inv[N];\n\nint f[N], m = 0, r[N], b[N], visit[N];\ninline void solve() {\n  for (int i = 1; i <= k; i++) visit[i] = 0;\n  for (int i = 1, j = 1; i <= m; i++, j++) {\n    while (j <= k && s[j] != 'r') j++;\n    if (j > k) return;\n    r[i] = j;\n    visit[j] = 1;\n  }\n  for (int i = 1, j = 1; i <= m; i++, j++) if (f[i] >= 2) {\n    j = max(j, r[i]);\n    while (j <= k && s[j] != 'b') j++;\n    if (j > k) return;\n    b[i] = j;\n    visit[j] = 1;\n  }\n  for (int i = 1, j = 1; i <= m; i++, j++) if (f[i] >= 3) {\n    int x = f[i] - 2;\n    j = max(j, b[i]);\n    while (x--) {\n      while (j <= k && visit[j]) j++;\n      if (j > k) return;\n      visit[j] = 1;\n      j++;\n    }\n  }\n  int coef = fac[m];\n  for (int i = 1, j = 0; i <= m; i++) {\n    j = f[i] != f[i - 1] ? 1 : j + 1;\n    coef = (ll) coef * fac[j - 1] % mod * inv[j] % mod;\n  }\n  int upper = n + 1, lower = 0;\n  for (int i = 1; i <= m; i++) {\n    if (f[i] >= 2) upper += 2;\n    lower += f[i] * 2;\n  }\n  if (upper < lower) return;\n  coef = (ll) coef * fac[upper] % mod * inv[lower] % mod * inv[upper - lower] % mod;\n  ans = (ans + coef) % mod;\n}\nvoid dfs(int x, int last) {\n  solve();\n  for (int i = last; i; i--) {\n    int y = (i == 1 ? 1 : 2 * i - 3) + 1;\n    if (x >= y) {\n      f[++m] = i;\n      dfs(x - y, i);\n      --m;\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d%d%s\", &n, &k, s + 1);\n  fac[0] = fac[1] = 1;\n  inv[0] = inv[1] = 1;\n  for (int i = 2; i < N; i++) {\n    fac[i] = (ll) fac[i - 1] * i % mod;\n    inv[i] = mod - (ll) mod / i * inv[mod % i] % mod;\n  }\n  for (int i = 2; i < N; i++) {\n    inv[i] = (ll) inv[i] * inv[i - 1] % mod;\n  }\n  dfs(n + 1, n + 1);\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 75;\n\ninline int qPow(int b, int e) {\n\tint a = 1;\n\tfor (; e; e >>= 1, b = (LL)b * b % Mod)\n\t\tif (e & 1) a = (LL)a * b % Mod;\n\treturn a;\n}\n\nint Fac[100005], iFac[100005];\ninline void Init(int N) {\n\tFac[0] = 1;\n\tfor (int i = 1; i <= N; ++i) Fac[i] = (LL)Fac[i - 1] * i % Mod;\n\tiFac[N] = qPow(Fac[N], Mod - 2);\n\tfor (int i = N; i >= 1; --i) iFac[i - 1] = (LL)iFac[i] * i % Mod;\n}\n\nint Len;\nchar Str[MN];\nint posr[MN], nxposb[MN], rcnt;\n\nint N, Ans;\n\nint stk[MN];\ninline void Calc(int cnt, int csum) {\n\tint Sum = 0;\n\tif (!cnt) Sum = 1;\n\telse if (cnt <= rcnt) {\n\t\tstatic int vis[MN];\n\t\tfor (int i = 1; i <= cnt; ++i) vis[i] = posr[i];\n\t\tint tot = cnt, mxp = 1;\n\t\tfor (int i = 1; i <= cnt && stk[i] >= 2; ++i)\n\t\t\tmxp = vis[++tot] = nxposb[std::max(mxp, vis[i])];\n\t\tif (mxp <= Len) {\n\t\t\tstd::inplace_merge(vis + 1, vis + cnt + 1, vis + tot + 1);\n\t\t\tint nwp = Len + 1, sum = 0, now = cnt, ok = 1;\n\t\t\twhile (now && stk[now] == 1) --now;\n\t\t\tfor (int i = tot; i >= 1; --i) {\n\t\t\t\tsum += nwp - vis[i] - 1;\n\t\t\t\tif (Str[vis[i]] == 'b') {\n\t\t\t\t\tsum -= stk[now] - 2;\n\t\t\t\t\tif (sum < 0) { ok = 0; break; }\n\t\t\t\t\t--now;\n\t\t\t\t}\n\t\t\t\tnwp = vis[i];\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tSum = Fac[cnt];\n\t\t\t\tint len = 0, num = 1;\n\t\t\t\tfor (int i = 1; i <= cnt; ++i) {\n\t\t\t\t\t++len;\n\t\t\t\t\tnum += stk[i] * 2;\n\t\t\t\t\tif (i == cnt || stk[i] != stk[i + 1]) {\n\t\t\t\t\t\tSum = (LL)Sum * iFac[len] % Mod;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSum = (LL)Sum * Fac[N - csum + num] % Mod * iFac[num - 1] % Mod * iFac[N - csum + 1] % Mod;\n\t\t\t}\n\t\t}\n\t}\n\tAns -= (Ans += Sum) >= Mod ? Mod : 0;\n}\nvoid DFS(int st, int mx, int sum) {\n\tCalc(st - 1, sum);\n\tif (sum < N) {\n\t\tstk[st] = 1;\n\t\tDFS(st + 1, 1, sum + 2);\n\t}\n\tfor (int i = 2; i <= mx; ++i) {\n\t\tif (sum + i * 2 <= N + 3) {\n\t\t\tstk[st] = i;\n\t\t\tDFS(st + 1, i, sum + i * 2 - 2);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &Len, Str + 1);\n\tInit(100000);\n\tfor (int i = 1; i <= Len; ++i)\n\t\tif (Str[i] == 'r')\n\t\t\tposr[++rcnt] = i;\n\tint nwposb = Len + 1;\n\tnxposb[Len + 1] = Len + 1;\n\tfor (int i = Len; i >= 1; --i) {\n\t\tnxposb[i] = nwposb;\n\t\tif (Str[i] == 'b')\n\t\t\tnwposb = i;\n\t}\n\tDFS(1, (N + 3) / 2, 0);\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=1e9+7;\nconst int maxn=210;\nlong long fac[maxn],inv[maxn];\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nchar str[maxn];\nint stk[maxn],top;\nint n,m;\nbool check(int x){\n\tstatic bool vis[maxn];\n\tfor(int i=1;i<=m;i++)\n\t\tvis[i]=0;\n\tint p=0,cnt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(cnt>=top) break;\n\t\tif(str[i]=='r'){\n\t\t\tif(p<i) p=i;\n\t\t\twhile(p<=m&&(vis[p]||str[p]=='r'))\n\t\t\t\tp++;\n\t\t\tif(p>m) return 0;\n\t\t\tcnt++;\n\t\t\tvis[i]=vis[p]=1;\n\t\t}\n\t}\n\tif(cnt!=top) return 0;\n\tcnt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(cnt>=x) break;\n\t\tif(str[i]=='r'&&!vis[i]){\n\t\t\tvis[i]=1;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt!=x) return 0;\n\tp=m;\n\tfor(int i=top;i>=1;i--){\n\t\tcnt=0;\n\t\twhile(p>=1&&cnt<stk[i]/2){\n\t\t\tif(!vis[p]) cnt++;\n\t\t\tp--;\n\t\t}\n\t\tif(cnt!=stk[i]/2) return 0;\n\t}\n//\tprintf(\"top=%d\\n\",top);\n//\tfor(int i=1;i<=top;i++)\n//\t\tprintf(\"%d \",stk[i]);\n//\tprintf(\"\\n\");\n\treturn 1;\n}\nlong long sum[maxn][maxn];\nvoid solve(int res,long long val,int num){\n\tlong long fas;\n\tint tot=0;\n\tfor(int i=1;i<=top;i++) tot+=stk[i];\n\tfor(int i=0;i<=res;i++){\n\t\tif(tot+top+i*2>n) break;\n\t\tif(!check(i)) break;\n\t\tfas=fac[num+i]*val%md*inv[i]%md;\n\t\t(sum[tot+top+i*2][top]+=fas)%=md;\n//\t\tprintf(\"%d %d\\n\",tot+top+i*2,top);\n\t}\n}\nvoid dfs(int res,int las,long long val,int num){\n\tsolve(res,val,num);\n\tres--;\n\tint ttp;\n\tfor(int i=1;i<=res&&i<=las;i+=2){\n\t\tttp=top;\n\t\tfor(int j=1;res-i*j>=0;j++){\n\t\t\tstk[++top]=i;\n\t\t\tdfs(res-i*j,i-1,val*inv[j]%md,num+j);\n\t\t}\n\t\ttop=ttp;\n\t}\n}\nlong long C[maxn][maxn];\nint main(){\n//\tfreopen(\"F.in\",\"r\",stdin);\n\tfac[0]=1;\n\tfor(int i=1;i<=70;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[70]=powd(fac[70],md-2);\n\tfor(int i=70;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tC[0][0]=C[1][0]=C[1][1]=1;\n\tfor(int i=2;i<=71;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%md;\n\t}\n\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\tdfs(n+1,n,1,0);\n\tlong long ans=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(!sum[i][j]) continue;\n\t\t\tfor(int k=0;k<=j*2;k++){\n\t\t\t\tif(i+k<=n+1)\n\t\t\t\t\tans=(ans+C[n+1][i+k]*C[j*2][k]%md*sum[i][j])%md;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\n\nvoid calc(int sz) {\n    int tb = 0, tr = 0;\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && ch[tb] != 'b') tb++;\n        }\n        if(tr > K || tb > K) return;\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i);\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,q;\nstring str;\nll pattern[75][75][40];\nll patall[75][40];\nll dp[75][75][75];\n\nint lefr[75];\nint lefb[75][75];\n\nint getr(int v){\n\tif(lefr[v]!=-1)return lefr[v];\n\tint nv=v;\n\twhile(nv<q && str[nv]!='r')nv++;\n\treturn (lefr[v]=nv);\n}\n\nint getb(int v,int c){\n\tif(lefb[v][c]!=-1)return lefb[v][c];\n\tint cnt=0;\n\tint nv=v;\n\twhile(nv<q){\n\t\tif(str[nv]=='b')cnt++;\n\t\tif(cnt==c)break;\n\t\tnv++;\n\t}\n\treturn (lefb[v][c]=nv);\n}\n\n\nint main(void){\n\tfor(int i=1;i<=70;i++){\n\t\tpattern[i][0][0]=1;\n\t}\n\tfor(int k=0;k<=38;k++){\n\t\tfor(int i=0;i<=70;i++){\n\t\t\tfor(int j=0;j<=i+1;j++){\n\t\t\t\tpatall[i][k]+=(ll)pattern[i][j][k]%MOD;\n\t\t\t\tpatall[i][k]%=MOD;\n\t\t\t\tfor(int l=j;l<i;l++){\n\t\t\t\t\tfor(int m=l+1;m<=i;m++){\n\t\t\t\t\t\tpattern[i][m+1][k+1]+=pattern[i][j][k];\n\t\t\t\t\t\tpattern[i][m+1][k+1]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\tfor(int i=0;i<=70;i++){\n\t\tfor(int j=0;j<=38;j++){\n\t\t\tprintf(\"%lld \",patall[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tmemset(lefr,-1,sizeof(lefr));\n\tmemset(lefb,-1,sizeof(lefb));\n\tscanf(\"%d%d\",&n,&q);\n\tcin >> str;\n\tint prevs=0,nows=1;\n\tdp[0][0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<=q;j++){\n\t\t\tfor(int k=0;k<=q;k++){\n\t\t\t\t//if(dp[i][j][k]>0)printf(\"%d %d %d %lld\\n\",i,j,k,dp[i][j][k]);\n\t\t\t\tdp[i+1][j][k]+=dp[i][j][k];\n\t\t\t\tdp[i+1][j][k]%=MOD;\n\t\t\t\tfor(int l=1;l+i<=n;l++){\n\t\t\t\t\tfor(int m=0;m<=(l+1)/2;m++){\n\t\t\t\t\t\tint gr=getr(j);\n\t\t\t\t\t\tint gb=getb(max(k,gr),m);\n\t\t\t\t\t\tif(m==0)gb=max(k-1,gr);\n\t\t\t\t\t\tif(gr!=q && gb!=q){\n\t\t\t\t\t\t\tdp[i+l+1][gr+1][gb+1]+=dp[i][j][k]*patall[l][m]%MOD;\n\t\t\t\t\t\t\tdp[i+l+1][gr+1][gb+1]%=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=q;i++){\n\t\tfor(int j=0;j<=q;j++){\n\t\t\tans=(ans+dp[n][i][j])%MOD;\n\t\t\tans=(ans+dp[n+1][i][j])%MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[80];\nint n, K, chk[80], Loc[40], C[40], F[150], InvF[150], Mod = 1000000007;\nint D[40][40], TD[40][40]; // 한 블럭의 크기, 블럭의 개수, 쓴거의 개수\n\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint Comb(int n, int r) {\n\treturn 1ll * F[n] * InvF[r] % Mod*InvF[n - r]%Mod;\n}\nint Do(int A, int B) { // R* : A, RBxx : B\n\tint i, c1 = 0, c2 = 0, j, k, ii, jj;\n\tfor (i = 0; i < K; i++) {\n\t\tchk[i] = 0;\n\t\tif (p[i] == 'r' && c1 < B) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t\tif (p[i] == 'b' && c2 < c1) {\n\t\t\tchk[i] = 1;\n\t\t\tc2++;\n\t\t\tLoc[c2] = i;\n\t\t}\n\t}\n\tif (c1 < B || c2 < B)return 0;\n\tc1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tif (p[i] == 'r' && !chk[i] && c1 < A) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t}\n\tif (c1 < A)return 0;\n\tfor (i = 1; i <= B; i++) {\n\t\tC[B-i+1] = 0;\n\t\tfor (j = Loc[i]; j < K; j++)if (!chk[j])C[B-i+1]++;\n\t}\n\tfor (i = 0; i < 40; i++)for (j = 0; j < 40; j++)D[i][j] = TD[i][j] = 0;\n\tD[0][0] = InvF[A];\n\n\tfor (i = 0; i <= n / 2; i++) {\n\t\tfor (j = 0; j < 40; j++) {\n\t\t\tfor (k = 0; k < 40; k++) {\n\t\t\t\tif (!D[j][k])continue;\n\t\t\t\tfor (ii = 0;; ii++) {\n\t\t\t\t\tint s = (ii*i + k);\n\t\t\t\t\tif (ii+j > B || s * 2 + A + B + (A + B - 1) > n || C[j+ii] < s)break;\n\t\t\t\t\tTD[j + ii][s] = (TD[j + ii][s] + 1ll * D[j][k] * InvF[ii]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 40; j++)for (k = 0; k < 40; k++) {\n\t\t\tD[j][k] = TD[j][k];\n\t\t\tTD[j][k] = 0;\n\t\t}\n\t}\n\tint r = 0;\n\tfor (i = 0; i < 40; i++) {\n\t\tint c = (A + B + A + B - 1 + i * 2);\n\t\tint t = c + B * 2 + 2;\n\t\tif (!D[B][i] || n-c < 0)continue;\n\t\tr = (r + 1ll * D[B][i] * F[A+B] % Mod * Comb(t + (n - c) - 1, (n - c)))%Mod;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, res = 0;\n\tF[0] = 1;\n\tfor (i = 1; i <= 140; i++)F[i] = 1ll * F[i - 1] * i%Mod;\n\tfor (i = 0; i <= 140; i++)InvF[i] = Pow(F[i], Mod - 2);\n\tscanf(\"%d%d\", &n, &K);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i <= (n+1)/2; i++) {\n\t\tfor (j = 0; i + j <= (n + 1) / 2; j++) {\n\t\t\tres = (res + Do(i, j))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 75\n#define rep(i,j,k) for(int i=(j),LIM=(k);i<=LIM;i++)\n#define per(i,j,k) for(int i=(j),LIM=(k);i>=LIM;i--)\n#define mod 1000000007\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\n\nint n,K,fac[maxn << 2],invf[maxn << 2],inv[maxn << 2];\nint C(int a,int b){ if(a<0 || b<0 || a-b<0) return 0;return fac[a] * 1ll * invf[b] % mod * invf[a-b]%mod; }\nchar s[maxn];\nvi p;int ans;\n\nbool check(){\n\tstatic bool vis[maxn];\n\tstatic int loc[maxn];\n\tmemset(vis,0,sizeof vis);\n\tint j=1;\n\tfor(int i=p.size()-1;i>=0 && p[i];i--){\n\t\tfor(;j <= K && s[j] != 'r';j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , loc[i] = j , j++;\n\t}\n\tj=1;\n\tfor(int i=p.size()-1;i>=0 && p[i];i--){\n\t\tj = max(j , loc[i]);\n\t\tfor(;j <= K && s[j] != 'b';j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , loc[i] = j , j++;\n\t}\n\tj=1;\n\tfor(int i=0;i<p.size() && p[i]==0;i++){\n\t\tfor(;j <= K && (s[j] != 'r' || vis[j]);j++);\n\t\tif(j > K) return 0;\n\t\tvis[j] = 1 , j++;\n\t}\n\tj=1;\n\tfor(int i=p.size()-1;i>=0 && p[i] > 1;i--){\n\t\tj = max(j , loc[i]);\n\t\trep(k,2,p[i]){\n\t\t\tfor(;j <= K && vis[j];j++);\n\t\t\tif(j > K) return 0;\n\t\t\tvis[j] = 1 , j++;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid dfs(int sz,int mx,int lim){\n\tif(sz > n) return;\n\tif(check()){\n\t\tint sm = fac[p.size()];\n\t\tfor(int i=0,j;i<p.size();i=j){\n\t\t\tfor(j=i;j<p.size() && p[j] == p[i];j++);\n\t\t\tsm = 1ll * sm * invf[j-i] % mod;\n\t\t}\n\t\tans = (ans + 1ll * C(n-sz+mx-1,mx-1) * sm) % mod;\n\t\t//printf(\"%d %d %d %d\\n\",sm,ans,sz,mx);\n\t}\n\telse return;\n\trep(i,lim,(n-sz+1)/2){\n\t\tp.pb(i);\n\t\tdfs(sz+max(2*i-1,1)+(sz!=0),mx+2*i+2,i);\n\t\tp.pop_back();\n\t}\n}\n\nint main(){//freopen(\"1.in\",\"r\",stdin);//freopen(\"2.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&K);\n\tscanf(\"%s\",s+1);\n\tfac[0] = inv[0] = inv[1] = fac[1] = invf[0] = invf[1] = 1;\n\trep(i,2,(maxn << 2) - 1) fac[i] = 1ll * fac[i-1] * i % mod , inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod,\n\t\tinvf[i] = 1ll * invf[i-1] * inv[i] % mod;\n\tdfs(0,1,0);\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\ntypedef long long ll;\n\nconst int P=1000000007;\nint n,K,Ans,a[75],Fac[305],Inv[305];\nchar s[75];\n\ninline int C(int n,int m){return (ll)Fac[n]*Inv[m]%P*Inv[n-m]%P;}\n\nvoid Check(int num,int sum)\n{\n    int pos=num+1,res=Fac[num],rnum=0,leftr=0,nxt=0,left=0;\n    for(int i=1;i<=K;++i)\n        if(s[i]=='r') rnum<num?leftr+=(a[++rnum]>1):(left?--left:0);\n        else leftr?(--leftr,left+=a[++nxt]-2):(left?--left:0);\n    if(left||rnum<num||leftr) return;\n    for(int i=1,j;i<=num;i=j+1)\n    {\n        for(j=i;j<num&&a[j+1]==a[i];++j);\n        res=1LL*res*Inv[j-i+1]%P;\n        pos+=(j-i+1)*(a[i]*2-1);\n    }\n    Ans=(Ans+1LL*res*C(n-sum+pos-1,pos-1))%P;\n}\nvoid DFS(int x,int num,int sum)\n{\n    if(sum>n) return;Check(num,sum);\n    for(int i=x;i;--i) a[num+1]=i,DFS(i,num+1,sum+(i>1?i*2-3:1)+(num>0));\n}\n\nint main()\n{\n    scanf(\"%d%d%s\",&n,&K,s+1),Fac[0]=Inv[0]=Fac[1]=Inv[1]=1;\n    for(int i=2;i<=300;++i)Fac[i]=(ll)Fac[i-1]*i%P,Inv[i]=ll(P-P/i)*Inv[P%i]%P;\n    for(int i=2;i<=300;++i)Inv[i]=(ll)Inv[i-1]*Inv[i]%P;\n    return DFS(70,0,0),printf(\"%d\\n\",Ans),0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=75,Mo=1e9+7;\n\nint n,k,t,f[N],C[N*3][N*3],ans;\nchar st[N];\n\nvoid calc() {\n\tint sum=0,tr=t,tb=t;\n\tfo(i,1,k) {\n\t\tif (st[i]=='r'&&tr) tr--;\n\t\telse if (st[i]=='b'&&f[tb]>1&&tb>tr) sum+=f[tb]-2,tb--;\n\t\telse if (sum) sum--;\n\t}\n\twhile (f[tb]==1) tb--;\n\tif (tr||tb||sum) return;\n\n\tint ret=1;\n\tfor(int l=1,r=0;l<=t;l=r+1) {\n\t\twhile (r<t&&f[r+1]==f[l]) r++;\n\t\tret=(ll)ret*C[r][r-l+1]%Mo;\n\t}\n\n\tint cnt=0,ulm=0;\n\tfo(i,1,t) {\n\t\tcnt+=(f[i]==1?1:f[i]*2-3)+1;\n\t\tulm+=(f[i]==1?1:f[i]*2-3)+1;\n\t\tulm+=2*(f[i]>1);\n\t}\n\tcnt--;ulm++;\n\t(ans+=(ll)ret*C[n-cnt+ulm-1][ulm-1]%Mo)%=Mo;\n\t//fo(i,1,t) printf(\"%d \",f[i]);printf(\"%d\\n\",ans);\n}\n\nvoid dfs(int x,int y,int la) {\n\tcalc();\n\t++t;\n\tif (la==1&&x+2<=n+1&&y+1<=k) {\n\t\tf[t]=1;\n\t\tdfs(x+2,y+1,1);\n\t}\n\tfor(int i=max(la,2);;i++) {\n\t\tif (y+i>k) break;\n\t\tif (x+2*i-2>n+1) break;\n\t\tf[t]=i;\n\t\tdfs(x+2*i-2,y+i,i);\n\t}\n\tt--;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&k);\n\tfo(i,0,n*3) {\n\t\tC[i][0]=1;\n\t\tfo(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%Mo;\n\t}\n\tscanf(\"%s\",st+1);\n\tdfs(0,0,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[80];\nint n, K, chk[80], Loc[36], C[36], F[150], InvF[150], Mod = 1000000007;\nint D[36][36], TD[36][36]; // 한 블럭의 크기, 블럭의 개수, 쓴거의 개수\n\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint Comb(int n, int r) {\n\treturn 1ll * F[n] * InvF[r] % Mod*InvF[n - r]%Mod;\n}\n\nint Do(int A, int B) { // R* : A, RBxx : B\n\tint i, c1 = 0, c2 = 0, j, k, ii, jj;\n\tif (!A && !B)return 1;\n\tfor (i = 0; i < K; i++) {\n\t\tchk[i] = 0;\n\t\tif (p[i] == 'r' && c1 < B) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t\tif (p[i] == 'b' && c2 < c1) {\n\t\t\tchk[i] = 1;\n\t\t\tc2++;\n\t\t\tLoc[c2] = i;\n\t\t}\n\t}\n\tif (c1 < B || c2 < B)return 0;\n\tc1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tif (p[i] == 'r' && !chk[i] && c1 < A) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t}\n\tif (c1 < A)return 0;\n\tfor (i = 1; i <= B; i++) {\n\t\tC[B-i+1] = 0;\n\t\tfor (j = Loc[i]; j < K; j++)if (!chk[j])C[B-i+1]++;\n\t}\n\tfor (i = 0; i < 36; i++)for (j = 0; j < 36; j++)D[i][j] = TD[i][j] = 0;\n\tD[0][0] = InvF[A];\n\n\tfor (i = 0; i <= n / 2; i++) {\n\t\tfor (j = 0; j < 36; j++) {\n\t\t\tfor (k = 0; k < 36; k++) {\n\t\t\t\tif (!D[j][k])continue;\n\t\t\t\tfor (ii = 0;; ii++) {\n\t\t\t\t\tint s = (ii*i + k);\n\t\t\t\t\tif (ii+j > B || s * 2 + A + B + (A + B - 1) > n || C[j+ii] < s)break;\n\t\t\t\t\tTD[j + ii][s] = (TD[j + ii][s] + 1ll * D[j][k] * InvF[ii]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 36; j++)for (k = 0; k < 36; k++) {\n\t\t\tD[j][k] = TD[j][k];\n\t\t\tTD[j][k] = 0;\n\t\t}\n\t}\n\tint r = 0;\n\tfor (i = 0; i < 36; i++) {\n\t\tint c = (A + B + A + B - 1 + i * 2);\n\t\tint t = c + B * 2 + 2;\n\t\tif (!D[B][i] || n-c < 0)continue;\n\t\tr = (r + 1ll * D[B][i] * F[A+B] % Mod * Comb(t + (n - c) - 1, (n - c)))%Mod;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, res = 0;\n\tF[0] = 1;\n\tfor (i = 1; i <= 142; i++)F[i] = 1ll * F[i - 1] * i%Mod;\n\tfor (i = 0; i <= 142; i++)InvF[i] = Pow(F[i], Mod - 2);\n\tscanf(\"%d%d\", &n, &K);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i <= (n+1)/2; i++) {\n\t\tfor (j = 0; i + j <= (n + 1) / 2; j++) {\n\t\t\tres = (res + Do(i, j))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int MX = 200;\nll inv[MX], fact[MX], ifact[MX];\n\nvoid init() {\n    inv[1] = 1;\n    for (int i = 2; i < MX; ++i) {\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = ifact[0] = 1;\n    for (int i = 1; i < MX; ++i) {\n        fact[i] = fact[i-1] * i % MOD;\n        ifact[i] = ifact[i-1] * inv[i] % MOD;\n    }\n}\n\nll comb(int n, int r) {\n    if (n < 0 || r < 0 || r > n) return 0;\n    return fact[n] * ifact[r] % MOD * ifact[n - r] % MOD;\n}\n\nint N, K;\nstring s;\nll ans;\n\nint cnt = 0;\nvoid calc(V<int>& vec) { //based on blue\n\tif (vec.empty()) {\n\t\tans = (ans + 1) % MOD;\n\t\treturn ;\n\t}\n\n\tint sz = vec.size();\n\n\tV<int> us(K);\n\tV<int> piv(sz);\n\n\tint now = 0;\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\twhile (now < K && s[now] == 'b') {\n\t\t\t++now;\n\t\t}\n\t\tif (now < K) {\n\t\t\tpiv[i] = now;\n\t\t\tus[now] = 1;\n\t\t\tnow++;\n\t\t} else {\n\t\t\treturn ;\n\t\t}\n\t}\n\n\tnow = 0;\n\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\tif (x >= 2) {\n\t\t\tchmax(now, piv[i] + 1);\n\t\t\twhile (now < K && s[now] == 'r') {\n\t\t\t\t++now;\n\t\t\t}\n\t\t\tif (now < K) {\n\t\t\t\tpiv[i] = now;\n\t\t\t\tus[now] = 1;\n\t\t\t\tnow++;\n\t\t\t} else {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\n\tnow = 0;\n\n\tfor (int i = sz - 1; i >= 0; --i) {\n\t\tint x = vec[i];\n\t\tif (x >= 3) {\n\t\t\tx -= 2;\n\t\t\tchmax(now, piv[i] + 1);\n\t\t\trep(t, x) {\n\t\t\t\twhile (now < K && us[now]) {\n\t\t\t\t\t++now;\n\t\t\t\t}\n\t\t\t\tif (now < K) {\n\t\t\t\t\tus[now] = 1;\n\t\t\t\t\tnow++;\n\t\t\t\t} else {\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint need = sz - 1;\n\tint bs = 0;\n\n\tfor (int x : vec) {\n\t\tif (x == 1) {\n\t\t\t++need;\n\t\t} else {\n\t\t\t++bs;\n\t\t\tneed += x * 2 - 3;\n\t\t}\n\t}\n\n\tif (need > N) {\n\t\treturn ;\n\t}\n\n\tll coef = fact[sz];\n\t{\n\n\t\trep(i, sz) {\n\t\t\tif (i == 0 || vec[i] != vec[i-1]) {\n\t\t\t\tint c = 0;\n\t\t\t\tfor (int j = i; j < sz; ++j) {\n\t\t\t\t\tif (vec[j] == vec[i]) {\n\t\t\t\t\t\t++c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcoef = coef * ifact[c] % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\t//dump(vec);\n\t//dump(need);\n\n\tcoef = coef * comb(N - need + (need + 1 + bs * 2), need + 1 + bs * 2);\n\n\tans = (ans + coef) % MOD;\n\t++cnt;\n}\n\nvoid gen(int p, int s, V<int>& vec) {\n\tif (p == K + 1 || s + p + vec.size() > N) {\n\t\tcalc(vec);\n\t\treturn ;\n\t}\n\n\tgen(p + 1, s, vec);\n\n\tfor (; ; ) {\n\t\tif (p == 1) {\n\t\t\t++s;\n\t\t} else {\n\t\t\ts += p * 2 - 3;\n\t\t}\n\t\tif (s + vec.size() > N) {\n\t\t\tbreak;\n\t\t}\n\t\tvec.pb(p);\t\t\n\t\tgen(p + 1, s, vec);\n\t}\n\twhile (vec.size() && vec.back() == p) {\n\t\tvec.pop_back();\n\t}\n}\n\nint main() {\n\tinit();\n\n\tcin >> N >> K >> s;\n\t{\n\t\tV<int> vec;\n\t\tgen(1, 0, vec);\n\t}\n\t//dump(cnt);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n\nstring str;\nll comb[301][301];\nint n,k;\nint group[81];\nint assign[81];\nbool used[81];\nll dp2[101][101];\nll ans;\n\nbool isvalid(int v){\n\tint len=0;\n\tfor(int i=0;i<v;i++){\n\t\tif(i!=0)len++;\n\t\tif(group[i]==1){\n\t\t\tlen++;\n\t\t}else{\n\t\t\tlen+=group[i]*2-3;\n\t\t}\n\t}\n\tif(len>n)return false;\n\tmemset(assign,0,sizeof(assign));\n\tmemset(used,false,sizeof(used));\n\tint cnt=0;\n\tfor(int i=0;i<k;i++){\n\t\tif(cnt==v)break;\n\t\tif(str[i]=='r'){\n\t\t\tassign[cnt++]=i;\n\t\t\tused[i]=true;\n\t\t}\n\t}\n\tif(cnt<v)return false;\n\tfor(int i=0;i<v;i++){\n\t\tif(group[i]>=2){\n\t\t\tbool flag=false;\n\t\t\tfor(int j=assign[i]+1;j<k;j++){\n\t\t\t\tif(str[j]=='b' && !used[j]){\n\t\t\t\t\tassign[i]=j;\n\t\t\t\t\tused[j]=true;\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)return false;\n\t\t}\n\t}\n\tfor(int i=0;i<v;i++){\n\t\tif(group[i]>=3){\n\t\t\tint rest=group[i]-2;\n\t\t\tfor(int j=assign[i]+1;j<k;j++){\n\t\t\t\tif(!used[j]){\n\t\t\t\t\tused[j]=true;\n\t\t\t\t\trest--;\n\t\t\t\t}\n\t\t\t\tif(rest==0)break;\n\t\t\t}\n\t\t\tif(rest!=0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nll dp[2][71];\n\nvoid dfs(int v,int now){\n\tif(v>0){\n\t\tif(!isvalid(v))return;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint cur=0,nxt=1;\n\t\tdp[cur][v-1]=1;\n\t\tfor(int i=0;i<v;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(group[i]==1){\n\t\t\t\t\tif(j+1<=n){\n\t\t\t\t\t\tdp[nxt][j+1]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+1]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tint pl=(group[i]-1)*2-1;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\tpl=(group[i]-1)*2;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j]*2LL;\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\tpl=(group[i]-1)*2+1;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur,nxt);\n\t\t\tmemset(dp[nxt],0,sizeof(dp[nxt]));\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<v;i++){\n\t\t\tprintf(\"%d \",group[i]);\n\t\t}\n\t\tprintf(\"ok\\n\");\n\t\t*/\n\t\tll pw=1;\n\t\tint len=1,rest=v;\n\t\tfor(int i=1;i<v;i++){\n\t\t\tif(group[i]==group[i-1]){\n\t\t\t\tlen++;\n\t\t\t}else{\n\t\t\t\tpw=pw*comb[rest][len]%MOD;\n\t\t\t\trest-=len;\n\t\t\t\tlen=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tll va=(dp[cur][i]*pw)%MOD;\n\t\t\t//printf(\"%lld \",dp[cur][i]);\n\t\t\tva=va*dp2[i+2][n-i]%MOD;\n\t\t\tans+=va;\n\t\t\tans%=MOD;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t//printf(\"%lld %lld\\n\",pw,ans);\n\t}\n\tfor(int i=1;i<=now;i++){\n\t\tgroup[v]=i;\n\t\tdfs(v+1,i);\n\t}\n}\n\nint main(void){\n\tcomb[0][0]=1;\n\tfor(int i=1;i<=300;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tcomb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n\t\t}\n\t\tcomb[i][0]=1;\n\t\tcomb[i][i]=1;\n\t}\n\tdp2[1][0]=1;\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tdp2[i+1][j]+=dp2[i][j];\n\t\t\tdp2[i+1][j]%=MOD;\n\t\t\tdp2[i][j+1]+=dp2[i][j];\n\t\t\tdp2[i][j+1]%=MOD;\n\t\t}\n\t}\n\tscanf(\"%d%d\",&n,&k);\n\tcin >> str;\n\tdfs(0,38);\n\tprintf(\"%lld\\n\",(ans+1LL)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,x,n) for(int i=x; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {os<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {os<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst ll MOD = 1e9+7;\n\n// n^m%MOD を求める。O( log(m) )\nll modpow(ll n, int m){\n\tll ret=1;\n\tfor(int i=1; i<=m; i<<=1, (n*=n)%=MOD){\n\t\tif( m&i ) (ret *= n) %= MOD;\n\t}\n\treturn ret;\n}\n\n// 逆元を求める\nll modinv(ll n){\n\treturn modpow( n, MOD-2 );\n}\n\n// 階乗を求める。O(1)  準備O( n*log(n) )\n// fact[n]     : nの階乗\n// fact.inv[n] : nの階乗の逆元\nclass FACTORIAL{\npublic:\n\tvector<ll> fact, inv;\n\tFACTORIAL(int MAX_NUM): fact(MAX_NUM), inv(MAX_NUM) {\n\t\tfact[0] = inv[0] = 1;\n\t\tfor(ll i=1; i<MAX_NUM; i++){\n\t\t\tfact[i] = (fact[i-1] * i) % MOD;\n\t\t\tinv[i] = modinv( fact[i] );\n\t\t}\n\t}\n\tconst ll& operator [ ] ( const int i ) const {\n\t\treturn fact[i];\n\t}\n} fact(1000006); // nの最大値を指定\n\n\n// 組み合わせ(Combinationを求める) O(1)\nll cmb(unsigned int n, unsigned int r){\n\tif( n < r ) return 0;\n\treturn fact[n] * fact.inv[r] % MOD * fact.inv[n-r] % MOD;\n}\n\n\nvector<vector<int>> vec;\nvoid dfs(vector<int> &v, int n, int last=1){\n\tvec.push_back(v);\n\tif(last <= 1 && n >= 1){\n\t\tauto _v = v;\n\t\t_v.push_back(1);\n\t\tdfs(_v, n-2, 1);\n\t}\n\tif(last <= 2 && n >= 2){\n\t\tauto _v = v;\n\t\t_v.push_back(2);\n\t\tdfs(_v, n-2, 2);\n\t\tlast = 3;\n\t}\n\tfor(int i = last; i <= n; i+=2){\n\t\tauto _v = v;\n\t\t_v.push_back(i);\n\t\tdfs(_v, n-i-1, i);\n\t}\n}\n\nint main(){\n\t//ios_base::sync_with_stdio(false);\n\tint N, K;\n\tstring s;\n\tll ans = 0;\n\n\tcin >> N >> K;\n\tcin >> s;\n\n\tvector<int> _v;\n\tdfs(_v, N);\n\t//cout << vec.size() << endl;\n\n\tfor(auto v: vec){\n\t\treverse(all(v));\n\t\tint a[70]={}, b[70]={}, c[70]={}, used[100]={};\n\n\t\t// check 1\n\t\tint pos = 0;\n\t\tif(pos < v.size()) rep(i,s.length()) if(s[i] == 'r'){\n\t\t\tused[i] = true;\n\t\t\ta[pos++] = i;\n\t\t\tif(pos >= v.size()) break;\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t// check 2\n\t\tpos = 0;\n\t\twhile(pos < v.size() && v[pos] < 2) pos++;\n\t\tif(pos < v.size()) rep(i,s.length()) if(s[i] == 'b' && a[pos] < i){\n\t\t\tused[i] = true;\n\t\t\tb[pos++] = i;\n\t\t\twhile(pos < v.size() && v[pos] < 2) pos++;\n\t\t\tif(pos >= v.size()) break;\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t// check 3\n\t\tpos = 0;\n\t\twhile(pos < v.size() && v[pos] < 3) pos++;\n\t\tif(pos < v.size()) rep(i,s.length()) if(!used[i] && b[pos] < i){\n\t\t\tused[i] = true;\n\t\t\tc[pos]++;\n\t\t\tif( c[pos] >= v[pos] / 2 ){\n\t\t\t\tpos++;\n\t\t\t\twhile(pos < v.size() && v[pos] < 3) pos++;\n\t\t\t\tif(pos >= v.size()) break;\n\t\t\t}\n\t\t}\n\t\tif(pos < v.size()) continue;\n\n\t\t//cout << v << \"\\t\";\n\t\t// ok\n\t\tll less = N;\n\t\tfor(auto t: v) less -= t + 1;\n\t\tfor(auto t: v) if(t == 2) less++;\n\t\tif( !v.empty() ) less++;\n\t\t//cout << \"less=\" << less << \" \";\n\n\t\tll num = v.size() + 1;  // for White\n\t\tfor(auto t: v){  // for Red\n\t\t\tif(t == 1) num++;\n\t\t\telse if(t == 2) num += 2;\n\t\t\telse num += t / 2 + 2;\n\t\t}\n\t\tfor(auto t: v){  // for Blue\n\t\t\tif(t == 1) ;\n\t\t\telse if(t == 2) num += 1;\n\t\t\telse num += t / 2 + 1;\n\t\t}\n\t\t//cout << \"num=\" << num << \" \";\n\n\t\tll sum = fact[v.size()];\n\t\tll bf = -1, cnt=0;\n\t\tv.push_back(-1);\n\t\tfor(auto t: v){\n\t\t\tcnt++;\n\t\t\tif(bf != t){\n\t\t\t\t//cout << \"c=\" << cnt << \" \";\n\t\t\t\tsum = (sum * fact.inv[cnt]) % MOD;\n\t\t\t\tcnt = 0;\n\t\t\t\tbf = t;\n\t\t\t}\n\t\t}\n\t\t//cout << sum << \" \";\n\t\t//sum = (sum * modpow(num, less)) % MOD;\n\t\tsum = (sum * cmb(num + less - 1, less)) % MOD;\n\t\tans = (ans + sum) % MOD;\n\t\t//cout << \"sum=\" << sum << endl;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=1005;\nint C[maxn][maxn];\nint fac[maxn],invfac[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=1LL*fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline int comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nvi apos;\nint ca=0;\nint n,k;\nvi f;\nint solve()\n{\n    if(!f.size()) return 1;\n    int tot=0;\n    for(int i=0;i<f.size();i++)\n    {\n        //dbg(i,apos[i],f[f.size()-i-1]);\n        if(k-apos[i]<f[f.size()-i-1]) return 0;\n        tot+=f[i];\n    }\n    if(tot>k) return 0;\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++)\n    {\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    int ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nint dfs(int r,int mx,int cc,int len=0)\n{\n    if(len>n) return 0;\n    int ret=1LL*solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(f.size()>=ca) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        int cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=1LL*cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    for(int i=0;i<k;i++) \n    {\n        ca+=s[i]=='r';\n        if(s[i]=='r') apos.push_back(i);\n    }\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[80];\nint n, K, chk[80], Loc[40], C[40], F[150], InvF[150], Mod = 1000000007;\nint D[40][40], TD[40][40]; // 한 블럭의 크기, 블럭의 개수, 쓴거의 개수\n\nint Pow(int a, int b) {\n\tint r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nint Comb(int n, int r) {\n\treturn 1ll * F[n] * InvF[r] % Mod*InvF[n - r]%Mod;\n}\n\nint DD[80][80][80][3];\n\nint Do(int A, int B) { // R* : A, RBxx : B\n\tint i, c1 = 0, c2 = 0, j, k, ii, jj;\n\tif (!A && !B)return 1;\n\tfor (i = 0; i < K; i++) {\n\t\tchk[i] = 0;\n\t\tif (p[i] == 'r' && c1 < B) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t\tif (p[i] == 'b' && c2 < c1) {\n\t\t\tchk[i] = 1;\n\t\t\tc2++;\n\t\t\tLoc[c2] = i;\n\t\t}\n\t}\n\tif (c1 < B || c2 < B)return 0;\n\tc1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tif (p[i] == 'r' && !chk[i] && c1 < A) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t}\n\tif (c1 < A)return 0;\n\tfor (i = 1; i <= B; i++) {\n\t\tC[B-i+1] = 0;\n\t\tfor (j = Loc[i]; j < K; j++)if (!chk[j])C[B-i+1]++;\n\t}\n\tfor (i = 0; i < 40; i++)for (j = 0; j < 40; j++)D[i][j] = TD[i][j] = 0;\n\tD[0][0] = InvF[A];\n\n\tfor (i = 0; i <= n / 2; i++) {\n\t\tfor (j = 0; j < 40; j++) {\n\t\t\tfor (k = 0; k < 40; k++) {\n\t\t\t\tif (!D[j][k])continue;\n\t\t\t\tfor (ii = 0;; ii++) {\n\t\t\t\t\tint s = (ii*i + k);\n\t\t\t\t\tif (ii+j > B || s * 2 + A + B + (A + B - 1) > n || C[j+ii] < s)break;\n\t\t\t\t\tTD[j + ii][s] = (TD[j + ii][s] + 1ll * D[j][k] * InvF[ii]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 40; j++)for (k = 0; k < 40; k++) {\n\t\t\tD[j][k] = TD[j][k];\n\t\t\tTD[j][k] = 0;\n\t\t}\n\t}\n\tint r = 0;\n\tfor (i = 0; i < 40; i++) {\n\t\tint c = (A + B + A + B - 1 + i * 2);\n\t\tint t = c + B * 2 + 2;\n\t\tif (!D[B][i] || n-c < 0)continue;\n\t\tr = (r + 1ll * D[B][i] * F[A+B] % Mod * Comb(t + (n - c) - 1, (n - c)))%Mod;\n\t}\n\treturn r;\n}\nint main() {\n\tint i, j, res = 0;\n\tF[0] = 1;\n\tfor (i = 1; i <= 142; i++)F[i] = 1ll * F[i - 1] * i%Mod;\n\tfor (i = 0; i <= 142; i++)InvF[i] = Pow(F[i], Mod - 2);\n\tscanf(\"%d%d\", &n, &K);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i <= (n+1)/2; i++) {\n\t\tfor (j = 0; i + j <= (n + 1) / 2; j++) {\n\t\t\tres = (res + Do(i, j))%Mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0;int f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 255*3;\nconst int mod = 1e9+7;\nint n,m;\nchar s[maxn];\nint ans,fac[maxn],ifac[maxn];\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(){\n\tn = read(),m = read();\n\tscanf(\"%s\",s+1);\n\tfac[0] = 1;rep(i,1,maxn) fac[i] = 1ll * fac[i-1] * i % mod;\n\tifac[maxn-1] = qpow(fac[maxn-1],mod-2);\n\tDep(i,maxn-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % mod;\n\tassert(ifac[0]==1);\n}\ninline int C(int n,int m){\n\tif(n<m||n<0) return 0;\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\n#define cal(x,y) C((x)+(y)-1,(y)-1)\ninline void add(int &x,int v){\n\tx+=v;\n\tif(x>=mod) x-=mod;\n}\nint q1[maxn],q2[maxn],suf[maxn],f[maxn][maxn];\nbool used[maxn];\nvoid solve(int S1,int S2){\n\tif(!S1&&!S2) return ++ans,void(0);\n\tif((S1+S2)*2>n+1 || S1+2*S2>m) return ;\n\t*q1=*q2=0;\n\tmemset(used,0,sizeof(used));\n\tint x=0,y=0;\n\tRep(i,1,m)\n\t\tif(s[i]=='r' && x<S1+S2) q1[++x]=i; else \n\t\tif(s[i]=='b' && y<S2 && y<x) q2[++y]=i;\n\tif(y!=S2 || x!=S1+S2) return ;\n\tRep(i,1,x) used[q1[i]]=true;\n\tRep(i,1,y) used[q2[i]]=true;\n\tDep(i,m,1) suf[i]=suf[i+1]+(!used[i]);\n\tRep(i,1,S2) q2[i] = suf[q2[i]];\n//\tRep(i,1,S2) wri(q2[i]);puts(\"\");\n\tmemset(f,0,sizeof(f));\n\tf[0][0]=1;\n\tint limit = max(2,n)+1;\n\tRep(i,2,limit)Dep(j,S2-1,0)Rep(k,2*j,limit-i*(S2-j)){\n\t\tRep(l,1,min(S2-j,(limit-k)/i)){\n\t\t\tif(k+i*l-2*(j+l) > q2[S2-(j+l)+1]) break;\n\t\t\tadd(f[j+l][k+i*l],1ll*ifac[l]*f[j][k]%mod);\n\t\t}\n\t}\n\tint res = 0;\n\tRep(i,0,limit){\n\t\tint sum=2*S1+2*i-2*S2-1;\n\t\tint par=2*S1+2*i+1;\n\t\tif (sum>=0&&sum<=n&&f[S2][i])\n\t\t\tadd(res,1ll*f[S2][i]*cal(n-sum,par)%mod);\n\t}res = 1ll * res * fac[S1+S2] % mod * ifac[S1] % mod;\n\tadd(ans,res);\n}\nint main(){\n//\tfreopen(\"cover.in\",\"r\",stdin);\n//\tfreopen(\"cover.out\",\"w\",stdout);\n\tinit(); \n\tans = 0;\n\tRep(S1,0,n)Rep(S2,0,n)solve(S1,S2);\n\twriteln(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint n,k;\nchar s[110];\nbool vis[110];\nbool book[110];\nint a[110];\nbool check(int m)\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(book,0,sizeof(book));\n\tint cnt=0;\n\tfor(int i=1;i<=m&&a[i]==1;i++)cnt++;\n\tint nowr=1,nowb=1;\n\tfor(int i=1;i<=m-cnt;i++)\n\t{\n\t\twhile(nowr<=k&&(vis[nowr]||s[nowr]!='r'))nowr++;\n\t\twhile(nowb<=k&&(vis[nowr]||s[nowb]!='b'||nowb<=nowr))nowb++;\n\t\tif(nowr>k||nowb>k)return false;\n\t\tvis[nowr]=true;\n\t\tvis[nowb]=true;\n\t\tbook[nowb]=true;\n\t}\n\tint tmp=cnt;\n\tfor(int i=1;i<=k&&tmp;i++)\n\t\tif(!vis[i]&&s[i]=='r'){\n\t\t\tvis[i]=true;\n\t\t\ttmp--;\n\t\t}\n\tif(tmp)return false;\n\tint now=cnt+1,num=0;\n\tfor(int i=k;now<=m;i--)\n\t{\n\t\tif(!vis[i])num++;\n\t\tif(book[i]){\n\t\t\tnum-=a[now]-2;\n\t\t\tif(num<0)return false;\n\t\t\tnow++;\n\t\t}\n\t}\n\treturn true;\n}\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1ll*ans*t%Mod;\n\t\tt=1ll*t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint ans;\nint fac[2010],inv[2010];\nvoid init()\n{\n\tint N=2000;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=1ll*fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=1ll*inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\tif(x<0||y<0||x-y<0)return 0;\n\treturn 1ll*fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nvoid solve(int m,int len)\n{\n\tint s=0;//block-1\n\tfor(int i=1;i<=m;i++)\n\t\ts+=a[i]*2;\n\tint res=1ll*C(n-len+s,s)*fac[m]%Mod;\n\tfor(int i=1,j;i<=m;i=j)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&a[j]==a[i])j++;\n\t\tres=1ll*res*inv[j-i]%Mod;\n\t}\n\tans=(ans+res)%Mod;\n\treturn ;\n}\nint cntr;\nbool dfs(int m,int lst,int sum,int len)\n{\n\tif(len>n)return false;\n\tif(!check(m-1))return false;\n\tif(m-1>cntr)return true;\n\tsolve(m-1,len);\n\tfor(a[m]=lst;a[m]<=k-sum;a[m]++)\n\t{\n\t\tint tlen=len;\n\t\tif(m>1)tlen++;\n\t\tif(a[m]==1)tlen++;\n\t\telse tlen+=(a[m]-1)*2-1;\n\t\tif(!dfs(m+1,a[m],sum+a[m],tlen))\n\t\t\tbreak;\n\t}\n\treturn true;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=k;i++)\n\t\tif(s[i]=='r')cntr++;\n\tdfs(1,1,0,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], suf[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nbool check () {\n\tvector<int> vec1, vec2, vec3;\n\tfor (int i = 0; i < top; i++) vec1.push_back(stk[i]);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') {\n\t\t\tif (!vec1.empty()) {\n\t\t\t\tif (vec1.back()) vec2.insert(vec2.begin(), vec1.back());\n\t\t\t\tvec1.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!vec2.empty()) {\n\t\t\t\tif (vec2.back() > 1) vec3.push_back(vec2.back() - 1);\n\t\t\t\tvec2.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn vec1.empty() && vec2.empty() && vec3.empty();\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tassert(j <= n * 3 && tmp[i] <= n * 3);\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tif (n + num2 - 1 < 0 || num1 + num2 - 1 < 0) return 0ll;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 75;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m; char s[MAXN];\nint dp[2][MAXN][MAXN][MAXN][4];\nbool vis[MAXN][MAXN][MAXN][MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"\\n%s\", s + 1);\n\tvis[0][0][0][0] = true;\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 0; j <= i; j++)\n\t\tfor (int k = 0; k <= j; k++)\n\t\tfor (int l = k; l <= i; l++) {\n\t\t\tif (!vis[i - 1][j][k][l]) continue;\n\t\t\tvis[i][j][k][l] = true;\n\t\t\tif (s[i] == 'r') {\n\t\t\t\tvis[i][j + 1][k][l] = true;\n\t\t\t\tif (k != 0) vis[i][j][k][l + 1] = true;\n\t\t\t} else {\n\t\t\t\tif (k < j) vis[i][j][k + 1][l + 1] = true;\n\t\t\t\tif (k != 0) vis[i][j][k][l + 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j <= m; j++)\n\tfor (int k = 0; k <= j; k++)\n\tfor (int l = k; l <= m; l++)\n\t\tdp[0][j][k][l][0] = vis[m][j][k][l];\n\t//state: 0 -> w, 1 -> r, 2 -> b*, 3 -> r*\n\t//j -> segments, k -> with b, l -> cntb\n\tfor (int i = 1, dest = 1, from = 0; i <= n; i++, swap(dest, from)) {\n\t\tmemset(dp[dest], 0, sizeof(dp[dest]));\n\t\tfor (int j = 0; j <= m; j++)\n\t\tfor (int k = 0; k <= m; k++)\n\t\tfor (int l = k; l <= m; l++) {\n\t\t\tint tmp = dp[from][j][k][l][0];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 0 + w\n\t\t\tif (j) update(dp[dest][j - 1][k][l][1], tmp); // 0 + r\n\t\t\tif (j && k && l) update(dp[dest][j - 1][k - 1][l - 1][2], tmp); // 0 + b\n\t\t\t\n\t\t\ttmp = dp[from][j][k][l][1];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 1 + w\n\t\t\tupdate(dp[dest][j][k][l][1], tmp); // 1 + r\n\t\t\tif (k && l) update(dp[dest][j][k - 1][l - 1][2], tmp); // 1 + b\n\t\t\t\n\t\t\ttmp = dp[from][j][k][l][2];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 2 + w\n\t\t\tupdate(dp[dest][j][k][l][3], tmp); // 2 + r\n\t\t\tupdate(dp[dest][j][k][l][2], tmp); // 2 + b\n\t\t\t\n\t\t\ttmp = dp[from][j][k][l][3];\n\t\t\tupdate(dp[dest][j][k][l][0], tmp); // 3 + w\n\t\t\tupdate(dp[dest][j][k][l][3], tmp); // 3 + r\n\t\t\tif (l) update(dp[dest][j][k][l - 1][2], tmp); // 3 + b\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= 3; i++)\n\t\tupdate(ans, dp[n & 1][0][0][0][i]);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7;\ninline int inc(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline void add(int &x, int y) {y += x; x = y >= MOD ? y - MOD : y;}\ninline int mul(int x, int y) {return (ll)x * y % MOD;}\ninline int qpow(int x, int y)\n{\n\tint res = 1;\n\tfor (; y; y >>= 1, x = mul(x, x))\n\t\tif (y & 1) res = mul(res, x);\n\treturn res;\n}\n\nstring s;\nint n, k;\n\nbool check(vector<int> &v)\n{\n\tstatic int pos[75], use[75];\n\tmemset(pos, 0, sizeof pos);\n\tmemset(use, 0, sizeof use);\n\tint now = 0;\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\twhile (now < k)\n\t\t{\n\t\t\tif (s[now] == 'r') break;\n\t\t\tnow ++;\n\t\t}\n\t\tif (now == k) return 0;\n\t\tpos[i] = now, use[now] = 1;\n\t\tnow ++;\n\t}\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\tif (v[i] < 2) continue;\n\t\tnow = max(now, pos[i] + 1);\n\t\twhile (now < k)\n\t\t{\n\t\t\tif (!use[now] && s[now] == 'b') break;\n\t\t\tnow ++;\n\t\t}\n\t\tif (now == k) return 0;\n\t\tuse[now] = 1, pos[i] = now;\n\t\tnow ++;\n\t}\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\tif (v[i] < 3) continue;\n\t\tint cnt = 0;\n\t\tnow = max(now, pos[i] + 1);\n\t\twhile (now < k)\n\t\t{\n\t\t\tif (!use[now])\n\t\t\t{\n\t\t\t\t++ cnt, use[now] = 1;\n\t\t\t\tif (cnt + 2 == v[i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow ++;\n\t\t}\n\t\tif (now == k) return 0;\n\t}\n\treturn 1;\n}\n\nint fac[205], ifac[205];\n\ninline int binom(int x, int y)\n{\n\tif (y > x || y < 0) return 0;\n\treturn mul(mul(fac[x], ifac[y]), ifac[x - y]);\n}\n\nint Getans(vector<int> &v)\n{\n\tif (v.empty()) return 1;\n\tif (v.size() == 1)\n\t{\n\t\tif (v[0] == 1) return binom(n + 1, 2);\n\t\telse return binom(n + 3, v[0] * 2);\n\t}\n\tstatic int buc[75];\n\tmemset(buc, 0, sizeof buc);\n\tfor (int i = 0; i < v.size(); i ++)\n\t\tbuc[v[i]] ++;\n\tint res = fac[v.size()];\n\tfor (int i = 1; i <= n; i ++)\n\t\tres = mul(res, ifac[buc[i]]);\n\tint num = n + 1, pos = 0;\n\tfor (int i = 0; i < v.size(); i ++)\n\t{\n\t\tpos += v[i] * 2;\n\t\tif (v[i] >= 2) num += 2;\n\t}\n\treturn mul(res, binom(num, pos));\n}\n\nint ans;\nvoid dfs(int now, int remain, int pre, vector<int> &v)\n{\n\tif (check(v)) add(ans, Getans(v));\n\tfor (int i = min(remain, pre); i >= 1; i --)\n\t{\n\t\tint cnt = i == 1 ? 1 : ((i - 1) * 2 - 1); // BR...RB\n\t\tif (now + cnt + max(0, (int)v.size() - 1) > n) continue;\n\t\tv.push_back(i);\n\t\tdfs(now + cnt, remain - i, i, v);\n\t\tv.pop_back();\n\t}\n}\n\nint main()\n{\n\tcin >> n >> k >> s;\n\tfac[0] = ifac[0] = 1;\n\tfor (int i = 1; i <= 200; i ++) fac[i] = mul(fac[i - 1], i);\n\tifac[200] = qpow(fac[200], MOD - 2);\n\tfor (int i = 200; i >= 1; i --) ifac[i - 1] = mul(ifac[i], i);\n\tvector<int> foo(0); ans = 0;\n\tdfs(0, k, k, foo);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\nchar buf[1 << 23], *ps = buf, *pt = buf;\n#define getchar() (ps == pt && (pt = (ps = buf) + fread(buf, 1, 1 << 23, stdin), ps == pt) ? EOF : *ps++)\nint read(){\n\tregister int x = 0;\n\tregister char f = 1, ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');\n\treturn f ? x : -x;\n}\nvoid print(int x, char ch = '\\n'){\n\tif (x == 0) return putchar('0'), putchar(ch), void(0);\n\tint cnt = 0, num[25];\n\tfor (x < 0 ? putchar('-'), x = -x : 0; x; x /= 10) num[++cnt] = x % 10;\n\twhile (cnt) putchar(num[cnt] ^ '0'), --cnt;\n\tputchar(ch);\n}\nconst int N = 105, M = 305, P = 1000000007;\nint n, m, C[M][M];\nchar a[N];\nvoid initC(int n){\n\tfor (register int i = 0; i < n; ++i){\n\t\tC[i][0] = C[i][i] = 1;\n\t\tfor (register int j = 1; j < i; ++j)\n\t\t\tC[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % P;\n\t}\n}\nint cnt, pos[N], suf[N], f[N], dp[N][N], ans;\nvoid DP(int s, int sr){ // 一共 s + sr 段，sr 段是单独的 R，s 段含有 B (B, BRB, BRBRB, ...)\n\tregister int ts = s + sr, x = sr + ts - 1, y = 2 * s + 1, lim = n - x;\n\tif (lim < 0) return;\n\tfor (register int i = 1; i <= m; ++i) suf[i] = 1;\n\tcnt = 0, *pos = 0;\n\tfor (register int i = 1; i <= m; ++i) // 把能开的 rb 都先开掉（使得费用上界尽量大）\n\t\tif (a[i] == 'r' && cnt < s) ++cnt, suf[i] = 0;\n\t\telse if (a[i] == 'b' && *pos < cnt) pos[++*pos] = i, suf[i] = 0;\n\tif (*pos < s) return;\n\tcnt = 0;\n\tfor (register int i = 1; i <= m; ++i) // 开完 rb 后从前往后拿 r 给单独的 R（使得费用上界尽量大）\n\t\tif (a[i] == 'r' && suf[i] && cnt < sr) ++cnt, suf[i] = 0;\n\tif (cnt < sr) return;\n\tsuf[m + 1] = 0;\n\tfor (register int i = m; i; --i) suf[i] += suf[i + 1];\n\tfor (register int i = 1; i <= s; ++i) f[i] = suf[pos[s - i + 1]] + i * 2;\n\t// f[i] 费用前 i 小的段的费用之和上界（从后往前第 i 个 b 后面能用的位置数量）\n\tfor (register int i = 0; i <= s; ++i)\n\t\tfor (register int j = 0; j <= lim; ++j)\n\t\t\tdp[i][j] = 0;\n\tdp[0][0] = 1;\n\tfor (register int i = 2; i <= ((lim + 3) >> 1); ++i) // 费用\n\t\tfor (register int j = s - 1; ~j; --j) // 段数\n\t\t\tfor (register int k = lim - 1; ~k; --k) // 每段长度之和\n\t\t\t\tif (dp[j][k])\n\t\t\t\t\tfor (register int tj = j + 1, len = (i << 1) - 3, tk = k + len; tj <= s; ++tj, tk += len){\n\t\t\t\t\t\tif (tk > lim || (tk + tj * 3) / 2 > f[tj]) break;\n\t\t\t\t\t\tdp[tj][tk] = (dp[tj][tk] + 1ll * dp[j][k] * C[tj][j]) % P;\n\t\t\t\t\t}\n\tfor (register int i = 0; i <= lim; ++i, ++x)\n\t\tif (dp[s][i]) ans = (ans + 1ll * C[ts][s] * C[n + y][x + y] % P * dp[s][i]) % P;\n}\nint main(){\n\tn = read(), m = read();\n\tfor (register int i = 1; i <= m; ++i) while (!islower(a[i] = getchar())) ;\n\tinitC(M);\n\tfor (register int i = 0; i <= n; ++i)\n\t\tfor (register int j = 0; j <= n - i; ++j)\n\t\t\tif (i == 0 && j == 0) ++ans;\n\t\t\telse DP(i, j);\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7;\ninline int add(int a,int b) {return a+=b,a>=MOD?a-MOD:a;}\ninline int del(int a,int b) {return a-=b,a<0?a+MOD:a;}\ninline int mul(int a,int b) {return 1LL*a*b%MOD;}\nconst int MAXN=110;\nint C[MAXN][MAXN];\ninline void initC(int N)\n{\n\tfor(int i=0;i<=N;i++) C[i][0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfor(int j=1;j<=i;j++) C[i][j]=add(C[i-1][j-1],C[i-1][j]);\n\treturn;\n}\nint dp[MAXN][MAXN][MAXN],up[MAXN],sum[MAXN];\ninline void solve(int n,int m,int c)\n{\n\tint r=m+(c<<1)-1;\n\tmemset(dp,0,sizeof(dp)),dp[0][0][0]=1;\n\tfor(int i=0;i<m;i++)\n\t\tfor(int j=0;j<=up[i]&&(j<<1)+r<=n+m;j++)\n\t\t{\n\t\t\tint tmp=dp[i][j][0];\n\t\t\tfor(int k=1;k<=up[m]&&j+(m-i)*k<=up[m];k++)\n\t\t\t{\n\t\t\t\tfor(int l=1;i+l<=m&&j+k*l<=up[i+l];l++) dp[i+l][j+k*l][k]=add(dp[i+l][j+k*l][k],mul(tmp,C[i+l][l]));\n\t\t\t\ttmp=add(tmp,dp[i][j][k]);\n\t\t\t}\n\t\t}\n\tfor(int i=0;i<=up[m]&&(i<<1)+r<=n+m;i++)\n\t{\n\t\tint tmp=0,tmp_=(i<<1)+r-m;\n\t\tfor(int j=0;j<=i;j++) tmp=add(tmp,dp[m][i][j]);\n\t\tif(!tmp) continue;\n\t\tfor(int j=0;j<=((m+1)<<1)&&tmp_+j<=n;j++) sum[tmp_+j]=add(sum[tmp_+j],mul(tmp,mul(C[m+c][c],C[(m+1)<<1][j])));\n\t}\n\treturn;\n}\nchar ch[MAXN];\nint q[MAXN],pos[MAXN],vis[MAXN];\nint n,k,ans;\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>k>>(ch+1);\n\tinitC(100);\n\tfor(int i=0;(i<<1)<=k;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint cnt=0,L=1,R=0,s=0,r=1;\n\t\tfor(int j=1;j<=k&&cnt<i;j++)\n\t\t\tif(ch[j]=='r') q[++R]=j;\n\t\t\telse if(L<=R) vis[q[L++]]=vis[j]=1,pos[++cnt]=j;\n\t\tif(cnt<i) continue;\n\t\tfor(int j=1;j<=k;j++)\n\t\t\tif(!vis[j]&&ch[j]=='r') s++;\n\t\tpos[i+1]=k+1,up[i+1]=0;\n\t\tfor(int j=0;j<=s;j++)\n\t\t{\n\t\t\tif(j)\n\t\t\t{\n\t\t\t\twhile(vis[r]||ch[r]!='r') r++;\n\t\t\t\tvis[r]=1;\n\t\t\t}\n\t\t\tfor(int t=i;t>0;t--)\n\t\t\t{\n\t\t\t\tup[t]=up[t+1];\n\t\t\t\tfor(int t_=pos[t+1]-1;t_>pos[t];t_--)\n\t\t\t\t\tif(!vis[t_]) up[t]++;\n\t\t\t\tup[t]++;\n\t\t\t}\n\t\t\treverse(up+1,up+i+1),solve(n,i,j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) ans=add(ans,mul(sum[i],C[n-1][i-1]));\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define inver(a) power(a,mod-2)\nusing namespace std;\ntemplate<class T> inline bool Cmax(T &x,T y) {return x<y?x=y,1:0;}\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=1000+5;\nconst int maxk=70+5;\nint n,k;\nint an;\nint r[maxk],b[maxk];\nint fac[maxn];\nint inv[maxn];\nint num[maxk];\nbool vis[maxk];\nchar s[maxk];\nvector<int> a; \ninline int add(int x) {return x>=mod?x-mod:x;}\nll power(ll x,ll y)\n{\n\tll re=1;\n\twhile(y)\n\t{\n\t\tif(y&1) re=re*x%mod;\n\t\tx=x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn re;\n}\ninline int binom(int x,int y)\n{\n\treturn (ll)fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nbool check()\n{\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0,j=1;i<a.size();++i)\n\t{\n\t\twhile(j<=k&&s[j]!='r') ++j; if(j>k) return 0;\n\t\tr[i]=j,vis[j++]=1;\n\t}\n\tfor(int i=0,j=1;i<a.size();++i) if(a[i]>=2)\n\t{\n\t\tCmax(j,r[i]+1);\n\t\twhile(j<=k&&s[j]!='b') ++j; if(j>k) return 0;\n\t\tb[i]=j,vis[j++]=1;\n\t}\n\tfor(int i=0,j=1;i<a.size();++i) if(a[i]>=3)\n\t{\n\t\tCmax(j,b[i]+1);\n\t\tint T=a[i]-2; while(T--)\n\t\t{\n\t\t\twhile(j<=k&&vis[j]) ++j; if(j>k) return 0;\n\t\t\tvis[j++]=1;\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int rest,int las)\n{\n\tif(check())\n\t{\n\t\tint v=a.size()+1;\n\t\tfor(int i=0;i<a.size();++i)\n\t\t{\n\t\t\tv+=num[a[i]];\n\t\t\tif(a[i]>1) v+=2;\n\t\t}\n\t\tint re=(ll)binom(rest+v-1,rest)*fac[a.size()]%mod;\n\t\tfor(int i=0,j;i<a.size();i=j)\n\t\t{\n\t\t\tj=i; while(j<a.size()&&a[j]==a[i]) ++j;\n\t\t\tre=(ll)re*inv[j-i]%mod;\n\t\t}\n\t\tan=add(an+re);\n\t}\n\tfor(int i=1;i<=las;++i)\n\t{\n\t\tif(num[i]+1>rest) break;\n\t\ta.push_back(i);\n\t\tdfs(rest-num[i]-1,i);\n\t\ta.pop_back();\n\t}\n}\nvoid init(int n)\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfac[i]=(ll)fac[i-1]*i%mod;\n\t}\n\tinv[n]=inver(fac[n]);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tinv[i-1]=(ll)inv[i]*i%mod;\n\t}\n}\nint sol()\n{\n\tinit(1000);\n\tan=1;\n\tnum[1]=1;\n\tnum[2]=1;\n\tfor(int i=3;i<=n;++i) num[i]=num[i-1]+2;\n\tfor(int i=1;;++i)\n\t{\n\t\tif(num[i]>n) break;\n\t\ta.push_back(i);\n\t\tdfs(n-num[i],i);\n\t\ta.pop_back();\n\t}\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tprintf(\"%d\\n\",sol());\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 70 + 10,mod = 1e9 + 7;\n\nint a[N],vis[N],fac[N << 1],inv[N << 1],Pos[N];\nchar str[N];\n\nint n,k,ans = 0;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int A,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * A % mod;\n\t\tA = 1ll * A * A % mod,b /= 2;\n\t}\n\treturn res;\n}\n\ninline int C(int A,int B) {\n\treturn 1ll * fac[A] * inv[B] % mod * inv[A - B] % mod;\n}\n\ninline void Calc(int len,int sum) {\n\tmemset(vis,0,sizeof(vis)),memset(Pos,0,sizeof(Pos));\n\tint lasr = 0,lasb = 0;\n\tFor(i,1,len) {\n\t\tint pos = 0;\n\t\tFor(j,lasr + 1,k) if(!vis[j] && str[j] == 'r') {\n\t\t\tvis[j] = true;\n\t\t\tpos = lasr = j;break;\n\t\t}\n\t\tif(!pos) return;\n\t\tif(a[i] < 2) continue;\n\t\tFor(j,max(pos,lasb) + 1,k) if(!vis[j] && str[j] == 'b') {\n\t\t\tvis[j] = true;\n\t\t\tPos[i] = lasb = j;break;\n\t\t}\n\t\tif(!Pos[i]) return;\n\t}\n\tint Las = 0;\n\tFor(i,1,len) {\n\t\tif(a[i] < 3) continue;\n\t\tint cnt = 0;\n\t\tFor(j,max(Pos[i],Las) + 1,k) {\n\t\t\tif(!vis[j]) cnt++,vis[j] = true;\n\t\t\tLas = j;\n\t\t\tif(cnt == a[i] - 2) break;\n\t\t}\n\t\tif(cnt < a[i] - 2) return;\n\t}\n\tint Inv = fac[len],tot = len + 1;\n\tfor(int i = 1,j = 1;i <= len;i = j + 1) {\n\t\tfor(j = i;j < len && a[j + 1] == a[i];j++);\n\t\tInv = 1ll * Inv * inv[j - i + 1] % mod;\n\t\ttot += (j - i + 1) * (a[i] * 2 - 1);\n\t}\n\tans = (ans + 1ll * Inv * C(n - sum + tot - 1,tot - 1)) % mod;\n}\n\ninline void dfs(int res,int Mn,int cur) {\n\tif(res < 0) return;\n\tCalc(cur - 1,n - res);\n\tif(res == 0) return;\n\tFor(i,1,min(res + 1,Mn)) a[cur] = i,dfs(res - (i == 1 ? 1 : i * 2 - 3) - (cur > 1),i,cur + 1);\n}\n\ninline void init(int Lim) {\n\tfac[0] = 1;\n\tFor(i,1,Lim) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[Lim] = fpm(fac[Lim],mod - 2);\n\tFordown(i,Lim,1) inv[i - 1] = 1ll * inv[i] * i % mod;\n}\n\nint main() {\n\n\tn = read(),k = read();\n\tinit(150);\n\tscanf(\"%s\",str + 1);\n\n\tdfs(n,70,1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\nint ts = 0;\nvoid calc(int sz) {\n    ts++;\n    int tb = 0, tr = 0;\n    int used[77];\n    memset(used, 0, sizeof used);\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        used[tr] = 1;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && ch[tb] != 'b') tb++;\n            used[tb] = 1;\n        }\n        if(tr > K || tb > K) return;\n    }\n    int tt = 1;\n    for(int i = 1; i <= sz; i++)\n        for(int j = 1; j <= X[i] - 2; j++) {\n            while(tt <= K && used[tt]) tt++;\n            if(tt > K) return;\n        }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tot = 0) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K && max(2ll, i * 2 - 2) + tot <= n + 3; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tot + max(2ll, i * 2 - 2));\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    //printf(\"%d\\n\", ts);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=1 +117;\nconst int MM=1 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\nconst int mod=1e9+7;\nint k,n;\nLL fact[4*NN]={};\nLL rev[4*NN]={};\nchar s[NN]={};\nLL ksm(LL a,LL b){\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=a*ret%mod;\n\treturn ret;\n}\nLL comp(int n,int m){\n\treturn fact[n]*rev[m]%mod*rev[n-m]%mod;\n}\nvoid prefact(int n){\n\tfact[0]=1;\n\tfor(int i=1;i<=n;++i)fact[i]=fact[i-1]*i%mod;\n\trev[n]=ksm(fact[n],mod-2);\n\tfor(int i=n;i>=1;--i){\n\t\trev[i-1]=rev[i]*i%mod;\n\t}\n}\nint seq[NN][2]={},scnt=0;\nLL ans=0;\nint len[NN]={};\nint pos[NN]={};\nbool used[NN]={};\nint rcnt=0;\nint bcnt=0;\nvoid calc(){\n\tint tp=0;\n\tfor(int i=1;i<=k;++i)used[i]=0;\n\tfor(int i=1;i<=scnt;++i){\n\t\tfor(int j=1;j<=seq[i][1];++j){\n\t\t\tlen[++tp]=seq[i][0];\n\t\t\tpos[tp]=0;\n\t\t}\n\t}\n\tint now=1;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!used[i]&&s[i]=='r'&&now<=tp&&pos[now]<i){\n\t\t\t--len[now],pos[now]=i,++now,used[i]=1;\n\t\t}\n\t}\n\tif(now!=tp+1)return ;\n\tnow=1;\n\twhile(now<=tp&&!len[now])++now;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!used[i]&&s[i]=='b'&&now<=tp&&pos[now]<i){\n\t\t\t--len[now],pos[now]=i,used[i]=1;\n\t\t\t++now;\n\t\t\twhile(now<=tp&&!len[now])++now;\n\t\t}\n\t}\n\tif(now!=tp+1)return ;\n\tnow=1;\n\twhile(now<=tp&&!len[now])++now;\n\tfor(int i=1;i<=k;++i){\n\t\tif(!used[i]&&now<=tp&&pos[now]<i){\n\t\t\t--len[now],pos[now]=i,used[i]=1;\n\t\t\twhile(now<=tp&&!len[now])++now;\n\t\t}\n\t}\n\tif(now!=tp+1)return ;\n\tint les=tp-1;\n\tif(tp==0)les=1;\n\tint seg=tp+1;\n\tLL ad=fact[tp];\n\tfor(int i=1;i<=scnt;++i){\n\t\tad=ad*rev[seq[i][1]]%mod;\n\t\tint l=seq[i][0];\n\t\tfor(int j=1;j<=seq[i][1];++j){\n\t\t\tif(l==1)les+=1;\n\t\t\telse les+=2*l-3;\n\t\t\tseg+=2*l-1;\n\t\t}\n\t}\n\tif(les>n)return ;\n\t//for(int i=1;i<=scnt;++i)cerr<<seq[i][0]<<\":\"<<seq[i][1]<<endl;\n\t//cerr<<endl;\n\t//cerr<<ad<<\" \"<<seg<<\" \"<<n-les<<endl;\n\tad=ad*comp(n-les+seg-1,n-les)%mod;\n\tans=(ans+ad)%mod;\n}\nint all=0;\nvoid dfs(int rem,int now){\n\tif(rcnt<all)return ;\n\tif(now==0){\n\t\tcalc();\n\t\treturn ;\n\t}\n\tif(bcnt<all)return ;\n\tfor(int i=0;i*now<=rem;++i){\n\t\tif(i){\n\t\t\t++scnt;\n\t\t\tseq[scnt][0]=now;\n\t\t\tseq[scnt][1]=i;\n\t\t\tall+=i;\n\t\t}\n\t\tdfs(rem-i*now,now-1);\n\t\tif(i){\n\t\t\t--scnt;\n\t\t\tall-=i;\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tk=read();\n\tprefact(4*k+n+10);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=k;++i)\n\t\tif(s[i]=='r')rcnt++;\n\t\telse bcnt++;\n\tdfs(k,k);\n\tprintf(\"%lld\\n\",ans);\n\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 75;\nconst int mod = 1000000007;\nint n, m, posr[N], cr, a[N], fact[301], ifact[301], inv[301];\nchar S[N];\nint ans;\ninline void Init() {\n\tinv[1] = 1;\n\tfor (int i = 2; i <= 300; i++) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;\n\tfact[0] = ifact[0] = 1;\n\tfor (int i = 1; i <= 300; i++) {\n\t\tfact[i] = 1ll * fact[i - 1] * i % mod;\n\t\tifact[i] = 1ll * ifact[i - 1] * inv[i] % mod;\n\t}\n}\ninline void calc(int cnt, int sum) {\n\tif (!cnt) { ans = (ans + 1) % mod; return; }\n\tif (cr < cnt) return;\n\tint R[N], B[N], vis[N];\n\tfor (int i = 1; i <= m; i++) vis[i] = 0;\n\tint fir1 = cnt + 1;\n\tfor (int i = 1, posb = 1; i <= cnt; i++) {\n\t\tif (a[i] == 1) {\n\t\t\tfir1 = i;\n\t\t\twhile (i <= cnt) {\n\t\t\t\tR[i] = B[i] = posr[i];\n\t\t\t\tvis[R[i]] = 1;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (posb < posr[i]) posb = posr[i] + 1;\n\t\twhile (posb <= m && S[posb] != 'b') posb++;\n\t\tif (posb > m) return;\n\t\tR[i] = posr[i];\n\t\tB[i] = posb;\n\t\tvis[R[i]] = vis[B[i]] = 1;\n\t\tposb++;\n\t}\n\tfor (int i = fir1 - 1, j = m, ss = 0, ps = 0; i; i--) {\n\t\twhile (j > B[i]) {\n\t\t\tif (!vis[j]) ss++;\n\t\t\tj--;\n\t\t}\n\t\tif (ss - ps < a[i] - 2) return;\n\t\tps += a[i] - 2;\n\t}\n\tint res = fact[cnt], cp = 1;\n\tfor (int i = 1, j = 0; i <= cnt; i++) {\n\t\tj++;\n\t\tcp += a[i] * 2;\n\t\tif (i == cnt || a[i] != a[i + 1]) {\n\t\t\tres = 1ll * res * ifact[j] % mod;\n\t\t\tj = 0;\n\t\t}\n\t}\n\tres = 1ll * res * fact[n - sum + cp] % mod * ifact[cp - 1] % mod * ifact[n - sum + 1] % mod;\n\tans = (ans + res) % mod;\n}\nvoid go(int d, int mx, int sum) {\n\tcalc(d - 1, sum);\n\tif (sum + 1 <= n) {\n\t\ta[d] = 1;\n\t\tgo(d + 1, 1, sum + 2);\n\t}\n\tfor (int i = 2; i <= mx; i++) {\n\t\tif (sum + 2 * i - 3 <= n) {\n\t\t\ta[d] = i;\n\t\t\tgo(d + 1, i, sum + 2 * i - 2);\n\t\t}\n\t}\n}\nint main() {\n\tInit();\n\tscanf(\"%d%d %s\", &n, &m, S + 1);\n\tcr = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (S[i] == 'r') posr[++cr] = i;\n\t}\n\tgo(1, (n + 3) >> 1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOCAL\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool x) { return (x ? \"T\" : \"F\"); }\nstring to_string(const char* s) { return to_string((string)s); }\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename V>\nstring to_string(V v) {\n    bool f = true; string res = \"[\";\n    for (const auto& x: v) {\n        if (!f) res += \", \";\n        f = false;\n        res += to_string(x); } res += \"]\";\n    return res;\n}\nvoid debug() { cerr << endl; }\ntemplate <typename H, typename... T>\nvoid debug(H h, T... t) { cerr << \" \" << to_string(h); debug(t...); }\n#ifdef LOCAL\n#define dbg(args...) cerr<<\"(\"<<#args<<\") =\", debug(args)\n#else\n#define dbg(args...) 2019\n#endif\n\nconst int MOD = 1000000007; // 998244353; // 998244853;\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nstruct Comb {\n    int N;\n    vector<mint> fac, ifac, inv;\n\n    Comb(int _n=1) {\n        resize(2);\n        fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;\n        N = 1; grow(_n);\n    }\n\n    void resize(int _s) {\n        fac.resize(_s); ifac.resize(_s); inv.resize(_s);\n    }\n    bool grow(int _n) {\n        if (_n <= N) return false;\n        swap(_n, N); resize(N+1);\n        for (int i = _n+1; i <= N; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n        return true;\n    }\n    // perm\n    mint a(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k];\n    }\n    // choose\n    mint c(int n, int k) {\n        if (n < k || k < 0) return 0;\n        if (n > N) grow(n);\n        return fac[n] * ifac[n-k] * ifac[k];\n    }\n    // sum x = s, x > 0\n    mint p(int s, int k) {\n        return c(s-1, k-1);\n    }\n    // sum x = s, x >= 0\n    mint z(int s, int k) {\n        return p(s+k, k);\n    }\n    // \\E Y-X >= m\n    mint hit(int n, int k, int m=1) {\n        if (m <= k-n) return c(n+k, n);\n        return c(n+k, k-m);\n    }\n    // catalan trapezoids C_m(n, k)\n    // \\A Y-X < m,  =c(n+k,n) - hit\n    mint cat(int n, int k, int m=1) {\n        if (m > k) return c(n+k, n);\n        if (m <= k-n) return 0;\n        return c(n+k,n) - c(n+k, k-m);\n    }\n} c(150);\n\nmint res;\nint n,k;\nstring s;\nbool trk[77];\nint8_t pos[77];\nint8_t cnt[77];\n\nbool check(const vector<int>& ip, int sum) {\n    memset(trk, 0, sizeof trk);\n    memset(pos, -1, sizeof pos);\n    int m = ip.size();\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = 0; j < k; j++) {\n            if (s[j]=='r' && !trk[j]) {\n                pos[i] = j; trk[j] = true;\n                break;\n            }\n        }\n        if (pos[i] == -1) return false;\n    }\n    memset(cnt, 0x01, sizeof cnt);\n    for (int i = m-1; i >= 0; i--) {\n        if (ip[i] == 1) continue;\n        for (int j = pos[i]+1; j < k; j++) {\n            if (s[j]=='b' && !trk[j]) {\n                cnt[i]++;\n                pos[i]=j; trk[j] = true;\n                break;\n            }\n        }\n        if (cnt[i] != 2) return false;\n    }\n    for (int i = m-1; i >= 0; i--) {\n        for (int j = pos[i]+1; ip[i] > cnt[i] && j < k; j++) {\n            if (!trk[j]) {\n                cnt[i]++;\n                pos[i] = j; trk[j] = true;\n            }\n        }\n        //cout << i << ','<<cnt[i]<<'\\n';\n        if (ip[i] != (int)cnt[i]) return false;\n    }\n    \n    mint coeff = c.fac[m];\n    int las = 0, len = 0;\n    for (const int& x: ip) {\n        if (x == las) len++;\n        else {\n            coeff *= c.ifac[len];\n            len = 1;\n            las = x;\n        }\n    }coeff *= c.ifac[len];\n\n    int zero = 0;\n    zero += 2;\n    for (const int& x: ip) {\n        if (x > 1) zero+=2;\n    }\n\n    if (sum == 0) {\n        res += 1; return true;\n    }\n    //dbg(ip, sum);\n    //cout << coeff << '\\n';\n    res += c.p(n+zero, sum+zero) * coeff;\n    //cout << res << \"\\n\";\n    return true;\n}\n\nvoid dfs(vector<int>& ip, int sum) {\n    check(ip, sum);\n    //dbg(ip);\n    int sta = ip.empty()? 1 : ip.back();\n    for (int i = sta; i <= n; i++) {\n        int nex_sum = sum + max(2*i-3, 1) + (ip.empty()?0:1);\n        if (nex_sum > n) break;\n        ip.emplace_back(i);\n        dfs(ip, nex_sum);\n        ip.pop_back();\n    }\n}\n\nvoid solve() {\n    cin >> n >> k;\n    cin >> s;\n    vector<int> ip;\n    dfs(ip, 0);\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0;int f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 255;\nconst int mod = 1e9+7;\nint n,m;\nchar s[maxn];\nint ans,fac[maxn],ifac[maxn];\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(){\n\tn = read(),m = read();\n\tscanf(\"%s\",s+1);\n\tfac[0] = 1;rep(i,1,maxn) fac[i] = 1ll * fac[i-1] * i % mod;\n\tifac[maxn-1] = qpow(fac[maxn-1],mod-2);\n\tDep(i,maxn-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % mod;\n\tassert(ifac[0]==1);\n}\ninline int C(int n,int m){\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\n#define cal(x,y) C((x)+(y)-1,(y)-1)\nint g[maxn],a[maxn];\nvoid calc(int w,int tot){\n\tRep(i,1,tot) a[i] = g[tot-i+1];a[tot+1]=0;\n\tint lim=0;while(lim<tot && a[lim+1]>1) ++lim;\n\tint i,j,k,l,t;\n\tfor(i=1,k=1,l=1,t=0;i<=m;++i){\n\t\tif(s[i]=='r' && k<=tot) \n\t\tk++; else\n\t\tif(s[i]=='b' && l<k && l<=lim) t+=a[l]-2,l++; else\n\t\tif(t) t--; \n\t}\n\tif(k<=tot || l<=lim || t) return ;\n\tint pos=tot+1,res=fac[tot];\n\tfor(i=1;i<=tot;i=j+1){\n\t\tfor(j=i;a[j+1]==a[i];++j);\n\t\tres=1ll*res*ifac[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(2*a[i]-1);\n\t}\n\tans=(ans+1ll*res*cal(w,pos))%mod;\n}\nvoid dfs(int w,int z,int last){\n\tcalc(w,z-1);\n\tif(last==1&&w-1>=0) g[z]=1,dfs(w-1-(z>1),z+1,1); \n\tfor(int i=max(2,last);w-(i-1)-(i-2)>=0;++i){\n\t\tg[z] = i,dfs(w-(i-1)-(i-2)-(z>1),z+1,i);\n\t}\n\tg[z] = 0;\n}\nint main(){\n\tans=0;\n\tinit(); \n\tdfs(n,1,1);\n\twriteln(ans);\n}"
  },
  {
    "language": "C++",
    "code": "//Create Time: 2018-05-01 16:03:26\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <functional>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cctype>\n#include <ctime>\n#include <utility>\n#include <complex>\n#include <cassert>\n#include <climits>\n#include <iterator>\n#include <tuple>\nusing namespace std;\n#define snuke(i,x) for (__typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)\n#define rep(i,a,n) for (int i=(a);i<(n);i++)\n#define per(i,n,a) for (int i=(n)-1;i>=(a);i--)\n// #define OUT(x) std::cout<<(#x)<<\":\"<<(x)<<std::endl\n// #define TST(x) std::cout<<(#x)<<\":\"<<(x)<<\" \"\n#define OUT(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\\n\",_it,args);}\n#define TST(args...) {string _s=#args;replace(_s.begin(),_s.end(),',',' ');stringstream _ss(_s);istream_iterator<string> _it(_ss);OUT_TST(\"\",_it,args);}\n#define SZ(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\n#define unq(x) sort(all(x)),(x).erase(unique(all(x)),(x).end())\n#define mem(f,x) memset((f), (x), sizeof(f))\n#define clr(f) mem(f,0)\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define eb emplace_back\n#define DEBUG\nvoid OUT_TST(string s,istream_iterator<string> it) {cerr<<s;}\ntemplate<typename T, typename... Args> void OUT_TST(string s,istream_iterator<string> it,T a,Args... args){cerr<<*it<<\"=\"<<a<<\" \";OUT_TST(s,++it,args...);}\ntemplate<class T> void rd(T&ret){ret=0;bool ok=0,u=0;for(;;){int c=getchar();if(c>='0'&&c<='9')ret=(ret<<3)+(ret<<1)+c-'0',ok=1;else if(c=='-')u=1;else if(ok){if(u)ret*=-1;return;}}}\nlong long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\ntemplate <class T> bool chmin(T& a, const T &b) {return b < a? a = b, 1: 0;}\ntemplate <class T> bool chmax(T& a, const T &b) {return b > a? a = b, 1: 0;}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii > vii;\ntypedef tuple<int,int,int> tp;\n/****head****/\nconst ll mod=(ll)1e9+7;\n\ntemplate<int sz> struct Comb{\n    const ll mod = ::mod;\n    ll *fac, *ifac;\n    ll mem_fac[sz+5],mem_ifac[sz+5];\n\n    // long long powmod(long long p,long long n,long long mod){long long ret=1;for(;n;n>>=1){if(n&1)ret=ret*p%mod;p=p*p%mod;}return ret;}\n\n    Comb(ll *fa=0,ll *ifa=0){\n        fac=fa?fa:mem_fac;\n        ifac=ifa?ifa:mem_ifac;\n        fac[0]=ifac[0]=1;\n        for(int i=1;i<sz;++i){\n            fac[i]=i*fac[i-1]%mod;\n            ifac[i]=powmod(fac[i],mod-2,mod);\n        }\n    }\n    ll C(ll n,ll m){  // n >= m\n        if(n<m)return 0;\n        return (fac[n]*ifac[m]%mod)*ifac[n-m]%mod;\n    }\n    ll A(ll n,ll m){\n        if(n<m)return 0;\n        return fac[n]*ifac[n-m]%mod;\n    }\n};\n\nconst int N=87;\nll fac[N],ifac[N];\nComb<N> comb(fac,ifac);\n\nvector<vii> trans;\nint n,m,dp[77][77],pos[77],pos_top,clk,cnt_r,cnt_b,flag[77],can[77],can_top;\nll ans;\nstring s;\nvector<vi> state;\nvoid add(int &a,int b){\n    a+=b;if(a>=mod)a-=mod;\n}\nvoid DP(){\n    if(pos_top==0){\n        ++ans;return;\n    }\n    clr(dp);\n    dp[pos_top][0]=1;\n    int up=1,nxt,dn=0,ndn,nup;\n    per(i,pos_top,0){\n        ndn=100;\n        nup=up;\n        rep(j,dn,up)if(dp[i+1][j]){\n            for(auto k:trans[pos[i]]){\n                if(j==0){\n                    nxt=k.x;\n                    add(dp[i][nxt],(ll)dp[i+1][j]*k.y%mod);\n                    add(dp[i][nxt+1],(ll)2*dp[i+1][j]*k.y%mod);\n                    add(dp[i][nxt+2],(ll)dp[i+1][j]*k.y%mod);\n                    chmax(nup,nxt+3);\n                    chmin(ndn,nxt);\n                } else {\n                    nxt=j+k.x+1;\n                    add(dp[i][nxt],(ll)dp[i+1][j]*k.y%mod);\n                    // OUT(i+1,j,dp[i+1][j],nxt,dp[i][nxt]);\n                    chmax(nup,nxt+1);\n                    chmin(ndn,nxt);\n                }\n                if(nup>n)nup=n+1;\n            }\n        }\n        dn=ndn;up=nup;\n    }\n\n    ll xi=fac[pos_top];\n    int c=0;\n    rep(i,0,pos_top){\n        if(!i || pos[i]==pos[i-1])++c;\n        else {\n            xi=xi*ifac[c]%mod;\n            c=1;\n        }\n        if(i==pos_top-1)xi=xi*ifac[c]%mod;\n    }\n    // ll tmp;\n    rep(i,0,up)if(dp[0][i]){\n        // OUT(i,dp[0][i],xi,comb.C(n-1,i-1));\n        // tmp=xi*dp[0][i]%mod;\n        // \"R\" could be \"WRW\",\"\n        // if(i<=n) ans+=tmp*comb.C(n-1,i-1)%mod;\n        // if(i+1<=n) ans+=tmp*comb.C(n-1,i)*2ll%mod;\n        // if(i+2<=n) ans+=tmp*comb.C(n-1,i+1)%mod;\n        ans+=xi*comb.C(n-1,i-1)%mod *dp[0][i]%mod;\n        if(ans>=mod)ans-=mod;\n    }\n}\n/*\nbool check(){\n    if(top==0)return 1;\n    clk++;\n    int cr=top,c1=0;\n    rep(i,0,top){\n        if(pos[i]==1)c1++;\n        if(pos[i]>=2)break;\n    }\n    int cb=top-c1;\n    if(cr>cnt_r)return 0;\n    if(cb>cnt_b)return 0;\n    // TST(\"139\",c1,cb,cr);\n\n    if(c1==top)return 1;\n\n    static int stk[77],stk_top;\n    stk_top=0;\n    int i=0,j=0;\n    for(int _=0;_<top-c1;++_){\n        while(i<m && s[i]!='r')++i;\n        while(j<m && (j<=i || s[j]!='b')){\n            if(s[j]=='b' && _==0)flag[j]=clk;\n            ++j;\n        }\n        // TST(i,j);\n        if(j>=m)return 0;\n        flag[i]=flag[j]=clk;\n        stk[stk_top++]=j;\n        ++i;++j;\n    }\n    stk[stk_top++]=m;\n    for(i=0;c1>0;--c1){\n        while(i<m && !(flag[i]!=clk && s[i]=='r'))++i;\n        if(i>=m)return 0;\n        flag[i]=clk;\n    }\n    ll sum=0;\n    for(int i=c1,j=stk_top-2;j>=0 && i<top;++i,--j){\n        rep(k,stk[j],stk[j+1])if(flag[k]!=clk)++sum;\n        sum-=pos[i]-2;\n        if(sum<0)return 0;\n    }\n    return 1;\n}\nint ok_cnt;\nvoid dfs(int p,int s,int cr,int cb){\n    if(p+s>m){\n        if(check()){\n            // TST(top);rep(i,0,top)TST(pos[i]);printf(\"YES \");\n            // TST(ans);\n            // DP();\n            ++ok_cnt;\n            // OUT(ans);\n        } else{\n            // TST(top);rep(i,0,top)TST(pos[i]);puts(\"NO\");\n        } return;\n    }\n    for(int i=0;;++i){\n        if(s+i*p>m)break;\n        rep(j,0,i)pos[top++]=p;\n        dfs(p+1,s+i*p);\n        top-=i;\n    }\n}\n*/\nint ok_cnt;\nvector<vi > output;\nbool output_flag;\nvoid dfs(int p,int ci,int yu,int ns){\n    // if(output_flag && ci==5)OUT(p,ci,yu,ns);\n    if(ns>n)return;\n    if(ci==can_top){\n        ++ok_cnt;\n        // TST(ns);\n        // rep(i,0,pos_top)TST(pos[i]);\n        // puts(\"\");\n        // vi tmp;\n        // rep(i,0,pos_top)tmp.pb(pos[i]);\n        // output.pb(tmp);\n        DP();\n        return;\n    }\n    if(p-2>yu+can[ci])return;\n    dfs(p+1,ci,yu,ns);\n    pos[pos_top++]=p;\n    dfs(p,ci+1,can[ci]+yu-(p-2),ns+2*p-2);\n    pos_top--;\n}\nint main(){\n    trans.resize(71);\n    trans[1]={{1,1}};\n    trans[2]={{1,1},{2,2},{3,1}};\n    rep(i,3,71){\n        trans[i].clear();\n        trans[i].eb(i*2-3,1);\n        trans[i].eb(i*2-2,2);\n        trans[i].eb(i*2-1,1);\n    }\n\n    cin>>n>>m>>s;\n    m=SZ(s);\n    rep(i,0,m){\n        if(s[i]=='r')++cnt_r;\n        if(s[i]=='b')++cnt_b;\n    }\n    static int stk[77],stk_top;\n    rep(i,0,cnt_r+1)rep(j,0,min(cnt_b,cnt_r-i)+1){\n        if(!i && !j){\n            ++ans;continue;\n        }\n        ++clk;\n        pos_top=0;\n        rep(k,0,i)pos[pos_top++]=1;\n        int t1=0,t2=0;\n        stk_top=0;\n        bool gg=0;\n        rep(_,0,j){\n            while(t1<m && s[t1]!='r')++t1;\n            while(t2<m && !(t2>t1 && s[t2]=='b')){\n                if(s[t2]=='b' && _==0)flag[t2]=clk;\n                ++t2;\n            }\n            if(t2>=m){gg=1;break;}\n            stk[stk_top++]=t2;\n            flag[t1]=flag[t2]=clk;\n            ++t1;++t2;\n        }\n        // if(i==0 && j==1)OUT(gg);\n        // if(i==1 && j==0)OUT(gg);\n        t1=0;\n        rep(k,0,i){\n            while(t1<m && !(flag[t1]!=clk && s[t1]=='r'))++t1;\n            flag[t1]=clk;\n        }\n\n        if(gg)continue;\n        stk[stk_top++]=m;\n        // if(i==1&&j==6){\n            // OUT(\"debug\");\n            // rep(i,0,stk_top)TST(stk[i]);puts(\"\");\n            // OUT(clk);\n            // rep(i,0,m)TST(flag[i]);puts(\"\");\n            // OUT(flag[12]);OUT(flag[13]);\n        // }\n        can_top=0;\n        per(k,stk_top-1,0){\n            int c=0;\n            rep(t,stk[k],stk[k+1])if(flag[t]!=clk)++c;\n            can[can_top++]=c;\n        }\n        // if(i==1 && j==6){\n            // output_flag=1;\n            // rep(i,0,can_top)TST(can[i]);\n            // dfs(2,0,0,2*i-1);\n            // assert(false);\n        // }\n        dfs(2,0,0,2*i-1);\n    }\n    ans%=mod;\n    cout<<ans<<endl;\n    OUT(ok_cnt);\n\n    // sort(all(output));\n    // for(auto i:output){\n        // for(int j:i)printf(\"%d \",j);\n        // puts(\"\");\n    // }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<ll, ll> ll_ll;\nstruct edge { int v, w; };\nconst int INF = INT_MAX / 2;\nconst int MOD = 1e9 + 7;\nconst ll e18 = 1e18;\n\nll dp[72][71][71][36], C[100][100], unko[100][100];\n\nll H(int x, int y) {\n\tif (!y) return !x;\n\treturn C[x - 1][y - 1];\n}\n\nint main() {\n\trep(x, 100) {\n\t\tC[x][0] = 1;\n\t\tfor (int y = 1; y <= x; y++)\n\t\t\tC[x][y] = (C[x - 1][y - 1] + C[x - 1][y]) % MOD;\n\t}\n\tfor (int d = 1; d < 100; d++)\n\t\tfor (int b = 1; b <= (d + 1) / 2; b++)\n\t\t\tfor (int r = b - 1; r <= b + 1; r++)\n\t\t\t\tif (b + r <= d) {\n\t\t\t\t\tunko[d][b] = (unko[d][b] + H(d, b + r)) % MOD;\n\t\t\t\t\tif (b == r) unko[d][b] = (unko[d][b] + H(d, b + r)) % MOD;\n\t\t\t\t}\n\tint N, M; cin >> N >> M;\n\tstring s; cin >> s;\n\tint R = 0, L = 0;\n\trep(j, M) {\n\t\tif (s[j] == 'r') R++;\n\t\tif (s[j] == \"rb\"[L % 2]) L++;\n\t}\n\tL /= 2;\n\tdp[0][0][0][0] = 1;\n\trep(i, N + 1) rep(r, R + 1) rep(s, M + 1) rep(l, L + 1) {\n\t\tll z = dp[i][r][s][l];\n\t\tif (!z) continue;\n\t\tdp[i + 1][r][s][l] = (dp[i + 1][r][s][l] + z) % MOD;\n\t\tif (r == R) continue;\n\t\tfor (int d = 1; i + d <= N; d++) {\n\t\t\tint j = i + d + 1;\n\t\t\tif (s + 1 <= M)\n\t\t\t\tdp[j][r + 1][s + 1][l] = (dp[j][r + 1][s + 1][l] + z) % MOD;\n\t\t\tif (l == L) continue;\n\t\t\tfor (int b = 1; b <= (d + 1) / 2 && s + b + 1 <= M; b++)\n\t\t\t\tdp[j][r + 1][s + b + 1][l + 1] = (dp[j][r + 1][s + b + 1][l + 1] + z * unko[d][b]) % MOD;\n\t\t}\n\t}\n\tll ans = 0;\n\trep(r, R + 1) rep(s, M + 1) rep(l, L + 1)\n\t\tans = (ans + dp[N + 1][r][s][l]) % MOD;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint fac[150], ifac[150], ans, n, k;\nbool del[75];\nvector<int> f, r;\nchar s[75];\n\nint power(int a, int x) {\n\tint ans = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % P)\n\t\tif (x & 1) ans = 1ll * ans * a % P;\n\treturn ans;\n}\n\nbool check() {\n\tfill(del + 1, del + 1 + k, false);\n\tfor (int i = 0; i < f.size(); ++i) del[r[i]] = true;\n\tvector<int> b(f.size());\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 2) {\n\t\t\tint j;\n\t\t\tfor (j = r[f.size() - 1 - i] + 1; (del[j] || s[j] == 'r') && j <= k; ++j);\n\t\t\tif (j > k) return false;\n\t\t\tb[i] = j;\n\t\t\tdel[j] = true;\n\t\t}\n\tfor (int i = f.size() - 1; i >= 0; --i)\n\t\tif (f[i] >= 3) {\n\t\t\tint cnt = f[i] - 2;\n\t\t\tfor (int j = b[i] + 1; cnt && j <= k; ++j)\n\t\t\t\tif (!del[j]) del[j] = true, --cnt;\n\t\t\tif (cnt) return false;\n\t\t}\n\treturn true;\n}\n\nvoid dfs(int lst, int sum) {\n\tif (f.size() > r.size()) return;\n\tif (check()) {\n\t\tint s = n + 1, c = fac[f.size()], s1 = 0;\n\t\tfor (int i = 0, j; i < f.size(); i = j) {\n\t\t\tfor (j = i + 1; j < f.size() && f[j] == f[i]; ++j);\n\t\t\tc = 1ll * c * ifac[j - i] % P;\n\t\t\tif (f[i] > 1) s += 2 * (j - i);\n\t\t\ts1 += 2 * f[i] * (j - i);\n\t\t}\n\t\tans = (ans + 1ll * c * fac[s] % P * ifac[s1] % P * ifac[s - s1]) % P;\n\t}\n\tfor (int i = lst; (sum + max(1, i - 1)) * 2 <= n + 1; ++i) f.push_back(i), dfs(i, sum + max(1, i - 1)), f.pop_back();\n}\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &k, s + 1);\n\tfor (int i = 1; i <= k; ++i)\n\t\tif (s[i] == 'r') r.push_back(i);\n\tfor (int i = fac[0] = 1; i <= 2 * n + 5; ++i) fac[i] = 1ll * fac[i - 1] * i % P;\n\tifac[2 * n + 5] = power(fac[2 * n + 5], P - 2);\n\tfor (int i = 2 * n + 5; i; --i) ifac[i - 1] = 1ll * ifac[i] * i % P;\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=75;\nint n,K,i,j,s1,s2,C[N*2][N*2],st[N],w,b,x,y,ans=1,a[N];\nchar c[N];\nvoid dfs(int d,int s,int ss,bool fl){\n\tif(fl){\n\t\tbool ff=0;\n\t\tfor(i=1,j=w,b=0;i<=K;++i){\n\t\t\tif(c[i]=='r'){if(j)b+=st[j--],ff=1;else if(b)--b;}\n\t\t\tif(c[i]=='b' && b)--b;if(!b)ff=0;\n\t\t}\n\t\tif(!j && !b){\n\t\t\ts1=s-1,s2=ss+1,x=C[n-s1+s2-1][s2-1];y=0;\n\t\t\tfor(i=0;i<d;++i)y+=a[i],x=1ll*C[y][a[i]]*x%mo;\n//for(i=1;i<=w;++i)printf(\"%d \",st[i]);printf(\"a%d %d %d\\n\",s1,s2,x);\n\t\t\tans=(ans+x)%mo;\n\t\t}\n\t}\n\tif(s+(d<2?1:d*2-1)>n)return;\n\tint ow=w;\n\tfor(int i=0,j;s+i*(d<2?1:d*2-1)+i-1<=n;st[++w]=d,++i)\n\t\ta[d]=i,dfs(d+1,s+i*(d<2?1:d*2-1)+i,ss+i*(d*2+1)+i,i);\n\tw=ow;\n}\nint main(){\n\tfor(i=**C=1;i<N*2;++i)for(j=*C[i]=1;j<=i;++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mo;\n\tscanf(\"%d%d%s\",&n,&K,c+1);\n\tdfs(0,0,0,0);\n\tprintf(\"%d\\n\",ans%mo);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 1000000007\nusing namespace std;\nchar s[75];int n,K,ans,a[75],p[205],inv[205];\ninline int C(int n,int m){return 1LL*p[n]*inv[m]%mod*inv[n-m]%mod;}\nvoid Check(int num,int sum)\n{\n\tint pos=num+1,res=p[num],rnum=0,leftr=0,nxt=1,left=0;\n\tfor(int i=1;i<=K;++i)\n\t\tif(s[i]=='r') rnum<num?leftr+=(a[++rnum]>1):(left?--left:0);\n\t\telse leftr?(--leftr,left+=a[nxt]-2,++nxt):(left?--left:0);\n\tif(left||rnum<num||leftr) return;\n\tfor(int i=1,j;i<=num;i=j+1)\n\t{\n\t\tfor(j=i;j<num&&a[j+1]==a[i];++j);\n\t\tres=1LL*res*inv[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(a[i]*2-1);\n\t}\n\tans=(ans+1LL*res*C(n-sum+pos-1,pos-1))%mod;\n}\nvoid dfs(int x,int num,int sum)\n{\n\tif(sum>n) return;Check(num,sum);\n\tfor(int i=x;i;--i) a[num+1]=i,dfs(i,num+1,sum+(i>1?i*2-3:1)+(num>0));\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&K,s+1);\n\tp[0]=inv[0]=p[1]=inv[1]=1;\n\tfor(int i=2;i<=200;++i) p[i]=1LL*p[i-1]*i%mod,inv[i]=1LL*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(int i=2;i<=200;++i) inv[i]=1LL*inv[i-1]*inv[i]%mod; \n\tdfs(n,0,0);cout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=1e9+7;\n\nint n,k,comb[233][233],tot,tot2,ma[111],mb[111];\nchar s[111];\n\nint c[111],ans,use[111];\nvoid dfs(int mx,int cnt,int sum,int coef)\n{\n\tif(cnt+sum-1>n)return;\n\tif(cnt>tot)return;\n\tif(mx==0)\n\t{\n\t\tif(cnt==0)\n\t\t{\n\t\t\tans++;if(ans>=mod)ans-=mod;\n\t\t\treturn;\n\t\t}\n\t\tif(cnt-c[1]>tot2)return;\n\t\t\n\t\tbool ok=1;int cur=0;\n\t\tmemset(use,0,sizeof(use));\n\t\tfor(int i=(n+3)>>1;i>0;i--)\n\t\t{\n\t\t\tfor(int j=1;j<=c[i];j++)\n\t\t\t{\n\t\t\t\tcur++;\n\t\t\t\tuse[ma[cur]]=1;\n\t\t\t\tuse[mb[cur]]=i-1;\n\t\t\t}\n\t\t}\n\t\tcur=0;\n\t\tfor(int i=k;i>=1&&ok;i--)\n\t\t{\n\t\t\tcur++;\n\t\t\tif(cur<use[i])ok=0;\n\t\t\telse cur-=use[i];\n\t\t}\n\t\tif(ok)\n\t\t{\n\t\t\tint have=n-cnt-sum+1,need=sum+cnt+1+(cnt-c[1])*2;\n\t\t\tans=(ans+1ll*coef*comb[have+need-1][need-1])%mod;\n\t\t}\n\t\treturn;\n\t}\n\tfor(c[mx]=0;c[mx]<=n;c[mx]++)dfs(mx-1,cnt+c[mx],sum+c[mx]*(mx==1?1:mx+mx-3),coef*1ll*comb[cnt+c[mx]][cnt]%mod);\n}\n\nint main()\n{\n\tfor(int i=0;i<233;i++)\n\t{\n\t\tcomb[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t{\n\t\t\tcomb[i][j]=comb[i-1][j]+comb[i-1][j-1];\n\t\t\tif(comb[i][j]>=mod)comb[i][j]-=mod;\n\t\t}\n\t}\n\tget2(n,k);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=k;i++)if(s[i]=='r')\n\t{\n\t\tint j=i;\n\t\tfor(;j<=n;j++)if(s[j]=='b'&&!use[j])break;\n\t\ttot++;tot2+=(j<=n);\n\t\tma[tot]=i;mb[tot]=j;\n\t\tuse[j]=1;\n\t}\n\tdfs((n+3)/2,0,0,1);\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=5e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=72;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();PRE();\n\t\tscanf(\"%s\",str+1);int R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,R-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tif(!cc) add(g[0][i+ii][j+1],g[0][i][j]);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tll V=Comb(ii-1,cc*2-2)+Comb(ii-1,cc*2-1)*2+Comb(ii-1,cc*2);V%=MOD;\n\t\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*V%MOD);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfo(i,0,n) fo(j,0,R) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tfo(i,0,n-S) fo(j,0,R-t) if(go[cnt][ln][t][j]<=blu[m])\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*Comb(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::main();\n\t//debug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int inc(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=505;\nchar s[N];int a[N],b[N],f[N],g[N],C[N][N],st[N],fac[N],ifac[N],n,L,res;\ninline int max(R int x,R int y){return x>y?x:y;}\n//inline int calc(){\n//\tint s=0,t=0;\n//\tt=n-(top-1),s=top+1;\n//\tfp(i,1,top)s+=(st[i]<<1)-1,t-=max((st[i]<<1)-3,1);\n//\treturn s-1<0||t<0?0:C[s+t-1][s-1];\n//}\nbool ck(int top){\n\tfp(i,1,top)a[i]=st[i];\n\tsort(a+1,a+1+top,[](const int &x,const int &y){return x>y;});\n\tfp(i,1,n)b[i]=0;\n\tfor(R int i=1,j=1;i<=top;++i){\n\t\twhile(j<=n&&s[j]!='r')++j;\n\t\tif(j>n)return false;\n\t\tf[i]=j,b[j]=1,++j;\n\t}\n\tfor(R int i=1,j=1;i<=top&&a[i]>=2;++i){\n\t\tcmax(j,f[i]+1);\n\t\twhile(j<=n&&s[j]!='b')++j;\n\t\tif(j>n)return false;\n\t\tg[i]=j,b[j]=1,++j;\n\t}\n\tfor(R int i=1,j=1,r;i<=top&&a[i]>=3;++i){\n\t\tcmax(j,g[i]+1),r=a[i]-2;\n//\t\tprintf(\"%d %d\\n\",i,j);\n\t\twhile(j<=n&&r)r-=!b[j],++j;\n\t\tif(r)return false;\n\t}\n//\tfp(i,1,top)printf(\"%d%c\",st[i],\" \\n\"[i==top]);\n//\tputs(\"---------------\");\n\t\n\treturn true;\n}\ninline int calc(R int top){\n\tR int res=fac[top];\n\tfor(R int i=1,j=1;i<=top;i=j){\n\t\twhile(j<=top&&st[i]==st[j])++j;\n\t\tres=mul(res,ifac[j-i]);\n\t}\n\treturn res;\n}\nvoid dfs(int pos,int s,int t,int lim){\n\tif(ck(pos-1))upd(res,mul(C[s+t-1][s-1],calc(pos-1)));\n//\tif(st[pos-1]==3)printf(\"qwq %d %d %d\\n\",pos,s,t);\n\tif(t<=1)return;\n\tfor(int i=lim,rt;i<=t;++i){\n\t\trt=t-max((i<<1)-3,1)-1;\n\t\tif(rt<0)return;\n\t\tst[pos]=i,dfs(pos+1,s+(i<<1)-1+1,rt,i);\n\t}\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&L,&n);\n\tscanf(\"%s\",s+1);\n\tC[0][0]=fac[0]=ifac[0]=1;\n\tfp(i,1,500){\n\t\tC[i][0]=1,fac[i]=mul(fac[i-1],i);\n\t\tfp(j,1,i)C[i][j]=inc(C[i-1][j],C[i-1][j-1]);\n\t}\n\tifac[500]=ksm(fac[500],P-2);fd(i,499,1)ifac[i]=mul(ifac[i+1],i+1);\n//\tst[1]=3,st[2]=1,printf(\"%d\\n\",ck(2));\n\tdfs(1,1,L+1,1);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MOD (1000000007)\nusing namespace std;\nconst int MAXN = 75;\ntypedef long long LL;\nint N, M, A[MAXN], minLen[MAXN], Belong[MAXN], Last[MAXN],KK,LLL;\nchar S[MAXN];\nLL Data[MAXN][MAXN], C[MAXN][MAXN], Fact[MAXN], factIne[MAXN], Ine[MAXN], Ans;\ninline void Init()\n{\n\tfor(int I = 0; I <= 70; ++I)C[I][0] = 1;\n\tfor(int I = 1; I <= 70; ++I)\n\t\tfor(int J = 1; J <= I; ++J){\n\t\t\tC[I][J] = C[I - 1][J] + C[I - 1][J - 1];\n\t\t\tif(C[I][J] >= MOD)C[I][J] -= MOD;\n\t\t}\n\tFact[1] = 1;\n\tIne[1] = Ine[0] = 1;\n\tfactIne[1] = factIne[0] = 1;\n\tfor(int I = 2; I <= 70; ++I){\n\t\tFact[I] = Fact[I - 1] * I % MOD;\n\t\tIne[I] = (LL)(MOD - MOD / I) * Ine[MOD % I] % MOD;\n\t\tfactIne[I] = (LL)factIne[I - 1] * Ine[I] % MOD;\n\t}\n}\ninline bool Check(vector<int> Seq)\n{\n\tmemset(Belong, -1, sizeof(Belong));\n\tmemset(Last, 0, sizeof(Last));\n\tint Size = Seq.size(), P = 0;\n\tif(!Size)return false;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'r'){\n\t\t\tBelong[I] = P;\n\t\t\tLast[P] = I;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tP = 0;\n\twhile(!Seq[Size - 1])--Size;\n\tif(!Size)return true;\n\tfor(int I = 1; I <= M; ++I){\n\t\tif(S[I] == 'b' && I > Last[P]){\n\t\t\tBelong[I] = P;\n\t\t\t++P;\n\t\t\tif(P == Size)break;\n\t\t}\n\t}\n\tif(P < Size)return false;\n\tint Free = 0;\n\tfor(int I = M; I; --I){\n\t\tif(Belong[I] == -1)++Free;\n\t\telse if(S[I] == 'b'){\n\t\t\tint Need = Seq[Belong[I]] + 1 - 2;\n\t\t\tif(Need > Free)return false;\n\t\t\tFree -= Need;\n\t\t}\n\t}\n\treturn true;\n}\ninline void Calc(int Len, vector<int> Seq, vector<LL> V)\n{\n/*\tcout<<\"Working...\"<<endl;\n\tfor(int I = 1; I <= N; ++I)cout<<V[I]<<\" \";\n\tcout<<endl;*/\n\tLL Now = 0;\n\tint Size = Seq.size();\n\tfor(int X = Len; X <= N; ++X){\n\t\tint Left = N - (Size - 1) - X;\n\t\tNow += (LL)V[X] * C[Left + Size][Size] % MOD;\n\t\tif(Now >= MOD) Now -= MOD;\n\t}\n\tint Cnt[MAXN] = {0};\n\tfor(int I = 0; I < Size; ++I)++Cnt[Seq[I]];\n\tNow = Now * Fact[Size] % MOD;\n\tfor(int I = 0; I <= M; ++I)\n\t\tif(Cnt[I] > 1)Now = Now * factIne[Cnt[I]] % MOD;\n\tAns += Now;\n\tif(Ans >= MOD)Ans -= MOD;\n}\nvoid Dfs(int Len, int Rest, int maxSpace, vector<int> Seq, vector<LL> V, bool needCalc, int Tot)\n{\n\tif(needCalc && Check(Seq))Calc(Tot, Seq, V),++KK;\n\tif(Len < 0)return;\n\tDfs(Len - 1, Rest, maxSpace, Seq, V, 0, Tot);\n\tif(Len + 1 > Rest || minLen[Len] > maxSpace)return;\n\tvector<LL> newV(MAXN);\n\tfor(int I = 0; I <= 70; ++I){\n\t\tif(V[I]){\n\t\t\tfor(int J = I + minLen[Len]; J <= N; ++J){\n\t\t\t\tnewV[J] += (LL)V[I] * Data[Len][J - I] % MOD;\n\t\t\t\tif(newV[J] >= MOD)newV[J] -= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tSeq.push_back(Len);\n\tDfs(Len, Rest - Len - 1, maxSpace - minLen[Len] - 1, Seq, newV, 1, Tot + minLen[Len]);\n}\nint main()\n{\n\tInit();\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tfor(int I = 1; I <= N; ++I)\n\t\tData[0][I] = 1;\n\tminLen[0] = 1;\n\tfor(int I = 1; I <= N; ++I){\n\t\tint T[5] = {I * 2 - 1, I * 2, I * 2, I * 2 + 1};\n\t\tminLen[I] = T[0];\n\t\tif(T[0] > N)break;\n\t\tfor(int J = 0; J < 5; ++J)\n\t\t\tfor(int K = T[J]; K <= N; ++K){\n\t\t\t\tData[I][K] += C[K - 1][T[J] - 1];\n\t\t\t\tif(Data[I][K] >= MOD) Data[I][K] -= MOD;\n\t\t\t}\n\t}\n\tvector<int> V1;\n\tvector<LL> V2(MAXN);\n\tV2[0] = 1;\n\tDfs(N / 2, M, N, V1, V2, 0, 0);\n\tcout << Ans + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 80;\nconst int mod = 1000000007;\ntypedef long long LL;\nvoid reduce(int & x) { x += x >> 31 & mod; }\nint mul(int a, int b) { return (LL) a * b % mod; }\nint fastpow(int a, int b, int res = 1) {\n\tfor (; b; b >>= 1, a = mul(a, a)) if (b & 1) res = mul(res, a);\n\treturn res;\n}\nint li[MAXN];\nchar buf[MAXN];\nint n, K, ans;\nconst int MAXS = 300;\nint tl[MAXN], C[MAXS][MAXS];\nint fac[MAXN], inv[MAXN];\nvoid dfs(int S, int rest, int can, int lst) {\n\tif (rest < 0) return ;\n\tmemcpy(tl + 1, li + 1, S << 2);\n\tint cur1 = 1, cur2 = 1, cur3 = 1;\n\tfor (int i = 1; i <= K; ++i) {\n\t\tbool ok = false;\n\t\tif (cur1 <= S && buf[i] == 'r') {\n\t\t\t++cur1; ok = true;\n\t\t}\n\t\twhile (cur2 < cur1 && tl[cur2] == 0) ++cur2;\n\t\tif (!ok && cur2 + 1 <= cur1 && buf[i] == 'b') {\n\t\t\t--tl[cur2++]; ok = true;\n\t\t}\n\t\tif (!ok && cur3 < cur2 && tl[cur3]) --tl[cur3];\n\t\twhile (cur3 < cur2 && tl[cur3] == 0) ++cur3;\n\t}\n\tif (cur3 <= S) return ;\n\tint tx = mul(C[can + rest - 1][can - 1], fac[S]);\n\tstatic int hav[MAXN];\n\tmemset(hav, 0, n + 1 << 2);\n\tfor (int i = 1; i <= S; ++i) ++hav[li[i]];\n\tfor (int i = 0; i <= n; ++i) if (hav[i]) tx = mul(tx, inv[hav[i]]);\n\treduce(ans += tx - mod);\n\tfor (int i = lst; ~i; --i) {\n\t\tli[S + 1] = i;\n\t\tdfs(S + 1, rest - std::max(i, 1) * 2 + (S == 0), can + (i + 1) * 2, i);\n\t}\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tfor (int i = 0; i != MAXS; ++i) {\n\t\tC[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j)\n\t\t\treduce(C[i][j] = C[i - 1][j] + C[i - 1][j - 1] - mod);\n\t}\n\tstd::cin >> n >> K >> buf + 1;\n\tinv[0] = inv[1] = fac[0] = fac[1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tinv[i] = mul(inv[mod % i], mod - mod / i);\n\t\tfac[i] = mul(fac[i - 1], i);\n\t}\n\tfor (int i = 2; i <= n; ++i) inv[i] = mul(inv[i - 1], inv[i]);\n\tdfs(0, n, 1, n);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\nint ts = 0;\nvoid calc(int sz) {\n    ts++;\n    int tb = 0, tr = 0;\n    int used[77], TR[77], TB[77];\n    memset(used, 0, sizeof used);\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        used[tr] = 1;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && (ch[tb] != 'b' || used[tb])) tb++;\n            used[tb] = 1;\n            TR[i] = tr;\n            TB[i] = tb;\n        } else {\n            TR[i] = tr;\n            TB[i] = tr;\n        }\n        if(tr > K || tb > K) return;\n    }\n    for(int i = 1; i <= sz; i++) {\n        int tt = TB[i] + 1;\n        for(int j = 1; j <= X[i] - 2; j++) {\n            while(tt <= K && used[tt]) tt++;\n            if(tt > K) return;\n        }\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tot = 0) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K && max(2ll, i * 2 - 2) + tot <= n + 7; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tot + max(2ll, i * 2 - 2));\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    //printf(\"%d\\n\", ts);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mem(x,v) memset(x,v,sizeof(x))\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\ninline ll read(){\n    ll x=0;int f=1;char c=gc();\n    for(;!isdigit(c);c=gc())if(c=='-')f=-1;\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return x*f;\n}\ninline void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\ninline void writeln(ll x){write(x);pc('\\n');}\ninline void wri(ll x){write(x);pc(' ');}\nconst int maxn = 255;\nconst int mod = 1e9+7;\nint n,m;\nchar s[maxn];\nint ans,fac[maxn],ifac[maxn];\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nvoid init(){\n\tn = read(),m = read();\n\tscanf(\"%s\",s+1);\n\tfac[0] = 1;rep(i,1,maxn) fac[i] = 1ll * fac[i-1] * i % mod;\n\tifac[maxn-1] = qpow(fac[maxn-1],mod-2);\n\tDep(i,maxn-2,0) ifac[i] = 1ll * ifac[i+1] * (i+1) % mod;\n\tassert(ifac[0]==1);\n}\ninline int C(int n,int m){\n\treturn 1ll * fac[n] * ifac[m] % mod * ifac[n-m] % mod;\n}\n#define cal(x,y) C((x)+(y)-1,(y)-1)\nint g[maxn],a[maxn];\nvoid calc(int w,int tot){\n\tRep(i,1,tot) a[i] = g[tot-i+1];a[tot+1]=0;\n\tint lim=0;while(lim<tot && a[lim+1]>1) ++lim;\n\tint i,j,k,l,t;\n\tfor(i=1,k=1,l=1,t=0;i<=m;++i){\n\t\tif(s[i]=='r' && k<=tot) \n\t\tk++; else\n\t\tif(s[i]=='b' && l<k && l<=lim) t+=a[l]-2,l++; else\n\t\tif(t) t--; \n\t}\n\tif(k<=tot || l<=lim || t) return ;\n\tint pos=tot+1,res=fac[tot];\n\tfor(i=1;i<=tot;i=j+1){\n\t\tfor(j=i;a[j+1]==a[i];++j);\n\t\tres=1ll*res*ifac[j-i+1]%mod;\n\t\tpos+=(j-i+1)*(2*a[i]-1);\n\t}\n\tans=(ans+1ll*res*cal(w,pos));\n}\nvoid dfs(int w,int z,int last){\n\tcalc(w,z-1);\n\tif(last==1&&w-1>=0) g[z]=1,dfs(w-1-(z>1),z+1,1); \n\tfor(int i=max(2,last);w-(i-1)-(i-2)>=0;++i){\n\t\tg[z] = i,dfs(w-(i-1)-(i-2)-(z>1),z+1,i);\n\t}\n\tg[z] = 0;\n}\nint main(){\n\tans=0;\n\tinit(); \n\tdfs(n,1,1);\n\twriteln(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define int long long\n\n#define left __left__\n\n#define QAQ cout<<\"QAQ\"<<endl\n\nconst int N=70+10;\n\nconst int A=520;\n\nconst int MOD=1000000007;\n\nint n,k;\n\nchar s[N];\n\nint C[A][A];\n\nvoid prework()\n{\n\tint i,j;\n\tfor(i=0;i<A;++i)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(j=1;j<=i;++j)\n\t\t\tif((C[i][j]=C[i-1][j-1]+C[i-1][j])>=MOD)\n\t\t\t\tC[i][j]-=MOD;\n\t}\n}\n\nint ans;\n\nint B[N],ed,left;\n\nbool valid()\n{\n\tif(!ed)\n\t\treturn false;\n\tint i,j=1,jj=1,c=0;\n\tfor(i=1;i<=k&&(j<=ed||B[jj]>1||c);++i)\n\t{\n\t\tif(j<=ed&&s[i]=='r')\n\t\t\t++j;\n\t\telse if(jj<j&&B[jj]>1&&s[i]=='b')\n\t\t\tc+=B[jj++]-2;\n\t\telse if(c)\n\t\t\t--c;\n\t}\n\treturn !(j<=ed||B[jj]>1||c);\n}\n\nvoid update()\n{\n\tint i,j,res(1),em(0);\n\tfor(i=1;i<=ed;i=j+1)\n\t{\n\t\tfor(j=i;B[j+1]==B[i];++j);\n\t\tres=res*C[j][i-1]%MOD;\n\t\tem+=(j-i+1)*((B[i]<<1)-1);\n\t}\n\tem+=ed+1;\n\tres=res*C[em-1+left][em-1]%MOD;\n\tif((ans+=res)>=MOD)\n\t\tans-=MOD;\n}\n\nvoid dfs(int lim)\n{\n\tif(left<0)\n\t\treturn;\n\tif(valid())\n\t{\n\t\t//cout<<ed<<\",\"<<B[1]<<\",\"<<B[2]<<\",\"<<B[3]<<endl;\n\t\tupdate();\n\t\t//cout<<ans<<\"!\"<<endl;\n\t}\n\tif(ed&&(--left)<=0)\n\t{\n\t\t++left;\n\t\treturn;\n\t}\n\t++ed;--left;\n\tdfs(B[ed]=1);\n\t++left;\n\tfor(int i=2;i<=lim;++i)\n\t{\n\t\tleft-=(i<<1)-3;\n\t\tdfs(B[ed]=i);\n\t\tleft+=(i<<1)-3;\n\t}\n\tB[ed--]=0;\n\tif(ed)\n\t\t++left;\n}\n\nsigned main()\n{\n\tscanf(\"%lld%lld%s\",&n,&k,s+1);\n\tprework();\n\t//ed=2;\n\t//B[1]=2;B[2]=1;\n\t//cout<<valid()<<endl;\n\t//left=1;\n\t//update();\n\t//cout<<ans<<\"!\"<<endl;\n\tleft=n;dfs(n);\n\tprintf(\"%lld\",(ans+1)%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=200;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=62;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];\n\tbool inB[N];char str[N];\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);if(n>60) exit(0);\n\t\tg[0][0][0]=1;fo(i,1,n) fo(j,1,m) g[0][i][j]=C(i-1,j-1)*facinv[j]%MOD;\n\t\tfo(cc,1,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,m-1) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t\tadd(g[cc][i+ii][j+1],g[cc][i][j]*( (C(ii-1,cc*2-2)+C(ii-1,cc*2-1)*2+C(ii-1,cc*2))%MOD )%MOD);\n\t\t\tfo(i,0,n) fo(j,0,m) g[cc][i][j]=g[cc][i][j]*facinv[j]%MOD;\n\t\t}\n\t\tll ans=0;dp[n+1][0][0][0]=1;\n\t\tfo(A,0,m)\n\t\t{\n\t\t\tint R=0;mem(inB,0);\n\t\t\tif(A) fo(i,1,m) if(str[i]=='r')\n\t\t\t{\n\t\t\t\tbool ok=0;fo(j,i+1,m) if(str[j]=='b' and !inB[j]) {inB[j]=1,pos[++R]=j,ok=1;break;}\n\t\t\t\tif(!ok or R==A) break;//posi=被匹配的第i个蓝色\n\t\t\t}if(R<A) break;\n\t\t\t\n\t\t\tfo(B,0,m)\n\t\t\t{\n\t\t\t\tint cc=0;fo(i,1,m) if(str[i]=='r') cc++,blu[i]=blu[i-1]+(cc>A+B); else blu[i]=blu[i-1]+(!inB[i]);if(cc<A+B) break;\n\t\t\t\tfo(cnt,0,blu[m]) fo(ln,1,n) fo(st,0,A)\n\t\t\t\t{\n\t\t\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\t\t\tfo(j,1,A-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-(blu[pos[st+j]]-blu[pos[st+j-1]]))+(ln-1);\n\t\t\t\t}\n\t\t\t\tfd(ln,n,1) fo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,m) dp[ln][S][t][cnt]=0;\n\t\t\t\tfd(ln,n,1)\n\t\t\t\t{\n\t\t\t\t\tfo(S,0,n) fo(t,0,min(A,S/ln)) fo(cnt,0,blu[m]-blu[pos[t]]) if(dp[ln+1][S][t][cnt])\n\t\t\t\t\t\tfo(j,0,A-t) if(go[cnt][ln][t][j]<=blu[m]-blu[pos[t+j]]) fo(i,0,n-S)\n\t\t\t\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],1ll*dp[ln+1][S][t][cnt]*g[ln][i][j]%MOD);\n\t\t\t\t}\n\t\t\t\tfo(S,0,n) fo(cnt,0,m) if(dp[1][S][A][cnt]) fo(S2,0,n-S) if(g[0][S2][B])\n\t\t\t\t\tadd(ans,1ll*dp[1][S][A][cnt]*g[0][S2][B]%MOD*fac[A+B]%MOD*C(n-S-S2+1,A+B)%MOD);\n\t\t\t}\n\t\t}\n\t\twrite(ans);\n\t}\n};\nsigned main()\n{\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nmap<vector<char>,int> ma;\nvector<char> V,v[420010];\nint cnt,t[420010][36],n,m,f[71][420010],g[71][36][2],sum[71][36],ans,h[420010];\nchar s[110];\n\nvoid dfs(int nw)\n{\n\tma[V]=(++cnt),v[cnt]=V;\n\tfor (int i=(V.empty()?0:V[V.size()-1]); (i==0)+i+nw<=35; i++)\n\t\tV.push_back(i),dfs(i+nw+(i==0)),V.pop_back();\n}\n\nint main()\n{\n\tV.clear(),cnt=0,dfs(0);\n\tfor (int i=1,nw; i<=cnt; i++)\n\t{\n\t\tnw=0;\n\t\tfor (int j=0,sz=v[i].size(); j<sz; j++) nw+=(v[i][j]==0)+v[i][j];\n\t\tfor (int j=0; (j==0)+j+nw<=35; j++) \n\t\t{\n\t\t\tV=v[i],V.push_back(j),sort(V.begin(),V.end());\n\t\t\tt[i][j]=ma[V];\n\t\t}\n\t}\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tf[0][1]=1,g[0][0][0]=1;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tg[i][0][0]=g[i-1][0][0],g[i][0][1]=0;\n\t\tfor (int j=1; j<=(i+1>>1); j++)\n\t\t\tg[i][j][0]=(g[i-1][j][0]+g[i-1][j][1])%mod,\n\t\t\tg[i][j][1]=(g[i-1][j][1]+g[i-1][j-1][0])%mod;\n\t}\n\tfor (int j=0; j<=(n+1>>1); j++)\n\t{\n\t\tsum[0][j]=0;\n\t\tfor (int i=1; i<=n; i++) sum[i][j]=(sum[i-1][j]+1ll*g[i][j][0]+g[i][j][1])%mod;\n\t}\n\tfor (int i=0; i<n; i++)\n\t\tfor (int k=1; k<=cnt; k++) if (f[i][k])\n\t\t\tfor (int nxt=(i==0?1:i+2),j=nxt; j<=n; j++)\n\t\t\t\tfor (int l=0; l<=(j-nxt+2>>1); l++)\n\t\t\t\t\tf[j][t[k][l]]=(f[j][t[k][l]]+1ll*f[i][k]*sum[j-nxt+1][l])%mod;\n\tfor (int j=1; j<=cnt; j++)\n\t\tfor (int i=0; i<=n; i++) h[j]=(h[j]+f[i][j]>=mod?h[j]+f[i][j]-mod:h[j]+f[i][j]);\n\tans=0;\n\tfor (int nw,p,i=1,nww,pp; i<=cnt; i++) if (h[i])\n\t{\n\t\tnw=0,p=v[i].size(),nww=0,pp=v[i].size();\n\t\tfor (int j=0; (p||nw)&&j<m; j++)\n\t\t\tif (s[j]=='r') \n\t\t\t{\n\t\t\t\tif (p) \n\t\t\t\t{\n\t\t\t\t\tnw+=v[i][--p];\n\t\t\t\t\tif (max(p,pp)==p) nww+=max(v[i][p]-1,0); \n\t\t\t\t} else if (nww&&nw) nw--,nww--;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif (nw) \n\t\t\t\t{\n\t\t\t\t\tnw--,pp--;\n\t\t\t\t\tif (max(p,pp)==pp) nww+=max(v[i][pp]-1,0);\n\t\t\t\t}\n\t\t\t}\n\t\tif (!p&&!nw)  ans=(ans+h[i])%mod;\n\t}\n\treturn printf(\"%d\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 1000005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,K,C[1005][1005],L[75],fac[1005],invfac[1005],cnt;\nint sum[75],pos[75],tot,ans,matc[75];\nchar s[75];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nbool check() {\n    if(tot < cnt) return false;\n    memset(sum,0,sizeof(sum));\n    int p = 1;\n    for(int i = cnt ; i >= 1 ; --i) {\n\tsum[pos[i]]++;\n\tif(L[p] >= 2) {\n\t    sum[matc[i]] += L[p] - 1;\n\t}\n\t++p;\n    }\n    for(int i = K ; i >= 1 ; --i) {\n\tsum[i] += sum[i + 1];\n\tif(sum[i] > K - i + 1) return false;\n    }\n    return true;\n}\nbool dfs(int pre,int dep,int len) {\n    cnt = dep;\n    if(!check()) return false;\n    int k = 1 + cnt;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] == 1) ++k;\n        else k += 2 * L[i] - 1;\n    }\n    int res = C[N - len + k - 1][k - 1];\n    res = mul(res,fac[cnt]);\n    int t = 0;\n    for(int i = 1 ; i <= cnt ; ++i) {\n        if(L[i] != L[i - 1]) {\n            res = mul(res,invfac[t]);\n            t = 0;\n        }\n        ++t;\n    }\n    res = mul(res,invfac[t]);\n    update(ans,res);\n    if(dep + 1 > tot) return true;\n    for(int i = pre ; i <= 70 ; ++i) {\n        int tl = len;\n        if(dep != 0) ++tl;\n        if(i == 1 || i == 2) tl += 1;\n        else tl += i - 2 + i - 1;\n        if(tl > N) break;\n        L[dep + 1] = i;\n        if(!dfs(i,dep + 1,tl)) break;\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);read(K);\n    scanf(\"%s\",s + 1);\n    C[0][0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) {\n        C[i][0] = 1;\n        for(int j = 1 ; j <= i ; ++j) {\n            C[i][j] = inc(C[i - 1][j - 1],C[i - 1][j]);\n        }\n    }\n    fac[0] = 1;\n    for(int i = 1 ; i <= 1000 ; ++i) fac[i] = mul(fac[i - 1],i);\n    invfac[1000] = fpow(fac[1000],MOD - 2);\n    for(int i = 999 ; i >= 0 ; --i) invfac[i] = mul(invfac[i + 1],i + 1);\n    tot = 0;\n    for(int i = 1 ; i <= K ; ++i) {\n        if(s[i] == 'r') pos[++tot] = i;\n\tfor(int j = i + 1 ; j <= K ; ++j) {\n\t    if(s[j] == 'b' && !matc[j]) {matc[i] = j;break;}\n\t}\n    }\n    dfs(1,0,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nbool used[100];\nint p[100];\nint calc(){\n    int n=X.size();\n    if(n>R)return 0;\n\n    memset(used,0,sizeof(used));\n    for(int i=0;i<n;i++)used[r[R-i]]=true;\n    rep(i,n){\n        if(X[i]==1)break;\n        int pos=r[R-i]+1;\n        while(pos<N&&(S[pos]=='r'||used[pos]))pos++;\n        if(pos==N)return 0;\n        used[pos]=true;\n        p[i]=pos;\n    }\n    rep(i,n){\n        if(X[i]<=2)break;\n        int pos=p[i];\n        rep(t,X[i]-2){\n            while(pos<N&&used[pos])pos++;\n            if(pos==N)return 0;\n            used[pos]=true;\n            pos++;\n        }\n    }\n\n    /*\n    rep(i,n)used[r[R-i]]=true;\n    int pos=B;\n    for(int i=0;i<n;i++){\n        if(X[i]==1)break;\n        while(pos>0&&b[pos]<r[R-i])pos--;\n        if(pos==0)return 0;\n        used[b[pos]]=true;\n        p[i]=pos;\n        pos--;\n    }\n    pos=0;\n    rep(i,n){\n        chmax(pos,b[p[i]]+1);\n        rep(t,X[i]-2){\n            while(pos<N&&used[pos])pos++;\n            if(pos==N)return 0;\n            used[pos]=true;\n            pos++;\n        }\n    }\n\n    */\n    vpint ei;\n    rep(i,X.size()){\n        if(ei.size()==0||ei.back().fi!=X[i])ei.pb({X[i],1});\n        else ei.back().se++;\n    }\n\n    int latte=0;\n    int s=0;\n    for(int i=0;i<X.size();i++){\n        if(X[i]==1){\n            latte++;\n            s++;\n        }\n        else{\n            latte+=X[i]*2-3;\n            s+=X[i]*2-3+2;\n        }\n    }\n\n    int ret=0;\n    for(int k=0;latte+k<=N;k++){\n        int y=N-latte-k;\n        add(ret,nCk(y+1,n)*nCk(s-1+k,k)%mod);\n\n    }\n    ret=ret*fact[n]%mod;\n    rep(i,ei.size())ret=ret*inv[ei[i].se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"No\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=5e6+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=71;\n\t//------------------FIXED------------------\n\tint pos[N],blu[N];char str[N];int ask(int l,int r){return blu[r]-blu[l-1];}\n\tint go[N][N][N][N];\n\tint g[N][N][N];\n\tint dp[N][N][N][N];\n\tvoid main()\n\t{\n\t\tint n=qread(),m=qread();scanf(\"%s\",str+1);\n\t\tint R=0;fo(i,1,m) {blu[i]=blu[i-1];if(str[i]=='r') pos[++R]=i;else if(R) blu[i]++;}\n\t\tfo(cnt,0,blu[m]) fo(ln,0,n) fo(st,0,R)\n\t\t{\n\t\t\tgo[cnt][ln][st][0]=cnt;\n\t\t\tfo(j,1,R-st) go[cnt][ln][st][j]=max(0,go[cnt][ln][st][j-1]-ask(pos[st+j-1],pos[st+j]))+ln;\n\t\t}\n\t\tfo(cc,0,n)\n\t\t{\n\t\t\tg[cc][0][0]=1;\n\t\t\tfo(i,0,n) fo(j,0,n) if(g[cc][i][j]) fo(ii,1,n-i)\n\t\t\t{\n\t\t\t\tfo(s,max(1,cc),ii) add(g[cc][i+ii][j+1],g[cc][i][j]*C(ii-s+1,cc)%MOD*(cc?C(s-1,cc-1):(s==ii))%MOD);\n\t\t\t}\n\t\t}\n\t\tdp[n+1][0][0][0]=1;\n\t\tfd(ln,n,0) fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[ln+1][S][t][cnt])\n\t\t{\n\t\t\tdebug(\"dp(%d,%d,%d,%d)=%d\\n\",ln+1,S,t,cnt,dp[ln+1][S][t][cnt]);\n\t\t\tfo(i,0,n-S) fo(j,0,R-t)\n\t\t\t{\n\t\t\t\tadd(dp[ln][S+i][t+j][go[cnt][ln][t][j]],dp[ln+1][S][t][cnt]*facinv[j]%MOD*g[ln][i][j]%MOD);\n\t\t\t}\n\t\t}\n\t\tfo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(dp[0][S][t][cnt])\n\t\t\tdebug(\"dp(%d,%d,%d,%d)=%d\\n\",0,S,t,cnt,dp[0][S][t][cnt]);\n\t\tll ans=0;fo(S,0,n) fo(t,0,R) fo(cnt,0,blu[m]) if(ask(pos[t],m)>=cnt)\n\t\t\tadd(ans,dp[0][S][t][cnt]*fac[t]%MOD*C(n-S+1,t)%MOD );\n\t\twrite(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//线性预处理模意义\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\")\n#endif\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nusing ll = long long;\nusing ld = long double;\n\nconstexpr int nax = 75;\nconstexpr int infty = 1000 * 1000 * 1000 + 5;\nconstexpr int mod = 1000 * 1000 * 1000 + 7;\n\nll Dodaj(ll a, ll b) {\n  a += b;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\nll Mnoz(ll a, ll b) {\n  return (a * b) % mod;\n}\n\nll dwumian[nax][nax];\nll sposoby[nax][nax];\n\nll C(int n, int k) {\n  if (0 <= k and k <= n) {\n    assert(0 <= n and n < nax);\n    return dwumian[n][k];\n  }\n  return 0;\n}\n\nvoid InitSposoby() {\n  for (int n = 0; n < nax; n++) {\n    dwumian[n][0] = dwumian[n][n] = 1;\n    for (int k = 1; k < n; k++) {\n      dwumian[n][k] = Dodaj(dwumian[n - 1][k - 1], dwumian[n - 1][k]);\n    }\n  }\n\n  for (int len = 0; len < nax; len++) {\n    sposoby[len][0] = 1;\n    sposoby[len][1] = (len * (len + 1)) / 2;\n  }\n  for (int cntb = 2; cntb < nax; cntb++) {\n    for (int len = 0; len < nax; len++) {\n      for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n          sposoby[len][cntb] = Dodaj(sposoby[len][cntb], sposoby[i][cntb - 1]);\n        }\n      }\n    }\n  }\n}\n\nbool NewSizes(const vector<int>& sizes, int cnt, vector<int>& res) {\n  res = sizes;\n  int zostalo = cnt;\n  for (int i = (int) res.size() - 1; i >= 0; i--) {\n    zostalo -= res[i];\n    if (zostalo <= 0) {\n      for (int j = i; cnt > 0; j++) {\n        const int ile = min(cnt, res[j]);\n        res[j] -= ile;\n        cnt -= ile;\n      }\n      if (i > 0) {\n        res[i - 1] += res[i];\n      }\n      res.erase(res.begin() + i);\n      return true;\n    }\n  }\n  return false;\n}\n\nll Dp(int n, const vector<int>& sizes);\nll Dp_(int n, const vector<int>& sizes) {\n  ll wynik = 0;\n  for (int len = 1; len <= n; len++) {\n    for (int cnt_b = 1; cnt_b <= (len + 1) / 2; cnt_b++) {\n      if (sposoby[len][cnt_b]) {\n        vector<int> uloz;\n        if (NewSizes(sizes, cnt_b - 1, uloz)) {\n          wynik = Dodaj(wynik, Mnoz(sposoby[len][cnt_b], Dp(n - len, uloz)));\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  //debug() << \"Dp(\" imie(n) imie(sizes) \") = \" << wynik;\n  return wynik;\n}\n\nmap<vector<int>, ll> dp_memo[nax];\nll Dp(int n, const vector<int>& sizes) {\n  assert(0 <= n and n < nax);\n  if (n == 0) {\n    if (sizes.empty()) {\n      return 1;\n    }\n    return 0;\n  }\n  auto res = dp_memo[n].emplace(sizes, 0ll);\n  if (res.second) {\n    res.first->second = Dp_(n, sizes);\n  }\n  return res.first->second;\n}\n\nint n, k;\nstring s;\n\nvoid Algos() {\n  ll wynik = 0;\n  for (int cntr = 0; cntr <= k; cntr++) {\n    for (int cntblok = 0; cntblok <= (k - cntr) / 2; cntblok++) {\n      string str = s;\n      vector<int> sizes;\n      int zostalo_r = cntr;\n      int wsk = -1;\n      for (int i = 0; i < k and (int) sizes.size() < cntblok; i++) {\n        if (str[i] == 'b') {\n          int poz = -1;\n          for (int j = 0; j < i; j++) {\n            if (str[j] == 'r') {\n              poz = j;\n              break;\n            }\n          }\n          if (poz != -1) {\n            str[i] = 'x';\n            str[poz] = 'y';\n            sizes.push_back(0);\n          }\n        }\n      }\n      if ((int) sizes.size() < cntblok) {\n        //debug() << \"male\" imie(sizes);\n        goto nope;\n      }\n      assert((int) sizes.size() == cntblok);\n      for (int i = 0; i < k; i++) {\n        if (str[i] == 'r') {\n          if (zostalo_r > 0) {\n            zostalo_r--;\n            continue;\n          }\n        }\n        if (str[i] == 'x') {\n          wsk++;\n        } else if (str[i] == 'y') {\n          // Pass.\n        } else if (wsk >= 0) {\n          sizes[wsk]++;\n        }\n      }\n      if (zostalo_r > 0) {\n        //debug() << imie(zostalo_r) imie(zostalo_r > 0);\n        goto nope;\n      }\n      debug() << imie(s) imie(cntr) imie(cntblok) imie(sizes);\n      for (int dlug = 0; dlug <= n; dlug++) {\n        for (int dlugr = 0; dlugr <= dlug; dlugr++) {\n          const int fragmenty = cntr + cntblok;\n          const int pomiedzy = max(0, fragmenty - 1);\n          const int wolne = n - dlug - pomiedzy;\n          if (wolne >= 0) {\n            ll jakmozna = Mnoz(C(wolne + fragmenty, fragmenty),\n                               C(fragmenty, cntr));\n            if (cntr > 0) {\n              jakmozna = Mnoz(jakmozna, C(dlugr - 1, cntr - 1));\n            } else if (dlugr > 0) {\n              jakmozna = 0;\n            }\n            //debug() << imie(fragmenty) imie(pomiedzy) imie(wolne) imie(C(wolne + fragmenty, fragmenty)) imie(C(fragmenty, cntr)) imie(C(dlugr + cntr - 1, cntr - 1));\n            //debug() << imie(dlug) imie(dlugr) imie(jakmozna);\n            if (jakmozna) {\n              const int reszta = Dp(dlug - dlugr, sizes);\n              //debug() << imie(dlug - dlugr) imie(sizes) imie(reszta);\n              wynik = Dodaj(wynik, Mnoz(jakmozna, reszta));\n            }\n          }\n        }\n      }\n      nope:;\n    }\n  }\n  printf(\"%lld\\n\", wynik);\n}\n\nint main() {\n  InitSposoby();\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cin >> n >> k >> s;\n  assert(k == (int) s.size());\n  Algos();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#define Mod 1000000007\nusing namespace std;\nint n,k;\nchar s[110];\nint nxt[110][2];\nint fac[210],inv[210];\nint fpow(int a,int b)\n{\n\tint ans=1,t=a;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=(long long)ans*t%Mod;\n\t\tt=(long long)t*t%Mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init()\n{\n\tint N=200;\n\tfac[0]=1;\n\tfor(int i=1;i<=N;i++)\n\t\tfac[i]=(long long)fac[i-1]*i%Mod;\n\tinv[N]=fpow(fac[N],Mod-2);\n\tfor(int i=N;i>=1;i--)\n\t\tinv[i-1]=(long long)inv[i]*i%Mod;\n\treturn ;\n}\nint C(int x,int y)\n{\n\treturn (long long)fac[x]*inv[y]%Mod*inv[x-y]%Mod;\n}\nint ans;\nint f[110],g[110],h[110];\nbool vis[110];\nvoid calc(int num)\n{\n\t//check\n\tfor(int i=1;i<=k;i++)\n\t\tvis[i]=false;\n\tint cur=nxt[1][0],cnt=0;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1&&cnt==0)\n\t\t\tcnt=num-i+1;\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;h[i]=cur;\n\t\tcur=nxt[cur+1][0];\n\t}\n\tcur=nxt[1][1];\n\tfor(int i=1;i<=num-cnt;i++)\n\t{\n\t\twhile(cur<=k&&(cur<h[i]||vis[cur]))\n\t\t\tcur=nxt[cur+1][1];\n\t\tif(cur>k)return ;\n\t\tvis[cur]=true;\n\t\tg[i]=cur;\n\t}\n\tint now=num-cnt;\n\tcur=f[now];\n\twhile(cur<=2&&now>0){\n\t\tnow--;\n\t\tcur=f[now];\n\t}\n\tfor(int i=k;i>=1;i--)\n\t\tif(!vis[i]){\n\t\t\tif(now<=0)break;\n\t\t\tif(i<g[i])return ;\n\t\t\tvis[i]=true;\n\t\t\tcur--;\n\t\t\twhile(cur<=2&&now>0){\n\t\t\t\tnow--;\n\t\t\t\tcur=f[now];\n\t\t\t}\n\t\t}\n\tif(now>0)return ;\n\tint sum=fac[num];cur=0;\n\tint cntb=0,cntr=0,cntw=num-1;\n\tfor(int i=1;i<=num;i++)\n\t{\n\t\tif(f[i]==1)cntr++;\n\t\telse cntr+=f[i]-2,cntb+=f[i]-1;\n\t\tif(i==1||f[i]==f[i-1])cur++;\n\t\telse{\n\t\t\tsum=(long long)sum*inv[cur]%Mod;\n\t\t\tcur=1;\n\t\t}\n\t}\n\tsum=(long long)sum*inv[cur]%Mod;\n\tint cntB=(num-cnt)*2+1;//rbr->2(num-cnt)  ...rw->1\n\tif(cntb+cntr+cntw>n)return ;\n\tsum=(long long)sum*C(n+cntB,cntb+cntr+cntw+cntB)%Mod;\n//\tfor(int i=1;i<=num;i++)\n//\t\tprintf(\"%d \",f[i]);\n//\tprintf(\":%d\\n\",sum);\n\tans=(ans+sum)%Mod;\n\treturn ;\n}\nvoid dfs(int x,int rest,int cnt)\n{\n\tif(rest<0)return ;\n\tif(x==0){\n\t\tcalc(cnt);\n\t\treturn ;\n\t}\n\tfor(int i=0;i*x<=rest;i++)\n\t{\n\t\tif(i>0)f[cnt+i]=x;\n\t\tdfs(x-1,rest-i*(x==1?1:(2*x-3)),cnt+i);\n\t}\n\treturn ;\n}\nint main()\n{\n//\tf[1]=2;\n//\tcalc(2);\n//\tprintf(\"%d\\n\",ans);\n\t\n\tscanf(\"%d %d\",&n,&k);\n\tscanf(\"%s\",s+1);\n\tnxt[k+1][0]=nxt[k+1][1]=k+1;\n\tfor(int i=k;i>=1;i--)\n\t{\n\t\tnxt[i][0]=nxt[i+1][0];\n\t\tnxt[i][1]=nxt[i+1][1];\n\t\tif(s[i]=='r')nxt[i][0]=i;\n\t\telse nxt[i][1]=i;\n\t}\n\tinit();\n\tdfs(n,n,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nint n,k;\nint C[555][555];\nint inv[555];\nchar seq[75];\nint mat[75],fact[555];\nint pos[75],cnt;\nint ln[75];\nint ans;\nconst int mod = 1000000007;\n\nint qpow(int base,int tms)\n{\n\tint tmp = 1;\n\twhile(tms)\n\t{\n\t\tif(tms & 1) tmp = tmp * 1ll * base % mod;\n\t\tbase = base * 1ll * base % mod;\n\t\ttms >>= 1;\n\t}\n\treturn tmp;\n}\n\nbool chk(int cn)\n{\n\tif(cn > cnt) return false;\n\tstatic int sum[75]; memset(sum,0,sizeof(sum));\n\tfor(int i = cn;i >= 1; -- i)\n\t{\n\t\tif(!pos[i]) return false;\n\t\tsum[pos[i]] ++;\n\t\tif(ln[cn - i + 1] >= 2)\n\t\t{\n\t\t\tif(!mat[pos[i]]) return false;\n\t\t\tsum[mat[pos[i]]] += ln[cn - i + 1] - 1;\n\t\t}\n\t}\n\tfor(int i = k;i >= 1; -- i)\n\t{\n\t\tsum[i] += sum[i + 1];\n\t\tif(sum[i] > k - i + 1) return false;\n\t}\n\treturn true;\n}\n\nbool dfs(int mi,int cnt,int mus)\n{\n\tif(!chk(cnt)) return false;\n\tint k = cnt + 1;\n\tfor(int i = 1;i <= cnt; ++ i)\n\t\tk += 2 * ln[i] - 1;\n\tint as = C[n - mus + k - 1][k - 1];\n\tif(k > 500) cerr << k << endl; \n\tint p = 0;\n\tfor(int i = 1;i <= cnt; ++ i)\n\t{\n\t\tif(ln[i] != ln[i - 1])\n\t\t\tas = as * 1ll * inv[p] % mod,p = 0;\n\t\tp ++;\n\t}\n\tas = as * 1ll * inv[p] % mod;\n\tas = as * 1ll * fact[cnt] % mod;\n\tans = (ans + as) % mod; \n\tfor(int i = mi;i <= 70; ++ i)\n\t{\n\t\tln[cnt + 1] = i;\n\t\tint nw = mus;\n\t\tif(cnt) nw ++;\n\t\tnw += i <= 2 ? 1 : 2 * i - 3;\n\t\tif(nw > n) break;\n\t\tif(!dfs(i,cnt + 1,nw)) break;\n\t}\n\treturn true;\n}\n\nsigned main()\n{\n\tscanf(\"%lld%lld\",&n,&k);\n\tscanf(\"%s\",seq + 1);\n\tint po = 1;\n\tfor(int i = 1;i <= k; ++ i)\n\t{\n\t\tif(seq[i] == 'r')\n\t\t{\n\t\t\tpo = max(po,i);\n\t\t\twhile(po <= k && seq[po] != 'b') po ++;\n\t\t\tif(po <= k)\n\t\t\t\tmat[i] = po ++;\n\t\t\tpos[++ cnt] = i;\n\t\t}\n\t}\n\tC[0][0] = 1;\n\tfact[0] = 1;\n\tinv[0] = 1;\n\tint pre = 1;\n\tfor(int i = 1;i <= 550; ++ i)\n\t{\n\t\tpre = pre * 1ll * i % mod;\n\t\tfact[i] = pre;\n\t\tinv[i] = qpow(pre,mod - 2);\n\t\tC[i][0] = 1;\n\t\tfor(int j = 1;j <= i; ++ j)\n\t\t\tC[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;\n\t}\n\tdfs(1,0,0);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, x, n) for(int i=x;i<=n;i++)\n#define pr make_pair\n#define fi first\n#define se second\n\nconst int MOD = int(1E9) + 7;\nconst int MAX = 420000;\nconst int HASHSIZE = 1000037;\n\ninline int add(int x, int y) {x += y; return x >= MOD ? x - MOD : x;}\ninline int sub(int x, int y) {x -= y; return x < 0 ? x + MOD : x;}\ninline int mul(int x, int y) {return (int) (1LL * x * y % MOD);}\nint mpow(int b, int p) {\n\tint r; for(r=1;p;p>>=1,b=mul(b,b))\n\t\tif( p & 1 ) r = mul(r, b);\n\treturn r;\n}\n\nstruct node{\n\tint x[40], cnt;\n\tint get() {\n\t\tint h = 0;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\th = (131LL*h + x[i]) % HASHSIZE;\n\t\treturn h;\n\t}\n\tvoid print() {\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tprintf(\"%d%c\", x[i], i + 1 == cnt ? '\\n' : ' ');\n\t}\n\tbool equal(const node &b) {\n\t\tif( cnt != b.cnt ) return false;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tif( x[i] != b.x[i] ) return false;\n\t\treturn true;\n\t}\n}st[MAX + 5];\nvector<pair<node, int> >h[HASHSIZE];\nvoid insert(node a, int i) {h[a.get()].push_back(pr(a, i));}\nint search(node a) {\n\tint x = a.get();\n\tfor(unsigned i=0;i<h[x].size();i++)\n\t\tif( a.equal(h[x][i].fi) ) return h[x][i].se;\n\treturn -1;\n}\n\nint l[75], tot, N, K;\nvoid dfs(int s, node a, int x) {\n\ttot++, insert(st[tot] = a, tot);\n\tfor(int i=x;i<=N&&l[i]<=s;i++)\n\t\ta.x[a.cnt++] = i, dfs(s - l[i], a, i), a.x[--a.cnt] = i;\n}\n\nint f[MAX + 5], fct[505], ifct[505], c[505][505];\nvoid init() {\n\trep(i, 0, 500) rep(j, 0, i)\n\t\tc[i][j] = (j == 0 ? 1 : add(c[i - 1][j], c[i - 1][j - 1]));\n\tfct[0] = 1; rep(i, 1, 500) fct[i] = mul(fct[i - 1], i);\n\tifct[500] = mpow(fct[500], MOD - 2);\n\tfor(int i=499;i>=0;i--) ifct[i] = mul(ifct[i + 1], i + 1);\n\t\n\tl[1] = 2; rep(i, 2, N) l[i] = (i - 1) << 1; dfs(N, (node){}, 1);\n\trep(i, 1, tot) {\n\t\tint a = 1, b = 0, t = 1, p = 1;\n\t\trep(j, 1, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != st[i].x[j-1] )\n\t\t\t\tt = mul(t, ifct[p]), p = 1;\n\t\t\telse p++;\n\t\t}\n\t\tt = mul(t, ifct[p]);\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tb += l[st[i].x[j]];\n\t\t\tif( st[i].x[j] != 1 ) a += 2;\n\t\t}\n\t\tf[i] = mul(mul(fct[st[i].cnt], t), c[N + a - 1][a + b - 1]);\n\t}\n//\tprintf(\"%d\\n\", tot);\n}\n\nint tg[75], q[75]; char s[75];\nint main() {\n\tscanf(\"%d%d%s\", &N, &K, s + 1), N++, init();\n\t\n\tint ans = 0;\n\trep(i, 1, tot) {\n\t\tint cnt1 = 0, pos = -1;\n\t\trep(j, 0, st[i].cnt - 1) {\n\t\t\tif( st[i].x[j] != 1 ) {\n\t\t\t\tpos = j;\n\t\t\t\tbreak;\n\t\t\t} else cnt1++;\n\t\t}\n\t\t\n\t\tint hd = 1, tl = 0, p = st[i].cnt - cnt1;\n\t\trep(j, 1, K) tg[j] = -1;\n\t\tfor(int j=1;p&&j<=K;j++) {\n\t\t\tif( s[j] == 'r' ) q[++tl] = j;\n\t\t\telse if( hd <= tl ) tg[q[hd++]] = 0, tg[j] = 1, p--;\n\t\t}\n\t\t\n\t\tint cnt[2] = {}; bool flag = true;\n\t\tfor(int j=K;j>=1;j--) {\n\t\t\tif( tg[j] == -1 ) cnt[s[j] == 'r' ? 0 : 1]++;\n\t\t\telse if( tg[j] == 1 ) {\n\t\t\t\tint tmp = st[i].x[pos] - 2;\n\t\t\t\twhile( cnt[1] && tmp ) cnt[1]--, tmp--;\n\t\t\t\twhile( cnt[0] && tmp ) cnt[0]--, tmp--;\n\t\t\t\tif( tmp ) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( flag && cnt[0] >= cnt1 && p == 0 ) ans = add(ans, f[i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], pos[N], suf[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\n\nbool check () {\n\tvector<int> vec1, vec2, vec3;\n\tfor (int i = 0; i < top; i++) vec1.push_back(stk[i]);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') {\n\t\t\tif (!vec1.empty()) {\n\t\t\t\tif (vec1.back()) vec2.insert(vec2.begin(), vec1.back());\n\t\t\t\tvec1.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (!vec2.empty()) {\n\t\t\t\tif (vec2.back() > 1) vec3.push_back(vec2.back() - 1);\n\t\t\t\tvec2.pop_back();\n\t\t\t}\n\t\t\telse if (!vec3.empty()) {\n\t\t\t\t(*vec3.rbegin())--;\n\t\t\t\tif (!vec3.back()) vec3.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn vec1.empty() && vec2.empty() && vec3.empty();\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tassert(j <= n * 3 && tmp[i] <= n * 3);\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tassert(n + num2 - 1 >= 0 && num1 + num2 - 1 >= 0);\n\tassert(n + num2 - 1 <= n * 3 && num1 + num2 - 1 <= n * 3);\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 73\n#define mod 1000000007\n\nint n, k, i;\nint f[maxN], p[maxN];\nstring s, aux;\n\nll dp[4][maxN][2 * maxN]; //! stage, used, sum\nll cnt[maxN][maxN];\nll comb[maxN][maxN];\n\nll data[2][maxN];\nll ans;\n\n\nvoid addit(ll& a, ll b) {\n    a += b;\n    if (a >= mod) a -= mod;\n}\n\nvoid pre() {\n    int st, i, j, k, dd;\n\n    for (i = 0; i <= n + 1; i++) {\n        comb[i][0] = 1;\n        for (j = 1; j <= i; j++) {\n            comb[i][j] = comb[i - 1][j];\n            addit(comb[i][j], comb[i - 1][j - 1]);\n        }\n    }\n\n    for (i = 0; i <= n; i++)\n        dp[0][i][0] = 1;\n\n    for (st = 0; st < 3; st++) {\n        dd = (st <= 1 ? 1 : 2);\n\n        for (i = 0; i <= n; i++) {\n            for (j = 0; j <= i; j++) {\n                if (dp[st][i][j] == 0) continue;\n                for (k = 0; i + k <= n; k++) {\n                    addit(dp[st + 1][i + k][j + dd * k], (dp[st][i][j] * comb[i + k][k]) % mod);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i <= n; i++)\n        for (j = 0; j <= 2 * i; j++)\n            cnt[i][j] = dp[3][i][j];\n}\n\nint get_first(int bg, char c) {\n    while (bg < aux.size()) {\n        if (aux[bg] == c) {\n            aux[bg] = '.';\n            return bg;\n        }\n        bg++;\n    }\n\n    return bg;\n}\n\nbool get_others(int bg, int cnt) {\n    while (bg < aux.size() && cnt > 0) {\n        if (aux[bg] != '.') {\n            aux[bg] = '.';\n            cnt--;\n        }\n        bg++;\n    }\n    return (cnt == 0);\n}\n\nbool check(int dim) {\n    int i, need;\n\n    need = 0;\n    for (i = 1; i <= dim; i++) {\n        if (f[i] == 1)\n            need += 2;\n        else\n            need += f[i] * 2 - 2;\n    }\n\n    if (need > n + 1) return false;\n\n    aux = s;\n    for (i = 1; i <= dim; i++) {\n        int pos_r = get_first(0, 'r');\n        if (pos_r == aux.size()) return false;\n\n        if (f[i] == 1) {\n            p[i] = pos_r;\n        } else {\n            int pos_b = get_first(pos_r + 1, 'b');\n            if (pos_b == aux.size()) return false;\n            p[i] = pos_b;\n        }\n    }\n\n    for (i = 1; i <= dim; i++) {\n        if (f[i] <= 2) break;\n        if (!get_others(p[i] + 1, f[i] - 2)) return false;\n    }\n\n    return true;\n}\n\nvoid add_to_solution(int dim) {\n    int i, j, p, l, sz, to;\n    static int iter = 0;\n\n\n    if ( (++iter) % 50000 == 0)\n        cerr << iter << '\\n';\n\n\n    //for (i = 1; i <= dim; i++) cerr << f[i] << ' ';\n    //cerr << '\\n';\n\n    memset(data, 0, sizeof(data));\n    data[0][0] = 1;\n\n    for (i = 1; i <= dim; i = j) {\n        for (j = i; j <= dim && f[i] == f[j]; j++);\n        sz = j - i;\n\n        if (f[i] == 1) {\n            for (p = 0; p + sz * 2 <= n + 1; p++)\n                addit(data[1][p + sz * 2], (data[0][p] * comb[j - 1][sz]) % mod );\n        } else {\n            for (p = 0; p <= n + 1; p++) {\n                if (data[0][p] == 0) continue;\n\n                for (l = 0; l <= n + 1; l++) {\n                    to = p + sz * (2 * f[i] - 2) + l;\n                    if (to > n + 1) break;\n\n                    addit(data[1][to], (((data[0][p] * cnt[sz][l]) % mod) * comb[j - 1][sz]) % mod );\n                }\n            }\n        }\n\n        memcpy(data[0], data[1], sizeof(data[0]));\n        memset(data[1], 0, sizeof(data[1]));\n    }\n\n    for (i = 0; i <= n + 1; i++) {\n        ans += data[0][i] * comb[n + 1][i];\n        ans %= mod;\n    }\n}\n\nbool gen(int step) {\n    if (!check(step - 1)) return false;\n    add_to_solution(step - 1);\n\n    for (int i = 1; i <= f[step - 1]; i++) {\n        f[step] = i;\n        if (!gen(step + 1)) break;\n    }\n\n    return true;\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    cin >> n >> k >> s;\n    pre();\n\n    f[0] = (n + 3) / 2;\n    gen(1);\n\n    cout << ans;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvoid mod_inverse(int n, vector<long long>& inv, int mod)\n{\n    inv.assign(n+1, -1);\n    inv[1] = 1;\n    for(int i=2; i<=n; ++i)\n        inv[i] = inv[mod % i] * (mod - mod / i) % mod;\n}\n\nclass FactorialCalculation\n{\nprivate:\n    const int mod;\n    vector<long long> factorial;\n    vector<long long> invFactorial;\npublic:\n    FactorialCalculation(int n, int mod) : mod(mod)\n    {\n        factorial.resize(n+1, 1);\n        invFactorial.resize(n+1, 1);\n        vector<long long> inv;\n        mod_inverse(n, inv, mod);\n        for(int i=1; i<=n; ++i){\n            factorial[i] = factorial[i-1] * i % mod;\n            invFactorial[i] = invFactorial[i-1] * inv[i] % mod;\n        }\n    }\n    long long getFactorial(int n){\n        return factorial[n];\n    }\n    long long getInvFactorial(int n){\n        return invFactorial[n];\n    }\n    long long getPermutation(int n, int r){\n        if(n < r)\n            return 0;\n        return factorial[n] * invFactorial[n-r] % mod;\n    }\n    long long getCombination(int n, int r){\n        if(n < r)\n            return 0;\n        return getPermutation(n, r) * invFactorial[r] % mod;\n    }\n    long long getHomogeneous(int n, int r){\n        return getCombination(n+r-1, r);\n    }\n};\n\nconst long long MOD = 1000000007;\nFactorialCalculation fc(200, MOD);\n\nint ballNum, opeNum; // ボールの個数、操作列の長さ\nstring opeStr; // 操作列\n\nlong long calc(const vector<int>& v)\n{\n    int n = v.size();\n    int cnt = 1;\n    int sum = 1;\n    long long ans = 1;\n    for(int i=0; i<n; ++i){\n        if(i < n - 1 && v[i] == v[i+1]){\n            ++ cnt;\n        }\n        else{\n            ans *= fc.getHomogeneous(sum, cnt);\n            ans %= MOD;\n            sum += cnt;\n            cnt = 1;\n        }\n    }\n    return ans;\n}\n\nlong long solve(const vector<int>& v)\n{\n    int size = v.size();\n    vector<int> index(size+1, -1);\n    vector<bool> check(opeNum, false);\n    for(int i=size-1; i>=0; --i){\n        index[i] = index[i+1] + 1;\n        while(index[i] < opeNum && opeStr[index[i]] != 'r')\n            ++ index[i];\n        if(index[i] == opeNum)\n            return -1;\n        check[index[i]] = true;\n    }\n    for(int i=size-1; i>=0; --i){\n        if(v[i] > 1){\n            while(index[i] < opeNum && opeStr[index[i]] != 'b')\n                ++ index[i];\n            if(index[i] == opeNum)\n                return -1;\n            check[index[i]] = true;\n        }\n    }\n\n    int k = opeNum - 1;\n    for(int i=0; i<size; ++i){\n        int x = v[i] - 2;\n        while(x > 0 && k > index[i]){\n            if(!check[k])\n                -- x;\n            -- k;\n        }\n        if(x > 0)\n            return -1;\n    }\n\n    int cnt = v.size() + 1;\n    int rest = ballNum - (v.size() - 1);\n    for(int i=0; i<size; ++i){\n        cnt += v[i] * 2 - 1;\n        rest -= max(1, v[i] * 2 - 3);\n    }\n    if(rest < 0)\n        return -1;\n\n    long long ans = fc.getHomogeneous(cnt, rest);\n    ans *= calc(v);\n    ans %= MOD;\n    return ans;\n}\n\nlong long dfs(int a, vector<int> v)\n{\n    long long ans = 0;\n    vector<int> v2 = v;\n    for(;;){\n        v.push_back(a);\n        long long tmp = solve(v);\n        if(tmp == -1)\n            break;\n        ans += tmp;\n        ans %= MOD;\n        ans += dfs(a+1, v2);\n        ans %= MOD;\n        v2.push_back(a);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> ballNum >> opeNum >> opeStr;\n\n    long long ans = dfs(1, vector<int>()) + 1;\n    ans %= MOD;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long md=1e9+7;\nconst int maxn=210;\nlong long fac[maxn],inv[maxn];\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nchar str[maxn];\nint stk[maxn],top;\nint n,m;\nbool check(int x){\n\tstatic bool vis[maxn];\n\tfor(int i=1;i<=m;i++)\n\t\tvis[i]=0;\n\tint p=0,cnt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(cnt>=top) break;\n\t\tif(str[i]=='r'){\n\t\t\tif(p<i) p=i;\n\t\t\twhile(p<=m&&(vis[p]||str[p]=='r'))\n\t\t\t\tp++;\n\t\t\tif(p>m) return 0;\n\t\t\tcnt++;\n\t\t\tvis[i]=vis[p]=1;\n\t\t}\n\t}\n\tif(cnt!=top) return 0;\n\tcnt=0;\n\tfor(int i=1;i<=m;i++){\n\t\tif(cnt>=x) break;\n\t\tif(str[i]=='r'&&!vis[i]){\n\t\t\tvis[i]=1;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt!=x) return 0;\n\tp=m;\n\tfor(int i=top;i>=1;i--){\n\t\tcnt=0;\n\t\twhile(p>=1&&cnt<stk[i]/2){\n\t\t\tif(!vis[p]) cnt++;\n\t\t\tp--;\n\t\t}\n\t\tif(cnt!=stk[i]/2) return 0;\n\t}\n//\tprintf(\"top=%d\\n\",top);\n//\tfor(int i=1;i<=top;i++)\n//\t\tprintf(\"%d \",stk[i]);\n//\tprintf(\"\\n\");\n\treturn 1;\n}\nlong long sum[maxn][maxn];\nvoid solve(int res,long long val,int num){\n\tlong long fas;\n\tint tot=0;\n\tfor(int i=1;i<=top;i++) tot+=stk[i];\n\tfor(int i=0;i<=res;i++){\n\t\tif(tot+top+i*2>n+1) break;\n\t\tif(!check(i)) break;\n\t\tfas=fac[num+i]*val%md*inv[i]%md;\n\t\t(sum[tot+top+i*2][top]+=fas)%=md;\n//\t\tprintf(\"%d %d\\n\",tot+top+i*2,top);\n\t}\n}\nvoid dfs(int res,int las,long long val,int num){\n\tsolve(res,val,num);\n\tres--;\n\tint ttp;\n\tfor(int i=1;i<=res&&i<=las;i+=2){\n\t\tttp=top;\n\t\tfor(int j=1;res-i*j>=0;j++){\n\t\t\tstk[++top]=i;\n\t\t\tdfs(res-i*j,i-1,val*inv[j]%md,num+j);\n\t\t}\n\t\ttop=ttp;\n\t}\n}\nlong long C[maxn][maxn];\nint main(){\n//\tfreopen(\"F.in\",\"r\",stdin);\n//\tfreopen(\"F.out\",\"w\",stdout);\n\tfac[0]=1;\n\tfor(int i=1;i<=100;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[100]=powd(fac[100],md-2);\n\tfor(int i=100;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tC[0][0]=C[1][0]=C[1][1]=1;\n\tfor(int i=2;i<=100;i++){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;j++)\n\t\t\tC[i][j]=(C[i-1][j]+C[i-1][j-1])%md;\n\t}\n\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\tdfs(n,n,1,0);\n\tlong long ans=0,st=0;\n\tfor(int i=0;i<=n+1;i++){\n\t\tfor(int j=0;j<=n+1;j++){\n\t\t\tif(!sum[i][j]) continue;\n//\t\t\tprintf(\"%d %d %lld\\n\",i,j,sum[i][j]);\n\t\t\tst=0;\n\t\t\tfor(int k=0;k<=j*2;k++){\n\t\t\t\tif(i+k<=n+1){\n\t\t\t\t\tans=(ans+C[n+1][i+k]*C[j*2][k]%md*sum[i][j])%md;\n\t\t\t\t\tst+=C[n+1][i+k]*C[j*2][k]%md*sum[i][j];\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n//\t\t\tprintf(\"st=%lld\\n\",st);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DMP(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nconst int mod=1000000007;\ntemplate<class T,class U>\nvoid add(T& a,U b){\n\ta=((ll)a+b)%mod;\n}\n\ntemplate<class T,class U>\nvoid sub(T& a,U b){\n\ta=((ll)a-b%mod+mod)%mod;\n}\n\ntemplate<class T,class U>\nvoid mult(T& a,U b){\n\ta=((ll)a*b)%mod;\n}\n\nll modPow(ll a,ll p){\n\tll s=1;\n\tREP(i,30){\n\t\tif((p>>i)&1)\n\t\t\tmult(s,a);\n\t\tmult(a,a);\n\t}\n\treturn s;\n}\n\nll modInv(ll a){\n\treturn modPow(a,mod-2);\n}\n\nconst int Vmax=500;\nint binom[Vmax][Vmax];\nvoid Init(){\n\tbinom[0][0]=1;\n\tREP(i,Vmax)REP(j,Vmax){\n\t\tif(i-1>=0)add(binom[i][j],binom[i-1][j]);\n\t\tif(j-1>=0)add(binom[i][j],binom[i][j-1]);\n\t}\n}\nint Choose(int n,int k){\n\treturn binom[n-k][k];\n}\n\nconst int Nmax=75;\nint n,k;\nstring s;\nvi t;\nint SetT(){\n\tt.resize(k,inf);\n\tint j=0,cnt=0;\n\tREP(i,k)\n\t\tif(s[i]=='r'){\n\t\t\twhile(j<k&&(j<i||s[j]=='r'))\n\t\t\t\tj++;\n\t\t\tif(j==k)\n\t\t\t\tbreak;\n\t\t\tt[i]=cnt*2;\n\t\t\tt[j]=cnt*2+1;\n\t\t\tj++;\n\t\t\tcnt++;\n\t\t}\n\treturn cnt;\n}\n\nint dp[Nmax][Nmax][Nmax];\nvi Sigma(vi num){\n\tint p=num.size(),m=num.back();\n\tZERO(dp);\n\tdp[0][0][0]=1;\n\tREP(y,m+1){\n\t\tfor(int x=p;x>=0;x--){\n\t\t\tREP(sm,m+1){\n\t\t\t\tint cur=sm;\n\t\t\t\tFOR(z,x+1,p+1){\n\t\t\t\t\tcur+=y;\n\t\t\t\t\tif(cur>num[z-1])break;\n\t\t\t\t\tadd(dp[z][y][cur],dp[x][y][sm]*Choose(p-x,z-x));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(y<m)\n\t\tREP(x,p+1)\n\t\t\tREP(sm,m+1)\n\t\t\t\tadd(dp[x][y+1][sm],dp[x][y][sm]);\n\t}\n\treturn vi(dp[p][m],dp[p][m]+m+1);\n}\n\nint hog[Nmax];\n\nint semiBuf[Nmax][Nmax];\nvoid Semiexp(int u,int p,int w){\n\tif(u==0){\n\t\tadd(hog[1],w);\n\t}else{\n\t\tadd(hog[u+p-1],w);\n\t\tadd(hog[u+p],w*2);\n\t\tadd(hog[u+p+1],w);\n\t}\n}\n\nvoid Wafrelka(int p,int q){\n\tvi z(k,0);\n\t{\n\t\tint cnt=0;\n\t\tREP(i,k)\n\t\t\tif(t[i]>=p*2&&s[i]=='r'&&cnt<q){\n\t\t\t\tz[i]=1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\tif(cnt<q)return;\n\t}\n\tvi num(p,0);\n\t{\n\t\tint j=0;\n\t\tfor(int i=k-1;i>=0;i--)if(j<p){\n\t\t\tif(t[i]>=p*2){\n\t\t\t\tif(z[i]==0)\n\t\t\t\t\tnum[j]++;\n\t\t\t}else if(t[i]%2){\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,1,p)\n\t\tnum[i]+=num[i-1];\n\tif(p==0)num.PB(0);\n\tvi x=Sigma(num);\n\tREP(i,x.size()){\n\t\tREP(j,p*2+1){\n\t\t\tint w=Choose(p+q,p);\n\t\t\tmult(w,x[i]);\n\t\t\tmult(w,Choose(p*2,j));\n\t\t\tint used=p+i*2+j+q;\n\t\t\tif(used+(p+q-1)<=n)\n\t\t\t\tadd(semiBuf[used][p+q],w);\n\t\t}\n\t}\n}\n\nint Wo(){\n\tint res=0;\n\tFOR(i,1,n+1)\n\t\tadd(res,hog[i]*Choose(n-1,i-1));\n\treturn res;\n}\n\nsigned main(){\n\tInit();\n\tn=read(),k=read();\n\ts=readString();\n\tint cnt=SetT();\n\tREP(p,cnt+1)REP(q,k-p*2+1)\n\t\tWafrelka(p,q);\n\tREP(i,n+1)REP(j,n+1)\n\t\tSemiexp(i,j,semiBuf[i][j]);\n\tcout<<Wo()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\n#define int long long\n\n#define left __left__\n\nconst int N=70+10;\n\nconst int A=520;\n\nconst int MOD=1000000007;\n\nint n,k;\n\nchar s[N];\n\nint C[A][A];\n\nvoid prework()\n{\n\tint i,j;\n\tfor(i=0;i<A;++i)\n\t{\n\t\tC[i][0]=1;\n\t\tfor(j=1;j<=i;++j)\n\t\t\tif((C[i][j]=C[i-1][j-1]+C[i-1][j])>=MOD)\n\t\t\t\tC[i][j]-=MOD;\n\t}\n}\n\nint ans;\n\nint B[N],ed,left;\n\nbool valid()\n{\n\tif(!ed)\n\t\treturn false;\n\tint i,j=1,jj=1,c=0;\n\tfor(i=1;i<=k&&(j<=ed||B[jj]>1||c);++i)\n\t{\n\t\tif(j<=ed&&s[i]=='r')\n\t\t\t++j;\n\t\telse if(jj<j&&B[jj]>1&&s[i]=='b')\n\t\t\tc+=B[jj++]-2;\n\t\telse if(c)\n\t\t\t--c;\n\t}\n\treturn !(j<=ed||B[jj]>1||c);\n}\n\nvoid update()\n{\n\tint i,j,res(1),em(0);\n\tfor(i=1;i<=ed;i=j+1)\n\t{\n\t\tfor(j=i;B[j+1]==B[i];++j);\n\t\tres=res*C[j][i-1]%MOD;\n\t\tem+=(j-i+1)*((B[i]<<1)-1);\n\t}\n\tem+=ed+1;\n\tres=res*C[em-1+left][em-1]%MOD;\n\tif((ans+=res)>=MOD)\n\t\tans-=MOD;\n}\n\nvoid dfs(int lim)\n{\n\tif(left<0)\n\t\treturn;\n\tif(valid())\n\t\tupdate();\n\tif(ed)\n\t\t--left;\n\t++ed;--left;\n\tdfs(B[ed]=1);\n\t++left;\n\tfor(int i=2;i<=lim;++i)\n\t{\n\t\tleft-=(i<<1)-3;\n\t\tdfs(B[ed]=i);\n\t\tleft+=(i<<1)-3;\n\t}\n\tB[ed--]=0;\n\tif(ed)\n\t\t++left;\n}\n\nsigned main()\n{\n\tscanf(\"%lld%lld%s\",&n,&k,s+1);\n\tprework();\n\tleft=n;dfs(n);\n\tprintf(\"%lld\",(ans+1)%MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 75\nusing namespace std;\nconst int mod = 1e9+7;\nint n,k,m,a[maxn],x[maxn],C[maxn*2][maxn*2],ans=1;\nchar s[maxn];\nvoid dfs(int d,int l,int r,bool chose){\n\tif(chose){\n\t\tint R=1,B=1,S=0;\n\t\tfor(int i=1;i<=k;i++){\n\t\t\tif(s[i]=='r') {if(R<=m) R++; else if(S) S--;}\n\t\t\tif(s[i]=='b') {if(B<R&&x[B]) S+=x[B++]-1; else if(S) S--;}\n\t\t}\n\t\tif(R>m&&(B>m||!x[B])&&!S){\n\t\t\tint ret=C[n-l+r][r];\n\t\t\tfor(int i=d+1;i<=x[1];i++) S+=a[i],ret=1ll*ret*C[S][a[i]]%mod;\n\t\t\tans=(ans+ret)%mod;\n\t\t}\n\t}\n\tif(d<0) return;\n\tint tm=m,tl=(d?2*d-1:1),tr=2*d+1;\n\tfor(int i=0;l<=n;x[++m]=d,l+=tl+(l!=0),r+=tr+1,i++) \n\t\ta[d]=i,dfs(d-1,l,r,i);\n\tm=tm;\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tfor(int i=C[0][0]=1;i<150;i++) for(int j=C[i][0]=1;j<=i;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\tdfs(n,0,0,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 75, K = 75;\nconst long long mod = 1000000007ll;\n\nint n, m, stk[N], suf[K], pos[K], tmp[N], top = 0;\nchar str[K];\nbool vis[K];\nlong long c[N * 3][N * 3], ans = 0ll;\nvector<pair<int, int> > vec;\n\nbool check () {\n\n\tint cnt = 0;\n\tvector<int> sta;\n\tfor (int i = 0; i < top; i++) cnt += (bool)stk[i];\n\tif (cnt > vec.size()) return false;\n\tfor (int i = 0; i < m; i++) vis[i] = true;\n\tfor (int i = 0; i < cnt; i++) {\n\t\tvis[vec[i].first] = vis[vec[i].second] = false;\n\t\tpos[i] = vec[i].second;\n\t}\n\n\tint b = 0, r = 0, j = m - 1;\n\tfor (int i = cnt - 1; i >= 0; i--) {\n\t\tfor (; j >= pos[i]; j--) {\n\t\t\tif (vis[j] && str[j] == 'b') b++;\n\t\t\tif (vis[j] && str[j] == 'r') r++;\n\t\t}\n\t\tif (b + r < stk[top - 1 - i] - 1) return false;\n\t\tif (b >= stk[top - 1 - i] - 1) b -= stk[top - 1 - i] - 1;\n\t\telse r = b + r - stk[top - 1 - i] + 1, b = 0; \n\t}\n\tfor (; j >= 0; j--) {\n\t\tif (vis[j] && str[j] == 'b') b++;\n\t\tif (vis[j] && str[j] == 'r') r++;\n\t}\n\treturn r >= top - cnt;\n}\nlong long solve () {\n\tif (!check()) return 0ll;\n\tlong long res = 1ll;\n\tfor (int i = 0; i <= n; i++) tmp[i] = 0;\n\tfor (int i = 0; i < top; i++) tmp[stk[i]]++;\n\tfor (int i = 0, j = 0; i <= n; i++) {\n\t\tj += tmp[i];\n\t\tres = res * c[j][tmp[i]] % mod;\n\t}\n\n\tint num1 = 0, num2 = 0;\n\tfor (int i = 0; i < top; i++) {\n\t\tif (stk[i]) num1 += 2 * stk[i] - 1, num2 += 2;\n\t\telse num1++;\n\t}\n\tif (top) num1 += top - 1, num2 += 2;\n\telse num1++;\n\tres = res * c[n + num2 - 1][num1 + num2 - 1] % mod;\n\treturn res;\n}\n\nvoid dfs (int mn, int total) {\n\tif (mn == n + 1) ans = (ans + solve()) % mod;\n\tif (mn <= n) dfs(mn + 1, total);\n\tint t = mn ? mn << 1 : 2;\n\tif (total + t <= n + 1) {\n\t\tstk[top++] = mn;\n\t\tdfs(mn, total + t);\n\t\ttop--;\n\t}\n}\n\nint main () {\n\tscanf(\"%d%d%s\", &n, &m, str);\n\tqueue<int> que;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (str[i] == 'r') que.push(i);\n\t\telse if (!que.empty()) {\n\t\t\tvec.push_back(make_pair(que.front(), i));\n\t\t\tque.pop();\n\t\t}\n\t}\n\tfor (int i = 0; i <= n * 3; i++) c[i][0] = c[i][i] = 1ll;\n\tfor (int i = 1; i <= n * 3; i++) {\n\t\tfor (int j = 1; j < i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n\t}\n\tdfs(0, 0);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=1005;\nint C[maxn][maxn];\nint fac[maxn],invfac[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=1LL*fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline int comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nvi apos;\nint ca=0;\nint n,k;\nvi f;\nint solve()\n{\n    if(!f.size()) return 1;\n    int pr=f.size()-1,pb=f.size()-1,pc=f.size()-1,pd=f.size()-1;\n    vi len(f.size());\n    for(int i=0;i<s.length();i++)\n    {\n        if(s[i]=='r')\n        {\n            if(pr>=0)\n            {\n                len[pr]++;\n                pr--;\n            }\n            else{\n                while(pc>=0&&len[pc]==f[pc]) pc--;\n                if(pc>=0&&len[pc]>1) len[pc]++;\n            }\n        }\n        else{\n            bool use=0;\n            if(pb>=0)\n            {\n                while(pb>=0&&len[pb]==f[pb]) pb--;\n                if(pb>=0&&len[pb])\n                {\n                    len[pb]++;\n                    pb--;\n                    use=1;\n                }\n            }\n            if(!use)\n            {\n                while(pd>=0&&len[pd]==f[pd]) pd--;\n                if(pd>=0&&len[pd]>1) len[pd]++;\n            }\n        }\n    }\n    for(int i=0;i<f.size();i++) if(f[i]!=len[i]) return 0;\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++)\n    {\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    int ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nint dfs(int r,int mx,int cc,int len=0)\n{\n    if(len+(int)f.size()-1>n) return 0;\n    int ret=1LL*solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(f.size()>=ca) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        int cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=1LL*cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    for(int i=0;i<k;i++) \n    {\n        ca+=s[i]=='r';\n        if(s[i]=='r') apos.push_back(i);\n    }\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cassert>\n\n#define P 1000000007\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\n\nchar ch[77];\n\nvoid add(int &x, int y) {\n    x = (x + y) % P;\n}\n\nint n, K, Fac[333], Rev[333], X[77], C[333][333], ans = 0;\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n    ll ans = 1;\n    while(y) {\n        if(y & 1) ans = ans * x % p;\n        x = x * x % p;\n        y >>= 1;\n    }\n    return ans;\n}\nint ts = 0;\nvoid calc(int sz) {\n    ts++;\n    int tb = 0, tr = 0;\n    int used[77], TR[77], TB[77];\n    memset(used, 0, sizeof used);\n    for(int i = 1; i <= sz; i++) {\n        tr++;\n        while(tr <= K && ch[tr] != 'r') tr++;\n        used[tr] = 1;\n        if(X[i] > 1) {\n            tb = max(tb + 1, tr);\n            while(tb <= K && ch[tb] != 'b') tb++;\n            used[tb] = 1;\n            TR[i] = tr;\n            TB[i] = tb;\n        } else {\n            TR[i] = tr;\n            TB[i] = tr;\n        }\n        if(tr > K || tb > K) return;\n    }\n    for(int i = 1; i <= sz; i++) {\n        int tt = TB[i];\n        for(int j = 1; j <= X[i] - 2; j++) {\n            while(tt <= K && used[tt]) tt++;\n            if(tt > K) return;\n        }\n    }\n    int t = 0, rw = 0, bw = 0;\n    for(int i = 1; i <= sz; i++)\n        if(X[i] == 1) {\n            rw++;\n            t++;\n        } else {\n            bw += X[i] - 1;\n            rw += X[i];\n            t += X[i] * 2 - 3;\n        }\n    t = n + 1 - t - sz;\n    if(t < 0) return;\n    ll tmp = Fac[sz];\n    X[sz + 1] = 0; //!!!\n    for(int i = 2, lst = 1; i <= sz + 1; i++)\n        if(X[i] != X[lst]) {\n            tmp = tmp * Rev[i - lst] % P;\n            lst = i;\n        }\n    for(int r = 0; r <= t; r++)\n        for(int b = 0; r + b <= t; b++) {\n            add(ans, (!rw ? !r : C[r + rw - 1][r]) * (!bw ? !b : C[b + bw - 1][b]) % P * C[sz + (t - r - b)][sz] % P * tmp);\n        }\n}\n\nvoid Search(int x, int lst, int tbr, int tot = 0) {\n    calc(x - 1);\n    for(int i = 1; i <= lst && i + tbr <= K && max(2ll, i * 2 - 2) + tot <= n + 3; i++) {\n        X[x] = i;\n        Search(x + 1, i, tbr + i, tot + max(2ll, i * 2 - 2));\n    }\n}\n\n#undef int\nint main() {\n#define int long long\n    for(int i = 0; i < 333; i++)\n        for(int j = 0; j <= i; j++)\n            C[i][j] = !j ? 1 : (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    for(int i = 0; i < 333; i++) Fac[i] = !i ? 1 : Fac[i - 1] * i % P;\n    for(int i = 332; i >= 0; i--) Rev[i] = i == 332 ? powmod(Fac[i]) : Rev[i + 1] * (i + 1) % P;\n    scanf(\"%lld%lld\", &n, &K);\n    scanf(\"%s\", ch + 1);\n    Search(1, K, 0);\n    //printf(\"%d\\n\", ts);\n    printf(\"%lld\\n\", (ans % P + P) % P);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int mod=1e9+7;\nint n,k;\nchar s[75],vis[75];\nint len[75],tag[75];\nll ans,fac[205],finv[205],C[205][205];\ninline bool check(int cnt){\n\tmemset(vis,0,sizeof(vis));\n\tmemset(tag,0,sizeof(tag));\n\tint fr=1,fb=1,now=0;\n\tfor(int i=cnt;i;--i){\n\t\tif(len[i]==1){\n\t\t\twhile(fr<=k&&s[fr]!='r') ++fr;\n\t\t\tif(fr>k) return 0;\n\t\t\tvis[fr++]=1;\n\t\t}\n\t\telse{\n\t\t\twhile(fr<=k&&s[fr]!='r') ++fr;\n\t\t\twhile(fb<=k&&(fb<=fr||s[fb]!='b')) ++fb;\n\t\t\tif(fr>k||fb>k) return 0;\n\t\t\tvis[fr++]=vis[fb++]=1; tag[max(fr,fb)-1]+=len[i]-2;\n\t\t}\n\t}\n\tfor(int i=k;i;--i){\n\t\tif(!vis[i]) ++now;\n\t\telse now-=tag[i];\n\t\tif(now<0) return 0;\n\t}\n\treturn 1;\n}\nbool dfs(int sum,int lst,int cnt,int tot){\n\tif(tot<0||!check(cnt)) return 0;\n\tint num=cnt+1;\n\tfor(int i=1;i<=cnt;++i) num+=len[i]*2-1;\n\tll now=C[tot+num-1][tot]*fac[cnt]%mod;\n\tfor(int i=1,sz=len[cnt+1]=0;i<=cnt+1;++i) if(len[i]==len[i-1]) ++sz; else now=now*finv[sz]%mod,sz=1;\n\t(ans+=now)%=mod;\n\tfor(int i=lst;i<=k-sum;++i){\n\t\tlen[cnt+1]=i;\n\t\tif(!dfs(sum+i,i,cnt+1,tot-(i<=2?1:i*2-3)-(cnt>0))) return 1;\n\t}\n\treturn 1;\n}\ninline ll qpow(ll x,int k,ll r=1){\n\tfor(;k;k>>=1,x=x*x%mod) if(k&1) r=r*x%mod;\n\treturn r;\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tfor(int i=fac[0]=1;i<=200;++i) fac[i]=fac[i-1]*i%mod;\n\tfinv[200]=qpow(fac[200],mod-2);\n\tfor(int i=200;i;--i) finv[i-1]=finv[i]*i%mod;\n\tfor(int i=0;i<=200;++i) for(int j=C[i][0]=1;j<=i;++j) C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n\tdfs(0,1,0,n);\n\treturn printf(\"%lld\\n\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint N,K;\nstring S;\n\nint r[111],b[111];\nint R,B;\n\nint ans;\nvint X;\n\nbool used[100];\nint p[100];\nint calc(){\n    int n=X.size();\n    if(n>R)return 0;\n\n    memset(used,0,sizeof(used));\n    rep(i,n)used[r[R-i]]=true;\n    int pos=B;\n    for(int i=0;i<n;i++){\n        if(X[i]==1)break;\n        while(pos>0&&b[pos]<r[R-i])pos--;\n        if(pos==0)return 0;\n        used[b[pos]]=true;\n        p[i]=pos;\n        pos--;\n    }\n    pos=0;\n    rep(i,n){\n        chmax(pos,b[p[i]]+1);\n        rep(t,X[i]-2){\n            while(pos<N&&used[pos])pos++;\n            if(pos==N)return 0;\n            used[pos]=true;\n            pos++;\n        }\n    }\n\n    vpint ei;\n    rep(i,X.size()){\n        if(ei.size()==0||ei.back().fi!=X[i])ei.pb({X[i],1});\n        else ei.back().se++;\n    }\n\n    int latte=0;\n    int s=0;\n    for(int i=0;i<X.size();i++){\n        if(X[i]==1){\n            latte++;\n            s++;\n        }\n        else{\n            latte+=X[i]*2-3;\n            s+=X[i]*2-3+2;\n        }\n    }\n\n    int ret=0;\n    for(int k=0;latte+k<=N;k++){\n        int y=N-latte-k;\n        add(ret,nCk(y+1,n)*nCk(s-1+k,k)%mod);\n    }\n    ret=ret*fact[n]%mod;\n    rep(i,ei.size())ret=ret*inv[ei[i].se]%mod;\n    return ret;\n}\n\nvoid dfs(int n,int k){\n    add(ans,calc());\n\n    if(X.size()>=R)return;\n    for(int i=1;i<=X.back();i++){\n        int nn=n+1;\n        if(i==1)nn++;\n        else nn+=2*i-3;\n        int nk=k+i;\n        if(nn>N||nk>K)continue;\n        X.pb(i);\n        dfs(nn,nk);\n        X.pop_back();\n    }\n}\n\nsigned main(){\n    cin>>N>>K;\n    cin>>S;\n    for(int i=K-1;i>=0;i--){\n        if(S[i]=='r'){\n            r[++R]=i;\n        }\n        else{\n            b[++B]=i;\n        }\n    }\n\n    for(int i=1;i<=K;i++){\n        X.pb(i);\n        if(i==1)dfs(1,1);\n        else dfs(2*i-3,i);\n        X.pop_back();\n    }\n    add(ans,1ll);\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n\nconst int DEBUG = 0;\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define DEBUGP(val) cerr << #val << \"=\" << val << \"\\n\"\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\nll powmod(ll a, ll e) {\n  ll sum = 1;\n  ll cur = a;\n  while (e > 0) {\n    if (e % 2) {\n      sum = sum * cur % mod;\n    }\n    cur = cur * cur % mod;\n    e /= 2;\n  }\n  return sum;\n}\n\n\nconst int M = 200000;\nll fact[M], invfact[M];\nvoid init(void) {\n  fact[0] = 1;\n  REP(i, 1, M) {\n    fact[i] = fact[i - 1] * i % mod;\n  }\n  invfact[M - 1] = powmod(fact[M - 1], mod - 2);\n  for (int i = M - 2; i >= 0; --i) {\n    invfact[i] = invfact[i + 1] * (i + 1) % mod;\n  }\n}\n\nll comb(int x, int y) {\n  if (x < 0) {\n    return y == 0 || y == x ? 1 : 1;\n  }\n  if (y < 0 || y > x) {\n    return 0;\n  }\n  long r = fact[x] * (invfact[x - y] * invfact[y] % mod) % mod;\n  return r;\n}\n\nvoid add(ll &x, ll y) {\n  x = (x + y) % mod;\n}\n\n\nint n, k;\nstring s;\n\nll match(const VI &v) {\n  int m = v.size();\n  VI r(m, -1);\n  VI used(k, 0);\n  int pos = 0;\n  REP(i, 0, m) {\n    while (pos < k && s[pos] != 'r') {\n      pos++;\n    }\n    if (pos == k) return 0;\n    r[i] = pos;\n    used[pos] = 1;\n    pos++;\n  }\n  pos = 0;\n  REP(i, 0, m) {\n    if (v[i] <= 1) break;\n    pos = max(pos, r[i] + 1);\n    while (pos < k && s[pos] != 'b') { pos++; }\n    if (pos == k) return 0;\n    used[pos] = 1;\n    pos++;\n  }\n  pos = 0;\n  REP(i, 0, m) {\n    if (v[i] <= 2) break;\n    int res = v[i] - 2;\n    REP(j, 0, res) {\n      while (pos < k && used[pos] == 1) { pos++; }\n      if (pos == k) return 0;\n      used[pos] = 1;\n      pos++;\n    }\n  }\n  ll tmp = fact[v.size()];\n  map<int, int> freq;\n  REP(i, 0, v.size()) {\n    freq[v[i]] += 1;\n  }\n  for (auto p: freq) {\n    tmp = tmp * invfact[p.second] % mod;\n  }\n  int x = n + 1;\n  int y = 0;\n  REP(i, 0, v.size()) {\n    if (v[i] >= 2) {\n      x += 2;\n    }\n    y += 2 * v[i];\n  }\n  if(DEBUG){\n    DEBUGP(x);\n    DEBUGP(y);\n  }\n  tmp = tmp * comb(x, y) % mod;\n  return tmp;\n}\n\nint cnt = 0;\nll tot = 0;\nvoid output(const VI &vi) {\n  cnt++;\n  if (DEBUG && n <= 10) {\n    cerr << \"out:\";\n    for (auto c: vi) cerr << \" \" << c;\n    cerr << endl;\n  }\n  ll res = match(vi);\n  add(tot, res);\n  if (DEBUG) {\n    DEBUGP(res);\n    cerr<<endl;\n  }\n}\n\n\nvoid calc(int rem, int ma, int maxlen, VI &v) {\n  if (rem < -1) return;\n  output(v);\n  if ((int) v.size() >= maxlen) return;\n  for (int i = min(rem, ma); i >= 1; --i) {\n    v.push_back(i);\n    int len = i <= 1 ? 1 : 2 * i - 3;\n    calc(rem - len - 1, i, maxlen, v);\n    v.pop_back();\n  }\n}\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init();\n  cin >> n >> k;\n  cin >> s;\n  VI ret;\n  int rc = 0;\n  REP(i, 0, k) {\n    if (s[i] == 'r') rc++;\n  }\n  calc(n, k, rc, ret);\n  DEBUGP(cnt);\n  cout << tot << endl;\n}\n\n#if 0\n  int ymax = 0;\n  int zmax = 0;\n  VI col;\n  REP(i, 0, k) {\n    if (s[i] == 'b') {\n      if (col.size() >= 1) {\n\tcol.back()++;\n      }\n      zmax += 1;\n    } else {\n      col.push_back(0);\n      ymax += 1;\n    }\n  }\n  VI col_acc(col.size() + 1, 0);\n  REP(i, 0, col.size()) {\n    col_acc[i + 1] = col_acc[i] + col[i];\n  }\n  dp[0][0][0] = 1;\n  for (int i = N - 1; i >= 0; --i) {\n    memset(dp2, 0, sizeof(dp2));\n    REP(x, 0, N) {\n      REP(y, 0, N) {\n\tREP(z, 0, N) {\n\t  if (dp[x][y][z] == 0) continue;\n\t  if (DEBUG&&0){\n\t    cerr << endl;\n\t    DEBUGP(x);\n\t    DEBUGP(y);\n\t    DEBUGP(z);\n\t    DEBUGP(dp[x][y][z]);\n\t  }\n\t  // TODO\n\t  REP(l, 0, N) {\n\t    int ny = y + l;\n\t    int nz = z + i * l;\n\t    if (ny >= N || nz >= N) continue;\n\t    REP(u, 0, N - x) {\n\t      int nx = x + u;\n\t      ll tmp = dp[x][y][z] * comb(u + 1 + 2 * l - 2, 2 * l * (i + 1) - 2);\n\t      tmp = tmp * invfact[l] % mod;\n\t      add(dp2[nx][ny][nz], tmp);\n\t      if (DEBUG&&0){\n\t\tDEBUGP(l);\n\t\tDEBUGP(u);\n\t\tDEBUGP(tmp);\n\t\tDEBUGP(u + 1 + 2 * l - 2);\n\t\tDEBUGP(2 * l * (i + 1) - 2);\n\t\tcerr << endl;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    swap(dp, dp2);\n  }\n  DEBUGP(dp[n+1][col.size()][k - col.size()]);\n#endif\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\nint n,k;\nchar str[1111];\ntypedef long long ll;\ncpnst ll mod=1e9+7;\nll C[1111][1111],fac[1111];\nvoid precalc()\n{\n\tregister int i,ii;\n\tC[0][0]=1;\n\tfor(i=fac[0]=1;i<=1000;i++)fac[i]=fac[i-1]*i%mod;\n\tfor(i=1;i<=1000;C[i][0]=1,i++)\n\t\tfor(ii=1;ii<=1000;ii++)C[i][ii]=(C[i-1][ii-1]+C[i-1][ii])%mod;\n}\nll ans=0;\nint siz[1111];\nbool vis[1111];\nbool eraser()\n{for(register int i=k;i;i--)if(!vis[i])if(str[i]=='r')return vis[i]=1;return 0;}\nvoid cover(register int p,int s)\n{for(;s;p++)if(!vis[p])vis[p]=1,s--;}\nbool elim(int ss)\n{\n\tint R=0;\n\tfor(register int i=k;i;i--)\n\t{\n\t\tif(!vis[i])R++;\n\t\tif(R>=ss)if(!vis[i])if(str[i]=='r')return cover(i,ss),1;\n\t}return 0;\n}\nbool valid(int T)\n{\n\tif(!T)return 1;\n\tregister int i;\n\tfor(i=1;i<=k;i++)vis[i]=0;\n\tfor(i=1;i<=T;i++)\n\t\tif(siz[i]==1)\n\t\t\tif(!eraser())return 0;\n\tfor(i=T;i;i--)\n\t\tif(siz[i]>1)\n\t\t\tif(!elim(siz[i]))return 0;\n\treturn 1;\n}\nll concen(int T)\n{\n\tregister int i,ii;\n\tll ret=1,G=T;\n\tfor(i=1;i<=T;i=ii+1)\n\t{\n\t\tfor(ii=i;ii<T&&siz[ii]==siz[ii+1];ii++);\n\t\t(ret*=C[G][ii-i+1])%=mod,G-=ii-i+1;\n\t}return ret;\n}\nll solve(int T,int res)\n{\n\tif(!T)return 1;\n\tregister int i;\n\tll SS=T+1;\n\tfor(i=1;i<=T;i++)SS+=2*siz[i]-1;\n\treturn C[SS+res-1][res]*concen(T);\n}\nvoid dfs(int dep=1,int lim=k,int prev=k,int sum=0)\n{\n\tif(sum>n)return;\n\tif(!valid(dep-1))return;\n\t(ans+=solve(dep-1,n-sum))%=mod;\n\tregister int i;\n\tif(lim>n)lim=n+1;\n\tif(prev>lim)prev=lim;\n\tif(dep^1)sum++;\n\tfor(i=prev;i;i--)siz[dep]=i,dfs(dep+1,lim-i,i,sum+(i<<1)-3+(i==1)*2);\n}\nint main()\n{precalc(),scanf(\"%d%d%s\",&n,&k,str+1),dfs(),printf(\"%lld\\n\",ans);}\n/*\nJust go for it.\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n\nstring str;\nll comb[301][301];\nint n,k;\nint group[81];\nint assign[81];\nbool used[81];\nll dp2[101][101];\nll ans;\n\nbool isvalid(int v){\n\tint len=0;\n\tfor(int i=0;i<v;i++){\n\t\tif(i!=0)len++;\n\t\tif(group[i]==1){\n\t\t\tlen++;\n\t\t}else{\n\t\t\tlen+=group[i]*2-3;\n\t\t}\n\t}\n\tif(len>n)return false;\n\tmemset(assign,0,sizeof(assign));\n\tmemset(used,false,sizeof(used));\n\tint cnt=0;\n\tfor(int i=0;i<k;i++){\n\t\tif(cnt==v)break;\n\t\tif(str[i]=='r'){\n\t\t\tassign[cnt++]=i;\n\t\t\tused[i]=true;\n\t\t}\n\t}\n\tif(cnt<v)return false;\n\tfor(int i=0;i<v;i++){\n\t\tif(group[i]>=2){\n\t\t\tbool flag=false;\n\t\t\tfor(int j=assign[i]+1;j<k;j++){\n\t\t\t\tif(str[j]=='b' && !used[j]){\n\t\t\t\t\tused[j]=true;\n\t\t\t\t\tflag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag)return false;\n\t\t}\n\t}\n\tfor(int i=0;i<v;i++){\n\t\tif(group[i]>=3){\n\t\t\tint rest=group[i]-2;\n\t\t\tfor(int j=assign[i]+1;j<k;j++){\n\t\t\t\tif(!used[j]){\n\t\t\t\t\tused[j]=true;\n\t\t\t\t\trest--;\n\t\t\t\t}\n\t\t\t\tif(rest==0)break;\n\t\t\t}\n\t\t\tif(rest!=0)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nll dp[2][71];\n\nvoid dfs(int v,int now){\n\tif(v>0){\n\t\tif(!isvalid(v))return;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint cur=0,nxt=1;\n\t\tdp[cur][v-1]=1;\n\t\tfor(int i=0;i<v;i++){\n\t\t\tfor(int j=0;j<=n;j++){\n\t\t\t\tif(group[i]==1){\n\t\t\t\t\tif(j+1<=n){\n\t\t\t\t\t\tdp[nxt][j+1]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+1]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tint pl=(group[i]-1)*2-1;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\tpl=(group[i]-1)*2;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j]*2;\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\tpl=(group[i]-1)*2+1;\n\t\t\t\t\tif(j+pl<=n){\n\t\t\t\t\t\tdp[nxt][j+pl]+=dp[cur][j];\n\t\t\t\t\t\tdp[nxt][j+pl]%=MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur,nxt);\n\t\t\tmemset(dp[nxt],0,sizeof(dp[nxt]));\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<v;i++){\n\t\t\tprintf(\"%d \",group[i]);\n\t\t}\n\t\tprintf(\"ok\\n\");\n\t\t*/\n\t\tll pw=1;\n\t\tint len=1,rest=v;\n\t\tfor(int i=1;i<v;i++){\n\t\t\tif(group[i]==group[i-1]){\n\t\t\t\tlen++;\n\t\t\t}else{\n\t\t\t\tpw=pw*comb[rest][len]%MOD;\n\t\t\t\trest-=len;\n\t\t\t\tlen=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tll va=(dp[cur][i]*pw)%MOD;\n\t\t\t//printf(\"%lld \",dp[cur][i]);\n\t\t\tva=va*dp2[i+2][n-i]%MOD;\n\t\t\tans+=va;\n\t\t\tans%=MOD;\n\t\t}\n\t\t//printf(\"\\n\");\n\t\t//printf(\"%lld %lld\\n\",pw,ans);\n\t}\n\tfor(int i=1;i<=now;i++){\n\t\tgroup[v]=i;\n\t\tdfs(v+1,i);\n\t}\n}\n\nint main(void){\n\tcomb[0][0]=1;\n\tfor(int i=1;i<=300;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tcomb[i][j]=(comb[i-1][j-1]+comb[i-1][j])%MOD;\n\t\t}\n\t\tcomb[i][0]=1;\n\t\tcomb[i][i]=1;\n\t}\n\tdp2[1][0]=1;\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<100;j++){\n\t\t\tdp2[i+1][j]+=dp2[i][j];\n\t\t\tdp2[i+1][j]%=MOD;\n\t\t\tdp2[i][j+1]+=dp2[i][j];\n\t\t\tdp2[i][j+1]%=MOD;\n\t\t}\n\t}\n\tscanf(\"%d%d\",&n,&k);\n\tcin >> str;\n\tdfs(0,36);\n\tprintf(\"%lld\\n\",(ans+1LL)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 70 + 10,mod = 1e9 + 7;\n\nint a[N],vis[N],fac[N << 1],inv[N << 1],Pos[N];\nchar str[N];\n\nint n,k,ans = 0;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline int fpm(int A,int b) {\n\tint res = 1;\n\twhile(b) {\n\t\tif(b & 1) res = 1ll * res * A % mod;\n\t\tA = 1ll * A * A % mod,b /= 2;\n\t}\n\treturn res;\n}\n\ninline int C(int A,int B) {\n\treturn 1ll * fac[A] * inv[B] % mod * inv[A - B] % mod;\n}\n\ninline void Calc(int len,int sum) {\n\tmemset(vis,0,sizeof(vis)),memset(Pos,0,sizeof(Pos));\n\tsort(a + 1,a + len + 1,greater<int>());\n\tint lasr = 0,lasb = 0;\n\tFor(i,1,len) {\n\t\tint pos = 0;\n\t\tFor(j,lasr + 1,k) if(!vis[j] && str[j] == 'r') {\n\t\t\tvis[j] = true;\n\t\t\tpos = lasr = j;break;\n\t\t}\n\t\tif(!pos) return;\n\t\tif(a[i] < 2) continue;\n\t\tFor(j,max(pos,lasb) + 1,k) if(!vis[j] && str[j] == 'b') {\n\t\t\tvis[j] = true;\n\t\t\tPos[i] = lasb = j;break;\n\t\t}\n\t\tif(!Pos[i]) return;\n\t}\n\tint Las = 0;\n\tFor(i,1,len) {\n\t\tif(a[i] < 3) continue;\n\t\tint cnt = 0;\n\t\tFor(j,max(Pos[i],Las) + 1,k) {\n\t\t\tif(!vis[j]) cnt++,vis[j] = true;\n\t\t\tLas = j;\n\t\t\tif(cnt == a[i] - 2) break;\n\t\t}\n\t\tif(cnt < a[i] - 2) return;\n\t}\n\tint Inv = fac[len],tot = len + 1;\n\tfor(int i = 1,j = 1;i <= len;i = j + 1) {\n\t\tfor(j = i;j < len && a[j + 1] == a[i];j++);\n\t\tInv = 1ll * Inv * inv[j - i + 1] % mod;\n\t\ttot += (j - i + 1) * (a[i] * 2 - 1);\n\t}\n\tans = (ans + 1ll * Inv * C(n - sum + tot - 1,tot - 1)) % mod;\n}\n\ninline void dfs(int res,int Mn,int cur) {\n\tif(res < 0) return;\n\tCalc(cur - 1,n - res);\n\tif(res == 0) return;\n\tFordown(i,min(res,Mn),1) a[cur] = i,dfs(res - (i == 1 ? 1 : i * 2 - 3) - (cur > 1),i,cur + 1);\n}\n\ninline void init(int Lim) {\n\tfac[0] = 1;\n\tFor(i,1,Lim) fac[i] = 1ll * fac[i - 1] * i % mod;\n\tinv[Lim] = fpm(fac[Lim],mod - 2);\n\tFordown(i,Lim,1) inv[i - 1] = 1ll * inv[i] * i % mod;\n}\n\nint main() {\n\n\tn = read(),k = read();\n\tinit(150);\n\tscanf(\"%s\",str + 1);\n\n\tdfs(n,70,1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int MOD=1e9+7;\nstruct mint{int x;mint(int x=0):x(x){}};\ninline mint operator+  (mint a,mint b){return a.x+b.x<MOD?a.x+b.x:a.x+b.x-MOD;}\ninline mint operator-  (mint a){return MOD-a.x;}\ninline mint operator-  (mint a,mint b){return a+-b;}\ninline mint operator*  (mint a,mint b){return 1LL*a.x*b.x%MOD;}\ninline mint operator<< (mint x,int y){mint r=1;for(;y;y>>=1,x=x*x)if(y&1)r=r*x;return r;}\ninline mint operator~  (mint x){return x<<MOD-2;}\ninline mint operator/  (mint a,mint b){return a*~b;}\ninline mint&operator+= (mint&a,mint b){return a=a+b;}\ninline mint&operator-= (mint&a,mint b){return a=a-b;}\ninline mint&operator*= (mint&a,mint b){return a=a*b;}\ninline mint&operator<<=(mint&x,int y){return x=x<<y;}\ninline mint&operator/= (mint&a,mint b){return a=a/b;}\n#define MN 200\nchar s[MN+5];\nmint F[MN+5],R[MN+5],ans;\nint n,a[MN+5],an,b[MN+5],bn,u[MN+5],p[MN+5];\ninline mint C(int n,int m){return F[n]*R[m]*R[n-m];}\nvoid dfs(int x,int y,int z,int s0)\n{\n\tint i,j,k;\n\tmemset(u,0,sizeof(u));\n\tfor(i=j=1;i<z;++i)if(p[z-i])\n\t{\n\t\twhile(j<=bn&&b[j]<a[i])++j;\n\t\tif(j>bn)break;\n\t\tu[a[i]]=u[b[j++]]=1;\n\t}\n\tif(i==z)for(i=j=1;i<z;++i)\n\t{\n\t\tfor(k=1;k<p[z-i];++k)\n\t\t{\n\t\t\twhile(s[j]&&(j<i||u[j]))++j;\n\t\t\tif(!s[j++])break;\n\t\t}\n\t\tif(k<p[z-i])break;\n\t}\n\tif(i==z)\n\t{\n\t\tmint s=F[z-1];\n\t\tfor(i=1;i<z;s*=R[j-i],i=j)for(j=i;j<z&&p[i]==p[j];++j);\n\t\tans+=s*C(n+2*(z-1-s0),2*(z-1+x));\n\t}\n\tif(z<=an)for(;x+y<=an+bn-z&&x+y+s0+!y<=n/2;++y)dfs(x+y,p[z]=y,z+1,s0+!y);\n}\nint main()\n{\n\tint m,i;\n\tscanf(\"%d%d%s\",&n,&m,s+1);++n;\n\tfor(F[0]=i=1;i<=MN;++i)F[i]=F[i-1]*i;\n\tfor(R[i=MN]=~F[MN];i--;)R[i]=R[i+1]*(i+1);\n\tfor(i=1;i<=m;++i)(s[i]=='r'?a[++an]:b[++bn])=i;\n\tdfs(0,0,1,0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int mod=1e9+7;\nconst int maxn=1005;\nint C[maxn][maxn];\nint fac[maxn],invfac[maxn];\nll quick(ll a,ll b)\n{\n    ll ret=1;\n    while(b)\n    {\n        if(b&1) ret=ret*a%mod;\n        a=a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nll inv(ll a){return quick(a,mod-2);}\nvoid init()\n{\n    fac[0]=1;\n    invfac[0]=1;\n    for(int i=1;i<maxn;i++)\n    {\n        fac[i]=1LL*fac[i-1]*i%mod;\n        invfac[i]=inv(fac[i]);\n    }\n    for(int i=0;i<maxn;i++)\n    {\n        C[i][0]=1;\n        for(int j=1;j<=i;j++)\n            C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n}\nstring s;\ninline int comb(int n,int m)\n{\n    if(m>n) return 0;\n    return C[n][m];\n}\nvi apos;\nint ca=0;\nint n,k;\nint suf[75];\nvi f;\nint solve()\n{\n    if(!f.size()) return 1;\n    int need=0;\n    int p=0;\n    for(int i=f.size()-1;i>=0;i--)\n    {\n        need+=f[p]-1;\n        if(suf[apos[i]]+apos.size()-f.size()<need) return 0;\n        p++;\n    }\n    int L=f.size()-1;\n    int cnt=f.size()+1;\n    for(int i=0;i<f.size();i++)\n    {\n        if(f[i]==1) \n        {\n            L++;\n            cnt++;\n        }\n        else {\n            L+=2*f[i]-3;\n            cnt+=2*f[i]-1;\n        }\n    }\n    //dbg(f);\n    int ret=comb(n-L+cnt-1,cnt-1);\n    //dbg(ret,L,cnt);\n    return ret;\n}\nint dfs(int r,int mx,int cc,int len=0)\n{\n    if(len+(int)f.size()-1>n) return 0;\n    int ret=1LL*solve()*invfac[cc]%mod*fac[f.size()]%mod;\n    if(r==0) return ret;\n    if(f.size()>=ca) return ret;\n    for(int i=mx;i<=r;i++)\n    {\n        f.push_back(i);\n        int cur=dfs(r-i,i,(i==mx)?cc+1:1,i==1?len+1:len+2*i-3);\n        if(i!=mx) cur=1LL*cur*invfac[cc]%mod;\n        ret=(ret+cur)%mod;\n        f.pop_back();\n    }\n    return ret;\n}\nint main()\n{\n    init();\n    cin>>n>>k;\n    cin>>s;\n    for(int i=0;i<k;i++) \n    {\n        ca+=s[i]=='r';\n        if(s[i]=='r') apos.push_back(i);\n    }\n    for(int i=k-1;i>=0;i--)\n        suf[i]=suf[i+1]+(s[i]=='b');\n    print(dfs(k,1,0));\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=150,P=1e9+7;\nint n,m,top,ans,st[N],fac[N],ifac[N],inv[N],beg[N];\nchar s[N];\nbool vis[N];\nint C(int k1,int k2){\n\tif(k1<0||k2<0||k1-k2<0)return 0;\n\treturn 1LL*fac[k1]*ifac[k2]%P*ifac[k1-k2]%P;\n}\nbool chk(){\n\trep(i,1,m)vis[i]=0;\n\tint ntop=top;\n\trep(i,1,ntop)beg[i]=0;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='r')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t\tbeg[i]=beg[i];\n\t}\n\twhile(ntop&&st[ntop]==1)--ntop;\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\twhile(beg[i]<=m&&s[beg[i]]!='b')++beg[i];\n\t\tif(beg[i]>m)return 0;\n\t\tvis[beg[i]]=1;\n\t}\n\tfor(int i=1;i<=ntop;++i){\n\t\tbeg[i]=max(beg[i],beg[i-1]+1);\n\t\trep(_,1,st[i]-2){\n\t\t\twhile(beg[i]<=m&&vis[beg[i]])++beg[i];\n\t\t\tif(beg[i]>m)return 0;\n\t\t\t++beg[i];\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int num,int mn,int mx,int ntop){\n\tif(!num){\n\t\tif(!chk())return;\n\t\trep(i,1,top){\n\t\t\tD(\"%d \",st[i]);\n\t\t}\n\t\tD(\"\\n\");\n\t\tD(\">>> %d %d\\n\",mn,mx);\n\t\tint ans=C(n-mn+mx-1,mx-1);\n\t\twhile(ntop){\n\t\t\tint x=st[ntop];\n\t\t\tint t=0;\n\t\t\twhile(st[ntop]==x)++t,--ntop;\n\t\t\tans=1LL*ans*C(ntop+t,t)%P;\n\t\t}\n\t\t(::ans+=ans)%=P;\n\t\treturn;\n\t}\n\twhile(1){\n\t\tdfs(num-1,mn,mx,ntop);\n\t\ttop=ntop;\n\t\tmn+=(num==1?1:2*num-3)+!!mn;\n\t\tif(mn>n)return;\n\t\tmx+=2*num;\n\t\tst[++top]=num;\n\t\t++ntop;\n\t}\n}\nint main(){\n\tfac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;\n\tfor(int i=2;i<N;++i)fac[i]=1LL*fac[i-1]*i%P,inv[i]=1LL*(P-P/i)*inv[P%i]%P,ifac[i]=1LL*ifac[i-1]*inv[i]%P;\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tdfs(n+1,0,1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n/*\n1 35\nrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbr\n\n3\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nchar p[80];\nlong long n, K, chk[80], Loc[40], C[40], F[150], InvF[150], Mod = 1000000007;\nlong long D[40][40], TD[40][40]; // 한 블럭의 크기, 블럭의 개수, 쓴거의 개수\n\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = 1ll * r*a%Mod;\n\t\ta = 1ll * a*a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nlong long Comb(long long n, long long r) {\n\treturn 1ll * F[n] * InvF[r] % Mod*InvF[n - r]%Mod;\n}\nlong long Do(long long A, long long B) { // R* : A, RBxx : B\n\tlong long i, c1 = 0, c2 = 0, j, k, ii, jj;\n\tfor (i = 0; i < K; i++) {\n\t\tchk[i] = 0;\n\t\tif (p[i] == 'r' && c1 < B) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t\tif (p[i] == 'b' && c2 < c1) {\n\t\t\tchk[i] = 1;\n\t\t\tc2++;\n\t\t\tLoc[c2] = i;\n\t\t}\n\t}\n\tif (c1 < B || c2 < B)return 0;\n\tc1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tif (p[i] == 'r' && !chk[i] && c1 < A) {\n\t\t\tchk[i] = 1;\n\t\t\tc1++;\n\t\t}\n\t}\n\tif (c1 < A)return 0;\n\tfor (i = 1; i <= B; i++) {\n\t\tC[B-i+1] = 0;\n\t\tfor (j = Loc[i]; j < K; j++)if (!chk[j])C[B-i+1]++;\n\t}\n\tfor (i = 0; i < 40; i++)for (j = 0; j < 40; j++)D[i][j] = TD[i][j] = 0;\n\tD[0][0] = InvF[A];\n\n\tfor (i = 0; i <= n / 2; i++) {\n\t\tfor (j = 0; j < 40; j++) {\n\t\t\tfor (k = 0; k < 40; k++) {\n\t\t\t\tif (!D[j][k])continue;\n\t\t\t\tfor (ii = 0;; ii++) {\n\t\t\t\t\tlong long s = (ii*i + k);\n\t\t\t\t\tif (ii+j > B || s * 2 + A + B + (A + B - 1) > n || C[j+ii] < s)break;\n\t\t\t\t\tTD[j + ii][s] = (TD[j + ii][s] + 1ll * D[j][k] * InvF[ii]) % Mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 40; j++)for (k = 0; k < 40; k++) {\n\t\t\tD[j][k] = TD[j][k];\n\t\t\tTD[j][k] = 0;\n\t\t}\n\t}\n\tlong long r = 0;\n\tfor (i = 0; i < 40; i++) {\n\t\tlong long c = (A + B + A + B - 1 + i * 2);\n\t\tlong long t = c + B * 2 + 2;\n\t\tif (!D[B][i] || n-c < 0)continue;\n\t\tr = (r + 1ll * D[B][i] * F[A+B] % Mod * Comb(t + (n - c) - 1, (n - c)))%Mod;\n\t}\n\treturn r;\n}\nint main() {\n\tlong long i, j, res = 0;\n\tF[0] = 1;\n\tfor (i = 1; i <= 140; i++)F[i] = 1ll * F[i - 1] * i%Mod;\n\tfor (i = 0; i <= 140; i++)InvF[i] = Pow(F[i], Mod - 2);\n\tscanf(\"%lld%lld\", &n, &K);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i <= (n+1)/2; i++) {\n\t\tfor (j = 0; i + j <= (n + 1) / 2; j++) {\n\t\t\tres = (res + Do(i, j))%Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t70\n#define K\t70\n#define MD\t1000000007\n\nint min(int a, int b) { return a < b ? a : b; }\n\nint ch[N + 1][N + 1], cnt[N + 1][N + 1];\n\nvoid init() {\n\tint n, b, k, l;\n\n\tch[0][0] = 1;\n\tfor (n = 1; n <= N; n++) {\n\t\tch[n][0] = 1;\n\t\tfor (k = 1; k <= n; k++)\n\t\t\tch[n][k] = (ch[n - 1][k] + ch[n - 1][k - 1]) % MD;\n\t}\n\tfor (n = 1; n <= N; n++) {\n\t\tcnt[n][0] = 1;\n\t\tfor (b = 1; b <= (n + 1) / 2; b++)\n\t\t\tfor (l = b; l <= n; l++)\n\t\t\t\tcnt[n][b] = (cnt[n][b] + (long long) ch[l - 1][b - 1] * ch[n - l + 1][b]) % MD;\n\t}\n}\n\nint main() {\n\tstatic char cc[N + 1];\n\tstatic int iir[N + 1], iib[N + 1], dp[N + 1][N + 1][N + 1];\n\tint n, m, mr, mb, c, h, i, j, k, i_, j_, k_, b, l, ans;\n\n\tinit();\n\tscanf(\"%d%d%s\", &n, &m, cc);\n\tmr = mb = 0;\n\tfor (i = 0; i < m; i++)\n\t\tif (cc[i] == 'r')\n\t\t\tiir[mr++] = i;\n\t\telse\n\t\t\tiib[mb++] = i;\n\tans = 1;\n\tfor (c = 1; c <= (n + 1) / 2 && c <= mr; c++) {\n\t\tint n1 = n - c + 1, n2 = c, n3 = mb;\n\n\t\tfor (i = 0; i <= n1; i++)\n\t\t\tfor (j = 0; j <= n2; j++)\n\t\t\t\tfor (k = 0; k <= n3; k++)\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\tdp[0][0][0] = 1;\n\t\tfor (b = 0; b <= mb; b++)\n\t\t\tfor (l = b == 0 ? 1 : b * 2 - 1; l <= n1; l++) {\n\t\t\t\tint y = cnt[l][b];\n\n\t\t\t\tfor (i = n1 - l; i >= 0; i--)\n\t\t\t\t\tfor (j = n2 - 1; j >= 0; j--)\n\t\t\t\t\t\tfor (k = n3 - b; k >= 0; k--) {\n\t\t\t\t\t\t\tint x = dp[i][j][k], p;\n\n\t\t\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tp = 1;\n\t\t\t\t\t\t\tfor (h = 1; (i_ = i + h * l) <= n1 && (j_ = j + h) <= n2 && (k_ = k + h * b) <= n3; h++) {\n\t\t\t\t\t\t\t\tif (b > 0 && iir[c - j_] > iib[mb - k_])\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tp = (long long) p * y % MD;\n\t\t\t\t\t\t\t\tdp[i_][j_][k_] = (dp[i_][j_][k_] + (long long) x * p % MD * ch[j_][h]) % MD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\tj = c;\n\t\tfor (i = 0; i <= n1; i++)\n\t\t\tfor (k = 0; k <= n3; k++)\n\t\t\t\tans = (ans + (long long) dp[i][j][k] * ch[n - i + 1][j]) % MD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t70\n#define M\t70\n#define MD\t1000000007\n\nint min(int a, int b) { return a < b ? a : b; }\n\nint ch[N + 1][N + 1], cnt[N + 1][N + 1];\n\nvoid init() {\n\tint n, b, k, l;\n\n\tch[0][0] = 1;\n\tfor (n = 1; n <= N; n++) {\n\t\tch[n][0] = 1;\n\t\tfor (k = 1; k <= n; k++)\n\t\t\tch[n][k] = (ch[n - 1][k] + ch[n - 1][k - 1]) % MD;\n\t}\n\tfor (n = 1; n <= N; n++) {\n\t\tcnt[n][0] = 1;\n\t\tfor (b = 1; b <= (n + 1) / 2; b++)\n\t\t\tfor (l = b; l <= n; l++)\n\t\t\t\tcnt[n][b] = (cnt[n][b] + (long long) ch[l - 1][b - 1] * ch[n - l + 1][b]) % MD;\n\t}\n}\n\nint main() {\n\tstatic char cc[M + 1];\n\tstatic int iir[M + 1], iib[M + 1], dp[N + 1][M + 1][M + 1], pp[M];\n\tint n, m, mr, mb, c, h, i, j, k, i_, j_, k_, b, l, ans;\n\n\tinit();\n\tscanf(\"%d%d%s\", &n, &m, cc);\n\tmr = mb = 0, k = 0;\n\tfor (i = 0; i < m; i++)\n\t\tif (cc[i] == 'r')\n\t\t\tiir[mr++] = i, k++;\n\t\telse if (k > 0)\n\t\t\tiib[mb++] = i, k--;\n\tans = 1;\n\tfor (c = 1; c <= (n + 1) / 2 && c <= mr; c++) {\n\t\tfor (i = 0; i < m; i++)\n\t\t\tpp[i] = 1;\n\t\tfor (h = 0; h < c; h++)\n\t\t\tpp[iir[h]] = 0;\n\t\tfor (i = m - 2; i >= 0; i--)\n\t\t\tpp[i] += pp[i + 1];\n\t\tfor (i = 0; i <= n - c + 1; i++)\n\t\t\tfor (j = 0; j <= c && j <= i; j++)\n\t\t\t\tfor (k = 0; k <= m && k <= i / 2 + j; k++)\n\t\t\t\t\tdp[i][j][k] = 0;\n\t\tdp[0][0][0] = 1;\n\t\tfor (b = 0; b <= m; b++)\n\t\t\tfor (l = b == 0 ? 1 : b * 2 - 1; l <= n - c + 1; l++) {\n\t\t\t\tint y = cnt[l][b];\n\n\t\t\t\tfor (i = n - c + 1 - l; i >= 0; i--)\n\t\t\t\t\tfor (j = min(c - 1, i); j >= 0; j--)\n\t\t\t\t\t\tfor (k = min(m - b, i / 2 + j); k >= 0; k--) {\n\t\t\t\t\t\t\tint x = dp[i][j][k], p;\n\n\t\t\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tp = 1;\n\t\t\t\t\t\t\tfor (h = 1; (i_ = i + h * l) <= n - c + 1 && (j_ = j + h) <= c && (k_ = k + h * b) <= m; h++) {\n\t\t\t\t\t\t\t\tif (b > 0 && (c - j_ >= mb || pp[iib[c - j_]] < k_))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tp = (long long) p * y % MD;\n\t\t\t\t\t\t\t\tdp[i_][j_][k_] = (dp[i_][j_][k_] + (long long) x * p % MD * ch[j_][h]) % MD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t}\n\t\tj = c;\n\t\tfor (i = 0; i <= n - c + 1; i++)\n\t\t\tfor (k = 0; k <= m && k <= i / 2 + j; k++)\n\t\t\t\tans = (ans + (long long) dp[i][j][k] * ch[n - i + 1][j]) % MD;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "// package arc.arc089;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    static int[][][][][] dp;\n\n    static final int WHITE = 0;\n    static final int RED = 1;\n    static final int BLUE = 2;\n    static final int FIRST_RED = 3;\n\n    static void addTo(int idx, int last, int rb, int r, int cmpl, int add) {\n        dp[idx][last][rb][r][cmpl] += add;\n        if (dp[idx][last][rb][r][cmpl] >= MOD) {\n            dp[idx][last][rb][r][cmpl] -= MOD;\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n        char[] s = in.nextToken().toCharArray();\n\n\n        dp = new int[71][4][40][40][70];\n        dp[0][0][0][0][0] = 1;\n\n        for (int i = 0 ; i < n ; i++) {\n            for (int last = 0; last < 4 ; last++) {\n                for (int rb = 0; rb < 40; rb++) {\n                    for (int r = 0; r < 40 ; r++) {\n                        for (int cmpl = 0; cmpl < 70 ; cmpl++) {\n                            int base = dp[i][last][rb][r][cmpl];\n                            if (base == 0) {\n                                continue;\n                            }\n                            addTo(i+1, WHITE, rb, r, cmpl, base);\n\n                            if (last == WHITE) {\n                                addTo(i+1, FIRST_RED, rb, r+1, cmpl, base);\n                                addTo(i+1, BLUE, rb+1, r, cmpl+1, base);\n                            } else if (last == RED) {\n                                // same\n                                addTo(i+1, RED, rb, r, cmpl, base);\n                                addTo(i+1, BLUE, rb, r, cmpl+1, base);\n                            } else if (last == BLUE) {\n                                // same\n                                addTo(i+1, BLUE, rb, r, cmpl, base);\n                                addTo(i+1, RED, rb, r, cmpl, base);\n                            } else if (last == FIRST_RED) {\n                                // same\n                                addTo(i+1, FIRST_RED, rb, r, cmpl, base);\n                                addTo(i+1, BLUE, rb+1, r-1, cmpl+1, base);\n                            } else {\n                                throw new RuntimeException(\"invalid color\");\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n\n        long ans = 0;\n        for (int rb = 0 ; rb < 40 ; rb++) {\n            for (int r = 0 ; r < 40 ; r++) {\n                for (int cmpl = 0; cmpl < 70 ; cmpl++) {\n                    if (canDoit(rb, r, cmpl, s)) {\n                        for (int l = 0; l < 4 ; l++) {\n                            ans += dp[n][l][rb][r][cmpl];\n                        }\n                        ans %= MOD;\n                    }\n                }\n            }\n        }\n        out.println(ans);\n        out.flush();\n    }\n\n    private static boolean canDoit(int rb, int r, int cmpl, char[] s) {\n        int redcount = 0;\n        int bluecount = 0;\n        int rrc = 0;\n        int free = 0;\n        int n = s.length;\n        for (int i = 0; i < n ; i++) {\n            if (s[i] == 'r') {\n                if (redcount < rb) {\n                    redcount++;\n                } else if (rrc < r) {\n                    rrc++;\n                } else {\n                    free++;\n                }\n            } else {\n                if (bluecount == redcount) {\n                    if (redcount >= 1) {\n                        free++;\n                    }\n                    continue;\n                }\n                if (bluecount < redcount && bluecount < rb) {\n                    bluecount++;\n                } else {\n                    free++;\n                }\n            }\n        }\n        return redcount == rb && bluecount == rb && rrc == r && free >= (cmpl - rb);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "// package arc.arc089;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static final int MOD = 1000000007;\n\n    static char[] S;\n    static long[][] C;\n\n    static long dfs(int[] a, int idx, int last, int left) {\n        if (left < 0) {\n            return 0;\n        }\n\n        long ret = way(a, idx, left);\n        for (int l = last ; l >= 1 ; l--) {\n            int cost = ((l <= 2) ? 1 : ((l-2)*2+1)) + Math.min(idx, 1);\n            a[idx] = l;\n            ret += dfs(a, idx+1, l, left - cost);\n        }\n        ret %= MOD;\n        return ret;\n    }\n\n    static long way(int[] a, int n, int space) {\n        if (!canDoit(a, n, S)) {\n            return 0;\n        }\n        if (n == 0) {\n            return 1;\n        }\n\n        long pway = 1;\n        int left = n;\n        for (int i = 0; i < n ; ) {\n            int j = i+1;\n            while (j < n && a[i] == a[j]) {\n                j++;\n            }\n            pway *= C[left][j-i];\n            pway %= MOD;\n            left -= j-i;\n            i = j;\n        }\n\n        long total = 0;\n        int free = 0;\n        for (int i = 0; i < n; i++) {\n            free += a[i] * 2 - 1;\n        }\n\n        for (int s = 0 ; s <= space ; s++) {\n            long sway = C[s+n][s];\n            int L = space - s;\n            total += C[free+L-1][free-1] * sway % MOD;\n        }\n        total %= MOD;\n        return total * pway % MOD;\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        in.nextInt();\n        S = in.nextToken().toCharArray();\n        C = new long[200][200];\n        for (int i = 0; i < C.length; i++) {\n            C[i][0] = C[i][i] = 1;\n            for (int j = 1 ; j < i; j++) {\n                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;\n            }\n        }\n\n        out.println(dfs(new int[140], 0, 70, n));\n        out.flush();\n    }\n\n    private static boolean canDoit(int[] a, int n, char[] s) {\n        int[] b = new int[n];\n;\n\n        int ridx = 0;\n        int bidx = 0;\n        for (char c : s) {\n            if (c == 'r') {\n                if (ridx < n) {\n                    b[ridx] = 1;\n                    ridx++;\n                } else {\n                    for (int i = 0 ; i < n ; i++) {\n                        if (b[i] >= 2 && b[i] < a[i]) {\n                            b[i]++;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                if (ridx == bidx || a[bidx] == 1) {\n                    for (int i = 0 ; i < n ; i++) {\n                        if (b[i] >= 2 && b[i] < a[i]) {\n                            b[i]++;\n                            break;\n                        }\n                    }\n                } else {\n                    b[bidx] = 2;\n                    bidx++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n ; i++) {\n            if (b[i] < a[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n\tstatic final int P = 1_000_000_007;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tnextInt();\n\t\tchar[] s = nextToken().toCharArray();\n\n\t\tint ans = 1;\n\n\t\tfor (int rb = 0; 2 * rb <= s.length; rb++) {\n\t\t\tfor (int r = 0; 2 * rb + r <= s.length; r++) {\n\t\t\t\tif (rb == 0 && r == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nowRb = 0;\n\t\t\t\tint nowR = 0;\n\n\t\t\t\tint[] have = new int[rb];\n\n\t\t\t\tfor (char c : s) {\n\t\t\t\t\tif (c == 'r') {\n\t\t\t\t\t\tif (nowRb + nowR < rb + r) {\n\t\t\t\t\t\t\tnowR++;\n\t\t\t\t\t\t} else if (nowRb > 0) {\n\t\t\t\t\t\t\thave[rb - nowRb]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nowR > 0 && nowRb < rb) {\n\t\t\t\t\t\t\tnowR--;\n\t\t\t\t\t\t\tnowRb++;\n\t\t\t\t\t\t} else if (nowRb > 0) {\n\t\t\t\t\t\t\thave[rb - nowRb]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nowR != r || nowRb != rb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i < rb; i++) {\n\t\t\t\t\thave[i] += have[i - 1];\n\t\t\t\t}\n\n\t\t\t\tans += solve(rb, r, have, n);\n\t\t\t\tif (ans >= P) {\n\t\t\t\t\tans -= P;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tint solve(int rb, int r, int[] have, int len) {\n\t\t\n//\t\tSystem.err.println(rb + \" \" + r + \" \" + Arrays.toString(have) + \" \" + len);\n\t\t\n\t\t\n\t\tint maxUsed = have.length == 0 ? 0 : have[have.length - 1];\n\t\tint[][] dp = new int[rb + 1][maxUsed + 1];\n\t\tdp[0][0] = (int) ((long) fact[rb + r] * invFact[r] % P);\n\n\t\tfor (int x = 0; x <= maxUsed; x++) {\n\t\t\tfor (int idx = rb; idx >= 0; idx--) {\n\t\t\t\tfor (int sum = 0; sum <= maxUsed; sum++) {\n\t\t\t\t\tint val = dp[idx][sum];\n\t\t\t\t\tif (val == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 1; idx + k <= rb\n\t\t\t\t\t\t\t&& sum + k * x <= have[idx + k - 1]; k++) {\n\n\t\t\t\t\t\tint delta = (int) ((long) val * invFact[k] % P);\n\t\t\t\t\t\tdp[idx + k][sum + k * x] += delta;\n\t\t\t\t\t\tif (dp[idx + k][sum + k * x] >= P) {\n\t\t\t\t\t\t\tdp[idx + k][sum + k * x] -= P;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\t\tfor (int sum = 0; sum <= maxUsed; sum++) {\n\t\t\tint ways = dp[rb][sum];\n\n\t\t\tif (ways == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint boxes = rb + r + 1; // whites\n\t\t\tboxes += r; // just rs\n\t\t\tboxes += 3 * rb + 2 * sum; // rbs, with 0->3, 1->5, 2->7, ...\n\n\t\t\tint occ = rb + r - 1; // whites\n\t\t\tocc += r; // just rs\n\t\t\tocc += rb + 2 * sum; // rbs, with 0->1, 1->3, 2->5\n\n\t\t\tint free = len - occ;\n\t\t\tif (free < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret += (int) ((long) ways * go(boxes, free) % P);\n\t\t\tif (ret >= P) {\n\t\t\t\tret -= P;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tint go(int boxes, int items) {\n\t\treturn (int) ((long) fact[items + boxes - 1] * invFact[items] % P\n\t\t\t\t* invFact[boxes - 1] % P);\n\t}\n\n\tstatic final int N = 200;\n\n\tint[] fact;\n\tint[] invFact;\n\n\tvoid preCalc() {\n\t\tint[] inv = new int[N];\n\t\tinv[0] = 0;\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < inv.length; i++) {\n\t\t\tinv[i] = P - (int) ((long) (P / i) * inv[P % i] % P);\n\t\t}\n\n\t\tfact = new int[N];\n\t\tinvFact = new int[N];\n\t\tfact[0] = invFact[0] = 1;\n\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfact[i] = (int) ((long) i * fact[i - 1] % P);\n\t\t\tinvFact[i] = (int) ((long) inv[i] * invFact[i - 1] % P);\n\t\t}\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tD() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew D();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint n = ni(), K = ni();\n\t\tString S = ns().replaceAll(\"^b+\", \"\");\n\t\tchar[] s = S.toCharArray();\n\t\tK = s.length;\n\t\tboolean[] ued = new boolean[K];\n\t\tint use = 0;\n\t\touter:\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tfor(int j = 0;j < K;j++){\n\t\t\t\tif(s[j] == 'r' && !ued[j]){\n\t\t\t\t\tued[j] = true;\n\t\t\t\t\tfor(int k = j+1;k < K;k++){\n\t\t\t\t\t\tif(s[k] == 'b' && !ued[k]){\n\t\t\t\t\t\t\tued[k] = true;\n\t\t\t\t\t\t\tuse++;\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][] C = new long[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t\t\t\tif (C[i][j] >= mod)\n\t\t\t\t\tC[i][j] -= mod;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// ababa\n\t\tlong[][] nums = new long[41][n+1]; // asterisk len\n\t\t\n\t\tfor(int len = 3;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t// baba\n\t\t// abab\n\t\tfor(int len = 2;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// bab\n\t\tfor(int len = 1;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i <= 40;i++){\n\t\t\tfor(int j = 0;j < nums[i].length;j++){\n\t\t\t\tnums[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][][][] dp = new long[41][41][use+1][n+1]; // asterisk red ab\n\t\tdp[0][0][0][0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 0;j <= 40;j++){\n\t\t\t\tif(use > 0)dp[j][0][1][i] += nums[j][i];\n\t\t\t}\n\t\t\tdp[0][1][0][i] += 1; // r\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int ast = 0;ast <= 40;ast++){\n\t\t\t\tfor(int red = 0;red <= 40;red++){\n\t\t\t\t\tfor(int rb = 0;rb <= use;rb++){\n\t\t\t\t\t\tif(dp[ast][red][rb][i] == 0)continue;\n//\t\t\t\t\t\ttr(ast, red, rb, i, dp[ast][red][rb][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// w\n\t\t\t\t\t\tdp[ast][red][rb][i+1] += dp[ast][red][rb][i];\n\t\t\t\t\t\tdp[ast][red][rb][i+1] %= mod;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// wrbr\n\t\t\t\t\t\tif(rb+1 <= use){\n\t\t\t\t\t\t\tfor(int last = 0;ast+last <= 40;last++){\n\t\t\t\t\t\t\t\tfor(int llen = 0;i+llen+1 <= n;llen++){\n\t\t\t\t\t\t\t\t\tdp[ast+last][red][rb+1][i+llen+1] += \n\t\t\t\t\t\t\t\t\t\t\tdp[ast][red][rb][i] * nums[last][llen];\n\t\t\t\t\t\t\t\t\tdp[ast+last][red][rb+1][i+llen+1] %= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// wr\n\t\t\t\t\t\tif(red+1 <= 40){\n\t\t\t\t\t\t\tfor(int llen = 1;i+llen+1 <= n;llen++){\n\t\t\t\t\t\t\t\tdp[ast][red+1][rb][i+llen+1] += \n\t\t\t\t\t\t\t\t\t\tdp[ast][red][rb][i];\n\t\t\t\t\t\t\t\tdp[ast][red+1][rb][i+llen+1] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint nr = 0;\n\t\tfor(char c : s)if(c == 'r')nr++;\n\t\tint nb = K-nr;\n\t\tlong ans = 0;\n\t\tfor(int ast = 0;ast <= 40;ast++){\n\t\t\tfor(int red = 0;red <= 40;red++){\n\t\t\t\tfor(int rb = 0;rb <= use;rb++){\n\t\t\t\t\tint remr = nr - red - rb;\n\t\t\t\t\tint remb = nb - rb;\n\t\t\t\t\tif(remr < 0 || remr + remb < ast)break;\n\t\t\t\t\tans += dp[ast][red][rb][n];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans%mod);\n\t}\n\t\n\t\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint n = ni(), K = ni();\n\t\tchar[] s = ns(K);\n\t\tboolean[] ued = new boolean[K];\n\t\tint use = 0;\n\t\touter:\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tfor(int j = 0;j < K;j++){\n\t\t\t\tif(s[j] == 'r' && !ued[j]){\n\t\t\t\t\tued[j] = true;\n\t\t\t\t\tfor(int k = j+1;k < K;k++){\n\t\t\t\t\t\tif(s[k] == 'b' && !ued[k]){\n\t\t\t\t\t\t\tued[k] = true;\n\t\t\t\t\t\t\tuse++;\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][] C = new long[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t\t\t\tif (C[i][j] >= mod)\n\t\t\t\t\tC[i][j] -= mod;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// ababa\n\t\tlong[][] nums = new long[41][n+1]; // asterisk len\n\t\t\n\t\tfor(int len = 3;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t// baba\n\t\t// abab\n\t\tfor(int len = 2;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// bab\n\t\tfor(int len = 1;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t\n//\t\tfor(int i = 0;i <= 80;i++){\n//\t\t\tfor(int j = 0;j < nums[i].length;j++){\n//\t\t\t\tif(nums[i][j] != 0){\n//\t\t\t\t\ttr(i, j, nums[i][j]);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n\t\t\n\t\tlong[][][][] dp = new long[41][41][use+1][n+1]; // asterisk red ab\n\t\tdp[0][0][0][0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 0;j <= 40;j++){\n\t\t\t\tif(use > 0)dp[j][0][1][i] += nums[j][i];\n\t\t\t}\n\t\t\tdp[0][1][0][i] += 1; // r\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int ast = 0;ast <= 40;ast++){\n\t\t\t\tfor(int red = 0;red <= 40;red++){\n\t\t\t\t\tfor(int rb = 0;rb <= use;rb++){\n\t\t\t\t\t\tif(dp[ast][red][rb][i] == 0)continue;\n//\t\t\t\t\t\ttr(ast, red, rb, i, dp[ast][red][rb][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// w\n\t\t\t\t\t\tdp[ast][red][rb][i+1] += dp[ast][red][rb][i];\n\t\t\t\t\t\tdp[ast][red][rb][i+1] %= mod;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// wrbr\n\t\t\t\t\t\tif(rb+1 <= use){\n\t\t\t\t\t\t\tfor(int last = 0;ast+last <= 40;last++){\n\t\t\t\t\t\t\t\tfor(int llen = 0;i+llen+1 <= n;llen++){\n\t\t\t\t\t\t\t\t\tdp[ast+last][red][rb+1][i+llen+1] += \n\t\t\t\t\t\t\t\t\t\t\tdp[ast][red][rb][i] * nums[last][llen];\n\t\t\t\t\t\t\t\t\tdp[ast+last][red][rb+1][i+llen+1] %= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// wr\n\t\t\t\t\t\tif(red+1 <= 40){\n\t\t\t\t\t\t\tfor(int llen = 1;i+llen+1 <= n;llen++){\n\t\t\t\t\t\t\t\tdp[ast][red+1][rb][i+llen+1] += \n\t\t\t\t\t\t\t\t\t\tdp[ast][red][rb][i];\n\t\t\t\t\t\t\t\tdp[ast][red+1][rb][i+llen+1] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint nr = 0;\n\t\tfor(char c : s)if(c == 'r')nr++;\n\t\tint nb = K-nr;\n\t\tlong ans = 0;\n\t\tfor(int ast = 0;ast <= 40;ast++){\n\t\t\tfor(int red = 0;red <= 40;red++){\n\t\t\t\tfor(int rb = 0;rb <= use;rb++){\n\t\t\t\t\tint remr = nr - red - rb;\n\t\t\t\t\tint remb = nb - rb;\n\t\t\t\t\tif(remr < 0 || remr + remb < ast)break;\n\t\t\t\t\tans += dp[ast][red][rb][n];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans%mod);\n\t}\n\t\n\t\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n\tstatic final int P = 1_000_000_007;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tnextInt();\n\t\tchar[] s = nextToken().toCharArray();\n\n\t\tint ans = 1;\n\n\t\tfor (int rb = 0; 2 * rb <= s.length; rb++) {\n\t\t\tfor (int r = 0; 2 * rb + r <= s.length; r++) {\n\t\t\t\tif (rb == 0 && r == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nowRb = 0;\n\t\t\t\tint nowR = 0;\n\n\t\t\t\tint[] have = new int[rb];\n\n\t\t\t\tfor (char c : s) {\n\t\t\t\t\tif (c == 'r') {\n\t\t\t\t\t\tif (nowRb + nowR < rb + r) {\n\t\t\t\t\t\t\tnowR++;\n\t\t\t\t\t\t} else if (nowRb > 0) {\n\t\t\t\t\t\t\thave[rb - nowRb]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nowR > 0 && nowRb < rb) {\n\t\t\t\t\t\t\tnowR--;\n\t\t\t\t\t\t\tnowRb++;\n\t\t\t\t\t\t} else if (nowRb > 0) {\n\t\t\t\t\t\t\thave[rb - nowRb]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nowR != r || nowRb != rb) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i < rb; i++) {\n\t\t\t\t\thave[i] += have[i - 1];\n\t\t\t\t}\n\n\t\t\t\tans += solve(rb, r, have, n);\n\t\t\t\tif (ans >= P) {\n\t\t\t\t\tans -= P;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tint solve(int rb, int r, int[] have, int len) {\n\t\t\n//\t\tSystem.err.println(rb + \" \" + r + \" \" + Arrays.toString(have) + \" \" + len);\n\t\t\n\t\t\n\t\tint maxUsed = have.length == 0 ? 0 : have[have.length - 1];\n\t\tint[][] dp = new int[rb + 1][maxUsed + 1];\n\t\tdp[0][0] = (int) ((long) fact[rb + r] * invFact[r] % P);\n\n\t\tfor (int x = 0; x <= maxUsed; x++) {\n\t\t\tfor (int idx = rb; idx >= 0; idx--) {\n\t\t\t\tfor (int sum = 0; sum <= maxUsed; sum++) {\n\t\t\t\t\tint val = dp[idx][sum];\n\t\t\t\t\tif (val == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int k = 1; idx + k <= rb\n\t\t\t\t\t\t\t&& sum + k * x <= have[idx + k - 1]; k++) {\n\n\t\t\t\t\t\tint delta = (int) ((long) val * invFact[k] % P);\n\t\t\t\t\t\tdp[idx + k][sum + k * x] += delta;\n\t\t\t\t\t\tif (dp[idx + k][sum + k * x] >= P) {\n\t\t\t\t\t\t\tdp[idx + k][sum + k * x] -= P;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ret = 0;\n\t\tfor (int sum = 0; sum <= maxUsed; sum++) {\n\t\t\tint ways = dp[rb][sum];\n\n\t\t\tif (ways == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint boxes = rb + r + 1; // whites\n\t\t\tboxes += r; // just rs\n\t\t\tboxes += 3 * rb + 2 * sum; // rbs, with 0->3, 1->5, 2->7, ...\n\n\t\t\tint occ = rb + r - 1; // whites\n\t\t\tocc += r; // just rs\n\t\t\tocc += rb + 2 * sum; // rbs, with 0->1, 1->3, 2->5\n\n\t\t\tint free = len - occ;\n\t\t\tif (free < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret += (int) ((long) ways * go(boxes, free) % P);\n\t\t\tif (ret >= P) {\n\t\t\t\tret -= P;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tint go(int boxes, int items) {\n\t\treturn (int) ((long) fact[items + boxes - 1] * invFact[items] % P\n\t\t\t\t* invFact[boxes - 1] % P);\n\t}\n\n\tstatic final int N = 200;\n\n\tint[] fact;\n\tint[] invFact;\n\n\tvoid preCalc() {\n\t\tint[] inv = new int[N];\n\t\tinv[0] = 0;\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < inv.length; i++) {\n\t\t\tinv[i] = P - (int) ((long) (P / i) * inv[P % i] % P);\n\t\t}\n\n\t\tfact = new int[N];\n\t\tinvFact = new int[N];\n\t\tfact[0] = invFact[0] = 1;\n\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfact[i] = (int) ((long) i * fact[i - 1] % P);\n\t\t\tinvFact[i] = (int) ((long) inv[i] * invFact[i - 1] % P);\n\t\t}\n\n\t}\n\n\tvoid stress() {\n\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tMain() throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\t\tpreCalc();\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tString nextToken() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tString nextString() {\n\t\ttry {\n\t\t\treturn br.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint mod = 1000000007;\n\t\tint n = ni(), K = ni();\n\t\tchar[] s = ns(K);\n\t\tboolean[] ued = new boolean[K];\n\t\tint use = 0;\n\t\touter:\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tfor(int j = 0;j < K;j++){\n\t\t\t\tif(s[j] == 'r' && !ued[j]){\n\t\t\t\t\tued[j] = true;\n\t\t\t\t\tfor(int k = j+1;k < K;k++){\n\t\t\t\t\t\tif(s[k] == 'b' && !ued[k]){\n\t\t\t\t\t\t\tued[k] = true;\n\t\t\t\t\t\t\tuse++;\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][] C = new long[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tC[i][0] = 1;\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tC[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n\t\t\t\tif (C[i][j] >= mod)\n\t\t\t\t\tC[i][j] -= mod;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\t// ababa\n\t\tlong[][] nums = new long[41][n+1]; // asterisk len\n\t\t\n\t\tfor(int len = 3;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t// baba\n\t\t// abab\n\t\tfor(int len = 2;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t\tnums[len/2-1][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// bab\n\t\tfor(int len = 1;len <= n;len+=2){\n\t\t\tfor(int i = len;i <= n;i++){\n\t\t\t\tnums[len/2][i] += C[i-1][len-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i <= 40;i++){\n\t\t\tfor(int j = 0;j < nums[i].length;j++){\n\t\t\t\tnums[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][][][] dp = new long[41][41][use+1][n+1]; // asterisk red ab\n\t\tdp[0][0][0][0] = 1;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 0;j <= 40;j++){\n\t\t\t\tif(use > 0)dp[j][0][1][i] += nums[j][i];\n\t\t\t}\n\t\t\tdp[0][1][0][i] += 1; // r\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int ast = 0;ast <= 40;ast++){\n\t\t\t\tfor(int red = 0;red <= 40;red++){\n\t\t\t\t\tfor(int rb = 0;rb <= use;rb++){\n\t\t\t\t\t\tif(dp[ast][red][rb][i] == 0)continue;\n//\t\t\t\t\t\ttr(ast, red, rb, i, dp[ast][red][rb][i]);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// w\n\t\t\t\t\t\tdp[ast][red][rb][i+1] += dp[ast][red][rb][i];\n\t\t\t\t\t\tdp[ast][red][rb][i+1] %= mod;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// wrbr\n\t\t\t\t\t\tif(rb+1 <= use){\n\t\t\t\t\t\t\tfor(int last = 0;ast+last <= 40;last++){\n\t\t\t\t\t\t\t\tfor(int llen = 0;i+llen+1 <= n;llen++){\n\t\t\t\t\t\t\t\t\tdp[ast+last][red][rb+1][i+llen+1] += \n\t\t\t\t\t\t\t\t\t\t\tdp[ast][red][rb][i] * nums[last][llen];\n\t\t\t\t\t\t\t\t\tdp[ast+last][red][rb+1][i+llen+1] %= mod;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// wr\n\t\t\t\t\t\tif(red+1 <= 40){\n\t\t\t\t\t\t\tfor(int llen = 1;i+llen+1 <= n;llen++){\n\t\t\t\t\t\t\t\tdp[ast][red+1][rb][i+llen+1] += \n\t\t\t\t\t\t\t\t\t\tdp[ast][red][rb][i];\n\t\t\t\t\t\t\t\tdp[ast][red+1][rb][i+llen+1] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint nr = 0;\n\t\tfor(char c : s)if(c == 'r')nr++;\n\t\tint nb = K-nr;\n\t\tlong ans = 0;\n\t\tfor(int ast = 0;ast <= 40;ast++){\n\t\t\tfor(int red = 0;red <= 40;red++){\n\t\t\t\tfor(int rb = 0;rb <= use;rb++){\n\t\t\t\t\tint remr = nr - red - rb;\n\t\t\t\t\tint remb = nb - rb;\n\t\t\t\t\tif(remr < 0 || remr + remb < ast)break;\n\t\t\t\t\tans += dp[ast][red][rb][n];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(ans%mod);\n\t}\n\t\n\t\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    Fact F;\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int K = re.i();\n        string S = re.s();\n        List<List<int>>[,] Div = new List<List<int>>[K+1,K+1];\n        Div[0,0] = new List<List<int>>();\n        Div[0,0].Add(new List<int>());\n        for(int i=0;i<=K;i++){\n            for(int j=0;j<=K;j++){\n                Div[i,j] = new List<List<int>>();\n            }\n        }\n        Div[0,0].Add(new List<int>());\n        for(int i=1;i<=K;i++){\n            for(int j=1;j<=K;j++){\n                for(int k=0;k<Div[i-1,j-1].Count;k++){\n                    List<int> L = new List<int>();\n                    List<int> cL = Div[i-1,j-1][k];\n                    L.Add(1);\n                    for(int l=0;l<cL.Count;l++){\n                        L.Add(cL[l]);\n                    }\n                    Div[i,j].Add(L);\n                }\n                if(j >= i){\n                    for(int k=0;k<Div[i,j-i].Count;k++){\n                        List<int> L = new List<int>();\n                        List<int> cL = Div[i,j-i][k];\n                        for(int l=0;l<cL.Count;l++){\n                            L.Add(cL[l]+1);\n                        }\n                        Div[i,j].Add(L);\n                    }\n                }\n            }\n        }\n        long count = 0;\n        F = new Fact(1000);\n        for(int i=0;i<=K;i++){\n            for(int j=0;j<=K;j++){\n                for(int k=0;k<Div[i,j].Count;k++){\n                    if(Possible(Div[i,j][k],S)){\n                        count += Querry(Div[i,j][k],N);\n                    }\n                }\n            }\n        }\n        count %= Define.mod;\n        sb.Append(count+\"\\n\");\n    }\n    long Querry(List<int> L,int N){\n        if(L.Count == 0){\n            return 1;\n        }\n        int a = 0;\n        int b = 0;\n        for(int i=0;i<L.Count;i++){\n            if(L[i] == 1){\n                a += 1;\n            }\n            else{\n                a += L[i]*2-3;\n                b += 2;\n            }\n        }\n        a += L.Count-1;\n        b += 2;\n        if(N < a){\n            return 0;\n        }\n        long ans = F.GetConv(N+b-1,a+b-1);\n        ans *= F.f[L.Count];\n        ans %= Define.mod;\n        int c = 1;\n        for(int i=1;i<L.Count;i++){\n            if(L[i] == L[i-1]){\n                c++;\n            }\n            else{\n                ans *= F.rf[c];\n                ans %= Define.mod;\n                c = 1;\n            }\n        }\n        ans *= F.rf[c];\n        ans %= Define.mod;\n        return ans;\n    }\n    bool Possible(List<int> L,string S){\n        int[] A = new int[L.Count];\n        int Zero = L.Count-1;\n        int One = L.Count-1;\n        int Two = L.Count-1;\n        for(int i=0;i<S.Length;i++){\n            if(S[i] == 'r'){\n                if(Zero != -1){\n                    A[Zero]++;\n                    Zero--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n            else{\n                if(One != -1 && L[One] != 1 && A[One] == 1){\n                    A[One]++;\n                    One--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n        }\n        return Zero == -1 && (One == -1 || L[One] == 1) && (Two == -1 || L[Two] <= 2);\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetPerm(int N,int R){\n        return f[N] * rf[N-R] % Define.mod;\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n    public long GetRev(int N){\n        if(N == 0){\n            return 1;\n        }\n        else{\n            return rf[N] * f[N-1] % Define.mod;\n        }\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    int[] L;\n    Fact F;\n    StringBuilder sb;\n    ReadData re;\n    long count;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int K = re.i();\n        string S = re.s();\n        count = 1;\n        L = new int[70];\n        F = new Fact(1000);\n        for(int i=1;i<=70;i++){\n            L[0] = i; \n            dfs(N,1,N-i,S);\n        }\n        count %= Define.mod;\n        sb.Append(count+\"\\n\");\n    }\n    void dfs(int N,int l,int n,string S){\n        if(Possible(l,S)){\n            count += Querry(l,N);\n        }\n        for(int i=L[l-1];i<=n;i++){\n            L[l] = i;\n            dfs(N,l+1,n-i,S);\n        }\n    }\n    long Querry(int l,int N){\n        if(l == 0){\n            return 1;\n        }\n        int a = 0;\n        int b = 0;\n        for(int i=0;i<l;i++){\n            if(L[i] == 1){\n                a += 1;\n            }\n            else{\n                a += L[i]*2-3;\n                b += 2;\n            }\n        }\n        a += l-1;\n        b += 2;\n        if(N < a){\n            return 0;\n        }\n        long ans = F.GetConv(N+b-1,a+b-1);\n        ans *= F.f[l];\n        ans %= Define.mod;\n        int c = 1;\n        for(int i=1;i<l;i++){\n            if(L[i] == L[i-1]){\n                c++;\n            }\n            else{\n                ans *= F.rf[c];\n                ans %= Define.mod;\n                c = 1;\n            }\n        }\n        ans *= F.rf[c];\n        ans %= Define.mod;\n        return ans;\n    }\n    bool Possible(int l,string S){\n        int[] A = new int[l];\n        int Zero = l-1;\n        int One = l-1;\n        int Two = l-1;\n        for(int i=0;i<S.Length;i++){\n            if(S[i] == 'r'){\n                if(Zero != -1){\n                    A[Zero]++;\n                    Zero--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n            else{\n                if(One != -1 && L[One] != 1 && A[One] == 1){\n                    A[One]++;\n                    One--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n        }\n        return Zero == -1 && (One == -1 || L[One] == 1) && (Two == -1 || L[Two] <= 2);\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetPerm(int N,int R){\n        return f[N] * rf[N-R] % Define.mod;\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n    public long GetRev(int N){\n        if(N == 0){\n            return 1;\n        }\n        else{\n            return rf[N] * f[N-1] % Define.mod;\n        }\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    int[] L;\n    Fact F;\n    StringBuilder sb;\n    ReadData re;\n    long count;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int K = re.i();\n        string S = re.s();\n        count = 1;\n        L = new int[70];\n        F = new Fact(1000);\n        for(int i=1;i<=70;i++){\n            L[0] = i; \n            if(i == 1){\n                dfs(N,1,N-i,S,1);\n            }\n            else{\n                dfs(N,1,N-i,S,i*2-3);\n            }\n        }\n        count %= Define.mod;\n        sb.Append(count+\"\\n\");\n    }\n    void dfs(int N,int l,int n,string S,int a){\n        if(N < a){\n            return;\n        }\n        if(Possible(l,S)){\n            count += Querry(l,N);\n        }\n        for(int i=L[l-1];i<=n;i++){\n            L[l] = i;\n            if(i == 1){\n                dfs(N,l+1,n-i,S,a+1);\n            }\n            else{\n                dfs(N,l+1,n-i,S,a+i*2-3);\n            }\n        }\n    }\n    long Querry(int l,int N){\n        if(l == 0){\n            return 1;\n        }\n        int a = 0;\n        int b = 0;\n        for(int i=0;i<l;i++){\n            if(L[i] == 1){\n                a += 1;\n            }\n            else{\n                a += L[i]*2-3;\n                b += 2;\n            }\n        }\n        a += l-1;\n        b += 2;\n        if(N < a){\n            return 0;\n        }\n        long ans = F.GetConv(N+b-1,a+b-1);\n        ans *= F.f[l];\n        ans %= Define.mod;\n        int c = 1;\n        for(int i=1;i<l;i++){\n            if(L[i] == L[i-1]){\n                c++;\n            }\n            else{\n                ans *= F.rf[c];\n                ans %= Define.mod;\n                c = 1;\n            }\n        }\n        ans *= F.rf[c];\n        ans %= Define.mod;\n        return ans;\n    }\n    bool Possible(int l,string S){\n        int[] A = new int[l];\n        int Zero = l-1;\n        int One = l-1;\n        int Two = l-1;\n        for(int i=0;i<S.Length;i++){\n            if(S[i] == 'r'){\n                if(Zero != -1){\n                    A[Zero]++;\n                    Zero--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n            else{\n                if(One != -1 && L[One] != 1 && A[One] == 1){\n                    A[One]++;\n                    One--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n        }\n        return Zero == -1 && (One == -1 || L[One] == 1) && (Two == -1 || L[Two] <= 2);\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetPerm(int N,int R){\n        return f[N] * rf[N-R] % Define.mod;\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n    public long GetRev(int N){\n        if(N == 0){\n            return 1;\n        }\n        else{\n            return rf[N] * f[N-1] % Define.mod;\n        }\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    int[] L;\n    Fact F;\n    StringBuilder sb;\n    ReadData re;\n    long count;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int K = re.i();\n        string S = re.s();\n        count = 1;\n        L = new int[70];\n        F = new Fact(1000);\n        for(int i=1;i<=70;i++){\n            L[0] = i; \n            dfs(N,1,N-i,S);\n        }\n        count %= Define.mod;\n        sb.Append(count+\"\\n\");\n    }\n    void dfs(int N,int l,int n,string S){\n        if(l > 36){\n            return;\n        }\n        if(Possible(l,S)){\n            count += Querry(l,N);\n        }\n        for(int i=L[l-1];i<=n;i++){\n            L[l] = i;\n            dfs(N,l+1,n-i,S);\n        }\n    }\n    long Querry(int l,int N){\n        if(l == 0){\n            return 1;\n        }\n        int a = 0;\n        int b = 0;\n        for(int i=0;i<l;i++){\n            if(L[i] == 1){\n                a += 1;\n            }\n            else{\n                a += L[i]*2-3;\n                b += 2;\n            }\n        }\n        a += l-1;\n        b += 2;\n        if(N < a){\n            return 0;\n        }\n        long ans = F.GetConv(N+b-1,a+b-1);\n        ans *= F.f[l];\n        ans %= Define.mod;\n        int c = 1;\n        for(int i=1;i<l;i++){\n            if(L[i] == L[i-1]){\n                c++;\n            }\n            else{\n                ans *= F.rf[c];\n                ans %= Define.mod;\n                c = 1;\n            }\n        }\n        ans *= F.rf[c];\n        ans %= Define.mod;\n        return ans;\n    }\n    bool Possible(int l,string S){\n        int[] A = new int[l];\n        int Zero = l-1;\n        int One = l-1;\n        int Two = l-1;\n        for(int i=0;i<S.Length;i++){\n            if(S[i] == 'r'){\n                if(Zero != -1){\n                    A[Zero]++;\n                    Zero--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n            else{\n                if(One != -1 && L[One] != 1 && A[One] == 1){\n                    A[One]++;\n                    One--;\n                }\n                else{\n                    if(Two != -1 && L[Two] > 2 && A[Two] >= 2){\n                        A[Two]++;\n                        if(A[Two] == L[Two]){\n                            Two--;\n                        }\n                    }\n                }\n            }\n        }\n        return Zero == -1 && (One == -1 || L[One] == 1) && (Two == -1 || L[Two] <= 2);\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetPerm(int N,int R){\n        return f[N] * rf[N-R] % Define.mod;\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n    public long GetRev(int N){\n        if(N == 0){\n            return 1;\n        }\n        else{\n            return rf[N] * f[N-1] % Define.mod;\n        }\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.modint;\nalias Mint = ModInt!(10^^9 + 7);\n\nMint[] fact, iFac;\nstatic this() {\n    fact = factTable!Mint(1000);\n    iFac = invFactTable!Mint(1000);\n}\n\nint n, m, z;\nint[] v;\nint r;\n\n// import dkh.functional;\n\nmemoCont!fBase f;\nMint fBase(int pos, int sm, int cnt) {\n    if (pos == -1) {\n        if (sm) return Mint(0);\n        int zc = m * 2 + 2;\n        cnt = cnt * 2 + m;\n        int oc = r + cnt + m + r - 1;\n        if (n < oc) return Mint(0);\n        int nn = n-oc;\n        int kk = zc+oc;\n\n        Mint u = Mint(1);\n        u *= fact[nn + kk - 1];\n        u *= iFac[kk - 1];\n        u *= iFac[nn];\n//        writeln(\"wow \", pos, \" \", sm, \" \", zc, \" \", oc, \" : \", u);\n        return u;\n    }\n    Mint ans = Mint(0);\n    foreach (i; 0..z+1) {\n        int nsm = sm - max(0, v[pos]-i) + max(0, i-v[pos]);\n        if (z < nsm) continue;\n        ans += f(pos-1, max(0, nsm), cnt + i);\n    }\n    return ans;\n}\n\nMint calc(int[] _v, int _r) {\n    v = _v; r = _r; m = v.length.to!int;\n    reverse(v);\n    z = v.sum;\n//    writeln(\"calc start: \", v, \" \", r);\n    f.init([[-1, m-1], [0, z], [0, 2*z]]);\n    Mint res = f(v.length.to!int - 1, 0, 0);\n//    writeln(\"res \", res);\n    return res * fact[r+m] * iFac[r] * iFac[m];\n}\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) sc.read!true;\n\n    int k; string s;\n    sc.read(n, k, s);\n\n    Mint sm = Mint(1);\n    foreach (i; 0..k+1) {\n        foreach (j; 0..k+1) {\n            if (!i && !j) continue;\n            int rc = j;\n            string ns;\n            foreach_reverse (c; s) {\n                if (c == 'r' && rc) {\n                    rc--;\n                    continue;\n                } else {\n                    ns = c ~ ns;\n                }\n            }\n            if (rc) continue;\n            \n            int[] v = new int[i];\n            rc = 0; int bc = 0;\n            foreach (c; ns) {\n                if (c == 'r') {\n                    if (rc != i) {\n                        rc++;\n                        continue;\n                    }\n                } else {\n                    if (bc < rc) {\n                        bc++;\n                        continue;\n                    }\n                }\n                if (bc == 0) continue;\n                v[bc-1]++;\n            }\n            if (bc != i) continue;\n            sm += calc(v, j);\n        }\n    }\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/int128.d */\n \n\n// module dkh.int128;\n\nversion(LDC) {\n//     import dkh.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/functional.d */\n// module dkh.functional;\n\n \nstruct memoCont(alias pred) {\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.meta : allSatisfy;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    \n    private int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(in int[2][N] rng) {\n        import std.algorithm : reduce, map;\n        import std.range : array;\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        auto sz = reduce!\"a*b\"(1, len);\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        import core.exception : RangeError;\n        size_t idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/modint.d */\n// module dkh.modint;\n\n// import dkh.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/ldc/inline.d */\n// module dkh.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir) R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/numeric/primitive.d */\n// module dkh.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n \nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\n// import dkh.int128;\n\n \nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.modint;\nalias Mint = ModInt!(10^^9 + 7);\n\nMint[] fact, iFac;\nstatic this() {\n    fact = factTable!Mint(1000);\n    iFac = invFactTable!Mint(1000);\n}\n\nint n, m, z;\nint[] v;\nint r;\n\n// import dkh.functional;\n\nmemoCont!fBase f;\nMint fBase(int pos, int sm, int cnt, int he) {\n    if (pos == -1) {\n//        if (sm) return Mint(0);\n        int zc = m * 2 + 2;\n        cnt = cnt * 2 + m;\n        int oc = r + cnt + m + r - 1;\n        if (n < oc) return Mint(0);\n        int nn = n-oc;\n        int kk = zc+oc;\n\n        Mint u = Mint(1);\n        u *= fact[nn + kk - 1];\n        u *= iFac[kk - 1];\n        u *= iFac[nn];\n//        writeln(\"wow \", pos, \" \", sm, \" \", zc, \" \", oc, \" : \", u);\n        return u;\n    }\n    if (he == z+1) return Mint(0);\n    Mint ans = Mint(0);\n    int nsm = sm;\n    foreach (i; 0..pos+2) {\n        int u = he * i;\n        ans += f(pos-i, nsm, cnt + he * i, he+1) * iFac[i];\n        if (i == pos+1) break;\n        nsm -= max(0, he - v[pos-i]);\n        nsm += max(0, v[pos-i] - he);\n        if (nsm < 0) break;\n    }\n    return ans;\n}\n\nMint calc(int[] _v, int _r) {\n    v = _v; r = _r; m = v.length.to!int;\n    z = v.sum;\n    f.init([[-1, m-1], [0, z], [0, 2*z], [0, z+1]]);\n    Mint res = f(v.length.to!int - 1, 0, 0, 0);\n    return res * fact[r+m] * iFac[r] * iFac[m] * fact[m];\n}\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) sc.read!true;\n\n    int k; string s;\n    sc.read(n, k, s);\n\n    Mint sm = Mint(1);\n    foreach (i; 0..k+1) {\n        foreach (j; 0..k+1) {\n            if (!i && !j) continue;\n            \n            int[] v = new int[i];\n            int rc = 0, nrc = 0; int bc = 0;\n            foreach (c; s) {\n                if (c == 'r') {\n                    if (rc != i) {\n                        rc++;\n                        continue;\n                    }\n                    if (nrc != j) {\n                        nrc++;\n                        continue;\n                    }\n                } else {\n                    if (bc < rc) {\n                        bc++;\n                        continue;\n                    }\n                }\n                if (bc == 0) continue;\n                v[bc-1]++;\n            }\n            if (bc != i) continue;\n            if (nrc != j) continue;\n            sm += calc(v, j);\n        }\n    }\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/int128.d */\n \n\n// module dkh.int128;\n\nversion(LDC) {\n//     import dkh.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/functional.d */\n// module dkh.functional;\n\n \nstruct memoCont(alias pred) {\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.meta : allSatisfy;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    \n    private int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(in int[2][N] rng) {\n        import std.algorithm : reduce, map;\n        import std.range : array;\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        auto sz = reduce!\"a*b\"(1, len);\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        import core.exception : RangeError;\n        size_t idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/modint.d */\n// module dkh.modint;\n\n// import dkh.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/ldc/inline.d */\n// module dkh.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir) R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/numeric/primitive.d */\n// module dkh.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n \nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\n// import dkh.int128;\n\n \nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\n// import dkh.modint;\nalias Mint = ModInt!(10^^9 + 7);\n\nMint[] fact, iFac;\nstatic this() {\n    fact = factTable!Mint(1000);\n    iFac = invFactTable!Mint(1000);\n}\n\nint n, m, z;\nint[] v;\nint r;\n\n// import dkh.functional;\n\nmemoCont!fBase f;\nMint fBase(int pos, int sm, int cnt) {\n    if (pos == -1) {\n        if (sm) return Mint(0);\n        int zc = m * 2 + 2;\n        cnt = cnt * 2 + m;\n        int oc = r + cnt + m + r - 1;\n        if (n < oc) return Mint(0);\n        int nn = n-oc;\n        int kk = zc+oc;\n\n        Mint u = Mint(1);\n        u *= fact[nn + kk - 1];\n        u *= iFac[kk - 1];\n        u *= iFac[nn];\n//        writeln(\"wow \", pos, \" \", sm, \" \", zc, \" \", oc, \" : \", u);\n        return u;\n    }\n    Mint ans = Mint(0);\n    foreach (i; 0..z+1) {\n        int nsm = sm - max(0, v[pos]-i) + max(0, i-v[pos]);\n        if (z < nsm) continue;\n        ans += f(pos-1, max(0, nsm), cnt + i);\n    }\n    return ans;\n}\n\nMint calc(int[] _v, int _r) {\n    v = _v; r = _r; m = v.length.to!int;\n    reverse(v);\n    z = v.sum;\n//    writeln(\"calc start: \", v, \" \", r);\n    f.init([[-1, m-1], [0, z], [0, 2*z]]);\n    Mint res = f(v.length.to!int - 1, 0, 0);\n//    writeln(\"res \", res);\n    return res * fact[r+m] * iFac[r] * iFac[m];\n}\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n    scope(exit) sc.read!true;\n\n    int k; string s;\n    sc.read(n, k, s);\n\n    Mint sm = Mint(1);\n    foreach (i; 0..k+1) {\n        foreach (j; 0..k+1) {\n            if (!i && !j) continue;\n            \n            int[] v = new int[i];\n            int rc = 0, nrc = 0; int bc = 0;\n            foreach (c; s) {\n                if (c == 'r') {\n                    if (rc != i) {\n                        rc++;\n                        continue;\n                    }\n                    if (nrc != j) {\n                        nrc++;\n                        continue;\n                    }\n                } else {\n                    if (bc < rc) {\n                        bc++;\n                        continue;\n                    }\n                }\n                if (bc == 0) continue;\n                v[bc-1]++;\n            }\n            if (bc != i) continue;\n            if (nrc != j) continue;\n            sm += calc(v, j);\n        }\n    }\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/int128.d */\n \n\n// module dkh.int128;\n\nversion(LDC) {\n//     import dkh.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/functional.d */\n// module dkh.functional;\n\n \nstruct memoCont(alias pred) {\n    import std.traits : ReturnType, ParameterTypeTuple, isIntegral;\n    import std.meta : allSatisfy;\n    alias R = ReturnType!pred;\n    alias Args = ParameterTypeTuple!pred;\n    static assert (allSatisfy!(isIntegral, Args));\n    static immutable N = Args.length;\n    \n    private int[2][N] rng;\n    int[N] len;\n    R[] dp;\n    bool[] used;\n    void init(in int[2][N] rng) {\n        import std.algorithm : reduce, map;\n        import std.range : array;\n        this.rng = rng;\n        len = rng[].map!(a => a[1]-a[0]+1).array;\n        auto sz = reduce!\"a*b\"(1, len);\n        dp = new R[sz];\n        used = new bool[sz];\n    }\n    R opCall(Args args) {\n        import core.exception : RangeError;\n        size_t idx, base = 1;\n        foreach (i, v; args) {\n            version(assert) {\n                if (v < rng[i][0] || rng[i][1] < v) {\n                    throw new RangeError;\n                }\n            }\n            assert(rng[i][0] <= v && v <= rng[i][1]);\n            idx += base*(v - rng[i][0]);\n            base *= len[i];\n        }\n        if (used[idx]) return dp[idx];\n        used[idx] = true;\n        auto r = pred(args);\n        dp[idx] = r;\n        return r;\n    }\n}\n\n \n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/modint.d */\n// module dkh.modint;\n\n// import dkh.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() const {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/ldc/inline.d */\n// module dkh.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir) R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/numeric/primitive.d */\n// module dkh.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n \nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\n// import dkh.int128;\n\n \nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Python",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nconstexpr lint MOD = 1000000007;\n\nvector<lint> fac, facInv, inv;\n\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\n\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\n\nint N, K;\nstring s;\n\nbool is_partition_able(vector<int> partition)\n{\n    int r_head = 0, b_head = 0;\n    int pending = 0;\n    for (auto c : s)\n    {\n        if (c == 'r')\n        {\n            if (r_head < partition.size()) r_head++;\n            else pending = max(pending-1, 0);\n        }\n        else\n        {\n            if (r_head == b_head || partition[b_head] < 2) pending = max(pending-1, 0);\n            else\n            {\n                pending += partition[b_head] - 2;\n                b_head++;\n            }\n        }\n    }\n    if (pending > 0 || (b_head < partition.size() && partition[b_head] > 1) || r_head < partition.size()) return false;\n    return true;\n}\n\n\nlint calc_for_each_partition(vector<int> &partition)\n{\n    if (!is_partition_able(partition)) return 0;\n\n    int rd = 0;\n    map<int, int> len_map;\n    for (auto v : partition)\n    {\n        len_map[v]++;\n        if (v > 1) rd += 2;\n    }\n    lint ans = nCr(N + 1 + rd, 2 * accumulate(partition.begin(), partition.end(), 0));\n    for (auto v : len_map) (ans *= facInv[v.second]) %= MOD;\n    (ans *= fac[partition.size()]) %= MOD;\n    return ans;\n}\n\n\nlint dfs(vector<int> partition_now)\n{\n    lint ans = calc_for_each_partition(partition_now);\n    int used_len = 0;\n    for (auto v : partition_now) used_len += 1 + max(v*2-3, 1);\n    int highest = partition_now.back();\n\n    partition_now.push_back(0);\n\n    if (partition_now.size() - 1 < K) for (int l=1; l<=min(highest, K-used_len); l++)\n    {\n        partition_now.back() = l;\n        ans += dfs(partition_now);\n    }\n    return ans % MOD;\n}\n\n\n// r -> b -> (n個のrまたはb)で島を作る\n\nint main()\n{\n    cin >> N >> K >> s;\n    facInit(70*3);\n\n    lint ans = 1;\n    for (int i=1; i<=K; i++)\n    {\n        (ans += dfs(vector<int>{i})) %= MOD;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 { ans = ans * base % modulo; }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100000;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX+1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe {\n        FACTORIAL[n]\n    }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 { return 0; }\n    init_fact();\n    unsafe {\n        FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD\n    }\n}\n\nfn get_min_size(g: usize) -> usize {\n    if g <= 2 { 1 } else { (g - 2) * 2 + 1 }\n}\nfn is_valid(groups: &Vec<usize>, n: usize, s: &Vec<char>) -> bool {\n    // println!(\"{:?}\", groups);\n    if groups.len() == 0 { return true; }\n    let k = s.len();\n    let mut sum = groups.len() - 1;\n    for g in groups.iter().rev() {\n        sum += get_min_size(*g);\n    }\n    // println!(\"{:?} {}\", groups, sum);\n    if sum > n { return false; }\n    let mut used = vec![false; k];\n    let mut rindex = vec![k; groups.len()];\n    'rloop: for (i, _) in groups.iter().rev().enumerate() {\n        for j in 0..k {\n            if used[j] || s[j] == 'b' { continue; }\n            used[j] = true;\n            rindex[i] = j;\n            continue 'rloop;\n        }\n        return false;\n    }\n    'bloop: for (i, g) in groups.iter().rev().enumerate() {\n        if *g == 1 { continue; }\n        for j in rindex[i]+1..k {\n            if used[j] || s[j] == 'r' { continue; }\n            used[j] = true;\n            continue 'bloop;\n        }\n        return false;\n    }\n    'lastloop: for (i, g) in groups.iter().rev().enumerate() {\n        if *g <= 2 { continue; }\n        let mut rest = g - 2;\n        for j in rindex[i] + 1..k {\n            if used[j] { continue; }\n            used[j] = true;\n            rest -= 1;\n            if rest == 0 { continue 'lastloop; }\n        }\n        return false;\n    }\n    true\n}\n\nstruct Solver {\n    memo: Vec<HashMap<Vec<usize>, i64>>,\n    memo_rb_seq: [[i64; 100]; 100],\n}\nimpl Solver {\nfn new() -> Solver {\n    Solver {\n        memo: vec![HashMap::<Vec<usize>, i64>::new(); 100],\n        memo_rb_seq: [[-1; 100]; 100],\n    }\n}\n\nfn calc_rb_seq(&mut self, g: usize, w: usize) -> i64 {\n    if w == 0 { return 0; }\n    if g == 1 { return 1; }\n    if self.memo_rb_seq[g][w] != -1 { return self.memo_rb_seq[g][w]; }\n    // println!(\"{} {}\", g, w);\n    let mut ret = 0;\n    for i in 0..3 {\n        let use_width = get_min_size(g) + i;\n        let amp = [1, 2, 1][i];\n        if w < use_width { continue; }\n        ret = (ret + amp * combi(w - 1, use_width - 1)) % MOD;\n        // println!(\"cnt {} {}\", use_width, ret);\n    }\n    self.memo_rb_seq[g][w] = ret;\n    ret\n}\nfn calc_inner(&mut self, groups: &Vec<usize>, sum: usize, n: usize, index: usize, rest: usize) -> i64 {\n    if index == groups.len() { return 1; }\n    if sum > rest { return 0; }\n    if let Some(ret) = self.memo[rest].get(&groups[index..]) {\n        // println!(\"{:?} {}\", groups[index..].to_vec(), ret);\n        return *ret;\n    }\n    let g = get_min_size(groups[index]);\n    let mut ret = 0;\n    ret = (ret + self.calc_inner(groups, sum, n, index, rest - 1)) % MOD;\n    for i in g..rest {\n        let mut nrest = rest - i - 1;\n        // println!(\"{} {} {}\", index, rest, nrest);\n        let cnt = self.calc_rb_seq(groups[index], i);\n        ret = (ret + cnt * self.calc_inner(groups, sum - (g + 1), n, index + 1, nrest)) % MOD;\n    }\n    self.memo[rest].insert(groups[index..].to_vec(), ret);\n    ret\n}\n\nfn calc(&mut self, groups: &Vec<usize>, n: usize) -> i64 {\n    let groups = groups.iter().cloned().rev().collect::<Vec<usize>>();\n    let mut cnts = HashMap::<usize, usize>::new();\n    for g in groups.iter() {\n        let cnt = cnts.entry(*g).or_insert(0);\n        *cnt += 1;\n    }\n    let mut amp = 1;\n    let mut rest = groups.len();\n    for cnt in cnts.values() {\n        amp = (amp * combi(rest, *cnt)) % MOD;\n        rest -= *cnt;\n    }\n    // println!(\"{} {:?}\", n, groups);\n    let sum = groups.iter().fold(0, |sum, v| sum + get_min_size(*v) + 1);\n    let ret = amp * self.calc_inner(&groups, sum, n, 0, n + 1) % MOD;\n    // println!(\"{} {:?} {}\", n, groups, ret);\n    ret\n}\n\nfn solve(&mut self, groups: &mut Vec<usize>, depth: usize, n: usize, s: &Vec<char>) -> i64 {\n    if depth > n + 1 { return 0; }\n    let mut ans = 0;\n    groups.push(depth);\n    if is_valid(groups, n, s) {\n        ans = (ans + self.calc(groups, n)) % MOD;\n        ans = (ans + self.solve(groups, depth, n, s)) % MOD;\n    }\n    groups.pop();\n    ans = (ans + self.solve(groups, depth + 1, n, s)) % MOD;\n    return ans;\n}\n}\n\nfn main() {\n    let n: usize = read();\n    let _: usize = read();\n    let s: String = read();\n    let s = s.chars().collect::<Vec<char>>();\n    let mut solver = Solver::new();\n    let ans = (1 + solver.solve(&mut vec![], 1, n, &s)) % MOD;\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 { ans = ans * base % modulo; }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100000;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX+1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe {\n        FACTORIAL[n]\n    }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 { return 0; }\n    init_fact();\n    unsafe {\n        FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD\n    }\n}\n\nfn get_min_size(g: usize) -> usize {\n    if g <= 2 { 1 } else { (g - 2) * 2 + 1 }\n}\nfn total_size(groups: &Vec<usize>) -> usize {\n    groups.iter().fold(0, |sum, v| sum + get_min_size(*v) + 1) - 1\n}\nfn is_valid(groups: &Vec<usize>, n: usize, s: &Vec<char>) -> bool {\n    // println!(\"{:?}\", groups);\n    if groups.len() == 0 { return true; }\n    let k = s.len();\n    let sum = total_size(groups);\n    // println!(\"{:?} {}\", groups, sum);\n    if sum > n { return false; }\n    let mut used = vec![false; k];\n    let mut rindex = vec![k; groups.len()];\n    'rloop: for (i, _) in groups.iter().rev().enumerate() {\n        for j in 0..k {\n            if used[j] || s[j] == 'b' { continue; }\n            used[j] = true;\n            rindex[i] = j;\n            continue 'rloop;\n        }\n        return false;\n    }\n    'bloop: for (i, g) in groups.iter().rev().enumerate() {\n        if *g == 1 { continue; }\n        for j in rindex[i]+1..k {\n            if used[j] || s[j] == 'r' { continue; }\n            used[j] = true;\n            rindex[i] = j;\n            continue 'bloop;\n        }\n        return false;\n    }\n    'lastloop: for (i, g) in groups.iter().rev().enumerate() {\n        if *g <= 2 { continue; }\n        let mut rest = g - 2;\n        for j in rindex[i] + 1..k {\n            if used[j] { continue; }\n            used[j] = true;\n            rest -= 1;\n            if rest == 0 { continue 'lastloop; }\n        }\n        return false;\n    }\n    true\n}\n\nstruct Solver {\n    memo: Vec<HashMap<Vec<usize>, i32>>,\n    memo_rb_seq: [[i32; 100]; 100],\n}\nimpl Solver {\nfn new() -> Solver {\n    Solver {\n        memo: vec![HashMap::new(); 100],\n        memo_rb_seq: [[-1; 100]; 100],\n    }\n}\n\nfn calc_rb_seq(&mut self, g: usize, w: usize) -> i64 {\n    if w == 0 { return 0; }\n    if g == 1 { return 1; }\n    if self.memo_rb_seq[g][w] != -1 { return self.memo_rb_seq[g][w] as i64; }\n    // println!(\"{} {}\", g, w);\n    let mut ret = 0;\n    for i in 0..3 {\n        let use_width = get_min_size(g) + i;\n        let amp = [1, 2, 1][i];\n        if w < use_width { continue; }\n        ret = (ret + amp * combi(w - 1, use_width - 1)) % MOD;\n        // println!(\"cnt {} {}\", use_width, ret);\n    }\n    self.memo_rb_seq[g][w] = ret as i32;\n    ret\n}\nfn calc_inner(&mut self, groups: &Vec<usize>, sum: usize, index: usize, rest: usize) -> i64 {\n    if index == groups.len() {\n        return if rest == 0 { 1 } else { 0 };\n    }\n    if sum > rest { return 0; }\n    if let Some(ret) = self.memo[rest].get(&groups[index..]) {\n        // println!(\"{:?} {}\", groups[index..].to_vec(), ret);\n        return *ret as i64;\n    }\n    let g = get_min_size(groups[index]);\n    let mut ret = 0;\n    ret = (ret + self.calc_inner(groups, sum, index, rest - 1)) % MOD;\n    for i in g..rest {\n        let nrest = rest - i - 1;\n        // println!(\"{} {} {}\", index, rest, nrest);\n        let cnt = self.calc_rb_seq(groups[index], i);\n        ret = (ret + cnt * self.calc_inner(groups, sum - (g + 1), index + 1, nrest)) % MOD;\n    }\n    self.memo[rest].insert(groups[index..].to_vec(), ret as i32);\n    ret\n}\n\nfn calc(&mut self, groups: &Vec<usize>, n: usize) -> i64 {\n    let groups = groups.iter().cloned().rev().collect::<Vec<usize>>();\n    let mut cnts = HashMap::<usize, usize>::new();\n    let mut ones = 0;\n    for g in groups.iter() {\n        let cnt = cnts.entry(*g).or_insert(0);\n        *cnt += 1;\n        if *g == 1 { ones += 1; }\n    }\n    let mut amp = 1;\n    let mut rest = groups.len();\n    for cnt in cnts.values() {\n        amp = (amp * combi(rest, *cnt)) % MOD;\n        rest -= *cnt;\n    }\n    let groups = groups.iter().cloned().filter(|v| *v != 1).collect::<Vec<usize>>();\n    // println!(\"{} {:?}\", n, groups);\n    let sum = total_size(&groups) + 1;\n    let mut ret = 0;\n    for ones_use in 2*ones..n+2 {\n        ret = (ret + combi(ones_use, 2 * ones) * self.calc_inner(&groups, sum, 0, n + 1 - ones_use)) % MOD;\n        // println!(\"{} {} {} {}\", ones_use, combi(ones_use, 2 * ones), self.calc_inner(&groups, sum, 0, n + 1 - ones_use), ones);\n    }\n    // println!(\"{} {:?} {}\", n, groups, ret);\n    ret * amp % MOD\n}\n\nfn solve(&mut self, groups: &mut Vec<usize>, depth: usize, n: usize, s: &Vec<char>) -> i64 {\n    if depth > n + 1 { return 0; }\n    let mut ans = 0;\n    groups.push(depth);\n    if is_valid(groups, n, s) {\n        ans = (ans + self.calc(groups, n)) % MOD;\n        ans = (ans + self.solve(groups, depth, n, s)) % MOD;\n    }\n    groups.pop();\n    ans = (ans + self.solve(groups, depth + 1, n, s)) % MOD;\n    return ans;\n}\n}\n\nfn main() {\n    let n: usize = read();\n    let _: usize = read();\n    let s: String = read();\n    let s = s.chars().collect::<Vec<char>>();\n    let mut solver = Solver::new();\n    let ans = (1 + solver.solve(&mut vec![], 1, n, &s)) % MOD;\n    println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\nuse std::collections::HashMap;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nfn pow_mod(base: i64, power: i64, modulo: i64) -> i64 {\n    let mut base = base;\n    let mut power = power;\n    let mut ans = 1;\n    while power > 0 {\n        if power & 1 == 1 { ans = ans * base % modulo; }\n        power >>= 1;\n        base = base * base % modulo;\n    }\n    ans\n}\n\n#[allow(dead_code)]\nfn inv_mod(a: i64, modulo: i64) -> i64 {\n    pow_mod(a, modulo - 2, modulo)\n}\n\nconst MOD: i64 = 1e+9 as i64 + 7;\nconst FACT_MAX: usize = 100000;\nstatic mut FACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nstatic mut RFACTORIAL: [i64; FACT_MAX + 1] = [0; FACT_MAX + 1];\nfn init_fact() {\n    unsafe {\n        if FACTORIAL[0] == 0 {\n            FACTORIAL[0] = 1;\n            for i in 1..FACT_MAX+1 {\n                FACTORIAL[i] = (FACTORIAL[i - 1] * i as i64) % MOD;\n            }\n            RFACTORIAL[FACT_MAX] = inv_mod(FACTORIAL[FACT_MAX], MOD);\n            for i in (0..FACT_MAX).rev() {\n                RFACTORIAL[i] = RFACTORIAL[i + 1] * (i as i64 + 1) % MOD;\n            }\n        }\n    }\n}\n#[allow(dead_code)]\nfn fact(n: usize) -> i64 {\n    init_fact();\n    unsafe {\n        FACTORIAL[n]\n    }\n}\n#[allow(dead_code, unused_comparisons)]\nfn combi(n: usize, m: usize) -> i64 {\n    if n < m || m < 0 { return 0; }\n    init_fact();\n    unsafe {\n        FACTORIAL[n] * RFACTORIAL[m] % MOD * RFACTORIAL[n - m] % MOD\n    }\n}\n\nfn get_min_size(g: usize) -> usize {\n    if g <= 2 { 1 } else { (g - 2) * 2 + 1 }\n}\nfn total_size(groups: &Vec<usize>) -> usize {\n    groups.iter().fold(0, |sum, v| sum + get_min_size(*v) + 1) - 1\n}\nfn is_valid(groups: &Vec<usize>, n: usize, s: &Vec<char>) -> bool {\n    // println!(\"{:?}\", groups);\n    if groups.len() == 0 { return true; }\n    let k = s.len();\n    let sum = total_size(groups);\n    // println!(\"{:?} {}\", groups, sum);\n    if sum > n { return false; }\n    let mut used = vec![false; k];\n    let mut rindex = vec![k; groups.len()];\n    'rloop: for (i, _) in groups.iter().rev().enumerate() {\n        for j in 0..k {\n            if used[j] || s[j] == 'b' { continue; }\n            used[j] = true;\n            rindex[i] = j;\n            continue 'rloop;\n        }\n        return false;\n    }\n    'bloop: for (i, g) in groups.iter().rev().enumerate() {\n        if *g == 1 { continue; }\n        for j in rindex[i]+1..k {\n            if used[j] || s[j] == 'r' { continue; }\n            used[j] = true;\n            rindex[i] = j;\n            continue 'bloop;\n        }\n        return false;\n    }\n    'lastloop: for (i, g) in groups.iter().rev().enumerate() {\n        if *g <= 2 { continue; }\n        let mut rest = g - 2;\n        for j in rindex[i] + 1..k {\n            if used[j] { continue; }\n            used[j] = true;\n            rest -= 1;\n            if rest == 0 { continue 'lastloop; }\n        }\n        return false;\n    }\n    true\n}\n\nstruct Solver {\n    memo: Vec<HashMap<Vec<usize>, i32>>,\n    memo_rb_seq: [[i32; 100]; 100],\n}\nimpl Solver {\nfn new() -> Solver {\n    Solver {\n        memo: vec![HashMap::new(); 100],\n        memo_rb_seq: [[-1; 100]; 100],\n    }\n}\n\nfn calc_rb_seq(&mut self, g: usize, w: usize) -> i64 {\n    if w == 0 { return 0; }\n    if g == 1 { return 1; }\n    if self.memo_rb_seq[g][w] != -1 { return self.memo_rb_seq[g][w] as i64; }\n    // println!(\"{} {}\", g, w);\n    let mut ret = 0;\n    for i in 0..3 {\n        let use_width = get_min_size(g) + i;\n        let amp = [1, 2, 1][i];\n        if w < use_width { continue; }\n        ret = (ret + amp * combi(w - 1, use_width - 1)) % MOD;\n        // println!(\"cnt {} {}\", use_width, ret);\n    }\n    self.memo_rb_seq[g][w] = ret as i32;\n    ret\n}\nfn calc_inner(&mut self, groups: &Vec<usize>, sum: usize, n: usize, index: usize, rest: usize) -> i64 {\n    if index == groups.len() { return 1; }\n    if sum > rest { return 0; }\n    if let Some(ret) = self.memo[rest].get(&groups[index..]) {\n        // println!(\"{:?} {}\", groups[index..].to_vec(), ret);\n        return *ret as i64;\n    }\n    if groups[index] == 1 {\n        let ones = groups.len() - index;\n        return combi(rest, 2 * ones);\n    }\n    let g = get_min_size(groups[index]);\n    let mut ret = 0;\n    ret = (ret + self.calc_inner(groups, sum, n, index, rest - 1)) % MOD;\n    for i in g..rest {\n        let mut nrest = rest - i - 1;\n        // println!(\"{} {} {}\", index, rest, nrest);\n        let cnt = self.calc_rb_seq(groups[index], i);\n        ret = (ret + cnt * self.calc_inner(groups, sum - (g + 1), n, index + 1, nrest)) % MOD;\n    }\n    self.memo[rest].insert(groups[index..].to_vec(), ret as i32);\n    ret\n}\n\nfn calc(&mut self, groups: &Vec<usize>, n: usize) -> i64 {\n    let groups = groups.iter().cloned().rev().collect::<Vec<usize>>();\n    let mut cnts = HashMap::<usize, usize>::new();\n    for g in groups.iter() {\n        let cnt = cnts.entry(*g).or_insert(0);\n        *cnt += 1;\n    }\n    let mut amp = 1;\n    let mut rest = groups.len();\n    for cnt in cnts.values() {\n        amp = (amp * combi(rest, *cnt)) % MOD;\n        rest -= *cnt;\n    }\n    // println!(\"{} {:?}\", n, groups);\n    let sum = total_size(&groups) + 1;\n    let ret = amp * self.calc_inner(&groups, sum, n, 0, n + 1) % MOD;\n    // println!(\"{} {:?} {}\", n, groups, ret);\n    ret\n}\n\nfn solve(&mut self, groups: &mut Vec<usize>, depth: usize, n: usize, s: &Vec<char>) -> i64 {\n    if depth > n + 1 { return 0; }\n    let mut ans = 0;\n    groups.push(depth);\n    if is_valid(groups, n, s) {\n        ans = (ans + self.calc(groups, n)) % MOD;\n        ans = (ans + self.solve(groups, depth, n, s)) % MOD;\n    }\n    groups.pop();\n    ans = (ans + self.solve(groups, depth + 1, n, s)) % MOD;\n    return ans;\n}\n}\n\nfn main() {\n    let n: usize = read();\n    let _: usize = read();\n    let s: String = read();\n    let s = s.chars().collect::<Vec<char>>();\n    let mut solver = Solver::new();\n    let ans = (1 + solver.solve(&mut vec![], 1, n, &s)) % MOD;\n    println!(\"{}\", ans);\n}"
  }
]