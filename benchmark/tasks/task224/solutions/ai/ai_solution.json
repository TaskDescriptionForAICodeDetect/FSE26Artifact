[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_TETRA 200\n#define MAX_NUM 1000000\n\nint tetra[MAX_TETRA];\nint odd_tetra[MAX_TETRA];\nint tetra_count = 0;\nint odd_tetra_count = 0;\n\nvoid precompute_tetra() {\n    int n = 1;\n    while (1) {\n        int num = n * (n + 1) * (n + 2) / 6;\n        if (num > MAX_NUM) break;\n        tetra[tetra_count++] = num;\n        if (num % 2 != 0) {\n            odd_tetra[odd_tetra_count++] = num;\n        }\n        n++;\n    }\n}\n\nvoid solve(int num, int* dp, int* tetra_arr, int count) {\n    dp[0] = 0;\n    for (int i = 1; i <= num; i++) {\n        dp[i] = INT_MAX;\n        for (int j = 0; j < count; j++) {\n            if (i >= tetra_arr[j] && dp[i - tetra_arr[j]] != INT_MAX) {\n                if (dp[i - tetra_arr[j]] + 1 < dp[i]) {\n                    dp[i] = dp[i - tetra_arr[j]] + 1;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    precompute_tetra();\n    \n    int num;\n    while (1) {\n        scanf(\"%d\", &num);\n        if (num == 0) break;\n        \n        int* dp = (int*)malloc((num + 1) * sizeof(int));\n        int* dp_odd = (int*)malloc((num + 1) * sizeof(int));\n        \n        solve(num, dp, tetra, tetra_count);\n        solve(num, dp_odd, odd_tetra, odd_tetra_count);\n        \n        printf(\"%d %d\\n\", dp[num], dp_odd[num]);\n        \n        free(dp);\n        free(dp_odd);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PollockConjecture {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            int[] result = solve(n);\n            System.out.println(result[0] + \" \" + result[1]);\n        }\n        \n        scanner.close();\n    }\n    \n    static int[] solve(int n) {\n        List<Integer> tetrahedralNumbers = generateTetrahedralNumbers(n);\n        List<Integer> oddTetrahedralNumbers = generateOddTetrahedralNumbers(n);\n        \n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        \n        int[] oddDp = new int[n + 1];\n        Arrays.fill(oddDp, Integer.MAX_VALUE);\n        oddDp[0] = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int num : tetrahedralNumbers) {\n                if (num > i) break;\n                if (dp[i - num] != Integer.MAX_VALUE) {\n                    dp[i] = Math.min(dp[i], dp[i - num] + 1);\n                }\n            }\n            \n            for (int num : oddTetrahedralNumbers) {\n                if (num > i) break;\n                if (oddDp[i - num] != Integer.MAX_VALUE) {\n                    oddDp[i] = Math.min(oddDp[i], oddDp[i - num] + 1);\n                }\n            }\n        }\n        \n        return new int[]{dp[n], oddDp[n]};\n    }\n    \n    static List<Integer> generateTetrahedralNumbers(int limit) {\n        List<Integer> tetrahedralNumbers = new ArrayList<>();\n        int num = 1, index = 1;\n        \n        while (num <= limit) {\n            tetrahedralNumbers.add(num);\n            index++;\n            num = index * (index + 1) * (index + 2) / 6;\n        }\n        \n        return tetrahedralNumbers;\n    }\n    \n    static List<Integer> generateOddTetrahedralNumbers(int limit) {\n        List<Integer> oddTetrahedralNumbers = new ArrayList<>();\n        int num = 1, index = 1;\n        \n        while (num <= limit) {\n            if (index % 2 != 0) {\n                oddTetrahedralNumbers.add(num);\n            }\n            index++;\n            num = index * (index + 1) * (index + 2) / 6;\n        }\n        \n        return oddTetrahedralNumbers;\n    }\n}",
    "timestamp": "2025-08-05 19:09:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nvector<int> generateTetrahedralNumbers(int limit) {\n    vector<int> tetra;\n    int n = 1;\n    while (true) {\n        int num = n * (n + 1) * (n + 2) / 6;\n        if (num > limit) break;\n        tetra.push_back(num);\n        n++;\n    }\n    return tetra;\n}\n\nvector<int> generateOddTetrahedralNumbers(int limit) {\n    vector<int> oddTetra;\n    int n = 1;\n    while (true) {\n        int num = n * (n + 1) * (n + 2) / 6;\n        if (num > limit) break;\n        if (num % 2 != 0) {\n            oddTetra.push_back(num);\n        }\n        n++;\n    }\n    return oddTetra;\n}\n\nvoid precomputeDP(vector<int>& dp, const vector<int>& nums) {\n    dp[0] = 0;\n    for (int i = 1; i < dp.size(); ++i) {\n        for (int num : nums) {\n            if (num <= i) {\n                dp[i] = min(dp[i], dp[i - num] + 1);\n            }\n        }\n    }\n}\n\nint main() {\n    const int MAX = 1e6;\n    vector<int> tetra = generateTetrahedralNumbers(MAX);\n    vector<int> oddTetra = generateOddTetrahedralNumbers(MAX);\n    \n    vector<int> dp(MAX + 1, INT_MAX);\n    vector<int> dpOdd(MAX + 1, INT_MAX);\n    \n    precomputeDP(dp, tetra);\n    precomputeDP(dpOdd, oddTetra);\n    \n    int n;\n    while (cin >> n, n != 0) {\n        cout << dp[n] << \" \" << dpOdd[n] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000000\n\nint tetrahedral[MAX_N];\nint odd_tetrahedral[MAX_N];\nint dp[MAX_N];\nint odd_dp[MAX_N];\n\nvoid generate_tetrahedral() {\n    int idx = 0;\n    for (int n = 1; ; n++) {\n        int t = (n * (n + 1) * (n + 2)) / 6;\n        if (t >= MAX_N) break;\n        tetrahedral[idx++] = t;\n    }\n    tetrahedral[idx] = 0;\n}\n\nvoid generate_odd_tetrahedral() {\n    int idx = 0;\n    for (int n = 1; ; n += 2) {\n        int t = (n * (n + 1) * (n + 2)) / 6;\n        if (t >= MAX_N) break;\n        odd_tetrahedral[idx++] = t;\n    }\n    odd_tetrahedral[idx] = 0;\n}\n\nint solve(int* tetra, int* dp) {\n    memset(dp, 0x3f, MAX_N * sizeof(int));\n    dp[0] = 0;\n\n    for (int i = 0; tetra[i] != 0; i++) {\n        for (int j = tetra[i]; j < MAX_N; j++) {\n            dp[j] = (dp[j] < dp[j - tetra[i]] + 1) ? dp[j] : dp[j - tetra[i]] + 1;\n        }\n    }\n\n    return 0;\n}\n\nint main() {\n    generate_tetrahedral();\n    generate_odd_tetrahedral();\n\n    solve(tetrahedral, dp);\n    solve(odd_tetrahedral, odd_dp);\n\n    int n;\n    while (scanf(\"%d\", &n) && n != 0) {\n        printf(\"%d %d\\n\", dp[n], odd_dp[n]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nvector<long long> generateTetrahedralNumbers(int limit) {\n    vector<long long> tetraNumbers;\n    for (int n = 1; ; ++n) {\n        long long tn = (n * (n + 1) * (n + 2)) / 6;\n        if (tn >= limit) break;\n        tetraNumbers.push_back(tn);\n    }\n    return tetraNumbers;\n}\n\nvector<long long> generateOddTetrahedralNumbers(int limit) {\n    vector<long long> oddTetraNumbers;\n    for (int n = 1; ; n += 2) {\n        long long tn = (n * (n + 1) * (n + 2)) / 6;\n        if (tn >= limit) break;\n        oddTetraNumbers.push_back(tn);\n    }\n    return oddTetraNumbers;\n}\n\nint minTetrahedralSum(int target, const vector<long long>& tetraNumbers) {\n    vector<int> dp(target + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int i = 1; i <= target; ++i) {\n        for (long long tn : tetraNumbers) {\n            if (tn > i) break;\n            if (dp[i - tn] != INT_MAX) {\n                dp[i] = min(dp[i], dp[i - tn] + 1);\n            }\n        }\n    }\n\n    return dp[target];\n}\n\nint main() {\n    int limit = 1000000;\n    vector<long long> tetraNumbers = generateTetrahedralNumbers(limit);\n    vector<long long> oddTetraNumbers = generateOddTetrahedralNumbers(limit);\n\n    int n;\n    while (cin >> n && n != 0) {\n        int regularCount = minTetrahedralSum(n, tetraNumbers);\n        int oddCount = minTetrahedralSum(n, oddTetraNumbers);\n        cout << regularCount << \" \" << oddCount << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PollockConjecture {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<Integer> inputs = new ArrayList<>();\n        while (true) {\n            int num = scanner.nextInt();\n            if (num == 0) break;\n            inputs.add(num);\n        }\n        \n        int max = Collections.max(inputs);\n        List<Integer> tetra = new ArrayList<>();\n        List<Integer> oddTetra = new ArrayList<>();\n        \n        int n = 1;\n        while (true) {\n            int t = n * (n + 1) * (n + 2) / 6;\n            if (t > max) break;\n            tetra.add(t);\n            if (t % 2 != 0) {\n                oddTetra.add(t);\n            }\n            n++;\n        }\n        \n        int[] dp = new int[max + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        for (int t : tetra) {\n            for (int j = t; j <= max; j++) {\n                if (dp[j - t] != Integer.MAX_VALUE) {\n                    dp[j] = Math.min(dp[j], dp[j - t] + 1);\n                }\n            }\n        }\n        \n        int[] dpOdd = new int[max + 1];\n        Arrays.fill(dpOdd, Integer.MAX_VALUE);\n        dpOdd[0] = 0;\n        for (int t : oddTetra) {\n            for (int j = t; j <= max; j++) {\n                if (dpOdd[j - t] != Integer.MAX_VALUE) {\n                    dpOdd[j] = Math.min(dpOdd[j], dpOdd[j - t] + 1);\n                }\n            }\n        }\n        \n        for (int num : inputs) {\n            System.out.println(dp[num] + \" \" + dpOdd[num]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:11:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def generate_tetrahedral_numbers(max_num):\n    tetrahedral_numbers = []\n    n = 1\n    while True:\n        tetrahedral = n * (n + 1) * (n + 2) // 6\n        if tetrahedral > max_num:\n            break\n        tetrahedral_numbers.append(tetrahedral)\n        n += 1\n    return tetrahedral_numbers\n\ndef is_odd(number):\n    return number % 2 != 0\n\ndef pollocks_conjecture(num, tetrahedrals):\n    dp = [float('inf')] * (num + 1)\n    dp[0] = 0\n    for t in tetrahedrals:\n        for i in range(t, num + 1):\n            dp[i] = min(dp[i], dp[i - t] + 1)\n    return dp[num]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split()\n    numbers = list(map(int, data))\n    \n    max_number = max(numbers)\n    tetrahedrals = generate_tetrahedral_numbers(max_number)\n    odd_tetrahedrals = list(filter(is_odd, tetrahedrals))\n    \n    results = []\n    \n    for num in numbers:\n        if num == 0:\n            break\n        min_tetrahedral_count = pollocks_conjecture(num, tetrahedrals)\n        min_odd_tetrahedral_count = pollocks_conjecture(num, odd_tetrahedrals)\n        results.append(f\"{min_tetrahedral_count} {min_odd_tetrahedral_count}\")\n    \n    for result in results:\n        print(result)\n\nmain()",
    "timestamp": "2025-08-13 02:50:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class PollocksConjecture {\n\n    private static List<Integer> tetrahedralNumbers = new ArrayList<>();\n    private static List<Integer> oddTetrahedralNumbers = new ArrayList<>();\n\n    static {\n        int n = 1;\n        int tetra;\n        while ((tetra = n * (n + 1) * (n + 2) / 6) < 1000000) {\n            tetrahedralNumbers.add(tetra);\n            if (tetra % 2 != 0) {\n                oddTetrahedralNumbers.add(tetra);\n            }\n            n++;\n        }\n    }\n\n    private static int minTetrahedralNumbers(int number, List<Integer> tetraNumbers) {\n        int[] dp = new int[number + 1];\n        for (int i = 1; i <= number; i++) {\n            dp[i] = Integer.MAX_VALUE;\n            for (int t : tetraNumbers) {\n                if (t > i) break;\n                dp[i] = Math.min(dp[i], dp[i - t] + 1);\n            }\n        }\n        return dp[number];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int number = scanner.nextInt();\n            if (number == 0) break;\n            int minTetra = minTetrahedralNumbers(number, tetrahedralNumbers);\n            int minOddTetra = minTetrahedralNumbers(number, oddTetrahedralNumbers);\n            System.out.println(minTetra + \" \" + minOddTetra);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 02:50:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint calculate_tetrahedral(int n) {\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\nvoid generate_tetrahedral_numbers(int *tetrahedral, int *odd_tetrahedral, int *count, int *odd_count) {\n    int n = 1;\n    while (1) {\n        int tn = calculate_tetrahedral(n);\n        if (tn >= 1000000) break;\n        tetrahedral[(*count)++] = tn;\n        if (tn % 2 != 0) {\n            odd_tetrahedral[(*odd_count)++] = tn;\n        }\n        n++;\n    }\n}\n\nint min_tetrahedral_sum(int num, int *tetrahedral, int count) {\n    int dp[num + 1];\n    for (int i = 1; i <= num; i++) {\n        dp[i] = num + 1;\n    }\n    dp[0] = 0;\n\n    for (int i = 0; i < count; i++) {\n        for (int j = tetrahedral[i]; j <= num; j++) {\n            if (j >= tetrahedral[i]) {\n                dp[j] = dp[j] < dp[j - tetrahedral[i]] + 1 ? dp[j] : dp[j - tetrahedral[i]] + 1;\n            }\n        }\n    }\n    return dp[num];\n}\n\nint main() {\n    int num;\n    int tetrahedral[500], odd_tetrahedral[500];\n    int count = 0, odd_count = 0;\n\n    generate_tetrahedral_numbers(tetrahedral, odd_tetrahedral, &count, &odd_count);\n\n    while (1) {\n        scanf(\"%d\", &num);\n        if (num == 0) break;\n        int result_all = min_tetrahedral_sum(num, tetrahedral, count);\n        int result_odd = min_tetrahedral_sum(num, odd_tetrahedral, odd_count);\n        printf(\"%d %d\\n\", result_all, result_odd);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:50:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def generate_tetrahedral_numbers(limit):\n    tet_nums = []\n    k = 1\n    while True:\n        num = k * (k + 1) * (k + 2) // 6\n        if num > limit:\n            break\n        tet_nums.append(num)\n        k += 1\n    return tet_nums\n\ndef generate_odd_tetrahedral_numbers(limit):\n    odd_tet_nums = []\n    k = 1\n    while True:\n        num = k * (k + 1) * (k + 2) // 6\n        if num > limit:\n            break\n        if num % 2 == 1:\n            odd_tet_nums.append(num)\n        k += 1\n    return odd_tet_nums\n\ndef min_tetrahedral_sum(n, tet_nums):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        for t in tet_nums:\n            if t <= i:\n                dp[i] = min(dp[i], dp[i - t] + 1)\n    \n    return dp[n]\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        tet_nums = generate_tetrahedral_numbers(n)\n        odd_tet_nums = generate_odd_tetrahedral_numbers(n)\n        \n        all_tet_result = min_tetrahedral_sum(n, tet_nums)\n        odd_tet_result = min_tetrahedral_sum(n, odd_tet_nums)\n        \n        print(f\"{all_tet_result} {odd_tet_result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:50:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef precompute_tetrahedral(max_n):\n    tetra = []\n    n = 1\n    while True:\n        num = n * (n + 1) * (n + 2) // 6\n        if num > max_n:\n            break\n        tetra.append(num)\n        n += 1\n    return tetra\n\ndef precompute_odd_tetrahedral(max_n):\n    odd_tetra = []\n    n = 1\n    while True:\n        num = n * (n + 1) * (n + 2) // 6\n        if num > max_n:\n            break\n        if num % 2 == 1:\n            odd_tetra.append(num)\n        n += 1\n    return odd_tetra\n\ndef min_tetrahedral_numbers(target, tetra_list):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for num in tetra_list:\n        for i in range(num, target + 1):\n            if dp[i - num] + 1 < dp[i]:\n                dp[i] = dp[i - num] + 1\n    return dp[target]\n\ndef main():\n    inputs = []\n    max_input = 0\n    while True:\n        num = int(sys.stdin.readline())\n        if num == 0:\n            break\n        inputs.append(num)\n        if num > max_input:\n            max_input = num\n    \n    tetra_list = precompute_tetrahedral(max_input)\n    odd_tetra_list = precompute_odd_tetrahedral(max_input)\n    \n    for num in inputs:\n        min_tetra = min_tetrahedral_numbers(num, tetra_list)\n        min_odd_tetra = min_tetrahedral_numbers(num, odd_tetra_list)\n        print(min_tetra, min_odd_tetra)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:51:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nstd::vector<int> generateTetrahedralNumbers(int limit) {\n    std::vector<int> tetrahedralNumbers;\n    int n = 1;\n    int tn = n * (n + 1) * (n + 2) / 6;\n    while (tn <= limit) {\n        tetrahedralNumbers.push_back(tn);\n        n++;\n        tn = n * (n + 1) * (n + 2) / 6;\n    }\n    return tetrahedralNumbers;\n}\n\nstd::vector<int> generateOddTetrahedralNumbers(int limit) {\n    std::vector<int> oddTetrahedralNumbers;\n    int n = 1;\n    int tn = n * (n + 1) * (n + 2) / 6;\n    while (tn <= limit) {\n        if (tn % 2 != 0) {\n            oddTetrahedralNumbers.push_back(tn);\n        }\n        n++;\n        tn = n * (n + 1) * (n + 2) / 6;\n    }\n    return oddTetrahedralNumbers;\n}\n\nint minTetrahedralSum(int target, const std::vector<int>& tetrahedralNumbers) {\n    std::vector<int> dp(target + 1, INT_MAX);\n    dp[0] = 0;\n    for (int tn : tetrahedralNumbers) {\n        for (int i = tn; i <= target; ++i) {\n            if (dp[i - tn] != INT_MAX) {\n                dp[i] = std::min(dp[i], dp[i - tn] + 1);\n            }\n        }\n    }\n    return dp[target];\n}\n\nint main() {\n    std::vector<int> tetrahedralNumbers = generateTetrahedralNumbers(1000000);\n    std::vector<int> oddTetrahedralNumbers = generateOddTetrahedralNumbers(1000000);\n    \n    int number;\n    while (std::cin >> number && number != 0) {\n        int tetraCount = minTetrahedralSum(number, tetrahedralNumbers);\n        int oddTetraCount = minTetrahedralSum(number, oddTetrahedralNumbers);\n        std::cout << tetraCount << \" \" << oddTetraCount << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:07:48"
  }
]