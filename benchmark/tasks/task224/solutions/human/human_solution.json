[
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\nconst int INF = 1<<30;\nconst int N_MAX = 1000000;\n\nint dp[N_MAX];\nint dpOdd[N_MAX];\n\nint main() {\n\trep(i,N_MAX) {\n\t\tdp[i] = INF;\n\t\tdpOdd[i] = INF;\n\t}\n\tdp[0] = dpOdd[0] = 0;\n\tint n=1;\n\twhile(n*(n+1)*(n+2)/6 < N_MAX) {\n\t\tint v = n*(n+1)*(n+2)/6;\n\t\tfor(int i=v; i<N_MAX; i++) {\n\t\t\tdp[i] = min( dp[i], dp[i-v]+1 );\n\t\t}\n\t\tn++;\n\t}\n\tn=1;\n\twhile(n*(n+1)*(n+2)/6 < N_MAX) {\n\t\tint v = n*(n+1)*(n+2)/6;\n\t\tfor(int i=v; i<N_MAX; i++) {\n\t\t\tdpOdd[i] = min( dpOdd[i], dpOdd[i-v]+1 );\n\t\t}\n\t\tdo{ n++; } while((n*(n+1)*(n+2)/6)%2==0);\n\t}\n\twhile(cin >> n, n) {\n\t\tcout << dp[n] << ' ' << dpOdd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> poloc;\nvector<int> poloc_odd;\n\nvoid make_poloc()\n{\n\tint n=1;\n\twhile(1){\n\t\tint a = n*(n+1)*(n+2)/6;\n\t\tif(a > 1000000)\n\t\t\tbreak;\n\t\t\n\t\tpoloc.push_back(a);\n\t\tif(a % 2 == 1)\n\t\t\tpoloc_odd.push_back(a); \n\t\tn++;\n\t}\n}\n/*\nint search1(int n, int i, int depth)\n{\n\tif(n == 0)\n\t\treturn depth;\n\telse if(n < 0 || i < 0)\n\t\treturn 1000000;\n\telse\n\t\treturn min( min(search1(n-poloc[i],i-1,depth+1), search1(n,i-1,depth)), search1(n-poloc[i],i,depth+1));\n}\nint search2(int n, int i, int depth)\n{\n\tif(n == 0)\n\t\treturn depth;\n\telse if(n < 0 || i < 0)\n\t\treturn 1000000;\n\telse\n\t\t//return min( min(search2(n-poloc_odd[i],i-1,depth+1), search2(n,i-1,depth)), search2(n-poloc_odd[i],i,depth+1));\n\t\treturn min(search2(n-poloc_odd[i],i-1,depth+1), search2(n,i-1,depth));\n}\n*/\n\nint main()\n{\n\tmake_poloc();\n\tint n;\n\tint dp[1000001];\n\tfor(int i=0;i<=1000000;i++){\n\t\tdp[i] = 1000000;\n\t}\n\tdp[0] = 0;\n\tfor(int i=0;i<poloc.size();i++){\n\t\tfor(int j=0;j<=1000000;j++){\n\t\t\t\tif(j+poloc[i] <= 1000000)\n\t\t\t\t\tdp[j+poloc[i]] = min(dp[j+poloc[i]],dp[j]+1);\n\t\t\t\n\t\t}\n\t}\n\tint dpp[1000001] = {0};\n\tfor(int i=0;i<=1000000;i++){\n\t\tdpp[i] = 1000000;\n\t}\n\tdpp[0] = 0;\n\tfor(int i=0;i<poloc_odd.size();i++){\n\t\tfor(int j=0;j<=1000000;j++){\n\t\t\t\tif(j+poloc_odd[i] <= 1000000)\n\t\t\t\t\tdpp[j+poloc_odd[i]] = min(dpp[j+poloc_odd[i]],dpp[j]+1);\n\t\t}\n\t}\n\n\twhile(cin >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcout << dp[n] << \" \" << dpp[n] << endl;\n\t}\n\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1500001]={0,1,2,3},d[1500001],k=0,i,j,n;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<198;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MAX=1e6+10;\nusing namespace std;\nint main(){\n    vector<int>precal;\n    vector<int>dp(MAX,MAX);\n    vector<bool>flag(MAX+10,false);\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=(int)(upper_bound(precal.begin(),precal.end(),i)-precal.begin());\n        for(int j=0; j<=index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX,MAX);\n    vector<bool>oddflag(MAX+10,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=(int)(upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin());\n        for(int j=0;j<=index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\n\nint oddrec(int target, int sum, int cnt) {\n    int res=0xFFFF;\n    if(cnt>100) return 0xFFFF;\n    if(sum == target) return cnt;\n    for(int i=oddlist.size()-1; 0<=i && res>cnt; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1));\n    }\n    return res;\n}\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    int listcnt, oddlistcnt;\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\",res,oddrec(n, 0, 0));\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1000000;\nconst int INF = 1000000000;\n\nint dp_nat[MAX_N]; // dp_nat[i]: 数字iを作るための最小の正四面体の個数\nint dp_odd[MAX_N]; // dp_odd[i]: 数字iを作るための最小の奇数の正四面体の個数\n\nvector<int> tetras; // 正四面体数\nvector<int> odd_tetras; // 奇数の正四面体数\n\nint main() {\n  // 正四面体数を事前に計算しておく\n  for(int i = 1; 1; i++) {\n    int m = i*(i+1)*(i+2)/6;\n    if (m > MAX_N) break;\n    tetras.push_back(m);\n    if (m % 2 != 0) odd_tetras.push_back(m);\n  }\n\n  // 入力のnによらずdp_natとdp_oddの中身は同じになるので、入力を読む前に計算しておく\n\n  // 全ての正四面体数を使ったパターン\n  dp_nat[0] = 0;\n  for (int i = 1; i < MAX_N; i++) {\n    dp_nat[i] = INF;\n    for (int j = 0; j < tetras.size(); j++) {\n//    cout << \"dbg\" << i << \",\" << dp_nat[i] << endl;\n      if (i - tetras[j] < 0) break;\n      dp_nat[i] = min(dp_nat[i], dp_nat[i - tetras[j]] + 1);\n    }\n  }\n\n  // 奇数のみのパターン\n  dp_odd[0] = 0;\n  for (int i = 1; i < MAX_N; i++) {\n    dp_odd[i] = INF;\n    for (int j = 0; j < odd_tetras.size(); j++) {\n      if (i - odd_tetras[j] < 0) break;\n      dp_odd[i] = min(dp_odd[i], dp_odd[i - odd_tetras[j]] + 1);\n    }\n  }\n\n  int n;\n  while(cin >> n, n != 0) {\n    cout << dp_nat[n] << \" \" << dp_odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int i,j,k;\n  int x,y;\n  int inf = 1 << 10;\n  int m[200]={};\n  int memo[1000005]={};\n  int memo2[1000005]={};\n  vector <int>  odd;\n  fill(memo,memo+1000005,inf);\n  fill(memo2,memo2+1000005,inf);\n  for(i=1;i<201;i++) {\n    m[i-1]=i*(i+1)*(i+2)/6;\n    if(m[i-1]%2==1) odd.push_back(m[i-1]);\n  }\n  memo[0]=0;\n  for(i=0;i<200;i++) {\n    for(j=m[i];j<1000005;j++){\n      memo[j]=min(memo[j],memo[j-m[i]]+1);\n    }\n  }\n  memo2[0]=0;\n  for(i=0;i<odd.size();i++) {\n    for(j=odd[i];j<1000005;j++){\n      memo2[j]=min(memo2[j],memo2[j-odd[i]]+1);\n    }\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    cout << memo[n] << \" \" <<  memo2[n] << endl;\n    cin >> n;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint p(int i){\n  return i * (i + 1) * (i + 2) / 6;\n}\n\nint main(void){\n  int n = 1000000;\n  /* ???????¨??????? */\n  int ans1[n+1];\n  int ans2[n+1];\n  for(int i = 1 ; i < n + 1 ; i++){\n    ans1[i+1] = -1;\n    ans2[i+1] = -1;\n  }\n\n  for(int i = 1 ; p(i) < n + 1 ; i++){\n    ans1[p(i)] = 1;\n    if(p(i) % 2 == 1){ ans2[p(i)] = 1; }\n  }\n\n  for(int i = 2 ; i <= n ; i++){\n    if(ans1[i] == 1){\n    }else{\n      int min = 10000;\n      for(int j = 1 ; p(j) < i ; j++){\n        if(min > 2 && ans1[i - p(j)] + 1 < min){\n          min = ans1[i - p(j)] + 1;\n        }\n      }\n      ans1[i] = min;\n    }\n  }\n\n  for(int i = 2 ; i <= n ; i++){\n    if(ans2[i] == 1){\n    }else{\n      int min = 10000;\n      for(int j = 1 ; p(j) < i ; j++){\n        if(min > 2 && p(j) % 2 == 1 && ans2[i - p(j)] + 1 < min){\n          min = ans2[i - p(j)] + 1;\n        }\n      }\n      ans2[i] = min;\n    }\n  }\n\n  while(1){\n    cin >> n;\n    if(n == 0){return 0;}\n    cout << ans1[n] << \" \" << ans2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// ------------------\n// author: MatsuTaku\n// date  : 27/02/2020\n// ------------------\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  constexpr int MAX = 1e6;\n  vector<int> dp(MAX+1, MAX), dpo(MAX+1, MAX);\n  dp[0] = dpo[0] = 0;\n  vector<int> nf, nfo;\n  for (int i = 1; i*(i+1)*(i+2)/6 <= MAX; i++) {\n    const int v = i*(i+1)*(i+2)/6;\n    nf.push_back(v);\n    if (v%2==1)\n      nfo.push_back(v);\n  }\n  for (int i = 1; i <= MAX; i++) {\n    for (auto f : nf) {\n      if (i-f<0) break;\n      dp[i] = min(dp[i], dp[i-f]+1);\n    }\n    for (auto f : nfo) {\n      if (i-f<0) break;\n      dpo[i] = min(dpo[i], dpo[i-f]+1);\n    }\n  }\n\n  int n;\n  while (cin>>n and n > 0) {\n    cout << dp[n]<<\" \"<<dpo[n]<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    ll s4[101];\n    vector<ll> s4_k;\n    s4[0] = 1;\n    for(int i = 1; i < 101; i++){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    vector<ll> dp1(1000001, INF), dp2(1000001, INF);\n    dp1[0] = 0;\n    REP(i, 101){\n        REP(j, 1000001){\n            if(s4[i] <= j){\n                dp1[j] = min(dp1[j], dp1[j - s4[i]] + 1);\n            }\n        }\n    }\n    \n    dp2[0] = 0;\n    REP(i, s4_k.size()){\n        REP(j, 1000001){\n            if(s4_k[i] <= j){\n                dp2[j] = min(dp2[j], dp2[j - s4_k[i]] + 1);\n            }\n        }\n    }\n    \n    ll n;\n    cin >> n;\n    while(n != 0){\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n        \n        cin >> n;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\nint c[300];\nvector<int> d;\nint a[10000000],b[10000000];\n\nvoid f(int n){\n\n  int j=1;\n  FOR(i,1,n+1){\n    if(c[j+1]==i){\n      a[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,1,j+1){\n        res = min(res,(i/c[k])+a[i%c[k]]);\n      }\n      a[i] = res;\n    }\n  }\n\n\n  j = 0;\n  FOR(i,1,n+1){\n    if(d[j+1]==i){\n      b[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,1,j+1){\n        res = min(res,(i/d[k])+b[i%d[k]]);\n      }\n      b[i] =res;\n    }\n  \n  }\n\n\n\n\n}\n\nvoid g(int n){\n  cout<<a[n]<<' '<<b[n]<<endl;\n}\n\n\nint main(){\n\n  for(int i=1;i<200;i++){\n    c[i] = (i*(i+1)*(i+2))/6;\n   if(c[i]%2){\n     d.push_back(c[i]);\n   }\n  }\n\n  f(1000000);\n\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    g(n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[200]={0},c[1000001],d[1000001],k=0,i,j,n;\n\n  for(i=0;i<200;i++)a[i]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=0;i<1000000;i++)c[i]=d[i]=i;\n\n  for(i=1;i<195;i++)for(j=a[i];j<a[i+1];j++){\n    if(j>1000000)break;\n    c[j]=c[j-a[i]]+1;\n  }\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++){\n    if(j>1000000)break;\n    d[j]=d[j-b[i]]+1;\n  }\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nint d[1000001];\nint d2[1000001];\n\nint main()\n{\n\tint n;\n\tFill(d, INF);\n\tFill(d2, INF);\n\t\n\tvector<int> v,v2;\n\tfor (int i = 1;; i++){\n\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\tif (t > 1e6)break;\n\t\tv.push_back(t);\n\t\td[t] = 1;\n\t\tif (t % 2){\n\t\t\td2[t] = 1;\n\t\t\tv2.push_back(t);\n\t\t}\n\t}\n\n\tFor(i,1, 1e6){\n\t\trep(j, v.size())if(i + v[j] < 1e6){\n\t\t\td[i + v[j]] = min(d[i + v[j]], d[i] + 1);\n\t\t}\n\t\trep(j, v2.size())if (i + v2[j] < 1e6){\n\t\t\td2[i + v2[j]] = min(d2[i + v2[j]], d2[i] + 1);\n\t\t}\n\t}\n\n\twhile (cin >> n && n){\n\n\t\tcout << d[n] << \" \" << d2[n] << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 1e6+10\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nusing namespace std;\n#define int ll\n\nvector<int>precal;\nvector<int>dp(MAX+10,MAX);\nvector<bool>flag(MAX+10,false);\nsigned main(){\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=(int)(upper_bound(precal.begin(),precal.end(),i)-precal.begin());\n        for(int j=0; j<index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX+10,MAX);\n    vector<bool>oddflag(MAX+10,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=(int)(upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin());\n        for(int j=0;j<index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> T, T_odd, A(M,INF), odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  odd[0] = 0;\n  T.push_back(1);\n  T_odd.push_back(1);\n  while(t < 1000000){\n    T.push_back(t);\n    if (t%2) T_odd.push_back(t);\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  odd.push_back(M);\n  for(int i = 0; i < T.size(); ++i){\n    for(int j = 1; j <= 5; ++j){\n      for(int k = 0; k < T[i] && k+T[i]*j < M; ++k){\n\tA[k+T[i]*j] = min(A[k+T[i]*j],A[k]+j);\n      }\n    }\n  }\n  for(int i = 0; i < T_odd.size()-1; ++i){\n    for(int j = 1; T_odd[i]*j < T_odd[i+1]; ++j){\n      for(int k = 0; k < T_odd[i] && k+T_odd[i]*j < M; ++k){\n\todd[k+T_odd[i]*j] = min(odd[k+T_odd[i]*j],odd[k]+j);\n      }\n    }\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n#define tr(container, it) \\\n        for (auto it = container.begin(); it != container.end(); it++)\n#define scontains(c, x) ((c).find(x) != (c).end())   //O(log n)\n#define contains(c, x) (find((c).begin(),(c).end(),x) != (c).end()) //O(n)\n#define pll pair<ll,ll>\n#define pii pair<int,int>\n#define mll map<ll,ll>\n#define intv(x, a, b)((x)>=a && (x)<=b)\n#define  rep(i, _begin, _end) for (__typeof(_end) end = _end, begin = _begin,  i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n#define  _for(i, end) for (__typeof(end) i = 0, _len = (end); i < (_len); i += 1)\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define F first\n#define S second\n#define y0 y3487465\n#define y1 y8687969\n#define j0 j1347829\n#define j1 j234892\n#define next asdnext\n#define prev asdprev\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\n#define mod(x, m) ((((x) % (m)) + (m)) % (m))\n#define bit(n) (1LL<<(n))\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define readint ({int t;cin >> t;t;})\n\nconst double PI = 2 * acos(.0);\nconst int INF = 0x3f3f3f3f;\nconst ll LLINF = 1000000000000000005LL;;\nconst ll MOD = (ll) (1e9) + 7;\n\nvoid _mod(ll &x) { x = mod(x, MOD); }\n\n//const ll MOD = (ll) 998244353 ;\nconst double EPS = 1e-10;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *) array, (T *) (array + N), val);\n}\n\n\n//#define int ll\n\nint least[2010101], _least[2010101];\nint Num[301];\nvector<int> _Num;\n\n\n\nclass ExactChange {\npublic:\n\n    void solve(std::istream &cin, std::ostream &cout) {\n        int N;\n        N = 1e6;\n        rep(i, 0, 301)Num[i] = (i + 1) * (i + 2) * (i + 3) / 6;\n        int j = 0;\n        rep(i, 0, 301)if ((i + 1) * (i + 2) * (i + 3) / 6 & 1)_Num.push_back((i + 1) * (i + 2) * (i + 3) / 6);\n        Fill(least, (int) 1e7);\n        Fill(_least, (int) 1e7);\n        least[0] = _least[0] = 0;\n        _for(i, 301)\n            _for(j, (int) 1e6 + 1)\n                if (j + Num[i] <= N)\n                    least[j + Num[i]] = min(least[j + Num[i]], least[j] + 1);\n\n        _for(i, SZ(_Num))\n            _for(j, (int) 1e6 + 1)\n                if (j + _Num[i] <= N)\n                    _least[j + _Num[i]] = min(_least[j + _Num[i]], _least[j] + 1);\n        while (cin >> N && N) {\n            cout << least[N] << \" \" << _least[N] << endl;\n        };\n    };\n\n};\n\n\n#undef int\n\nint main() {\n    ExactChange solver;\n    std::istream &in(std::cin);\n    std::ostream &out(std::cout);\n    in.tie(0);\n    ios::sync_with_stdio(0);\n    out << fixed << setprecision(20);\n    solver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint cnt1[1000100], cnt2[1000100];\n\nint main() {\n\tvector< int > nums;\n\t\n\tint a = 2, c = 1, num = 1;\n\t\n\twhile (num < 1000100) {\n\t\tnums.push_back(num);\n\t\tc += a;\n\t\t++a;\n\t\tnum += c;\n\t}\n\t\n\tfor_(j,0,(int)nums.size()) {\n\t\tcnt1[nums[j]] = 1;\n\t\tif (nums[j] % 2) cnt2[nums[j]] = 1;\n\t}\n\t\n\tfor_(i,1,1000100) {\n\t\tfor_(j,0,(int)nums.size()) {\n\t\t\tif (i - nums[j] <= 0) break;\n\t\t\t\n\t\t\tif (cnt1[i] == 0) cnt1[i] = cnt1[i - nums[j]] + 1;\n\t\t\telse cnt1[i] = min(cnt1[i], cnt1[i - nums[j]] + 1);\n\t\t\t\n\t\t\tif (nums[j] % 2) {\n\t\t\t\tif (cnt2[i] == 0) cnt2[i] = cnt2[i - nums[j]] + 1;\n\t\t\t\telse cnt2[i] = min(cnt2[i], cnt2[i - nums[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << cnt1[n] << \" \" << cnt2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tlong int ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 100002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 100002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[84];\n    int b[22];\n    int t[100010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> A(M,INF), A_odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  A_odd[0] = 0;\n  while(t < 1000000){\n    for(int k = 0; k+t < M; ++k){\n      A[k+t] = min(A[k]+1,A[k+t]);\n      if(t%2) A_odd[k+t] = min(A_odd[k]+1,A_odd[k+t]);\n    }\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << A_odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int MAX = 1000100;\n\nvector<int> list;\nvector<int> odd;\n\nvoid init()\n{\n\tfor(int i=1;;i++)\n\t{\n\t\tint num = i*(i+1)*(i+2)/6;\n\t\tif(num > MAX){ break; }\n\t\tlist.push_back(num);\n\t\tif(num % 2){ odd.push_back(num); }\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\tinit();\n\t\n\tvector<int> dp(MAX,MAX);\n\tvector<int> odd_dp(MAX,MAX);\n\t\n\tdp[0] = 0;\n\todd_dp[0] = 0;\n\n\trep(i,list.size()){\n\t\tREP(j,list[i],MAX){\n\t\t\tdp[j] = min(dp[j], dp[j - list[i]] + 1);\t\n\t\t}\n\t}\n\n\trep(i,odd.size()){\n\t\tREP(j,odd[i],MAX){\n\t\t\todd_dp[j] = min(odd_dp[j], odd_dp[j - odd[i]] + 1);\t\n\t\t}\n\t}\n\t\n\tint N;\n\twhile(cin >> N && N){\n\t\tcout << dp[N] << \" \" << odd_dp[N] << endl;\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int INF = 1e9;\n\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define ALL( a )        (a).begin(), (a).end()             \n\nconst int L = 1000001;\n\n// iを作るのに必要な正四面体数\nint dp[L] = {};\nint odp[L] = {};\n// 正四面体数: 1 4 10 20 35 ...\nint x[L] = {};\nint ox[L] = {};\n\nint main() {\n\n\tint xsize = 0, oxsize = 0;\n\tfor( int i = 1; i * ( i + 1 ) * ( i + 2 ) / 6 <= L; i++ ) {\n\t\tx[i] = i * ( i + 1 ) * ( i + 2 ) / 6;\n\t\txsize++;\n\t\tif( x[i] % 2 == 1 ) {\n\t\t\tox[oxsize++] = x[i];\n\t\t}\n\t}\n\n\tREP( i, L ) dp[i] = odp[i] = i;\n\n\tREP( i, L ) {\n\t\tREP( j, xsize ) {\n\t\t\tif( i < x[j] ) break;\n\t\t\tdp[i] = min( dp[i - x[j]] + 1, dp[i] );\n\t\t}\n\t\tREP( j, oxsize ) {\n\t\t\tif( i < ox[j] ) break;\n\t\t\todp[i] = min( odp[i - ox[j]] + 1, odp[i] );\n\t\t}\n\t}\n\n\tint n;\n\twhile( cin >> n, n ) {\n\t\tcout << dp[n] << \" \" << odp[n] <<  endl;\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 1000000\n#define INFINITY 2000000000\nusing namespace std;\nint dp[200][N],data[N];\nvector<int> data2;\nint DP(int);\nint DP2(int);\nint main(){\n  int i,out,out2,n,c;\n  data2.push_back(0);\n  for(i=1;i<N;i++){\n    data[i]=i*(i+1)*(i+2)/6;\n    if(data[i]>N){\n      c=i;\n    }\n    if(data[i]%2==1){\n      data2.push_back(data[i]);\n    }\n  }\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    out=DP(n);\n    out2=DP2(n);\n    cout << out << ' ' << out2 << endl;\n  }\n  return 0;\n}\nint DP(int n){\n  int i,j,minret,s;\n  for(i=1;i<N;i++){\n    if(data[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}\nint DP2(int n){\n  int i,j,minret,s,len;\n  len=data2.size();\n  for(i=1;i<len;i++){\n    if(data2[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data2[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data2[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\n\tint n = 1000000;\n\n\tvector<int> a(200);\n\tvector<int> b(200);\n\n\tint nn, nnb;\n\tint ii = 1;\n\tint jj = 1;\n\twhile (1) {\n\t\ta[ii] = ii * (ii + 1) * (ii + 2) / 6;\n\t\tif (a[ii] % 2 == 1) {\n\t\t\tb[jj] = a[ii];\n\t\t\tjj++;\n\t\t}\n\t\tif (a[ii] > n) {\n\t\t\tnn = ii;\n\t\t\tnnb = jj;\n\t\t\tbreak;\n\t\t}\n\t\tii++;\n\t}\n\n\t//ｎを作る時の最小数\n\tvector<int> dp(1000010, 1000010);\n\tvector<int> dpb(1000010, 1000010);\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdpb[0] = 0;\n\tdpb[1] = 1;\n\n\tfor (int j = 1; j <= nn; j++) {\n\t\tfor (int i = a[j]; i <= n; i++) {\n\t\t\tdp[i] = min(dp[i], dp[i - a[j]] + 1);\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= nnb; j++) {\n\t\tfor (int i = b[j]; i <= n; i++) {\n\t\t\tdpb[i] = min(dpb[i], dpb[i - b[j]] + 1);\n\t\t}\n\t}\n\n\n\twhile (1) {\n\n\t\tcin >> n;\n\t\tif (n == 0) { return 0; }\n\t\tcout << dp[n] << \" \" << dpb[n] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint a[201];\nint dp1[1000001],dp2[1000001];\nint main(){\n    FOR(i,1,201){\n        a[i-1]=i*(i+1)*(i+2)/6;\n    }\n    int n;\n    while(cin>>n,n){\n        rep(i,n+1) dp1[i]=dp2[i]=1000100010;\n        dp1[n]=0,dp2[n]=0;\n        rep(i,200)for(int j=n;j>=0;--j){\n            if(j>=a[199-i]) dp1[j-a[199-i]]=min(dp1[j-a[199-i]],dp1[j]+1);\n            if(j>=a[199-i]&&a[199-i]%2==1) dp2[j-a[199-i]]=min(dp2[j-a[199-i]],dp2[j]+1);\n        }\n        cout<<dp1[0]<<\" \"<<dp2[0]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define ALL( a )        (a).begin(), (a).end()             \n\nconst int MAX = 1000000;\n\nint\tdp[MAX] = {};\nint oddp[MAX];\n\nint main() {\n\tREP( i, MAX ) dp[i] = oddp[i] = i;\n\n\tint i = 2, x = 4;\n\twhile( x < MAX ) {\n\t\tfor( int j = 0; j + x < MAX; j++ ) {\n\t\t\tdp[j + x] = min( dp[j + x], dp[j] + 1 );\n\t\t\tif( x % 2 == 1 ) {\n\t\t\t\toddp[j + x] = min( oddp[j + x], oddp[j] + 1 );\n\t\t\t}\n\n//\t\t\tif( j + x > ( i + 8 ) * ( i + 9 ) * ( i + 10 ) / 2 ) break;\n\t\t}\n\t\ti++;\n\t\tx = i * ( i + 1 ) * ( i + 2 ) / 6;\n\t}\n\n\n\tint n;\n\twhile( 1 ) {\n\t\tcin >> n; if( n == 0 ) break;\n\t\tcout << dp[n] << \" \" << oddp[n] << endl;\n\t}\n\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define reps(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint dp[1000000] = {};\nint dp_o[1000000] = {};\nvector<int>n, n_o;\nint DP(int num) {\n\tif (dp[num] != 0)return dp[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP(n[cnt]) + DP(num - n[cnt]), rec);\n\t\tcnt++;\n\t\tif (n[cnt] > num)break;\n\t}\n\tdp[num] = rec;\n\treturn rec;\n\n}\nint DP_o(int num) {\n\tif (dp_o[num] != 0)return dp_o[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP_o(n_o[cnt]) + DP_o(num - n_o[cnt]), rec);\n\t\tcnt++;\n\t\tif (n_o[cnt] > num)break;\n\t}\n\tdp_o[num] = rec;\n\treturn rec;\n\n}\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tll cnt1 = 0, cnt2 = 0;\n\treps(i, 1, 1000000) {\n\t\tcnt1 += i;\n\t\tcnt2 += cnt1;\n\t\tif (cnt2 >= 1000000)break;\n\t\tdp[cnt2] = 1;\n\t\tn.push_back(cnt2);\n\t\tif (cnt2 % 2 == 1) {\n\t\t\tdp_o[cnt2] = 1;\n\t\t\tn_o.push_back(cnt2);\n\t\t}\n\t}\n\twhile (1) {\n\t\tint Q;\n\t\tcin >> Q;\n\t\tif (Q == 0)break;\n\t\tcout << DP(Q) << \" \";\n\t\tcout << DP_o(Q) << endl;\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pii;\n// #define int ll\n#define fi first\n#define se second\n#define SORT(a) sort(a.begin(),a.end())\n#define rep(i,n) for(int i = 0;i < (n) ; i++) \n#define REP(i,n) for(int i = 0;i < (n) ; i++) \n#define MP(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define INF LLONG_MAX/2\n#define INTINF INT_MAX/2\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define debug_vec(v) cerr<<#v<<\":\";rep(i,v.size())cerr<<\" \"<<v[i];cerr<<endl\ntemplate<class T>\ninline bool chmax(T &a, T b){\n\tif(a < b){\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T>\ninline bool chmin(T &a, T b){\n\tif(a > b){\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n/*----------------------------------------------------------------*/\n\n// int MOD = 998244353;\nint MOD = 1000000007;\nconst int M = 1000000;\nvector<int> dp(M+10);\nvector<int> dpodd(M+10);\nvector<int> num;\nvector<int> numodd;\n/*----------------------------------------------------------------*/\nsigned main(){\n\n\tfor(int i = 1;;i++){\n\t\tint x = i*(i+1)*(i+2)/6;\n\t\tif(x > M)break;\n\t\tnum.pb(x);\n\t\tif(x%2 == 1)numodd.pb(x);\n\t}\n\trep(i,M)dp[i+1] = dpodd[i+1] = INTINF;\n\trep(i,M){\n\t\tfor(auto x:num){\n\t\t\tif(i+x > M)break;\n\t\t\tchmin(dp[i+x],dp[i]+1);\n\t\t}\n\t\tfor(auto x:numodd){\n\t\t\tif(i+x > M)break;\n\t\t\tchmin(dpodd[i+x],dpodd[i]+1);\n\t\t}\n\t}\n\t\n    while(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0)return 0;\n\t\tcout << dp[n] << \" \" << dpodd[n] << endl;\n\t}\n\n\treturn 0;\n}\n/*----------------------------------------------------------------*/\n\n// g++ -std=c++14 code1.cpp\n// sudo pip3 install --upgrade online-judge-tools\n// rm -r -f test;oj dl https://code-festival-2018-quala.contest.atcoder.jp/tasks/code_festival_2018_quala_c\n// rm -r -f test;oj dl https://pakencamp-2019-day3.contest.atcoder.jp/tasks/pakencamp_2019_day3_c\n// rm -r -f test;oj dl https://pakencamp-2019-day3.contest.atcoder.jp/tasks/pakencamp_2019_day3_d\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n;\n\tint i1,i2;\n\tint nn;\n\tint p;\n\tint min;\n\tint num;\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\n\t\tvector<int> pollock(n+1,0);\n\t\tvector<int> pollock2(n+1,0);\n\t\tvector<int> p;\n\t\tvector<int> p2;\n\t\tnn=1;\n\t\tnum=(nn*(nn+1)*(nn+2))/6);\n\n\t\tfor(i1=1;i1<=n;i1++){\t\t\t\n\n\t\t\tif(i1==num) {\n\t\t\t\tif(i1%2==1){\n\t\t\t\t\tp.push_back(i1);\n\t\t\t\t\tp2.push_back(i1);\n\t\t\t\t\tnn++;\n\t\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6);\n\t\t\t\t\tpollock[i1]=1;\n\t\t\t\t\tpollock2[i1]=1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnn++;\n\t\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6);\n\t\t\t\t\tp.push_back(i1);\n\t\t\t\t\tpollock[i1]=1;\n\t\t\t\t\tmin=100000;\n\t\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpollock2[i1]=min+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p.size();i2++){\n\t\t\t\t\tif((pollock[i1-p[i2]])<min){\n\t\t\t\t\t\tmin=pollock[i1-p[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock[i1]=min+1;\n\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock2[i1]=min+1;\n\t\t\t}\n\t\t\t//cout<<pollock[i1]<<\" \";\n\n\t\t}\n\n\t\tcout << pollock[n] << \" \" << pollock2[n] << endl;\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint tetrahedral_number (int n)\n{\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\nint vector_sum (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i];\n    }\n\n    return num;\n}\n\nstd::vector<int>* approx_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    while (tmp_n != 0)\n    {\n\n        int i = 0;\n\n        while (i++, tetrahedral_number (i + 1) <= tmp_n);\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (i);\n        }\n\n        (*solution)[i-1] = (*solution)[i-1] + 1;\n\n        tmp_n = tmp_n - tetrahedral_number (i);\n\n    }\n\n    return solution;\n}\n\nstd::vector<int>* approx_odd_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    while (tmp_n != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= tmp_n; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (cnt);\n        }\n\n        (*solution)[cnt-1] = (*solution)[cnt-1] + 1;\n\n        tmp_n = tmp_n - tetrahedral_number (odd_i);\n\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* odd_branch_and_bound (std::vector<int>* base, int n)\n{\n\n    int upper_b = vector_sum (base);\n\n    int v_dim = base->size ();\n\n    auto tetra_indices = new std::vector<int> (v_dim);\n\n    int n_copy = n;\n\n    while (n_copy != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= n_copy; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n\n        (*tetra_indices)[cnt-1] = odd_i;\n\n        int tetra_num = tetrahedral_number (odd_i);\n\n        while (n_copy >= tetra_num)\n        {\n            n_copy = n_copy - tetra_num;\n        }\n\n    }\n\n    auto f = [&](int upper_bound, int upper_index) -> std::vector<int>*\n    {\n        int cnt = 1;\n\n\n        std::vector<int>* target = new std::vector<int> (upper_index);\n\n        (*target)[upper_index-1] = 1;\n\n        int tmp_n = n - tetrahedral_number ((*tetra_indices)[upper_index-1]);\n\n        while (tmp_n != 0)\n        {\n\n            int i = 0;\n\n            while (i++, tetrahedral_number ((*tetra_indices)[i]) <= tmp_n && i < upper_index);\n\n            \n            (*target)[i-1] = (*target)[i-1] + 1;\n\n            cnt++;\n\n            if (cnt >= upper_bound)\n            {\n                return NULL;\n            }\n\n            tmp_n = tmp_n - tetrahedral_number ((*tetra_indices)[i-1]);\n\n        }\n\n\n        return target;\n    };\n\n    std::vector<int>* solution = base;\n\n    for (int i = solution->size () - 1; i > 0; i--)\n    {\n\n\n        auto vec = f (vector_sum (solution), i);\n\n\n        if (vec !=NULL)\n        {\n            solution = vec;\n        }\n\n    }\n\n\n    return solution;\n}\n\n\nstd::vector<int>* branch_and_bound (std::vector<int>* base, int n)\n{\n\n    int upper_b = vector_sum (base);\n\n    auto f = [](std::vector<int>* base, int n, int index) -> std::vector<int>*\n    {\n        int cnt = 1;\n\n        int upper_cnt = vector_sum (base);\n\n        std::vector<int>* solution = new std::vector<int> (index);\n\n        (*solution)[index-1] = 1;\n\n        int tmp_n = n - tetrahedral_number (index);\n\n        while (tmp_n != 0)\n        {\n\n            int i = 0;\n\n            while (i++, tetrahedral_number (i + 1) <= tmp_n && i <= index);\n\n            \n            (*solution)[i-1] = (*solution)[i-1] + 1;\n\n            cnt++;\n\n            if (cnt >= upper_cnt)\n            {\n                return NULL;\n            }\n\n            tmp_n = tmp_n - tetrahedral_number (i);\n\n        }\n\n\n        return solution;\n    };\n\n    std::vector<int>* solution = base;\n\n    for (int i = solution->size () - 1; i > 0; i--)\n    {\n\n\n        auto vec = f (solution, n, i);\n\n\n        if (vec !=NULL)\n        {\n            solution = vec;\n        }\n\n    }\n\n\n\n    return solution;\n}\n\nint main ()\n{\n\n    int n = 0;\n    while (std::cin >> n, n != 0)\n    {\n\n        auto b = approx_least_number_by_tetrahedral (n);\n\n        auto s = branch_and_bound(b,n);\n        \n        int normal = vector_sum (s);\n\n        auto ob = approx_odd_least_number_by_tetrahedral (n);\n\n        auto os = odd_branch_and_bound (ob, n);\n\n        int odd =vector_sum (os);\n\n        std::cout << normal << \" \" << odd <<  std::endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n#define max_n 1000000\n\nint main(void) {\n    int i,j;\n\n    vi tetra;\n    i = 1;\n    while(1){\n        int t = i * (i+1) * (i+2) / 6;\n        if(t > max_n) break;\n        tetra.push_back(t);\n        i++;\n    }\n\n    int dp[max_n][2];\n\n    rep(i,max_n)\n        dp[i][0] = dp[i][1] = i;\n\n    rep(i,tetra.size()) rep(j,max_n - tetra[i]){\n        dp[j+tetra[i]][0] = min(dp[j+tetra[i]][0], dp[j][0] + 1);\n        if(tetra[i] % 2)\n            dp[j+tetra[i]][1] = min(dp[j+tetra[i]][1], dp[j][1] + 1);\n    }\n\n    int n;\n    while(cin >> n, n){\n            cout << dp[n][0] << \" \" << dp[n][1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\n// x未満の要素の個数を返す\ntemplate <typename T>\ni64 count_less(const vector<T>& v, T x) {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n}\n\n// x以下の要素の個数を返す\ntemplate <typename T>\ni64 count_less_or_equal(const vector<T>& v, T x) {\n    return upper_bound(begin(v), end(v), x) - begin(v);\n}\n\n// xより大きい要素の個数を返す\ntemplate <typename T>\ni64 count_greater(const vector<T>& v, T x) {\n    return end(v) - upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素の個数を返す\ntemplate <typename T>\ni64 count_greater_or_equal(const vector<T>& v, T x) {\n    return end(v) - lower_bound(begin(v), end(v), x);\n}\n\n// x未満の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less(const vector<T>& v, T x) {\n    return *(lower_bound(begin(v), end(v), x) - 1);\n}\n\n// x以下の要素のうち最大のものを返す\ntemplate <typename T>\nT max_less_or_equal(const vector<T>& v, T x) {\n    return *(upper_bound(begin(v), end(v), x) - 1);\n}\n\n// xより大きい要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater(const vector<T>& v, T x) {\n    return *upper_bound(begin(v), end(v), x);\n}\n\n// x以上の要素のうち最小のものを返す\ntemplate <typename T>\nT min_greater_or_equal(const vector<T>& v, T x) {\n    return *lower_bound(begin(v), end(v), x);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// 実数値のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない)\nconstexpr i64 max_loop = 100;\n\nlong double tolerance(const long double& a, const long double& b, const long double& epsilon = eps) {\n    return epsilon * max({1.l, abs(a), abs(b)});\n}\n\n// a<0なら-1, a==0なら0, a>0なら1\nint sgn(const long double a, const long double& epsilon = eps) {\n    return (a > epsilon) - (a < -epsilon);\n}\n\n// a<bなら-1, a==bなら0, a>bなら1\nint compare(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return sgn(a - b, is_relative ? tolerance(a, b, epsilon) : epsilon);\n}\n\n// a==bか?\nbool is_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 0;\n}\n\n// a<bか?\nbool is_less(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == -1;\n}\n\n// a<=bか?\nbool is_less_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) <= 0;\n}\n\n// a>bか?\nbool is_greater(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) == 1;\n}\n\n// a>=bか?\nbool is_greater_or_equal(const long double& a, const long double& b, const long double& epsilon = eps, bool is_relative = true) {\n    return compare(a, b, epsilon, is_relative) >= 0;\n}\n\nvoid solve(i64 s) {\n    //constexpr i64 mod = 1'000'000'007;\n\n    vector<i64> odd,even;\n    rep(i,1,inf64){\n        i64 n=i*(i+1)*(i+2)/6;\n        if(n>s) break;\n        if(n%2==1) odd.emplace_back(n);\n        else even.emplace_back(n);\n    }\n\n    vector<i64> dp(s+1,inf64);\n    dp[0]=0;\n\n    rep(i,0,odd.size()){\n        rep(j,odd[i],s+1){\n            dp[j]=min(dp[j],dp[j-odd[i]]+1);\n        }\n    }\n\n    const i64 ans2=dp[s];\n\n    rep(i,0,even.size()){\n        rep(j,even[i],s+1){\n            dp[j]=min(dp[j],dp[j-even[i]]+1);\n        }\n    }\n\n    const i64 ans1=dp[s];\n\n    cout << ans1 << \" \" << ans2 << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    while(true){\n        i64 s;\n        cin >> s;\n        if(s==0) break;\n        solve(s);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\t\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nDef inf = sizeof(Def) == sizeof(ll) ? 2e18 : 1e9+10;\nint main(){\n\tvi w;\n\tloop(i,1,200)if(i*(i+1)*(i+2)/6<1000100)w.pb(i*(i+1)*(i+2)/6);\n\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi dp(n+1,inf),dp2(n+1,inf);\n\t\tdp[0]=dp2[0]=0;\n\t\trep(i,w.size())rep(j,n){\n\t\t\tint t=j+w[i];\n\t\t\tif(t<n+1)dp[t]=min(dp[t],dp[j]+1);\n\t\t\tif(t<n+1&&w[i]%2)dp2[t]=min(dp2[t],dp2[j]+1);\n\t\t}\n\t\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\ntypedef pair<int,int> P;\n\nvector<P> p;\n\nvoid make_pollock (void )\n{\n\tfor (int i = 1; i <= 85; i++ ){\n\t\tll ans = (ll)i*(i+1LL)*(i+2LL)/6LL;\n\t\tp.push_back (P ((int)ans, i )  );\n\t} // end rep\n}\n\nint main()\n{\n\tp.clear();\n\tmake_pollock();\n\n\tint n;\n\twhile (cin >> n && n ){\n\t\tP res = P(0, 0 );\n\t\tvector <int> dp1 (n+1, INF ), dp2 (n+1, INF );\n\t\tdp1[0] = 0;\n\t\tfor (int i = 0; i < p.size(); i++ ){\n\t\t\tint m = p[i].first;\n\t\t\tfor (int j = m; j <= n; j++ ){\n\t\t\t\tif (dp1[j] > dp1[j - m] + 1 ){\n\t\t\t\t\tdp1[j] = dp1[j - m] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\tres.first = dp1[n];\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < p.size(); i++ ){\n\t\t\tif (p[i].first % 2 == 0 ) continue;\n\t\t\tint m = p[i].first;\n\t\t\tfor (int j = m; j <= n; j++ ){\n\t\t\t\tif (dp2[j] > dp2[j - m] + 1 ){\n\t\t\t\t\tdp2[j] = dp2[j - m] + 1;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\tres.second = dp2[n];\t\n\n\t\tcout << res.first << ' ' << res.second << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\nusing namespace std;\n\n#define M 1000000\n\nint odd[M + 10], all[M + 10];\n\nvoid update(int *a, int x){\n    for(int i = x; i <= M; ++i){\n        a[i] = min(a[i], a[i - x] + 1);\n    }\n}\n\nint main(){\n    for(int i = 1; i <= M; ++i){\n        odd[i] = all[i] = 10000000;\n    }\n\n    for(int i = 1; ; ++i){\n        int x = i * (i + 1) * (i + 2) / 6;\n        if(x > M){ break; }\n        update(all, x);\n        if(x % 2){ update(odd, x); }\n    }\n\n    int n;\n    while(cin>>n, n){\n        printf(\"%d %d\\n\", all[n], odd[n]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n \nusing namespace std;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define foreach(c, it) for(typeof(c) it = (c).begin(); it != (c).end(); it++)\n \ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n \nconst int MAX = 1000000;\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n \nint p[4 * MAX + 1], op[4  *MAX + 1];\nvector < int > num;\nint main() {\n     \n    for(int i = 0; i < 2 + MAX + 1; i++)\n        p[i] = op[i] = INF;\n     \n    for(int i = 1; i < 200; i++) {\n        num.push_back(i * (i + 1) * (i + 2) / 6);\n        p[i * (i + 1) * (i + 2) / 6] = 1;\n        if((i * (i + 1) * (i + 2) / 6) % 2) op[i * (i + 1) * (i + 2) / 6] = 1;\n    }\n \n    for(int i = 1; i <= MAX; i++) {\n        for(int j = 0; j <num.size(); j++) {\n            if(p[i] != INF) {\n                p[i + num[j]] = min(p[i] + 1, p[i + num[j]]);\n            }\n            if(op[i]  != INF && num[j] % 2) {\n                op[i + num[j]] = min(op[i] + 1, op[i + num[j]]);\n            }\n        }\n    }\n     \n    int N;\n    while(cin >> N, N) {\n        cout << p[N] << \" \" << op[N] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint e[1048576],o[1048576];\nint main(void)\n{\n  REP(i,1048576) e[i]=1048576;\n  REP(i,1048576) o[i]=1048576;\n  e[0]=0;\n  o[0]=0;\n  REP(i,1024){\n    int gap=i*(i+1)*(i+2)/6;\n    for(int j=0;j+gap<1048576;++j) e[j+gap]=min(e[j+gap],e[j]+1);\n    if(gap%2==1) for(int j=0;j+gap<1048576;++j) o[j+gap]=min(o[j+gap],o[j]+1);\n  }    \n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    cout << e[n] << ' ' << o[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[60]={0},c[200001]={0,1,2,3},d[200001],k=0,i,j,n;\n  for(i=1;i<100;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<99;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tint v[200];\n\tstatic int ansA[1000000], ansB[1000000];\n\tfor (int i = 0; i<=200; i++) v[i] = i * (i + 1)*(i + 2) / 6;\n\tansA[0] = ansB[0] = 0;\n\tfor (int i = 1; i<1000000; i++) {\n\t\tansA[i] = ansB[i] = i;\n\t\tfor (int j = 0; i - v[j] >= 0; j++) {\n\t\t\tansA[i] = min(ansA[i], ansA[i - v[j]] + 1);\n\t\t\tif (v[j] % 2 == 1)\n\t\t\t\tansB[i] = min(ansB[i], ansB[i - v[j]] + 1);\n\t\t}\n\t}\n\twhile (cin >> N, N)\n\t\tcout << ansA[N] << \" \" << ansB[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int>data[2];\nint mins;\n\nint check(int i,int sum,int cnt,int tar)\n{\n  if(sum==0)\n    {\n      if(cnt<mins)\n        mins=cnt;\n      return mins;\n    }\n  if(sum<0 || i<0 || cnt>=mins)\n    return mins;\n  check(i,sum-data[tar][i],cnt+1,tar);\n  check(i-1,sum,cnt,tar);\n  return mins;\n}\n\nvoid set()\n{\n  int sum=0;\n  int num=0;\n  for(int i=1;sum<=1000000;i++)\n    {\n      num=i+num;\n      sum+=num;\n      data[0].push_back(sum);\n      if(sum%2==1)\n        data[1].push_back(sum);\n    }\n}\n\n\nint main()\n{\n  set();\n  int n;\n  for(;cin>>n,n;)\n    {\n      int a,b;\n      mins=99999999;\n      a=check(data[0].size()-1,n,0,0);\n      mins=99999999;\n      b=check(data[1].size()-1,n,0,1);\n\n      cout<<a<<\" \"<<b<<endl;\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nll dp[1000001],dpo[1000001];\n\nconst ll MAX=LONG_MAX/10;\n\nll pol(ll n){\n\treturn n*(n+1)*(n+2)/6;\n}\n\nll dfs(ll n,bool odd,int size){\n\tll (&dpp)[1000001]=(odd?dpo:dp);\n\tif(dpp[n]!=MAX){\n\t\treturn dpp[n];\n\t}\n\tif(n==0){\n\t\treturn 0;\n\t}\n\tif(size>100){\n\t\treturn MAX;\n\t}\n\tll ret=MAX;\n\tfor(ll j=1,i=pol(j);i<=n;j++,i=pol(j)){\n\t\tif(odd&&(!(i&1)))continue;\n\t\tret=min(ret,dfs(n-i,odd,size+1)+1);\n\t}\n\treturn dpp[n]=ret;\n}\n\nint main(){\n\tll n;\n\tREP(i,1000001){\n\t\tdp[i]=MAX;\n\t}\n\tREP(i,1000001){\n\t\tdpo[i]=MAX;\n\t}\n\twhile(cin>>n,n){\n\t\tcout<<dfs(n,false,0);\n\t\tcout<<\" \"<<dfs(n,true,0)<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvi llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\n\nint beam_width=20;\n\nint bfs(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n        }\n        if(i<target){\n            q.pb(i);\n            mm=i;\n        }\n        if(i>target) break;\n    }\n    //auto mm=*max_element(beginend(q));\n    int cnt=0;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(llist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,llist){\n                if(k+x>target) break;\n                // if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.pb(k+x);\n            }\n\n            \n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) {q.pb(i);mm=i;}\n        if(i>target) break;\n    }\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    //out(mm);\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(oddlist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                //if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.pb(k+x);\n            }\n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    int mm=0;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n        mm=max(mm,n);\n    }\n    map<int,pii> m;\n    makeList(mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        //int ans2=0;\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconstexpr int LIMIT = 1000000;\nint dp1[LIMIT], dp2[LIMIT];\n\nvoid solve() {\n  std::fill(dp1, dp1 + LIMIT, 100);\n  std::fill(dp2, dp2 + LIMIT, 100);\n  dp1[0] = dp2[0] = 0;\n  for (int n = 1; n < 200; ++n) {\n    int const tet = n * (n + 1) * (n + 2) / 6;\n    for (int i = 0; i + tet < LIMIT; ++i) {\n      dp1[i + tet] = std::min(dp1[i + tet], dp1[i] + 1);\n      if (tet % 2) {\n        dp2[i + tet] = std::min(dp2[i + tet], dp2[i] + 1);\n      }\n    }\n  }\n}\n\nint main() {\n  solve();\n  int N;\n  while (std::cin >> N && N) {\n    std::cout << dp1[N] << \" \" << dp2[N] << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 1111111\n#define INF 1<<28\nusing namespace std;\n\nint data[M];\nint memo[M], memo2[M];\n\nint solve(int n){\n\n  if(!n) return 0;\n  if(n < 0) return INF;\n  if(~memo[n]) return memo[n];\n  \n  int ret = INF;\n  for(int i=1;data[i]<=n;i++) ret = min(ret, solve(n-data[i])+1);\n\n  return memo[n] = ret;\n}\n\nint solve2(int n){\n\n  if(!n) return 0;\n  if(n < 0) return INF;\n  if(~memo2[n]) return memo2[n];\n  \n  int ret = INF;\n  for(int i=1;data[i]<=n;i+=2)\n    if(data[i]&1) ret = min(ret, solve2(n-data[i])+1);\n\n  return memo2[n] = ret;\n}\n\nint main(){\n\n  for(int i=0;i<M;i++) data[i] = (i*(i+1)*(i+2))/6;\n  \n  int n;\n\n  while(cin >> n, n){\n\n    memset(memo, -1, sizeof(memo));\n    memset(memo2, -1, sizeof(memo2));\n    \n    cout << solve(n) << \" \" << solve2(n) << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF 1 << 28\n\nint t[500];\nint odd_t[500];\nint ns[1000001];\nint odd_ns[1000001];\n\nint count_t(int n) {\n\tif (ns[n] != 0) return ns[n];\n\tif (binary_search(t, t+500, n)) return 1;\n\tns[n] = INF;\n\tfor (int i = 0; n-t[i] >= 0; i++) {\n\t\tns[n] = min(ns[n], count_t(n-t[i])+1);\n\t}\n\treturn ns[n];\n}\n\nint count_odd_t(int n) {\n\tif (odd_ns[n] != 0) return odd_ns[n];\n\tif (binary_search(odd_t, odd_t+100, n)) return 1;\n\todd_ns[n] = INF;\n\tfor (int i = 0; n-odd_t[i] >= 0; i++) {\n\t\todd_ns[n] = min(odd_ns[n], count_odd_t(n-odd_t[i])+1);\n\t}\n\treturn odd_ns[n];\n}\n\nint main() {\n\tmemset(ns, 0, sizeof(ns));\n\tmemset(odd_ns, 0, sizeof(odd_ns));\n\n\tint odd_pos = 0;\n\tfor (int i = 0; i < 500; i++) {\n\t   \tt[i] = (i+1)*(i+2)*(i+3) / 6;\n\t\tif (t[i] % 2 == 1) odd_t[odd_pos++] = t[i];\n\t}\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << count_t(n) << ' ' << count_odd_t(n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nconst int N=1e6;\nint dp[1000010];\nint dp2[1000010];\nint move[200];\nint main(){\n\tfor(int i=0;i<1000010;i++)\tdp[i]=dp2[i]=i;\n\tfor(int i=2;;i++){\n\t\tint add=i*(i+1)*(i+2)/6;\n\t\tif(add>N)\tbreak;\n\t\tfor(int j=add;j<=N;j++)\tdp[j]=min(dp[j],dp[j-add]+1);\n\t\tif(add&1)\tfor(int j=add;j<=N;j++){\n\t\t\tdp2[j]=min(dp2[j],dp2[j-add]+1);\n\t\t}\n\t}\n\twhile(true){\n\t\tint n;\tcin>>n;\n\t\tif(n==0)\tbreak;\n\t\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n  int i,ki[1000001],all[1000001],n[200],a;\n  for(i=0;;i++){\n    n[i]=i*(i+1)*(i+2)/6;\n    if(n[i]>1000000)break;\n  }\n  for(int j=0;j<=1000000;j++){\n    ki[j]=j;\n    all[j]=j;\n  }\n  for(int j=2 ; j<i ; j++){\n    for(int k=n[j];k<=1000000;k++){\n      all[k]=min(all[k],all[k-n[j]]+1);\n      if(n[j]%2==1){\n      ki [k]=min(ki [k],ki[k-n[j]]+1);\n      }\n    }\n  }\n  while(1){\n    cin>>a;\n    if(a==0)break;\n    cout<<all[a]<<\" \"<<ki[a]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n\ntypedef long long ll;\n\n#define N 1000000\n\nint x[1000001]={} , y[1000001]={};\n\nint main(void) {\n    vector<int> a,b;\n    int i=1;\n    while (i*(i+1)*(i+2)/6<=N){\n        int f = i*(i+1)*(i+2)/6;\n        a.push_back(f);\n        if (f%2==1)\n            b.push_back(f);\n        i++;\n    }\n    int n = a.size() , m = b.size();\n    FOR(i,1,N){\n        x[i] = N;\n        y[i] = N;\n    }\n    FOR(i,0,N-1){\n        REP(j,n){\n            if (i+a[j]>N)\n                break;\n            x[i+a[j]] = min(x[i+a[j]],x[i]+1);\n        }\n        REP(j,m){\n            if (i+b[j]>N)\n                break;\n            y[i+b[j]] = min(y[i+b[j]],y[i]+1);\n        }\n    }\n    while (cin >> n && n){\n        cout << x[n] << \" \" << y[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#define N 1000000\n\nusing namespace std;\n\nint main(){\n\tvector<int> sq;\n\tvector<int> sqodd;\n\tint a[N];\n\tint aodd[N];\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++)  sq.push_back((i * (i + 1) * (i + 2)) / 6);\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++){\n\t\tif(((i * (i + 1) * (i + 2)) / 6) % 2) sqodd.push_back((i * (i + 1) * (i + 2)) / 6);\n\t}\n\tfor(int i = 0; i < N; i++) a[i] = N;\n\tfor(int i = 0; i < N; i++) aodd[i] = N;\n\tfor(int i = 0; i < sq.size(); i++) a[sq[i]] = 1;\n\tfor(int i = 0; i < sqodd.size(); i++) aodd[sqodd[i]] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tif(a[i] == N) continue;\n\t\tfor(int j = 0; j < sq.size(); j++){\n\t\t\tif(sq[j] + i < N && a[sq[j] + i] > a[i] + 1) a[sq[j] + i] = a[i] + 1;\n\t\t}\n\t}\n\tfor(int i = 1; i < N; i++){\n\t\tif(aodd[i] == N) continue;\n\t\tfor(int j = 0; j < sqodd.size(); j++){\n\t\t\tif(sqodd[j] + i < N && aodd[sqodd[j] + i] > aodd[i] + 1) aodd[sqodd[j] + i] = aodd[i] + 1;\n\t\t}\n\t}\t\n\tint n;\n\twhile(cin >> n, n) cout << a[n] << \" \" << aodd[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nstd::vector<int>t,o;\nconst int N=1000000,V=1<<9;\nint a[N],b[N];\nint main()\n{\n\tint i,j,n;\n\tfor(i=1;i<N;++i)a[i]=b[i]=V;\n\tfor(i=1;n=(i*(i+1)*(i+2))/6,n<N;++i)if(a[n]=1,t.push_back(n),n&1)b[n]=1,o.push_back(n);\n\tfor(i=t.size()-1;i>=0;--i)\n\t{\n\t\ta[t[i]]=1;\n\t\tfor(j=t[i];j+t[i]<N;++j)if(a[j]+1<a[j+t[i]])a[j+t[i]]=a[j]+1;\n\t}\n\tfor(i=o.size()-1;i>=0;--i)\n\t{\n\t\tb[o[i]]=1;\n\t\tfor(j=o[i];j+o[i]<N;++j)if(b[j]+1<b[j+o[i]])b[j+o[i]]=b[j]+1;\n\t}\n\twhile(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",a[n],b[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repd(i,a,b) for (int i=(a);i<(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntypedef long long ll;\nconst long long INF = 1LL << 60;\ntypedef pair<int, int> P;\nint main()\n{\n    vector<int> num(200), numodd;\n    rep(i, 200) {\n        num[i] = ((i + 1) * (i + 2) * (i + 3)) / 6;\n        if (num[i] % 2) numodd.push_back(num[i]);\n    }\n    int len = (int)numodd.size();\n\n    vector<int> dp1(1000001, 1e9);\n    vector<int> dp2(1000001, 1e9);\n    dp1[0] = 0;\n    dp2[0] = 0;\n\n    rep(i, 200) {\n        repd(j, num[i], 1000001) {\n            chmin(dp1[j], dp1[j - num[i]] + 1);\n        }\n    }\n\n    rep(i, len) {\n        repd(j, numodd[i], 1000001) {\n            chmin(dp2[j], dp2[j - numodd[i]] + 1);\n        }\n    }\n\n\n    while (1) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        cout << dp1[N] << \" \" << dp2[N] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef long double ld;\n#define MOD 998244353\ntemplate<class T>inline bool chmax(T& a,T b){if (a<b){a=b;return 1;}return 0;}\ntemplate<class T>inline bool chmin(T& a,T b){if (a>b){a=b;return 1;}return 0;}\nconst long long INF = 1LL << 60;\nbool pairCompare(const pair<double,ll>& firstElof, const pair<double,ll>& secondElof){\n    return firstElof.first < secondElof.first;\n}\nbool pairCompareSecond(const pair<double,ll>& firstElof, const pair<double,ll>& secondElof){\n    return firstElof.second < secondElof.second;\n}\n//四方向への移動ベクトル\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct edge{//グラフに使うヤツ\n    ll from,to,cost;\n};\n\ntypedef vector<vector<edge> > G;\nll gcd(ll a,ll b){\n    if (a%b==0)return(b);\n    else return(gcd(b,a%b));\n}\n\nint main() {\n    while (true){\n        ll n;\n        cin >> n;\n        if (n==0){\n            break;\n        }\n        ll dp[n+1],odddp[n+1];\n        fill(dp,dp+n+1,INF);\n        fill(odddp,odddp+n+1,INF);\n        dp[0]=odddp[0]=0;\n        for (ll i=1;;i++){\n            ll x=i*(i+1)*(i+2)/6;\n            if (x>n)break;\n            for (ll j=x;j<=n;j++){\n                dp[j]=min(dp[j],dp[j-x]+1);\n                if (x&1){\n                    odddp[j]=min(odddp[j],odddp[j-x]+1);\n                }\n            }\n        }\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\t//??£?????¢?????°??¨????????????????\\???°??????????????????????????¨??£??????????????¨???\n\tint sq[200]={0};\n\tint oddsq[200]={0};\n\t//???????????????index?????????\n\tint index=0;\n\tint indexODD=0;\n\t //dp???????????¨??????\n\tint INF=2000000;\n\t\n\tfor(int i=0; (i+1)*(i+2)*(i+3)/6<=1000000; ++i){\n\t\tsq[i]=(i+1)*(i+2)*(i+3)/6;\n\t\tif(sq[i]%2==1) oddsq[indexODD++]=sq[i];\t\n\t\t//printf(\"%3d :%7d\\n\",i, sq[i]);\n\t\tindex=i+1;\n\t}\n\t//printf(\"index= %d, inODD = %d\\n\", index, indexODD);\n\t\n\t//solve\n\twhile(1){\n\t\tint n;\n\t\tscanf(\" %d\", &n);\n\t\tif(n==0) break;\n\t\t\t\n\t\t//dp[i]:=??°i?????£?????¢?????°????????¨????????¨?????¨?????????????????£?????¢?????°?????°???????°????\n\t\t\n\t\tint dp[1000001];\n\t\tfill(dp,dp+n+1,INF);\n\t\tdp[0]=0;\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tfor(int j=0; j<index; ++j){\n\t\t\t\tif(i+sq[j]<=n) dp[i+sq[j]]=min(dp[i+sq[j]],dp[i]+1);\n\t\t\t\telse break;\t\n\t\t\t}\t\n\t\t}\n\t\tint ans1=dp[n];\n\t\t\n\t\t//?\\???°?????????????????????????????¨??????\n\t\tfill(dp,dp+n+1,INF);\n\t\tdp[0]=0;\n\t\t\n\t\tfor(int i=0; i<=n; ++i){\n\t\t\tfor(int j=0; j<indexODD; ++j){\n\t\t\t\tif(i+oddsq[j]<=n) dp[i+oddsq[j]]=min(dp[i+oddsq[j]],dp[i]+1);\n\t\t\t\telse break;\t\n\t\t\t}\t\n\t\t}\n\t\tint ans2=dp[n];\n\t\t\t\t\n\t\tprintf(\"%d %d\\n\", ans1, ans2);\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nP solve(int n, vector<int> &v, vector<int> &w, vector<int> &ma, vector<int> &mb){\n\tif(n == 0) return P(0, 0);\n\tif(ma[n] < 1e6) return P(ma[n], mb[n]);\n\tfor(size_t i=0; i<v.size(); ++i){\n\t\tif(v[i] > n) break;\n\t\tif(v[i] == n){\n\t\t\tma[n] = 1;\n\t\t\tbreak;\n\t\t}\n\t\tma[n] = min(ma[n], 1+solve(n-v[i], v, w, ma, mb).first);\n\t}\n\tfor(size_t i=0; i<w.size(); ++i){\n\t\tif(w[i] > n) break;\n\t\tif(w[i] == n){\n\t\t\tmb[n] = 1;\n\t\t\tbreak;\n\t\t}\n\t\tmb[n] = min(mb[n], 1+solve(n-w[i], v, w, ma, mb).second);\n\t}\n\treturn P(ma[n], mb[n]);\n}\n\nint main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\tconst int N = 1'000'000;\n\tvector<int> v, w, ma(N, N), mb(N, N);\n\tfor(int i=1; i<=1000; ++i){\n\t\tint t = i * (i+1) / 2 * (i+2) / 3;\n\t\tv.push_back(t);\n\t\tif(t % 2 == 1) w.push_back(t);\n\t}\n\tfor(int i=1; i<N; ++i) solve(i, v, w, ma, mb);\n//\tfor(size_t i=0; i<v.size(); ++i) cout << i << \" \" << v[i] << \"\\n\";\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(n == 0) break;\n\t\tcout << ma[n] << \" \" << mb[n] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 100010;\n\nvector<int> tetras;\nvector<int> oddTetras;\n\nint dp[MAX];\nint oddDp[MAX];\n\nint main() {\n\tfor (int i = 1; i < 200; i++) {\n\t\tint n = i * (i + 1) * (i + 2) / 6;\n\t\ttetras.push_back(n);\n\t\tif (n % 2 == 1)\n\t\t\toddTetras.push_back(n);\n\t}\n\n\tfor (int i = 0; i < MAX; i++) {\n\t\tdp[i] = oddDp[i] = i;\n\t}\n\tfor (int i = 1; i < MAX; i++) {\n\t\tfor (int j = 0; tetras[j] <= i; j++) {\n\t\t\tdp[i] = min(dp[i], dp[i - tetras[j]] + 1);\n\t\t}\n\t\tfor (int j = 0; oddTetras[j] <= i; j++) {\n\t\t\toddDp[i] = min(oddDp[i], oddDp[i - oddTetras[j]] + 1);\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n , n != 0) {\n\t\tcout << dp[n] << \" \" << oddDp[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nint N;\n\nint L[200];\nint M[200];\nint M_max;\n\nvoid init() {\n    for (int i = 1; i <= 200; i++) {\n        L[i - 1] = (i * (i + 1) * (i + 2)) / 6;\n    }\n\n    int j = 0;\n    for (int i = 0; i < 200; i++) {\n        if (L[i] % 2 == 1) {\n            M[j++] = L[i];\n        }\n    }\n    M_max = j;\n}\n\nint f(int nth, int s) {\n    int r = N - s;\n    int start = distance(L, upper_bound(L, L + 200, r)) - 1;\n\n    int m = 100;\n    for (int i = start; i >= 0 && r <= (5 - nth) * L[i]; i--) {\n        if (r == L[i]) {\n            return nth + 1;\n        }\n\n        m = min(m, f(nth + 1, s + L[i]));\n        break;\n    }\n\n    return m;\n}\n\nint g(int nth, int s) {\n    int r = N - s;\n    int start = distance(M, upper_bound(M, M + M_max, r)) - 1;\n\n    int m = 100;\n    for (int i = start; i >= 0; i--) {\n        if (r == M[i]) {\n            return nth + 1;\n        }\n\n        m = min(m, g(nth + 1, s + M[i]));\n        break;\n    }\n\n    return m;\n}\n\nvoid solve() {\n    printf(\"%d %d\\n\", f(0, 0), g(0, 0));\n}\n\nint main() {\n    init();\n    while (true) {\n        scanf(\"%d\", &N);\n        if (!N) {\n            break;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    vector<long long> polock;\n    vector<long long> oddpolock;\n    long long pol = 1;\n    polock.push_back(1);\n    oddpolock.push_back(1);\n    \n    for (int i=2; i<201; i++){\n        pol += i;\n        long long stack = polock.back() + pol;\n        polock.push_back(stack);\n        if (stack%2==1){\n            oddpolock.push_back(stack);\n        }\n    }\n    \n    long long INF = pow(10,18);\n    vector<long long> dp(pow(10,6), INF);\n    vector<long long> dp2(pow(10,6), INF);\n    dp[0] = 0;\n    dp2[0] = 0;\n    \n    for (int i=1; i < pow(10,6); i++){\n        for (int j = 0; j < polock.size(); j++){\n            if (polock[j] > i) break;\n            dp[i] = min(dp[i],dp[i-polock[j]] + 1);\n        }\n    }\n    \n    for (int i=1; i < pow(10,6); i++){\n        for (int j = 0; j < oddpolock.size(); j++){\n            if (oddpolock[j] > i) break;\n            dp2[i] = min(dp2[i],dp2[i-oddpolock[j]] + 1);\n        }\n    }\n    \n    int n;\n    cin >> n;\n    while (n!=0){\n        cout << dp[n] << ' ' << dp2[n] << endl;\n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nvi all, odd, v;\nint allt[1000005], oddt[1000005];\n\nint main()\n{\n\tv.push_back(0);\n\tFOR(i, 1, 1000) v.push_back(v[i - 1] + i);\n\tall.push_back(0);\n\tFOR(i,1, v.size())\n\t{\n\t\tall.push_back(all[i - 1] + v[i]);\n\t\tif (i & 1) odd.push_back(all[i - 1] + v[i]);\n\t\tif (all[i] > 1000000) break;\n\t}\n\tint n;\n\tfill(ALL(allt), INF); fill(ALL(oddt), INF);\n\tREP(i, 1000001)REP(j, all.size())\n\t{\n\t\tint t = i + all[j];\n\t\tif (t >= 1000001) break;\n\t\tallt[t] = min(allt[i] + 1, allt[t]);\n\t}\n\tREP(i, 1000001)REP(j, all.size())\n\t{\n\t\tint t = i + odd[j];\n\t\tif (t >= 1000001) break;\n\t\toddt[t] = min(oddt[i] + 1, oddt[t]);\n\t}\n\twhile (cin >> n, n) cout << allt[n] << \" \" << oddt[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;n[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)ki[j]=all[j]=j;\n  for(j=2;j<i;j++){\n    for(k=n[j];k<=1000000;k++){\n      b[k]=min(b[k],b[k-a[j]]+1);\n      if(n[j]%2){\n        c[k]=min(c[k],c[k-a[j]]+1);\n      }\n    }\n  }\nwhile(cin>>n,n){\ncout<<all[a]<<\" \"<<ki[a]<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    int lower,size,rest;\n    State(int lower,int size,int rest) : lower(lower),size(size),rest(rest) {};\n};\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<int> v;\n        vector<int> odd;\n        for(int i=1;;i++){\n            int c = i*(i+1)*(i+2)/6;\n            if(c > 1000000) break;\n            v.push_back(c);\n            if(c % 2 == 1) odd.push_back(c);\n        }\n        queue<State> que;\n        que.push(State(0,0,n));\n        int ret;\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                ret = s.size;\n                break;\n            }\n            for(int i=s.lower;v[i] <= s.rest;i++){\n                que.push(State(i,s.size+1,s.rest-v[i]));\n            }\n        }\n        int oret;\n        que = queue<State>();\n        que.push(State(0,0,n));\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                oret = s.size;\n                break;\n            }\n            for(int i=lower_bound(all(odd),s.rest)-odd.begin();\n                i>=0;i--){\n                que.push(State(i,s.size+1,s.rest-odd[i]));\n            }\n            //for(int i=s.lower;odd[i] <= s.rest;i++){\n        }\n        cout << ret << \" \" << oret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint list[100];\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100010;i++){\n\t\tlist[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tfor(i=1;i<=100010;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;list[j]<=i-1;j+=2)if(!dp2[i] || dp2[list[j]]+dp2[i-list[j]] < dp2[i]) dp2[i]=dp2[list[j]]+dp2[i-list[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;list[j]<=i-1;j++) if(!dp1[i] || dp1[list[j]]+dp1[i-list[j]] < dp1[i]) dp1[i]=dp1[list[j]]+dp1[i-list[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define rep(i,n) for(ll i=0;i<n;++i)\n#define ALL(a) (a).begin(),(a).end()\n \nusing namespace std;\nusing ll  = long long;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n \nconst ll MOD  = 1e9+7;\nconst ll LINF = 1LL << 60;\nconst int INF = 1e9 + 7;\n\nint main(){\n    vector<ll> rt, rt_odd;\n    rt.push_back(1);\n    rt_odd.push_back(1);\n\n    for(int i = 4; i <= 1000; ++i){\n        ll s = i * rt.back() / (i-3);\n        rt.push_back(s);\n    }\n\n    ll rt_len = rt.size();\n\n    //dp[i][0] : 正四面体数でiを作る最小値\n    //dp[i][1] : 奇数の正四面体数i作る最小値\n    vector<vector<ll>> dp(1000001, vector<ll>(2));\n    rep(i, 1000001){\n        dp[i][0] = INF;\n        dp[i][1] = INF;\n    }\n\n    dp[0][0] = 0;\n    dp[0][1] = 0;\n    rep(i, 1000001)rep(j, rt_len){\n        if(rt[j] <= i){\n            dp[i][0] = min(dp[i][0], dp[i-rt[j]][0]+1);\n\n            if(rt[j] & 1){\n                dp[i][1] = min(dp[i][1], dp[i-rt[j]][1]+1);\n            }\n        }\n    }\n\n    ll n;\n    vector<pll> ans;\n    while(cin >> n, n != 0){\n        cout << dp[n][0] << \" \" << dp[n][1] << endl;\n        // ans.push_back(make_pair(dp[n][0], dp[n][1]));\n    }\n\n    // rep(i, ans.size())cout << ans[i].first << \", \" << ans[i].second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int a[200],b[50],n,p;\n  bool c[1000000],d[1000000];\n  a[0]=b[0]=0;\n  p=0;\n  j=1;\n  for(i=1;a[i-1]<1000000;i++){\n    p+=i;\n    a[i]=a[i-1]+p;\n    if(a[i]%2){\n      b[j]=a[i];\n      j++;\n    }\n  }\n  while(cin>>n&&n){\n    memset(c,0,n);\n    c[0]=1;\n    for(i=1;;i++){\n      memset(d,0,n);\n      for(j=0;j<n;j++){\n\tif(c[j]){\n\t  for(k=0;j+a[k]<n;k++)\n\t    d[j+a[k]]=1;\n\t  if(j+a[k]==n)\n\t    break;\n\t}\n      }\n      if(j!=n)\n\tbreak;\n      memcpy(c,d,n);\n    }\n    cout<<i<<\" \";\n    memset(c,0,n);\n    c[0]=1;\n    for(i=1;;i++){\n      memset(d,0,n);\n      for(j=0;j<n;j++){\n\tif(c[j]){\n\t  for(k=0;j+b[k]<n;k++)\n\t    d[j+b[k]]=1;\n\t  if(j+b[k]==n)\n\t    break;\n\t}\n      }\n      if(j!=n)\n\tbreak;\n      memcpy(c,d,n);\n    }\n    cout<<i<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int i,j,n,three[1000],four[1000],four_2[1000],c[1000],c_2[1000];\n\n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < 100; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < 100; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate<class T>\nvoid print_vector (std::vector<T>* v)\n{\n    std::cout << std::endl;\n    for (T& e: *v)\n    {\n        std::cout << e << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint tetrahedral_number (int n)\n{\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\nint tetrahedral_number (std::vector<int>* vec, std::vector<int>* indices)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i] * tetrahedral_number ((*indices)[i]);\n    }\n\n    return num;\n}\n\nint tetrahedral_number (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i] * tetrahedral_number (i + 1);\n    }\n    return num;\n}\n\nint vector_sum (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i];\n    }\n\n    return num;\n}\n\nstd::vector<int>* approx_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n\n    while (tmp_n != 0)\n    {\n\n        int i = 0;\n\n        while (i++, tetrahedral_number (i + 1) <= tmp_n);\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (i);\n        }\n\n        (*solution)[i-1] = (*solution)[i-1] + 1;\n\n\n        tmp_n = tmp_n - tetrahedral_number (i);\n\n    }\n\n\n    return solution;\n}\n\nstd::vector<int>* improve_pollock_solution (std::vector<int>* base, int total)\n{\n\n    int dim = base->size ();\n\n    auto iterated_v = new std::vector<int> (*base);\n\n    std::vector<int>* solution = base;\n\n    int vsum = 0;\n\n    int approx_sum = 5;\n\n    while ((vsum = vector_sum (iterated_v)) > 0)\n    {\n\n        if (tetrahedral_number (iterated_v) == total && vsum <= approx_sum)\n        {\n            if (vector_sum (solution) > vsum)\n            {\n                solution = new std::vector<int> (*iterated_v);\n                approx_sum = vsum;\n                return solution;\n            }\n        }\n\n\n        if ((*iterated_v)[0] > 0)\n        {\n            (*iterated_v)[0] = (*iterated_v)[0] - 1;\n        }\n        else\n        {\n            for (int index = 1; index < dim; index++)\n            {\n                if ((*iterated_v)[index] != 0)\n                {\n                    (*iterated_v)[index] = (*iterated_v)[index] - 1;\n\n                    for (index = index - 1; index >= 0; index--)\n                    {\n                        (*iterated_v)[index] = approx_sum - vector_sum (iterated_v);\n                    }\n\n                    int i = 0;\n                    for (i = dim - 1; i > 0; i--)\n                    {\n                        if ((*iterated_v)[i] != 0)\n                        {\n                            break;\n                        }\n                    }\n\n                    if (tetrahedral_number (i+1) * approx_sum < total)\n                    {\n                        return solution;\n                    }\n\n                    break;\n                }\n            }\n\n        }\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* approx_odd_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    while (tmp_n != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= tmp_n; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (cnt);\n        }\n\n        (*solution)[cnt-1] = (*solution)[cnt-1] + 1;\n\n        tmp_n = tmp_n - tetrahedral_number (odd_i);\n\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* improve_odd_pollock_solution (std::vector<int>* base, int total)\n{\n\n    int dim = base->size ();\n\n    auto iterated_v = new std::vector<int> (*base);\n\n    std::vector<int>* solution = base;\n\n\n    auto tetra_indices = new std::vector<int> (dim);\n\n    int n_copy = total;\n\n    while (n_copy != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= n_copy; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n\n        (*tetra_indices)[cnt-1] = odd_i;\n\n        int tetra_num = tetrahedral_number (odd_i);\n\n        while (n_copy >= tetra_num)\n        {\n            n_copy = n_copy - tetra_num;\n        }\n\n    }\n\n    int vsum = 0;\n\n    int approx_sum = vector_sum (iterated_v);\n\n    while ((vsum = vector_sum (iterated_v)) > 0)\n    {\n\n        if (tetrahedral_number (iterated_v, tetra_indices) == total)\n        {\n\n            if (vector_sum (solution) > vsum)\n            {\n                solution = new std::vector<int> (*iterated_v);\n                approx_sum = vsum;\n            }\n        }\n\n\n        if ((*iterated_v)[0] > 0)\n        {\n            (*iterated_v)[0] = (*iterated_v)[0] - 1;\n        }\n        else\n        {\n            for (int index = 1; index < dim; index++)\n            {\n                if ((*iterated_v)[index] != 0)\n                {\n                    (*iterated_v)[index] = (*iterated_v)[index] - 1;\n\n                    for (index = index - 1; index >= 0; index--)\n                    {\n                        (*iterated_v)[index] = approx_sum - vector_sum (iterated_v);\n                    }\n\n                    int i = 0;\n                    for (i = dim - 1; i > 0; i--)\n                    {\n                        if ((*iterated_v)[i] != 0)\n                        {\n                            break;\n                        }\n                    }\n\n                    if (tetrahedral_number ((*tetra_indices)[i+1]) * approx_sum < total)\n                    {\n                        return solution;\n                    }\n\n                    break;\n                }\n            }\n\n        }\n    }\n\n\n\n    return solution;\n\n}\n\nint main ()\n{\n\n    int n = 0;\n    while (std::cin >> n, n != 0)\n    {\n\n\n        auto b = approx_least_number_by_tetrahedral (n);\n\n        int normal = vector_sum (b);\n\n        if (normal > 5)\n        {\n            auto s = improve_pollock_solution (b,n);\n        \n            normal = vector_sum (s);\n        }\n\n        auto ob = approx_odd_least_number_by_tetrahedral (n);\n\n        auto os = improve_odd_pollock_solution (ob, n);\n\n        int odd =vector_sum (os);\n\n        std::cout << normal << \" \" << odd <<  std::endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[2000001]={0,1,2,3},d[2000001],k=0,i,j,n;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<195;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct P{\n  int sum;\n  char k,n;\n  P(){}\n  P(int S,int K,int N){ sum=S;k=K;n=N; }\n};\n\nint a[200];\n\nint main(){\n  int n, ans1,ans2;\n  queue<P> q;\n  P p;\n\n  for( int i=1;i<200 ; i++ )\n    if( (a[i]=i*(i+1)*(i+2)/6)>1000000 )\n      break;\n\n  int size,n2;\n  while( cin>>n && n ){\n\n    ans1=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<200;i++ ){\n      if( a[i]==n ){\n\tans1=1; size=i+1;\n\tbreak;\n      }\n      if( a[i]<n ) q.push( P(a[i],i,1) );\n      else{\n\tsize=i; break;\n      }\n    }\n    while( !ans1 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      if( binary_search( a,a+size, n-p.sum ) ){\n\tans1=n2; break;\n      }\n      for( int i=p.k,j;i<size;i++ ){\n\tj=p.sum+a[i];\n\tif( j>n ) break;\n\tq.push( P(j,i,n2) );\n      }\n    }\n\n    ans2=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<size;i++ ){\n      if( a[i]%2==1 ){\n\tif( a[i]==n ){ ans2=1; break; }\n\tq.push( P(a[i],i,1) );\n      }\n    }\n    while( !ans2 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      int mm=n-p.sum;\n      if( mm%2==1 && binary_search( a,a+size,mm ) ){\n\tans2=n2; break;\n      }\n      for( int i=p.k,j;i<size;i++ ){\n\tif( a[i]%2==1 ){\n\t  j=p.sum+a[i];\n\t  if( j>n ) break;\n\t  q.push( P(j,i,n2) );\n\t}\n      }\n    }\n    \n    cout << ans1 << \" \" << ans2 << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int i,j,n,three[1000],four[1000],four_2[1000],c[1000],c_2[1000];\n\n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < 50; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < 50; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint i,j,n,three[1000000],four[1000000],four_2[1000000],c[1000000],c_2[1000000];\n\nint main(){\n  \n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  for( i = 0; i <= n; i++ ){\n    c[i] = 2000000;\n    c_2[i] = 2000000;\n  }\n\n  c[0] = 0;\n  for( i = 0; i < 1000; i++ ){\n    for( j = four[i]; j <= n; j++ ){\n      c[j] = min( c[j],c[j-four[i]] + 1 );\n    }\n  }\n\n  c_2[0] = 0;\n  for( i = 0; i < 1000; i++ ){\n    for ( j = four_2[i]; j <= n; j++ ){\n      c_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n   \n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing ll = long long;\n\n#define N 1000007\nll s[N], t[N];\n\nint main() {\n\n    for(ll i=0; i<N; ++i) s[i] = t[i] = 10000000;\n    s[0] = t[0] = 0;\n    for(ll i=0; i<N; ++i) {\n        ll j = 1;\n        while(i + j*(j+1)*(j+2)/6 < N) {\n            ll p = j*(j+1)*(j+2)/6;\n            s[i+p] = min(s[i]+1, s[i+p]);\n            if(p % 2 == 1) {\n                t[i+p] = min(t[i]+1, t[i+p]);\n            }\n            ++j;\n        }\n    }\n\n    int n;\n    while(cin >> n && n) {\n        cout << s[n] << \" \" << t[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF (1e9+7)\n\nusing namespace std;\n\nint tetra[200];\nint odd_tetra[200];\nint tetracount[1000000];\nint oddcount[1000000];\n\nint dfs(int target){\n  if(target == 0) return 0;\n  if(tetracount[target] != 0) return tetracount[target];\n  int res = INF;\n  REP(i, 200){\n    if(tetra[i] > target) continue;\n    if(tetra[i] == 0) break;\n    res = min(res, dfs(target - tetra[i]) + 1);\n  }\n  tetracount[target] = res;\n  return res;\n}\n\nint odddfs(int target){\n  if(target == 0) return 0;\n  if(oddcount[target] != 0) return oddcount[target];\n  int res = INF;\n  REP(i, 200){\n    if(odd_tetra[i] > target) continue;\n    if(odd_tetra[i] == 0) break;\n    res = min(res, odddfs(target - odd_tetra[i]) + 1);\n  }\n  oddcount[target] = res;\n  return res;\n}\n\nint main(){\n  REP(i, 200) tetra[i] = i * (i+1) * (i+2) / 6;\n  int cnt = 0;\n  REP(i, 200) if(tetra[i] % 2) odd_tetra[cnt++] = tetra[i];\n  sort(tetra, tetra+200, greater<int>());\n  sort(odd_tetra, odd_tetra+200, greater<int>());\n  int n;\n  while(cin >> n and n) cout << dfs(n) << \" \" << odddfs(n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\nusing pci = pair<char, int>;\nusing vpci = vector<pci>;\n#define out(S) cout<<(S)<<endl;\n#define REP(i,b) for(size_t i=0;i<(b);i++)\n#define rREP(i,b) for(int i=(b)-1;i>=0;i--)\n#define FOR(i,a,b) for(size_t i=(a);i<(b);i++)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define Foreach(item,collection) for(auto item:collection)\n#define mod(i) ((i) % (ll)(1e9 + 7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a * modpow((ll)b,(ll)(1e9 + 5))))\n#define Yes out(\"Yes\")\n#define No out(\"No\")\n#define NO out(\"NO\")\n#define YES out(\"YES\")\n#define INF 1e10;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define IfOut(condition,text) if((condition)){out(text);return 0;}\n#define IfeOut(condition,itext,etext) if(condition){out(itext);return 0;}else{out(etext);return 0;}\n#define Select(collection,condition,result) Foreach(i,collection){result+=condition;}\n#define GetAuto(_N,vect) {cin>>_N;vect.resize(_N);REP(i,_N){cin>>vect[i];}}\n#define beginend(vec) (vec).begin(),(vec).end()\n#define pb(item) push_back(item)\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) { ll prime; double sqrtmax = sqrt(max); vector<ll> primeVec, searchVec; FOR(i, 2, max + 1) searchVec.push_back(i); do { prime = searchVec[0]; primeVec.push_back(prime); auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; }); searchVec.erase(itr, searchVec.end()); } while (prime < sqrtmax); primeVec.reserve(primeVec.size() + searchVec.size()); primeVec.insert(primeVec.end(), beginend(searchVec)); return primeVec; }\nbool isPrime(ll x) { if (x == 2) return true; if (x < 2 || x % 2 == 0) return false; ll i = 3; while (i <= sqrt(x)) { if (x%i == 0) return false; i += 2; }return true; }\n\n\nmap<int, int> dp, odddp;\nint main() {\n\tint N;\n\tint p = 4;\n\tREP(i, 1000000) {\n\t\tdp[i] = i;\n\t\todddp[i] = i;\n\t}\n\tint n = 3;\n\twhile (p<=1000000)\n\t{\n\t\tfor (int i = 0; i+p <=1000000; i++)\n\t\t{\n\t\t\tdp[i + p] = min(dp[i + p], dp[i] + 1);\n\t\t}\n\t\tif (p % 2 == 1) {\n\t\t\tfor (int i = 0; i + p <= 1000000; i++)\n\t\t\t{\n\t\t\t\todddp[i + p] = min(odddp[i + p], odddp[i] + 1);\n\t\t\t}\n\t\t}\n\n\t\tp = n*(n + 1)*(n + 2) / 6;\n\t\tn++;\n\t}\n\n\t\n\n\twhile (cin>>N,N)\n\t{\n\t\tcout << dp[N - 1] << \" \" << odddp[N - 1] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[84];\n    int b[22];\n    int t1[100010],t2[100010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n\n        for(i = 0; i <= 100005; i++){\n            t1[i] = i;\n        }\n\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= 100005; j++){\n                if(t1[j] > t1[j - a[i]] + 1){\n                    t1[j] = t1[j -a[i]] + 1;\n                }\n            }    \n        }        \n\n        for(i = 0; i <= 100005; i++){\n            t2[i] = i;\n        }\n        \n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= 100005; j++){\n                if(t2[j] > t2[j - b[i]] + 1){\n                    t2[j] = t2[j - b[i]] + 1;\n                }\n            }\n        }\n            \n\n\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << t1[n] << \" \" << t2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint memo1[1000001], memo2[1000001], memoodd[1000001], memo3[1000001];\n\nint pollock_1(int n)\n{\n    int min = 100, ex;\n    if (n == memo1[n])\n        return memo2[n] = 1;\n    if (memo2[n] > 0)\n        return memo2[n];\n    for (int i = 1; i < 1000001; i++)\n    {\n        if (i <= n / 2)\n        {\n            if (pollock_1(n - i) == 1)\n            {\n                ex = pollock_1(n - i) + pollock_1(i);\n            }\n            if (i == 1)\n            {\n                ex = pollock_1(n - 1) + 1;\n            }\n            if (ex < min)\n                min = ex;\n        }\n    }\n    return memo2[n] = min;\n}\n\nint pollock_2(int n)\n{\n    int min = 10000000, ex;\n    if (n == memoodd[n])\n        return memo2[n] = 1;\n    if (memo3[n] > 0)\n        return memo3[n];\n    for (int i = 1; i < 1000001; i++)\n    {\n        if (i <= n / 2)\n        {\n            if (pollock_2(n - i) == 1)\n            {\n                ex = pollock_2(n - i) + pollock_2(i);\n            }\n            if (i == 1)\n            {\n                ex = pollock_2(n - 1) + 1;\n            }\n            if (ex < min)\n                min = ex;\n        }\n    }\n    return memo3[n] = min;\n}\n\nint main()\n{\n    for (int k = 0; k < 1000001; k++)\n    {\n        memo1[k] = 0;\n        memo2[k] = 0;\n        memoodd[k] = 0;\n        memo3[k] = 0;\n    }\n    for (int k = 1; k < 200; k++)\n    {\n        n = (k * (k + 1) * (k + 2)) / 6;\n        memo1[n] = n;\n        if (n % 2 != 0)\n            memoodd[n] = n;\n    }\n    while (1)\n    {\n        scanf(\"%d\", &n);\n        if (n == 0)\n            break;\n        printf(\"%d %d\\n\", pollock_1(n), pollock_2(n));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\nvector<pii> a(1000010);\n//int b[5]={1,4,10,20,35};\n//int c[3]={1,10,35};\nint main(){\n\tint n;\n\tvint b,c;\n\tll lim=1000010;\n\tfor(ll i=0;i<lim;i++){\n\t\ta[i]=mkp(INT_MAX,INT_MAX);\n\t\t//cout<<a[i].S<<endl;\n\t}\n\ta[0]=mkp(0,0);\n\trep(i,1000000){\n\t\tif(!i) continue;\n\t\tint t=i*(i+1)*(i+2)/6;\n\t\tif(t>1000000) break;\n\t\tb.PB(t);\n\t\tif(t&1) c.PB(t);//cout<<t<<endl;\n\t}\n\t// for(int i=1;i<INT_MAX;i+=2){\n\t\t// int t=i*(i+1)*(i+2)/6;\n\t\t// if(t>1000000) break;\n\t\t// c.PB(t);\n\t\t//cout<<t<<endl;\n\t// }\n\trep(i,b.size()){\n\t\tint t=b[i];\n\t\twhile(t<=lim){\n\t\t\ta[t].F=min(a[t].F,a[t-b[i]].F+1);\n\t\t\tt++;\n\t\t}\n\t}\n\t//cout<<\"hoge\"<<endl;\n\trep(i,c.size()){\n\t\tint t=c[i];\n\t\twhile(t<=lim){\n\t\t\ta[t].S=min(a[t].S,a[t-c[i]].S+1);\n\t\t\t//if(t==14) cout<<a[t].S<<\" \"<<c[i]<<endl;\n\t\t\tt++;\n\t\t}\n\t}\n\twhile(cin>>n,n){\n\t\tcout<<a[n].F<<\" \"<<a[n].S<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    vector<vector<int> > tetra(2);\n    for(int i = 1; (i * (i + 1) * (i + 2)) / 6 < 1000001; i++){\n        tetra[0].push_back((i * (i + 1) * (i + 2)) / 6);\n        tetra[((i * (i + 1) * (i + 2)) / 6) % 2].push_back((i * (i + 1) * (i + 2)) / 6);\n    }\n    // for(int i = 0; i < 2; i++){\n    //     for(int j = 0; j < tetra[i].size(); j++){\n    //         cout << tetra[i][j] << endl;\n    //     }\n    //     cout << endl;\n    // }\n    int result[1000001][2];\n    for(int i = 0; i < 1000001; i++){\n        for(int j = 0; j < 2; j++){\n            result[i][j] = 1000001;\n        }\n    }\n    result[0][0] = 0;\n    result[0][1] = 0;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < tetra[i].size(); j++){\n            for(int k = 0; k + tetra[i][j] < 100001; k++){\n                result[k + tetra[i][j]][i] = min(result[k + tetra[i][j]][i], result[k][i] + 1);\n            }\n        }\n    }\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0)break;\n        cout << result[n][0] << \" \" << result[n][1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 1000000\nusing namespace std;\nconst int infty = 1<<25;\nint main()\n{\n  int allnum = 0;\n  static int KAll[MAX];\n  static int Answer1[MAX];\n  static int Answer2[MAX];\n\n  Answer1[0]=0;\n  Answer2[0]=0;\n\n  int n = 1;\n  while( true ){\n    int t = n*(n+1)*(n+2) / 6;\n    if( t >= MAX ) break;\n    KAll[allnum++]=t;\n    ++n;\n  }\n  \n  for(int i = 1; i < MAX; ++i){\n    Answer2[i] = Answer1[i] = infty;\n    for(int j = 0; j < allnum && i - KAll[j] >= 0; ++j){\n      Answer1[i] = min(Answer1[i], 1+Answer1[i-KAll[j]]);\n      if( KAll[j] % 2 == 1 ){\n\tAnswer2[i] = min(Answer2[i], 1+Answer2[i-KAll[j]]);\n      }\n    }\n  }\n  \n  while(true){\n    int N;\n    scanf(\"%d\", &N);\n    if( N == 0 ) break;\n    printf(\"%d %d\\n\", Answer1[N], Answer2[N]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200],b[150],c[1000010],d[1000010],k=0,i,j,n;\n\n  for(i=0;i<200;i++)a[i]=i*(i+1)*(i+2)/6;\n\n  for(j=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=0;i<1000010;i++)c[i]=d[i]=i;\n\n  for(i=1;i<198;i++)for(j=a[i];j<1000010;j++){\n    c[j]=min(c[j],c[j-a[i]]+1);\n  }\n  for(i=1;i<k-1;i++)for(j=b[i];j<10000010;j++){\n    d[j]=min(d[j],d[j-b[i]]+1);\n  }\n while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint tsum[1000060];\nint toddsum[1000060];\n\nint main()\n{\n  int n;\n  cin >> n;\n  int last = 1;\n  tsum[1] = 1;\n  toddsum[1] = 1;\n\n  while (n > 0)\n    {\n      for (;last < n+1; last++)\n\t{\n\t  for (int i = 1; i*(i+1)*(i+2)/6 < last+1; i++)\n\t    {\n\t      int tet = i*(i+1)*(i+2)/6;\n\t      if (last - tet >= 0 && \n\t\t  (tsum[last] == 0 || tsum[last-tet] + 1 < tsum[last]))\n\t\ttsum[last] = tsum[last-tet]+1;\n\t      if ((tet % 2 == 1) &&\n\t\t  last - tet >= 0 &&\n\t\t  (toddsum[last] == 0 || \n\t\t  toddsum[last-tet] + 1 < toddsum[last]))\n\t\ttoddsum[last] = toddsum[last-tet]+1;\n\t    }\n\t}\n      cout << tsum[n] << \" \" << toddsum[n] << \"\\n\";\n      cin >> n;\n    }\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  //tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[200]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<195;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX =1000000;\nint Pollock[MAX];\nint T[MAX];\nstatic const int INF (1<<29);\nint min(int n){\n   /*\n     Same as problem 17.1 in the book Algo and Data Struct\n     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_A\n\n    */\n    \n    int i=1;\n    Pollock[i]=1;\n    while(Pollock[i]<=n){\n\ti++;\n\tPollock[i]=(i*(i+1)*(i+2)/6);\n    }\n    // Pollock to i-1 th element is used\n    int j,k;\n    for(j=0;j<MAX;j++)T[j]=INF;\n    T[0]=0;\n    for(j=1;j<i;j++){\n\tfor(k=Pollock[j];k<=n;k++){\n\t    T[k]=min(T[k],T[k - Pollock[j]]+1);\n\n\t\t}\n    }\n    //DP?????£???????°????\n    \n    \n    return T[n];\n}\n\nint is_odd(int n){\n    if (n % 2 == 1)return 1;\n    return 0;\n}\n\nint cal_pollock(int i){\n    return (i*(i+1)*(i+2)/6);\n}\nint odd(int n){\n    int i=1;\n    Pollock[i]=1;\n    int j=1;\n    while(cal_pollock(i)<=n){\n\tif(is_odd(cal_pollock(i))){\n\t    Pollock[j]=cal_pollock(i);\n\t    j++;\n\t}\n\ti++;\n    }\n    // Pollock to i-1 th element is used\n    int k,l;\n    for(l=0;l<MAX;l++)T[l]=INF;\n    T[0]=0;\n    for(l=1;l<j;l++){\n\tfor(k=Pollock[l];k<=n;k++){\n\t    T[k]=min(T[k],T[k - Pollock[l]]+1);\n\n\t\t}\n    }\n    //DP?????£???????°????\n    \n    \n    return T[n];\n}\n\nint main(){\n    int n;\n    while(1){\n\tcin >>n;\n\tif(n==0)break;\n\n\tcout << min(n) << \" \" << odd(n) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    vector<int> tri;\n    vector<int> odd;\n    constexpr int MAX = 1000000;\n    for (int i = 1;; i++) {\n        const int num = i * (i + 1) * (i + 2) / 6;\n        if (num >= MAX) {\n            break;\n        }\n        tri.push_back(num);\n        if (num % 2 == 1) {\n            odd.push_back(num);\n        }\n    }\n    constexpr int INF = 1000000000;\n    vector<int> num(MAX, INF);\n    vector<int> oddnum(MAX, INF);\n    num[0] = 0;\n    oddnum[0] = 0;\n    for (int i = 0; i < MAX; i++) {\n        if (num[i] == INF) {\n            continue;\n        }\n        for (const int p : tri) {\n            if (i + p < MAX) {\n                num[i + p] = min(num[i + p], num[i] + 1);\n            }\n        }\n    }\n    for (int i = 0; i < MAX; i++) {\n        if (oddnum[i] == INF) {\n            continue;\n        }\n        for (const int p : odd) {\n            if (i + p < MAX) {\n                oddnum[i + p] = min(oddnum[i + p], oddnum[i] + 1);\n            }\n        }\n    }\n\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        cout << num[n] << \" \" << oddnum[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n \n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nconst int size = 200;\nconst int limit = 1000001;\nint dp[limit], dp_odd[limit];\nint tetra[size], odd[size];\n\nint main(void){\n    int size_odd = 0;\n    for(int i=1; i<size+1; ++i) {\n        ll t = i*(i+1)*(i+2)/6;\n        tetra[i-1] = t;\n        if(t%2==1) {odd[size_odd]=t; size_odd++;}\n    }\n    int inf = numeric_limits<int>::max();\n    rep(i, limit) dp[i] = dp_odd[i] = inf;\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    rep(i, size) {\n        for(int j=tetra[i]; j<limit; ++j) \n            dp[j] = min(dp[j-tetra[i]]+1, dp[j]);\n    }\n    rep(i, size_odd) {\n        for(int j=odd[i]; j<limit; ++j) \n            dp_odd[j] = min(dp_odd[j-odd[i]]+1, dp_odd[j]);\n    }\n\n    int n;\n    while(cin >> n && n) {\n        cout << dp[n] << \" \";\n        cout << dp_odd[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n \nint dp[1000010];\nint dp2[1000010];\n\nint main(){\n\tint a = 1, b;\n\tvi v;\n\tvi u;\n\twhile((b = a*(a+1)*(a+2)/6)<1e6){\n\t\tv.pb(b);\n\t\tif(b%2 == 1){\n\t\t\tu.pb(b);\n\t\t}\n\t\ta++;\n\t}\n\t//cout<<v.size()<<endl;\n\tfor(int i = 0; i < 1000010; i++){\n\t\tdp[i] = INF;\n\t\tdp2[i] = INF;\n\t}\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tfor(int j = v[i]; j < 1000010; j++){\n\t\t\tdp[j] = min(dp[j], dp[j-v[i]]+1);\n\t\t\tif(i < u.size() && j >= u[i]){\n\t\t\t\tdp2[j] = min(dp2[j], dp2[j-u[i]]+1);\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<\"OK\"<<endl;\n\tint n;\n\twhile(cin>>n && n > 0){\n\t\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][100000] = {0};\n\nvoid solve(int n) {\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t\tif (dp[i][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=100000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\t//dp[i%2][j] = 0;\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t\tif (dp[i%2][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nusing namespace std;\n\nconst int MAX_N = 100100;\nconst int INF = 1 << 29;\n\nvoid solve(int n)\n{\n\tint dp[MAX_N], dp_odd[MAX_N];\n\tfill_n(dp, n + 1, INF);\n\tfill_n(dp_odd, n + 1, INF);\n\t\n\tdp[0] = 0;\n\tdp_odd[0] = 0;\n\tREP(i, 100) {\n\t\tint m = (i + 1) * (i + 2) * (i + 3) / 6;\n\t\tif(m > n) break;\n\t\tFOR(j, m, n + 1) {\n\t\t\tif(m % 2) dp_odd[j] = min(dp_odd[j], dp_odd[j - m] + 1);\n\t\t\tdp[j] = min(dp[j], dp[j - m] + 1);\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\", dp[n], dp_odd[n]);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n), n) solve(n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nint main(void){\n  std::vector<int>lis = {1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286, 364, 455, 560, 680, 816, 969, 1140, 1330, 1540, 1771, 2024, 2300, 2600, 2925, 3276, 3654, 4060, 4495, 4960, 5456, 5984, 6545, 7140, 7770, 8436, 9139, 9880, 10660, 11480, 12341, 13244, 14190, 15180, 16215, 17296, 18424, 19600, 20825, 22100, 23426, 24804, 26235, 27720, 29260, 30856, 32509, 34220, 35990, 37820, 39711, 41664, 43680, 45760, 47905, 50116, 52394, 54740, 57155, 59640, 62196, 64824, 67525, 70300, 73150, 76076, 79079, 82160, 85320, 88560, 91881, 95284, 98770, 102340, 105995, 109736, 113564, 117480, 121485, 125580, 129766, 134044, 138415, 142880, 147440, 152096, 156849, 161700, 166650, 171700, 176851, 182104, 187460, 192920, 198485, 204156, 209934, 215820, 221815, 227920, 234136, 240464, 246905, 253460, 260130, 266916, 273819, 280840, 287980, 295240, 302621, 310124, 317750, 325500, 333375, 341376, 349504, 357760, 366145, 374660, 383306, 392084, 400995, 410040, 419220, 428536, 437989, 447580, 457310, 467180, 477191, 487344, 497640, 508080, 518665, 529396, 540274, 551300, 562475, 573800, 585276, 596904, 608685, 620620, 632710, 644956, 657359, 669920, 682640, 695520, 708561, 721764, 735130, 748660, 762355, 776216, 790244, 804440, 818805, 833340, 848046, 862924, 877975, 893200, 908600, 924176, 939929, 955860, 971970};\n  std::vector<int>lis_1 = {1, 35, 165, 455, 969, 1771, 2925, 4495, 6545, 9139, 12341, 16215, 20825, 26235, 32509, 39711, 47905, 57155, 67525, 79079, 91881, 105995, 121485, 138415, 156849, 176851, 198485, 221815, 246905, 273819, 302621, 333375, 366145, 400995, 437989, 477191, 518665, 562475, 608685, 657359, 708561, 762355, 818805, 877975, 939929};\n  std::vector<int>dp(1000001);\n  std::vector<int>dp_1(1000001);\n  for (int i = 0; i < 1000001; i++){\n    dp[i] = 1000;\n    dp_1[i] = 1000;\n  }\n  dp[0] = 0;\n  dp_1[0] = 0;\n  for (int i = 0; i < 1000001; i++){\n    for (int j = 0; j < lis.size(); j++){\n      if (i+lis[j] <= 1000000){\n        dp[i+lis[j]] = std::min(dp[i]+1, dp[i+lis[j]]);\n      }\n    }\n  }\n  for (int i = 0; i < 1000001; i++){\n    for (int j = 0; j < lis_1.size(); j++){\n      if (i+lis_1[j] <= 1000000){\n        dp_1[i+lis_1[j]] = std::min(dp_1[i]+1, dp_1[i+lis_1[j]]);\n      }\n    }\n  }\n\n  while (1){\n    int n;\n    std::cin >> n;\n    if (n == 0) break;\n    std::cout << dp[n] << \" \" << dp_1[n] << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint pollock[190]; //(i+1)の正四面体数\nint dp[2][1000001]; //jのポロック数を作る最小四面体数個数\nint main()\n{\n\tfor(int i=0;i<190;i++)\n\t\tpollock[i]=(i+1)*(i+2)*(i+3)/6;\n\tfill(dp[0],dp[2],1e8-1);\n\tdp[0][0]=0;\n\t//start dp\n\tfor(int i=0;i<190;i++)\n\t{\n\t\tfor(int j=0;j+pollock[i]<1000001;j++)\n\t\t{\n\t\t\tdp[0][j+pollock[i]]=min(dp[0][j+pollock[i]],dp[0][j]+1);\n\t\t}\n\t}\n\tdp[1][0]=0;\n\tfor(int i=0;i<190;i++)\n\t{\n\t\tif((pollock[i]&1)==0)\n\t\t\tcontinue;\n\t\tfor(int j=0;j+pollock[i]<1000001;j++)\n\t\t{\n\t\t\tdp[1][j+pollock[i]]=min(dp[1][j+pollock[i]],dp[1][j]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(1)\n\t{\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcout<<dp[0][n]<<\" \"<<dp[1][n]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1001001001;\ntypedef pair<int, int> P;\n\nint d[1000001], d2[1000001];\n\nint main()\n{\n\tint tet[1001];\n\tfor (int i = 1; i <= 1000; i++){\n\t\ttet[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\t\n\tfill(d, d + 1000001, INF);\n\td[0] = 0;\n\tfor (int i = 1; tet[i] <= 1000000; i++){\n\t\tfor (int j = 0; j + tet[i] <= 1000000; j++){\n\t\t\td[j + tet[i]] = min(d[j + tet[i]], d[j] + 1);\n\t\t}\n\t}\n\t\n\tfill(d2, d2 + 1000001, INF);\n\td2[0] = 0;\n\tfor (int i = 1; tet[i] <= 1000000; i++){\n\t\tif (tet[i] % 2 == 0) continue;\n\t\tfor (int j = 0; j + tet[i] <= 1000000; j++){\n\t\t\td2[j + tet[i]] = min(d2[j + tet[i]], d2[j] + 1);\n\t\t}\n\t}\n\t\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tcout << d[n] << \" \" << d2[n] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint p(int i){\n  return i * (i + 1) * (i + 2) / 6;\n}\n\n\nint main(void){\n\n  /* ???????¨??????? */\n      int ans1[100001];\n      int ans2[100001];\n      for(int i = 1 ; i < 100001 ; i++){\n        ans1[i+1] = -1;\n        ans2[i+1] = -1;\n      }\n\n      for(int i = 1 ; p(i) < 100001 ; i++){\n        ans1[p(i)] = 1;\n        if(p(i) % 2 == 1){ ans2[p(i)] = 1; }\n      }\n\n      for(int i = 2 ; i <= 100001 ; i++){\n        if(ans1[i] == 1){\n        }else{\n          int min = 1000000;\n          for(int j = 1 ; j < i ; j++){\n            if(ans1[j] + ans1[i - j] < min){\n              min = ans1[j] + ans1[i - j];\n            }\n          }\n          ans1[i] = min;\n        }\n      }\n\n      for(int i = 2 ; i <= 100001 ; i++){\n        if(ans2[i] == 1){\n        }else{\n          int min = 1000000;\n          for(int j = 1 ; j < i ; j++){\n            if(ans2[j] + ans2[i - j] < min){\n              min = ans2[j] + ans2[i - j];\n            }\n          }\n          ans2[i] = min;\n        }\n      }\n\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0){return 0;}\n\n    cout << ans1[n] << \" \" << ans2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define max 1000000\n\n//正四面体数を返す\nint getRt(int n){\n\treturn (n) * (n + 1) * (n + 2) / 6;\n}\nint min(int p, int q) {\n\tif( p > q ) return q;\n\treturn p;\n}\n\nint main(void){\n//\tFILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\t\n\tvector<int> Rtlist;\n\tvector<int> Rtlist2;\n\tvector<int> vn;\n\tvector<int> vo;\n\t//正四面体数テーブル\n\tfor(int i = 1; getRt(i) <= max; i++) {\n\t\tRtlist.push_back( getRt(i) );\n\t\tif( getRt(i) % 2 != 0 ) Rtlist2.push_back( getRt(i) );\n\t}\n\t//答えのテーブル\n\tfor(int i = 0; i <= max; i++) {\n\t\tvn.push_back(i);\n\t\tvo.push_back(i);\n\t}\n\tfor(int i = 0; i < Rtlist.size(); i++)\n\t\tvn.at( Rtlist.at(i) ) = 1;\n\tfor(int i = 0; i < Rtlist2.size(); i++)\n\t\tvo.at( Rtlist2.at(i) ) = 1;\n\t\n\t//動的計画法を用いる\n\t/*\n\t\t正四面体数p\n\t\tvn(n+p) = min( vn(n) + 1, vn(n+p) ) \n\t*/\n\tfor(int i = 1; i <= max; i++ )\n\t\tfor(int j = 0; j < Rtlist.size() && i + Rtlist.at(j) <= max ; j++)\n\t\t\tvn.at( i + Rtlist.at(j) ) = min( vn.at( i ) + 1, vn.at( i + Rtlist.at(j) ) );\n\tfor(int i = 1; i <= max; i++ )\n\t\tfor(int j = 0; j < Rtlist2.size()  && i + Rtlist2.at(j) <= max ; j++)\n\t\t\tvo.at( i + Rtlist2.at(j) ) = min( vo.at( i ) + 1, vo.at( i + Rtlist2.at(j) ) );\n\n\t\n\twhile(1){\n\t\tint n, tmp;\n\t\tcin >> n;\n\t\tif( n == 0 ) break;\n\n\t\tcout << vn.at(n) << \" \" << vo.at(n) << endl;\n\n\t}\n\n//\twhile(1){}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<algorithm>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define INF 1000000000000\nint MOD=1000000007;\n\nsigned main() {\n  vector<int>seisi(0);\n  vector<int>seisiki(0);\n  int k=1,t=1;\n  while(k<=1000000){\n    k=t*(t+1)*(t+2)/6;\n    seisi.push_back(k);\n    if(k%2==1) seisiki.push_back(k);\n    t++;\n  }\n\n  int dpkisu[1000001],dp[1000001];\n  rep(i,1000001){\n    dpkisu[i]=INF;\n    dp[i]=INF;\n  }\n  dpkisu[0]=0;\n  dp[0]=0;\n  for(int x=1;x<1000001;x++){\n    rep(i,seisi.size()){\n      if(seisi[i]<=x){\n        dp[x]=min(dp[x],dp[x-seisi[i]]+1);\n      }\n    }\n    rep(i,seisiki.size()){\n      if(seisiki[i]<=x){\n        dpkisu[x]=min(dpkisu[x],dpkisu[x-seisiki[i]]+1);\n      }\n    }\n\n  }\n  while(true){\n    int l;cin>>l;\n    if(l==0) exit(0);\n    cout<<dp[l]<<' '<<dpkisu[l]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int lim = 1000010;\n    vector<int> dp(lim, lim);\n    vector<int> oddp(lim, lim);\n    vector<int> lis;\n    for (int i = 1; ; ++i) {\n        int p = i * (i + 1) * (i + 2) / 6;\n        if (p > lim) break;\n        lis.push_back(p);\n    }\n    dp[0] = oddp[0] = 0;\n    for (int i = 1; i < lim; ++i) {\n        for (int j : lis) {\n            if (j > i) break;\n            dp[i] = min(dp[i], dp[i - j] + 1);\n            if (j & 1)\n                oddp[i] = min(oddp[i], oddp[i - j] + 1);\n        }\n    }\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        cout << dp[n] << \" \" << oddp[n] << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main() {\n    int table[1000000];\n    int max;\n    for (int i = 1; i < 1000000; i++) {\n        table[i] = i * (i + 1) * (i + 2) / 6;\n        if (table[i] >= 1000000) {\n            max = i - 1;\n            break;\n        }\n    }\n\n    int m;\n    while (cin >> m, m) {\n        bool used[1000000];\n        fill_n((bool *)used, 1000000, false);\n        priority_queue<pii, vector<pii>, greater<pii>> q;\n        q.push({0, 0});\n        while (!q.empty()) {\n            pii p = q.top(); q.pop();\n            int count = p.first;\n            int total = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << \" \";\n                break;\n            }\n\n            for (int i = 1; i < max; i++) {\n                int sum = table[i] + total;\n                if (sum <= m && !used[sum]) {\n                    q.push({count+1, sum});\n                    used[sum] = true;\n                }\n            }\n        }\n        while(!q.empty())\n            q.pop();\n        fill_n((bool *)used, 1000000, false);\n        q.push({0, 0});\n        while (!q.empty()) {\n            pii p = q.top(); q.pop();\n            int count = p.first;\n            int total = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << endl;\n                break;\n            }\n\n            for (int i = 1; i < max; i++) {\n                int sum = table[i] + total;\n                if (table[i] % 2 && sum <= m && !used[sum]) {\n                    q.push({count+1, sum});\n                    used[sum] = true;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n\n#include<iostream>\n#include<fstream>\n\n\n#define Max_Len 1000000\n\nusing namespace std;\n\nint triCalc(int num){\n\tstatic short int count[Max_Len];\n\tstatic short int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//?????????\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (num / 5 < triNum){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > triCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = triCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint oddCalc(int num){\n\tstatic short int count[Max_Len];\n\tstatic short int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//?????????\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\twhile ((i * (i + 1) * (i + 2) / 6 )% 2 == 0)i--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (i > 0){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > oddCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = oddCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\twhile ((i * (i + 1) * (i + 2) / 6) % 2 == 0)i--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint main(){\n/*\n\tifstream fin;\n\tofstream fout;\n\n\tfin.open(\"input.txt\");\n\tfout.open(\"output.txt\");\n*/\n\tint n;\n\n\n\twhile (true){\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tcout << triCalc(n) << \" \" << oddCalc(n) << endl;\n\t}\n\t\n\n\t//cout << oddCalc(40);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1000003;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nsigned main(){\n    vector<int> s{1};\n    for(int i = 2; s.back() <= 1e6; ++i){\n        s.push_back(s.back() + i);\n    }\n    vector<i64> v{1};\n    for(int i = 1; v.back() <= 1e6; ++i)\n        v.push_back(v.back() + s[i]);\n    s.clear();\n    int m = 1e6 + 7;\n    vector<int> dist(m, MOD), dist2(m, MOD);\n    queue<int> que;\n    que.emplace(0);\n    dist[0] = 0;\n    while(!que.empty()){\n        int k = que.front();\n        que.pop();\n        for(auto x : v)\n            if(k + x < m && chmin(dist[k + x], dist[k] + 1))\n                que.emplace(k + x);\n    }\n    que.emplace(0);\n    dist2[0] = 0;\n    while(!que.empty()){\n        int k = que.front();\n        que.pop();\n        for(auto x : v)\n            if(x % 2 == 1 && k + x < m && chmin(dist2[k + x], dist2[k] + 1))\n                que.emplace(k + x);\n    }\n    while(1){\n        int k;\n        cin >> k;\n        if(!k)\n            break;\n        cout << dist[k] << \" \" << dist2[k] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint dp[1000001],dp2[1000001];\nint main(void)\n{\n\tint n,p[10001],i,j,nn,x,a,b;\n\tfor(i=1;i<=1000000;i++)\t{\n\t\tx=i*(i+1)*(i+2)/6;\n\t\tif(x>1000000)\tbreak;\n\t\tp[i]=x;\n\t}\n\tnn=i;\n\tdp[0]=0;\n\tfor(i=1;i<=1000000;i++)\tdp[i]=i;\n\tfor(i=2;i<nn;i++)\t{\n\t\tif(p[i]>1000000)\tbreak;\n\t\tfor(j=0;j<1000000;j++)\t{\n\t\t\tif(j+p[i]<=1000000)\t{\n\t\t\t\tdp[j+p[i]]=min(dp[j+p[i]],dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\t\n\tdp2[0]=0;\n\tfor(i=1;i<=1000000;i++)\tdp2[i]=i;\n\tfor(i=2;i<=nn;i++)\t{\n\t\tif(p[i]>1000000)\tbreak;\n\t\tif(p[i]%2==1)\t{\n\t\t\tfor(j=0;j<1000000;j++)\t{\n\t\t\t\tif(j+p[i]<=1000000)\t{\n\t\t\t\t\tdp2[j+p[i]]=min(dp2[j+p[i]],dp2[j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\n\twhile(1)\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\tbreak;\n\t\ta=dp[n];\n\t\tb=dp2[n];\t\t\n\t\tprintf(\"%d %d\\n\",a,b);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> A(M,INF), A_odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  A_odd[0] = 0;\n  for(int i = 0; i < M; ++i){\n    A[i] = i;\n    A_odd[i] = i;\n  }\n  while(t < 1000000){\n    for(int k = 0; k+t < M; ++k){\n      A[k+t] = min(A[k]+1,A[k+t]);\n      if(t%2) A_odd[k+t] = min(A_odd[k]+1,A_odd[k+t]);\n    }\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << A_odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int SIZE = 181 + 1;\nconst int MAX = 1000000;\n\nint T[SIZE];\nint cost1[MAX], cost2[MAX];\n\nint main( void )\n{\t\n\tfor(int i=0; i < SIZE; ++i) T[i] = i * (i + 1) * (i + 2) / 6;\n\n\tfill(cost1, cost1+MAX, MAX);\n\tfill(cost2, cost2+MAX, MAX + MAX);\n\tcost1[0] = cost2[0] = 0;\n\tfor(int i=0; i < MAX; ++i) {\n\t\t//if(cost1[i] < 6) {\n\t\t\tfor(int j=0; j < SIZE; ++j) {\n\t\t\t\tif(i + T[j] < MAX && cost1[i] < 5)\n\t\t\t\t\tcost1[i + T[j]] = min(cost1[i + T[j]], cost1[i] + 1);\n\t\t\t\tif(T[j] & 1) {\n\t\t\t\t\tif(i + T[j] < MAX)\n\t\t\t\t\t\tcost2[i + T[j]] = min(cost2[i + T[j]], cost2[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n) {\n\t\tcout << cost1[n] << ' ' << cost2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tstatic int p[1000];\n\tfor(int i=0;i<1000;i++)\n\t\tp[i]=(i+1)*(i+2)*(i+3)/6;\n\t\n\tstatic int a[1000001],b[1000001];\n\tfor(int i=0;i<1000001;i++)\n\t\ta[i]=b[i]=i;\n\tfor(int i=0;i<1000;i++){\n\t\tfor(int j=p[i];j<100001;j++)\n\t\t\ta[j]=min(a[j],a[j-p[i]]+1);\n\t\tif(!(p[i]&1)) continue;\n\t\tfor(int j=p[i];j<100001;j++)\n\t\t\tb[j]=min(b[j],b[j-p[i]]+1);\n\t}\n\t\n\tfor(int n;cin>>n,n;)\n\t\tcout<<a[n]<<\" \"<<b[n]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define reps(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint dp[1000000] = {};\nint dp_o[1000000] = {};\nmap<int, int>mp, mp_o;\nint DP(int num) {\n\tif (dp[num] != 0)return dp[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 1;\n\twhile (1) {\n\t\trec = min(DP(mp[cnt]) + DP(num - mp[cnt]), rec);\n\t\tcnt++;\n\t\tif (mp[cnt] > num)break;\n\t}\n\tdp[num] = rec;\n\treturn rec;\n\n}\nint DP_o(int num) {\n\tif (dp_o[num] != 0)return dp_o[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 1;\n\twhile (1) {\n\t\trec = min(DP(mp_o[cnt]) + DP(num - mp_o[cnt]), rec);\n\t\tcnt++;\n\t\tif (mp_o[cnt] > num)break;\n\t}\n\tdp_o[num] = rec;\n\treturn rec;\n\n}\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tll cnt1 = 1, cnt2 = 1;\n\tdp[1] = 1, dp[1] = 1;\n\tmp[1] = 1, mp_o[1] = 1;\n\tint cnt_o = 2;\n\treps(i, 2, 1000001) {\n\t\tcnt1 += i;\n\t\tcnt2 += cnt1;\n\t\tdp[cnt2] = 1;\n\t\tmp[i] = cnt2;\n\t\tif (cnt2 % 2 == 1) {\n\t\t\tdp_o[cnt2] = 1;\n\t\t\tmp[cnt_o] = cnt2;\n\t\t\tcnt_o++;\n\t\t}\n\t}\n\twhile (1) {\n\t\tint Q;\n\t\tcin >> Q;\n\t\tif (Q == 0)break;\n\t\tcout << DP(Q) << \" \";\n\t\tcout << DP_o(Q) << endl;\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nll inf=1e9;\n\nint main() {\n  vector<ll> dpe(1e6+1,inf);\n  vector<ll> dpo(1e6+1,inf);\n  dpe[0]=0;\n  dpo[0]=0;\n  vector<ll> a;\n  for(ll i=1;i*(i+1)*(i+2)/6<dpe.size();i++) {\n    a.push_back(i*(i+1)*(i+2)/6);\n  } \n  for(ll i=0;i<a.size();i++) {\n    if(a[i]%2) {\n      for(ll j=0;j<dpe.size();j++) {\n        if(a[i]+j>dpe.size()-1) break;\n        dpe[j+a[i]]=min(dpe[j+a[i]],dpe[j]+1);\n        dpo[j+a[i]]=min(dpo[j+a[i]],dpo[j]+1);\n      }\n    }\n    else {\n      for(ll j=0;j<dpe.size();j++) {\n        if(a[i]+j>dpe.size()-1) break;\n        dpe[j+a[i]]=min(dpe[j+a[i]],dpe[j]+1);\n      }\n    }\n  }\n  while(1) {\n    ll n;\n    cin >> n;\n    if(n==0) break;\n    cout << dpe[n] << \" \" << dpo[n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nvector<int>nums;\nvector<int>oddnums;\n\nvector<short>memo(1000001,-1);\nvector<short>oddmemo(1000001,-1);\n\nint getans(const int num,const int atime) {\n\tif (memo[num] != -1) {\n\t\treturn memo[num];\n\t}\n\telse {\n\t\tif (num == 0)return memo[num] = 0;\n\t\tif (atime > 10)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <nums.size(); ++i) {\n\t\t\tint minusnum = nums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 10) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getans(num - minusnum, atime + 1)+1);\n\t\t}\n\n\t\treturn memo[num] = ans;\n\t}\n}\nint getoddans(const int num, const int atime) {\n\tif (oddmemo[num] != -1) {\n\t\treturn oddmemo[num];\n\t}\n\telse {\n\t\tif (num == 0)return oddmemo[num] = 0;\n\t\tif (atime > 50)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i < oddnums.size(); ++i) {\n\t\t\tint minusnum = oddnums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 50) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getoddans(num - minusnum, atime + 1) + 1);\n\t\t}\n\t\treturn oddmemo[num] = ans;\n\t}\n\n}\nint main() {\n\tfor (int i = 1; i < 190; ++i) {\n\t\tnums.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (((i*(i + 1)*(i + 2)) / 6) % 2) {\n\n\t\t\n\t\t\toddnums.push_back((i*(i + 1)*(i + 2)) / 6);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tint normalans = getans(n, 0);;\n\t\tint oddans = getoddans(n, 0);\n\n\t\tcout << normalans << \" \" << oddans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define N (int)1e6\nusing namespace std;\n\nint main(){\n  int n,tmp,dp[N+1],dp_odd[N+1];\n  vector<int> plc;\n\n  for(int i=0;i<=N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(int i=1;;i++){\n    plc.push_back(tmp);\n    tmp *= i+3; tmp /= i;\n    if(tmp>N)break;\n  }\n\n  for(int i=(int)plc.size()-1;i>=0;i--){\n    for(int j=0;j+plc[i]<=N;j++){\n      if(dp[j]>N)continue;\n      tmp = j+plc[i];\n      dp[tmp] = min(dp[tmp],dp[j]+1);\n    }\n    if(plc[i]&1){\n      for(int j=0;j+plc[i]<=N;j++){\n\tif(dp_odd[j]>N)continue;\n\ttmp = j+plc[i];\n\tdp_odd[tmp] = min(dp_odd[tmp],dp_odd[j]+1);\n      }\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[100]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<195;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author champon\n */\n\n#include <iostream>\n#include <fstream>\n#include <bits/stdc++.h>\n#define se cout << \"test ok\" << endl;\n#define sp << \" \" <<\n#define enl \"\\n\"\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing vlll = vector<vector<vector<ll>>>;\nusing vc = vector<char>;\nusing vcc = vector<vector<char>>;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nll mod = ll(1e9)+7;\nll inf = ll(1e18);\nvoid bl(bool b, ostream& out=cout){ out << (b ? \"Yes\" : \"No\") << endl; }\nvoid bl2(bool b, ostream& out=cout){ out << (b ? \"YES\" : \"NO\") << endl; }\ntemplate<typename T> inline bool chmax(T &a, T b){ if(a<b){a=b; return true;} return false; }\ntemplate<typename T> inline bool chmin(T &a, T b){ if(a>b){a=b; return true;} return false; }\nint dx[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint dy[] = {0, 1, 0, -1, 1, -1, -1, 1};\n\n#ifndef INCLUDE_DEBUG_HPP\n#define INCLUDE_DEBUG_HPP\n\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nnamespace dbg {\n    using ll = long long;\n\n    class Debug {\n    public:\n        Debug(){}\n        template<typename T>\n        void vd(vector<T> vec);\n        template<typename T>\n        void vd2(vector<vector<T>> vec);\n        template<typename T>\n        void ad(T *arr, ll n);\n        template<typename T, size_t N>\n        void ad2(T (&arr)[N], ll n);\n        template<typename T>\n        void md(T mp);\n    };\n\n    template<typename T>\n    void Debug::vd(vector<T> vec) {\n        for (auto vv : vec) cout << vv << \" \";\n        cout << endl;\n    }\n\n    template<typename T>\n    void Debug::vd2(vector<vector<T>> vec) {\n        for (auto vv : vec) {\n            for (auto vvv : vv) cout << vvv << \" \";\n            cout << endl;\n        }\n    }\n\n    template<typename T>\n    void Debug::ad(T *arr, ll n) {\n        for (int i = 0; i <= n; i++) cout << arr[i] << \" \";\n        cout << endl;\n    }\n\n    template<typename T, size_t N>\n    void Debug::ad2(T (&arr)[N], ll n) {\n        for (int i = 0; i <= N; i++) for (int j = 0; j <= n; j++) cout << arr[i][j] << \" \";\n        cout << endl;\n    }\n\n    template<typename T>\n    void Debug::md(T mp) {\n        cout << \"key : value\" << endl;\n        for (auto const &m : mp) cout << m.first << \" : \" << m.second << endl;\n        cout << endl;\n    }\n\n}\n\n#endif //INCLUDE_DEBUG_HPP\n\nusing dbg::Debug;\nDebug debug;\n\nclass a {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t    int x = 1;\n\t    vl tri, triodd;\n\t    while(x*(x+1)*(x+2) / 6 <= 1000000){\n\t        ll s = x*(x+1)*(x+2)/6;\n\t        tri.push_back(s);\n\t        if(s&1) triodd.push_back(s);\n\t        x++;\n\t    }\n\t    vl dp(1000010, inf);\n\t    vl dpodd(1000010, inf);\n\t    dp[0] = dpodd[0] = 0;\n        for(int j=0; j<tri.size(); j++){\n            for(int i=0; i<1000000; i++){\n                if(i+tri[j] <= 1000000) {\n                    chmin(dp[i+tri[j]],dp[i]+1);\n                }\n                if(i+tri[j] <= 1000000 && tri[j]&1) {\n                    chmin(dpodd[i+tri[j]],dpodd[i]+1);\n                }\n            }\n\t    }\n        while(true) {\n            ll n;\n            in >> n;\n            if(!n) break;\n            out << dp[n] sp dpodd[n] << enl;\n        }\n\t}\n};\n\n\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n\ta solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\n//const int INF = 1107110711071107;\n\nint dp[1000001];\nint dp_odd[1000001];\nint four[300];\nint x;\n\nsigned main() {\n  Rep(i, 210) four[i] = i * (i+1) * (i+2) / 6;\n  \n  Rep(i, 1000001) dp[i] = i;\n  Rrep(i, 2, 300) {\n    Rep(j, 1000001) {\n      if ( j+four[i] <= 1000000 ) {\n\tdp[j+four[i]] = min(dp[j+four[i]], dp[j]+1);\n      }\n    }\n  }\n\n  Rep(i, 1000001) dp_odd[i] = i;\n  Rrep(i, 2, 50) {\n    Rep(j, 1000001) {\n      dp_odd[j] = min(dp_odd[j], dp_odd[j]);\n      if ( j+four[(i-1)*4+1] <= 1000000 ) {\n\tdp_odd[j+four[(i-1)*4+1]] = min(dp_odd[j+four[(i-1)*4+1]], dp_odd[j]+1);\n      }\n    }\n  }\n \n  while ( cin >> x, x ) {\n    cout << dp[x] << \" \" << dp_odd[x] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 2140000000;\nint nums[1000000];\nint nums_k[1000000];\n\nint main(){\n\tint n;\n\tint p;\n\tqueue<int> q, q_k;\n\tfor(int i = 0; i < 1000000; i++){\n\t\tnums_k[i] = INF;\n\t\tnums[i] = INF;\n\t}\n\tfor(int i = 0; i * (i+1) * (i+2) / 6 < 1000000; i++){\n\t\tint j = i*(i+1)*(i+2)/6;\n\t\tnums[j] = 1;\n\t\tq.push(j);\n\t\tif(j % 2 == 1){\n\t\t\tq_k.push(j);\n\t\t\tnums_k[j] = 1;\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tp = q.front();\n\t\tq.pop();\n\t\tfor(int i = 1; i*(i+1)*(i+2)/6 < 1000000-p; i++){\n\t\t\tint j = i*(i+1)*(i+2)/6;\n\t\t\tif(nums[p+j] == INF){\n\t\t\t\tnums[p+j] = nums[p]+1;\n\t\t\t\tq.push(p+j);\n\t\t\t}\n\t\t}\n\t}\n\twhile(!q_k.empty()){\n\t\tp = q_k.front();\n\t\tq_k.pop();\n\t\tfor(int i = 1; i*(i*1)*(i+2)/6 < 1000000-p; i++){\n\t\t\tint j = i*(i+1)*(i+2)/6;\n\t\t\tif(j % 2 == 1 && nums_k[p+j] == INF){\n\t\t\t\tnums_k[p+j] = nums_k[p]+1;\n\t\t\t\tq_k.push(p+j);\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tcout << nums[n] << \" \" << nums_k[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tmemset(dp, 0, sizeof(dp));\n\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=1000000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tdp[i%2][j] = 0;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t}\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tdp[1-i%2][j] = dp[i%2][j];\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint d1[1000001]={},d2[1000001]={};\nint main(){\n\tint n,i=0,j=0;\n\tint pollock1[181]={},pollock2[46]={};\n\tfor(i=1;i*(i+1)*(i+2)/6<1000000;i++){\n\t\tpollock1[i-1]=i*(i+1)*(i+2)/6;\n\t\tif(pollock1[i-1]%2)\n\t\tpollock2[j++]=pollock1[i-1];\n\t}\n\tfor(i=0;i<1000001;i++){\n\t\td1[i]=9999999;\n\t\td2[i]=9999999;\n\t}\n\tfor(i=0;i<180;i++)\n\t\td1[pollock1[i]]=1;\n\tfor(i=0;i<45;i++)\n\t\td2[pollock2[i]]=1;\n\t\n\tfor(i=1;i<1000001;i++){\n\t\tfor(j=0;j<180;j++){\n\t\t\tif(d1[i] && i+pollock1[j]<1000001){\n\t\t\t\td1[i+pollock1[j]]=min(d1[i+pollock1[j]],d1[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<1000001;i++){\n\t\tfor(j=0;j<45;j++){\n\t\t\tif(d2[i] && i+pollock2[j]<1000001){\n\t\t\t\td2[i+pollock2[j]]=min(d2[i+pollock2[j]],d2[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<40;i++){\n\t\tcout<<d1[i]<<' '<<d2[i]<<endl;\n\t}\n\twhile(cin>>n,n){\n\t\tcout<<d1[n]<<' '<<d2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\nint index;\nint fourth[201];\nint odd[201];\nint mintable[1500000];\nint mintableOdd[1500000];\n\nvoid init(){\n\tfourth[0] = 0;\n\todd[0] = 0;\n\tindex = 0;\n\tfor(int i = 1; i <= 200; i++){\n\t\tfourth[i] = (i*(i+1)*(i+2))/6;\n\t\tmintable[fourth[i]] = 1;\n\t\tif(fourth[i]%2){\n\t\t\todd[++index] = fourth[i];\n\t\t\tmintableOdd[odd[index]] = 1;\n\t\t}\n\t}\n}\n\nint dfs(int n){\n\tfor(int i = 2; i <= n/i; i++){\n\t\tif(n%i==0){\n\t\t\treturn min(dfs(n/i)*i, mintable[n]);\n\t\t}\n\t}\n\treturn mintable[n];\n}\n\nint dfsOdd(int n){\n\tfor(int i = 3; i <= n/i; i+=2){\n\t\tif(n%i==0){\n\t\t\treturn min(dfsOdd(n/i)*i, mintableOdd[n]);\n\t\t}\n\t}\n\treturn mintableOdd[n];\n}\n\nint countFourth(int n){\n\tint min = 10000;\n\tfor(int i = 200; i >= 1; i--){\n\t\tif(n>=fourth[i]){\n\t\t\tint tmp = n;\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j >= 1; j--){\n\t\t\t\twhile(tmp>=fourth[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp -= fourth[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = min>count?count:min; \n\t\t}\n\t}\n\treturn min;\n}\n\nint countFourthOdd(int n){\n\tint min = 10000;\n\tfor(int i = index; i >= 1; i--){\n\t\tif(n>=odd[i]){\n\t\t\tint tmp = n;\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j >= 1; j--){\n\t\t\t\twhile(tmp>=odd[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp -= odd[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = min>count?count:min; \n\t\t}\n\t}\n\treturn min;\n}\n\nint main(){\n\tmemset(mintable, 0, sizeof(mintable));\n\tinit();\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(mintable[i]&&mintableOdd[i]) continue;\t\t\n\t\t\tmintable[i] = countFourth(i);\n\t\t\tmintable[i] = dfs(i);\n\t\t\tmintableOdd[i] = countFourthOdd(i);\n\t\t\tmintableOdd[i] = dfsOdd(i);\n\t\t}\n\t\tcout << mintable[n] << \" \" << mintableOdd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n\nint f(int x) {\n  return ((x)*(x+1)*(x+2))/6;\n}\n\nconst int INF = 1 << 28;\nint adp[1000000];\nint odp[1000000];\nbool done[1000000] = {};\nbool odan[1000000] = {};\nvector<int> list;\n\nint main()\n{\n  for(int i = 1; f(i) < 1000000; ++i) {\n    list.push_back(f(i));\n  }\n  rep(i, 1000000) {\n    adp[i] = INF;\n    odp[i] = INF;\n  }\n  done[0] = true;\n  adp[0] = 0;\n  odan[0] = true;\n  odp[0] = 0;\n  for(auto v : list) {\n    rep(i, 1000000 - v) {\n      if(done[i]) {\n        adp[i + v] = min(adp[i + v], adp[i] + 1);\n        done[i + v] = true;\n      }\n      if(v&1 && odan[i]) {\n        odp[i + v] = min(odp[i + v], odp[i] + 1);\n        odan[i + v] = true;\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    cout << adp[n] << \" \" << odp[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nnamespace Solver {\n\n    int N;\n    vector<int> m1, m2;\n    inline bool Read() {\n        cin >> N;\n        return N != 0;\n    }\n\n    inline void PreWork() {\n        m1.resize(1000000, 1000000);\n        m2.resize(1000000, 1000000);\n        m1[0] = m2[0] = 0;\n        for (int i = 1; i < 1000000; i++) {\n            for (int j = 0;; j++) {\n                int vol = vol = ((j * (j + 1) * (j + 2)) / 6);\n                if (i < vol) break;\n                m1[i] = min(m1[i], m1[i - vol] + 1);\n                if (vol % 2 == 1) {\n                    m2[i] = min(m2[i], m2[i - vol] + 1);\n                }\n            }\n        }\n    }\n\n    inline void Work() {\n        cout << m1[N] << \" \" << m2[N] << endl;\n    }\n\n    inline void Solve() {\n        PreWork();\n        while (Read()) Work();\n    }\n}\n\nint main() {\n    Solver::Solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int N = 1000000;\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\nvector<int> mem1, mem2;\n\nvoid calc(vector<int>& v, vector<int>& mem){\n    mem.assign(N, 0); iota(all(mem), 0);\n    rep(i, N)for(int& j: v){\n        if(i < j)break;\n        chmin(mem[i], mem[i-j] + 1);\n    }\n}\n\nvoid init(){\n    vector<int> num, odd;\n    for(int i=1, x=1; x<N; ++i, x=i*(i+1)*(i+2)/6)num.push_back(x);\n    copy_if(all(num), back_inserter(odd), [](int x){return x&1;});\n    calc(num, mem1); calc(odd, mem2);\n}\n\nint main(){\n    init();\n    for(int n; cin >> n, n; cout << mem1[n] << \" \" << mem2[n] << '\\n');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define EPS 1e-8\n\nint dp[2][1000000];\nint data[200];\n\nvoid init(){\n\tfor(int i=1; i<200; i++)data[i-1]=i*(i+1)*(i+2)/6;\n\tdp[0][0]=dp[1][0]=0;\n\tREP(i,1,1000000){\n\t\tdp[0][i] = dp[1][i] = i;\n\t\tfor(int j=0; j<199 && i-data[j]>=0; j++){\n\t\t\tdp[0][i] = min(dp[0][i], dp[0][i-data[j]]+1);\n\t\t\tif( data[j]%2 ){\n\t\t\t\tdp[1][i] = min(dp[1][i], dp[1][i-data[j]]+1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tinit();\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define req(i,r,k) for(int i=k;i<r;i++)\n#define rep(i,r) req(i,r,0)\nconst int INF = 10000;\n\nint dp[1000000];\nint odddp[1000000];\n\nconst long  int h = 180,nmax=1000000;\n\nint main() {\n\n    int n,a,a2;\n\n    vector<int> t;\n    vector<int> oddt;\n\n    req(i,200,1){\n        t.push_back(i * (i+1) * (i+2) / 6);\n        if(t[i-1]%2 == 1){\n            oddt.push_back(t[i-1]);\n        }\n        if(t[i-1] > 1000000) {\n            t.erase(t.end() - 1);\n            break;\n        }\n    }\n\n    rep(i,nmax){\n        dp[i] = INF;\n        odddp[i] = INF;\n    }\n\n    /*rep(i,20){\n        rep(j,41){\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }*/\n\n/*\n    rep(i,oddh){\n        odddp[i][0] = 0;\n    }\n*/\n\n    /*rep(i,oddh){\n        cout << t[i*2] << endl;\n    }*/\n\n    dp[0] = 0;\n    odddp[0] = 0;\n\n\n    rep(i,h){\n        rep(j,nmax){\n            if(j >= t[i]){\n                dp[j] = min(dp[j],dp[j-t[i]] + 1);\n            }\n            else{\n                dp[j] = dp[j];\n            }\n        }\n    }\n\n    int oddh;\n\n    oddh = oddt.size();\n\n    rep(i,oddh){\n        rep(j,nmax){\n            if(j >= oddt[i]){\n                odddp[j] = min(odddp[j],odddp[j-oddt[i]] + 1);\n            }\n            else{\n                odddp[j] = odddp[j];\n            }\n        }\n    }\n\n    while(1){\n\n        cin >> n;\n        if(n==0) break;\n\n\n        printf(\"%d %d\\n\",dp[n],odddp[n]);\n\n        /*if(dp[h-1][n] == INF){\n            rep(i,h){\n                rep(j,namx){\n                    if(j >= t[i]){\n                        dp[i+1][j] = min(dp[i][j],dp[i][j-t[i]] + 1);\n                    }\n                    else{\n                        dp[i+1][j] = dp[i][j];\n                    }\n                }\n            }\n        }\n\n        cout << dp[h-1][n] << ' ';\n         */\n/*\n        if(odddp[oddh-1][n] == INF){\n            rep(i,oddh){\n                rep(j,w){\n                    if(j >= t[i]){\n                        dp[i+1][j] = min(dp[i][j],dp[i][j-t[i]] + 1);\n                    }\n                    else{\n                        dp[i+1][j] = dp[i][j];\n                    }\n                }\n            }\n        }\n\n        cout << odddp[h-1][n] << endl;\n*/\n    }\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[1000001], dp2[1000001];\n\nint nums[200] = {0};\n\nint main(){\n\n    for(int i = 0;i < 200;i++) nums[i] = i * (i + 1) * (i + 2) / 6;\n\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i = 0;i <= n;i++) dp[i] = dp2[i] = 100002;\n        dp[0] = dp2[0] = 0;\n\n        for(int j = 1;nums[j] <= n;j++) {\n            for(int i = nums[j];i <= n;i++) {\n                if(dp[i] > dp[i - nums[j]] + 1) {\n                    dp[i] = dp[i - nums[j]] + 1;\n                }\n            }\n        }\n        for(int j = 1;nums[j] <= n;j++) {\n            for(int i = nums[j];i <= n;i++) {\n                if(dp2[i] > dp2[i - nums[j]] + 1) {\n                    if(nums[j] % 2 == 1) dp2[i] = dp2[i - nums[j]] + 1;\n                }\n            }\n        }\n        cout << dp[n] << ' ' << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n\nusing namespace std;\nstring tmp,str;\nint num,ans[2],n;\n\nstring i2s(int num){\n  string str;\n  stringstream s;\n  s<<num;\n  s>>str;\n  return str;\n}\n  \nvoid dfs(string str,int cnt){\n  if(str.size()==1){\n    ans[cnt%2]=1;\n    return;\n  }\n  tmp=\"\";\n  num=(str[0]-'0')+(str[1]-'0');\n  tmp+=i2s(num);\n  if(str.size()>2)tmp+=str.substr(2,str.size()-2);\n  dfs(tmp,cnt+1);\n}\nint main(){\n  cin>>n;\n  while(n--){\n    ans[0]=ans[1]=0;\n    string str;\n    cin>>str;\n    dfs(str,0);\n    if(!ans[0]) cout<<\"Fabre wins.\"<<endl;\n    else cout<<\"Audrey wins.\"<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint coin[100000];\nint coin_ki[100000];\nint dp[100000];\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    int ans_tmp=0;\n    int ans2_tmp=0;\n\n    \n   \n    int tmp2=0;\n  \n    for(int i=1;i<100000;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    \n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //printf(\"dp[%d]=%d\\n\",i+coin[j],dp[i+coin[j]]);\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n    \n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  ans2_tmp=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  dp2[i+coin_ki[j]]=ans2_tmp;\n\t  //printf(\"dp2[%d]=%d\\n\",i+coin_ki[j],dp[i+coin_ki[j]]);\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n\n    //for(int i=0;i<count;i++)\n      //printf(\"coin[%d]=%d\\n\",i,coin[i]);\n      //for(int i=0;i<count_ki;i++)\n      //printf(\"coin_ki[%d]=%d\\n\",i,coin_ki[i]);\n\n\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <list>\n#include <utility>\n#include <cmath>\nusing namespace std;\nvector<int> v,memo(1000005,999999),memo2(1000005,999999);\nint a;\nint main ()\n{\n\tv.push_back(0);\n\tfor(int i=1;i<=100;i++)\n\t{\n\t\tv.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tmemo[0]=memo2[0]=0;\n\tfor(int i=0;i<=100000;i++)\n\t{\n\t\tfor(int l=0;l<v.size();l++)\n\t\t{\n\t\t\tif(v[l]%2==1)memo2[i+v[l]]=min(memo2[i+v[l]],memo2[i]+1);\n\t\t\tmemo[i+v[l]]=min(memo[i+v[l]],memo[i]+1);\n\t\t}\n\t}\n\t// for(int i=1;i<100;i++)cout<<memo[i]<<\" \"<<memo[i]<<endl;\n\twhile(cin>>a&&a)\n\t{\n\t\tcout<<memo[a]<<\" \"<<memo2[a]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD=1000000007;\n#define INF 1LL<<30\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n\nint dp1[1000010],dp2[1000010];\n\nint main() {\n    vector<int> c,d;\n    int x=1;\n    while((x*(x+1)*(x+2))/6<1000010){\n        int y=(x*(x+1)*(x+2))/6;\n        c.push_back(y);\n        if(y%2==1) d.push_back(y);\n        x++;\n    }\n\n    //rep(i,10) cout<<d[i]<<endl;\n    \n    rep(i,1000010){\n        dp1[i]=INF;\n        dp2[i]=INF;\n    }\n    dp1[0]=0;\n    dp2[0]=0;\n    rep(i,1000010){\n        rep(j,c.size()){\n            if(i+c[j]<1000010) dp1[i+c[j]]=min(dp1[i+c[j]],dp1[i]+1);\n        }\n\n        rep(j,d.size()){\n            if(i+d[j]<1000010) dp2[i+d[j]]=min(dp2[i+d[j]],dp2[i]+1);\n        }\n    }\n\n    while(1){\n        int n;\n        cin>>n;\n        if(n==0) break;\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define NMAX 1000001\nint nm[NMAX],nm2[NMAX];\n\nint main()\n{\n\tint N;\n\tfor(int i=0; i<NMAX; i++)\n\t{\n\t\tnm[i] = nm2[i] = (1<<25);\n\t}\n\tnm[0]=nm2[0]=0;\n\t\n\tfor(int n=1; true; n++)\n\t{\n\t\tint V=n*(n+1)*(n+2)/6;\n\t\tif(V>=NMAX) break;\t\t\n\t\n\t\tfor(int i=V; i<NMAX; i++)\n\t\t{\n\t\t\tnm[i]=min(nm[i],nm[i-V]+1);\n\t\t}\t\n\t}\n\t\n\tfor(int n=1; true; n++)\n\t{\n\t\tint V=n*(n+1)*(n+2)/6;\n\t\tif(V>=NMAX) break;\n\t\t\n\t\tif(V%2==0) continue;\t\t\n\t\n\t\tfor(int i=V; i<NMAX; i++)\n\t\t{\n\t\t\tnm2[i]=min(nm2[i],nm2[i-V]+1);\n\t\t}\t\n\t}\t\n\t\n\twhile(cin >> N, N)\n\t{\t\t\n\t\tcout << nm[N] << \" \" << nm2[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp2[i+coin_ki[j]]=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  tmp=min(dp2[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n#define LL long long\nusing VS = vector<string>;\nusing VI = vector<int>;\nusing VL = vector<LL>;\nusing VVI = vector<VI>;\nusing VVL = vector<VL>;\n#define FOR(i,s,e) for(i = s; i < e; i++)\n#define FORR(i,s,e) for(i = e-1; i >= s; i--)\nconst LL INF = (LL)1e16;\nconst LL MOD = (LL)1e9 + 7;\n\n#define ma 1000000\nLL i,j,s,m,dp[ma],dp_2[ma];\n\nint main(){\n  memset(dp,100,sizeof(dp));\n  memset(dp_2,100,sizeof(dp_2));\n  dp[0] = 0;\n  dp_2[0] = 0;\n  FOR(i,1,181){\n    s = i*(i+1)*(i+2)/6;\n    FOR(j,s,ma){\n      if (dp[j-s]+1 < dp[j]) dp[j] = dp[j-s]+1;\n    }\n    if (s%2){\n      FOR(j,s,ma){\n        if (dp_2[j-s]+1 < dp_2[j]) dp_2[j] = dp_2[j-s]+1;\n      }\n    }\n  }\n  while (1){\n    cin >> m;\n    if (m == 0){\n      return 0;\n    }\n    cout << dp[m] << \" \" << dp_2[m]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= 50; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000\nusing namespace std;\n\nconst int M = 1000000;\nint N, base1[M + 1], base2[M + 2], dp1[M + 1], dp2[M + 1];\n\nint dfs1(int n) {\n  if(dp1[n] >= 0) return dp1[n];\n  if(base1[n]) return dp1[n] = 1;\n\n  int ret = INF;\n  REP(i, 1, n - 1) ret = min(ret, dfs1(i) + dfs1(n - i));\n  return dp1[n] = ret;\n}\n\nint dfs2(int n) {\n  if(dp2[n] >= 0) return dp2[n];\n  if(base2[n]) return dp2[n] = 1;\n\n  int ret = INF;\n  REP(i, 1, n - 1) ret = min(ret, dfs2(i) + dfs2(n - i));\n  return dp2[n] = ret;\n}\n\nint main(void) {\n  REP(i, 1, M) dp1[i] = dp2[i] = -1, base1[i] = base2[i] = 0;\n  for(int i = 1, n; n = i * (i + 1) * (i + 2) / 6, n <= M; i++) {\n    base1[n] = 1;\n    if(n % 2 == 1) base2[n] = 1;\n  }\n\n  while(cin >> N, N) {\n    cout << dfs1(N) << \" \" << dfs2(N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n\n#include<iostream>\n#include<fstream>\n\n#define Max_Len 1000000\n\nusing namespace std;\n\nint triCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (num / 5 < triNum){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > triCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = triCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint oddCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\twhile ((i * (i + 1) * (i + 2) / 6 )% 2 == 0)i--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (i > 0){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > oddCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = oddCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\twhile ((i * (i + 1) * (i + 2) / 6) % 2 == 0)i--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint main(){\n\n\tifstream fin;\n\n\tfin.open(\"input.txt\");\n\n\tint n;\n\n\twhile (true){\n\t\tfin >> n;\n\t\tif (n == 0)break;\n\n\t\tcout << triCalc(n) << \" \" << oddCalc(n) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1001001001;\ntypedef pair<int, int> P;\n\nint d[1000001], d2[1000001];\n\nint main()\n{\n\tint tet[1001];\n\tfor (int i = 1; i <= 1000; i++){\n\t\ttet[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\t\n\tfill(d, d + 1000001, INF);\n\tqueue<P> que;\n\tfor (que.push(P(0, 0)); que.size(); que.pop()){\n\t\tP p = que.front();\n\t\tif (d[p.first] <= p.second) continue;\n\t\td[p.first] = p.second;\n\t\tfor (int i = 1; p.first + tet[i] <= 1000000; i++){\n\t\t\tif (d[p.first + tet[i]] <= p.second + 1) continue;\n\t\t\tque.push(P(p.first + tet[i], p.second + 1));\n\t\t}\n\t}\n\t\n\tfill(d2, d2 + 1000001, INF);\n\twhile (!que.empty()) que.pop();\n\tfor (que.push(P(0, 0)); que.size(); que.pop()){\n\t\tP p = que.front();\n\t\tif (d2[p.first] <= p.second) continue;\n\t\td2[p.first] = p.second;\n\t\t\n\t\tfor (int i = 1; p.first + tet[i] <= 1000000; i++){\n\t\t\tif (tet[i] % 2 == 0) continue;\n\t\t\tif (d2[p.first + tet[i]] <= p.second + 1) continue;\n\t\t\tque.push(P(p.first + tet[i], p.second + 1));\n\t\t}\n\t}\n\t\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tcout << d[n] << \" \" << d2[n] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dpt1[1000001];\nint dpt2[1000001];\nbool dpb1[1000001];\nbool dpb2[1000001];\nint tr[301];\nint sq[301];\n\nint dp1(int s) {\n  if(dpb1[s])\n    return dpt1[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; s-sq[i] >= 0; i++) {\n    r = dp1(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt1[s] = m + 1;\n  dpb1[s] = true;\n  return m + 1;\n}\n\nint dp2(int s) {\n  if(dpb2[s])\n    return dpt2[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; s-sq[i] >= 0; i++) {\n    if(sq[i]%2 == 0)\n      continue;\n    r = dp2(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt2[s] = m + 1;\n  dpb2[s] = true;\n  return m + 1;\n}\n\nint main() {\n\n  for(int i=1; i <= 300; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  dpt1[0] = 0;\n  dpb1[0] = true;\n  dpt2[0] = 0;\n  dpb2[0] = true;\n  int n;\n  while(cin >> n, n) {\n    cout << dp1(n) << \" \" << dp2(n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n\n#include<iostream>\n#include<fstream>\n\n#define Max_Len 1000000\n\nusing namespace std;\n\nint triCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (num / 5 < triNum){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > triCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = triCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint oddCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\twhile ((i * (i + 1) * (i + 2) / 6 )% 2 == 0)i--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (i > 0){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > oddCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = oddCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\twhile ((i * (i + 1) * (i + 2) / 6) % 2 == 0)i--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint main(){\n\n\tint n;\n\n\twhile (true){\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tcout << triCalc(n) << \" \" << oddCalc(n) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ninline int tetrahedral(int n) {\n\treturn n * (n + 1) * (n + 2) / 6;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int MAX = 1000000;\n\tvector<int> dp(MAX, MAX), odd_dp(MAX, MAX);\n\tdp[0] = 0;\n\todd_dp[0] = 0;\n\tfor(int n = 1;; ++n) {\n\t\tconst int tmp = tetrahedral(n);\n\t\tif(tmp >= MAX)\n\t\t\tbreak;\n\n\t\tfor(int i = 0; i + tmp < MAX; ++i)\n\t\t\tchmin(dp[i + tmp], dp[i] + 1);\n\n\t\tif(tmp & 1)\n\t\t\tfor(int i = 0; i + tmp < MAX; ++i)\n\t\t\t\tchmin(odd_dp[i + tmp], odd_dp[i] + 1);\n\t}\n\n\tfor(int x; cin >> x, x;)\n\t\tcout << dp[x] << \" \" << odd_dp[x] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\nvector<int>vec;\nint dp[1000005][2];\nint main(){\n    for(int i=1;;i++){\n        int x = i*(i+1)*(i+2)/6;\n        if(x > 1000000) break;\n        vec.push_back(x);\n    }\n    rep(i,1000005) dp[i][0] = dp[i][1] = 1e9;\n    dp[0][0] = dp[0][1] = 0;\n    for(int i=0;i<vec.size();i++){\n        for(int j=0;j<=1000000;j++){\n            if(j+vec[i] <= 1000000) dp[j+vec[i]][0] = min(dp[j+vec[i]][0],dp[j][0]+1);\n            if(vec[i]%2==1 && j+vec[i] <= 1000000) dp[j+vec[i]][1] = min(dp[j+vec[i]][1],dp[j][1]+1);\n        }\n    }\n    while(1){\n        int n; cin>>n; if(n==0) return 0;\n        cout << dp[n][0] << \" \" << dp[n][1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n;\nint res =inf;\nint solve(int a,int b,int c,vector<int> v){\n  if(b == 0) res = inf;\n//   rep(i,b) cout <<\"\\t\";\n//   cout << a<< \" \" << b << \" \" << v[c]<<endl;\n  if(a == n){\n    res = min(res,b);\n    return b;\n  }\n  if(a > n || res < b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < 1000000){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    cout << solve(0,0,lb1,suqnum) << \" \" << solve(0,0,lb2,odd) << endl;\n//     cout << solve(0,0,lb1,suqnum)<<endl;\n//     cout << solve(0,0,lb2,odd) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tlong int ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX + 1], dp2[MAX + 1];\n\nint main()\n{\n    for (int i = 1; i <= MAX; i++)\n    {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    for (int n = 1; n * (n + 1) * (n + 2) / 6 <= MAX; n++)\n    {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp1[i] = min(dp1[i], dp1[i - a] + 1);\n        }\n        if (a % 2 == 0)\n            continue;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp2[i] = min(dp2[i], dp2[i - a] + 1);\n        }\n    }\n    while (1)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n            break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=1;\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    //int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  //tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  tmp=1;\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    //int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",1,2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::vector;\n\nvector<int> make_table(vector<int> v) {\n    vector<int> dp(1000000, 0);\n    dp[1] = 1;\n    int j;\n    int min;\n    for (int i = 2; i < dp.size(); i++) {\n        j = 0;\n        min = 1e09;\n        while (i >= v[j]) {\n            if (min > dp[i - v[j]]) {\n                min = dp[i - v[j]];\n            }\n            j++; \n        }\n        dp[i] = min + 1;\n    }\n    return dp; \n}\n\nint main(void) {\n    vector<int> all;\n    vector<int> odd;\n\n    int tetra = 0;\n    int times = 1;\n    while (1) {\n        tetra = times * (times + 1) * (times + 2) / 6;\n        all.push_back(tetra);\n        if (tetra % 2 == 1) {\n            odd.push_back(tetra);\n        }\n        times++;\n        if (tetra > 1000000) {\n            break;\n        }\n    }\n    vector<int> dp_all = make_table(all);\n    vector<int> dp_odd = make_table(odd);\n    int input;\n    while (1) {\n        cin >> input;\n        if (input == 0) {\n            break;\n        }\n        cout << dp_all[input] << \" \" << dp_odd[input] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint d1[1000001]={},d2[1000001]={};\nint main(){\n\tint n,i=0,j=0;\n\tint pollock1[181]={},pollock2[46]={};\n\tfor(i=1;i*(i+1)*(i+2)/6<1000000;i++){\n\t\tpollock1[i-1]=i*(i+1)*(i+2)/6;\n\t\tif(pollock1[i-1]%2)\n\t\tpollock2[j++]=pollock1[i-1];\n\t}\n\tfor(i=0;i<1000001;i++){\n\t\td1[i]=9999999;\n\t\td2[i]=9999999;\n\t}\n\tfor(i=0;i<180;i++)\n\t\td1[pollock1[i]]=1;\n\tfor(i=0;i<45;i++)\n\t\td2[pollock2[i]]=1;\n\t\n\tfor(i=1;i<1000001;i++){\n\t\tfor(j=0;j<180;j++){\n\t\t\tif(d1[i] && i+pollock1[j]<1000001){\n\t\t\t\td1[i+pollock1[j]]=min(d1[i+pollock1[j]],d1[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<1000001;i++){\n\t\tfor(j=0;j<45;j++){\n\t\t\tif(d2[i] && i+pollock2[j]<1000001){\n\t\t\t\td2[i+pollock2[j]]=min(d2[i+pollock2[j]],d2[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin>>n,n){\n\t\tcout<<d1[n]<<' '<<d2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[1000001];\n\nint nums[200] = {0};\n\nint main(){\n\n    for(int i = 0;i < 200;i++) nums[i] = i * (i + 1) * (i + 2) / 6;\n\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        for(int j = 1;nums[j] <= n;j++) {\n            for(int i = nums[j];i <= n;i++) {\n                if(i - nums[j] >= 0) {\n                    dp[i] = min(dp[i], dp[i - nums[j]] + 1);\n                }\n            }\n        }\n\n        cout << dp[n] << ' ';\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        int num = 0;\n        int j = 0;\n        for(int j = 1;nums[j] <= n;j++) {\n            if(nums[j] % 2 != 1) continue;\n            //cout << num << endl;\n            for(int i = nums[j];i <= n;i++) {\n                if(i - nums[j] >= 0) {\n                    dp[i] = min(dp[i], dp[i - nums[j]] + 1);\n                }\n                //cout << dp[i] << ' ';\n            }\n            //cout << endl;\n        }\n\n        cout << dp[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define EPS (1e-7)\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////////////////////\n\nll dfs(string S) {\n  int N = S.size();\n  if (S[1] != '[') {\n    ll k = stoll(S.substr(1,N-2));\n    return k / 2 + 1;\n  }\n  int count = 0;\n  vector<ll> A;\n  string t = \"\";\n  for (int i = 1; i < N-1; i++) {\n    if (S[i] == '[') count++;\n    if (S[i] == ']') count--;\n    t.push_back(S[i]);\n    if (count == 0) {\n      A.emplace_back(dfs(t));\n      t = \"\";\n    }\n  }\n  sort(all(A));\n  ll y = 0;\n  rep(i,A.size() / 2 + 1) y += A[i];\n  return y;\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(nullptr); //入出力高速化\n  vector<int> sum = {1};\n  int k = 0;\n  while (sum[k] <= 1000000) {\n    sum.emplace_back(sum[k] + (k+2));\n    k++;\n  }\n\n  vector<int> four{1};\n  k = 0;\n  while (four[k] <= 1000000) {\n    four.emplace_back(four[k] + sum[k+1]);\n    k++;\n  }\n\n  int N = four.size();\n  vector<int> dp(1000001,INF);\n  dp[0] = 0;\n  for (int i = 1; i <= 1000000; i++) {\n    rep (j,N) {\n      if (i < four[j]) continue;\n      chmin(dp[i],dp[i-four[j]] + 1); \n    }\n  }\n\n  vector<int> odd(1000001,INF);\n  odd[0] = 0;\n  for (int i = 1; i <= 1000000; i++) {\n    rep(j,N) {\n      if (four[j] % 2 == 0) continue;\n      if (i < four[j]) continue;\n      chmin(odd[i],odd[i - four[j]] + 1);\n    }\n  }\n\n  while (true) {\n    int n; cin >> n;\n    if (n == 0) break;\n    cout << dp[n] << \" \" << odd[n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint p[200],q[50];\n\nint f(int n,int m,int c){\n\tif(c==4&&n>0)return 5;\n\tif(n<10)return min(c+n/4+n%4,5);\n\tint rec=5,i=0;\n\twhile(p[i]<n/(4-c))i++;\n\tfor(i;p[i]<=m;i++)rec=min(rec,f(n-p[i],min(p[i],n-p[i]),c+1));\n\treturn rec;\n}\n\nint g(int n,int m,int c,int *M){\n\tif(c==*M)return *M;\n\tif(n<165)return c+n/35+n%35;\n\tint i=44;\n\twhile(q[i]>m)i--;\n\tfor(i;i>0;i--){\n\t\t*M=min(*M,g(n-q[i],min(q[i],n-q[i]),c+1,M));\n\t}\n\treturn *M;\n}\n\nint main(){\n\tfor(int i=0;(i+1)*(i+2)*(i+3)/6<=1000000;i++)p[i]=(i+1)*(i+2)*(i+3)/6;\n\tfor(int i=0;(4*i+1)*(4*i+2)*(4*i+3)/6<=1000000;i++)q[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\tint N;\n\twhile(cin>>N){\n\t\tif(!N)return 0;\n\t\tint ans=9999;\n\t\tcout<<f(N,N,0)<<\" \"<<g(N,N,0,&ans)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint d[182] = {} ;\nint D[182] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<182 ; i++ ){\n\t\td[i] = d[i-1] + i ;\n\t\tD[i] = D[i-1] + d[i] ;\n\t}\n}\n\nint cal_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse return x/D[c] + cal_2( x%D[c] , c-1 ) ;\n}\n\nint cal( int m , int q ){\n\tint ans = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans = min( ans , cal_2( m , j ) ) ;\n\t}\n\treturn ans ;\n}\n\nint cal_odd( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( D[c]%2 == 0 ) return cal_odd( x , c-1 ) ;\n\t\telse return x/D[c] + cal_odd( x%D[c] , c-1 ) ;\n\t}\n}\n\nvoid dp(){\n\tint p = 1 ;\n\t\n\tfor( int i=1 ; i<=1000000 ; i++ ){\n\t\tif( i < 182 && i >= D[p] ) p++ ;\n\t\tdp_map[0][i] = cal(i,p) ;\n\t\tdp_map[1][i] = cal_odd(i,p) ;\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvi tetra, odd_tetra;\nvi table(1000001, INF), dp(1000001, INF);\n\nvoid make_tetra();\nvoid make_odd_tetra();\n\n\nsigned main()\n{\n    make_tetra();\n    make_odd_tetra();\n\n    Int(n);\n\n    while (n) {\n        cout << dp[n] << \" \" << table[n] << endl;\n        cin >> n;\n    }\n\n    return 0;\n}\n\n\nvoid make_tetra()\n{\n    Rep(i, 181) {\n        tetra.pb(i * (i + 1) * (i + 2) /6);\n    }\n    dp[0] = 0;\n    Rep(x, 1000000) {\n        int ret = INF;\n        for (int i : tetra) {\n            if (x < i) {\n                break;\n            } else {\n                ret = min(ret, dp[x - i] + 1);\n            }\n        }\n        dp[x] = ret;\n    }\n}\n\nvoid make_odd_tetra()\n{\n    for (int i : tetra) {\n        if (i % 2) {\n            odd_tetra.pb(i);\n            table[i] = 1;\n        }\n    }\n    table[0] = 0;\n    Rep(x, 1000000) {\n        int ret = INF;\n        for (int i : odd_tetra) {\n            if (x < i) {\n                break;\n            } else {\n                ret = min(ret, table[x - i] + 1);\n            }\n        }\n        table[x] = ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1001001001;\ntypedef pair<int, int> P;\n\nint d[1000001], d2[1000001];\n\nint main()\n{\n\tint tet[1001];\n\tfor (int i = 1; i <= 1000; i++){\n\t\ttet[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\t\n\tfill(d, d + 1000001, INF);\n\tqueue<P> que;\n\tfor (que.push(P(0, 0)); que.size(); que.pop()){\n\t\tP p = que.front();\n\t\tif (d[p.first] <= p.second) continue;\n\t\td[p.first] = p.second;\n\t\tfor (int i = 1; p.first + tet[i] <= 1000000; i++){\n\t\t\tque.push(P(p.first + tet[i], p.second + 1));\n\t\t}\n\t}\n\t\n\tfill(d2, d2 + 1000001, INF);\n\twhile (!que.empty()) que.pop();\n\tfor (que.push(P(0, 0)); que.size(); que.pop()){\n\t\tP p = que.front();\n\t\tif (d2[p.first] <= p.second) continue;\n\t\td2[p.first] = p.second;\n\t\t\n\t\tfor (int i = 1; p.first + tet[i] <= 1000000; i++){\n\t\t\tif (tet[i] % 2 == 0) continue;\n\t\t\tque.push(P(p.first + tet[i], p.second + 1));\n\t\t}\n\t}\n\t\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tcout << d[n] << \" \" << d2[n] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\n#define MAX 1000000\n\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nint dp1[MAX * 2 + 1], dp2[MAX * 2 + 1];\n\nint main(){\n  \n  fill_n(dp1, MAX * 2 + 1, INF);\n  fill_n(dp2, MAX * 2 + 1, INF);\n  vector< int > num;\n  for(int i = 1; i <= 185; i++) {\n    num.push_back(i * (i + 1) * (i + 2) / 6);\n    dp1[num[num.size() - 1]] = 1;\n    if((i * (i + 1) * (i + 2) / 6) % 2) \n      dp2[num[num.size() - 1]] = 1;\n  }\n\n  for(int i = 1; i <= MAX; i++) {\n    for(int j = 0; j < num.size() && i + num[j] <= MAX; j++) {\n      dp1[i + num[j]] = min(dp1[i] + 1, dp1[i + num[j]]);\n    }\n  }\n \n  for(int i = 1; i <= MAX; i++) {\n    for(int j = 0; j < num.size() && i + num[j] <= MAX; j++) {\n      if(num[j] % 2) dp2[i + num[j]] = min(dp2[i] + 1, dp2[i + num[j]]);\n    }\n  }\n\n  int N;\n  while(cin >> N, N) {\n    cout << dp1[N] << \" \" << dp2[N] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\nconst int MAX = 1000005;\n\nint main() {\n  vector<int> dp(MAX, INF), odddp(MAX, INF);\n  dp[0] = 0;\n  odddp[0] = 0;\n  for (int i = 1;; ++i) {\n    int w = i * (i+1) * (i+2) / 6;\n    if (w >= MAX) break;\n    FOR(j, w, MAX) {\n      dp[j] = min(dp[j], dp[j-w] + 1);\n      if (w & 1) odddp[j] = min(odddp[j], odddp[j-w] + 1);\n    }\n  }\n\n  int n;\n  while (cin >> n) {\n    if (n == 0) break;\n    cout << dp[n] << \" \" << odddp[n] << endl;\n  }\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<string>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<iomanip>\n#include<cctype>\n#include<map>\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rep2(i,a,b) for (int (i)=a;(i)<(b);(i)++)\n#define all(x) (x).begin(),(x).end()\n\nusing namespace std;\nconst int inf = 1001001000;\n\nvoid print(vector<vector<int>> a){\n\tfor (int i=0;i<a.size();i++){\n\t\tfor (int j=0;j<a[i].size();j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print(vector<vector<long long int>> a){\n\tfor (int i=0;i<a.size();i++){\n\t\tfor (int j=0;j<a[i].size();j++){\n\t\t\tcout << a[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid print(vector<int> a){\n    int n = a.size();\n    for (int j=0;j<n;j++) {\n        if (j != n-1) cout << a[j] << \" \";\n        else cout << a[j] << endl;\n    }\n}\n\nint main(){\n\tint m = 1000000 + 10;\n\t\tvector<int> p;\n\t\tfor (int i = 0;;i++){\n\t\t\tp.push_back(i * (i + 1) * (i + 2) / 6);\n\t\t\tif (i * (i + 1) * (i + 2) / 6 > m)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvector<int> dp(m, inf);\n\t\tdp[0] = 0;\n\t\tvector<int> odd_dp(m, inf);\n\t\todd_dp[0] = 0;\n\t\trep(i, p.size())\n\t\t{\n\t\t\trep(j,m){\n\t\t\t\tif (j - p[i] >= 0)\n\t\t\t\t\tdp[j] = min(dp[j], dp[j - p[i]] + 1);\n\t\t\t\tif (p[i] % 2 == 1){\n\t\t\t\t\tif (j - p[i] >= 0)\n\t\t\t\t\t\todd_dp[j] = min(odd_dp[j], odd_dp[j - p[i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tcout << dp[n] << \" \" << odd_dp[n] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n   // cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tstatic int num[1000001],odd[1000001];\n\tvector<int> pol,podd;\n\tfor(int i = 0;i <= 1000000;i++) odd[i] = i;\n\tfor(int i = 1;;i++){\n\t\tint p = i * (i + 1) * (i + 2) / 6;\n\t\tif(p > 1000000) break;\n\t\tpol.push_back(p);\n\t\tnum[p] = 1;\n\t\tif(p % 2) podd.push_back(p);\n\t}\n\tfor(int i = 1;i <= 4;i++){\n\t\tfor(int j = 0;j <= 1000000;j++){\n\t\t\tif(num[j] == i){\n\t\t\t\tfor(int k = 0;k < pol.size();k++){\n\t\t\t\t\tif(j + pol[k] <= 1000000) {\n\t\t\t\t\t\tif(!num[j + pol[k]]) num[j + pol[k]] = i + 1;\n\t\t\t\t\t\telse num[j + pol[k]] = min(num[j + pol[k]],i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= podd.size();i++){\n\t\tfor(int j = 0;j <= 1000000;j++){\n\t\t\tif(j + podd[i] > 1000000) break;\n\t\t\todd[j + podd[i]] = min(odd[j + podd[i]],odd[j] + 1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n,n){\n\t\tcout << num[n] << \" \" << odd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1];\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=2;val<=1000000;i++){\n    for(int j=0;j+val<=1000000;j++){\n      dp[0][j+val] = min(dp[0][j+val],dp[0][j] + 1);\n      if(val&1)dp[1][j+val] = min(dp[1][j+val],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  int n;\n  while(cin >> n,n)cout << dp[0][n] << \" \" << dp[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS 1e-9\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nint main() {\n\tvi num(180);\n\trep(i, 180) {\n\t\tnum[i] = (i + 1)*(i + 2)*(i + 3) / 6;\n\t}\n\tint N = 1000001;\n\tvi ans1(N), ans2(N);\n\trep(i, N) {\n\t\tans1[i] = ans2[i] = i;\n\t}\n\t\n\trepl(i, 1, 180) {\n\t\trepl(j, num[i], N) {\n\t\t\tans1[j] = min(ans1[j], ans1[j - num[i]] + 1);\n\t\t}\n\t}\n\trepl(i, 1, 180 / 4) {\n\t\trepl(j, num[4 * i], N) {\n\t\t\tans2[j] = min(ans2[j], ans2[j - num[4 * i]] + 1);\n\t\t}\n\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tcout << ans1[n] << \" \" << ans2[n] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends\n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end())\n#define MAX(vec) *max_element(vec.begin(), vec.end())\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define INARR(h,w,x,y) (0 <= y && y < h && 0 <= x && x < w)\n\nusing namespace std;\nconstexpr int dx[4] = {0,1,0,-1};\nconstexpr int dy[4] = {1,0,-1,0};\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<LL> VL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<bool> VB;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\n\nint main(void) {\n\tlong lim = 400;\n\tVL seq1(400),seq2;\n\tREP(i,400) {\n\t\tseq1[i] = (i * (i+1) * (i+2) / 6);\n\t\tif (seq1[i]%2) seq2.push_back((i * (i+1) * (i+2) / 6));\n\t}\n\tVI dp(1000000,loINF),dp2(1000000,loINF);\n\tdp[0] = dp2[0] = 0;\n\tREP(i,400) FOR(j,seq1[i],1000000) {\n\t\tdp[j] = min(dp[j],dp[j-seq1[i]]+1);\n\t}\n\tREP(i,seq2.size()) {\n\t\tFOR(j,seq2[i],1000000) {\n\t\t\tdp2[j] = min(dp2[j],dp2[j-seq2[i]]+1);\n\t\t}\n\t}\n\tlong n;\n\twhile (1) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nconst int MAX_N = 1000000;\nconst int INF = 10000000;\n\nint main() {\n  vector<int> simen, odd_simen;\n\n  int n = 1, nv = 1;\n  while (nv <= MAX_N) {\n    simen.push_back(nv);\n    if (nv % 2 == 1) odd_simen.push_back(nv);\n    n++;\n    nv = n*(n+1)*(n+2) / 6;\n  }\n  vector<int> dp(MAX_N + 1, INF);\n  vector<int> odd_dp(MAX_N + 1, INF);\n  dp[0] = odd_dp[0] = 0;\n\n  for (int i = 1; i <= MAX_N; i++) {\n    for(int j = 0; j < simen.size(); j++) {\n      if (i < simen[j]) break;\n      dp[i] = min(dp[i], dp[i - simen[j]] + 1);\n    }\n    for(int j = 0; j < odd_simen.size(); j++) {\n      if (i < odd_simen[j]) break;\n      odd_dp[i] = min(odd_dp[i], odd_dp[i - odd_simen[j]] + 1);\n    }\n  }\n\n  cout << nv << endl;\n  while (true) {\n    int m;\n    cin >> m;\n    if (m == 0) break;\n\n    cout << dp[m] << \" \" << odd_dp[m] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dps[190][1000010] = { 0 };\nvector<vector<int>> dp;\n\nint N = 0;\nint C[190];\nint Codd[50];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp.resize(C_N);\n\t\tfor (int i = 0; i < C_N; i++) {\n\t\t\tdp[i].resize(N);\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\n\t\tdp.clear();\n\t\tdp.shrink_to_fit();\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n\n#define ll long long\n#define inf  1000000007\n#define mod 1000000007\n#define pa pair<int,int>\n#define pal pair<ll,ll>\n#define ppa pair<int,pa>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y) {}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double a) {return Point(x*a,y*a);}\n  Point operator / (double a) {return Point(x/a,y/a);}\n  double absv() {return sqrt(norm());}\n  double norm() {return x*x+y*y;}\n  bool operator < (const Point &p) const{\n    return x != p.x ? x<p.x: y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\ndouble hen(Vector a){\nif(fabs(a.x)<EPS && a.y>0) return acos(0);\nelse if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\nelse if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\nelse if(fabs(a.y)<EPS && a.x>0) return 0.0;\nelse if(a.y>0) return acos(a.x/a.absv());\nelse return 2*acos(0)+acos(-a.x/a.absv());\n\n}\n\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ru[11]={1,2,4,8,16,32,64,128,256,512,1024};\n\nll frac[100010];\nll inv[100010];\n\nll saikif(ll a,int n){\n  if(n==1) return a%mod;\n  else if(n%2==0){\n    ll q=saikif(a,n/2);\n    return (q*q)%mod;\n  }\n  else return (a*saikif(a,n-1))%mod;\n}\n\nvoid gyakugen(){\n  frac[0]=1;\n  for(int i=1;i<=100000;i++) frac[i]=(frac[i-1]*i)%mod;\n  for(int i=0;i<=100000;i++) inv[i]=saikif(frac[i],mod-2);\n}\n\n\n//----------------kokomade temple------------\nint dp[1000002];\nint dp2[1000002];\nvector<int> ve;\nvector<int> ve2;\nint num,num2;\n\nint dfs(int n){\nif(dp[n]<inf) return dp[n];\nelse{\n//  cout<<n<<endl;\n  int ans=inf;\nfor(int j=0;j<num;j++){\n  if(ve[j]>=n) break;\n\n  ans=min(ans,1+dfs(n-ve[j]));\n}\n  dp[n]=ans;\n  return ans;\n}\n\n}\n\nint dfs2(int n){\nif(dp2[n]<inf) return dp2[n];\nelse{\n//  cout<<n<<endl;\n  int ans=inf;\nfor(int j=0;j<num2;j++){\n  if(ve2[j]>=n) break;\n\n  ans=min(ans,1+dfs2(n-ve2[j]));\n}\n  dp2[n]=ans;\n  return ans;\n}\n\n}\n\n\n\nint main(){\n  fill(dp,dp+1000002,inf);\n  fill(dp2,dp2+1000002,inf);\nint z=1,w;\nwhile(1){\n  w=z*(z+1)*(z+2)/6;\n  //cout<<w<<endl;\n  if(w>1000000) break;\n  else{\n    ve.push_back(w);\n    if(w%2==1){\n      ve2.push_back(w);\n      dp2[w]=1;\n    }\n    z++;\n    dp[w]=1;\n\n  }\n}\nnum=ve.size();\nnum2=ve2.size();\nfor(int i=1;i<1000001;i++){\n  dfs(i);\n  dfs2(i);\n}\n\nint n;\n\nwhile(cin>>n){\n  if(n==0) break;\n  cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[1000010]={0};\nint dp2[1000010]={0};\nint List[200];\n\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<1000000;i++){\n\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tfor(i=1;i<1000000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint dp[1000001],Odp[1000001];\nint Tn[200],OTn[200]; \nint n = 1000000;\n\nint main(){\n    int count = 0;  //pollocks numberの生成\n    for(int i = 1;i < 200;i++){\n        Tn[i-1] = i * (i + 1) * (i + 2) / 6;\n        if(Tn[i-1] % 2 == 1){\n            OTn[count] = Tn[i-1];\n            count++;\n        }\n    }\n\n    //個数の初期化\n    for(int j = 0;j <= n;j++){\n        dp[j] = j;\n        Odp[j] = j;\n    }\n    \n    for(int i = 0;i < 200;i++){\n        for(int j = OTn[i];j <= n;j++){    //奇数正四面体数の個数の最小値\n            if(j >= OTn[i])\n                Odp[j] = min(Odp[j],Odp[j-OTn[i]] + 1);\n        }\n        for(int j = Tn[i];j <= 1000000;j++){    //正四面体数の個数の最小値\n            if(j >= Tn[i])\n                dp[j] = min(dp[j],dp[j-Tn[i]] + 1);\n        }\n    }\n\n    //入出力\n    while(cin >> n,n)\n        cout << dp[n] << ' ' <<  Odp[n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nvector<int> tetra;\nvector<int> tetra_odd;\n\nshort dp[MAX_N+1];\nshort dp_odd[MAX_N];\n\nvoid init() {\n\tint n = 1;\n\twhile (true){\n\t\tint m = n * (n + 1) * (n + 2) / 6;\n\t\tif (m >= MAX_N * 10) {\n\t\t\tbreak;\n\t\t}\n\t\ttetra.push_back(m);\n\t\tif (m % 2 == 1) {\n\t\t\ttetra_odd.push_back(m);\n\t\t}\n\t\tn++;\n\t}\n}\n\nvoid solve() {\n\tdp[0] = dp_odd[0] = 0;\n\tfor (int i = 1; i < MAX_N; i++) {\n\t\tshort ans = 10;\n\t\tshort ans_odd = 100;\n\t\tfor (int j = 0; tetra[j] <= i; j++) {\n\t\t\t//cout << i << \" \" << tetra[j] << endl;\n\t\t\tans = min(ans, dp[i-tetra[j]]);\n\t\t}\n\t\t\n\t\tfor (int j = 0; tetra_odd[j] <= i; j++) {\n\t\t\tans_odd = min(ans_odd, dp_odd[i-tetra_odd[j]]);\n\t\t}\n\t\tdp[i] = ans + 1;\n\t\tdp_odd[i] = ans_odd + 1;\n\t\t//cout << i << \" \" << dp[i] << \" \" << dp_odd[i] << endl;\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcout << dp[n] << \" \" << dp_odd[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[1000000], dp2[1000000];\nint main() {\n\tv.pb(0);\n\tll n, now = 1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)i*(i + 1)*(i + 2) / 6;\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 100000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 100000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], i / v[j] + dp2[i%v[j]]);\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define int long long\n#define ALL(x) (x).begin(),(x).end()\ntypedef pair<int, int> pii;\n\n\n\nvector<int>v,v_even;\nint dp[1000010],dp_even[1000010];\nint calc(int n){\n    return n*(n+1)*(n+2)/6;\n}\n\nint rec(int n){\n    if(n==0)return 0;\n    if(dp[n])return dp[n];\n    else{\n        int res = 1e9;\n        for(auto x:v){\n            if(x>n)break;\n            res=min(res,rec(n-x)+1);\n        }\n        return dp[n]=res;\n    }\n}\nint rec_even(int n){\n    if(n==0)return 0;\n    if(dp_even[n])return dp_even[n];\n    else{\n        int res = 1e9;\n        for(auto x:v_even){\n            if(x>n)break;\n            res=min(res,rec_even(n-x)+1);\n        }\n        return dp_even[n]=res;\n    }\n\n}\nvoid solve() {\n    for(int i=1;i<10000;i++){\n        int num=calc(i);\n        if(calc(i)>=1e6){\n            break;\n        }\n        else{\n            v.push_back(num);\n            if(num&1)v_even.push_back(num);\n        }\n    }\n    while(true){\n        int n;cin>>n;\n        if(n==0)exit(0);\n        cout<<rec(n)<<\" \"<<rec_even(n)<<endl;\n    }\n}\n\nsigned main() {\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define _GLIBCXX_DEBUG\n#define all(v) (v).begin(),(v).end()\n\nusing namespace std;\n\nusing ll=long long;\nusing pii=pair<int, int>;\nusing vi=vector<int>;\n\nconst ll LINF=(1LL<<60);\nconst int INF=1<<29;\nconst int MOD=1e9+7;\n\ntemplate <typename T>\nbool chmin(T &a, const T &b){\n    if(a > b){\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nvi num;\n\nvoid make_num(int n){\n    int i=1, val;\n    while(1){\n        val=i*(i+1)*(i+2)/6;\n        if(val > n) break;\n        num.push_back(val);\n        i++;\n    }\n}\n\nint main(){\n    int n;\n    make_num(1000000);\n    vi dp1(1000001, INF);\n    dp1[0]=0;\n    for(int i=1; i<=1000000; i++){\n        for(auto &m : num){\n            if(m <= i){\n                chmin(dp1[i], dp1[i-m]+1);\n            }\n        }\n    }\n    vi dp2(1000001, INF);\n    dp2[0]=0;\n    for(int i=1; i<=1000000; i++){\n        for(auto &m : num){\n            if(m <= i && m%2 == 1){\n                chmin(dp2[i], dp2[i-m]+1);\n            }\n        }\n    }\n    while(cin >> n){\n        if(n == 0) break;\n        printf(\"%d %d\\n\", dp1[n], dp2[n]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int MAX_V=1000010;\nunsigned int dp[MAX_V]{};\nunsigned int dpodd[MAX_V]{};\nset<int> tetras{-1};\nset<int> oddtetras{-1};\nint main(){ _;\n  int n;\n  for(int i=1;;i++){\n    int k=i*(i+1)*(i+2)/6;\n    if(k>MAX_V)break;\n    tetras.insert(k);\n    if((k>>1)<<1!=k)//odd\n      oddtetras.insert(k);\n  }\n  for(int i=1;i<MAX_V;i++){\n    auto tetra=tetras.upper_bound(i);\n    int j=*(--tetra);\n    int k=*(--tetra);\n    dp[i]=k<0?dp[i-j]+1:min(dp[i-j],dp[i-k])+1;\n    auto oddtetra=oddtetras.upper_bound(i);\n    j=*(--oddtetra);\n    k=*(--oddtetra);\n    dpodd[i]=k<0?dpodd[i-j]+1:min(dpodd[i-j],dpodd[i-k])+1;\n  }\n  while(cin>>n,n!=0){\n    cout<<dp[n]<<\" \"<<dpodd[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<map>\nusing namespace std;\nint a[1001],ta[1001],tta[1001];\nint dp[1000021];\nconst int INF=99999999;\nint main(){\n\ta[1]=1,ta[1]=1,tta[1]=1;\n\tint cnt=1;\n\tfor(int i=2;i<=1000;i++)a[i]=i+a[i-1];\n\tfor(int i=2;i<=1000;i++){\n\tta[i]=a[i]+ta[i-1];\n\tif(ta[i]%2==1)tta[++cnt]=ta[i];\n\t}\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tta[1]=1;\n\tint am=0,bm=0;\n\tfor(int i=0;i<200;i++)\t{if(n<=ta[i]){am=ta[i];break;}}\n\tfor(int i=0;i<100;i++){if(n<=tta[i]){bm=tta[i];break;}}\n\tfill(dp+1,dp+1000021,INF);\n\tfor(int i=0;i<=am;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\tif(j>=ta[i])dp[j]=min(dp[j],dp[j-ta[i]]+1);\n\t\t}\n\t}//endfor\n\tcout<<dp[n]<<\" \";\n\tfill(dp+1,dp+1000021,INF);\n\tfor(int i=0;i<=bm;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\tif(j>=tta[i])dp[j]=min(dp[j],dp[j-tta[i]]+1);\n\t\t}\n\t}//endfor\n\tcout<<dp[n]<<endl;\n\t}//endwhile\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Problem 44\n    https://onlinejudge.u-aizu.ac.jp/problems/1167\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\ntypedef pair<int, int> pii;\n/* constant */\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 50;\nconst int NIL = -1;\nconst int MAX = 1000005;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\nvector<int> dpAll(MAX, INF), dpOdd(MAX, INF);\nvector<int> sqAll, sqOdd;\n/* function */\nint calcSq(int x) { return x * (x+1) * (x+2) / 6; }\nvoid initSq() {\n    for (int i = 1; i < MAX; i++) {\n        int cost = calcSq(i);\n        if (cost >= MAX) break;\n        sqAll.push_back(cost);\n        if (cost % 2 == 1)\n            sqOdd.push_back(cost);\n    }\n}\nvoid calcDP() {\n    dpAll[0] = 0;\n    for (int i = 0; i < sqAll.size(); i++) {\n        for (int j = sqAll[i]; j < MAX; j++) {\n            dpAll[j] = min(dpAll[j], dpAll[j-sqAll[i]] + 1);\n        }\n    }\n    dpOdd[0] = 0;\n    for (int i = 0; i < sqOdd.size(); i++) {\n        for (int j = sqOdd[i]; j < MAX; j++) {\n            dpOdd[j] = min(dpOdd[j], dpOdd[j-sqOdd[i]] + 1);\n        }\n    }\n}\nint calcAll(int m) { return dpAll[m]; }\nint calcOdd(int m) { return dpOdd[m]; }\n/* main */\nint main(){\n    vector<int> query;\n    while (1) {\n        int q; cin >> q;\n        if (q == 0) break;\n        query.push_back(q);\n    }\n    initSq();\n    calcDP();\n    for (int q : query)\n        cout << calcAll(q) << ' ' << calcOdd(q) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[84];\n    int b[22];\n    int t[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\n\n\nint main() {\n\t\n\tvi nums;\n\tvi nums2;\n\n\tFOR(i, 1, 1000) {\n\t\tint num = i*(i + 1)*(i + 2) / 6;\n\t\tif (num > 1000000)\n\t\t\tbreak;\n\t\tnums.push_back(num);\n\t\tif (num % 2 == 1)\n\t\t\tnums2.push_back(num);\n\t}\n\t\n\tvi dp(1000000);\n\tvi dp2(1000000);\n\t\n\tREP(i, 1000000) {\n\t\tdp[i] = 1000000;\n\t\tdp2[i] = 1000000;\n\t}\n\tREP(i, nums.size())\n\t\tdp[nums[i]] = 1;\n\tREP(i, nums2.size())\n\t\tdp2[nums2[i]] = 1;\n\n\tFOR(i, 2, 1000000) {\n\t\tREP(j, nums.size())\n\t\t\tif (i - nums[j] > 0)\n\t\t\t\tdp[i] = min(dp[i], dp[i - nums[j]] + 1);\n\t\t\telse\n\t\t\t\tbreak;\n\t\tREP(j, nums2.size())\n\t\t\tif (i - nums2[j] > 0)\n\t\t\t\tdp2[i] = min(dp2[i], dp2[i - nums2[j]] + 1);\n\t\t\telse\n\t\t\t\tbreak;\n\t}\n\t\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << ' ' << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\nint dp[1000010];\nint dp2[1000010];\n\nint main(int argc, char const* argv[])\n{\n  dp[0] = dp2[0] = 0;\n  FOR(i, 1, 1000001){\n    dp[i] = inf;\n    dp2[i] = inf;\n    rep(j, 300){\n      int k = j * (j + 1) * (j + 2) / 6;\n      if(i-k>=0)chmin(dp[i], dp[i-k] + 1);\n      if(i-k>=0&&k%2==1)chmin(dp2[i], dp2[i-k] + 1);\n    }\n  }\n  int n;\n  while(cin >> n){\n    if(n == 0)break;\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#define N 1000000\n\nusing namespace std;\n\nint main(){\n\tvector<int> sq;\n\tvector<int> sqodd;\n\tint a[N];\n\tint aodd[N];\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++)  sq.push_back((i * (i + 1) * (i + 2)) / 6);\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++){\n\t\tif(((i * (i + 1) * (i + 2)) / 6) % 2)\n\t\t \tsqodd.push_back((i * (i + 1) * (i + 2)) / 6);\n\t}\n\tfor(int i = 0; i < N; i++) a[i] = N;\n\tfor(int i = 0; i < N; i++) aodd[i] = N;\n\tfor(int i = 0; i < sq.size(); i++) a[sq[i]] = 1;\n\tfor(int i = 0; i < sqodd.size(); i++) aodd[sqodd[i]] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tif(a[i] == N) continue;\n\t\tfor(int j = 0; j < sq.size(); j++){\n\t\t\tif(sq[j] + i < N && a[sq[j] + i] > a[i] + 1) a[sq[j] + i] = a[i] + 1;\n\t\t}\n\t}\n\tfor(int i = 1; i < N; i++){\n\t\tif(aodd[i] == N) continue;\n\t\tfor(int j = 0; j < sqodd.size(); j++){\n\t\t\tif(sqodd[j] + i < N && aodd[sqodd[j] + i] > aodd[i] + 1) aodd[sqodd[j] + i] = aodd[i] + 1;\n\t\t}\n\t}\t\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << a[n] << \" \" << aodd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvi dp(1000001), dp2(1000001);\n\tfor (int i = 0; i*(i + 1)*(i + 2) / 6 <= 1000000; ++i) {\n\t\tint k = i*(i + 1)*(i + 2) / 6;\n\t\tREP(j, 1000001-k) {\n\t\t\tdp[j + k] = min(dp[j + k], dp[j] + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i*(i + 1)*(i + 2) / 6 <= 1000000; ++i) {\n\t\tint k = i*(i + 1)*(i + 2) / 6;\n\t\tif (k % 2 == 0)continue;\n\t\tREP(j, 1000001 - k) {\n\t\t\tdp2[j + k] = min(dp2[j + k], dp2[j] + 1);\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tcout << dp[n] <<\" \"<<dp2[n]<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint num[1000010], num2[1000010];\n\tfor(int i=0; i< 1000010; i++) num[i] = num2[i] = 10e8;\n\tnum[0] = num2[0] = 0;\n\tfor(int j=0; j< 1000010; j++){\n\t\tfor(int i=0; i < 1200; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(1000010 <= m+j) continue;\n\t\t\tnum[j+m] = min(num[j]+1, num[j+m]);\n\n\t\t\tif(m == 0) continue;\n\t\t\tif(m%2 == 0) continue;\n\t\t\tnum2[j+m] = min(num2[j]+1, num2[j+m]);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << num[n] << \" \" << num2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint dp1[MAX+1],dp2[MAX+1];\n\nint main(){\n    //INFで初期化\n    for(int i = 1;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n + 2) /6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;  //ポロック数の生成\n        for(int i = a;i <= MAX;i++){     //正四面体数の個数dp(a以下は必要ない)\n            dp1[i] = min(dp1[i],dp1[i-a] + 1);  //更新しないor左側から更新する\n        }\n        if(a % 2 == 0)continue;     //偶数の時は次のroopへ\n        for(int i = a;i <= MAX;i++){     //奇数の正四面体数の個数dp(a以下は必要ない)\n            dp2[i] = min(dp2[i],dp2[i-a] + 1);  //更新しないor左側から更新する\n        }\n    }\n\n    //入出力\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n int i,j,n,three[1000000],four[1000000],four_2[1000000],c[1000000],c_2[1000000];\n\nint main(){\n  \n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < 1000; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < 1000; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int MAX_N = 182;\nint num[MAX_N];\nVI odd;\n\nint bfs(int x){\n  queue<int> q[2];\n  int crt = 0, nxt = 1;\n  q[crt].push(x);\n\n  int ret = 0;\n  while(true){\n\t++ret;\n\twhile(!q[crt].empty()){\n\t  x = q[crt].front(); q[crt].pop();\n\t  REP(i,SZ(odd)){\n\t\tif(x < odd[i]) break;\n\t\tif(x == odd[i]) return ret;\n\t\tq[nxt].push(x - odd[i]);\n\t  }\n\t}\n\n\tswap(crt, nxt);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  num[0] = 0;\n  for(int i=1;i<MAX_N;++i){\n\tnum[i] = i*(i+1)*(i+2)/6;\n\tif(num[i] % 2 == 1) odd.PB(num[i]);\n  }\n\n  VI pr;\n  REP(i,MAX_N) REP(j,MAX_N)\n\tpr.PB(num[i]+num[j]);\n  SORT(pr);\n  \n  int N;\n  while(cin>>N,N){\n\tint cnt = 0;\n\tif(*lower_bound(num, num+MAX_N, N) == N) cnt=1;\n\telse if(*lower_bound(ALL(pr), N) == N) cnt=2;\n\telse{\n\t  REP(i,SZ(pr)){\n\t\tint x = N - pr[i];\n\t\tif(x < 0) break;\n\t\tif(*lower_bound(num, num+MAX_N, x) == x){\n\t\t  cnt=3; break;\n\t\t}\n\t\tif(*lower_bound(ALL(pr), x) == x){\n\t\t  cnt=4;\n\t\t}\n\t  }\n\t  if(!cnt) cnt = 5;\n\t}\n\tcout << cnt << \" \" << bfs(N) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvi llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\n\nint beam_width=1000;\n\nint bfs(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n        }\n        if(i<target){\n            q.pb(i);\n            mm=i;\n        }\n        if(i>target) break;\n    }\n    //auto mm=*max_element(beginend(q));\n    int cnt=0;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(llist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,llist){\n                if(k+x>target) break;\n                // if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.pb(k+x);\n            }\n\n            \n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) {q.pb(i);mm=i;}\n        if(i>target) break;\n    }\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    //out(mm);\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(oddlist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                //if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.pb(k+x);\n            }\n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    int mm=0;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n        mm=max(mm,n);\n    }\n    map<int,pii> m;\n    makeList(mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        //int ans2=0;\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INF 1<<28\nusing namespace std;\n\nint p[1111111];\nint memo[1111111];\nint memo2[1111111];\n\nint solve(int n){\n  \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n\n  int ans = INF;\n  for(int i=199;i>0;i--) if(n-p[i] >= 0) ans = min(ans, solve(n-p[i])+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n\n  int ans = INF;\n  for(int i=199;i>0;i--) if(n-p[i] >= 0 && p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n\n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n\n  for(int i=0;i<200;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mint[1000000], mink[1000000];\nint main() {\n\tmemset(mint, 0x3f, sizeof(mint));\n\tmemset(mink, 0x3f, sizeof(mink));\n\tmint[0] = mink[0] = 0;\n\tfor (int i = 1;; i++) {\n\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\tif (a >= 1000000)break;\n\t\tfor (int j = a; j < 1000000; j++) {\n\t\t\tmint[j] = min(mint[j], mint[j - a] + 1);\n\t\t\tif (a & 1)mink[j] = min(mink[j], mink[j - a] + 1);\n\t\t}\n\t}\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t\tprintf(\"%d %d\\n\", mint[n], mink[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nint v[1000];\nint main()\n{\n\tint n;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j <= 1000000; j++)\n\t\t{\n\t\t\tif (j == 0)dp[i][j] = 0;\n\t\t\telse dp[i][j] = 999999;\n\t\t}\n\t}\n\tfor (int i = 1;;i++)\n\t{\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif (k > 1000000)break;\n\t\tv[i - 1] = k;\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tfor (int i = 0; i <= n; i++)\n\t\t{\n\t\t\tfor (int j = 0;;j++)\n\t\t\t{\n\t\t\t\tif (i + v[j] > n)break;\n\t\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]],dp[0][i] + 1);\n\t\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint f(int n)\n{\n  return n*(n+1)*(n+2)/6;\n}\n\nint main()\n{\n  static const int M = 1000000;\n  static int tetra[200];\n  int tetra_size = 0;\n  for (int i = 1; f(i) <= M; i++) {\n    tetra[tetra_size++] = f(i);\n  }\n\n  static int dp[M+1], odd_dp[M+1];\n  fill_n(dp+1, M, 1000000);\n  fill_n(odd_dp+1, M, 1000000);\n  for (int i = 0; i < tetra_size; i++) {\n    for (int j = tetra[i]; j <= M; j++) {\n      dp[j] = min(dp[j], dp[j-tetra[i]] + 1);\n    }\n    if (tetra[i] % 2 == 1) {\n      for (int j = tetra[i]; j <= M; j++) {\n        odd_dp[j] = min(odd_dp[j], odd_dp[j-tetra[i]] + 1);\n      }\n    }\n  }\n  int N;\n  while (cin >> N && N != 0) {\n    cout << dp[N] << ' ' << odd_dp[N] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[1000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b???ans??????????????????????????? */\n\n  /* ??£?????¢?????°?¨???? */\n  for (i = 1; i < 200; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;  /* input???0??§break */\n    int temp = input; /* input??????????????? */\n    int j = 1, min = 1000;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n      \n    /* ?????????????????¢?????° */\n    while (j > 0) {\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* tetras[k] > input???????£???°??? */\n            if (tetras[k] > input) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][0] = min;\n      \n    /* ?\\???°?????£?????¢?????°?????? */\n    j = l;  /* j??????????????? */\n    min = 1000; /* min??????????????? */\n    while (j > 0) {\n        /* ??¶??°?????£?????¢?????°????£???°??? */\n        if (tetras[j] % 2 == 0) {\n            j--;\n            continue;\n        }\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* ??¶??°?????£?????¢?????°????£???°??? */\n            if (tetras[k] % 2 == 0 || tetras[k] > input) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][1] = min;\n      \n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tmemset(dp, 0, sizeof(dp));\n\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<6 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; k<N && j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=MAX && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tdp[i%2][j] = 0;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; k<M && j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[10000000], dp2[10000000];\nint main() {\n\tv.pb(0);\n\tll n, now = 1, now2 = 1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)(i*(i + 1)*(i + 2) / 6);\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 1000000) {\n\t\tif (i < 2) { dp[i] = i; dp2[i] = i;continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], (ll)i / ss[j] + dp[i%ss[j]]);\n\t\tif (i >= v[now2 + 1])++now2;\n\t\tdp2[i] = i / v[now2] + dp2[i%v[now2]];\n\t\tfor (int j = now2 - 1; j >= 1; --j)dp2[i] = min(dp2[i], (ll)i / v[j] + dp2[i%v[j]]);\n\t}\n\twhile (cin >> n, n) {\n\t\trep(i, n)cout << i << \"ha\" << dp[i] << endl;\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <list>\n#include <utility>\n#include <cmath>\nusing namespace std;\nvector<int> v,memo(1000005,999999),memo2(1000005,999999);\nint a;\nint main ()\n{\n\tv.push_back(0);\n\tfor(int i=1;i<=300;i++)\n\t{\n\t\tv.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tmemo[0]=memo2[0]=0;\n\tfor(int i=0;i<=1000000;i++)\n\t{\n\t\tfor(int l=0;l<v.size();l++)\n\t\t{\n\t\t\tif(i+v[l]>1000000)break;\n\t\t\tif(v[l]%2==1)memo2[i+v[l]]=min(memo2[i+v[l]],memo2[i]+1);\n\t\t\tmemo[i+v[l]]=min(memo[i+v[l]],memo[i]+1);\n\t\t}\n\t}\n\t// for(int i=1;i<100;i++)cout<<memo[i]<<\" \"<<memo[i]<<endl;\n\twhile(cin>>a&&a)\n\t{\n\t\tcout<<memo[a]<<\" \"<<memo2[a]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nbool   dp[6][1000001];\nbool dp2[38][1000001];\n\nint main(){\n  int n=1;\n  vector<int> vec, vec2;\n  int tmp=0;\n  while(tmp<=1000000){\n    tmp+=n*(n+1)/2;\n    vec.pb(tmp);\n    if(tmp%2==1) vec2.pb(tmp);\n    n++;\n  }\n  // dp[i][j] : i???????????£???j?????°????????????\n  dp[0][0]=true;\n  repl(i,1,5+1){\n    for(int upd : vec){\n      rep(j, 1000001){\n        dp[i][j] = dp[i][j] | dp[i-1][j];\n        if(j-upd>=0 && dp[i-1][j-upd]) dp[i][j] = true;\n      }\n    }\n  }\n  dp2[0][0]=true;\n  repl(i,1,38){\n    for(int upd : vec2){\n      rep(j, 1000001){\n        dp2[i][j] = dp2[i][j] | dp2[i-1][j];\n        if(j-upd>=0 && dp2[i-1][j-upd]) dp2[i][j] = true;\n      }\n    }\n  }\n\n  while(cin>>n, n){\n    int res=1;\n    while(dp[res][n]==false) res++;\n    cout<<res<<\" \";\n    res=1;\n    while(dp2[res][n]==false) res++;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;a[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++)for(k=a[j];k<=1000000;k++){\n    if(a[j+1]<k)break;\n    b[k]=min(b[k],b[k-a[j]]+1);\n    if(a[j]%2)c[k]=min(c[k],c[k-a[j]]+1);\n  }\nwhile(cin>>n,n)cout<<b[n]<<' '<<c[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 1000\n#define INFINITY 2000000000\nusing namespace std;\nint dp[N][N],data[N];\nvector<int> data2;\nint DP(int);\nint DP2(int);\nint main(){\n  int i,out,out2,n;\n  data2.push_back(0);\n  for(i=1;i<N;i++){\n    data[i]=i*(i+1)*(i+2)/6;\n    if(data[i]%2==1){\n      data2.push_back(data[i]);\n    }\n  }\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    out=DP(n);\n    out2=DP2(n);\n    cout << out << ' ' << out2 << endl;\n  }\n  return 0;\n}\nint DP(int n){\n  int i,j,minret,s;\n  for(i=1;i<N;i++){\n    if(data[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}\nint DP2(int n){\n  int i,j,minret,s,len;\n  len=data2.size();\n  for(i=1;i<len;i++){\n    if(data2[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data2[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data2[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MAX 1000000\n\nint calc(int n) { return n*(n + 1)*(n + 2) / 6; }\nint p[200];\nint p1[200];\nint dp[MAX] = { 0 };\nint dp1[MAX] = { 0 };\n\nint func(int n, int P[], int DP[])\n{\n\tif (n <= 0)return MAX;\n\tif (DP[n] != 0)return DP[n];\n\telse\n\t{\n\t\tint min_t = MAX;\n\t\tint i = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (P[i] <= n && n <= P[i + 1])break;\n\t\t\tif (P[i] == 1004731)\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int t = i; t>0; t--)\n\t\t{\n\t\t\tif (min_t > func(n - P[t], P, DP) + 1)\n\t\t\t{\n\t\t\t\tmin_t = func(n - P[t], P, DP) + 1;\n\t\t\t}\n\t\t}\n\t\tDP[n] = min_t;\n\t\treturn DP[n];\n\t}\n}\n\nint main()\n{\n\tint index = 1;\n\tFOR(i, 1, 200)\n\t{\n\t\tint temp = calc(i);\n\t\tif (temp > 1004731)break;\n\t\tp[i] = temp;\n\t\tdp[p[i]] = 1;\n\t\tif (temp % 2 == 1)\n\t\t{\n\t\t\tp1[index] = temp;\n\t\t\tdp1[p1[index]] = 1;\n\t\t\tindex++;\n\t\t}\n\t}\n\twhile (1)\n\t{\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcout << func(N, p, dp) << \" \" << func(N, p1, dp1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint lim = 1000000;\n\tint dp[lim],odp[lim];\n\tfor (int i = 0; i < lim; ++i) {\n\t\tdp[i] = i;\n\t\todp[i] = i;\n\t}\n\n\tint num = 4;\n\tfor (int now = 2; num < lim; ++now) {\n\t\tfor (int i = num; i < lim; ++i) {\n\t\t\tdp[i] = min(dp[i],dp[i-num]+1);\n\t\t}\n\t\tif (num%2 == 1) {\n\t\t\tfor (int i = num; i < lim; ++i) {\n\t\t\t\todp[i] = min(odp[i],odp[i-num]+1);\n\t\t\t}\n\t\t}\n\t\tnum = ((now+1)*(now+2)*(now+3))/6;\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << odp[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1000006;\nconst int INF = 1<<28;\nvector<int> V;\nint dp1[MAXN], dp2[MAXN];\n\nint main() {\n  for(int i = 1; ; ++i) {\n    int k = i * (i + 1) * (i + 2) / 6;\n    if(k >= MAXN) break;\n    V.push_back(k);\n  }\n  fill(dp1, dp1 + MAXN, INF);\n  fill(dp2, dp2 + MAXN, INF);\n  dp1[0] = dp2[0] = 0;\n  for(int i = 0; i < V.size(); ++i) {\n    for(int j = V[i]; j < MAXN; ++j) {\n      dp1[j] = min(dp1[j], dp1[j - V[i]] + 1);\n      if(V[i] & 1) dp2[j] = min(dp2[j], dp2[j - V[i]] + 1);\n    }\n  }\n  for(int n; cin >> n && n; ) {\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define print(a) cout<<a<<endl;\nint aaa[200] = {}, bbb[200] = {}, counta=1,countb=1, ansa, ansb, xxx[1100000] = {}, yyy[1100000] = {};\n\nint foo(int n, int x){//cout<<n<<\" \"<<x<<\" \"<<xxx[x]<<endl;;\n\tint mi = 1000000;\n\tif(xxx[n]) return xxx[n]+x;\n\tif(x > 5) return mi;\n\tfor(int i = counta-1; i >= 1; i--){\n\t\tif(aaa[i] < n){\n\t\t\tmi = min(foo(n-aaa[i],x+1), mi);\n\t\t//\tif(mi - n == 1)break;\n\t\t} //else if(aaa[i] < n/2) break;\n\t}\n\t\n\txxx[n] = mi;\n\treturn mi;\n}\nint boo(int n, int x){//cout<<n<<\" \"<<x<<\" \"<<yyy[n]<<endl;cin>>ansb;\n\tint mi = 1000000;\n\tif(yyy[n]) return yyy[n]+x;\n\tfor(int i = countb-1; i >= 1; i--){\n\t//\tcout<<bbb[i]<<\" \"<<n<<endl;\n\t\tif(bbb[i] < n){\n\t\t\tmi = min(boo(n-bbb[i],x+1), mi);\n\t\t\t//if(mi - n == 1)break;\n\t\t}// else if(bbb[i] < n/2) break;\n\t}\n\t//cout<<\"aaaa \"<<n<<\" \"<<x<<\" \"<<mi<<endl;\n\tyyy[n] = mi;\n\treturn mi;\n}\n\nint main(){\n\tint i, n, abc;\n\tfor(i = 1; abc <= 1000000; i++){\n\t\tabc = (i*(i+1)*(i+2))/6;\n\t\txxx[abc] = 1;\n\t\tif(abc%2 == 1){\n\t\t\tyyy[abc] = 1;\n\t\t\tbbb[countb++] = abc;\n\t\t}\n\t\taaa[counta++] = abc;\n\t//\tcout<<counta<<\" \"<<i<<\" \"<<abc<<endl;;\n\t}\n//\tprint(1);\n\tfor(i = 1; i <= 100000; i++){\n\t\txxx[i] = foo(i, 0);\n\t\tyyy[i] = boo(i, 0);\n\t}\n//\tprint('a');\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tcout<<foo(n,0)<<\" \"<<boo(n,0)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint all[1000001];\nint odd[1000001];\n\nint const INF = 1<<29;\n\nint main() {\n  \n  fill(all, all+1000001, INF);\n  fill(odd, odd+1000001, INF);\n  \n  all[0] = odd[0] = 0;\n  \n  for(int i=1; ; i++) {\n    int n = i*(i+1)*(i+2)/6;\n    if(n > 1000000) break;\n    for(int j=n; j<=1000000; j++) {\n      all[j] = min(all[j-n]+1, all[j]);\n      if(n % 2) {\n\todd[j] = min(odd[j-n]+1, odd[j]);\n      }\n    }\n  }\n  \n  int N;\n  while(cin >> N && N) {\n    cout << all[N] << ' ' << odd[N] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst ll INF=1e9;\nint main(){\n      int dp[2][1000000];\n      vector<int> V[2];\n      REP(i,2)REP(j,1000000)dp[i][j]=INF;\n      dp[0][0]=dp[1][0]=0;\n      for(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n            V[0].PB(i*(i+1)*(i+2)/6);\n            if((i*(i+1)*(i+2)/6)&1)V[1].PB(i*(i+1)*(i+2)/6);\n      }\n      REP(i,2){\n            REP(j,1000000){\n                  REP(k,V[i].size()){\n                        if(j+V[i][k]>=1000000)break;\n                        dp[i][j+V[i][k]]=min(dp[i][j+V[i][k]],dp[i][j]+1);\n                  }\n            }\n      }\n      int n;\n      while(cin>>n&&n){\n            cout<<dp[0][n]<<\" \"<<dp[1][n]<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int i,j,k;\n  int x,y;\n  int inf = 1 << 10;\n  int m[200]={};\n  int memo[1000005]={};\n  int memo2[1000005]={};\n  vector <int>  odd;\n  fill(memo,memo+1000005,inf);\n  fill(memo2,memo2+1000005,inf);\n  for(i=1;i<201;i++) {\n    m[i-1]=i*(i+1)*(i+2)/6;\n    if(m[i-1]%2==1) odd.push_back(m[i-1]);\n  }\n  memo[0]=0;\n  for(i=0;i<200;i++) {\n    for(j=m[i];j<1000005;j++){\n      memo[j]=min(memo[j],memo[j-m[i]]+1);\n    }\n  }\n  memo2[0]=0;\n  for(i=0;i<odd.size();i++) {\n    for(j=odd[i];j<1000005;j++){\n      memo2[j]=min(memo2[j],memo2[j-odd[i]]+1);\n    }\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    cout << memo[n] << \" \" <<  memo2[n] << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nbool t=true;\nint x;\nvector<int> input;\nint inpmax=0;\nint ans,ansodd;\n\n\nint main(){\n    while(true){\n        cin>>x;\n        if(x==0)break;\n        input.push_back(x);\n        if(inpmax<x)inpmax=x;\n    }\n    vector<int> tri={1};\n    vector<int> tetra={1};\n    vector<int> tetraodd={1};\n    int oddcnt=2;\n    vector<int> dpmin={0},dpmind={0};\n    for(int i=2;i<100000;i++){\n        tri.push_back(tri.back()+i);\n        tetra.push_back(tri.back()+tetra.back());\n        \n        dpmin.push_back(1);\n        if(tetra[i-2]<inpmax){\n            for(int k=tetra[i-2]+1;k<tetra[i-1];k++){\n                dpmin.push_back(dpmin.back()+1);\n                for(int l=1;l<i-1;l++){\n                    chmin(dpmin[k],dpmin[k-tetra[l]]+1);\n                }\n            }\n        }\n        if(tetra.back()%2){\n            tetraodd.push_back(tetra.back());\n            dpmind.push_back(1);\n            if(inpmax<tetraodd[oddcnt-2])break;\n            for(int k=tetraodd[oddcnt-2]+1;k<tetraodd[oddcnt-1];k++){\n                dpmind.push_back(dpmind.back()+1);\n                for(int l=1;l<oddcnt-1;l++)\n                    chmin(dpmind[k],dpmind[k-tetraodd[l]]+1);\n            }\n            oddcnt++;\n        }\n    }\n    for(int i=0;i<input.size();i++)cout<<dpmin[input[i]]<<\" \"<<dpmind[input[i]]<<endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "aaaa"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define LIM 1000000\nint all[LIM];\nint odd[LIM];\n\nint main()\n{\n    for (int i = 0; i < LIM; i++){\n        all[i] = i;\n        odd[i] = i;\n    }\n    for (int i = 0; i < LIM; i++){\n        int x = i * (i + 1) * (i + 2) / 6;\n        if (x > LIM) break;\n        for (int j = x; j <= LIM; ++j){\n            all[j] = min(all[j], all[j-x] + 1);\n        }\n        if (x % 2 == 1){\n            for (int j = x; j <= LIM; ++j){\n                odd[j] = min(odd[j], odd[j-x] + 1);\n            }\n        }\n    }\n\n    int n;\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        cout << all[n] << \" \" << odd[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\n\nint A[1000];\nint dp1[1000001];\nint dp2[1000001];\n\nint main() {\n    A[0] = 0;\n    A[1] = 1;\n    REP2(i, 1, 200) A[i+1] = A[i] * (i+3) / i;\n\n    dp1[0] = 0;\n    dp1[1] = 1;\n    REP2(i, 2, 1000001) dp1[i] = 1 << 29;\n    REP2(i, 2, 1000001) REP(j, 200) {\n        if (i < A[j]) break;\n        dp1[i] = min(dp1[i], dp1[i-A[j]] + 1);\n    }\n\n    dp2[0] = 0;\n    dp2[1] = 1;\n    REP2(i, 2, 1000001) dp2[i] = 1 << 29;\n    REP2(i, 2, 1000001) REP(j, 200) {\n        if (i < A[j]) break;\n        if (A[j] % 2 == 0) continue;\n        dp2[i] = min(dp2[i], dp2[i-A[j]] + 1);\n    }\n\n    \n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        cout << dp1[N] << \" \" << dp2[N] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MAX = 1000000;\nconst int INF = 1<<29;\nint main(){\n  vector<int> dp_1(MAX+1,INF);\n  vector<int> dp_2(MAX+1,INF);\n  vector<int> poll(1000,0);\n  for(int i = 0;i < 200;i++)poll[i] = i*(i+1)*(i+2)/6;\n  dp_1[0] = 0;\n  dp_2[0] = 0;\n  for(int i = 1;i < MAX;i++){\n    dp_1[i] = i;\n    dp_2[i] = i;\n    for(int j = 0;i-poll[j]>=0;j++){\n      dp_1[i] = min(dp_1[i],dp_1[i-poll[j]]+1);\n      if(poll[j] % 2 == 1)dp_2[i] = min(dp_2[i],dp_2[i-poll[j]]+1);\n    }\n  }\n  int n;\n  cout << \"aaaaaa\" << endl;\n  while(cin >> n,n != 0){\n    cout << dp_1[n] << \" \" << dp_2[n] << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    vector<int> tri;\n    vector<int> odd;\n    constexpr int MAX = 1000000;\n    for (int i = 1;; i++) {\n        const int num = i * (i + 1) * (i + 2) / 6;\n        if (num >= MAX) {\n            break;\n        }\n        tri.push_back(num);\n        if (num % 2 == 1) {\n            odd.push_back(num);\n        }\n    }\n    constexpr int INF = 1000000000;\n    vector<int> num(MAX, INF);\n    vector<int> oddnum(MAX, INF);\n    num[0] = 0;\n    oddnum[0] = 0;\n    for (int i = 0; i < MAX; i++) {\n        if (num[i] == INF) {\n            continue;\n        }\n        for (const int p : tri) {\n            if (i + p < MAX) {\n                num[i + p] = min(num[i + p], num[i] + 1);\n            }\n        }\n    }\n    for (int i = 0; i < MAX; i++) {\n        if (oddnum[i] == INF) {\n            continue;\n        }\n        for (const int p : odd) {\n            if (i + p < MAX) {\n                oddnum[i + p] = min(oddnum[i + p], oddnum[i] + 1);\n            }\n        }\n    }\n\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        cout << num[n] << \" \" << oddnum[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define reps(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint dp[1000000] = {};\nint dp_o[1000000] = {};\nvector<int>n, n_o;\nint DP(int num) {\n\tif (dp[num] != 0)return dp[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP(n[cnt]) + DP(num - n[cnt]), rec);\n\t\tcnt++;\n\t\tif (n[cnt] > num)break;\n\t}\n\tdp[num] = rec;\n\treturn rec;\n\n}\nint DP_o(int num) {\n\tif (dp_o[num] != 0)return dp_o[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP_o(n_o[cnt]) + DP_o(num - n_o[cnt]), rec);\n\t\tcnt++;\n\t\tif (n_o[cnt] > num)break;\n\t}\n\tdp_o[num] = rec;\n\treturn rec;\n\n}\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tll cnt1 = 0, cnt2 = 0;\n\treps(i, 1, 1000000) {\n\t\tcnt1 += i;\n\t\tcnt2 += cnt1;\n\t\tif (cnt2 >= 1000000)break;\n\t\tdp[cnt2] = 1;\n\t\tn.push_back(cnt2);\n\t\tif (cnt2 % 2 == 1) {\n\t\t\tdp_o[cnt2] = 1;\n\t\t\tn_o.push_back(cnt2);\n\t\t}\n\t}\n\tvector<int>ans;\n\twhile (1) {\n\t\tint Q;\n\t\tcin >> Q;\n\t\tif (Q == 0)break;\n\t\tans.push_back(DP(Q));\n\t\tans.push_back(DP_o(Q));\n\t}\n\trep(i, ans.size())cout << ans[i++] << \" \" << ans[i] << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nint dp1[1000001];\nint dp2[1000001];\n\nint search(int n, int k){\n\tif(k == 0){\n\t\tif(dp1[n] != -1)\n\t\t\treturn dp1[n];\n\t}\n\telse{\n\t\tif(k == 1){\n\t\t\tif(dp2[n] != -1)\n\t\t\t\treturn dp2[n];\n\t\t}\n\t}\n\t\n\tif(n <= 0)\n\t\treturn 0;\n\t\t\n\tint res = INF;\n\tfor(int i = 1; i <= 1000000; ++i){\n\t\tint a = i * (i + 1) * (i + 2) / 6;\n\t\tif(a > n)\n\t\t\tbreak;\n\t\tif(k == 1 && a % 2 == 0)\n\t\t\tcontinue;\n\t\t\t\n\t\tif(k == 0)\n\t\t\tres = min(res, search(n - a, k) + 1);\n\t\telse\n\t\t\tres = min(res, search(n - a, k) + 1);\n\t}\n\tif(k == 0)\n\t\treturn dp1[n] = res;\n\telse\n\t\treturn dp2[n] = res;\n}\n\nint main() {\n\tmemset(dp1, -1, sizeof(dp1));\n\tmemset(dp2, -1, sizeof(dp2));\n\t\n\tfor(int i = 1; i <= 1000000; ++i){\n\t\tsearch(i, 0);\n\t\tsearch(i, 1);\n\t}\n\tint n;\n\twhile(cin >> n && n){\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define put(a) cout<<a<<\"\\n\"\n#define all(a)  (a).begin(),(a).end()\n#define SORT(a) sort((a).begin(),(a).end())\n#define oorret 0\n#define oor(x) [&](){try{x;} catch(const out_of_range& oor){return oorret;} return x;}()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b){a=b;return 1;}return 0;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b){a=b;return 1;}return 0;}\n\nint main(){\n    vector<int> a;\n    int input;\n    while(cin >> input){\n        if(input==0){\n            break;\n        }\n        a.push_back(input);\n    }\n    int n = a.size();\n    int m = 1e6+1;\n    vector<int> dp(m,0);\n    vector<int> dp2(m,0);\n    Rep(i,m){\n        dp[i] = i;\n        dp2[i] = i;\n    }\n    REP(i,m){\n        for(int j=2;(j)*(j+1)*(j+2)/6+i<m;j++){\n            int k = (j)*(j+1)*(j+2)/6;\n            chmin(dp[i+k],dp[i]+1);\n            if(k%2==1){\n                chmin(dp2[i+k],dp2[i]+1);\n            }\n        }\n    }\n    REP(i,n){\n        cout << dp[a[i]] << \" \" << dp2[a[i]] << \"\\n\";\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvvi tetra(2);\nvvi dp(2, vi(1e6, 1e6));\n\nvoid preset() {\n    int n;\n    for (int i=0; (n = i*(i+1)*(i+2)/6) < 1e6; i++) {\n        tetra[0].push_back(n);\n        if (n % 2 == 1) tetra[1].push_back(n);\n    }\n\n    for (int i=0; i<2; i++) {\n        dp[i][0] = 0;\n        for (int k : tetra[i]) {\n            for (int j=k; j<1e6; j++) {\n                dp[i][j] = min(dp[i][j], dp[i][j-k]+1);\n            }\n        }\n    }\n}\n\nint main() {\n    preset();\n\n    int a;\n    while (cin >> a) {\n        if (a == 0) break;\n        cout << dp[0][a] << \" \" << dp[1][a] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXN 1000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint dp[200][MAXN+1];\nint dp2[200][MAXN+1];\n\nint main(void) {\n    for (int i = 0; i < 200; i++) {\n        for (int j = 0; j <= MAXN; j++) {\n            dp[i][j] = INF;\n            dp2[i][j] = INF;\n        }\n    }\n    dp[0][0] = 0; dp[0][1] = 1;\n    dp2[0][0] = 0; dp2[0][1] = 1;\n    // DP\n    for (int i = 1; i < 200; i++) {\n        int plus = i * (i+1) * (i+2) / 6;\n        dp[i][0] = 0;\n        dp2[i][0] = 0;\n        for (int j = 1; j <= MAXN; j++) {\n            if (j - plus >= 0) dp[i][j] = min(dp[i-1][j], dp[i][j-plus] + 1);\n            else dp[i][j] = dp[i-1][j];\n        }\n        if (plus % 2 == 1) {\n            for (int j = 1; j <= MAXN; j++) {\n                if (j - plus >= 0) dp2[i][j] = min(dp2[i-1][j], dp2[i][j-plus] + 1);\n                else dp2[i][j] = dp2[i-1][j];\n            }\n        } else {\n            for (int j = 1; j <= MAXN; j++) {\n                dp2[i][j] = dp2[i-1][j];\n            }\n        }\n    }\n//    for (int i = 1; i < 5; i++) {\n//        for (int j = 1; j <= 10; j++) {\n//            cout << dp2[i][j] << \" \";\n//        }\n//        cout << endl;\n//    }\n    int n;\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        cout << dp[199][n] << \" \" << dp2[99][n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\n\ntypedef vector<int> vi;\nint const inf = 1 << 28;\n\nint main(){\n    vi q, r;\n    for (int i = 1;; i++){\n        int pq = i*(i + 1)*(i + 2) / 6;\n        q.push_back(pq);\n        if (pq > 1e6 + 100) break;\n    }\n\n    int n = 1000000;\n\n    vi dp1(n + 1, inf);\n    vi dp2(n + 1, inf);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    rep(i, q.size()){\n        rep(j, n + 1){\n            if (j - q[i] >= 0){\n                dp1[j] = min(dp1[j], dp1[j - q[i]] + 1);\n            }\n        }\n        if(q[i]&1){\n            rep(j, n + 1){\n                if (j - q[i] >= 0){\n                    dp2[j] = min(dp2[j], dp2[j - q[i]] + 1);\n                }\n            }\n        }\n    }\n\n    int t;\n    while (cin >> t && t){\n        cout << dp1[t] << \" \" << dp2[t] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for(int i = (int)(n - 1); i >= 0; --i)\n#define RFOR(i, a, b) for(int i = (int)(b - 1); i >= (int)(a); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef vector<vll> vvll;\n\nconst int INF = (int)1e9;\n\nint main() {\n  vi pollock;\n  for(int i = 0, v; ( v = i * (i + 1) * (i + 2) / 6) <= 1000000; i++) {\n    pollock.push_back(v);\n  }\n\n  vi dpall(100000, INF);\n  vi dpodd(100000, INF);\n  dpall[0] = dpodd[0] = 0;\n  for (auto m : pollock) {\n    for(int i = 0; i + m < dpall.size(); i++) {\n      dpall[i + m] = min(dpall[i + m], dpall[i] + 1);\n    }\n    if (m % 2 == 1) {\n      for(int i = 0; i + m < dpall.size(); i++) {\n        dpodd[i + m] = min(dpodd[i + m], dpodd[i] + 1);\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    printf(\"%d %d\\n\", dpall[n], dpodd[n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX=1000005;\nint dp[MAX];\nint dp2[MAX];\nvector<int> pol,pol2;\nint main(void){\n    dp[0]=0;dp2[0]=0;\n    int cnt=1;\n    // printf(\"start\\n\");\n    while((cnt*(cnt+1)*(cnt+2))/6<MAX-1){\n        int a = (cnt*(cnt+1)*(cnt+2))/6;\n        pol.push_back(a);\n        if(a%2==1)pol2.push_back((cnt*(cnt+1)*(cnt+2))/6);\n        cnt++;\n    }\n    // cout << pol.size() << endl;\n    // printf(\"dp start\\n\");\n    for(int i=1;i<MAX;i++){\n        int tmp=1<<30;\n        int cur=0;\n        while(cur<pol.size()&&pol[cur]<=i){\n            tmp=min(tmp,dp[i-pol[cur]]+1);\n            cur++;\n        }\n        dp[i]=tmp;\n    }\n    for(int i=1;i<MAX;i++){\n        int tmp=1<<30;\n        int cur=0;\n        while(cur<pol2.size()&&pol2[cur]<=i){\n            tmp=min(tmp,dp2[i-pol2[cur]]+1);\n            cur++;\n        }\n        dp2[i]=tmp;\n    }\n    // printf(\"stand by\\n\");\n    while(true){\n        int n;\n        cin>>n;\n        if(n==0)return 0;\n        printf(\"%d %d\\n\",dp[n],dp2[n]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 100000\n#define INF (1<<24)\nint n[100000],M;\n\nint dp[100005];\nint od[100005];\n\nint main()\n{\n\tfor(M=1; ; M++)\n\t{\n\t\tint v=M*(M+1)*(M+2)/6;\n\t\tif(v>MAX) break;\n\t\tn[M]=v;\n\t}\n\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<=N; i++)\n\t\t{\n\t\t\tdp[i]=INF;\n\t\t\tod[i]=INF;\n\t\t}\n\n\t\tdp[0]=od[0]=0;\n\n\t\tfor(int i=1; i<M; i++)\n\t\tfor(int j=0; j<=N; j++) \n\t\t{\n\t\t\tif(j+n[i] > N) break;\n\t\t\tif(dp[j]!=INF)\n\t\t\t{\n\t\t\t\tdp[j+n[i]]=min(dp[j+n[i]], dp[j]+1);\n\t\t\t}\n\t\t\tif(od[j]!=INF&&n[i]%2==1)\n\t\t\t{\n\t\t\t\tod[j+n[i]]=min(od[j+n[i]], od[j]+1);\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[N] << \" \" << od[N] << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(v) v.begin(), v.end()\ntypedef long long ll;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() { \n  vector<int> A(201),B;\n  for(int i=1;i<=200;i++){\n    A[i]=i*(i+1)*(i+2)/6;\n    if(A[i]%2==1) B.push_back(A[i]);\n  }\n  \n  int dp1[1000100],dp2[1000100];\n  rep(i,1000100) dp1[i]=dp2[i]=1e9;\n  dp1[0]=dp2[0]=0;\n  for(int i=1;i<=1000000;i++){\n    for(int j=1;j<=200;j++){\n      if(i-A[j]>=0) dp1[i]=min(dp1[i],dp1[i-A[j]]+1);\n    }\n    rep(j,B.size()){\n      if(i-B[j]>=0) dp2[i]=min(dp2[i],dp2[i-B[j]]+1);\n    }\n  }\n  \n  ll n;\n  while(cin>>n){\n    if(n==0) return 0;\n    cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n  } \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 1000000\nint main(){\n  int a[MAX + 1],b[MAX + 1];\n  a[0] = b[0] = 0;\n  for(int i = 1; i < MAX + 1; i++){\n    a[i] = b[i] = i;\n    for(int j = 1;  ; j++ ){\n      int java = j * (j + 1) * (j + 2) / 6;\n      if(i - java < 0) break;\n      a[i] = min( a[i], a[i - java] + 1);\n      if(java & 1) b[i] = min( b[i], b[i - java] + 1);\n    }\n  }\n  int n;\n  while(cin >> n, n){\n    cout << a[n] << \" \" << b[n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\n\nconst int S = 1000010;\nint dp[S][2];\n\nsigned main() {\n    rep(i,1,S) rep(j,0,2) dp[i][j] = INF;\n    repq(i,1,210) rep(j,0,S) {\n        int d = i * (i+1) * (i+2) / 6;\n        if(j-d < 0) continue;\n        chmin(dp[j][0], dp[j-d][0] + 1);\n        if(d % 2) chmin(dp[j][1], dp[j-d][1] + 1);\n    }\n\n    while(cin >> N, N) {\n        printf(\"%lld %lld\\n\", dp[N][0], dp[N][1]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1e6],c[1e6],a[190],n;\n  for(i=0;a[i-1]<1e6;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1e6;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++)for(k=a[j];k<=1e6;k++){\n    b[k]=min(b[k],b[k-a[j]]+1);\n    if(a[j]%2)c[k]=min(c[k],c[k-a[j]]+1);\n  }\nwhile(cin>>n,n)cout<<b[n]<<' '<<c[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define INF (1<<25)\nint N;\nint pr[182];\nint dp[1000002];\nvoid init(){\n  for(int i=0;i<=N;i++) dp[i]=INF;\n}\nint solve(int g){\n  dp[0]=0;\n  for(int i=0;i<=N;i++){\n    if(dp[i]==INF) continue;\n    for(int j=0;i+pr[j]<=N;j++){\n      if(g==2 && pr[j]%g==0) continue;\n      dp[i+pr[j]] = min(dp[i+pr[j]],dp[i]+1);\n    }\n  }\n  return dp[N];\n}\n\nint main(){\n  for(int i=0;i<182;i++) pr[i] = (i+1)*(i+2)*(i+3)/6;\n  //  for(int i=0;i<102;i++) printf(\"%d\\n\",pr[i]);\n  //  for(int i=0;i<102;i++) if(!(i%2)) printf(\"%d\\n\",pr[i]);\n  while(1){\n    scanf(\"%d\",&N);\n    if(!N) break;\n    init();\n    int res1 = solve(1);\n    init();\n    int res2 = solve(2);\n    printf(\"%d %d\\n\",res1,res2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define reps(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint dp[1000000] = {};\nint dp_o[1000000] = {};\nvector<int>n, n_o;\nint DP(int num) {\n\tif (dp[num] != 0)return dp[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP(n[cnt]) + DP(num - n[cnt]), rec);\n\t\tcnt++;\n\t\tif (n[cnt] > num)break;\n\t}\n\tdp[num] = rec;\n\treturn rec;\n\n}\nint DP_o(int num) {\n\tif (dp_o[num] != 0)return dp_o[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP_o(n_o[cnt]) + DP_o(num - n_o[cnt]), rec);\n\t\tcnt++;\n\t\tif (n_o[cnt] > num)break;\n\t}\n\tdp_o[num] = rec;\n\treturn rec;\n\n}\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tll cnt1 = 0, cnt2 = 0;\n\treps(i, 1, 1000000) {\n\t\tcnt1 += i;\n\t\tcnt2 += cnt1;\n\t\tif (cnt2 >= 1000000)break;\n\t\tdp[cnt2] = 1;\n\t\tn.push_back(cnt2);\n\t\tif (cnt2 % 2 == 1) {\n\t\t\tdp_o[cnt2] = 1;\n\t\t\tn_o.push_back(cnt2);\n\t\t}\n\t}\n\twhile (1) {\n\t\tint Q;\n\t\tcin >> Q;\n\t\tif (Q == 0)break;\n\t\tcout << DP(Q) << \" \";\n\t\tcout << DP_o(Q) << endl;\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#define V_MAX 10000\nusing namespace std;\n\nint n;\nvector<int> v(V_MAX);\nint i=0,mx=0;\nint p[200],size;\nint vSize,dMAX;\nint *dp1;\nint *dp2;\nint m,j;\n\n\nint main(){\n  while( cin>>n && n ){\n    if( i<V_MAX ) v[i]=n;\n    else          v.push_back(n);\n    i++;\n    mx=max(mx,n);\n  }\n  vSize=i;\n\n  p[0]=0;\n  for( size=1; ; size++ ){\n    p[size]= size*(size+1)*(size+2)/6;\n    if( p[size]>mx ) break;\n  }\n\n\n  dMAX = p[size-1] + 1;\n  dp1 = new int[dMAX];\n  dp2 = new int[dMAX];\n  fill( dp1,dp1+dMAX,INT_MAX );\n  fill( dp2,dp2+dMAX,INT_MAX );\n\n  dp1[0]=0;\n  for( i=1;i<size;i++){\n    m=p[i];\n    for( j=m;j<dMAX;j++ )\n      dp1[j] = min( dp1[j],dp1[j-m]+1 );\n  }\n\n  dp2[0]=0;\n  for( i=1;i<size;i++){\n    if( p[i]%2==0 ) continue;\n    m=p[i];\n    for( j=m;j<dMAX;j++ )\n      dp2[j] = min( dp2[j],dp2[j-m]+1 );\n  }\n\n  for( i=0;i<vSize;i++ )\n    cout << dp1[ v[i] ] << \" \" << dp2[ v[i] ] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> poloc;\nvector<int> poloc_odd;\n\nvoid make_poloc()\n{\n\tint n=1;\n\twhile(1){\n\t\tint a = n*(n+1)*(n+2)/6;\n\t\tif(a > 1000000)\n\t\t\tbreak;\n\t\t\n\t\tpoloc.push_back(a);\n\t\tif(a % 2 == 1)\n\t\t\tpoloc_odd.push_back(a); \n\t\tn++;\n\t}\n}\nint search1(int n, int i, int depth)\n{\n\tif(n == 0)\n\t\treturn depth;\n\telse if(n < 0 || i < 0)\n\t\treturn 1000000;\n\telse\n\t\treturn min( min(search1(n-poloc[i],i-1,depth+1), search1(n,i-1,depth)), search1(n-poloc[i],i,depth+1));\n}\nint search2(int n, int i, int depth)\n{\n\tif(n == 0)\n\t\treturn depth;\n\telse if(n < 0 || i < 0)\n\t\treturn 1000000;\n\telse\n\t\treturn min( min(search2(n-poloc_odd[i],i-1,depth+1), search2(n,i-1,depth)), search2(n-poloc_odd[i],i,depth+1));\t\t\n}\n\nint main()\n{\n\tmake_poloc();\n\tint n;\n\t\n\twhile(cin >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcout << search1(n,static_cast<int>(poloc.size()-1),0) << \" \" << search2(n,static_cast<int>(poloc_odd.size()-1),0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 1000001\n\nint main(void){\n\tint i, j, n ,c, small1, small2;\n\tint dp1[1000000],dp2[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp1[i] = dp2[i] = INF;\n\t\tdp1[0] = dp2[0] = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tsmall1 = dp1[n];\n\t\t\tif(small1 > dp1[i] + 1 && dp1[i] != INF){\n\t\t\t\tfor(j = 1,c = j * (j + 1) * (j + 2);c / 6 + i <= n;j++,c = j * (j + 1) * (j + 2)){\n\t\t\t\t\tif(dp1[c / 6 + i] > dp1[i] + 1 && dp1[i] != INF){\n\t\t\t\t\t\tdp1[c / 6 + i] = dp1[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tsmall2 = dp2[n];\n\t\t\tif(small2 > dp2[i] + 1 && dp2[i] != INF){\n\t\t\t\tfor(j = 1,c = j * (j + 1) * (j + 2);c / 6 + i <= n;j++,c = j * (j + 1) * (j + 2)){\n\t\t\t\t\tif(dp2[c / 6 + i] > dp2[i] + 1 && (c / 6) % 2 == 1 && dp2[i] != INF)\n\t\t\t\t\t\tdp2[c / 6 + i] = dp2[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nint inf = 1000005;\n\nint ok[1000010]={};\nint dp[1000010]={};\nint dp2[1000010]={};\n\nint main(void){\n\t\n\treg(i,1,1000){\n\t\tint no=(i*(i+1)*(i+2))/6;\n\t\tif(no>inf)break;\n\t\tok[no]=1;\n\t}\n\t\n\trep(i,inf)dp[i]=dp2[i]=inf;\n\t\n\trep(i,inf){\n\t\tif(!ok[i])continue;\n\t\t//printf(\"ok! %d\\n\",i);\n\t\tdp[i]=1;\n\t\trep(j,inf){\n\t\t\tint to=i+j;\n\t\t\tif(to>inf)continue;\n\t\t\tdp[to]=min(dp[to],dp[j]+1);\n\t\t}\n\t}\n\t\n\trep(i,inf){\n\t\tif(!ok[i] || i%2==0)continue;\n\t\t//printf(\"ok! %d\\n\",i);\n\t\tdp2[i]=1;\n\t\trep(j,inf){\n\t\t\tint to=i+j;\n\t\t\tif(to>inf)continue;\n\t\t\tdp2[to]=min(dp2[to],dp2[j]+1);\n\t\t}\n\t}\n\t\n\t\n\tfor(;;){\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tif(!p)break;\n\t\tprintf(\"%d %d\\n\",dp[p],dp2[p]);\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\n#define MAX 1000001\n#define pb( a ) push_back( a )\n/*\nvとkv(奇数用)を用意して\nガンガンまわす\n*/\nint t[MAX],kt[MAX];\nint main(){\n\t\n\tmemset(t,MAX,sizeof(t));\n\tmemset(kt,MAX,sizeof(kt));\n\tt[0]=kt[0]=0;\n\tvector<int>v,kv;\n\tfor(int i=1;1;i++){\n\t\tint tmp= i*(i+1)*(i+2)/6;\n\t\tif(tmp>MAX)break;\n\t\tv.pb(tmp);\n\t\tif(tmp%2)kv.pb(tmp);\n\t}\n\t\n\tfor(int i=0;i<MAX;i++){\n\t\tfor(int j=0;j<v.size();j++){\n\t\t\tint tmp=i+v[j];\n\t\t\tif(tmp>=MAX)break;\n\t\t\tt[tmp]=min(t[i]+1,t[tmp]);\n\t\t}\n\t\tfor(int j=0;j<kv.size();j++){\n\t\t\tint tmp=i+kv[j];\n\t\t\tif(tmp>=MAX)break;\n\t\t\tkt[tmp]=min(kt[i]+1,kt[tmp]);\n\t\t}\n\t}\n\t\n\tfor(int n;cin>>n,n;)cout<<t[n]<<\" \"<<kt[n]<<endl;;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP_N(i,n,s) for(ll i=0; i<(ll)n; i+=s)\n#define REP(i,n) REP_N(i,n,1)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nvoid solution(ll output[1000001], int interval) {\n\toutput[0] = 0;\n\tll current_i = 1-interval;\n\tREP(i, 1000001) if (i != 0) {\n\t\tif (table[current_i + interval] == i){\n\t\t\tcurrent_i += interval;\n\t\t\toutput[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tll minimum = 1000001;\n\t\tREP_N(j, current_i+1, interval) if(j!=0) minimum = min(output[i - table[j]] + 1, minimum);\n\t\toutput[i] = minimum;\n\n\t}\n}\n\nint main() {\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i++]) table[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tsolution(pollock, 1);\n\tsolution(dp, 4);\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nstatic const int INFTY = (1 << 29);\nstatic const int MAXN = 1000000;\nstatic const int LEN = 182;\nint T[MAXN+1], T2[MAXN+1];\n\nint main()\n{\n    int arr[LEN];\n    int i = 0, sum = 0;\n    while(sum <= MAXN) {\n        arr[i] = sum;\n        i++;\n        sum = i*(i+1)*(i+2) / 6;\n    }\n    int N;\n    for (int i = 0; i <= MAXN; i++) T[i] = T2[i] = INFTY;\n    T[0] = T2[0] = 0;\n    T[1] = T2[1] = 1;\n\n    for(int i = 2; i < MAXN; i++){\n       for(int j = 1; arr[j] <= i; j++){\n            T[i] = min(T[i], T[i-arr[j]]+1);\n            if(arr[j] % 2 != 0){\n                T2[i] = min(T2[i], T2[i-arr[j]]+1);\n            }\n        }\n    }\n\n    for (; ; ) {\n        scanf(\"%d\", &N);\n        if (N == 0) break;\n        printf(\"%d %d\\n\", T[N], T2[N]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    //int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  //tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    //int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",1,2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<int> four;\n    for(int i=1;i*(i+1)*(i+2)/6<=n;i++){\n      four.push_back(i*(i+1)*(i+2)/6);\n    }\n    vector<int> dp(n+1,1000000);\n    dp[0]=0;\n    for(int i=0;i<four.size();i++){\n      for(int j=four[i];j<=n;j++){\n\tdp[j] = min(dp[j-four[i]] + 1,dp[j]);\n      }\n      /*      REP(i,n+1)cout << dp[i] << \" \";\n\t      cout << endl;*/\n\t}\n    cout << dp[n] << \" \";\n    dp.clear();\n    dp.resize(n+1,10000000);\n    dp[0]=0;\n    for(int i=0;i<four.size();i++){\n      if(four[i]%2){\n\tfor(int j=four[i];j<=n;j++){\n\t  dp[j] = min(dp[j-four[i]] + 1,dp[j]);\n\t}\n      }\n      /*            REP(i,n+1)cout << dp[i] << \" \";\n\t\t    cout << endl;*/\n    }\n \n    cout << dp[n] << endl;\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n\n  for(int i=0;i<1111111;i+=100){ solve(i), solve2(i); }\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n\nint t[1000*1000+1];\nint ot[1000*1000+1];\n\nvoid init() {\n    memset(t, -1, sizeof(t));\n    memset(ot, -1, sizeof(ot));\n    for (int i = 1; ; i++) {\n        int n = i * (i+1) * (i+2) / 6;\n        if (n > 1000*1000) break;\n        t[n] = 1;\n        if (n % 2) ot[n] = 1;\n    }\n}\n\nint count_t(int n) {\n    if (t[n] >= 0) return t[n];\n    int ans = INF;\n    for (int i = 1; ; i++) {\n        int p = i * (i+1) * (i+2) / 6;\n        if (n < p) break;\n        ans = min(ans, count_t(n - p)+1);\n    }\n    return t[n] = ans;\n}\n\nint count_odd_t(int n) {\n    if (ot[n] >= 0) return ot[n];\n    int ans = INF;\n    for (int i = 1; ; i++) {\n        int p = i * (i+1) * (i+2) / 6;\n        if (n < p) break;\n        if (p % 2) ans = min(ans, count_odd_t(n - p)+1);\n    }\n    return ot[n] = ans;\n}\n\nint main() {\n    init();\n    int n;\n    while (scanf(\"%d\", &n), n) {\n        printf(\"%d %d\\n\", count_t(n), count_odd_t(n));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[100][100] = {{0}, {0}};\n\n  for (i = 1; i <= 180; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  int a = 0;\n  while (cin >> input) {\n    if (input == 0) break;\n    int temp = input;\n    int j = 1, min = 1000000000;\n    while (tetras[j] <= input) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j++;\n      input = temp;\n    }\n    ans[a][0] = min;\n    j = 1, min = 1000000000;\n    while (tetras[j] <= input) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tif (tetras[k] % 2 == 0) {\n\t  k--;\n\t  continue;\n\t}\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j++;\n      input = temp;\n    }\n    ans[a][1] = min;\n    a++;\n  }\n\n  int b;\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 1000000\n\nint main(){\n\tvector <int> v(200);\n\tfor(int i = 0; i < 200; i++)\n\t\tv[i] = i * (i + 1) * (i + 2) / 6;\n\t\n\twhile(1){\n\t\tint s, ans1, ans2;\n\t\tcin >> s;\n\t\t\n\t\tif(s == 0)\n\t\t\tbreak;\n\t\t\n\t\tfor(int k = 1; k <= 2; k++){\n\t\t\tvector <int> d(s + 1, INF);\n\t\t\t\n\t\t\td[0] = 0;\n\t\t\tfor(int i = 1; i <= s; i++){\n\t\t\t\tfor(int j = 0; v[j] <= i; j++){\n\t\t\t\t\tif(k == 1)\n\t\t\t\t\t\td[i] = min(d[i], d[i - v[j]] + 1);\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(v[j] % 2 != 0)\n\t\t\t\t\t\t\td[i] = min(d[i], d[i - v[j]] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k == 1)\n\t\t\t\tans1 = d[s];\n\t\t\telse\n\t\t\t\tans2 = d[s];\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint List[100];\n\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n/*\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n*/\t}\n\tList[i]=i*(i+1)*(i+2)/6;\n\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\nconst int N = 1000000;\n\ntemplate<typename T> inline void chmin(T& t, T f){if(t > f)t = f;}\n\nvector<int> mem1, mem2;\n\nvoid calc(vector<int>& v, vector<int>& mem){\n    mem.resize(N); iota(all(mem), 0);\n    rep(i, N)for(auto j: v){\n        if(i < j)break;\n        chmin(mem[i], mem[i-j]+1);\n    }\n}\n\nvoid init(){\n    vector<int> num, odd;\n    for(int i=1, x=1; x<N; ++i, x=i*(i+1)*(i+2)/6){\n        num.push_back(x);\n        if(x&1)odd.push_back(x);\n    }\n    calc(num, mem1);\n    calc(odd, mem2);\n}\n\nint main(){\n    init();\n    int n;\n    while(cin >> n, n)cout << mem1[n] << ' ' << mem2[n]<< '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\nint fourth[201];\nint odd[201];\nint mintable[1500000];\nint mintableOdd[1500000];\n\nvoid Init(){\n\tfourth[0] = 0;\n\todd[0] = 0;\n\tfor(int i = 1, j = 1; i <= 200; i++){\n\t\tfourth[i] = (i*(i+1)*(i+2))/6;\n\t\tmintable[fourth[i]] = 1;\n\t\tif(fourth[i]%2){\n\t\t\todd[j] = fourth[i];\n\t\t\tmintableOdd[odd[j]] = 1;\n\t\t\tj++;\n\t\t}\n\t}\n}\n\nint dfs(int n){\n\tfor(int i = 2; i <= n/i; i++){\n\t\tif(n%i==0){\n\t\t\treturn min(dfs(n/i)*i, mintable[n]);\n\t\t}\n\t}\n\treturn mintable[n];\n}\n\nint dfsOdd(int n){\n\tfor(int i = 3; i <= n/i; i+=2){\n\t\tif(n%i==0){\n\t\t\treturn min(dfsOdd(n/i)*i, mintableOdd[n]);\n\t\t}\n\t}\n\treturn mintableOdd[n];\n}\n\nint countFourth(int n){\n\tint min = 10000;\n\tfor(int i = 200; i >= 1; i--){\n\t\tif(n>=fourth[i]){\n\t\t\tint tmp = n;\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j >= 1; j--){\n\t\t\t\twhile(tmp>=fourth[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp -= fourth[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = min>count?count:min; \n\t\t}\n\t}\n\treturn min;\n}\n\nint countFourthOdd(int n){\n\tint min = 10000;\n\tfor(int i = 50; i >= 1; i--){\n\t\tif(n>=odd[i]){\n\t\t\tint tmp = n;\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j >= 1; j--){\n\t\t\t\twhile(tmp>=odd[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp -= odd[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = min>count?count:min; \n\t\t}\n\t}\n\treturn min;\n}\n\nint main(){\n\tmemset(mintable, 0, sizeof(mintable));\n\tInit();\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(mintable[i]&&mintableOdd[i]) continue;\t\t\n\t\t\tmintable[i] = countFourth(i);\n\t\t\tmintable[i] = dfs(i);\n\t\t\tmintableOdd[i] = countFourthOdd(i);\n\t\t\tmintableOdd[i] = dfsOdd(i);\n\t\t}\n\t\tcout << mintable[n] << \" \" << mintableOdd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvi tetra, odd_tetra;\nvi table(1000001, INF);\nint ans, odd;\n\nvoid search(int n, int step);\nint odd_search(int n);\nvoid make_tetra();\nvoid make_odd_tetra();\n\n\nsigned main()\n{\n    odd = 0;\n    make_tetra();\n    make_odd_tetra();\n\n    Int(n);\n\n    while (n) {\n        ans = INF;\n        search(n, 0);\n        cout << ans;\n        cout << \" \" << odd_search(n) << endl;\n        cin >> n;\n    }\n\n    cout << odd << endl;\n    return 0;\n}\n\n\nint odd_search(int n)\n{\n    return table[n];\n}\n\nvoid search(int n, int step)\n{\n    if (ans <= step) {\n        return;\n    } else if (!n) {\n        ans = step;\n        return ;\n    } else if (n < 0) {\n        return;\n    }\n    for (int i = tetra.size()-1; i >= 0; i--) {\n        if (n >= tetra[i]) {\n            search(n-tetra[i], step+1);\n        }\n    }\n}\n\n\nvoid make_tetra()\n{\n    Rep(i, 181) {\n        tetra.pb(i * (i + 1) * (i + 2) /6);\n    }\n}\n\nvoid make_odd_tetra()\n{\n    for (int i : tetra) {\n        if (i % 2) {\n            odd_tetra.pb(i);\n            table[i] = 1;\n        }\n    }\n    table[0] = 0;\n    Rep(x, 1000000) {\n        int ret = INF;\n        for (int i : odd_tetra) {\n            if (x < i) {\n                break;\n            } else {\n                ret = min(ret, table[x - i] + 1);\n            }\n        }\n        table[x] = ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[10000000], dp2[10000000];\nint main() {\n\tv.pb(0);\n\tll n, now = 1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)(i*(i + 1)*(i + 2) / 6);\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 1000000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], (ll)i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 1000000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], (ll)i / v[j] + dp2[i%v[j]]);\n\t}\n\twhile (cin >> n, n) {\n\t\trep(i, n)cout << i << \"ha\" << dp[i] << endl;\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main(){\n    //INFで初期化\n    for(int i = 1;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n * 2) /6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;  //ポロック数の生成\n        for(int i = a;i <= MAX;i++)     //正四面体数の個数dp(a以下は必要ない)\n            dp1[i] = min(dp1[i],dp1[i-a] + 1);  //更新しないor左側から更新する\n        if(a % 2 == 0)continue;     //偶数の時は次のroopへ\n        for(int i = a;i <= MAX;i++)     //奇数の正四面体数の個数dp(a以下は必要ない)\n            dp2[i] = min(dp2[i],dp2[i-a] + 1);  //更新しないor左側から更新する\n    }\n\n    //入出力\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n\nconst int N = 1e6+1;\n\nll dp[N], dp2[N];\n\nint main() {\n\n    dp[0] = dp2[0] = 0;\n    for (int i=1; i<N; ++i) {\n        dp[i] = dp2[i] = i;\n        for (int j=1; ; ++j) {\n            int p=j*(j+1)*(j+2)/6;\n            if (p > i) break;\n            dp[i] = min(dp[i], dp[i-p]+1);\n            if (p%2) {\n                dp2[i] = min(dp2[i], dp2[i-p]+1);\n            }\n        }\n    }\n\n    int n;\n    while (cin >> n and n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> A(M,INF), A_odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  A_odd[0] = 0;\n  while(t < 1000000){\n    for(int k = 0; k+t < M; ++k){\n      A[k+t] = min(A[k]+1,A[k+t]);\n      if(t%2) A_odd[k+t] = min(A_odd[k]+1,A_odd[k+t]);\n    }\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << A_odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n - 1); i >= 0; i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) int(x.size())\n#define get_unique(x) x.erase(unique(all(x)), x.end());\ntypedef long long ll;\ntypedef complex<double> Complex;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\nconst ll LINF = 1e18;\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\nint main() {\n    vector<int> v;\n    for (int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; i++) {\n        v.push_back(i * (i + 1) * (i + 2) / 6);\n    }\n    vector<int> dp0(1001001, INF), dp1(1001001, INF);\n    dp0[0] = 0, dp1[0] = 0;\n    for (int i = 1; i < 1001001; i++) {\n        for (int x : v) {\n            if (i - x < 0) break;\n            chmin(dp0[i], dp0[i - x] + 1);\n            if (x % 2 == 1) chmin(dp1[i], dp1[i - x] + 1);\n        }\n    }\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        cout << dp0[n] << \" \" << dp1[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define mod 1000000007\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define showp(n) cerr<<n.fs<<\", \"<<n.sc<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n#define showsp(n) for(auto z:n){cerr<<z.fs<<\" \"<<z.sc<<\", \"}cerr<<endl\n\n#define yes printf(\"Yes\\n\")\n#define no printf(\"No\\n\")\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int,int>;\n\nconst int INF=1LL<<55;\n\nint n;\nint a[1000001],b[1000001];\nint v;\n\nvoid ume(){\n    REP(i,1,1000001){\n        a[i]=b[i]=i;\n        for(int j=0;;j++){\n            v=j*(j+1)*(j+2)/6;\n            if(i-v<0) break;\n            a[i]=min(a[i], a[i-v]+1);\n            if(v&1) b[i]=min(b[i],b[i-v]+1);\n        }\n    }\n}\n\nvoid solve(){\n    \n    cout<<a[n]<<\" \"<<b[n]<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ume();\n    while(cin>>n,n){\n        solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n \nint dp[1000010];\nint dp2[1000010];\n\nint main(){\n\tint a = 1, b;\n\tvi v;\n\tvi u;\n\twhile((b = a*(a+1)*(a+2)/6)<1e6){\n\t\tv.pb(b);\n\t\tif(b%2 == 1){\n\t\t\tu.pb(b);\n\t\t}\n\t\ta++;\n\t}\n\t//cout<<v.size()<<endl;\n\tfor(int i = 0; i < 1000010; i++){\n\t\tdp[i] = INF;\n\t\tdp2[i] = INF;\n\t}\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tfor(int j = v[i]; j < 1000010; j++){\n\t\t\tdp[j] = min(dp[j], dp[j-v[i]]+1);\n\t\t\tif(j < u.size()){\n\t\t\t\tdp2[j] = min(dp2[j], dp2[j-u[i]]+1);\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<\"OK\"<<endl;\n\tint n;\n\twhile(cin>>n && n > 0){\n\t\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll n,a,dp[1000001],dp2[1000001];\nvector<ll> v,u;\nint main(void){\n    for(ll i=1;i<1000;i++){\n        a+=i*(i+1)/2;\n        //cout<<a<<endl;\n        if(a<=1000000){\n            v.push_back(a);\n            if(a%2==1)u.push_back(a);\n        }\n        else break;\n    }\n    for(int i=0;i<=1000000;i++)dp[i]=i;\n    for(int i=0;i<=1000000;i++)dp2[i]=i;\n    for(int i=1;i<v.size();i++){\n        for(int j=0;j+v[i]<=1000000;j++){\n            dp[j+v[i]]=min(dp[j+v[i]],dp[j]+1);\n        }\n    }\n    for(int i=1;i<u.size();i++){\n        for(int j=0;j+u[i]<=1000000;j++){\n            dp2[j+u[i]]=min(dp2[j+u[i]],dp2[j]+1);\n        }\n    }\n    while(1){\n    cin>>n;\n    if(n==0)return 0;\n        cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 1000000\nusing namespace std;\n\nint main(){\n  int n,tmp,dp[N],dp_odd[N];\n  int plc[1000],num;\n\n  for(int i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint func(int n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint solve1(int n, int j)\n{\n  int c = 0, m = 1000000;\n  for(int i = j; n >= 0; i--){\n    while(n >= func(i)){\n      c++;\n      n -= func(i);\n    }\n    if(n == 0)\n      break;\n  }\n  m = min(m, c);\n  return m;\n}\n\nint solve2(int n, int j)\n{\n  int c = 0, m = 1000000;\n  for(int i = j; n >= 0; i--){\n    while(n >= func(i) && (func(i) & 1)){\n      c++;\n      n -= func(i);\n    }\n    if(n == 0)\n      break;\n  }\n  m = min(m, c);\n  return m;\n} \n\nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      int m1, m2;\n      m1 = m2 = 1000000;\n      int k = 1;\n      while(n >= func(k)) \n\tk++;\n      for(int i = k - 1; i >= 1; i--){\n\tm1 = min(m1, solve1(n, i));\n\tm2 = min(m2, solve2(n, i));\n      }\n      cout << m1 << \" \" << m2 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nint N;\n\nint L[200];\nint M[200];\nint M_max;\n\nvoid init() {\n    for (int i = 1; i <= 200; i++) {\n        L[i - 1] = (i * (i + 1) * (i + 2)) / 6;\n    }\n\n    int j = 0;\n    for (int i = 0; i < 200; i++) {\n        if (L[i] % 2 == 1) {\n            M[j++] = L[i];\n        }\n    }\n    M_max = j;\n}\n\nint f(int nth, int s) {\n    int r = N - s;\n    int start = distance(L, upper_bound(L, L + 200, r)) - 1;\n\n    int m = 100;\n    for (int i = start; i >= 0 && r <= (5 - nth) * L[i]; i--) {\n        if (r == L[i]) {\n            return nth + 1;\n        }\n\n        m = min(m, f(nth + 1, s + L[i]));\n    }\n\n    return m;\n}\n\nint g(int nth, int s) {\n    int r = N - s;\n    int start = distance(M, upper_bound(M, M + M_max, r)) - 1;\n\n    int m = 100;\n    for (int i = start; i >= 0; i--) {\n        if (r == M[i]) {\n            return nth + 1;\n        }\n\n        m = min(m, g(nth + 1, s + M[i]));\n    }\n\n    return m;\n}\n\nvoid solve() {\n    printf(\"%d %d\\n\", f(0, 0), g(0, 0));\n}\n\nint main() {\n    init();\n    while (true) {\n        scanf(\"%d\", &N);\n        if (!N) {\n            break;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint p[200],q[50];\n\nint f(int n,int m,int c){\n\tif(c==4&&n>0)return 5;\n\tif(n<10)return min(c+n/4+n%4,5);\n\tint rec=5,i=0;\n\twhile(p[i]<n/(4-c))i++;\n\tfor(i;p[i]<=m;i++)rec=min(rec,f(n-p[i],min(p[i],n-p[i]),c+1));\n\treturn rec;\n}\n\nint g(int n,int m,int c){\n\tif(n<165)return c+n/35+n%35;\n\tint rec=99999;\n\tfor(int i=1;q[i]<=m;i++)rec=min(rec,f(n-q[i],min(q[i],n-q[i]),c+1));\n\treturn rec;\n}\n\nint main(){\n\tfor(int i=0;(i+1)*(i+2)*(i+3)/6<=1000000;i++)p[i]=(i+1)*(i+2)*(i+3)/6;\n\tfor(int i=0;(4*i+1)*(4*i+2)*(4*i+3)/6<=1000000;i++)q[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\tint N;\n\twhile(cin>>N){\n\t\tif(!N)return 0;\n\t\tcout<<f(N,N,0)<<\" \"<<g(N,N,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint coin[100000];\nint coin_ki[100000];\nint dp[100000]={1000000};\nint dp2[100000];\n\nint main(void)\n{\n\n  int count=0;\n  int count_ki=0;\n  int tmp;\n  int ans_tmp=0;\n  int ans2_tmp=0;\n    \n   \n  int tmp2=0;\n\n  for(int i=1;i<100000;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>1000000)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n   \n  \n    \n    \n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //printf(\"dp[%d]=%d\\n\",i+coin[j],dp[i+coin[j]]);\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    \n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n      \n\n    \n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  ans2_tmp=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  dp2[i+coin_ki[j]]=ans2_tmp;\n\t  //printf(\"dp2[%d]=%d\\n\",i+coin_ki[j],dp[i+coin_ki[j]]);\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n\n    //for(int i=0;i<count;i++)\n      //printf(\"coin[%d]=%d\\n\",i,coin[i]);\n      //for(int i=0;i<count_ki;i++)\n      //printf(\"coin_ki[%d]=%d\\n\",i,coin_ki[i]);\n\n\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,i,j,k,t=0,a[250]={},b[200]={},c[1000005]={2000000},d[1000005]={1000000};\n  for(i=1;i<250;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(a[i-1]%2==1)b[t++]=a[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<250;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t-1;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<d[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i, n) for(int i=0;i<n;i++)\n#define REP(i, n) for(int i=1;i<=n;i++)\ntypedef long long ll;\n\nconst int INF = 1000000000;\nint dp[1000005];\nint dp2[1000005];\n\nint main() {\n\tvector<ll> shimentaisuu(200);\n\tREP(i, 200) {\n\t\tshimentaisuu[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\t\n\tvector<int> input;\n\t\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tinput.push_back(n);\n\t}\n\t\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= 1000000; ++i) {\n\t\tdp[i] = INF;\n\t\tdp2[i] = INF;\n\t\tREP(j, 200) {\n\t\t\tif (shimentaisuu[j] > i) break;\n\t\t\tdp[i] = min(dp[i], dp[i - shimentaisuu[j]] + 1);\n\t\t\tif (j % 4 == 1) {\n\t\t\t\tdp2[i] = min(dp2[i], dp2[i - shimentaisuu[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,input.size()){\n\t\tcout << dp[input[i]] << \" \" << dp2[input[i]] << endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    //int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    //int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",1,2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n,res =inf;\nconst int MAX = 1000100;\nint solve(int a,int b,int c,vector<int> v, int** dp){\n  if(dp[b][a] == 1) return b;\n  else if(dp[b][a] == -1) return inf;\n  dp[b][a] = -1;\n  if(b == 0) res = inf;\n  if(a == n){\n    res = min(res,b);\n    dp[b][a] = 1;\n    return b;\n  }\n  if(a > n || res < b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v,dp),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < MAX){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    {\n      const size_t s = suqnum.size();\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb1,suqnum,arg) << \" \";\n      rep(i,s) delete[] dp[i];\n    }\n    {\n      const size_t s = odd.size();\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb2,odd,arg)<<endl;\n      rep(i,s) delete[] dp[i];\n    }\n//     queue<pii> q;\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb1,suqnum.size()){\n//         if(p.se+suqnum[i] == n){\n//           cout << p.fi+1<< \" \";\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+suqnum[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n//         }\n//       }\n//     }\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb2,odd.size()){\n//         if(p.se+odd[i] == n){\n//           cout << p.fi+1<< endl;\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+odd[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+odd[i]));\n//         }\n//       }\n//     }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <iostream>\n#include <limits>\n\nusing namespace std;\n\nint main()\n{\n    array<int, 1000001> dp = {};\n    fill(begin(dp), end(dp), numeric_limits<int>::max());\n    dp[0] = 0;\n    auto dp2 = dp;\n    auto tetrahedral = [](int n) { return n * (n + 1) * (n + 2) / 6; };\n    for (int i = 1; tetrahedral(i) < dp.size(); ++i) {\n        const auto t = tetrahedral(i);\n        for (int j = 0; j + t < dp.size(); ++j) {\n            dp[j + t] = min(dp[j + t], dp[j] + 1);\n        }\n        if (t % 2 == 1) {\n            for (int j = 0; j + t < dp2.size(); ++j) {\n                dp2[j + t] = min(dp2[j + t], dp2[j] + 1);\n            }\n        }\n    }\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        cout << dp[n] << ' ' << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvector <int> c;\nvector <int> a,b;\n\nint main() {\n\n\n  c.push_back(0);\n  for(int i=1;c[i-1]<=1000010;i++) c.push_back(i*(i+1)*(i+2)/6);\n   \n  for(int i=0;i<=1000000;i++) {\n    a.push_back(i);\n    b.push_back(i);\n  }\n  \n  for(int i=0;i<c.size();i++) {\n    for(int j=1;j<=1000000;j++) {\n      \n      if(j-c[i] >=0) { \n     \n\tif(a[j-c[i]] >= 0) a[j] = min(a[j], a[j-c[i]]+1);\n\n\tif(c[i] % 2 == 1 && b[j-c[i]] >0){\n\t  b[j] = min(b[j],b[j-c[i]]+1);\n\t}\n      }\n      \n    }\n  }\n\n while(1) {\n    int m;\n  cin >> m;\n  if(m == 0) break;\n  \n  cout << a[m] <<\" \" << b[m] << endl;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n/*\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e6;\nconst int INF = 1e9;\n \nint main()\n{\n\tcin.sync_with_stdio(false);\n    vector<int> dp(MAX, INF), res(MAX, INF), four, odd;\n    for (int i = 1; i * (i + 1) * (i + 2) / 6 < MAX; i++) {\n        four.push_back(i * (i + 1) * (i + 2) / 6);\n        if (i * (i + 1) * (i + 2) / 6 % 2)\n            odd.push_back(i * (i + 1) * (i + 2) / 6);\n    }\n    dp[0] = res[0] = 0;\n    for (int j = 0; j < MAX; j++) {\n        if (dp[j] != INF) {\n            for (int k = 0; k < (int)four.size() && j + four[k] < MAX;k++) {\n                dp[j + four[k]] = min(dp[j + four[k]], dp[j] + 1);\n            }\n        }\n    }\n    for (int j = 0; j < MAX; j++) {\n        if (res[j] != INF) {\n            for (int k = 0; k < (int)odd.size() && j + odd[k] < MAX; k++) {\n                res[j + odd[k]] = min(res[j + odd[k]], res[j] + 1);\n            }\n        }\n    }\n    int n;\n    while (cin >> n, n) {\n        printf(\"%d %d\\n\", dp[n], res[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<numeric>\n#include<utility>\n\nusing namespace std;\n\ntypedef long long int ll;\nconst int INF = 1<<30;\nconst long long LINF = 1LL<<60;\n\nint main(){\n    vector<int> a, b;\n    int x = 1;\n    while(1){\n        ll y = (x * (x + 1) * (x + 2)) / 6;\n        if(y > 1000000){\n            break;\n        }\n        a.push_back(y);\n        if(y % 2 == 1) b.push_back(y);\n        x++;\n    }\n    vector<int> dp1(1000001, INF), dp2(1000001, INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(auto&& i : a){\n        for(int j = 0; j <= 1000000 - i; j++){\n            dp1[j + i] = min(dp1[j + i], dp1[j] + 1); \n        }\n    }\n    for(auto&& i : b){\n        for(int j = 0; j <= 1000000 - i; j++){\n            dp2[j + i] = min(dp2[j + i], dp2[j] + 1); \n        }\n    }\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint dp[1000001],Odp[1000001];\nint Tn[200],OTn[200]; \n\nint main(){\n    int count = 0;  //pollocks numberの生成\n    for(int i = 1;i < 200;i++){\n        Tn[i-1] = i * (i + 1) * (i + 2) / 6;\n        if(Tn[i-1] % 2 == 1){\n            OTn[count] = Tn[i-1];\n            count++;\n        }\n    }\n    int n = 1000000;\n\n    //正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        dp[j] = j;\n    int k;\n    for(int i = 0;i < 200;i++)\n        for(int j = Tn[i];j <= 1000000;j++){\n            if(j >= Tn[i])\n                dp[j] = min(dp[j],dp[j-Tn[i]] + 1);\n            k = i;\n        }\n\n    //奇数正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        Odp[j] = j;\n    int k1;\n    for(int i = 0;i <= 200;i++)\n        for(int j = OTn[i];j <= n;j++){\n            if(j >= OTn[i])\n                Odp[j] = min(Odp[j],Odp[j-OTn[i]] + 1);\n            k1 = i;\n        }\n    while(cin >> n,n)\n        cout << dp[n] << ' ' <<  Odp[n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[84];\n    int b[22];\n    int t[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\n#define int long long\n#define dotimes(i, n) for (int i : range(n))\n\nusing namespace std;\n\nclass range {\n  class iterator {\n    int i, s;\n  public:\n    iterator(int i, int s): i(i), s(s) {}\n    int& operator*() {\n      return i;\n    }\n    void operator++() {\n      i += s;\n    }\n    bool operator!=(iterator const& that) {\n      return i < that.i;\n    }\n  };\n  iterator b, e;\npublic:\n  range(int e): b({0, 1}), e({e, 1}) {}\n  range(int b, int e): b({b, 1}), e({e, 1}) {}\n  range(int b, int e, int s): b({b, s}), e({e, s}) {}\n  iterator begin() {\n    return b;\n  }\n  iterator end() {\n    return e;\n  }\n};\n\nint rint() {\n  int n;\n  scanf(\"%lld\", &n);\n  return n;\n}\n\nvoid wint(int n) {\n  printf(\"%lld\\n\", n);\n}\n\ntemplate<typename T>\ninline int size(T container) {\n  return static_cast<int>(container.size());\n}\n\ntemplate<typename T>\ninline bool maxs(T& a, T const& b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T>\ninline bool mins(T& a, T const& b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nconst int N = static_cast<int>(1e6);\nint dp[N][2];\n\nsigned main() {\n  vector<int> pollock;\n  // skip n = 1\n  for (int n = 2;; n++) {\n    int p = n*(n+1)*(n+2)/6;\n    if (p >= N)\n      break;\n    pollock.emplace_back(p);\n  }\n  dotimes(i, N) dotimes(j, 2)\n    dp[i][j] = i;\n  for (int p : pollock) {\n    if (p % 2)\n      dotimes(i, N - p) {\n        mins(dp[p+i][0], dp[i][0] + 1);\n        mins(dp[p+i][1], dp[i][1] + 1);\n      }\n    else\n      dotimes(i, N - p)\n        mins(dp[p+i][0], dp[i][0] + 1);\n  }\n  for (;;) {\n    int x = rint();\n    if (!x)\n      break;\n    printf(\"%lld %lld\\n\", dp[x][0], dp[x][1]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst int SIZE = 300;\nconst int N = 1000002;\nint p[SIZE+1];\nint dp1[N], dp2[N];\n\nvoid make_pollock (void )\n{\n\tmemset (p, 0, sizeof (p ) );\n\n\tfor (int i = 0; i <= SIZE; i++ )\n\t\tp[i] = i*(i+1LL)*(i+2LL)/6LL;\n}\n\nvoid make_dp (void )\n{\n\tfill (dp1, dp1+N, INF );\n\tfill (dp2, dp2+N, INF );\n\n\tdp1[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tif (dp1[j] > dp1[j - m] + 1 )\n\t\t\t\tdp1[j] = dp1[j - m] + 1;\n\t} // end for\n\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tif (p[i] % 2 == 0 ) continue;\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tif (dp2[j] > dp2[j - m] + 1 )\n\t\t\t\tdp2[j] = dp2[j - m] + 1;\n\t} // end for\t\n}\n\t\nint main()\n{\n\tmake_pollock();\n\tmake_dp ();\n\n\tint n;\n\twhile (cin >> n && n )\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    vector<int> dp(1000001, 1e9);\n    vector<int> dp2(1000001, 1e9);\n    dp[0] = dp2[0] = 0;\n    for(int i=1; i*(i+1)*(i+2)/6 <= 1000000; ++i) {\n        int l = i*(i+1)*(i+2)/6;\n        for(int j=0; j+l<=1000000; ++j) {\n            dp[j+l] = min(dp[j+l], dp[j] + 1);\n        }\n        if(l % 2 == 1) {\n            for(int j=0; j+l<=1000000; ++j) {\n                dp2[j+l] = min(dp2[j+l], dp2[j] + 1);\n            }\n        }\n    }\n\n\n    int n;\n    while(cin >> n, n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n \n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nconst int limit = 200;\nint tetra[limit];\nint odd[limit];\nint ans(int n, int index, int *a) {\n    if(n < a[1] || index==0) return n;\n    int i;\n    for(i=index; i>0; --i) {\n        if(a[i]<=n) break;\n    }\n    return min(1+ans(n-a[i], i, a), ans(n, i-1, a));\n}\n\nint main(void){\n    int size = 0;\n    int inf = numeric_limits<int>::max();\n    rep(i, limit) odd[i] = inf;\n    for(int i=1; i<limit+1; ++i) {\n        ll t = i*(i+1)*(i+2)/6;\n        tetra[i-1] = t;\n        if(t%2==1) {odd[size]=t; size++;}\n    }\n    int n;\n    while(cin >> n && n) {\n        cout << ans(n, limit-1, tetra) << \" \";\n        cout << ans(n, limit-1, odd) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define int long long\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\n\nconst int INF = 1 << 29;\n\nusing namespace std;\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, -1, 0, 1 };\nconst int MOD = 1000000007;\n\nsigned main() {\n\n\tconst int Maxnum = 1000000;\n\tvector<int> seisi = { 1 };\n\tint num = 2;\n\twhile (seisi.back() <= Maxnum)\n\t{\n\t\tseisi.push_back(num * (num + 1) * (num + 2) / 6);\n\t\tnum++;\n\t}\n\n\tvector<int> dp(Maxnum + 1, INF), kidp(Maxnum + 1, INF);\n\tdp[0] = 0;\n\tkidp[0] = 0;\n\trep(i, Maxnum) {\n\n\t\trep(j, seisi.size()) {\n\t\t\tif (i + seisi[j] > Maxnum) break;\n\t\t\tdp[i + seisi[j]] = min(dp[i + seisi[j]], dp[i] + 1);\n\n\t\t\tif (seisi[j] % 2) {\n\t\t\t\tkidp[i + seisi[j]] = min(kidp[i + seisi[j]], kidp[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n && n) {\n\n\t\tcout << dp[n] << \" \" << kidp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef int64_t ll;\nvector<int> polc;\narray<int, 1000000> p, od;\n\nvoid calc(){\n    for (int i = 0; i < p.size(); ++i) {\n        p[i] = od[i] = i;\n    }\n\n    for(auto&& plc: polc){\n        for (int i = plc; i < p.size(); ++i) {\n            p[i] = min(p[i], p[i-plc] + 1);\n        }\n        if(plc % 2) {\n            for (int i = plc; i < p.size(); ++i) {\n                od[i] = min(od[i], od[i - plc] + 1);\n            }\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for (int i = 1; i < 1000; ++i) {\n        int pl = i*(i+1)*(i+2) / 6;\n        if(pl > 1000000) break;\n        polc.push_back(pl);\n    }\n    int n;\n    calc();\n    while(cin >> n){\n        if(n == 0)\n            break;\n        cout << p[n] << ' ' << od[n] << endl;\n    }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#define INF (int)(1e9)\n#define MAXN 1000001\nusing namespace std;\n\nint sankaku[500];\nint simen[500];\nint simen2[500];\nint maxi,maxj;\nint dp[MAXN];\nint dp2[MAXN];\n\nvoid solve(){\n  int i,j,t;\n  int n=1111111;\n  for(i=0;i<MAXN;i++){\n    dp[i]=dp2[i]=INF;\n  }\n  dp[0]=dp2[0]=0;\n  for(i=0;i<=maxj;i++){\n    t=simen[i];\n    for(j=t;j<MAXN;j++){\n      dp[j]=min(dp[j],dp[j-t]+1);\n    }\n  }\n\n  for(i=0;i<=maxi;i++){\n    t=simen2[i];\n    //if(t%2==0) continue;\n    for(j=t;j<MAXN;j++){\n      dp2[j]=min(dp2[j],dp2[j-t]+1);\n    }\n  }\n}\n\n\nint main(void){\n  int n,i,j,t;\n  t=i=j=1;\n  sankaku[0]=1;\n  simen[0]=1;\n  simen2[0]=1;\n  while(simen[j-1]<MAXN){\n    sankaku[j]=sankaku[j-1]+j+1;\n    simen[j]=simen[j-1]+sankaku[j];\n    t=simen[j++];\n    if(t%2==1) simen2[i++]=t;\n  }\n  maxi=i;\n  maxj=j;\n  \n  solve();\n  /*\n  for(i=0;i<10;i++){\n    printf(\"%d : %d   %d\\n\",i,simen[i],simen2[i]);\n  }\n  */\n  while(scanf(\"%d\",&n),n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\n    int res=0xFFFF;\n    if(maxcnt<cnt) return 0xFFFE;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n        if(res==0xFFFE) break;\n    }\n    return res;\n}\n\nint mama(int x,int ress){\n    if(x==0) return ress;\n    int tmp[oddlistcnt];\n    memset(tmp,0,sizeof(tmp));\n    for(int i=0;i<oddlistcnt;i++){\n        tmp[i]=x/oddlist[i];\n        if(tmp[i]==0) {\n            ress+=tmp[i-1];\n//            cout << \"tmp[i-1]:\" << tmp[i-1] <<endl;\n//            cout << \"x%tmp[i-1]:\" << x%oddlist[i-1] <<endl;\n            return mama(x%oddlist[i-1],ress);\n            break;\n        }\n    }\n}\n\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        if((oddres=oddrec(n, 0, 0, 1))>=0xFFFE) {\n            for(int i=2; ; i=i*3/2) {\n                if((oddres=oddrec(n, 0, 0, i))<0xFFFE)\n                    break;\n            }\n        }\n\n\n        printf(\"%d %d\\n\",res,mama(n,0));\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\nint t(int x) { return x*(x+1)*(x+2)/6; }\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  Vi one, odd, two;\n  for (int i = 1; t(i) <= 1000000; i++) {\n    one.push_back(t(i));\n    if (t(i)%2) odd.push_back(t(i));\n  }\n\n  for (int a : one) {\n    for (int b : one) {\n      two.push_back(a+b);\n    }\n  }\n  sort(ALL(two));\n\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    if (n == *lower_bound(ALL(one), n)) {\n      cout << 1;\n    } else if (n == *lower_bound(ALL(two), n)) {\n      cout << 2;\n    } else {\n      bool flag = false;\n      for (int a : one) {\n\tif (n - a == *lower_bound(ALL(two), n - a)) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if (flag) {\n\tcout << 3;\n      } else {\n\tfor (int a : two) {\n\t  if (n - a == *lower_bound(ALL(two), n - a)) {\n\t    flag = true;\n\t    break;\n\t  }\n\t}\n\tcout << (flag ? 4 : 5);\n      }\n    }\n\n    int cnt = 0;\n    while (n > 0) {\n      auto it = lower_bound(ALL(odd), n);\n      if (n != *it) it--; \n      cnt += n / *it;\n      n %= *it;\n    }\n    cout << ' ' << cnt << endl;\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n int i,j,n,three[1000000],four[1000000],four_2[1000000],c[1000000],c_2[1000000];\n\nint main(){\n  \n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < 50; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < 50; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_N 1000000\n#define MAX_P 190\ntypedef unsigned int uint;\nint p[MAX_P];\nint op[MAX_P];\nint pn[MAX_N];\nint opn[MAX_N];\n#define INF 1000000\nint main()\n{\n//\tREP(i,MAX_P) p[i]=i*(i+1)*(i+2)/6;\n\tint c=0;\n\tREP(i,MAX_P)\n\t{\n\n\t\tp[i]=i*(i+1)*(i+2)/6;\n\t\tif((p[i]%2) ==1)\n\t\t{\n\t\t\tc++;\n\t\t\top[c]= p[i];\n\t\t}\n\t}\n\tmemset(pn,INF,MAX_N*sizeof(int));\n\tmemset(opn,INF,MAX_N*sizeof(int));\n\tpn[0]=opn[0]=0;\n\tfor(int i=0;i<MAX_N;i++)\n\t{\n\t\tfor(int j=0;j<MAX_P;j++)\n\t\t{\n\t\t\tif(i+p[j] > MAX_N) break;\n\t\t\tpn[i+p[j] ]=min(pn[i+p[j]] ,pn[i]+1);\n\t\t\t\n\t\t}\n\t}\n\tfor(int i=0;i<MAX_N;i++)\n\t{\n\t\tfor(int j=0;j<MAX_P;j++)\n\t\t{\n\t\t\tif(i+op[j] > MAX_N) break;\n\t\t\topn[i+op[j] ]=min(opn[i+op[j]] ,opn[i]+1);\n\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n &&n)\n\t{\n\t\tcout << pn[n]  <<\" \" << opn[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000\nusing namespace std;\n\nconst int M = 1000000;\nint N, base1[M + 1], base2[M + 2], dp1[M + 1], dp2[M + 1];\nvector<int> b1, b2;\n\nint dfs1(int n) {\n  if(dp1[n] >= 0) return dp1[n];\n  if(base1[n]) return dp1[n] = 1;\n\n  int ret = INF;\n  for(int i : b1) {\n    if(i < n) ret = min(ret, 1 + dfs1(n - i));\n    else break;\n  }\n  return dp1[n] = ret;\n}\n\nint dfs2(int n) {\n  if(dp2[n] >= 0) return dp2[n];\n  if(base2[n]) return dp2[n] = 1;\n\n  int ret = INF;\n  for(int i : b2) {\n    if(i < n) ret = min(ret, 1 + dfs2(n - i));\n    else break;\n  }\n  return dp2[n] = ret;\n}\n\nint main(void) {\n  REP(i, 1, M) dp1[i] = dp2[i] = -1, base1[i] = base2[i] = 0;\n  for(int i = 1, n; n = i * (i + 1) * (i + 2) / 6, n <= M; i++) {\n    base1[n] = 1, b1.push_back(n);\n    if(n % 2 == 1) base2[n] = 1, b2.push_back(n);\n  }\n\n  while(cin >> N, N) {\n    cout << dfs1(N) << \" \" << dfs2(N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\n#define PB push_back\n\nconst int inf = 1e9;\n\nint dp[1000001], dp_odd[1000001];\n\nint main()\n{\n\tvi tet, tet_odd;\n\n\tfor (int i = 1; ; ++i) {\n\t\ttet.PB(i * (i + 1) * (i + 2) / 6);\n\t\tif (tet.back() >= 1000000) break;\n\t}\n\n\tfor (int i = 0; i < tet.size(); ++i) {\n\t\tif (tet[i] & 1) tet_odd.PB(tet[i]);\n\t}\n\n\tfor (int i = 1; i <= 1000000; ++i) dp[i] = dp_odd[i] = inf;\n\n\tfor (int i = 1; i <= 1000000; ++i) {\n\t\tfor (int j = 0; j < tet.size(); ++j) {\n\t\t\tif (i >= tet[j]) {\n\t\t\t\tdp[i] = min(dp[i], dp[i - tet[j]] + 1);\n\t\t\t}\n\t\t\tif (i < tet[j]) break;\n\t\t}\n\n\t\tfor (int j = 0; j < tet_odd.size(); ++j) {\n\t\t\tif (i >= tet_odd[j]) {\n\t\t\t\tdp_odd[i] = min(dp_odd[i], dp_odd[i - tet_odd[j]] + 1);\n\t\t\t}\n\t\t\tif (i < tet_odd[j]) break;\n\t\t}\n\t}\n\n\tint N;\n\twhile (scanf(\"%d\", &N), N) printf(\"%d %d\\n\", dp[N], dp_odd[N]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nconst int Max = 1000000;\nvoid update(vector<int> &a,int x){\n  for(int i = x;i<Max;i++){\n    a[i] = min(a[i-x]+1,a[i]);\n  }\n}\n    \n\nint main(){\n  vector<int> a(Max,Max);\n  vector<int> o(Max,Max);\n  a[0]=0;o[0]=0;\n  for(int i=0;;i++){\n    int x=i*(i+1)*(i+2)/6;\n    if(x>Max)break;\n    update(a,x);\n    if(x&1)update(o,x);\n  }\n  int n;\n  while(cin>>n,n){\n    cout << a[n] << \" \" << o[n] << endl;\n  }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//----***やべーやつら***----\nusing namespace std;\n#define int long long\n\n//----***型定義***----\nusing ll = long long;\nusing P = pair<int,int>;\n\n//----***Like a Pythonista***----\n#define REP(ii,jj,nn) for (ll ii=jj;ii<(nn);ii++)\n#define RREP(ii,nn,jj) for (ll ii = nn; jj<ii;ii--)\n#define each(i,...) for (auto&& i:__VA_ARGS__)\n#define ALL(vec) (vec).begin(),(vec).end()\n#define sum(...) accumulate(ALL(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(ALL(__VA_ARGS__),0.0)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\ntemplate<class T> inline auto max(const T& a){ return *max_element(ALL(a)); }\ntemplate<class T> inline auto min(const T& a){ return *min_element(ALL(a)); }\ninline ll gcd(ll a,ll b){if(b == 0) return a;return  gcd(b,a%b);}\ninline ll lcm(ll a,ll b){ll g = gcd(a,b);return a / g * b;}\n\n//----***定数***----\n#define MOD 1000000007\n#define INF 100000000000000000\n#define EPS 1e-9\nconst vector<vector<int>> DXY={{-1,0},{1,0},{0,-1},{0,1}};\n\n//----***パーツ***----\n#define fr first\n#define se second\n#define pb push_back\n\n//----***入出力***---\n#define print(out) cout<< out  << \"\\n\";\n#define debug(var)  do{std::cerr << #var << \" ↓ \"<<\"\\n\";view(var);}while(0);\n#define dbg cerr<<\"🥺🥺🥺🥺🥺🥺\"<<endl;\ntemplate<typename T> void view(T e){std::cout << e << std::endl;}\ntemplate<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cout << e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void view(const std::vector<std::vector<T> >& vv){ for(const auto& v : vv){ view(v); } }\n\n//----***初期時読み込み***----\nstruct initial{initial(){cin.tie(0); ios::sync_with_stdio(0); cout<<fixed<<setprecision(15);};}initial_;\n\nvector<vector<int>>dp(30,vector<int>(500,0));\n\nsigned main(){\n  int a;\n  vector<int> input;\n  while(true){\n    cin>>a;\n    if(a==0)break;\n    input.push_back(a);\n  }\n  vector<int> pollock(200),dp0(1000010),dp1(1000010);\n\n  REP(i,0,200){\n    pollock[i]=(i+1)*(i+2)*(i+3)/6;\n  }\n  dp0[0]=dp1[0]=0;\n  REP(i,1,1000002){\n    dp0[i]=dp1[i]=i;\n    REP(j,0,200){\n      if(i<pollock[j])break;\n      dp0[i]=min(dp0[i],dp0[i-pollock[j]]+1);\n      if(pollock[j]%2==1){\n        dp1[i]=min(dp1[i],dp1[i-pollock[j]]+1);\n      }\n    }\n  }\n  // debug(dp1)\n  each(v,input){\n    cout<<dp0[v]<<' '<<dp1[v]<<\"\\n\";\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string.h>\n\nusing namespace std;\n\nint f[1000000];\n\nint main()\n{\n\tint t_num[182];\n\tint t_num_odd[182];\n\t\n\tint k=0;\n\tfor (int i=1;i<182;++i)\n\t{\n\t\tt_num[i-1] = i*(i+1)*(i+2)/6;\n\t\tif (t_num[i-1] % 2 == 1)\n\t\t{\n\t\t\tt_num_odd[k] = t_num[i-1];\n\t\t\t++k;\n\t\t}\t\t\n\t}\n\t\n\tint n;\n\tcin >> n;\n\t\n\twhile (n)\n\t{\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tfor (int j=0;j<181;++j)\n\t\t\t{\n\t\t\t\tif (i>=t_num[j]) f[i] = min(f[i],f[i-t_num[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << \" \";\n\t\t\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tfor (int j=0;j<k;++j)\n\t\t\t{\n\t\t\t\tif (i>=t_num_odd[j]) f[i] = min(f[i],f[i-t_num_odd[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << endl;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nint main(){\n\tstd::vector<int> quadruple{ 1, 3 }, quadruple_double, quadruple_odd;\n\twhile (quadruple[quadruple.size() - 2] <= 1000000) {\n\t\tquadruple.push_back(quadruple.back() + quadruple.size() + 1);\n\t\tquadruple[quadruple.size() - 2] += quadruple[quadruple.size() - 3];\n\t}\n\tquadruple.pop_back(); quadruple.pop_back();\n\tfor (auto i = 0; i < quadruple.size(); ++i) {\n\t\tfor (auto j = 0; j <= i; ++j) {\n\t\t\tquadruple_double.push_back(quadruple[i] + quadruple[j]);\n\t\t}\n\t}\n\tstd::sort(quadruple_double.begin(), quadruple_double.end());\n\tquadruple_double.erase(std::unique(quadruple_double.begin(), quadruple_double.end()), quadruple_double.end());\n\tstd::copy_if(quadruple.begin(), quadruple.end(), std::back_inserter(quadruple_odd), [](const int a) {return a % 2 == 1; });\n\tstd::vector<int> min_odd(1000001, 1000000);\n\tmin_odd[0] = 0;\n\tfor (auto i = 0; i < min_odd.size(); ++i) {\n\t\tfor (const auto o : quadruple_odd) if (o + i < min_odd.size()) {\n\t\t\tif (min_odd[o + i] > min_odd[i] + 1) {\n\t\t\t\tmin_odd[o + i] = min_odd[i] + 1;\n\t\t\t}\n\t\t}\n\t\telse break;\n\t}\n\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) return 0;\n\t\tif (std::binary_search(quadruple.begin(), quadruple.end(), n)) {\n\t\t\tstd::cout << 1;\n\t\t}\n\t\telse if (std::binary_search(quadruple_double.begin(), quadruple_double.end(), n)) {\n\t\t\tstd::cout << 2;\n\t\t}\n\t\telse if (std::any_of(quadruple.begin(), quadruple.end(), [&quadruple_double, n](const int q) {return std::binary_search(quadruple_double.begin(), quadruple_double.end(), n - q); })) {\n\t\t\tstd::cout << 3;\n\t\t}\n\t\telse if (std::any_of(quadruple_double.begin(), quadruple_double.end(), [&quadruple_double, n](const int q) {return std::binary_search(quadruple_double.begin(), quadruple_double.end(), n - q); })) {\n\t\t\tstd::cout << 4;\n\t\t}\n\t\telse {\n\t\t\tstd::cout << 5;\n\t\t}\n\t\tstd::cout << ' ' << min_odd[n] << '\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nconst int size = 200;\nconst int limit = 1000001;\nint dp[limit], dp_odd[limit];\nint tetra[size], odd[size];\n\nint main(void){\n    int size_odd = 0;\n    for(int i=1; i<size+1; ++i) {\n        ll t = i*(i+1)*(i+2)/6;\n        tetra[i-1] = t;\n        if(t%2==1) {odd[size_odd]=t; size_odd++;}\n    }\n    int inf = numeric_limits<int>::max();\n    rep(i, limit) dp[i] = dp_odd[i] = inf;\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    rep(i, size) {\n        for(int j=tetra[i]; j<limit; ++j)\n            dp[j] = min(dp[j-tetra[i]]+1, dp[j]);\n    }\n    rep(i, size_odd) {\n        for(int j=odd[i]; j<limit; ++j)\n            dp_odd[j] = min(dp_odd[j-odd[i]]+1, dp_odd[j]);\n    }\n\n    int n;\n    while(cin >> n && n) {\n        cout << dp[n] << \" \";\n        cout << dp_odd[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll dp1[1000005];\nll dp2[1000005];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for(ll i = 1; i <= 1000000; i++) {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    ll tmp = 0;\n    while(true) {\n        tmp++;\n        ll now = tmp * (tmp + 1) * (tmp + 2) / 6;\n        //cerr << tmp << \" \" << now << endl;\n        if(now > 1000000) break;\n        for(ll after = now; after <= 1000000; after++) {\n            dp1[after] = min(dp1[after], dp1[after-now] + 1);\n        }\n        if(now % 2 == 0) continue;\n        for(ll after = now; after <= 1000000; after++) {\n            dp2[after] = min(dp2[after], dp2[after-now] + 1);\n        }\n    }\n        while(true) {\n            int n;\n            cin >> n;\n            if(n == 0) break;\n            cout << dp1[n] << \" \" << dp2[n] << endl;\n        }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tvector<int> tet;\n\tvector<int> tet_odd;\n\tfor (int i = 1; i*(i+1)*(i+2)<6000000; ++i) {\n\t\ttet.push_back((i*(i+1)*(i+2))/6);\n\t\tif (i%4 == 1) tet_odd.push_back((i*(i+1)*(i+2))/6);\n\t}\n\treverse(tet_odd.begin(), tet_odd.end());\n\tset<int> tet_one, tet_two, tet_three;\n\tfor (int t : tet) {\n\t\ttet_one.insert(t);\n\t\tfor (int u : tet) {\n\t\t\ttet_two.insert(t+u);\n\t\t\tfor (int v : tet) {\n\t\t\t\ttet_three.insert(t+u+v);\n\t\t\t}\n\t\t}\n\t}\n\tint dp[1000001];\n\tfor (int i = 0; i < 1000001; ++i) dp[i] = i;\n\tfor (int i = 2; i < 1000001; ++i) {\n\t\tfor (int to : tet_odd) {\n\t\t\tif (i>=to) dp[i] = min(dp[i], dp[i-to]+1);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint x; cin >> x;\n\t\tint ans1 = 5;\n\t\tif (x == 0)\treturn 0;\n\t\tauto on = tet_one.find(x);\n\t\tauto tw = tet_two.find(x);\n\t\tauto th = tet_three.find(x);\n\t\tif (on != tet_one.end()) ans1 = 1;\n\t\telse if (tw != tet_two.end()) ans1 = 2;\n\t\telse if (th != tet_three.end()) ans1 = 3;\n\t\telse {\n\t\t\tfor (int i = 2; i*2 <= x; ++i)\n\t\t\t{\n\t\t\t\tauto fo = tet_two.find(i);\n\t\t\t\tauto ur = tet_two.find(x-i);\n\t\t\t\tif (fo != tet_two.end() && ur != tet_two.end()) {\n\t\t\t\t\tans1 = 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans1 << \" \" << dp[x] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define INF 10000000\n\nusing namespace std;\n\nlong long int data[1000100];\nlong long int data2[1000100];\n\nint min1,min2;\n\nvoid solveMin1(int cnt,int sum,int objSum,int nowNum){\n\n\tif( (cnt==min1-1 && sum!=objSum) || cnt>7)return;\n\n\telse if(sum==objSum){\n\t\tif(min1>=cnt){\n\t\t\tmin1=cnt;\n\t\t\treturn;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=nowNum;sum+data[i]<=objSum;i++){\n\t\t\tsolveMin1(cnt+1,sum+data[i],objSum,i);\n\t\t}\n\t}\n}\n\nvoid solveMin2(int cnt,int sum,int objSum,int nowNum){\n\n\tif(cnt>min2 || sum>objSum)return;\n\n\telse if(sum==objSum){\n\t\tif(min2>=cnt){\n\t\t\tmin2=cnt;\n\t\t\treturn;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=nowNum;i>=0;i--){\n\t\t\tsolveMin2(cnt+1,sum+data2[i],objSum,i);\n\t\t}\n\t}\n}\n\nint main(){\n\tint cnt=0;\n\n\tfor(long long int i=0;i<1000100;i++){\n\t\tdata[i]=i*(i+1)*(i+2)/6;\n\t\tif(data[i]%2==1){\n\t\t\tdata2[cnt]=data[i];\n\t\t\tcnt++;\n\t\t\t//cout<<data2[cnt-1]<<endl;\n\t\t}\n\t}\n\n\tint n;\n\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\n\n\t\tmin1 = INF;\n\t\tmin2 = INF;\n\n\t\tsolveMin1(0,0,n,1);\n\n\t\tint nowNum=0;\n\t\tfor(nowNum=0;data2[nowNum]<=n;nowNum++);\n\n\t\t\t//min2の予想をする。\n\t\t\tint objNum=n;\n\t\tmin2=0;\n\t\twhile(1){\n\t\t\twhile(data2[nowNum]>objNum){\n\t\t\t\tnowNum--;\n\t\t\t}\n\t\t\tobjNum-=data2[nowNum];\n\t\t\tmin2++;\n\t\t\tif(objNum==0)break;\n\t\t}\n\n\t\t//solveMin2(0,0,n,nowNum);\n\n\t\tcout<<min1<<\" \"<<min2<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++) if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<185;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <valarray>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <list>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <deque>\n#include <unordered_set>\n#include <unordered_map>\n#include <regex>\n#include <array>\n#include <bitset>\n#include <complex>\n#include <tuple>\n#include <random>\n\nusing namespace std;\nusing ll = long long;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nint main()\n{\n  int a[1000000], b[1000000];\n  a[0] = b[0] = 0;\n  for (int i = 1; i < 1000000; ++i)\n  {\n    a[i] = b[i] = i;\n    for (int j = 1;; ++j)\n    {\n      int t = j * (j + 1) * (j + 2) / 6;\n      if (t > i)\n        break;\n      a[i]=min(a[i],a[i-t]+1);\n      if(t%2==1)\n      {\n        b[i]=min(b[i],b[i-t]+1);\n      }\n    }\n  }\n  int n;\n  while (cin >> n, n)\n  {\n    cout<<a[n]<<' '<<b[n]<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int MAX = 250;\nint dp1[1000006];\nint dp2[1000006];\nvector<int> pollock;\nvector<int> pollock2;\n\nint main() {\n    rep(i,1000006) dp1[i] = dp2[i] = 10000000;\n    rep(i,MAX){\n        int t = i*(i+1)*(i+2)/6;\n        if(t>1000006) break;\n        pollock.push_back(t);\n        if(t&1) pollock2.push_back(t);\n\n    }\n    rep(i,pollock.size()) {\n        if(!i) continue;\n        dp1[pollock[i]] = 1;\n    }\n    rep(i,pollock2.size()) {\n        dp2[pollock2[i]] = 1;\n    }\n    rep(i,1000006) {\n        rep(j,pollock.size()) {\n            if(!j) continue;\n            if(i+pollock[j]>1000006) continue;\n            dp1[i+pollock[j]] = min(dp1[i+pollock[j]],dp1[i]+1);\n        }\n        rep(j,pollock2.size()) {\n            if(i+pollock2[j]>1000006) continue;\n            dp2[i+pollock2[j]] = min(dp2[i+pollock2[j]],dp2[i]+1);\n\n        }\n    }\n    int n;\n    while(cin>>n) {\n        if(n==0) break;\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n\n    }\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1167\n#include<iostream>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int number;\n\nconst number NMAX = 1e6 + 8;\n\nint dp[NMAX], odp[NMAX];\n\nint main() {\n  REP(i, NMAX) {\n    dp[i] = odp[i] = i;\n  }\n  for (number i = 2; i * (i + 1) * (i + 2) / 6 < NMAX; i++) {\n    int tetr = i * (i + 1) * (i + 2) / 6;\n    int limit = min(NMAX, (i + 1) * (i + 2) * (i + 3) / 6 + 8);\n    for (number j = tetr; j < limit; j++) {\n      dp[j] = min(dp[j], dp[j - tetr] + 1);\n    }\n\n    if (tetr % 2 != 0) {\n      int limit = min(NMAX, (i + 4) * (i + 5) * (i + 6) / 6 + 8);\n      for (number j = tetr; j < limit; j++) {\n        odp[j] = min(odp[j], odp[j -tetr] + 1);\n      }\n    }\n  }\n\n  int n;\n  while (cin >> n and n) {\n    cout << dp[n] << \" \" << odp[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nvoid print() { cout << \"\\n\"; }\ntemplate <class T> void print(const T &x) { cout << x << \"\\n\"; }\ntemplate <class T, class... Args> void print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\ntemplate <class T> void printVector(const vector<T> &v) {\n    for(const T &x : v) {\n        cout << x << \" \";\n    }\n    cout << \"\\n\";\n}\nusing ll = long long;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconstexpr int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n//-------------------------------------\n\n// 正四面体数\nvector<int> all, odd;\n\nconst int MAX = 1000000;\nvector<int> dp, dp2;\n\nbool solve() {\n    int n;\n    cin >> n;\n    if(n == 0) {\n        return 0;\n    }\n    print(dp[n], dp2[n]);\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for(int i = 1;; i++) {\n        int s = i * (i + 1) * (i + 2) / 6;\n        if(s >= 1000000) {\n            break;\n        }\n        all.emplace_back(s);\n        if(s & 1) {\n            odd.emplace_back(s);\n        }\n    }\n    int N = all.size();\n    dp.assign(MAX + 1, INF);\n    dp[0] = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = all[i]; j <= MAX; j++) {\n            chmin(dp[j], dp[j - all[i]] + 1);\n        }\n    }\n    N = odd.size();\n    dp2.assign(MAX + 1, INF);\n    dp2[0] = 0;\n    for(int i = 0; i < N; i++) {\n        for(int j = odd[i]; j <= MAX; j++) {\n            chmin(dp2[j], dp2[j - odd[i]] + 1);\n        }\n    }\n    while(1) {\n        if(!solve()) {\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint main()\n{\n    vector<vector<int> > tetra(2);\n    for(int i = 1; (i * (i + 1) * (i + 2)) / 6 < 1000001; i++){\n        tetra[0].push_back((i * (i + 1) * (i + 2)) / 6);\n        tetra[((i * (i + 1) * (i + 2)) / 6) % 2].push_back((i * (i + 1) * (i + 2)) / 6);\n    }\n    // for(int i = 0; i < 2; i++){\n    //     for(int j = 0; j < tetra[i].size(); j++){\n    //         cout << tetra[i][j] << endl;\n    //     }\n    //     cout << endl;\n    // }\n    int result[1000001][2];\n    for(int i = 0; i < 1000001; i++){\n        for(int j = 0; j < 2; j++){\n            result[i][j] = 1000001;\n        }\n    }\n    result[0][0] = 0;\n    result[0][1] = 0;\n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < tetra[i].size(); j++){\n            for(int k = 0; k + tetra[i][j] < 1000001; k++){\n                result[k + tetra[i][j]][i] = min(result[k + tetra[i][j]][i], result[k][i] + 1);\n            }\n        }\n    }\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0)break;\n        cout << result[n][0] << \" \" << result[n][1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << \"\\n\";\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REVFOR(i, m, n) for (int i = (n - 1); i >= (m); --i)\n#define REP(i, n) FOR(i, 0, n)\n#define REVREP(i, n) REVFOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\nll MOD = 1e9+7;\n\n\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    vector<ll> num_all, num_odd;\n    FOR(i, 1, 1000) {\n        ll N = i * (i + 1) * (i + 2) / 6;\n        if (N > 1e6) break;\n        num_all.pb(N);\n        if(N & 1) num_odd.pb(N);\n    }\n\n    const int nmax = (int)1e6 + 1;\n\n    vi dp_all(nmax, INF), dp_odd(nmax, INF);\n    dp_all[0] = 0;\n    dp_odd[0] = 0;\n\n    for(auto &e: num_all) {\n        REP(i, dp_all.size()) {\n            if (i + e >= nmax) break;\n            dp_all[i + e] = min(dp_all[i + e], dp_all[i] + 1);\n        }\n    }\n\n    for(auto &e: num_odd) {\n        REP(i, dp_odd.size()) {\n            if (i + e >= nmax) break;\n            dp_odd[i + e] = min(dp_odd[i + e], dp_odd[i] + 1);\n        }\n    }\n\n    while(1) {\n        int n; cin >> n;\n\n        if (n == 0) break;\n\n        cout << dp_all[n] << \" \" << dp_odd[n] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\n\nint main(){\n    vector<int> val,odd;\n    for(int i=1;i*(i+1)*(i+2)<=6000000;i++){\n        int x = (i*(i+1)*(i+2))/6;\n        val.pb(x);\n        if(x%2==1)odd.pb(x);\n    }\n    \n    int dp[1000001],dp_odd[1000001];\n    rep(i,1000001)dp[i] = INF,dp_odd[i]=INF;\n    dp[0] = 0,dp_odd[0] = 0;\n//    cout<<val.size()<<\" \"<<odd.size()<<endl;\n    for(int i=1;i<=1000000;i++){\n        for(int j=0;j<val.size();j++){\n            if(i-val[j]>=0) dp[i] = min(dp[i] , dp[i-val[j]]+1);\n        }\n        for(int j=0;j<odd.size();j++){\n            if(i-odd[j]>=0) dp_odd[i] = min(dp_odd[i] , dp_odd[i-odd[j]]+1);\n        }\n    }\n    \n    int n;\n    while(cin>>n&&n){\n        cout<<dp[n]<<\" \"<<dp_odd[n]<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define MYDEBUG\n#include <bits/stdc++.h>\n\n#ifdef MYDEBUG\n#define dbp(x) cout<<#x<<\": \"<<x<<endl\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl\n#define ifcin(x) std::ifstream cin(x)\n#else\n#define dbp(x)\n#define dbp2(x,y)\n#define dbp3(x,y,z)\n#define ifcin(x)\n#endif\n#define ll long long\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define rep(i, from, to) for(int i=from; i<to; ++i)\n#define REP(i, from, to) for(int i=from; i<=to; ++i)\n#define EPS = 1e-14;\nusing std::vector;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::max;\nusing std::min;\nusing std::swap;\nusing std::string;\nusing std::fill;\nusing std::pair;\nusing std::sort;\nusing std::reverse;\nusing std::pair;\nusing std::greater;\nusing std::priority_queue;\nusing std::ostream;\ntypedef std::complex<int> P;\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<vector<T> >& v) {\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i] << endl;\n\t}\n\treturn out;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tsize_t last = v.size() - 1;\n\tfor (size_t i = 0; i < v.size(); ++i) {\n\t\tout << v[i];\n\t\tif (i != last) {\n\t\t\tout << \",\";\n\t\t}\n\t}\n\tout << \"]\";\n\treturn out;\n}\n\nconst int MAX_QUAD = 182;\nconst int INF = 100000000;\nconst int MAX_N = 1000100;\nint quad[MAX_QUAD], qodd[MAX_QUAD];\nint dp[MAX_N], dp_odd[MAX_N];\nint n, ODD_SIZE;\n\nvoid init() {\n\tint m = 1;\n\tODD_SIZE = 0;\n\trep(k,1,MAX_QUAD)\n\t{\n\t\tquad[k] = k * (k + 1) * (k + 2) / 6;\n\t\tif (quad[k] % 2 != 0) {\n\t\t\tqodd[m] = quad[k];\n\t\t\tm++;\n\t\t\tODD_SIZE = max(ODD_SIZE, m);\n\t\t}\n\t}\n}\n\nvoid doDP() {\n\tfill(dp, dp + MAX_N, INF);\n\tdp[0] = 0;\n\trep(i,1,MAX_N)\n\t{\n\t\trep(k,1,MAX_QUAD)\n\t\t{\n\t\t\tif (i - quad[k] >= 0) {\n\t\t\t\tdp[i] = min(dp[i - quad[k]] + 1, dp[i]);\n\t\t\t}\n\t\t}\n\t}\n\t//odd\n\tfill(dp_odd, dp_odd + MAX_N, INF);\n\tdp_odd[0] = 0;\n\trep(i,1, MAX_N)\n\t{\n\t\trep(k,1,ODD_SIZE)\n\t\t{\n\t\t\tif (i - qodd[k] >= 0) {\n\t\t\t\tdp_odd[i] = min(dp_odd[i - qodd[k]] + 1, dp_odd[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tinit();\n\tdoDP();\n\twhile (cin >> n, n) {\n\t\tprintf(\"%d %d\\n\", dp[n], dp_odd[n]);\n\t}\n}\n\nint main() {\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst int SIZE = 300;\nconst int N = 1000002;\nint p[SIZE+1];\nint dp1[N], dp2[N];\n\nvoid make_pollock (void )\n{\n\tmemset (p, 0, sizeof (p ) );\n\n\tfor (int i = 0; i <= SIZE; i++ )\n\t\tp[i] = i*(i+1LL)*(i+2LL)/6LL;\n}\n\nvoid make_dp (void )\n{\n\tfill (dp1, dp1+N, INF );\n\tfill (dp2, dp2+N, INF );\n\n\tdp1[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp1[j] = min (dp1[j], dp1[j-m]+1 );\n\t} // end for\n\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tif (p[i] % 2 == 0 ) continue;\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp2[j] = min (dp2[j], dp2[j-m]+1 );\n\t} // end for\t\n}\n\t\nint main()\n{\n\tmake_pollock();\n\tmake_dp ();\n\n\tint n;\n\twhile (cin >> n && n )\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\nconstexpr int gcd(int a,int b){return b?gcd(b,a%b):a;}\nconstexpr int lcm(int a,int b){return a*b/gcd(a,b);}\n\nint main(){\n\tint n;\n\tvi dp(1000001,0);\n\tvi dp2(1000001,0);\n\tiota(all(dp),0);\n\tiota(all(dp2),0);\n\tfor(int i=2;(i*(i+1)*(i+2)/6)<=1000000;i++){\n\t    int seisimentai=(i*(i+1)*(i+2)/6);\n\t    for(int j=0;j+seisimentai<=1000000;j++){\n\t        dp[j+seisimentai]=min(dp[j+seisimentai], dp[j]+1);\n\t    }\n\t    if(seisimentai%2==0)continue;\n\t    for(int j=0;j+seisimentai<=1000000;j++){\n\t        dp2[j+seisimentai]=min(dp2[j+seisimentai], dp2[j]+1);\n\t    }\n\t}\n\t\n\t\n\twhile(cin>>n,n){\n        cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1 << 25\n\nint dp[1500000];\nint dp2[1500000];\n\nint main()\n{\n  int n;\n  int tetra[200];\n  for(int i = 0; i < 200; i++) tetra[i] = (i+1)*(i+2)*(i+3)/6;\n  while(cin >> n, n){\n    for(int i = 0; i < 1500000; i++) dp[i] = dp2[i] = INF;\n    dp[0] = dp2[0] = 0;\n    for(int i = 0; i < 200; i++){\n      dp[tetra[i]] = 1;\n      if(tetra[i]%2 == 1) dp2[tetra[i]] = 1;\n    }\n    for(int i = 2; i <= n; i++){\n      for(int j = 1; j < i; j++){\n\tdp[i] = min(dp[i], dp[i-j] + dp[j]);\n\tdp2[i] = min(dp2[i], dp2[i-j] + dp2[j]);\n      }\n    }\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int i,j,n,three[1000],four[1000],four_2[1000],c[1000],c_2[1000];\n\n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i*i < n; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i*i < n; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INF 1<<28\nusing namespace std;\n\nint p[1111111];\nint memo[1111111];\nint memo2[1111111];\n\nint solve(int n){\n  \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n\n  int ans = INF;\n  for(int i=199;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n\n  int ans = INF;\n  for(int i=199;i>0;i--) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n\n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n\n  for(int i=0;i<200;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define Repr(i, n, a) for (int i = (n); i >= (a); i--)\n#define rep(i, n) Rep(i, 0, n)\n#define repr(i, n) Repr(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n\n#define SIZE 1000010\n\nint dp1[SIZE], dp2[SIZE];\n\nint calc(int n) { return n * (n + 1) * (n + 2) / 6; }\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    vector<int> v;\n    for (int i = 0; calc(i) < 1000000; i++)\n        v.push_back(calc(i));\n    for (int i = 0; i < 1000010; i++)\n        dp1[i] = dp2[i] = INF;\n    dp1[0] = dp2[0] = 0;\n    for (int i = 0; i < SIZE; i++)\n    {\n        for (int j = 0; j < v.size(); j++)\n        {\n            if (i - v[j] >= 0)\n                dp1[i] = min(dp1[i], dp1[i - v[j]] + 1);\n            if (v[j] % 2 == 1 && i - v[j] >= 0)\n                dp2[i] = min(dp2[i], dp2[i - v[j]] + 1);\n        }\n    }\n    int N;\n    while (1)\n    {\n        cin >> N;\n        if (N == 0)\n            break;\n        cout << dp1[N] << \" \" << dp2[N] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[1000001];\nint memo[1000001];\nint memo2[1000001];\n \nint solve(int n){\n   \n  //cout << n << endl;\n\n  if(!n) return 0;\n  if(n < 0) return INF;\n  if(memo[n]) return memo[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n; i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++){\n    if(!(p[i]%2)) continue;\n    ans = min(ans, solve2(n-p[i])+1);\n  }\n   \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  for(int i=0;i<=1000000;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i++) solve(i), solve2(i);\n   \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvl llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\nint bfs(int target){\n    si q;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n            }\n        if(i<target){\n            q.insert(i);\n        }\n        if(i>target) break;\n    }\n    auto mm=*max_element(beginend(q));\n    int cnt=(target-mm)/mm;\n    target=(target)%mm+mm;\n    Foreach(i,q) if(i==target) return cnt+1;\n    cnt+=2;\n    while(1){\n        si next;\n        Foreach(x,q){\n            Foreach(k,llist){\n                if(k+x>target) break;\n                if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.insert(k+x);\n            }\n        }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    si q;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) q.insert(i);\n        if(i>target) break;\n    }\n    auto mm=*max_element(beginend(q));\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    Foreach(i,q)if(target==i) return cnt+1;\n    cnt+=2;\n    while (1)\n    {\n        si next;\n        Foreach(x,q){\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.insert(k+x);\n            }\n        }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n    }\n    auto mm=max_element(beginend(query));\n    map<int,pii> m;\n    makeList(*mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Pollock's conjecture\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp \n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int MAX = 1000010;\n\nint t(int n) { return n*(n+1)*(n+2) / 6; }\nint main() { \n    vector<int> dp(MAX, 0);\n    vector<int> odd_dp(MAX, 0);\n    dp[0] = 0;\n    odd_dp[0] = 0;\n    for (int n = 1; n <= MAX; ++n) {\n        dp[n] = n;\n        odd_dp[n] = n;\n        for (int k = 1; t(k) <= n; ++k) {\n            dp[n] = min(dp[n - t(k)] + 1, dp[n]); \n            if (t(k) % 2) {\n                odd_dp[n] = min(odd_dp[n - t(k)] + 1, odd_dp[n]); \n            }\n        }\n    }\n    \n    int N;\n    while (cin >>  N) {\n        if (N == 0) break;\n        cout << dp[N] << \" \" << odd_dp[N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint prime[200],dprime[100];\nint dp[1000000];\nint main(){\n\tint a=1,b=2,count=1,dcount=1;\n\tprime[0]=1,dprime[0]=1;\n\twhile(true){\n\t\ta+=b;\n\t\tb++;\n\t\tif(prime[count-1]+a>=1000000)\n\t\t\tbreak;\n\t\tif((prime[count-1]+a)%2==1){\n\t\t\tdprime[dcount]=prime[count-1]+a;\n\t\t\tdcount++;\n\t\t}\n\t\tprime[count]=prime[count-1]+a;\n\t\tcount++;\n\t}\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)\n\t\tbreak;\n\tfor(int i=0;i<=n;i++)\n\t\tdp[i]=i;\n\tfor(int i=1;i<count;i++)\n\t\tfor(int j=n;j>=0;j--)\n\t\t\tfor(int k=j;k>=0;k-=prime[i])\n\t\t\t\tdp[j]=min(dp[j],dp[k]+(j-k)/prime[i]);\n\tcout<<dp[n]<<\" \";\n\tfor(int i=0;i<=n;i++)\n\t\tdp[i]=i;\n\tfor(int i=1;i<dcount;i++)\n\t\tfor(int j=n;j>=0;j--)\n\t\t\tfor(int k=j;k>=0;k-=dprime[i])\n\t\t\t\tdp[j]=min(dp[j],dp[k]+(j-k)/dprime[i]);\n\tcout<<dp[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\nstruct multi {\n  ll first;\n  ll second;\n  ll third;\n};\nbool multicomp(const multi &a, const multi &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvl func(vl &kouho, ll c) {\n  vl DP(c + 1, llINF);\n  vl prev(c + 1, llINF);\n  DP[0] = 0;\n  while (true) {\n    prev = DP;\n    AUTO(a, kouho) {\n      REP(i, c - a + 1) {\n        if (prev[i] < llINF)\n          DP[i + a] = min(prev[i] + 1, prev[i + a]);\n      }\n    }\n    bool ok = true;\n    REP(i, c) if (DP[i] == llINF) ok = false;\n    if (ok)\n      break;\n  }\n  return DP;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  vl all;\n  vl odd;\n  ll score = 0;\n  ll i = 1;\n  vector<pll> ans;\n  while (score < 1e6 + 1) {\n    score = (i * (i + 1) * (i + 2)) / 6;\n    if (score % 2 == 1)\n      odd.push_back(score);\n    all.push_back(score);\n    i++;\n  }\n  sort(ALL(odd), REV(ll));\n  sort(ALL(all), REV(ll));\n\n  vl odd_ = func(odd, 1e6);\n  vl all_ = func(all, 1e6);\n\n  while (true) {\n    ll n;\n    cin >> n;\n    if (n == 0)\n      break;\n    cout << all_[n] << \" \" << odd_[n] << endl;\n  }\n\n  // AUTO(a, ans) { cout << a.first << \" \" << a.second << endl; }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    vector<int> s;\n    for(int i=1;;i++){\n        int p=i*(i+1)*(i+2)/6;\n        if(p>1000000)break;\n        else s.push_back(p);\n    }\n    int n=s.size();\n    vector<int> dp(1000000);\n    for(int i=0;i<n;i++){\n        vector<int> ndp(1000000);\n        for(int j=0;j<1000000;j++){\n            if(!i)ndp[j]=j;\n            else if(j<s[i])ndp[j]=dp[j];\n            else ndp[j]=min(dp[j],min(dp[j-s[i]]+1,ndp[j-s[i]]+1));\n        }\n        dp=ndp;\n    }\n    vector<int> DP(1000000);\n    for(int i=0;i<n;i++){\n        if(s[i]%2==0)continue;\n        vector<int> ndp(1000000);\n        for(int j=0;j<1000000;j++){\n            if(!i)ndp[j]=j;\n            else if(j<s[i])ndp[j]=DP[j];\n            else ndp[j]=min(DP[j],min(DP[j-s[i]]+1,ndp[j-s[i]]+1));\n        }\n        DP=ndp;\n    }\n    while(true){\n        int p;scanf(\"%d\",&p);\n        if(!p)break;\n        printf(\"%d %d\\n\",dp[p],DP[p]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e7+1;\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i,r,n) for(ll i = (ll)(r); i < (ll)(n); i++)\n#define RFOR(i,r,n) for(ll i=(ll)(n-1);i>=r;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\ntypedef long long int ll;\ntypedef vector<ll> vi;\ntypedef vector < pair<ll, ll > > vp;\ntypedef vector <string> vs;\ntypedef vector <char> vc;\ntypedef list <ll> lst;\n\nll n, k, ans = 0, sum = 0, cnt = 0;\nstring s;\nchar c;\n\n/*--------------------template--------------------*/\n\n\nll dp[1000005];\nll dpOdd[1000005];\n\nint main()\n{\n\tREP(i, 1000001)\n\t{\n\t\tdp[i] = dpOdd[i] = i;\n\t}\n\n\tfor (ll n = 2;; n++) {\n\t\tll bNumber = n * (n + 1) * (n + 2) / 6;\n\t\tif (bNumber > 1000001) break;\n\n\t\tfor (ll i = 0; i <= 1000001; i++) {\n\t\t\tif (i - bNumber < 0) continue;\n\t\t\tdp[i] = min(dp[i], dp[i - bNumber] + 1);\n\t\t\tif (bNumber % 2 == 1) dpOdd[i] = min(dpOdd[i], dpOdd[i - bNumber] + 1);\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tll Value;\n\t\tcin >> Value;\n\t\tif (!Value) break;\n\t\tcout << dp[Value] << \" \" << dpOdd[Value] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nstd::vector<int>t,o;\nconst int N=1000000,V=1<<9;\nint a[N],b[N];\nint main()\n{\n\tint i,j,n;\n\tfor(i=1;i<N;++i)a[i]=b[i]=V;\n\tfor(i=1;n=(i*(i+1)*(i+2))/6,n<N;++i)if(a[n]=1,t.push_back(n),n&1)b[n]=1,o.push_back(n);\n\tfor(i=t.size()-1;i>=0;--i)\n\t{\n\t\ta[t[i]]=1;\n\t\tfor(j=t[i];j+t[i]<N;++j)if(a[j]-V&&a[j]>9)break;else if(a[j]+1<a[j+t[i]])a[j+t[i]]=a[j]+1;\n\t}\n\tfor(i=o.size()-1;i>=0;--i)\n\t{\n\t\tb[o[i]]=1;\n\t\tfor(j=o[i];j+o[i]<N;++j)if(b[j]-V&&b[j]>37)break;else if(b[j]+1<b[j+o[i]])b[j+o[i]]=b[j]+1;\n\t}\n\twhile(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",a[n],b[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define NUM 1000*1000\n\nusing namespace std;\n\nint pnum[500], dp1[NUM], dp2[NUM];\n\nint main(){\n\tfor(int i=0; pnum[i-1]<NUM; i++){\n\t\tpnum[i] = (i*(i+1)*(i+2))/6;\n\t}\n\tfor(int i=1; i<NUM; i++){\n\t\tdp1[i]=dp2[i]=NUM+1;\n\t}\n\tfor(int i=0; i<NUM; i++){\n\t\tfor(int j=0; j<500; j++){\n\t\t\tif(i+pnum[j]>NUM) break;\n\t\t\tdp1[i+pnum[j]] = min(dp1[i+pnum[j]], dp1[i]+1);\n\t\t\tif(pnum[j]%2) dp2[i+pnum[j]] = min(dp2[i+pnum[j]], dp2[i]+1);\n\t\t}\n\t}\n\twhile(1){\n\t\tint n;  cin >>n;\n\t\tif(!n) break;\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nll memo[250000];\nll memo2[250000];\n\nll calc(int n) {\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint dfs(int depth, int n) {\n  int ans = 9999;\n  if (memo[n] != 0) return memo[n];\n  for (int i = n; i >= 1; i--) {\n    ll t = calc(i);\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      memo[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs(depth + 1, n - t));\n  }\n  memo[n] = ans;\n  return ans;\n}\n\nint dfs_odd(int depth, int n) {\n  int ans = 9999;\n  if (memo2[n] != 0) return memo2[n];\n  for (int i = n; i >= 1; i--) {\n    if (i % 2 == 0) continue;\n    ll t = calc(i);\n    if (t % 2 == 0) continue;\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      memo2[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs_odd(depth + 1, n - t));\n  }\n  memo2[n] = ans;\n  return ans;\n}\n  \nint main() {\n  int N;\n  while (cin >> N, N != 0) {\n    for (int i = 0; i < 110; i++) {\n      memo[i] = 0;\n      memo2[i] = 0;\n   }\n    cout << dfs(1, N) << \" \" << dfs_odd(1, N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef ENABLE_DEBUG_OUTPUT\n#define DEBUG_LOG(s) cout << s << endl;\n#else\n#define DEBUG_LOG(s) void();\n#endif\n\nint main(){\n    vector<int> a(200), b;\n    for (auto i = 0; i < 200; i++) {\n        a[i] = i * (i + 1) * (i + 2) / 6;\n        if(a[i] % 2) b.push_back(a[i]);\n    }\n\n    vector<int> dp(1e6, 0), dp_odd(1e6, 0);\n    for (auto i = 1; i < 1e6; i++) {\n        dp[i] = dp[i - 1] + 1; // 1つ目の正四面体数が1なので+1した値をまず入れる\n        for (int elm : a) {\n            // 求めたい値i以下の正四面体数毎に前の値+1して最小値を求める\n            if(elm <= i) dp[i] = min(dp[i], dp[i - elm] + 1);\n            else break;\n        }\n    }\n    for (auto i = 1; i < 1e6; i++) {\n        dp_odd[i] = dp_odd[i - 1] + 1;\n        for (int elm : b) {\n            if(elm <= i) dp_odd[i] = min(dp_odd[i], dp_odd[i - elm] + 1);\n            else break;\n        }\n    }\n\n    while(true) {\n        int n;\n        cin >> n;\n\n        if(n == 0) break;\n        cout << dp[n] << \" \" << dp_odd[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=1;\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  //tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  tmp=1;\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",1,2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    /*\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   */\n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\n#include <iomanip>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<long double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n#define INF 1LL<<60\n\nint main() {\n\n    vector<int> fourth_powers;\n    FOR(i, 1, 1000) {\n        int fourth_power = i * (i + 1) * (i + 2) / 6;\n        if(fourth_power >= 1e6) break;\n        fourth_powers.push_back(fourth_power);\n    }\n    vector<int> dp(1000005, 1e9), dp_odd(1000005, 1e9);\n    \n    dp[0] = 0;\n    dp_odd[0] = 0;\n    dp[1] = 1;\n    dp_odd[1] = 1;\n\n    FOR(i, 0, 1e6 + 2) {\n        for(int x: fourth_powers) {\n            if(i + x > 1e6) continue;\n            dp[i + x] = min(dp[i + x], dp[i] + 1);\n            if(x % 2 == 1)\n                dp_odd[i + x] = min(dp_odd[i+x], dp_odd[i] + 1);\n        }\n    }\n\n    // FOR(i, 1, 20) cerr << dp[i] << \" \" << dp_odd[i] << endl;\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(N == 0) break;\n        cout << dp[N] << \" \" << dp_odd[N] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;a[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++){\n    for(k=a[j];k<=1000000;k++){\n      b[k]=min(b[k],b[k-a[j]]+1);\n      if(a[j]%2){\n        c[k]=min(c[k],c[k-a[j]]+1);\n      }\n    }\n  }\nwhile(cin>>n,n){\ncout<<b[n]<<' '<<c[n]<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define foreach(c, it) for(typeof(c) it = (c).begin(); it != (c).end(); it++)\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int MAX = 1000000;\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nint p[4 * MAX + 1], op[4  *MAX + 1];\nvector < int > num;\nint main() {\n    \n    for(int i = 0; i < 2 + MAX + 1; i++)\n        p[i] = op[i] = INF;\n    \n    for(int i = 1; i < 200; i++) {\n        num.push_back(i * (i + 1) * (i + 2) / 6);\n        p[i * (i + 1) * (i + 2) / 6] = 1;\n        if((i * (i + 1) * (i + 2) / 6) % 2) op[i * (i + 1) * (i + 2) / 6] = 1;\n    }\n\n    for(int i = 1; i <= MAX; i++) {\n        for(int j = 0; j <num.size(); j++) {\n            if(p[i] != INF) {\n                p[i + num[j]] = min(p[i] + 1, p[i + num[j]]);\n            }\n            if(op[i]  != INF && num[j] % 2) {\n                op[i + num[j]] = min(op[i] + 1, op[i + num[j]]);\n            }\n        }\n    }\n    \n    int N;\n    while(cin >> N, N) {\n        cout << p[N] << \" \" << op[N] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint dp[2][1000001];\n\nint f(int n)\n{\n    return n * (n + 1) * (n + 2) / 6;\n}\n\nint main()\n{\n    int n;\n    for(int k = 0; k < 2; k++)\n        fill(dp[k], dp[k] + 1000001, 1000000);\n    \n    dp[0][0] = dp[1][0] = 0;\n    for(int i = 1; i <= 1000000; i++) {\n        for(int k = 1; ; k++) {\n            int num = f(k);\n            if(i - num >= 0) {\n                dp[0][i] = min(dp[0][i], dp[0][i - num] + 1);\n                if((num % 2) == 1) {\n                    dp[1][i] = min(dp[1][i], dp[1][i - num] + 1);\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    \n    while(cin >> n && n) {\n        cout << dp[0][n] << \" \" << dp[1][n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MAX 1000000\n\nint calc(int n) { return n*(n + 1)*(n + 2) / 6; }\nint p[200];\nint p1[200];\nint dp[MAX] = { 0 };\nint dp1[MAX] = { 0 };\n\nint func(int n, int P[], int DP[])\n{\n\tif (n <= 0)return MAX;\n\tif (DP[n] != 0)return DP[n];\n\telse\n\t{\n\t\tint min_t = MAX;\n\t\tint i = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (P[i] <= n && n <= P[i + 1])break;\n\t\t\tif (P[i] == 1004731)\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int t = i; t>0; t--)\n\t\t{\n\t\t\tif (min_t > func(n - P[t], P, DP) + 1)\n\t\t\t{\n\t\t\t\tmin_t = func(n - P[t], P, DP) + 1;\n\t\t\t}\n\t\t}\n\t\tDP[n] = min_t;\n\t\treturn DP[n];\n\t}\n}\n\nint main()\n{\n\tint index = 1;\n\tFOR(i, 1, 200)\n\t{\n\t\tint temp = calc(i);\n\t\tif (temp > 1004731)break;\n\t\tp[i] = temp;\n\t\tdp[p[i]] = 1;\n\t\tif (temp % 2 == 1)\n\t\t{\n\t\t\tp1[index] = temp;\n\t\t\tdp1[p1[index]] = 1;\n\t\t\tindex++;\n\t\t}\n\t}\n\twhile (1)\n\t{\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcout << func(N, p, dp) << \" \" << func(N, p1, dp1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint main(){\n    int n=1000001;\n    vector<int> dp(n,inf),dp2(n,inf);\n    dp[0]=dp2[0]=0;\n    vector<int> a;\n    rep(i,300){\n        int x=(i+1)*(i+2)*(i+3)/6;\n        if(x>n)break;\n        a.push_back(x);\n    }\n    rep(i,a.size()){\n        rep(j,n)if(j+a[i]<n)dp[j+a[i]]=min(dp[j+a[i]],dp[j]+1);\n        if(a[i]%2==0)continue;\n        rep(j,n)if(j+a[i]<n)dp2[j+a[i]]=min(dp2[j+a[i]],dp2[j]+1);\n    }\n    int x;\n    while(cin>>x,x!=0){\n        cout<<dp[x]<<\" \"<<dp2[x]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 99999999;\nconst int N = 1000000;\n\nint dp[N+1], odd_dp[N+1];\n\nint main(void) {\n  vector<int> pollock, odd_pollock;\n  for (int n = 1; n*(n+1)*(n+2)/6 <= N; n++) {\n    int t = n*(n+1)*(n+2)/6;\n    pollock.push_back(t);\n    if (t%2) odd_pollock.push_back(t);\n  }\n  for (int i = 0; i <= N; i++) {\n    dp[i] = INF;\n    odd_dp[i] = INF;\n  }\n  for (int i = 0; i < pollock.size(); i++) {\n    dp[pollock[i]] = 1;\n  }\n  for (int i = 0; i < odd_pollock.size(); i++) {\n    odd_dp[odd_pollock[i]] = 1;\n  }\n\n  for (int i = 0; i < 5; i++) {\n    for (int j = 1; j <= N; j++) {\n      if (dp[j] != INF) {\n        for (int k = 0; k < pollock.size(); k++) {\n          if (j+pollock[k] > N) break;\n          dp[j+pollock[k]] = min(dp[j]+1, dp[j+pollock[k]]);\n        }\n      }\n      if (odd_dp[j] != INF) {\n        for (int k = 0; k < odd_pollock.size(); k++) {\n          if (j+odd_pollock[k] > N) break;\n          odd_dp[j+odd_pollock[k]] = min(odd_dp[j]+1, odd_dp[j+odd_pollock[k]]);\n        }\n      }\n    }\n  }\n\n  int n;\n  while (cin >> n, n) {\n    cout << dp[n] << \" \" << odd_dp[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nint dp_all[1000001];\nint dp_odd[1000001];\n\nint main() {\n    vector<int> num_all, num_odd;\n    for (int i = 1; i * (i + 1) * (i + 2) / 6 <= 1e6; i++) {\n        num_all.push_back(i * (i + 1) * (i + 2) / 6);\n        if ((i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n            num_odd.push_back(i * (i + 1) * (i + 2) / 6);\n        }\n    }\n    for (int i = 0; i <= 1e6; i++) {\n        dp_all[i] = dp_odd[i] = inf;\n    }\n    dp_all[0] = 0;\n    for (int i = 0; i < (int)num_all.size(); i++) {\n        for (int j = 0; j + num_all[i] <= 1e6; j++) {\n            dp_all[j + num_all[i]] = min(dp_all[j + num_all[i]], dp_all[j] + 1);\n        }\n    }\n    dp_odd[0] = 0;\n    for (int i = 0; i < (int)num_odd.size(); i++) {\n        for (int j = 0; j + num_odd[i] <= 1e6; j++) {\n            dp_odd[j + num_odd[i]] = min(dp_odd[j + num_odd[i]], dp_odd[j] + 1);\n        }\n    }\n    vector<pair<int, int>> res;\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        res.emplace_back(dp_all[n], dp_odd[n]);\n    }\n    for (int i = 0; i < (int)res.size(); i++) {\n        cout << res[i].fi << \" \" << res[i].se << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[60]={0},c[200001]={0,1,2,3},d[200001],k=0,i,j,n;\n  for(i=1;i<100;i++){a[k++]=i*(i+1)*(i+2)/6;}\n  for(j=k=0;j<i;j++){if(a[j]%2)b[k++]=a[j];}\n  for(i=1;i<99;i++){for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;}\n  for(i=0;i<36;i++){d[i]=i;}\n  for(i=1;i<k-2;i++){for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;}\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <utility>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\n\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define itrep(i,x) for(auto i=(x).begin(); i!=(x).end();i++)\n#define Sort(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define vec vector\n#define INF (int)1e9\n#define INFL 1e18\n#define MOD 1000000007\n#define pb push_back\n#define MP make_pair\n#define PI 3.1415926535\ntypedef long long int ll;\ntypedef std::pair<int,int> P;\nint D=1;\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\nusing namespace std;\n\nint main(){\n    vector<int> v,oddv;\n    for(ll i=1;;i++){\n        if(i*(i+1)*(i+2)/6<=2000000){\n            v.pb(i*(i+1)*(i+2)/6);\n        }\n        else break;\n    }\n    int ans1[1000010],ans2[1000010];\n    rep(i,0,1000010) ans1[i]=ans2[i]=INF;\n    ans1[0]=0; ans2[0]=0;\n    rep(i,0,1000000){\n        ans1[i]=i; ans2[i]=i;\n        for(int j=0;i>=v[j];j++){\n            ans1[i]=min(ans1[i-v[j]]+1,ans1[i]);\n            if(v[j]%2==1)ans2[i]=min(ans2[i],ans2[i-v[j]]+1);\n        }\n    }\n\n    int n;\n    while(cin>>n&&n){\n        cout<<ans1[n]<<\" \"<<ans2[n]<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nint INF = 1e9;\nstd::vector<int> boroc(200);\nvoid init(int n){\n    for(int i = 0; i < n; i++) boroc[i] = i*(i + 1)*(i + 2) / 6;\n}\nint main(){\n    int n = 1000000;\n    init(200);\n    int dp[n + 1], dp2[n + 1];\n    for(int i = 0; i < n + 1; i++){\n        dp[i] = INF;\n        dp2[i] = INF;\n    }\n    dp[0] = 0;\n    dp2[0] = 0;\n    for(int i = 0; i < 200; i++){\n        if(boroc[i] > n) break;\n        dp[boroc[i]] = 1;\n        if(boroc[i] % 2 == 1) dp2[boroc[i]] = 1;\n    }\n    for(int i = 1; i < 200; i++){\n        int t = boroc[i];\n        for(int j = 1; j + t < n; j++){\n            dp[j + t] = std::min(dp[j] + 1, dp[j + t]);\n        }\n        if(t % 2 == 1){\n            for(int j = 1; j + t < n; j++) dp2[j + t] = std::min(dp2[j] + 1, dp2[j + t]);\n        }\n    }\n    while(1){\n        int N;\n        std::cin >> N;\n        if(N == 0) break;\n        std::cout << dp[N] << ' ' << dp2[N] << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n \nusing namespace std;\n \nconst int SIZE = 181 + 1;\nconst int MAX = 1000000;\n \nint T[SIZE];\nint cost1[MAX], cost2[MAX];\n \nint main( void )\n{  \n    for(int i=0; i < SIZE; ++i) T[i] = i * (i + 1) * (i + 2) / 6;\n \n    fill(cost1, cost1+MAX, MAX);\n    fill(cost2, cost2+MAX, MAX + MAX);\n    cost1[0] = cost2[0] = 0;\n    for(int i=0; i < MAX; ++i) {\n        //if(cost1[i] < 6) {\n            for(int j=0; j < SIZE; ++j) {\n                int tj = T[j];\n                if(i + tj < MAX && cost1[i] < 5)\n                    cost1[i + tj] = min(cost1[i + tj], cost1[i] + 1);\n                if((T[j] & 1) && (i + tj < MAX)) {\n                        cost2[i + tj] = min(cost2[i + tj], cost2[i] + 1);\n                }\n            }\n    }\n    int n;\n    while(cin >> n, n) {\n        cout << cost1[n] << ' ' << cost2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[200][1000010] = { 0 };\n\nint N = 0;\nint C[200];\nint Codd[50];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 200;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define INF 100000000\n\n\nint main(){\n\tint table1[201]={};\n\tvector<int> table2;\n\tfor(int i=1;i<201;i++){\n\t\ttable1[i-1]=i*(i+1)*(i+2)/6;\n\t\tif(table1[i-1]%2!=0){\n\t\t\ttable2.push_back(table1[i-1]);\n\t\t}\n\t}\n\tint count1[100001];\n\tint count2[100001];\n\tfor(int i=0;i<100001;i++){\n\t\tcount1[i]=INF;\n\t\tcount2[i]=INF;\n\t}\n\tcount1[0]=0;\n\tcount2[0]=0;\n\tcount1[1]=1;\n\tcount2[1]=1;\n\tfor(int i=2;i<100001;i++){\n\t\tfor(int j=0;j<201;j++){\n\t\t\tif(table1[j]>i)break;\n\t\t\tcount1[i] = min(count1[i],count1[i-table1[j]]+1);\n\t\t}\n\t}\n\tfor(int i=2;i<100001;i++){\n\t\tfor(int j=0;j<201;j++){\n\t\t\tif(table2[j]>i)break;\n\t\t\tcount2[i] = min(count2[i],count2[i-table2[j]]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tcout << count1[n] << \" \" << count2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nint p[1000001];\nint memo[1000001];\nint memo2[1000001];\n\nint solve(int n, int count){\n  \n  if(!n) return 0;\n  if(n <= 0 || !count) return INF;\n  if(memo[n]) return memo[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n; i++) ans = min(ans, solve(n-p[i], count-1)+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n;i++){\n    if(!(p[i]%2)) continue;\n    ans = min(ans, solve2(n-p[i])+1);\n  }\n  \n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  for(int i=0;i<=1000000;i++) p[i] = i*(i+1)*(i+2)/6;\n  //for(int i=1;i<=1000000;i++) solve(i, 5), solve2(i);\n  \n  while(cin >> n, n) cout << solve(n, 5) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dp[1000001] = {};\nint ki[1000001] = {};\n\nint main(void) {\n\tint poll[181] = {};\n\n\tFOR(i, 1, 180) {\n\t\tpoll[i] = i * (i + 1)*(i + 2);\n\t\tpoll[i] /= 6;\n\t\t//cout << poll[i] << endl;\n\t}\n\tFOR(i, 2, 1000000) {\n\t\tdp[i] = INF;\n\t\tki[i] = INF;\n\t}\n\tdp[1] = 1;\n\tki[1] = 1;\n\tFOR(i, 1, 1000000) {\n\t\tFOR(j, 1, 180) {\n\t\t\tif (i - poll[j] > 0) {\n\t\t\t\tdp[i] = min(dp[i], dp[i - poll[j]] + 1);\n\t\t\t}\n\t\t\telse if (i == poll[j]) {\n\t\t\t\tdp[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tFOR(i, 1, 1000000) {\n\t\tfor(int j=1;j<=180;j+=4) {\n\t\t\tif (i - poll[j] > 0) {\n\t\t\t\tki[i] = min(ki[i], ki[i - poll[j]] + 1);\n\t\t\t}\n\t\t\telse if (i == poll[j]) {\n\t\t\t\tki[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\t/*FOR(i, 1, 1000000) {\n\t\tcout << i << \" \" << ki[i] << endl;\n\t}*/\n\twhile (1) {\n\t\tint n;\n\t\tint first = 0;\n\t\tint second = 0;\n\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcout << dp[n] << \" \" << ki[n] << endl;\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint main(){\n    const int max_n = 1000002;\n    vector<int> nums;\n    for(int i=1;i<200;i++){\n        int n = i * (i + 1) * (i + 2) / 6;\n        if(max_n < n) break;\n        nums.push_back(n);\n    }\n\n    vector<int> all(max_n, max_n);\n    vector<int> odd(max_n, max_n);\n\n    all[0] = 0;\n    odd[0] = 0;\n    for(int i=0;i<max_n;i++){\n        for(int n : nums){\n            if(max_n <= i + n) break;\n            all[i+n] = min(all[i+n], all[i] + 1);\n        }\n        for(int n : nums){\n            if(max_n <= i + n) break;\n            if(n % 2 == 1) odd[i+n] = min(odd[i+n], odd[i] + 1);\n        }\n    }\n\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) break;\n        cout << all[N] << \" \" << odd[N] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_NUM = 1000000;\nconst int INF = 100000000;\n\nint table[2][MAX_NUM];\nint tet[2][1000];\n\nint calc(int num,int m)\n{\n    if(table[m][num]==INF) {\n        for(int i=1; tet[m][i]<num; i++) {\n            table[m][num]=min(table[m][num],calc(num-tet[m][i],m)+1);\n        }\n    }\n    return table[m][num];\n}\n\nint main()\n{\n    for(int i=0; i<MAX_NUM; i++) {\n        table[0][i] = INF;\n        table[1][i] = INF;\n    }\n\n    for(int i=1; i*(i+1)*(i+2)/6<MAX_NUM; i++) {\n        int t=i*(i+1)*(i+2)/6;\n        table[0][t] = 1;\n        tet[0][i] = t;\n\n        if(t%2 == 1) {\n            table[1][t] = 1;\n            tet[1][i] = t;\n        }\n    }\n\n    int in;\n    while(cin>>in && in) {\n        cout<<calc(in,0)<<\" \"<<calc(in,1)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#pragma region Debug\ntemplate <typename T>\nvoid view(const std::vector<T> &v)\n{\n    for (const auto &e : v)\n    {\n        std::cout << e << \" \";\n    }\n    std::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv)\n{\n    for (const auto &v : vv)\n    {\n        view(v);\n    }\n}\n#pragma endregion\n#pragma region chminmax\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n    if (a > b)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n    if (a < b)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n#pragma endregion\n\nint main()\n{\n    vector<int> in;\n    int n = 0;\n    while (true)\n    {\n        int k;\n        cin >> k;\n        chmax(n, k);\n        if (!k)\n            break;\n        in.emplace_back(k);\n    }\n\n    vector<int> dp(n + 5, 1e6);\n    vector<int> dp2(n + 5, 1e6);\n    dp[0] = 1;\n    dp2[0] = 1;\n\n    int h = 1;\n    int i = 1;\n    while (h <= n)\n    {\n        rep(j, n + 1)\n        {\n            chmin(dp[h], 1);\n\n            if (j - h >= 0)\n            {\n                chmin(dp[j], dp[j - h] + 1);\n            }\n\n            if (h % 2 == 0)\n            {\n                continue;\n            }\n\n            chmin(dp2[h], 1);\n\n            if (j - h >= 0)\n            {\n                chmin(dp2[j], dp2[j - h] + 1);\n            }\n        }\n\n        i++;\n        h = i * (i + 1) * (i + 2) / 6;\n    }\n\n    for (int k : in)\n    {\n        cout << dp[k] << \" \" << dp2[k] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<utility>\n#include<queue>\n#define pi 3.14159\n#define Inf (int)pow(2., 12.)\n\nusing namespace std;\ntypedef std::pair<int, int> mypair;\nqueue<mypair> qu;\n#define M 1000000\n \nint odd[M+1], all[M+1];\n \nvoid update(int *ar, int x){\n    for(int i = x; i <= M; ++i){\n        ar[i] = min(ar[i], ar[i - x] + 1);\n    }\n}\n \nint main(){\n\todd[0] = all[0] = 0;\n    for(int i = 1; i <= M; ++i){\n        odd[i] = all[i] = 10000000;\n    }\n \n    for(int i = 1; ; ++i){\n        int x = i * (i + 1) * (i + 2) / 6;\n        if(x > M) break;\n        update(all, x);\n        if(x % 2 == 1) update(odd, x); \n    }\n     \n    int n;\n    while(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << all[n] << \" \" << odd[n] <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge {\n    int from,to;\n    int cost;\n\n    edge(int t,int c) : to(t),cost(c) {}\n    edge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n    bool operator<(const edge &e) const {\n        return cost < e.cost;\n    }\n};\n\nvector<edge> G[1000005];\nvector<edge> G2[1000005];\nint d[1000005];\nint d2[1000005];\n\nvoid dijkstra(int s,int n) {\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(d,d+n,INF);\n\n    d[s] = 0;\n    que.push(P(0,s));\n\n    while(que.size()) {\n        P p = que.top();\n        que.pop();\n\n        int v = p.second;\n        if(d[v] < p.first) continue;\n\n        rep(i,G[v].size()) {\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to],e.to));\n            }\n        }\n    }\n\n    priority_queue<P,vector<P>,greater<P> > que2;\n    fill(d2,d2+n,INF);\n\n    d2[s] = 0;\n    que2.push(P(0,s));\n\n    while(que2.size()) {\n        P p = que2.top();\n        que2.pop();\n\n        int v = p.second;\n        if(d2[v] < p.first) continue;\n\n        rep(i,G2[v].size()) {\n            edge e = G2[v][i];\n            if(d2[e.to] > d2[v] + e.cost) {\n                d2[e.to] = d2[v] + e.cost;\n                que2.push(P(d2[e.to],e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n    vector<int> v;\n    REP(i,1,200) {\n        int t = i * (i+1) * (i+2);\n        t /= 6;\n        v.push_back(t);\n    }\n\n    rep(i,100005) {\n        rep(j,v.size()) {\n            if(i + v[j] > 1000000) continue;\n\n            if(v[j]%2 == 0) {\n                G[i].push_back(edge(i+v[j],1));\n            }\n            else {\n                G[i].push_back(edge(i+v[j],1));\n                G2[i].push_back(edge(i+v[j],1));\n            }\n        }\n    }\n\n\n    dijkstra(0,1000005);\n\n    int n;\n    while(cin >> n && n) {\n        cout << d[n] << \" \" << d2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dpt1[1000001];\nint dpt2[1000001];\nbool dpb1[1000001];\nbool dpb2[1000001];\nint tr[1000];\nint sq[1000];\n\nint dp1(int s) {\n  if(dpb1[s])\n    return dpt1[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    r = dp1(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt1[s] = m + 1;\n  dpb1[s] = true;\n  return m + 1;\n}\n\nint dp2(int s) {\n  if(dpb2[s])\n    return dpt2[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    if(sq[i]%2 == 0)\n      continue;\n    r = dp2(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt2[s] = m + 1;\n  dpb2[s] = true;\n  return m + 1;\n}\n\nint main() {\n\n  for(int i=1; i < 1000; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  dpt1[0] = 0;\n  dpb1[0] = true;\n  dpt2[0] = 0;\n  dpb2[0] = true;\n  int n;\n  for(int i=1;i<=1000000;i++)\n    dp1(i),dp2(i);\n  while(cin >> n, n) {\n    cout << dp1(n) << \" \" << dp2(n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Problem     : AOJ1167\n * Title       : Pollock's conjecture (ポロック予想)\n * Author      : mizo0203\n * Language    : C++\n * Copyright   : Your copyright free\n * Description : 動的計画法\n */\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\nint dp1[1000000];\nint dp2[1000000];\n\nvoid init() {\n  int i, j;\n  int tmp, cnt;\n\n  tmp = 1;\n  cnt = 1;\n  while (tmp < 1000000) {\n    //printf(\"%d\\n\", tmp);\n    dp1[tmp] = 1;\n    if (tmp % 2 == 1)\n      dp2[tmp] = 1;\n    cnt++;\n    for (i = 1; i <= cnt; i++) {\n      tmp += i;\n    }\n  }\n  /*\n   for (i = 500000; i > 0; i--) {\n   if (!dp[i])\n   continue;\n   for (j = 1; i * j < 1000000; j++) {\n   if (!dp[i * j] || dp[i * j] > dp[i] * j) {\n   dp[i * j] = dp[i] * j;\n   }\n   }\n   }\n   */\n\n  for (i = 1; i < 1000000; i++) {\n    if (dp1[i] == 1) {\n      for (j = i; i + j < 1000000; j++) {\n        if (!dp1[i + j] || dp1[i + j] > dp1[i] + dp1[j])\n          dp1[i + j] = dp1[i] + dp1[j];\n      }\n      if (dp2[i] == 1)\n        for (j = i; i + j < 1000000; j++) {\n          if (!dp2[i + j] || dp2[i + j] > dp2[i] + dp2[j])\n            dp2[i + j] = dp2[i] + dp2[j];\n        }\n    }\n  }\n/*\n  for (i = 1; i < 1000000; i++) {\n    printf(\"%d\\n\", dp1[i]);\n  }\n  */\n  //printf(\"%d\\n\", cnt);\n\n}\n\nbool input() {\n  //int i;\n\n  scanf(\"%d\", &n);\n  if (!n)\n    return false;\n\n  return true;\n}\n\nint main() {\n\n  init();\n  while (input()) {\n    printf(\"%d %d\\n\", dp1[n], dp2[n]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint dp[1000001], dp_odd[1000001];\n\nsigned main()\n{\n    vi tet, tet_odd;\n\n    for (int i = 1; ; ++i) {\n        tet.PB(i * (i + 1) * (i + 2) / 6);\n        if (tet.back() >= 1000000) break;\n    }\n\n    for (int i = 0; i < tet.size(); ++i) {\n        if (tet[i] & 1) tet_odd.PB(tet[i]);\n    }\n\n    cout << tet.size() + tet_odd.size() << endl;\n\n    for (int i = 1; i <= 1000000; ++i) dp[i] = dp_odd[i] = inf;\n\n    for (int i = 1; i <= 1000000; ++i) {\n        for (int j = 0; j < tet.size(); ++j) {\n            if (i >= tet[j]) {\n                dp[i] = min(dp[i], dp[i - tet[j]] + 1);\n            }\n            if (i < tet[j]) break;\n        }\n\n        for (int j = 0; j < tet_odd.size(); ++j) {\n            if (i >= tet_odd[j]) {\n                dp_odd[i] = min(dp_odd[i], dp_odd[i - tet_odd[j]] + 1);\n            }\n            if (i < tet_odd[j]) break;\n        }\n    }\n\n    int N;\n    while (cin >> N, N) cout << dp[N] << ' ' << dp_odd[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\nint n;\nint dp[5000001];\nint dp2[5000001];\n\nint func(int v){\n\tif(dp[v]!=INF)return dp[v];\n\tif(v==0)return 0;\n\tint cnt=INF;\n\tint j=1;\n\twhile(j*(j+1)*(j+2)/6<=v)j++;\n\tj--;\n\tfor(int i=j;i>=1;i--){\n\t\tcnt=min(cnt,func(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp[v]=cnt+1);\n}\n\nint func2(int v){\n\tif(dp2[v]!=INF)return dp2[v];\n\tif(v==0)return 0;\n\tint cnt=INF;\n\tint j=1,i;\n\twhile(j*(j+1)*(j+2)/6<=v)j++;\n\tj--;\n\tfor(i=j;i>=1;i--){\n\t\tif((i*(i+1)*(i+2)/6)%2!=1)continue;\n\t\tcnt=min(cnt,func2(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp2[v]=cnt+1);\n}\n\nint main(void){\n\tfor(int i=1;i<=2000000;i++)dp[i]=dp2[i]=INF;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",func(n),func2(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll INF = 1ll<<60;\nconstexpr ll MAX = 1000001;\nll dpA[MAX], dpB[MAX];\n\nint main(int argc, char **argv)\n{\n\tvector<ll> A, B;\n\n\tfor (ll i = 1; i*(i+1)*(i+2)<=6000000; ++i)\n\t{\n\t\tA.push_back(i*(i+1)*(i+2)/6);\n\t\tif (A.back() & 1) B.push_back(A.back());\n\t}\n\n\t// DEBUG\n\t// for (ll i = 0; i < 10; ++i)\n\t// \tstd::cout << A[i] << \" \";\n\t// std::cout << std::endl;\n\t// for (ll i = 0; i < 10; ++i)\n\t// \tstd::cout << B[i] << \" \";\n\t// std::cout << std::endl;\t\n\n\tfill(dpA, dpA+MAX, INF);\n\tdpA[0] = 0;\n\tfor (ll i = 0; i < MAX; ++i)\n\t{\n\t\tfor (ll j = 0; j < (ll)A.size(); ++j)\n\t\t{\n\t\t\tif (i+A[j]<MAX) dpA[i+A[j]] = min(dpA[i+A[j]], dpA[i]+1);\n\t\t\telse break;\n\t\t}\n\t}\n\n\n\tfill(dpB, dpB+MAX, INF);\n\tdpB[0] = 0;\n\tfor (ll i = 0; i < MAX; ++i)\n\t{\n\t\tfor (ll j = 0; j < (ll)B.size(); ++j)\n\t\t{\n\t\t\tif (i+B[j]<MAX) dpB[i+B[j]] = min(dpB[i+B[j]], dpB[i]+1);\n\t\t\telse break;\n\t\t}\n\t}\n\n\tll n;\n\twhile (cin >> n, n)\n\t{\n\t\tstd::cout << dpA[n] << \" \" << dpB[n] << std::endl;\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[200];\nint dp1[1000001];\nint dp2[1000001];\nint main(){\n\tint a;\n\tfor(int i=0;i<200;i++){\n\t\tb[i]=i*(i+1)*(i+2)/6;\n\t}\n\tfor(int i=0;i<1000001;i++)dp1[i]=dp2[i]=99999999;\n\tdp1[0]=dp2[0]=0;\n\tfor(int i=0;i<1000001;i++){\n\t\tfor(int j=1;j<200;j++){\n\t\t\tif(i+b[j]<=1000000)dp1[i+b[j]]=min(dp1[i+b[j]],dp1[i]+1);\n\t\t\tif(b[j]%2&&i+b[j]<=1000000)dp2[i+b[j]]=min(dp2[i+b[j]],dp2[i]+1);\n\t\t}\n\t}\n\twhile(scanf(\"%d\",&a),a){\n\t\tprintf(\"%d %d\\n\",dp1[a],dp2[a]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint dp[2][1000001];\n\nint f(int n)\n{\n    return n * (n + 1) * (n + 2) / 6;\n}\n\nint main()\n{\n    int n;\n    for(int k = 0; k < 2; k++)\n        fill(dp[k], dp[k] + 1000001, 1000000);\n    \n    dp[0][0] = dp[1][0] = 0;\n    for(int i = 1; i <= n; i++) {\n        for(int k = 1; ; k++) {\n            int num = f(k);\n            if(i - num >= 0) {\n                dp[0][i] = min(dp[0][i], dp[0][i - num] + 1);\n                if((num % 2) == 1) {\n                    dp[1][i] = min(dp[1][i], dp[1][i - num] + 1);\n                }\n            } else {\n                break;\n            }\n        }\n    }\n    \n    while(cin >> n && n) {\n        cout << dp[0][n] << \" \" << dp[1][n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nvector<int> table;\nvector<int> otable;\n\nstatic const int MAX = 1000000;\nint memo[MAX];\nint omemo[MAX];\n\nint tri(int N) {\n  //printf(\"N = %d\\n\", N);\n  if (N == 0) {\n    return 0;\n  }\n  int mn = MAX;\n  if (memo[N] < 0) {\n    for (int i = 0; N - table[i] >= 0; i++) {\n      mn = min(mn, tri(N - table[i]) + 1);\n    }\n    memo[N] = mn;\n  }\n  return memo[N];\n}\n\nint otri(int N) {\n  //printf(\"N = %d\\n\", N);\n  if (N == 0) {\n    return 0;\n  }\n  int mn = MAX;\n  if (omemo[N] < 0) {\n    for (int i = 0; N - otable[i] >= 0; i++) {\n      mn = min(mn, otri(N - otable[i]) + 1);\n    }\n    omemo[N] = mn;\n    return mn;\n  }\n  return omemo[N];\n}\n\nint main()\n{\n  int N;\n  for (int i = 1; i * (i + 1) * (i + 2) / 6 <= MAX; i++) {\n    table.push_back(i * (i + 1) * (i + 2) / 6);\n    if ((i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n      otable.push_back(i * (i + 1) * (i + 2) / 6);\n    }\n  }\n\n  fill(memo, &memo[MAX], -1);\n  fill(omemo, &omemo[MAX], -1);\n  \n  while (scanf(\"%d \", &N) == 1) {\n    if (N == 0) {\n      break;\n    }\n    //printf(\"%d\\n\", N);\n    //printf(\"\\ntri:\\n\");\n    printf(\"%d \", tri(N));\n    //printf(\"\\notri:\\n\");\n    printf(\"%d\\n\", otri(N));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 181\n#define MAX_N 1100000\n#define INF 1e9\nint arr[MAX];\nint dp1[MAX_N], dp2[MAX_N];\n\nvoid make(){\n  vector<int> odd;\n  for(int i = 1 ; i < MAX ; i++){\n    arr[i] = i*(i+1)*(i+2)/6;\n    if(arr[i] % 2) odd.push_back(arr[i]);\n  }\n\n  for(int i = 0 ; i < MAX_N ; i++){\n    dp1[i] = dp2[i] = INF;\n  }\n  dp1[0] = dp2[0] = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX_N ; j++){\n      if(j + arr[i] >= MAX_N) continue;\n      dp1[j+arr[i]] = min(dp1[j+arr[i]], dp1[j]+1);\n    }\n  }\n\n  for(int i = 0 ; i < odd.size() ; i++){\n    for(int j = 0 ; j < MAX_N ; j++){\n      if(j + odd[i] >= MAX_N) continue;\n      dp2[j+odd[i]] = min(dp2[j+odd[i]], dp2[j]+1);\n    }\n  }\n}\n\nint main(){\n  int n;\n\n  make();\n  while(cin >> n ,n){\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S acm(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nvi od,all;\n\nvoid solve(int n){\n\tvi dp(n+1,INF);\n\tll odans=0;\n\tdp[0]=0;\n\trrep(i,od.size()){\n\t\trep(j,n){\n\t\t\tif(dp[j]==INF)continue;\n\t\t\tif(j+od[i]>n)j=n;\n\t\t\telse chmin(dp[j+od[i]],dp[j]+1);\n\t\t}\n\t}\n\todans=dp[n];\n\trrep(i,all.size()){\n\t\trep(j,n){\n\t\t\tif(dp[j]==INF)continue;\n\t\t\tif(j+all[i]>n)j=n;\n\t\t\telse chmin(dp[j+all[i]],dp[j]+1);\n\t\t}\n\t}\n\tputa(dp[n],odans);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tfor(int i=1;(i)*(i+1)*(i+2)/6<=1E6;i++){\n\t\tif((i)*(i+1)*(i+2)/6%2==1)od.push_back((i)*(i+1)*(i+2)/6);\n\t\telse all.push_back((i)*(i+1)*(i+2)/6);\n\t}\n\twhile(cin>>n,n)solve(n);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \";\n        a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    const int MAX_N = 1000000;\n    vi dp(MAX_N, INF), odd(MAX_N, INF);\n    dp[0] = odd[0] = 0;\n    for (int i = 1; i*(i+1)*(i+2)/6 < MAX_N; ++i) {\n        int d = i*(i+1)*(i+2)/6;\n        for (int j = 0; j + d < MAX_N; ++j) {\n            if (dp[j] != INF) chmin(dp[j+d], dp[j] + 1);\n            if (odd[j] != INF and d & 1) chmin(odd[j+d], odd[j] + 1);\n        }\n    }\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        cout << dp[n] << ' ' << odd[n] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lpin(a,i,n) for(int i=0;i<n;i++){cin>>a[i];}\n\nvoid calc(int a[],int f){\n  for(int i=f*(f+1)*(f+2)/6;i<=1000000;i++){\n    if(a[i]==0) a[i]=a[i-f*(f+1)*(f+2)/6]+1;\n    else if(a[i]>a[i-f*(f+1)*(f+2)/6]+1) a[i]=a[i-f*(f+1)*(f+2)/6]+1;\n  }\n}\n\nint x[1000001],b[1000001];\nint main(){\n  for(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    calc(x,i);\n  }\n  for(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    if(i*(i+1)*(i+2)/6%2==1)\n    calc(b,i);\n  }\n  while(1){\n    int z;\n    cin>>z;\n    if(z==0) break;\n    cout<<x[z]<<\" \"<<b[z]-3<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint n,a[1000010],b[1000010],l[200];\nint main(){\n    for(int i=1;i<200;i++)\n        l[i-1]=(i*(i+1)*(i+2))/6;\n    for(int i=1;i<=1000000;i++){\n        a[i]=i;\n        b[i]=i;\n        for(int t=0;l[t]<=i;t++){\n            a[i]=min(a[i],a[i-l[t]]+1);\n            if(l[t]%2)\n                b[i]=min(b[i],b[i-l[t]]+1);\n        }\n    }\n    while(scanf(\"%d\",&n),n){\n\t    printf(\"%d %d\\n\",a[n],b[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[1000010] = { 0 };\nint dpodd[1000010] = { 0 };\n\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\n\n\t\n\n\t\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[i] = dp[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i] = min(dp[i], dp[i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tCO dp[N] << \" \";\n\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdpodd[i] = 1001000;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdpodd[i] = dpodd[i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdpodd[i] = min(dpodd[i], dpodd[i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dpodd[N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int c1[100000],c2[100000],i,m,p=0,dp1[100001],dp2[100001],k;\n  for(i=0;i*(i+1)*(i+2)/6<=100000;i++){\n    c1[i]=i*(i+1)*(i+2)/6;\n    if(c1[i]%2==1){\n      c2[p]=c1[i]; \n      p++; \n    }\n  }\n  while(1){\n  cin >>m;\n  if(m==0)break;\n  for(int j=0;j<=m;j++){\n    dp1[j]=j;\n    dp2[j]=j;\n    for(int k=0;k<i;k++){\n      if(j-c1[k]>=0)dp1[j]=min(dp1[j],dp1[j-c1[k]]+1);\n      if(k<p)\n\tif(j-c2[k]>=0){\n\tdp2[j]=min(dp2[j],dp2[j-c2[k]]+1);\n       }\n    }\n  }\n  cout << dp1[m]<<\" \"<<dp2[m]<<endl;\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* C ????§????: ?????? */\n#include<bits/stdc++.h>\n#define dump(a) cout << (#a) << (a) << endl\nusing namespace std;\n\n#define MAX_SIZE 2000002\n\n//pollok\nint memo_cnt[MAX_SIZE]; //MAX_SIZE??????\nvector<int> all_pks;\nvector<int> kisu_pks;\n\n//P=pk??????, index=pks????????¨?????´???\nint dfs(const int P, vector<int> &pks)\n{\n\t//dump(level);\n\tif (P == 0) { return 0; }\n\tif (memo_cnt[P] != -1) { return memo_cnt[P]; } //?????¢????????\\\n\t\n\tint min_depth = INT_MAX;\n\t//100??????\n\tfor(int i=0; i<pks.size(); i++) { //??§?????????\n\t\tint next_P = P-pks[i];\n\t\tif (next_P >= 0) {\n\t\t\tint depth = dfs(next_P, pks) + 1; //????????°???????????????\n\t\t\tmin_depth = min(min_depth,depth); //????°????????????°\n\t\t}\n\t\t//?????????????????´???????¬?\n\t}\n\t//???????????¢???\n\tmemo_cnt[P] = min_depth;\n\t\n\treturn min_depth;\n}\n\nint main() {\n\tint n=1;\n\twhile(true) {\n\t\tint pk = n * (n+1) * (n+2) / 6;\n\t\tif (pk >= MAX_SIZE){ break; }\n\n\t\tall_pks.push_back(pk);\n\t\tif (pk % 2 != 0) { kisu_pks.push_back(pk); }\n\t\tn++;\n\t}\n\treverse(begin(all_pks),end(all_pks));\n\treverse(begin(kisu_pks),end(kisu_pks));\n\n\tint P;\n\twhile(cin >> P) {\n\t\tif (P == 0) { break; }\n\n\t\tint index=0; //\n\t\tint left=0,right=0;\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tleft = dfs(P, all_pks);\n\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tright = dfs(P, kisu_pks);\n\t\tcout << left << \" \" << right << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint num[100010];\n\tfor(int i=0; i< 100010; i++) num[i] = 10e8;\n\tnum[0] = 0;\n\tfor(int j=0; j< 100010; j++){\n\t\tfor(int i=1; i < 1000; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(10010 <= i*(i+1)*(i+2)/6+j) continue;\n\t\t\tnum[j+m] = min(num[j]+1, num[j+m]);\n\t\t}\n\t}\n\tint num2[100010];\n\tfor(int i=0; i< 100010; i++) num2[i] = 10e8;\n\tnum2[0] = 0;\n\tfor(int j=0; j< 100010; j++){\n\t\tfor(int i=1; i < 1010; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(m%2 == 0) continue;\n\t\t\tif(10010 <= i*(i+1)*(i+2)/6+j) continue;\n\t\t\tnum2[j+m] = min(num2[j]+1, num2[j+m]);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << num[n] << \" \" << num2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n              \nstatic constexpr int kMax = 1000000;\n              \nint main() {  \n  std::vector<int> tet, otet;\n  int i = 1;  \n  while (true) {\n    int t = i * (i+1) * (i+2) / 6;\n    if (t >= kMax) {\n      break;  \n    }         \n    tet.push_back(t);\n    if (t % 2 == 1) {\n      otet.push_back(t);\n    }         \n    i += 1;   \n  }           \n  std::vector<int> dp(kMax, kMax);\n  std::vector<int> odp(kMax, kMax);\n  dp[0] = 0;  \n  odp[0] = 0; \n              \n  for (const int t : tet) {\n    for (int i = t; i < kMax; i++) {\n      dp[i] = std::min(dp[i], dp[i-t]+1);\n    }         \n  }           \n  for (const int t : otet) {\n    for (int i = t; i < kMax; i++) {\n      odp[i] = std::min(odp[i], odp[i-t]+1);\n    }         \n  }           \n              \n  while (true) {\n    int n;    \n    std::cin >> n;\n    if (n == 0) {\n      break;  \n    }         \n    std::cout << dp[n] << \" \" << odp[n] << std::endl;\n  }           \n}             \n  \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define INF (1<<25)\nint N;\nint pr[102];\nint dp[100002];\nvoid init(){\n  for(int i=0;i<=N;i++) dp[i]=INF;\n}\nint solve(int g){\n  dp[0]=0;\n  for(int i=0;i<=N;i++){\n    if(dp[i]==INF) continue;\n    for(int j=0;j<102;j++){\n      if(g==2 && pr[j]%g==0) continue;\n      if(i+pr[j]>N) continue;\n      dp[i+pr[j]] = min(dp[i+pr[j]],dp[i]+1);\n    }\n  }\n\n  //  for(int i=0;i<=N;i++) printf(\"id=%d => %d\\n\",i,dp[i]);\n  return dp[N];\n}\n\nint main(){\n  for(int i=0;i<102;i++) pr[i] = (i+1)*(i+2)*(i+3)/6;\n  //  for(int i=0;i<102;i++) printf(\"%d\\n\",pr[i]);\n  //  for(int i=0;i<102;i++) if(!(i%2)) printf(\"%d\\n\",pr[i]);\n  while(1){\n    scanf(\"%d\",&N);\n    if(!N) break;\n    init();\n    int res1 = solve(1);\n    init();\n    int res2 = solve(2);\n    printf(\"%d %d\\n\",res1,res2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=1;\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) { ll d = euclid(b, a % b, y, x);\n        return y -= a/b * x, d; }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1) ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1); return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e) return Mod(1);\n        Mod r = *this ^ (e / 2); r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nll tri(ll i) {return i*(i+1)*(i+2)/6;}\nint dp[1000005], dp2[1000005];\n\nint main() {\n    rep(i, 0, 1000005) dp[i] = dp2[i] = i;\n    for (int i = 1; tri(i) < 1000005; i++) {\n        if (tri(i) % 2 == 1) {\n            for (int j = 0; j + tri(i) < 1000005; j++)\n                dp2[j + tri(i)] = min(dp2[j + tri(i)], dp2[j] + 1);\n        }\n        for (int j = 0; j + tri(i) < 1000005; j++)\n            dp[j + tri(i)] = min(dp[j + tri(i)], dp[j] + 1);\n    }\n    for (;;) {\n        int n; cin >> n; if (!n) break;\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t\tif (dp[i][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=1000000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t\tif (dp[i%2][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nint dp[10000001];\nint dp2[10000001];\n\nint func(int v){\n\tif(dp[v]!=11451419)return dp[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n\t\tif(v-i*(i+1)*(i+2)/6>=0)cnt=min(cnt,func(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp[v]=cnt+1);\n}\n\nint func2(int v){\n\tif(dp2[v]!=11451419)return dp2[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n\t\tif(i*(i+1)*(i+2)/6%2!=1)continue;\n\t\tif(v-i*(i+1)*(i+2)/6>=0)cnt=min(cnt,func2(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn dp2[v]=cnt+1;\n}\n\nint main(void){\n\tint n;\n\tfor(int i=1;i<=1000000;i++)dp[i]=dp2[i]=11451419;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",func(n),func2(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1],n;\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      dp[0][nxt] = min(dp[0][nxt],dp[0][j] + 1);\n      if(val&1)dp[1][nxt] = min(dp[1][nxt],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1200001]={0,1,2,3},d[1200001],k=0,i,j,n,p;\n  for(i=1;a[i-1]<1000000;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0,p=i;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<p;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint INF = 1000001;\n\nint main() {\n    vector<int> dp1(INF, INF);\n    vector<int> dp2(INF, INF);\n\n    dp1.at(0) = 0;\n    dp2.at(0) = 0;\n\n    for (int i = 0; i < INF; i++) {\n        for (int j = 1; j < 201; j++) {\n            int k = j*(j+1)*(j+2)/6;\n            if (i - k < 0 || INF <= i - k) {\n                continue;\n            }\n            dp1.at(i) = min(dp1.at(i), dp1.at(i-k) + 1);\n            if (k % 2 == 1) {\n                dp2.at(i) = min(dp2.at(i), dp2.at(i-k) + 1);\n            }\n        }\n    }\n    \n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        cout << dp1.at(n) << \" \" << dp2.at(n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n \nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n \n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)(??´????????`)///\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    vector < vector<bool> >dp(6, vector < bool>(1000001, 0));\n    dp[0][0] = 1;\n    REP(i, 5) {\n        REP(j, INF) {\n            int k = j*(j + 1)*(j + 2) / 6;\n            if (k > 100001)break;\n            REP(l, 100001 - k) {\n                if (dp[i][l])dp[i + 1][l + k] = 1;\n            }\n        }\n    }\n    vector<vector<bool>> dp2(101, vector<bool>(1000001, 0));\n    REP(i, 100) {\n        REP(j, INF) {\n            int k = j*(j + 1)*(j + 2) / 6;\n            if (k % 2 == 0)continue;\n            if (k > 100001)break;\n            REP(l, 100001 - k) {\n                if (dp2[i][l])dp2[i + 1][l + k] = 1;\n            }\n        }\n    }\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n)break;\n        REP(i, 5) {\n            if (dp[i + 1][n]) {\n                cout << i + 1;\n                break;\n            }\n        }\n        cout << \" \";\n        REP(i, 100) {\n            if (dp2[i + 1][n]) {\n                cout << i + 1 << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void) {\n\tint lim = 1000000;\n\tint dp[lim],odp[lim];\n\tfor (int i = 0; i < lim; ++i) {\n\t\tdp[i] = i;\n\t\todp[i] = i;\n\t}\n\n\tint num = 4;\n\tfor (int now = 2; num < lim; ++now) {\n\t\tfor (int i = num; i < lim; ++i) {\n\t\t\tdp[i] = min(dp[i],dp[i-num]+1);\n\t\t}\n\t\tif (num%2 == 1) {\n\t\t\tfor (int i = num; i < lim; ++i) {\n\t\t\t\todp[i] = min(odp[i],odp[i-num]+1);\n\t\t\t}\n\t\t}\n\t\tnum = ((now+1)*(now+2)*(now+3))/6;\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << odp[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define N 1000001\n\nint dp[N], dp1[N];\n\nvoid gen()\n{\n    memset(dp, 37, sizeof(dp));\n    memset(dp1, 37, sizeof(dp1));\n    dp[0] = dp1[0] = 0;\n\n    for (int n = 1; ; ++n) {\n        int p = n * (n + 1) * (n + 2) / 6;\n        if (p >= N)\n            break;\n        for (int i = p; i < N; ++i) {\n            dp[i] = min(dp[i], dp[i - p] + 1);\n            if (p & 1)\n                dp1[i] = min(dp1[i], dp1[i - p] + 1);\n        }\n    }\n}\n\nint main()\n{\n    gen();\n\n    int t;\n    while (cin >> t && t)\n        cout << dp[t] << ' ' << dp1[t] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint prime[200],dprime[100];\nint dp[2000001];\nint main(){\n\tint a=1,b=2,count=1,dcount=1;\n\tprime[0]=1,dprime[0]=1;\n\twhile(true){\n\t\ta+=b;\n\t\tb++;\n\t\tif(prime[count-1]+a>=1000000)\n\t\t\tbreak;\n\t\tif((prime[count-1]+a)%2==1){\n\t\t\tdprime[dcount]=prime[count-1]+a;\n\t\t\tdcount++;\n\t\t}\n\t\tprime[count]=prime[count-1]+a;\n\t\tcount++;\n\t}\n\tint n;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<=2000000;i++)\n\t\t\tdp[i]=i%4+i/4;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<count;j++)\n\t\t\t\tdp[i+prime[j]]=min(dp[i+prime[j]],dp[i]+1);\n\t\t}\n\t\tcout<<dp[n]<<\" \";\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tdp[i]=i%35+i/35;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<dcount;j++)\n\t\t\t\tdp[i+dprime[j]]=min(dp[i+dprime[j]],dp[i]+1);\n\t\t}\n\t\tcout<<dp[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\n\nvoid setpolloc(){\n\tint i,j;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100010;i++){\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tfor(i=1;i<=100010;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;j<=i-1;j+=2)if(!dp2[i] || dp2[j]+dp2[i-j] < dp2[i]) dp2[i]=dp2[j]+dp2[i-j];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;j<=i-1;j++) if(!dp1[i] || dp1[j]+dp1[i-j] < dp1[i]) dp1[i]=dp1[j]+dp1[i-j];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\ntypedef vector<vector<int> > VVI;\nconst int INF = 1e9;\nconst double EPS = 1e-6;\n\nconst int MAX = 1e6;\nvector<int> num;\n\nint main()\n{\n\tint dp[MAX+1], dp2[MAX+1];\n\tfill(dp, dp+MAX+1, INF);\n\tfill(dp2, dp2+MAX+1, INF);\n\t\n\tdp[0] = dp2[0] = 0;\n\tdp[1] = dp2[1] = 1;\n\t\n\tfor (int i=1; ; i++) {\n\t\tint n = i*(i+1)*(i+2)/6;\n\t\tif (n > MAX) break;\n\t\tnum.push_back(n);\n\t}\n\t\n\tfor (int i=0; i<=MAX; i++) {\n\t\tfor (int j=0; j<num.size(); j++) {\n\t\t\tint n = i + num[j];\n\t\t\tif (n <= MAX) {\n\t\t\t\tdp[n] = min(dp[n], dp[i]+1);\n\t\t\t\tif (num[j]%2==1)\n\t\t\t\t\tdp2[n] = min(dp2[n], dp2[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint N;\n\twhile (cin>>N, N) {\n\t\tcout << dp[N] << \" \" << dp2[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF (1<<29)\n\nusing namespace std;\n\nint main(void){\n\n  vector<int>v;\n  for(int i=1;i*(i+1)*(i+2)/6<1000000;i++)\n    v.push_back(i*(i+1)*(i+2)/6);\n\n  int dp1[1000001],dp2[1000001];\n  fill(dp1,dp1+1000001,INF);\n  fill(dp2,dp2+1000001,INF);\n  \n  dp1[0]=dp2[0]=0;\n\n  for(int i=0;i<v.size();i++){\n    for(int j=0;j<1000000;j++){\n      if(j+v[i]<1000000){\n\tdp1[j+v[i]]=min(dp1[j+v[i]],dp1[j]+1);\n\tif(v[i]%2==1)dp2[j+v[i]]=min(dp2[j+v[i]],dp2[j]+1);\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n,n){\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> T, T_odd, A(M,INF), odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  odd[0] = 0;\n  T.push_back(1);\n  T_odd.push_back(1);\n  while(t < 1000000){\n    T.push_back(t);\n    if (t%2) T_odd.push_back(t);\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  odd.push_back(M);\n  for(int i = 0; i < T.size(); ++i){\n    for(int j = 1; j <= 5; ++j){\n      for(int k = 0; k+T[i]*j < M; ++k){\n\tA[k+T[i]*j] = min(A[k+T[i]*j],A[k]+j);\n      }\n    }\n  }\n  for(int i = 0; i < T_odd.size()-1; ++i){\n    for(int j = 1; j < 10; ++j){\n      for(int k = 0; k+T_odd[i]*j < M; ++k){\n\todd[k+T_odd[i]*j] = min(odd[k+T_odd[i]*j],odd[k]+j);\n      }\n    }\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 1000000\n#define INF (1<<24)\nint n[100000],M;\n\nint dp[1000005];\nint od[1000005];\n\nint main()\n{\n\tfor(M=1; ; M++)\n\t{\n\t\tint v=M*(M+1)*(M+2)/6;\n\t\tif(v>MAX) break;\n\t\tn[M]=v;\n\t}\n\n\n\n\tfor(int i=0; i<=MAX; i++)\n\t{\n\t\tdp[i]=INF;\n\t\tod[i]=INF;\n\t}\n\n\tdp[0]=od[0]=0;\n\n\tfor(int i=1; i<M; i++)\n\tfor(int j=0; j<=MAX; j++) \n\t{\n\t\tif(j+n[i] > MAX) break;\n\t\tif(dp[j]!=INF)\n\t\t{\n\t\t\tdp[j+n[i]]=min(dp[j+n[i]], dp[j]+1);\n\t\t}\n\t\tif(od[j]!=INF&&n[i]%2==1)\n\t\t{\n\t\t\tod[j+n[i]]=min(od[j+n[i]], od[j]+1);\n\t\t}\n\t}\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\n\t\tcout << dp[N] << \" \" << od[N] << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint b[1000000],d[1000000];\nint main(){\n  \n  int c[181];\n  fill(b,b+1000000,1000000);\n  fill(d,d+1000000,1000000);\n  for(int i=1;i<=180;i++){\n    c[i] = i*(i+1)*(i+2)/6;\n    b[ c[i] ] = 1;\n    if(c[i]%2 == 1) d[ c[i] ] = 1;\n  }\n  \n  for(int i=1;i<=180;i++){\n    for(int j=1;j<1000000-c[i];j++){\n      b[j+c[i]] = min(b[j+c[i]],b[j]+1);\n      if(c[i]%2 == 1) d[j+c[i]] = min(d[j+c[i]],d[j]+1);\n    }\n  }\n  \n  \n  \n  int n;\n  while(cin>>n,n!=0)\n    cout << b[n] << ' ' << d[n] << endl;\n  \n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=1;\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  tmp=1; \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "/* C ????§????: ?????? */\n#include<bits/stdc++.h>\n#define dump(a) cout << (#a) << (a) << endl\nusing namespace std;\n\n#define MAX_SIZE 2000002\n\n//pollok\nint memo[MAX_SIZE]; //MAX_SIZE??????\nint memo_kisu[MAX_SIZE]; //MAX_SIZE??????\nvector<int> all_pks;\nvector<int> kisu_pks;\n\n//P=pk??????, index=pks????????¨?????´???\nint dfs(const int P, int memo_cnt[MAX_SIZE], vector<int> &pks)\n{\n\t//dump(level);\n\tif (P == 0) { return 0; }\n\tif (memo_cnt[P] != -1) { return memo_cnt[P]; } //?????¢????????\\\n\t\n\tint min_depth = INT_MAX;\n\t//100??????\n\tfor(int i=0; i<pks.size(); i++) { //??§?????????\n\t\tint next_P = P-pks[i];\n\t\tif (next_P >= 0) {\n\t\t\tint depth = dfs(next_P, memo_cnt, pks) + 1; //????????°???????????????\n\t\t\tmin_depth = min(min_depth,depth); //????°????????????°\n\t\t}\n\t\t//?????????????????´???????¬?\n\t}\n\t//???????????¢???\n\tmemo_cnt[P] = min_depth;\n\t\n\treturn min_depth;\n}\n\nint main() {\n\tint n=1;\n\twhile(true) {\n\t\tint pk = n * (n+1) * (n+2) / 6;\n\t\tif (pk >= MAX_SIZE){ break; }\n\n\t\tall_pks.push_back(pk);\n\t\tif (pk % 2 != 0) { kisu_pks.push_back(pk); }\n\t\tn++;\n\t}\n\treverse(begin(all_pks),end(all_pks));\n\treverse(begin(kisu_pks),end(kisu_pks));\n\n\tmemset(memo,-1,sizeof(memo));\n\tmemset(memo_kisu,-1,sizeof(memo_kisu));\n\n\tint P;\n\twhile(cin >> P) {\n\t\tif (P == 0) { break; }\n\n\t\tint index=0; //\n\t\tint left=0,right=0;\n\t\tleft = dfs(P, memo, all_pks);\n\t\tright = dfs(P,memo_kisu, kisu_pks);\n\t\tcout << left << \" \" << right << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX=200,MAX_N=1e6+10;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    vector<int> reg(MAX),dp0(MAX_N,MAX_N),dp1(MAX_N,MAX_N);\n    for (int i=0;i<MAX;++i)\n        reg[i]=i*(i+1)*(i+2)/6;\n    dp0[0]=dp1[0]=0;\n    for (int i=0;i<MAX_N;++i){\n        for (int j=1;i+reg[j]<MAX_N;++j){\n            dp0[i+reg[j]]=min(dp0[i+reg[j]],dp0[i]+1);\n            if (reg[j]&1) dp1[i+reg[j]]=min(dp1[i+reg[j]],dp1[i]+1);\n        }\n    }\n    int n;\n    while(cin >> n,n){\n        cout << dp0[n] << ' ' << dp1[n] << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nint odd[2][1000001];\nint Odd(int n,int w){\n  for(int i=0;i<2;i++)\n    for(int j=0;j<=n;j++){\n      odd[i][j]=99999999;\n      if(i==0)odd[i][j]=j;\n      if(j==0)odd[i][j]=0;\n    }\n\n    for(int i=1;i<=w;i++){\n      for(int j=1;j<=n;j++){\n\tif((i*(i+1)*(i+2)/6)%2==0){\n\t  odd[i&1][j]=odd[i&1^1][j];\n\t}else if(j<i*(i+1)*(i+2)/6){\n\t  odd[i&1][j]=odd[i&1^1][j];\n\t}else{\n\t  odd[i&1][j]=min(odd[i&1^1][j],odd[i&1][j-i*(i+1)*(i+2)/6]+1);\n\t}\n      }\n    }\n    return 1;\n}\n\nint main(){\n  int n=1000000;\n  int w=300;\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++){\n\tdp[i][j]=99999999;\n\tif(i==0)dp[i][j]=j;\n\tif(j==0)dp[i][j]=0;\n      }\n    for(int i=1;i<=w;i++){\n      for(int j=1;j<=n;j++){\n\tif(j<i*(i+1)*(i+2)/6){\n\t  dp[i&1][j]=dp[i&1^1][j];\n\t}else{\n\t  dp[i&1][j]=min(dp[i&1^1][j],dp[i&1][j-i*(i+1)*(i+2)/6]+1);\n\t}\n\t//cout << \"dp[\" << i << \"][\" << j <<\"]:\"<< dp[i][j] << endl;\n      }\n    }\n    int a;\n    Odd(n,w);\n    while(cin>>a,a){\n      int b=0;\n      while(b*(b+1)*(b+2)/6<a)b++;\n      cout << dp[b%2][a] << \" \" << odd[b%2][a] << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint dp1[MAX+1],dp2[MAX+1];\n\nint main(){\n    //INFで初期化\n    for(int i = 1;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n * 2) /6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;  //ポロック数の生成\n        for(int i = a;i <= MAX;i++){     //正四面体数の個数dp(a以下は必要ない)\n            dp1[i] = min(dp1[i],dp1[i-a] + 1);  //更新しないor左側から更新する\n        }\n        if(a % 2 == 0)continue;     //偶数の時は次のroopへ\n        for(int i = a;i <= MAX;i++){     //奇数の正四面体数の個数dp(a以下は必要ない)\n            dp2[i] = min(dp2[i],dp2[i-a] + 1);  //更新しないor左側から更新する\n        }\n    }\n\n    //入出力\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\nint main()\n{\n    int i,j;\n    int n = 1e6;\n    int tmpnmax = 200;\n    vector<ll> sankaku(tmpnmax);\n    for(i = 0;i < tmpnmax;++i){\n        sankaku.at(i) = i+1;\n    }\n    for(i = 1;i < tmpnmax;++i){\n        sankaku.at(i) += sankaku.at(i-1);\n    }\n    vector<ll> simen = sankaku;\n    for(i = 1;i < tmpnmax;++i){\n        simen.at(i) += simen.at(i-1);\n    }\n    vector<ll> dp1(n+1,1e9);\n    vector<ll> dp2(n+1,1e9);\n    dp1.at(0) = 0;\n    dp2.at(0) = 0;\n    for(i = 1;i <= tmpnmax;++i){\n        if(simen.at(i-1) > n) break;\n        for(j = 0;j + simen.at(i-1) <= n;++j){\n            dp1.at(j + simen.at(i-1)) = min(dp1.at(j) + 1, dp1.at(j + simen.at(i-1)));\n            if(simen.at(i-1)%2) dp2.at(j + simen.at(i-1)) = min(dp2.at(j) + 1, dp2.at(j + simen.at(i-1)));\n        }\n    }\n    while(true){\n        int nn;\n        cin >> nn;\n        if(nn == 0) return 0;\n        cout << dp1.at(nn) << \" \" << dp2.at(nn) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst long long LINF = 1e18;\n#define dump(x)  cout << 'x' << ' = ' << (x) << ` `;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOREACH(x,a) for(auto& (x) : (a) )\ntypedef long long ll;\nusing namespace std;\nint main(int argc, char const *argv[]) {\n    int M = 1e6+10;\n    vector<int> nums;\n    int x = 1;\n    while (true) {\n        int y = (x*(x+1)*(x+2))/6;\n        if (y > M) break;\n        nums.push_back(y);\n        ++x;\n    }\n    vector<int> dp(M, INF);\n    vector<int> odd_dp(M, INF);\n    dp[0] = odd_dp[0] = 0;\n    for (int i = 1; i < M; ++i) {\n        for (auto &&e: nums) {\n            if (i-e < 0) continue;\n            dp[i] = min(dp[i], dp[i-e]+1);\n            if (e%2 == 1) odd_dp[i] = min(odd_dp[i], odd_dp[i-e]+1);\n        }\n    }\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        \n        printf(\"%d %d\\n\",dp[N], odd_dp[N]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[10000000], dp2[10000000];\nint main() {\n\tv.pb(0);\n\tll n, now = 1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)(i*(i + 1)*(i + 2) / 6);\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 1000000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], (ll)i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 1000000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], (ll)i / v[j] + dp2[i%v[j]]);\n\t}\n\twhile (cin >> n, n) {\n\t\trep(i, n)cout << i << \"ha\" << dp[i] << endl;\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\nint main() {\n\tint n; vector<int>v; vector<int>u;\n\tint i = 1; int t = 1;\n\twhile (t < 1000000) {\n\t\tv.push_back(t);\n\t\tif (t % 2)u.push_back(t);\n\t\tt *= (i + 3);\n\t\tt /= i;\n\t\ti++;\n\t}\n\tint dp1[1000000],dp2[1000000];\n\tfill(dp1, dp1 + 1000000, (int)MOD);\n\tfill(dp2, dp2 + 1000000, (int)MOD);\n\tdp1[0] = dp2[0] = 0;\n\tint len = v.size();\n\trep(i, len) {\n\t\trep(j, 1000000) {\n\t\t\tif (dp1[j]!=(int)MOD&&j + v[i] < 1000000) {\n\t\t\t\tdp1[j + v[i]] = min(dp1[j + v[i]], dp1[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tlen = u.size();\n\trep(i, len) {\n\t\trep(j, 1000000) {\n\t\t\tif (dp2[j] != (int)MOD&&j + u[i] < 1000000) {\n\t\t\t\tdp2[j + u[i]] = min(dp2[j + u[i]], dp2[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 1e9\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int dp[1000010]={};\n  int dp2[1000010]={};\n  for(int i=1;i<=1000000;i++){dp[i]=INF;dp2[i]=INF;}\n  vector<ll> gu;\n  vector<ll> ki;\n  ll cnt=1;\n  while(1){\n    if((cnt*(cnt+1)*(cnt+2)/6)>1000000)break;\n    if(((cnt*(cnt+1)*(cnt+2))/6)%2){ki.pb(cnt*(cnt+1)*(cnt+2)/6);dp[ki[ki.size()-1]]=1;dp2[ki[ki.size()-1]]=1;}\n    else {gu.pb(cnt*(cnt+1)*(cnt+2)/6);dp[gu[gu.size()-1]]=1;}\n    cnt++;\n  }\n  dp[1]=1;\n  dp2[1]=1;\n  for(int i=1;i<1000000;i++){\n    for(int j=0;j<gu.size();j++){\n      if(i+gu[j]>1000000)break;\n      dp[i+gu[j]]=min(dp[i+gu[j]],(dp[i]+1));\n    }\n    for(int j=0;j<ki.size();j++){\n      if(i+ki[j]>1000000)break;\n      dp[i+ki[j]]=min(dp[i+ki[j]],(dp[i]+1));\n      dp2[i+ki[j]]=min(dp2[i+ki[j]],(dp2[i]+1));\n    }\n  }\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nint tetra(int n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint solve(int n)\n{\n  for(int i = 1; tetra(i) <= n; i++){\n    if(tetra(i) & 1)\n      dp2[tetra(i)] = 1;\n    dp[tetra(i)] = 1;\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; i + tetra(j) <= MAX; j++){\n      if(tetra(j) & 1)\n        dp2[i + tetra(j)] = min(dp2[i] + 1, dp2[i + tetra(j)]);\n      dp[i + tetra(j)] = min(dp[i] + 1, dp[i + tetra(j)]);\n    }\n  }    \n}\n\nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid append(int t, int n, int table[]) {\n    table[t] = 1;\n    for (int i=0; i<=n-t; i++) {\n        if (table[i] < 0) {\n            continue;\n        }\n        if (table[i+t] < 0) {\n            table[i+t] = table[i]+1;\n        }\n        else {\n            table[i+t] = min(table[i]+1, table[i+t]);\n        }\n    }\n}\n\nint main() {\n    int n;\n    int dp[1000000];\n    int dp_odd[1000000];\n    for (int i=0; i<1000000; i++) {\n        dp[i] = -1;\n        dp_odd[i] = -1;\n    }\n    for (int i=0; true; i++) {\n        int t = i*(i+1)*(i+2)/6;\n        if (t > 1000000) {\n            break;\n        }\n        append(t, 1000000, dp);\n        if (t%2 == 1) {\n            append(t, 1000000, dp_odd);\n        }\n    }\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n        cout << dp[n] << ' ' << dp_odd[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nenum{ALL, ODD, SIZE};\nvector<int> seq;\n\ninline bool toOdd(int &nowId, int nowN){\n    while((seq[nowId] & 1) == 0){\n        nowId--;\n    }\n    return nowId < 0;\n}\n\nint main(int argc, const char * argv[]) {\n    for(int i = 1; i < 400; i++){\n        seq.push_back(i*(i+1)*(i+2)/6);\n    }\n    \n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        \n        int id = int(distance(seq.begin(), lower_bound(seq.begin(), seq.end(), n)));\n        \n        int minimum[2] = {5,1000};\n        for(; id >= 0; id--){\n            int cnt[2] = {0, 0};\n            \n            for(int i = 0; i < SIZE; i++){\n                int nowId = id, nowN = n;\n                \n                while(nowN > 0 && nowId >= 0){\n                    if(i&1 && toOdd(nowId,nowN)) break;\n                    \n                    if(nowN >= seq[nowId]){\n                        nowN -= seq[nowId];\n                        cnt[i]++;\n                    } else {\n                        while(nowId > 0 && nowN < seq[nowId]){\n                            nowId--;\n                        }\n                        if(i&1 && toOdd(nowId,nowN)) break;\n                        \n                        if(nowId >= 0){\n                            nowN -= seq[nowId];\n                            cnt[i]++;\n                        }\n                    }\n                }\n                if(nowN == 0) minimum[i] = min(minimum[i], cnt[i]);\n            }\n\n        }\n        cout << minimum[0] << \" \" << minimum[1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\n\nint odd(int n,int w){\n  for(int i=0;i<2;i++)\n    for(int j=0;j<=n;j++){\n      dp[i][j]=99999999;\n      if(i==0)dp[i][j]=j;\n      if(j==0)dp[i][j]=0;\n    }\n\n    for(int i=1;i<=w;i++){\n      for(int j=1;j<=n;j++){\n\tif((i*(i+1)*(i+2)/6)%2==0){\n\t  dp[i&1][j]=dp[i&1^1][j];\n\t}else if(j<i*(i+1)*(i+2)/6){\n\t  dp[i&1][j]=dp[i&1^1][j];\n\t}else{\n\t  dp[i&1][j]=min(dp[i&1^1][j],dp[i&1][j-i*(i+1)*(i+2)/6]+1);\n\t}\n\t//cout << \"dp[\" << i << \"][\" << j <<\"]:\"<< dp[i][j] << endl;\n      }\n    }\n    return dp[w%2][n];\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int w=0;\n    while(w*(w+1)*(w+2)/6 < n){\n      w++;\n    }\n    for(int i=0;i<2;i++)\n      for(int j=0;j<=n;j++){\n\tdp[i][j]=99999999;\n\tif(i==0)dp[i][j]=j;\n\tif(j==0)dp[i][j]=0;\n      }\n    for(int i=1;i<=w;i++){\n      for(int j=1;j<=n;j++){\n\tif(j<i*(i+1)*(i+2)/6){\n\t  dp[i&1][j]=dp[i&1^1][j];\n\t}else{\n\t  dp[i&1][j]=min(dp[i&1^1][j],dp[i&1][j-i*(i+1)*(i+2)/6]+1);\n\t}\n\t//cout << \"dp[\" << i << \"][\" << j <<\"]:\"<< dp[i][j] << endl;\n      }\n    }\n    cout << dp[w%2][n] << \" \" << odd(n,w) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n       \nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\nint main() {\n  int n;\n\n  const int INF = 1e9;\n  const int N_MAX = 1e6;\n\n  vector<int> dp(N_MAX, INF), dpo(N_MAX, INF);\n  dp[0] = 0;\n  dpo[0] = 0;\n\n  for (int i = 1, t = 1; t < N_MAX; ++i, t = i * (i + 1) * (i + 2) / 6) {\n    for (int j = 0; j < (int)(N_MAX); ++j) {\n      int nj = j + t;\n      if (nj < N_MAX) chmin(dp[nj], dp[j] + 1);\n      if (nj < N_MAX && t % 2 == 1) chmin(dpo[nj], dpo[j] + 1);\n    }\n  }\n\n  while (true) {\n    cin >> n;\n    if (n == 0) return 0;\n    cout << dp[n] << \" \" << dpo[n] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 181\n#define INF 100000000\n\nint r[MAX_N];\n\nint main() {\n    r[0] = 0;\n    r[1] = 1;\n    int j = 3;\n    FOR(i, 2, MAX_N) {\n        r[i] = r[i-1] + j;\n        j += i+1;\n    }\n\n    int n;\n    while (cin >> n, n) {\n        vvi dp(2, vi(n+1, INF));\n        FOR(i, 1, MAX_N) {\n            if (r[i] <= n) {\n                dp[0][r[i]] = 1;\n            } else {\n                break;\n            }\n        }\n        while (dp[0][n] == INF) {\n            FOR(i, 1, n+1) {\n                if (dp[0][i] != INF) {\n                    REP(j, MAX_N) {\n                        if (i + r[j] <= n) {\n                            dp[1][i+r[j]] = min(dp[0][i+r[j]], dp[0][i] + 1);\n                        }\n                    }\n                }\n            }\n            dp[0] = dp[1];\n        }\n        cout << dp[0][n] << \" \";\n\n        fill(ALL(dp[0]), INF);\n        fill(ALL(dp[1]), INF);\n        FOR(i, 1, MAX_N) {\n            if (r[i] <= n) {\n                if (r[i] % 2 == 1) dp[0][r[i]] = 1;\n            } else {\n                break;\n            }\n        }\n        while (dp[0][n] == INF) {\n            FOR(i, 1, n+1) {\n                if (dp[0][i] != INF) {\n                    REP(j, MAX_N) {\n                        if (r[j] % 2 == 1 && i + r[j] <= n) {\n                            dp[1][i+r[j]] = min(dp[0][i+r[j]], dp[0][i] + 1);\n                        }\n                    }\n                }\n            }\n            dp[0] = dp[1];\n        }\n        cout << dp[0][n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i,p,k) for (int i = p; i < (int)(k); ++i)\n#define FOREACH(it,x) for (__typeof((x).begin()) it = (x).begin(); it != (x).end(); ++it)\n#define ALL(x) x.begin(), x.end()\n#define DEBUG(x) cerr<<#x\":\"<<(x)<<\" \"\ntemplate<class T> void DUMP(const T& v) { FOREACH(it,v) cerr<<*it<<' '; cerr<<endl; }\n\nconst int INF = 12345678;\nvector<int> nums;\n\nint memo[1000005][2];\n\nint solve(int rest, int odd) {\n  if (rest < 0) return INF;\n  if (rest == 0) {\n    return 0;\n  }\n  int& minv = memo[rest][odd];\n  if (minv >= 0) return minv;\n  minv = rest;\n  for (int i = nums.size()-1; i >= 2; --i) {\n    int v = nums[i];\n    if (odd && v % 2 == 0) continue;\n    if (rest < v) continue;\n    if (minv <= rest / v) continue;\n    minv = min(minv, solve(rest - v, odd) + 1);\n  }\n  return minv;\n}\n\nint main() {\n  int n;\n  for (int i = 0; ; i++) {\n    int v = i * (i+1) * (i+2) / 6;\n    if (v > 1000000) break;\n    nums.push_back(v);\n  }\n  memset(memo, -1, sizeof(memo));\n  while (cin >> n, n) {\n    cout << solve(n, 0) << \" \" << solve(n, 1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<set>\n#include<array>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n#define UNIQUE(a) a.erase(unique(ALL(a)), a.end())\n\nusing namespace std;\n\nconst int MAX_NUM=1000001;\n\n\nvector<int> dp(MAX_NUM,MAX_NUM);//?§????????????£?????¢?????°????????°\nvector<int> dp_odd(MAX_NUM,MAX_NUM);\n\nint main(){\n\n  vector<int> numbers;\n  \n  int cnt=1,sum=0;\n  while (1) {\n    sum=(cnt*(cnt+1)*(cnt+2))/6;\n    if(sum>MAX_NUM) break;\n    numbers.push_back(sum); \n    dp[sum]=1;\n    if(sum%2==1)dp_odd[sum]=1;\n    cnt++;  \n  }\n\n  for(int i=1;i<MAX_NUM;i++){\n    rep(j,numbers.size()){\n      if(i-numbers[j] <= 0) break;\n      dp[i]=min(dp[i],dp[i-numbers[j]] + 1);\n      if(numbers[j]%2==1) dp_odd[i]=min(dp_odd[i],dp_odd[i-numbers[j]] + 1);\n    }\n  }\n\n\n  while(1){\n    int n;\n    cin >> n; if(n==0) break;\n    cout << dp[n] << \" \" << dp_odd[n] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<set>\n#include<map>\n#include<math.h>\n#include <string>\n#define cinf(n,x) for(int i=0;i<(n);i++) cin >> x[i];\ntypedef long long int ll;\nusing namespace std;\nll mod=1e9+7;\nint N=1e6;\nint cnt[1000000];\nint odd[1000000];\nint main(){\n\tvector<int> v(180),u(181);\n\tv[0]=0;\n\tfor(int i=1;i<=180;i++){\n\t\tv[i]=(i*(i+1)*(i+2)/6);\n\t}\n\tu[0]=0;\n\tfor(int i=1;i<=180;i++){\n\t\tu[i]=u[i-1]+i;\n\t}\n\tcnt[0]=odd[0]=0;\n\tfor(int i=1;i<N;i++){\n\t\tcnt[i]=1e9;\n\t\todd[i]=1e9;\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=1;j<=180;j++){\n\t\t\tif(i-v[j]>=0){\n\t\t\t\tif(cnt[i]>cnt[i-v[j]]+1){\n\t\t\t\t\tcnt[i]=cnt[i-v[j]]+1;\n\t\t\t\t}\n\t\t\t\tif(v[j]%2==1&&odd[i]>odd[i-v[j]]+1){\n\t\t\t\t\todd[i]=odd[i-v[j]]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(1){\n\t\tint n; cin >>n;\n\t\tif(n==0)break;\n\t\tcout << cnt[n] << \" \" << odd[n] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define REP(i,l,n) for(int i=l;i<n;++i)\nint ans = 0;\nint oddans = 0;\nint pol[200];\nint oddpol[100];\nint oddpolcount = 0;\nint memo[1000000];\nint oddmemo[1000000];\nint memorep(int n);\nint oddmemorep(int n);\nusing namespace std;\nint main() {\n  pol[0] = 1;\n  oddpol[oddpolcount++] = 1;\n  int def = 3;\n  int defdef = 3;\n  REP(i,1,180){\n    pol[i] = pol[i-1] + def;\n    if(pol[i]%2==1) oddpol[oddpolcount++] = pol[i];\n    def += defdef++;\n  }\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    ans = memorep(n);\n    oddans = oddmemorep(n);\n    int i = 0;\n    cout << ans << \" \" << oddans << endl;\n  }\n  return 0;\n}\n\nint memorep(int n){\n  assert(n < 1000000);\n  if(memo[n]!=0) return memo[n];\n  int result;\n  int min = 1000000;\n  for(int i = 179;i>=0;i--){\n    result = n-pol[i];\n    if(result == 0){\n      return memo[n] = 1;\n    }\n    if(result > 0){\n      result = memorep(result) + 1;\n      if(min > result) min = result;\n    }\n  }\n  return memo[n] = min;\n}\n\nint oddmemorep(int n){\n  if(oddmemo[n]!=0) return oddmemo[n];\n  int result;\n  int min = 1000000;\n  for(int i = oddpolcount-1;i>=0;i--){\n    result = n-oddpol[i];\n    if(result == 0){\n      return oddmemo[n] = 1;\n    }\n    if(result > 0){\n      result = oddmemorep(result) + 1;\n      if(min > result){\n        min = result;\n      }\n    }\n  }\n  return oddmemo[n] = min;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\nint c[300];\nvector<int> d;\nint a[10000000],b[10000000];\n\nvoid f(int n){\n  fill(a,a+1000000,inf);\n  fill(b,b+1000000,inf);\n  a[0]=b[0]=0;\n  rep(i,1000000){\n    FOR(j,1,300){\n      if(i+c[j]>=1000000)break;\n      a[i+c[j]]=min(a[i+c[j]],a[i]+1);\n    }\n  }\n  rep(i,1000000){\n    FOR(j,1,d.size()){\n      if(i+d[j]>=1000000)break;\n      b[i+d[j]]=min(b[i+d[j]],b[i]+1);\n    }\n  }\n\n\n\n\n}\n\nvoid g(int n){\n  cout<<a[n]<<' '<<b[n]<<endl;\n}\n\n\nint main(){\n  d.push_back(0);\n  for(int i=1;i<200;i++){\n    c[i] = (i*(i+1)*(i+2))/6;\n  \n   if(c[i]%2){\n     d.push_back(c[i]);\n   }\n  }\n\n  f(1000000);\n\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    g(n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i,a,b) for(ll i=a;i<=b;i++)\n#define FORD(i,a,b) for(int i=a;i>=b;i--)\n#define ALL(a)  (a).begin(),(a).end()\n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define sqr(x) ((x) * (x))\n#define bit(n) (1LL<<(n))\n#define pcnt(x) __builtin_popcountll(x)\n#define PB push_back\n#define MP make_pair\n#define endl \"\\n\"\nusing Edge = pair<int,int>;\nusing Graph = vector<vector<Edge>>;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\n// ll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint dp[1001001];\nint dp2[1001001];\nconst int INF = 1001001001;\n\nint main() {\n  vector<int> v;\n  vector<int> v2;\n  int ret = 1;\n  while(1){\n    if(ret*(ret+1)*(ret+2)/6>1000000) break;\n    v.PB(ret*(ret+1)*(ret+2)/6);\n    if((ret*(ret+1)*(ret+2)/6)%2==1) v2.PB(ret*(ret+1)*(ret+2)/6);\n    ++ret;\n  }\n  sort(v.begin(),v.end(),greater<int>());\n  sort(v2.begin(),v2.end(),greater<int>());\n  FOR(i,1,1000000) dp[i] = INF;\n  FOR(i,1,1000000) dp2[i] = INF;\n  for(auto x: v){\n    dp[x] = 1;\n    FOR(i,0,1000000-x){\n      if(dp[i]!=INF) chmin(dp[i+x],dp[i]+1);\n    }\n  }\n  for(auto x: v2){\n    dp2[x] = 1;\n    FOR(i,0,1000000-x){\n      if(dp2[i]!=INF) chmin(dp2[i+x],dp2[i]+1);\n    }\n  }\n\n  while(1){\n    int n; cin >> n;\n    if(n==0) break;\n    cout << dp[n] << \" \" << dp2[n] << \"\\n\";\n  }\n  \n\n  \n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint D[182] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<182 ; i++ ){\n\t\tD[i] = i * (i+1) * (i+2) / 6 ;\n\t}\n}\n\nint cal_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( dp_map[0][x] != 0 ) return dp_map[0][x] ;\n\t\telse return x/D[c] + cal_2( x%D[c] , c-1 ) ;\n\t}\n}\n\nint cal( int m , int q ){\n\tint ans = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans = min( ans , cal_2( m , j ) ) ;\n\t}\n\treturn ans ;\n}\n\nint cal_odd_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( D[c]%2 == 0 ) return cal_odd_2( x , c-1 ) ;\n\t\telse{\n\t\t\tif( dp_map[1][x] != 0 ) return dp_map[1][x] ;\n\t\t\telse return x/D[c] + cal_odd_2( x%D[c] , c-1 ) ;\n\t\t}\n\t}\n}\n\nint cal_odd( int m , int q ){\n\tint ans_2 = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans_2 = min( ans_2 , cal_odd_2( m , j ) ) ;\n\t}\n\treturn ans_2 ;\n}\n\nvoid dp(){\n\tint p = 1 ;\n\tfor( int i=1 ; i<=1000000 ; i++ ){\n\t\tif( i < 182 && i >= D[p] ) p++ ;\n\t\tdp_map[0][i] = cal(i,p) ;\n\t\tdp_map[1][i] = cal_odd(i,p) ;\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\nint n = 0;\n\n\n\nvoid input() {\n\tCI n;\n}\n\n\nvoid proce_odd() {\n\tvector<int> tetra;\n\tint num = 1;\n\n\tint i = 0;\n\tint remain = 0;\n\tint maxx = 0;\n\n\twhile (true) {\n\n\t\tif (i * (i + 1) * (i + 2) / 6 > n && (i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n\t\t\ti--;\n\t\t\tauto ite = tetra.end();\n\t\t\tite--;\n\t\t\tmaxx = *ite;\n\t\t\tbreak;\n\t\t}\n\t\tif ((i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n\t\t\ttetra.push_back(i * (i + 1) * (i + 2) / 6);\n\t\t}\n\t\ti++;\n\t}\n\n\tremain = n - maxx;\n\tvector<int>::iterator it_end = tetra.end();\n\tvector<int>::iterator it_last = tetra.end();\n\t--it_end;\n\n\tint num_min = 1000001;\n\twhile (1) {\n\t\twhile (remain > 0) {\n\t\t\tnum++;\n\t\t\t++it_end;\n\t\t\tit_end = upper_bound(tetra.begin(), it_end, remain);\n\t\t\t--it_end;\n\n\t\t\tremain -= *it_end;\n\t\t}\n\t\tif (num_min > num) {\n\t\t\tnum_min = num;\n\t\t}\n\t\tnum = 1;\n\t\tremain = n - *--it_last;\n\t\tif (remain == n - 1)break;\n\t\tit_end = it_last;\n\t}\n\n\tCO num_min E;\n\n}\n\nvoid proce() {\n\tvector<int> tetra;\n\tint num = 1;\n\n\tint i = 0;\n\tint remain = 0;\n\tint maxx = 0;\n\n\twhile (true) {\n\n\t\tif (i * (i + 1) * (i + 2) / 6 > n) {\n\t\t\ti--;\n\t\t\tmaxx = i * (i + 1) * (i + 2) / 6;\n\t\t\tbreak;\n\t\t}\n\t\ttetra.push_back(i * (i + 1) * (i + 2) / 6);\n\t\ti++;\n\t}\n\n\tremain = n - maxx;\n\tvector<int>::iterator it_end = tetra.end();\n\tvector<int>::iterator it_last = tetra.end();\n\t--it_end;\n\n\tint num_min = 1000001;\n\twhile (1) {\n\t\twhile (remain > 0) {\n\t\t\tnum++;\n\t\t\t++it_end;\n\t\t\tit_end = upper_bound(tetra.begin(), it_end, remain);\n\t\t\t--it_end;\n\n\t\t\tremain -= *it_end;\n\t\t}\n\t\tif (num_min > num) {\n\t\t\tnum_min = num;\n\t\t}\n\t\tnum = 1;\n\t\tremain = n - *--it_last;\n\t\tif (remain == n - 1)break;\n\t\tit_end = it_last;\n\t}\n\n\tCO num_min;\n\n\n}\n\nint main(void) {\n\twhile (true) {\n\t\tinput();\n\t\tif (n == 0)break;\n\n\t\tproce();\n\n\t\tCO ' ';\n\n\t\tproce_odd();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, m, n) for(int(i) = (int)(m); i < (int)(n); ++i)\n#define rep2(i, m, n) for(int(i) = (int)(n)-1; i >= (int)(m); --i)\n#define REP(i, n) rep(i, 0, n)\n#define REP2(i, n) rep2(i, 0, n)\n#define all(hoge) (hoge).begin(), (hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\nconstexpr long long MOD = (ll)1e9 + 7;\n//constexpr long long MOD = 998244353LL;\nusing ld = long double;\nstatic const ld pi = 3.141592653589793L;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n    ll to, rev;\n    long double cap;\n    Edge(ll _to, long double _cap, ll _rev) {\n        to = _to;\n        cap = _cap;\n        rev = _rev;\n    }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph &G, ll from, ll to, long double cap, bool revFlag,\n              long double revCap) {\n    G[from].push_back(Edge(to, cap, (ll)G[to].size()));\n    if(revFlag)\n        G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\nvoid solve() {\n\n    vec<pair<int, int>> qs;\n    int x;\n    int i = 0;\n    while(cin >> x) {\n        if(x == 0)\n            break;\n        qs.push_back({x, i});\n        i++;\n    }\n    sort(all(qs));\n\n    int n = 190;\n    int m = 1000000;\n    int pos = 0;\n\n    vec<int> dp(m + 1, INF_INT), dp2(m + 1, INF_INT);\n    dp[0] = 0;\n    dp2[0] = 0;\n    vec<pair<int, int>> ans(qs.size());\n\n    REP(i, n) {\n        vec<int> dp3(m + 1, INF_INT), dp4(m + 1, INF_INT);\n        int k = (i + 1) * (i + 2) * (i + 3) / 6;\n        REP(j, m + 1) {\n            chmin(dp3[j], dp[j]);\n            chmin(dp4[j], dp2[j]);\n            if(j - k >= 0) {\n                chmin(dp3[j], dp3[j - k] + 1);\n                if(k % 2) {\n                    chmin(dp4[j], dp4[j - k] + 1);\n                }\n            }\n        }\n        dp = dp3;\n        dp2 = dp4;\n        while(pos < qs.size() and k >= qs[pos].first) {\n            ans[qs[pos].second] = {dp[qs[pos].first],\n                                   dp2[qs[pos].first]};\n            pos++;\n        }\n    }\n\n    for(auto i : ans) {\n        cout << i.first << \" \" << i.second << en;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    /*\n    ll t;\n    cin >> t;\n    while(t--)*/\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\nusing pci = pair<char, int>;\nusing vpci = vector<pci>;\n#define out(S) cout<<(S)<<endl;\n#define REP(i,b) for(size_t i=0;i<(b);i++)\n#define rREP(i,b) for(int i=(b)-1;i>=0;i--)\n#define FOR(i,a,b) for(size_t i=(a);i<(b);i++)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define Foreach(item,collection) for(auto item:collection)\n#define mod(i) ((i) % (ll)(1e9 + 7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a * modpow((ll)b,(ll)(1e9 + 5))))\n#define Yes out(\"Yes\")\n#define No out(\"No\")\n#define NO out(\"NO\")\n#define YES out(\"YES\")\n#define INF 1e10;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define IfOut(condition,text) if((condition)){out(text);return 0;}\n#define IfeOut(condition,itext,etext) if(condition){out(itext);return 0;}else{out(etext);return 0;}\n#define beginend(vec) (vec).begin(),(vec).end()\n#define pb(item) push_back(item)\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nbool isPrime(ll x) {if (x == 2) return true;if (x < 2 || x % 2 == 0) return false;ll i = 3;while (i <= sqrt(x)) {if (x%i == 0) return false;i += 2;}return true;}\n\nvl dd(int max) {\n\tvl rt;\n\tint n = 1;\n\twhile (true)\n\t{\n\t\tll next = n*(n + 1)*(n + 2) / 6;\n\t\tif (max  <= next) { rt.pb(next); break; }\n\t\trt.pb(next);\n\t\tn++;\n\t}\n\treturn rt;\n}\n\nvl llist;\n\nint bfs(int target) {\n\tqueue<ll> q;\n\tForeach(i, llist) {\n\t\tif (i == target) { return 1; }\n\t\telse if (i < target) q.push(i);\n\t}\n\tint cnt = 2;\n\twhile (1){\n\t\tqueue<ll> next;\n\t\tint ss = q.size();\n\t\tFOR(i, 0, ss) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tForeach(k, llist) {\n\t\t\t\tif (k + x > target) break;\n\t\t\t\tif (k + x == target) return cnt;\n\t\t\t\tif (k + x < target) next.push(k + x);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tq = next;\n\t}\n}\n\nint bfs2(int target) {\n\tqueue<ll> q;\n\tvl oddlist = llist;\n\tremoveAll(oddlist, [](ll x) {return x % 2 == 0; });\n\tForeach(i, oddlist) {\n\t\tif (i == target) { return 1; }\n\t\telse if (i < target) q.push(i);\n\t}\n\tint cnt = 2;\n\twhile (1) {\n\t\tset<ll> next;\n\t\tint ss = q.size();\n\t\tFOR(i, 0, ss) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tForeach(k, oddlist) {\n\t\t\t\tif (k + x > target) break;\n\t\t\t\tif (k + x == target) return cnt;\n\t\t\t\tif (k + x < target) next.insert(k + x);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tqueue<ll> nn;\n\t\tForeach(i, next) nn.push(i);\n\t\tq = nn;\n\t}\n}\n\nint main() {\n\tvi query;\n\tint k;\n\twhile (cin >> k, k)query.pb(k);\n\tauto mm = max_element(beginend(query));\n\tllist = dd(*mm);\n\t//ShowAll(llist);\n\tForeach(q, query) {\n\t\tcout << bfs(q) << \" \" << bfs2(q) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    int lower,size,rest;\n    State(int lower,int size,int rest) : lower(lower),size(size),rest(rest) {};\n};\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        vector<int> v;\n        vector<int> odd;\n        for(int i=1;;i++){\n            int c = i*(i+1)*(i+2)/6;\n            if(c > 1000000) break;\n            v.push_back(c);\n            if(c % 2 == 1) odd.push_back(c);\n        }\n        queue<State> que;\n        que.push(State(0,0,n));\n        int ret;\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                ret = s.size;\n                break;\n            }\n            for(int i=s.lower;v[i] <= s.rest;i++){\n                que.push(State(i,s.size+1,s.rest-v[i]));\n            }\n        }\n        int oret;\n        que = queue<State>();\n        que.push(State(0,0,n));\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                oret = s.size;\n                break;\n            }\n            for(int i=s.lower;odd[i] <= s.rest;i++){\n                que.push(State(i,s.size+1,s.rest-odd[i]));\n            }\n        }\n        cout << ret << \" \" << oret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = int(1e6);\n\nint dp[MAX + 1];\nint odp[MAX + 1];\n\nint main(void)\n{\n    int n;\n\n    fill(dp, dp + MAX + 1, MAX);\n    fill(odp, odp + MAX + 1, MAX);\n    dp[0] = odp[0] = 0;\n    for (int i = 0; i < 100; i++){\n        int tetra = i * (i + 1) * (i + 2) / 6;\n        for (int j = 0; j <= MAX - tetra; j++){\n            dp[j + tetra] = min(dp[j + tetra], dp[j] + 1);\n        }\n        if (tetra % 2 == 1){\n            for (int j = 0; j <= MAX - tetra; j++){\n                odp[j + tetra] = min(odp[j + tetra], odp[j] + 1);\n            }\n        }\n    }\n    while (cin >> n, n){\n        printf(\"%d %d\\n\", dp[n], odp[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp2[i+coin_ki[j]]=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  tmp=1; \n\t  tmp=min(dp2[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define all(a) a.begin(), a.end()\n#define P pair<int, int>\n#define F first\n#define S second\n#define prime 1000000007\n#define INF 40000000000000000\nint dx8[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint dy8[8] = {1, 1, 1, 0, -1, -1, -1, 0};\nint dx4[4] = {-1, 0, 1, 0};\nint dy4[4] = {0, -1, 0, 1};\nvector<int> V;\nvector<int> V1;\nint s, s1;\nint dp0[1000005];\nint dp1[1000005];\nint solve0(int n) {\n    if(n == 0) {\n        return dp0[0] = 0;\n    }\n    if(dp0[n] != -1) return dp0[n];\n    int res = INF;\n    rep(i, s) {\n        if(V[i] > n) break;\n        res = min(res, solve0(n - V[i]) + 1);\n    }\n    return dp0[n] = res;\n}\n\nint solve1(int n) {\n    if(n == 0) {\n        return dp1[0] = 0;\n    }\n    if(dp1[n] != -1) return dp1[n];\n    int res = INF;\n    rep(i, s1) {\n        if(V1[i] > n) break;\n        res = min(res, solve1(n - V1[i]) + 1);\n    }\n    return dp1[n] = res;\n}\nsigned main(void) {\n    for(int i = 1;; i++) {\n        int n = i * (i + 1) * (i + 2) / 6;\n        if(n < 1000000) {\n            V.push_back(n);\n            if(n % 2 == 1) V1.push_back(n);\n        } else\n            break;\n    }\n    s = V.size();\n    s1 = V1.size();\n    rep(i, 1000005) dp0[i] = -1;\n    rep(i, 1000005) dp1[i] = -1;\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n        cout << solve0(n) << ' ' << solve1(n) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define itrep(it, a) for(it = (a).begin(); it != (a).end(); it++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 30)\nusing namespace std;\n\nint dp1[2000050];\nint dp2[2000050];\n\nvoid solve(){\n    vector<int> va;\n    vector<int> vb;\n    int i = 1;\n    while(i * (i + 1) * (i + 2) / 6 <= 1000000){\n        int a = i * (i + 1) * (i + 2) / 6;\n        va.push_back(a);\n        if(a % 2 == 1) vb.push_back(a);\n        i++;\n    }\n    rep(i,1000005){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    dp1[0] = dp2[0] = 0;\n\n    for(int j = va.size() - 1; j >= 0; j--){\n        rep(i, 1000000){\n            if(dp1[i] != INF && dp1[i + va[j]] == INF){\n                dp1[i + va[j]] = dp1[i] + 1;\n            }\n        }\n    }\n    for(int j = vb.size(); j >= 0; j--){\n        rep(i, 1000000){\n            if(dp2[i] != INF && dp2[i + vb[j]] == INF){\n                dp2[i + vb[j]] = dp2[i] + 1;\n            }\n        }\n    }\n}\n\nint main(){\n    int n;\n    solve();\n    while(cin >> n, n){\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mint[1000000], mink[1000000];\nint main() {\n\tfor (int i = 1;; i++) {\n\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\tif (a >= 1000000)break;\n\t\tfor (int j = a; j < 1000000; j++) {\n\t\t\tmint[j] = min(mint[j], mint[j - a] + 1);\n\t\t\tif (a & 1)mink[j] = min(mink[j], mink[j - a] + 1);\n\t\t}\n\t}\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t\tprintf(\"%d %d\\n\", mint[n], mink[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX + 1], dp2[MAX + 1];\n\nint main()\n{\n    for (int i = 1; i <= MAX; i++)\n    {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for (int n = 1; n * (n + 1) * (n + 2) / 6 <= MAX; n++)\n    {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for (int i = a; i < MAX; i++)\n        {\n            dp1[i] = min(dp1[i], dp1[i - a] + 1);\n        }\n        if (a % 2 == 0)\n            continue;\n        for (int i = a; i < MAX; i++)\n        {\n            dp2[i] = min(dp2[i], dp2[i - a] + 1);\n        }\n    }\n\n    while (1)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n            break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nint tetra(int n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nvoid solve(int n)\n{\n  for(int i = 1; tetra(i) <= n; i++){\n    if(tetra(i) & 1)\n      dp2[tetra(i)] = 1;\n    dp[tetra(i)] = 1;\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(dp[j] == i){\n        for(int k = 1; j + tetra(k) <= n; k++){\n          dp[j + tetra(k)] = min(i + 1, dp[j + tetra(k)]);\n        }\n      }\n    }\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(dp2[j] == i){\n        for(int k = 1; j + tetra(k) <= n; k++){\n          if(tetra(k) & 1)\n            dp2[j + tetra(k)] = min(i + 1, dp2[j + tetra(k)]);\n        }\n      }\n    }\n  }\n}\n\n\n    \nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<climits>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n#define\tpf\tpush_front\n\nusing namespace std;\n\ntypedef\tvector<int>\t\tvi;\ntypedef\tpair<int,int>\tpii;\n\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main()\n{\n\tint t[181];\n\tfor(int i=1;i<=180;i++)\tt[i]=i*(i+1)*(i+2)/6;\t// T_181==1004731\n\n\tstatic int memo[1000000],memo_odd[1000000];\n\tmemo[0]=memo_odd[0]=0;\n\tfor(int i=1;i<1000000;i++)\tmemo[i]=memo_odd[i]=200;\n\tfor(int i=1;i<1000000;i++){\n\t\tfor(int j=1;j<=180;j++){\n\t\t\tif(t[j]>i)\tbreak;\n\t\t\tmemo[i]=min(memo[i],memo[i-t[j]]+1);\n\n\t\t\tif((j-1)%4==0)\n\t\t\t\tmemo_odd[i]=min(memo_odd[i],memo_odd[i-t[j]]+1);\n\t\t}\n\t}\n\n\tfor(int n;cin>>n,n;)\tcout<<memo[n]<<' '<<memo_odd[n]<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef vector<int> VI;\n \ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\nconst int mod=1e9+7;\n\n\nint main(){\n    int C=1e6;\n    vector<int> p;\n    while(true){\n        int x;cin>>x;\n        if(!x)break;\n        p.push_back(x);\n    }\n    int n=p.size();\n    vector<int> bnum;\n    for(int i=1;;++i){\n        int x=i*(i+1)*(i+2)/6;\n        if(x>=C)break;\n        bnum.push_back(x);\n    }\n    int m=bnum.size();\n    int dp[C+1];rep(i,C+1)dp[i]=mod;\n    dp[0]=0;\n    rep(i,C){\n        rep(j,m){\n            if(bnum[j]>i+1)break;\n            chmin(dp[i+1],dp[i+1-bnum[j]]+1);\n        }\n    }\n    vector<int> onum;\n    rep(i,m){\n        if(bnum[i]%2)onum.push_back(bnum[i]);\n    }\n    m=onum.size();\n    int odd[C+1];rep(i,C+1)odd[i]=mod;\n    odd[0]=0;\n    rep(i,C){\n        rep(j,m){\n            if(onum[j]>i+1)break;\n            chmin(odd[i+1],odd[i+1-onum[j]]+1);\n        }\n    }\n    rep(i,n){\n        cout<<dp[p[i]]<<\" \"<<odd[p[i]]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n \nint dp[1000010];\nint dp2[1000010];\n\nint main(){\n\tint a = 1, b;\n\tvi v;\n\tvi u;\n\twhile((b = a*(a+1)*(a+2)/6)<1e6){\n\t\tv.pb(b);\n\t\tif(b%2 == 1){\n\t\t\tu.pb(b);\n\t\t}\n\t\ta++;\n\t}\n\t//cout<<v.size()<<endl;\n\tfor(int i = 0; i < 1000010; i++){\n\t\tdp[i] = INF;\n\t\tdp2[i] = INF;\n\t}\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tfor(int j = v[i]; j < 1000010; j++){\n\t\t\tdp[j] = min(dp[j], dp[j-v[i]]+1);\n\t\t\tif(j < u.size()){\n\t\t\t\tdp2[j] = min(dp2[j], dp2[j-v[i]]+1);\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<\"OK\"<<endl;\n\tint n;\n\twhile(cin>>n && n > 0){\n\t\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[100001]={0,1,2,3},d[100001],k=0,i,j,n;\n\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=1;i<70;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 10000\n#define INFINITY 2000000000\nusing namespace std;\nint dp[N][N],data[N];\nvector<int> data2;\nint DP(int);\nint DP2(int);\nint main(){\n  int i,out,out2,n;\n  data2.push_back(0);\n  for(i=1;i<N;i++){\n    data[i]=i*(i+1)*(i+2)/6;\n    if(data[i]%2==1){\n      data2.push_back(data[i]);\n    }\n  }\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    out=DP(n);\n    out2=DP2(n);\n    cout << out << ' ' << out2 << endl;\n  }\n  return 0;\n}\nint DP(int n){\n  int i,j,minret,s;\n  for(i=1;i<N;i++){\n    if(data[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}\nint DP2(int n){\n  int i,j,minret,s,len;\n  len=data2.size();\n  for(i=1;i<len;i++){\n    if(data2[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data2[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data2[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 181\n#define MAX_N 1100000\n#define INF 1e9\nint arr[MAX];\nint dp1[MAX_N], dp2[MAX_N];\n \nvoid make(){\n    vector<int> odd;\n    for(int i = 1 ; i < MAX ; i++){\n\tarr[i] = i*(i+1)*(i+2)/6;\n\tif(arr[i] % 2) odd.push_back(arr[i]);\n    }\n \n    for(int i = 0 ; i < MAX_N ; i++){\n\tdp1[i] = dp2[i] = INF;\n    }\n    dp1[0] = dp2[0] = 0;\n    for(int i = 0 ; i < MAX ; i++){\n\tfor(int j = 0 ; j < MAX_N ; j++){\n\t    if(j + arr[i] >= MAX_N) continue;\n\t    dp1[j+arr[i]] = min(dp1[j+arr[i]], dp1[j]+1);\n\t}\n    }\n \n    for(int i = 0 ; i < odd.size() ; i++){\n\tfor(int j = 0 ; j < MAX_N ; j++){\n\t    if(j + odd[i] >= MAX_N) continue;\n\t    dp2[j+odd[i]] = min(dp2[j+odd[i]], dp2[j]+1);\n\t}\n    }\n}\n \nint main(){\n    int n;\n    make();\n    while(cin >> n ,n){\n\tcout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    int ans_tmp=0;\n    int ans2_tmp=0;\n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<=x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n    \n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  ans2_tmp=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  dp2[i+coin_ki[j]]=ans2_tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n    for(int i=0;i<count;i++)\n      printf(\"coin[%d]=%d\\n\",i,coin[i]);\n    for(int i=0;i<count_ki;i++)\n      printf(\"coin_ki[%d]=%d\\n\",i,coin_ki[i]);\n\n\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\n#define MIN(X,Y) ((X)<(Y) ? (X) : (Y))\n\nshort tbl[2000000], otbl[2000000];\n\nint main(void) {\n    memset(tbl,0x7F, sizeof(tbl));\n    memset(otbl,0x7F, sizeof(otbl));\n\n    for(int i=1; i*(i+1)*(i+2)/6<1050000; i++)\n        tbl[i*(i+1)*(i+2)/6] = 1;\n    for(int i=1; i<1005000; i++)\n        for(int j=1; i-j*(j+1)*(j+2)/6>=0; j++)\n            tbl[i] = MIN(tbl[i], 1+tbl[i-j*(j+1)*(j+2)/6]);\n\n    for(int i=1; i*(i+1)*(i+2)/6<1050000; i+=4)\n        otbl[i*(i+1)*(i+2)/6] = 1;\n    for(int i=1; i<1005000; i++)\n        for(int j=1; i-j*(j+1)*(j+2)/6>=0; j+=4)\n            otbl[i] = MIN(otbl[i], 1+otbl[i-j*(j+1)*(j+2)/6]);\n\n    while(1) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n        printf(\"%d %d\\n\",tbl[n],otbl[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n\n#include<iostream>\n#include<fstream>\n\n#define Max_Len 1000000\n\nusing namespace std;\n\nint triCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (num / 5 < triNum){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > triCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = triCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint oddCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\n\tcout << num << \"\\t\" << triangle[num] << endl;\n\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\twhile ((i * (i + 1) * (i + 2) / 6 )% 2 == 0)i--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (i > 0){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > oddCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = oddCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\twhile ((i * (i + 1) * (i + 2) / 6) % 2 == 0)i--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint main(){\n\n\tifstream fin;\n\n\tfin.open(\"input.txt\");\n\n\tint n;\n\n\twhile (true){\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tcout << triCalc(n) << \" \" << oddCalc(n) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nusing namespace std;\n\nconst int MAX_N = 1e6 + 10;\nconst int INF = 1e9;\nint dp1[MAX_N];\nint dp2[MAX_N];\n\nint main() {\n  vector<int> x, y;\n  REP(i, 1, 201) {\n    int z = i * (i+1) * (i+2) / 6;\n    x.push_back(z);\n    if(z&1) y.push_back(z);\n  }\n  \n  rep(i, MAX_N) dp1[i] = dp2[i] = INF;\n  dp1[0] = 0;\n  dp2[0] = 0;\n  for(const auto& a : x) {\n    for(int i = 0; i + a < MAX_N; ++i) {\n      dp1[i+a] = min(dp1[i+a], dp1[i]+1); \n    }\n  }\n  for(const auto& a : y) {\n    for(int i = 0; i + a < MAX_N; ++i) {\n      dp2[i+a] = min(dp2[i+a], dp2[i]+1); \n    }\n  }\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[60]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<190;i++){a[k++]=i*(i+1)*(i+2)/6;}\n  for(j=k=0;j<i;j++){if(a[j]%2)b[k++]=a[j];}\n  for(i=1;i<189;i++){for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;}\n  for(i=0;i<36;i++){d[i]=i;}\n  for(i=1;i<k-1;i++){for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;}\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n\nusing namespace std;\n\nlong long inf=1000000007;\n\nlong long modpow(long long n,long long p,long long mod);\n\nint main(){\n\tlong long mo=modpow(10,6,inf);\n\tvector<long long> simen,kisu;\n\tlong long hoge=1;\n\twhile(hoge*(hoge+1)*(hoge+2)/6<=mo){\n\t\tsimen.push_back(hoge*(hoge+1)*(hoge+2)/6);\n\t\tif(hoge*(hoge+1)*(hoge+2)/6%2==1) kisu.push_back(hoge*(hoge+1)*(hoge+2)/6);\n\t\thoge++;\n\t}\n\n\tvector<long long> dp(mo+1,inf),kdp=dp;\n\tdp.at(0)=0;\n\tkdp.at(0)=0;\n\n\tfor(long long i=0;i<=mo;i++){\n\t\tfor(auto a:simen){\n\t\t\tif(i+a<=mo){\n\t\t\t\tdp.at(i+a)=min(dp.at(i+a),dp.at(i)+1);\n\t\t\t}\n\t\t}\n\t\tfor(auto a:kisu){\n\t\t\tif(i+a<=mo){\n\t\t\t\tkdp.at(i+a)=min(kdp.at(i+a),kdp.at(i)+1);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong long n;\n\tcin>>n;\n\twhile(n>0){\n\t\tcout<<dp.at(n)<<\" \"<<kdp.at(n)<<endl;\n\t\tcin>>n;\n\t}\n\n\treturn 0;\n}\n\nlong long modpow(long long n,long long p,long long mod){\n\tif(p==0) return 1;\n\tif(p%2==0) return (modpow(n,p/2,mod)*modpow(n,p/2,mod))%mod;\n\tif(p%2==1) return (modpow(n,p-1,mod)*n)%mod;\n\tcerr<<\"ERROR\"<<endl;\n\treturn 1;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nint p[1000001];\nint memo[1000001];\nint memo2[1000001];\n\nint solve(int n, int count){\n  \n  if(!n) return 0;\n  if(n <= 0 || !count) return INF;\n  if(memo[n]) return memo[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n; i++) ans = min(ans, solve(n-p[i], count-1)+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n;i++){\n    if(!(p[i]%2)) continue;\n    ans = min(ans, solve2(n-p[i])+1);\n  }\n  \n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  for(int i=0;i<=1000000;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i+=100000) solve(i, 5), solve2(i);\n  \n  while(cin >> n, n) cout << solve(n, 5) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n  \nusing namespace std;\n\n#define pi 3.141592653589793\n\nint main()\n{\n\tint result[1000001] = {};\n\tint odd_result[1000001] = {};\n\tfill(result, result + 1000000, 1000000);\n\tfill(odd_result, odd_result + 1000000, 1000000);\n\tint trangular_sum = 0, tetrahedral_sum = 0;\n\tresult[0] = 0;\n\todd_result[0] = 0;\n\tfor(int i = 1; tetrahedral_sum < 1000000; i++){\n\t\ttrangular_sum += i;\n\t\ttetrahedral_sum += trangular_sum;\n\t\t// result[trangular_sum] = 1;\n\t\tresult[tetrahedral_sum] = 1;\n\t\tif(tetrahedral_sum % 2 == 1) odd_result[tetrahedral_sum] = 1;\n\t}\n\tfor(int i = 1; i < 1000000; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tresult[i] = min(result[i], result[i - j] + result[j]);\n\t\t\tif(j % 2 == 1) odd_result[i] = min(odd_result[i], odd_result[i - j] + odd_result[j]);\n\t\t}\n\t\t// cout << i  << \" \" << result[i] << \" \" << odd_result[i] << endl;\n\t}\n\tint n;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << result[n] << \" \" odd_result[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\nusing namespace std;\nusing ll=long long;\nusing ull=unsigned long long;\nusing pii=pair<int,int>;\n\n#define INF LONG_MAX\n#define MOD 1000000007\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.end(),a.begin()\n#define endl \"\\n\"\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  vector<ll>dp1(1000001,INT_MAX);\n  vector<ll>dp2(1000001,INT_MAX);\n  dp1[0]=0;\n  dp2[0]=0;\n  for(int i=1;i<=1000;i++){\n    ll w=i*(i+1)*(i+2)/6;\n    if(w>1000000)break;\n    for(int j=0;j<=1000000;j++){\n      if(j-w>=0)dp1[j]=min(dp1[j],dp1[j-w]+1);\n      if(j-w>=0&&w%2)dp2[j]=min(dp2[j],dp2[j-w]+1);\n    }\n  }\n  int x;\n  while(cin>>x){\n    if(x==0)break;\n    cout<<dp1[x]<<\" \"<<dp2[x]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n#if __cplusplus >= 201103L\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#endif\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int,int> Pint;\n//typedef pair<ll, ll> P;\n//typedef pair<ll, pair<ll, ll>> P;\n//typedef tuple<int,int,int> T;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < n; i++)\n#define revrep(i, n) for(ll i = n-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\nll INFL = 1LL << 60;//10^18 = 2^60\nint INF = 1 << 30;//10^9\nll MOD = 1e9 + 7;\n//ll MOD  = 998244353;\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\nll lcm(ll x, ll y){return x / gcd(x, y) * y % MOD;};\n\nint main(){\n  vector<int> dp(1000010, INF), odddp(1000010, INF);\n  dp[0] = 0, odddp[0] = 0;\n  for(int i = 1;; i++){\n    int num = i * (i+1) * (i+2) / 6;\n    if(num > 1000010) break;\n    for(int j = num; j < 1000010; j++){\n      dp[j] = min(dp[j], dp[j-num] + 1);\n      if(num % 2) odddp[j] = min(odddp[j], odddp[j-num] + 1);\n    }\n  }\n  while(true){\n    int n; cin >> n;\n    if(n == 0) break;\n    cout << dp[n] << \" \" << odddp[n] << endl;\n  }\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS 1e-9\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\ntemplate<typename T>\nusing v = vector<T>;\n\nint main() {\n\tvi num(180);\n\trep(i, 180) {\n\t\tnum[i] = (i + 1)*(i + 2)*(i + 3) / 6;\n\t}\n\tint N = 1000001;\n\tvi ans1(N), ans2(N);\n\trep(i, N) {\n\t\tans1[i] = ans2[i] = i;\n\t}\n\t\n\trepl(i, 1, 180) {\n\t\trepl(j, num[i], N) {\n\t\t\tans1[j] = min(ans1[j], ans1[j - num[i]] + 1);\n\t\t}\n\t}\n\trepl(i, 1, 180 / 4) {\n\t\trepl(j, num[4 * i], N) {\n\t\t\tans2[j] = min(ans2[j], ans2[j - num[4 * i]] + 1);\n\t\t}\n\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tcout << ans1[n] << \" \" << ans2[n] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector < vector<bool> >dp(6, vector < bool>(100001, 0));\n\tdp[0][0] = 1;\n\tREP(i, 5) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool>> dp2(1001, vector<bool>(100001, 0));\n\tREP(i, 1000) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k % 2 == 0)continue;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp2[i][l])dp2[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tREP(i, 5) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \" \";\n\t\tREP(i, 1000) {\n\t\t\tif (dp2[i + 1][n]) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\n#define INF (1<<29)\n\nusing namespace std;\n\nint eo[1000000];\nint o[1000000];\n\nint eoc,oc;\n\nint p(int x){\n  return x*(x+1)*(x+2)/6;\n}\n\nint main(){\n  fill_n(eo,1000000,INF);\n  fill_n(o,1000000,INF);\n  eo[0]=0;\n  o[0]=0;\n  vector<int> eop,op;\n  for(int i=1;p(i)<1000000;i++){\n    eop.push_back(p(i));\n    if(p(i)%2){\n      op.push_back(p(i));\n    }\n  }\n  for(int n;cin>>n,n;){\n    while(eo[n]==INF){\n      for(int i=0;i<1000000;i++){\n\tif(eo[i]==eoc){\n\t  for(int j=0;j<eop.size()&&i+eop[j]<1000000;j++){\n\t    eo[i+eop[j]]=min(eo[i]+1,eo[i+eop[j]]);\n\t  }\n\t}\n      }\n      eoc++;\n    }\n    cout<<eo[n]<<' '<<flush;\n    while(o[n]==INF){\n      for(int i=0;i<1000000;i++){\n\tif(o[i]==oc){\n\t  for(int j=0;j<op.size()&&i+op[j]<1000000;j++){\n\t    o[i+op[j]]=min(o[i]+1,o[i+op[j]]);\n\t  }\n\t}\n      }\n      oc++;\n    }\n    cout<<o[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint i,j,n,three[1000000],four[1000000],four_2[1000000],c[1000000],c_2[1000000];\n\nint main(){\n  \n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  for( i = 0; i < 1000000; i++ ){\n    c[i] = 2000000;\n    c_2[i] = 2000000;\n  }\n\n  c[0] = 0;\n  for( i = 0; i < 1000; i++ ){\n    for( j = four[i]; j <= 1000000; j++ ){\n      c[j] = min( c[j],c[j-four[i]] + 1 );\n    }\n  }\n\n  c_2[0] = 0;\n  for( i = 0; i < 1000; i++ ){\n    for ( j = four_2[i]; j <= 1000000; j++ ){\n      c_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n   \n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint inf = 1000000000;\n\nint d[MAX_N+1], d2[MAX_N+1]; // ?????????j??¨?????????????????????????°??????°\n\nint calc_sn(int n){\n\treturn n*(n+1)*(n+2)/6;\n}\n\nint main() {\n\td[0] = 0;\n    for(int i = 1; i <= MAX_N; i++){\n    \td[i] = inf;\n       \tfor (int j = 1; ; j++)\n        {\n        \tif(i < calc_sn(j)) break;\n            d[i] = min(d[i], d[i-calc_sn(j)]+1);\n        }\n    }\n    d2[0] = 0;\n    for(int i = 1; i <= MAX_N; i++){\n    \td2[i] = inf;\n       \tfor (int j = 1; ; j++)\n        {\n        \tif(i < calc_sn(j)) break;\n        \tif(calc_sn(j) % 2 == 0) continue;\n            d2[i] = min(d2[i], d2[i-calc_sn(j)]+1);\n        }\n    }\n    while(1){\n    \tcin >> N;\n    \tif(N == 0) break;\n    \tcout << d[N] << \" \" << d2[N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Pollock's conjecture\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp \n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int MAX = 1000010;\nint N;\n\nvector<int> dp;\nvector<int> odd_dp;\n\nint t(int n) { return n*(n+1)*(n+2) / 6; }\n\nint main() { \n    while (cin >>  N) {\n        if (N == 0) break;\n        dp.assign(MAX, 0);\n        odd_dp.assign(MAX, 0);\n        dp[0] = 0;\n        odd_dp[0] = 0;\n        for (int n = 1; n <= N; ++n) {\n            dp[n] = n;\n            odd_dp[n] = n;\n            for (int k = 1; t(k) <= n; ++k) {\n                dp[n] = min(dp[n - t(k)] + 1, dp[n]); \n                if (t(k) % 2) {\n                    odd_dp[n] = min(odd_dp[n - t(k)] + 1, odd_dp[n]); \n                }\n            }\n        }\n        cout << dp[N] << \" \" << odd_dp[N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\n#define rep(X,Y) for(int (X) = 0; (X) < (Y) ; ++(X))\n#define all(X) (X).begin,(X).end\n#define reps(i,j,k) for(inti=(j); i <= (k); ++(i))\n#define sz size()\n#define in(i,j,k) ((i) >= (j) && (i) <= (k))\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint d[2000000];\nint dd[2000000];\n\nint main(){\n    \n    vector<int> t;\n    vector<int> k;\n    int i = 0;\n    rep(i, 2000000)d[i]=dd[i]=1000000000;\n    while((i*(i+1)*(i+2))/6 <= 1000000){\n        ++i;\n        t.pb(i*(i+1)*(i+2)/6);\n        if((i*(i+1)*(i+2)/6)%2) k.pb(i*(i+1)*(i+2)/6);\n    }\n\n    d[0] = dd[0] = 0;\n\n    rep(i, 1000000){\n        rep(j, t.sz){\n            int tmp = i+t[j];\n            if(tmp < 1000001)d[tmp] = min(d[tmp], d[i]+1);\n        }\n        rep(j, k.sz){\n            int tmp = i+k[j];\n            if(tmp < 1000001)dd[tmp] = min(dd[tmp], dd[i]+1);\n        }\n    }\n    int n;\n\n    while(scanf(\"%d\", &n), n){\n        printf(\"%d %d\\n\", d[n], dd[n]);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint dp1[1111111];\nint dp2[1111111];\n\nint main() {\n  vector<int> v1, v2;\n\n  for (int i = 1; i*(i+1)*(i+2)/6 <= 1000006; i++) {\n    int a = i*(i+1)*(i+2)/6;\n    v1.push_back(a); \n    if (a & 1) { v2.push_back(a); }\n  }\n  rep(i, 1000006) {\n    dp1[i] = int(1e8);\n    dp2[i] = int(1e8);\n  }\n  dp1[0] = 0;\n  dp2[0] = 0;\n  // dp[x] := xを構成するために必要な正四面体数の個数の最小値\n  //\n  rep(i, 1000006) {\n    rep(j, v1.size()) {\n      if (i+v1[j] > 1000006) { continue; }\n      dp1[i+v1[j]] = min(dp1[i]+1, dp1[i+v1[j]]);\n    }\n    rep(j, v2.size()) {\n      if (i+v2[j] > 1000006) { continue; }\n      dp2[i+v2[j]] = min(dp2[i]+1, dp2[i+v2[j]]);\n    }\n  }\n \n  int in;\n  while (cin >> in) {\n    if (in == 0) { break; }\n    cout << dp1[in] << \" \" << dp2[in] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\nint *all, *odd;\n\nint main()\n{\n\tint n, t[100];\n\tint counter = 0;\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tt[counter++] = n;\n\tint maxnum = 0;\n\n\t//入力値の最大を取得\n\tfor (int i = 0; i < counter; i++)\n\t\tmaxnum = max(maxnum, t[i]);\n\n\tall = new int[maxnum+1];\n\todd = new int[maxnum+1];\n\n\n\t//1からmaxnumまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four>maxnum)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からmaxnumまで，配列を埋める.\n\tfor (int i = 1; i <= maxnum; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//出力\n\tfor (int i = 0; i < counter; i++)\n\t\tcout << all[t[i]] << \" \" << odd[t[i]] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,n,m) for(ll i=n; i>(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vector<ll> v(1e6,10);\n  vector<ll> seisi;\n  ll a=0;\n  seisi.push_back(a);\n  a++;\n  while(a<200){\n    seisi.push_back(a+seisi[a-1]);\n    a++;\n  }\n  FOR(i,1,seisi.size()){\n    seisi[i]+=seisi[i-1];\n  }\n  //coutv(seisi,0,100);\n  vector<ll> dp1(1e6,10);\n  vector<ll> dp2(1e6,1e6);\n  dp1[0]=0;\n  dp2[0]=0;\n  dp2[1]=1;\n  FOR(i,1,seisi.size()){\n    FOR(j,seisi[i],1e6){\n      dp1[j]=min(dp1[j-seisi[i]]+1,dp1[j]);\n      if(seisi[i]%2==1)dp2[j]=min(dp2[j],dp2[j-seisi[i]]+1);\n    }\n  }\n  while(true){\n    ll n;\n    cin>>n;\n    if(n==0)break;\n    cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\n\nvector<ll> table, table2;\n\nll dp[2][2][1001000];\n\nint main() {\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= 1000000; i++) {\n\t\ttable.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif ((i*(i + 1)*(i + 2) / 6) % 2 == 1)table2.push_back(i*(i + 1)*(i + 2) / 6);\n\t}\n\t//cout << table.size() << endl;\n\tREP(i, 2) {\n\t\tREP(j, 2) {\n\t\t\tREP(k, 1001000)dp[i][j][k] = INF;\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tdp[1][0][0] = 0;\n\n\tREP(i, table.size()) {\n\t\tint num = table[i];\n\t\tREP(j, 1000000) {\n\t\t\tif (j - num >= 0) {\n\t\t\t\tdp[0][(i + 1) % 2][j] = min(dp[0][(i + 1) % 2][j - num] + 1, dp[0][i % 2][j]);\n\t\t\t}\n\t\t\telse dp[0][(i + 1) % 2][j] = dp[0][i % 2][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < table2.size(); i++) {\n\t\tint num = table2[i];\n\t\t//cout << num << endl;\n\t\tREP(j, 1000000) {\n\t\t\tif (j - num >= 0) {\n\t\t\t\tdp[1][(i + 1) % 2][j] = min(dp[1][(i + 1) % 2][j - num] + 1, dp[1][i % 2][j]);\n\t\t\t}\n\t\t\telse dp[1][(i + 1) % 2][j] = dp[1][i % 2][j];\n\t\t}\n\t}\n\t\n\twhile (cin >> n&&n) {\n\t\tcout << dp[0][table.size() % 2][n] << \" \"\n\t\t\t<< dp[1][table2.size() % 2][n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstatic const int INFTY = (1 << 29);\n\nint main()\n{\n    vector<int> v;\n    int i = 1;\n    int sum = i*(i+1)*(i+2) / 6;\n    v.push_back(0);\n    while(sum <= 10000000) {\n        v.push_back(sum);\n        i++;\n        sum = i*(i+1)*(i+2) / 6;\n    }\n\n    int N, m, resa, resb;\n\n    for(; ;) {\n        scanf(\"%d\", &N);\n        if (N == 0) break;\n        resa = resb = INFTY;\n        m = upper_bound(v.begin(), v.end(), N)-v.begin()-1;\n        if (v[m] == N) resa = 1;\n        if (v[m] == N && v[m] % 2 != 0) resb = 1;\n\n        int T[N+1];\n        if (resa == INFTY) {\n            for(i = 0; i <= N; i++) T[i] = INFTY;\n            T[0] = 0;\n            for (i = 1; i <= m; i++) {\n                for (int j = 0; j + v[i] <= N; j++) {\n                    T[j+v[i]] = min(T[j+v[i]], T[j]+1);\n                }\n            }\n            resa = T[N];\n        }\n        if (resb == INFTY) {\n            for(i = 0; i <= N; i++) T[i] = INFTY;\n            T[0] = 0;\n\n            for (i = 1; i <= m; i++) {\n                if (v[i] % 2 == 0) continue;\n                for (int j = 0; j + v[i] <= N; j++) {\n                    T[j+v[i]] = min(T[j+v[i]], T[j]+1);\n                }\n            }\n            resb = T[N];\n        }\n        printf(\"%d %d\\n\", resa, resb);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\n\nint main() {\n    int table1[100000];\n    int max1;\n    for (int i = 1; i < 100000; i++) {\n        table1[i] = i * (i + 1) * (i + 2) / 6;\n        if (table1[i] >= 1000000) {\n            max1 = i - 1;\n            break;\n        }\n    }\n    int table2[100000];\n    int max2;\n    for (int i = 1; i < 100000; i++) {\n        int n = i;\n        do {\n            table2[i] = n * (n + 1) * (n + 2) / 6;\n            n++;\n        } while (table2[i] % 2 == 0);\n        if (table2[i] >= 1000000) {\n            max2 = i - 1;\n            break;\n        }\n    }\n\n    int m;\n    while (cin >> m, m) {\n        bool used[1000000];\n        fill_n((bool *)used, 1000000, false);\n        priority_queue<ppiii, vector<ppiii>, greater<ppiii>> q;\n        q.push({{0, 0}, 1});\n        while (!q.empty()) {\n            ppiii p = q.top(); q.pop();\n            int count = p.first.first;\n            int total = p.first.second;\n            int now = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << \" \";\n                break;\n            }\n\n            for (int i = now; i < max1; i++) {\n                int sum = table1[i] + total;\n                if (sum <= m && !used[sum]) {\n                    q.push({{count+1, sum}, i});\n                    used[sum] = true;\n                }\n            }\n        }\n        while(!q.empty())\n            q.pop();\n        fill_n((bool *)used, 1000000, false);\n        q.push({{0, 0}, 1});\n        while (!q.empty()) {\n            ppiii p = q.top(); q.pop();\n            int count = p.first.first;\n            int total = p.first.second;\n            int now = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << endl;\n                break;\n            }\n\n            for (int i = now; i < max2; i++) {\n                int sum = table2[i] + total;\n                if (sum <= m && !used[sum]) {\n                    q.push({{count+1, sum}, i});\n                    used[sum] = true;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INF 1<<28\nusing namespace std;\n \nint p[1111111];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=199;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=0;p[i]<=n;i++) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<200;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX 1000000\nusing namespace std;\nint ans1[MAX+10],ans2[MAX+10],box[200];\nvoid tab_make(){\n\tfor(int i=1;i*(i+1)*(i+2)/6<=MAX;i++)\n\t\tbox[i]=(i*(i+1)*(i+2)/6);\n}\nvoid ans_make(){\n\tans1[0]=ans2[0]=0;\n\tfor(int i=1;i<=MAX;i++){\n\t\tans1[i]=ans2[i]=i;\n\t\tfor(int j=1;i-box[j]>=0;j++){\n\t\t\tans1[i]=min(ans1[i],ans1[i-box[j]]+1);\n\t\t\tif(box[j]%2==1)\n\t\t\tans2[i]=min(ans2[i],ans2[i-box[j]]+1);\n\t\t}\n\t}\n}\nint main(){\n\tint x;\n\ttab_make();\n\tans_make();\n\twhile(cin>>x,x){\n\t\tcout<<ans1[x]<<' '<<ans2[x]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(a) a.begin(),a.end()\n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    vector<int> dp(1000001,0);\n    vector<int> dp2(1000001,0);\n    iota(all(dp),0);\n    iota(all(dp2),0);\n    for(int i=2;(i*(i+1)*(i+2)/6)<=1000000;i++){\n        int po=(i*(i+1)*(i+2)/6);\n        for(int j=0;j+po<=1000000;j++){\n            dp[j+po]=min(dp[j+po], dp[j]+1);\n        }\n        if(po%2==0)continue;\n        for(int j=0;j+po<=1000000;j++){\n            dp2[j+po]=min(dp2[j+po], dp2[j]+1);\n        }\n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ACM-ICPCà\\I2010 C. |bN\\z\n\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\tint tri[200];\n\tstatic int ansA[1000000], ansB[1000000];\n\tfor(int i=0;i<200;i++) tri[i] = i*(i+1)*(i+2)/6;\n\tansA[0] = ansB[0] = 0;\n\tfor(int i=1;i<1000000;i++){\n\t\tansA[i] = ansB[i] = i;\n\t\tfor(int j=0;i-tri[j]>=0;j++){\n\t\t\tansA[i] = min(ansA[i], ansA[i-tri[j]]+1);\n\t\t\tif(tri[j]%2==1)\n\t\t\t\tansB[i] = min(ansB[i], ansB[i-tri[j]]+1);\n\t\t}\n\t}\n\twhile(cin >> N, N)\n\t\tcout << ansA[N] << \" \" << ansB[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int MAX_N = 1000000, Inf = 1<<28;\nint dp[2][MAX_N];\n\nint main() {\n  rep(i,MAX_N) rep(j,2) dp[j][i] = Inf;\n  dp[0][0] = dp[1][0] = 0;\n\n  for (int i = 1; i*(i+1)*(i+2)/6 < MAX_N; ++i) {\n    const int v = i*(i+1)*(i+2)/6;\n    for (int j = 1; j < MAX_N; ++j) {\n      if (j-v < 0) continue;\n      dp[0][j] = min(dp[0][j], dp[0][j-v]+1);\n      if (v%2)\n        dp[1][j] = min(dp[1][j], dp[1][j-v]+1);\n    }\n  }\n\n  int in;\n  while (scanf(\"%d\",&in),in) {\n    printf(\"%d %d\\n\",dp[0][in], dp[1][in]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\t\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nDef inf = sizeof(Def) == sizeof(ll) ? 2e18 : 1e9+10;\nint main(){\n\tvi w;\n\tloop(i,1,200)if(i*(i+1)*(i+2)/6<1000100)w.pb(i*(i+1)*(i+2)/6);\n\tconst int n=1000100;\n\tvi dp(n+1,inf),dp2(n+1,inf);\n\tdp[0]=dp2[0]=0;\n\trep(i,w.size())rep(j,n){\n\t\tint t=j+w[i];\n\t\tif(t<n+1)dp[t]=min(dp[t],dp[j]+1);\n\t\tif(t<n+1&&w[i]%2)dp2[t]=min(dp2[t],dp2[j]+1);\n\t}\n\tint m;\n\twhile(cin>>m,m){\n\t\tcout<<dp[m]<<\" \"<<dp2[m]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 1e9\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int dp[1000010]={};\n  int dp2[1000010]={};\n  for(int i=1;i<=1000000;i++){dp[i]=INF;dp2[i]=INF;}\n  vector<ll> gu;\n  vector<ll> ki;\n  ll cnt=1;\n  while(1){\n    if((cnt*(cnt+1)*(cnt+2)/6)>1000000)break;\n    if(((cnt*(cnt+1)*(cnt+2))/6)%2){ki.pb(cnt*(cnt+1)*(cnt+2)/6);dp[ki[ki.size()-1]]=1;dp2[gu[gu.size()-1]]=1;}\n    else {gu.pb(cnt*(cnt+1)*(cnt+2)/6);dp[gu[gu.size()-1]]=1;}\n    cnt++;\n  }\n  dp[1]=1;\n  dp2[1]=1;\n  for(int i=1;i<1000000;i++){\n    for(int j=0;j<gu.size();j++){\n      if(i+gu[j]>1000000)break;\n      dp[i+gu[j]]=min(dp[i+gu[j]],(dp[i]+1));\n    }\n    for(int j=0;j<ki.size();j++){\n      if(i+ki[j]>1000000)break;\n      dp[i+ki[j]]=min(dp[i+ki[j]],(dp[i]+1));\n      dp2[i+ki[j]]=min(dp2[i+ki[j]],(dp2[i]+1));\n    }\n  }\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1500001]={0,1,2,3},d[1500001],k=0,i,j,n,p;\n  for(i=1;a[i-1]<1000000;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0,p=i;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<p;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint p[200],q[100];\n\nint f(int n,int m,int c){\n\tif(c==4&&n>0)return 5;\n\tif(n<10)return min(c+n/4+n%4,5);\n\tint rec=5,i=0;\n\twhile(p[i]<n/(4-c))i++;\n\tfor(i;p[i]<=m;i++)rec=min(rec,f(n-p[i],min(p[i],n-p[i]),c+1));\n\treturn rec;\n}\n\nint g(int n,int m,int c){\n\tif(n<165)return c+n/35+n%35;\n\tint rec=99999;\n\tfor(int i=1;q[i]<=m;i++)rec=min(rec,f(n-q[i],min(q[i],n-q[i]),c+1));\n\treturn rec;\n}\n\nint main(){\n\tfor(int i=0;(i+1)*(i+2)*(i+3)/6<=1000000;i++)p[i]=(i+1)*(i+2)*(i+3)/6;\n\tfor(int i=0;(4*i+1)*(4*i+2)*(4*i+3)/6<=1000000;i++)q[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\tint N;\n\twhile(cin>>N){\n\t\tif(!N)return 0;\n\t\tcout<<f(N,N,0)<<\" \"<<g(N,N,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 155. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n;\n    if (n % 2 == 0) {\n        return mypow(sq(b), n / 2);\n    } else {\n        return mypow(b, n - 1) * b;\n    }\n}\n\n/* --------------------\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n % MOD;\n    if (n % 2 == 0) {\n        return mypow(sq(b) % MOD, n / 2);\n    } else {\n        return mypow(b, n - 1) * b % MOD;\n    }\n}\n-------------------- */\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\nV<V<ll>> nums(2);\nconst ll MAX = 1000000;\nV<V<ll>> dp(2, V<ll>(MAX + 10, MAX + 10));\n\n/* ------------- Functions -------------- */\n\nvoid precalc() {\n    FOR(i, 1, 1000) {\n        ll pro = i * (i + 1) * (i + 2) / 6;\n        nums[0].pb(pro);\n        if (pro % 2) {\n            nums[1].pb(pro);\n        }\n\n        if (pro > MAX) break;\n    }\n\n    return;\n}\n\nll dfs(ll k, ll N) {\n    if (N == 0) {\n        return 0;\n    }\n\n    if (dp[k][N] < MAX + 10) {\n        return dp[k][N];\n    }\n\n    FOR(i, 0, 1000) {\n        if (N >= nums[k][i]) {\n            dp[k][N] = min(dp[k][N], dfs(k, N - nums[k][i]) + 1);\n        } else {\n            break;\n        }\n    }\n\n    return dp[k][N];\n}\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    precalc();\n\n    while (true) {\n        ll N;\n        cin >> N;\n        if (N == 0) break;\n\n        cout << dfs(0, N) << \" \" << dfs(1, N) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @brief  : c++ code for AtCoder\n * @author : rk222\n * @created: 2020.03.09 13:00:06\n */\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// #define int long long\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<int, P> P1;\ntypedef tuple<int, int, int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<tuple<int, int, int>> vt;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i, x) for (int i = 0; i < x; i++)\n#define rep1(i, x) for (int i = 1; i <= x; i++)\n#define srep(i, s, x) for (int i = s; i < x; i++)\n#define rrep(i, x) for (int i = x - 1; i >= 0; i--)\n#define rrep1(i, x) for (int i = x; i > 0; i--)\n#define rsrep(i, s, x) for (int i = x - 1; i >= s; i--)\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\n#define limit(x, l, r) max(l, min(x, r))\n#define lims(x, l, r) (x = max(l, min(x, r)))\n#define sor(v) sort(v.begin(), v.end())\n#define rev(s) reverse(s.begin(), s.end())\n#define lb(vec, a) lower_bound(vec.begin(), vec.end(), a)\n#define ub(vec, a) upper_bound(vec.begin(), vec.end(), a)\n#define uniq(vec) vec.erase(unique(vec.begin(), vec.end()), vec.end())\n#define mp1(a, b, c) P1(a, P(b, c))\n#define dame                                                                                  \\\n    puts(\"-1\");                                                                               \\\n    return 0\n#define yn                                                                                    \\\n    puts(\"Yes\");                                                                              \\\n    else puts(\"No\")\n#define YN                                                                                    \\\n    puts(\"YES\");                                                                              \\\n    else puts(\"NO\")\n\ntemplate <typename A, typename B> string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\nstring to_string(const string &s) {\n    return '\"' + s + '\"';\n}\nstring to_string(const char *s) {\n    return to_string((string)s);\n}\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\nstring to_string(vector<bool> v) {\n    bool first = true;\n    string ret = \"{\";\n    for (int i = 0; i < static_cast<int>(v.size()); i++) {\n        if (!first) {\n            ret += \", \";\n        }\n        first = false;\n        ret += to_string(v[i]);\n    }\n    ret += \"}\";\n    return ret;\n}\ntemplate <size_t N> string to_string(bitset<N> v) {\n    string ret = \"\";\n    for (size_t i = 0; i < N; i++) {\n        ret += static_cast<char>('0' + v[i]);\n    }\n    return ret;\n}\ntemplate <typename A> string to_string(A v) {\n    bool first = true;\n    string ret = \"{\";\n    for (const auto &x : v) {\n        string s = to_string(x);\n        if (!first) {\n            ret += \", \";\n        }\n        if (s[0] == '{') {\n            s = \"\\n\" + s;\n        }\n        first = false;\n        ret += s;\n    }\n    if (ret[ret.size() - 1] == '}') {\n        ret += \"\\n}\";\n    } else {\n        ret += \"}\";\n    }\n    return ret;\n}\ntemplate <typename A, typename... Lest> string to_string(A *v, int n, Lest... L) {\n    bool first = true;\n    string ret = \"{\";\n    rep(i, n) {\n        auto x = v[i];\n        string s = to_string(x, L...);\n        if (!first) {\n            ret += \", \";\n        }\n        if (s[0] == '{') {\n            s = \"\\n\" + s;\n        }\n        first = false;\n        ret += s;\n    }\n    if (ret[ret.size() - 1] == '}') {\n        ret += \"\\n}\";\n    } else {\n        ret += \"}\";\n    }\n    return ret;\n}\ntemplate <typename A, typename B> string to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A, typename B, typename C> string to_string(tuple<A, B, C> p) {\n    return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n           to_string(get<2>(p)) + \")\";\n}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n    return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" +\n           to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\nvoid name_disp(string s) {\n    cerr << \"-------\" << endl;\n    cerr << s << \": \" << endl;\n}\nvoid val_disp() {\n    cerr << endl;\n}\ntemplate <typename First, typename... Lest> void val_disp(First F, Lest... L) {\n    cerr << to_string(F) << endl;\n    val_disp(L...);\n}\ntemplate <typename A, typename... Lest> void val_disp(A *v, Lest... L) {\n    cerr << to_string(v, L...) << endl;\n    val_disp();\n}\n#define disp(...)                                                                             \\\n    name_disp(#__VA_ARGS__);                                                                  \\\n    val_disp(__VA_ARGS__)\n#define adisp(a, ...)                                                                         \\\n    name_disp(#a);                                                                            \\\n    val_disp(a, __VA_ARGS__)\n\n#ifdef int\nconst ll INF = 1002003004005006007ll;\n#else\nconst int INF = 1002003004;\n#endif\n\nconst int M = 100000000;\nconst int dir_4[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\nconst int dir_8[8][2] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\n/* ------------------------------------- */\n\n// dp[i][j]: j番目まででiを表すときに使う正四面体数の最小個数\nint dp[1000010];\nint odddp[1000010];\nint pre[205];\nint oddpre[105];\n\nsigned main() {\n    vi shimen, oddshimen;\n    rep1(i, 200) {\n        int shi = i * (i + 1) * (i + 2) / 6;\n        if (shi & 1)\n            oddshimen.pb(shi);\n        shimen.pb(shi);\n    }\n\n    dp[0] = 0;\n    odddp[0] = 0;\n    rep(j, 200) {\n        pre[j] = INF;\n    }\n    rep(j, 100) {\n        oddpre[j] = INF;\n    }\n\n    rep1(i, 1000005) {\n        rep(j, shimen.size()) {\n\n            if (i - shimen[j] < 0) {\n                dp[i] = pre[j];\n                pre[j + 1] = dp[i];\n            } else {\n                dp[i] = min(dp[i - shimen[j]] + 1, pre[j]);\n                pre[j + 1] = dp[i];\n            }\n        }\n\n        rep(j, oddshimen.size()) {\n            if (i - oddshimen[j] < 0) {\n                odddp[i] = oddpre[j];\n                oddpre[j + 1] = odddp[i];\n            } else {\n                odddp[i] = min(odddp[i - oddshimen[j]] + 1, oddpre[j]);\n                oddpre[j + 1] = odddp[i];\n            }\n        }\n    }\n\n    // disp(dp, x + 1, 10);\n    while (1) {\n        int x;\n        scanf(\"%d\", &x);\n        if (x == 0)\n            break;\n        printf(\"%d %d\\n\", dp[x], odddp[x]);\n    }\n\n    /* --------------------------------- */\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 29;\nconst int LIM = 1000000;\n\nint dp1[LIM], dp2[LIM];\n\nint main(){\n    fill(dp1, dp1 + LIM, INF);\n    fill(dp2, dp2 + LIM, INF);\n    dp1[0] = dp2[0] = 0;\n    for(int i = 1; i * (i + 1) * (i + 2) / 6 < LIM; i++){\n        int num = i * (i + 1) * (i + 2) / 6;\n        for(int j = num; j < LIM; j++){\n            dp1[j] = min(dp1[j], dp1[j-num] + 1);\n        }\n        if(num % 2 == 0) continue;\n        for(int j = num; j < LIM; j++){\n            dp2[j] = min(dp2[j], dp2[j-num] + 1);\n        }\n    }\n    int N;\n    while(true){\n        scanf(\"%d\", &N);\n        if(N == 0) break;\n        printf(\"%d %d\\n\", dp1[N], dp2[N]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvvi dp(6,vi(100001,0));\n\tdp[0][0] = 1;\n\tREP(i, 5) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif ( k> 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvvi dp2(501, vi(100001, 0));\n\tREP(i, 500) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k % 2 == 0)continue;\n\t\t\tif (k> 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp2[i][l])dp2[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tREP(i, 5) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \" \";\n\t\tREP(i, 5) {\n\t\t\tif (dp2[i + 1][n]) {\n\t\t\t\tcout << i+1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* C ????§????: ?????? */\n#include<bits/stdc++.h>\n#define dump(a) cout << (#a) << (a) << endl\nusing namespace std;\n\n#define MAX_SIZE 1000000\n\n//pollok\nint memo_cnt[MAX_SIZE]; //MAX_SIZE??????\nvector<int> all_pks;\nvector<int> kisu_pks;\n\n//P=pk??????, index=pks????????¨?????´???\nint dfs(const int P, const int &now_index, int level, vector<int> &pks)\n{\n\t//dump(level);\n\tif (P == 0) { return level; }\n\tif (memo_cnt[P] != -1) { return memo_cnt[P]; } //?????¢????????\\\n\t\n\tint min_depth = INT_MAX;\n\tfor(int i=now_index; i<pks.size(); i++) { //??§?????????\n\t\tint next_P = P-pks[i];\n\t\tif (next_P >= 0) {\n\t\t\tint depth = dfs(next_P, i, level+1, pks); //????????°???????????????cnt???\n\t\t\tmin_depth = min(min_depth,depth); //????°????????????°\n\t\t}\n\t\t//?????????????????´???????¬?\n\t}\n\t//???????????¢???\n\tmemo_cnt[P] = min_depth;\n\t\n\treturn min_depth;\n}\n\nint main() {\n\tint n=1;\n\twhile(true) {\n\t\tint pk = n * (n+1) * (n+2) / 6;\n\t\tif (pk >= MAX_SIZE){ break; }\n\n\t\tall_pks.push_back(pk);\n\t\tif (pk % 2 != 0) { kisu_pks.push_back(pk); }\n\t\tn++;\n\t}\n\treverse(begin(all_pks),end(all_pks));\n\treverse(begin(kisu_pks),end(kisu_pks));\n\n\tint P;\n\twhile(cin >> P) {\n\t\tif (P == 0) { break; }\n\n\t\tint index=0; //\n\t\tint left=0,right=0;\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tleft = dfs(P, 0/*pks???????????????*/, 0/* ??±??? */, all_pks);\n\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tright = dfs(P, 0/*pks???????????????*/, 0/* ??±??? */, kisu_pks);\n\t\tcout << left << \" \" << right << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}\n\n\n\n\n\t/*\n\tcout << all_pks.size() << endl;\n\tfor(int i=0; i<all_pks.size(); i++) {\n\t\tcout << all_pks[i] << \" \";\n\t}\n\tcout << endl;\n\n\tcout << kisu_pks.size() << endl;\n\tfor(int i=0; i<kisu_pks.size(); i++) {\n\t\tcout << kisu_pks[i] << \" \";\n\t}\n\tcout << endl;\n\t*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-8;\n\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n#define MAX_N 1000000\nint memo[MAX_N+1];\nint memo_odd[MAX_N+1];\n\nint plc(int n) { return n * (n + 1) * (n + 2) / 6; }\n\nvoid create_table() {\n  fill(memo, memo+MAX_N+1, 1<<30);\n  fill(memo_odd, memo_odd+MAX_N+1, 1<<30);\n  for (int i = 1; plc(i) <= MAX_N+1; i++) {\n    memo[plc(i)] = 1;\n    if (plc(i) % 2 == 0) continue;\n    memo_odd[plc(i)] = 1;\n  }\n  for (int i = 1; i <= MAX_N; i++) {\n    for (int j = 1; plc(j) <= i; j++) {\n      memo[i] = min(memo[i], memo[i-plc(j)] + 1);\n      if (plc(j) % 2 == 0) continue;\n      memo_odd[i] = min(memo_odd[i], memo_odd[i-plc(j)] + 1);\n    }\n  }\n}\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int n;\n  create_table();\n  while (cin >> n, n) {\n    cout << memo[n] << \" \" << memo_odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint dp[1000005];\nint dp2[1000005];\nint pl[180];\n\nint main() {\n\t//init\n\tfor (int i = 1; i<=180; i++)pl[i-1] = (i*(i + 1)*(i + 2)) / 6;\n\tmemset(dp, 0x7f, sizeof(dp));\n\tmemset(dp2, 0x7f, sizeof(dp2));\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tfor (int j = 0; j < 180; j++) {\n\t\t\tif(i+pl[j] <= 1000000)dp[i + pl[j]] = min(dp[i] + 1, dp[i + pl[j]]);\n\t\t\tif (i + pl[j] <= 1000000 && pl[j]&1)dp2[i + pl[j]] = min(dp2[i] + 1, dp2[i + pl[j]]);\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tprintf(\"%d %d\\n\", dp[n], dp2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint INF = 10000000;\nvector<int> po;\nvector<int> poo;\nvector<int> dp(1000005, INF);\nvector<int> dp2(1000005, INF);\n\nvoid init() {\n    for (int i = 1;; i++) {\n        int tmp = i*(i+1)*(i+2) / 6;\n        if (tmp > 1000000) break;\n        po.push_back(tmp);\n        if (tmp%2 == 1) poo.push_back(tmp);\n    }\n    \n    dp[0] = 0;\n    for (int i = 0; i < 1000001; i++) {\n        for (int j = 0; j < po.size(); j++) {\n            int sum = i + po[j];\n            if (sum <= 1000000) {\n                dp[sum] = min(dp[sum], dp[i] + 1);\n            }\n        }\n    }\n    \n    dp2[0] = 0;\n    for (int i = 0; i < 1000001; i++) {\n        for (int j = 0; j < poo.size(); j++) {\n            int sum = i + poo[j];\n            if (sum <= 1000000) {\n                dp2[sum] = min(dp2[sum], dp2[i] + 1);\n            }\n        }\n    }\n}\n\nint main(void){\n    // Your code here!\n    vector<pair<int, int>> ans;\n    init();\n    int N;\n    while (cin >> N, N) {\n        ans.push_back({dp[N], dp2[N]});\n    }\n    for (auto &p : ans) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint INF = (1LL << 30) - 1;\nint MOD = 1e9+7;\nint MAX_NUM = 1000000;\nmain(){\n    vector<int> V,W;\n    for(int i = 1;i * (i + 1) * (i + 2) / 6 <= MAX_NUM;i++){\n        int num = i * (i + 1) * (i + 2) / 6; \n        V.push_back(num);\n        if(i % 4 == 1)W.push_back(num);\n    }\n    vector<int> t1(MAX_NUM,INF),t2(MAX_NUM,INF);\n    t1[0] = t2[0] = 0;\n    rep(i,0,V.size()){\n        rep(j,0,MAX_NUM){\n            if(j + V[i] > MAX_NUM)break;\n            t1[j + V[i]] = min(t1[j + V[i]], t1[j] + 1);\n        }\n    }\n    rep(i,0,W.size()){\n        rep(j,0,MAX_NUM){\n            if(j + W[i] > MAX_NUM)break;\n            t2[j + W[i]] = min(t2[j + W[i]], t2[j] + 1);\n        }\n    }\n    int N;\n    cin >> N;\n    while(N){\n        cout << t1[N] << \" \" << t2[N] << endl;\n        cin >> N;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <tourist>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <string>\n#include <iomanip>\n#include <limits>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <list>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <numeric>\n#include <iomanip>\n#include <utility>\n#include <complex>\n#include <functional>\nusing namespace std;\nconst int MOD = 1000000007;\ntypedef long long ll;\ntypedef pair<ll, ll> p;\nconst int INF = (1 << 28);\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nconst int Dx[8] = {0, 1, 1, 1, 0, -1, -1, -1}, Dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n#define yes cout << \"Yes\" << endl\n#define YES cout << \"YES\" << endl\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl; \n#define no cout << \"No\" << endl\n#define NO cout << \"NO\" << endl\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define INF 2e9\n#define ALL(v) v.begin(), v.end()\n//setprecision(15)有効数字15桁\n//-std=c++14\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b)\n{\n    return a * b / gcd(a, b);\n}\nstruct edge {\n    int to, cost;\n};\nll n;\nvector<ll> ans,ansodd;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    vector<ll> dp(1000001,INF), odddp(1000001,INF);\n    dp[0]=0;\n    odddp[0]=0;\n    ll k=1;\n    while(true){\n        ll count=k*(k+1)*(k+2)/6;\n        if(count>1000000) break;\n        for(int i=count;i<=1000000;i++){\n            dp[i]=min(dp[i],dp[i-count]+1);\n            if(count%2){\n                odddp[i]=min(odddp[i],odddp[i-count]+1);\n            }\n        }\n        k++;\n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odddp[n]<<\"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n,res =inf;\nvector<vector<int>> dp;\nint solve(int a,int b,int c,vector<int> v){\n  if(dp[c][b] != inf){\n    return dp[c][b];\n  }\n  if(b == 0) res = inf;\n  if(a == n){\n    res = min(res,b);\n    dp[c][b] = min(res,dp[c][b]);\n    return res;\n  }\n  if(a > n || res < b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v),res);\n    }\n    dp[c][b] = min(res,dp[c][b]);\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < 1000000){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    const int Max = 1000;\n    dp = vector<vector<int>>(Max,vector<int>(Max,inf));\n    cout << solve(0,0,lb1,suqnum)<< \" \" ;\n    dp = vector<vector<int>>(Max,vector<int>(Max,inf));\n    cout << solve(0,0,lb2,odd) << endl;\n//     queue<pii> q;\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb1,suqnum.size()){\n//         if(p.se+suqnum[i] == n){\n//           cout << p.fi+1<< \" \";\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+suqnum[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n//         }\n//       }\n//     }\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb2,odd.size()){\n//         if(p.se+odd[i] == n){\n//           cout << p.fi+1<< endl;\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+odd[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+odd[i]));\n//         }\n//       }\n//     }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> bool chmax(T &u, const T z) { if (u < z) {u = z; return true;} else return false; }\ntemplate <typename T> bool chmin(T &u, const T z) { if (u > z) {u = z; return true;} else return false; }\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define ll long long \n\nint odd[10101010],even[10101010];\nint main() {\n\tvector<int>a,b;\n\tint cnt=0;\n\tfor(int i=1;i<=10101010;i++){\n\t\tint x=i*(i+1)*(i+2)/6;\n\t\tif(x>10101010)break;\n\t\ta.push_back(x);\n\t\tif(x%2==1) b.push_back(x);\n\t}\n\t//cout<<\"kazua\"<<a.size()<<\" kazub\"<<b.size()<<endl;\n\trep(i,a.size()){\n\t\tint cnt=1;\n\t\twhile(a[i]*cnt<10101010){\n    \t\tif(a[i]*cnt<10101010){\n\t\t\t\teven[a[i]*cnt]=cnt;\n\t\t\t}else break;\n\t\t\tcnt++;\n\t\t}\n\t}\n\trep(i,b.size()){\n\t\tint cnt=1;\n\t\twhile(b[i]*cnt<10101010){\n\t\t\tif(b[i]*cnt<10101010){\n\t\t\t\todd[b[i]*cnt]=cnt;\n\t\t\t}else break;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\t\t//rep(i,1010101){odd[i]=1010101;}\n\t\t//rep(i,1010101){even[i]=1010101;}\n\t\trep(j,a.size()){\n\t\t\tfor(int i=0;i<10101010;i++){\n\t\t\t\tif(even[i]!=0&&i+a[j]<10101010)chmin(even[i+a[j]],even[i]+1);\n\t\t\t}\n\t\t}\n\t\trep(j,b.size()){\n    \t\tfor(int i=0;i<10101010;i++){\n\t\t\t\tif(odd[i]!=0&&i+b[j]<10101010)chmin(odd[i+b[j]],odd[i]+1);\n\t\t\t}\n\t\t}\n\tint n=1;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\tcout<<even[n]<<\" \"<<odd[n]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\nusing namespace std;\n\nint memo[150];\nint dp[1000001];\nint dp2[1000001];\nvoid inset(){\n\tdp[0]=0;\n\tfill(dp,dp+100000,1000000);\n\tfill(dp2,dp2+100000,1000000);\n\tdp[0]=0;\n\tdp2[0]=0;\n\trep(i,1,150){\n\t\tmemo[i]=i*(i+1)*(i+2),memo[i]/=6;\n\t\trep(j,1,100001)if(j-memo[i]>=0){\n\t\tif(dp[j]>dp[j-memo[i]]+1)dp[j]=dp[j-memo[i]]+1;\n\t\tif(memo[i]&1)if(dp2[j]>dp2[j-memo[i]]+1)dp2[j]=dp2[j-memo[i]]+1;\n\t\t}\n\t}\n\t//rep(i,1,150){\n\t//\tprintf(\"[%d]%d\\n\",i,dp2[i]);\n\t//}\n}\n\n\nint main(void){\n\tinset();\n\tint x;\n\twhile(true){\n\t\tcin>>x;if(x==0)return(0);\n\t\tcout<<dp[x]<<\" \"<<dp2[x]<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define INF (1<<25)\nint N;\nint pr[182];\nint dp[1000002][2];\nvoid init(){\n  for(int i=0;i<=1000000;i++) for(int j=0;j<2;j++) dp[i][j]=INF;\n}\nvoid solve(){\n  dp[0][0]=0;\n  dp[0][1]=0;\n  for(int i=0;i<=1000000;i++){\n    if(dp[i][0]==INF) continue;\n    for(int j=0;i+pr[j]<=1000000;j++){\n      dp[i+pr[j]][0] = min(dp[i+pr[j]][0],dp[i][0]+1);\n      if(pr[j]&1) dp[i+pr[j]][1] = min(dp[i+pr[j]][1],dp[i][1]+1);\n    }\n  }\n}\n\nint main(){\n  for(int i=0;i<182;i++) pr[i] = (i+1)*(i+2)*(i+3)/6;\n  //  for(int i=0;i<102;i++) printf(\"%d\\n\",pr[i]);\n  //  for(int i=0;i<102;i++) if(!(i%2)) printf(\"%d\\n\",pr[i]);\n  init();\n  solve();\n  while(1){\n    scanf(\"%d\",&N);\n    if(!N) break;\n    printf(\"%d %d\\n\",dp[N][0],dp[N][1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include \"bits/stdc++.h\"\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n#define ll long long\n#define ull unsigned ll\ntypedef long double ld;\n#define ALL(a) (a).begin(),(a).end()\n#define ifnot(a) if(not a)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\nusing namespace std;\n\nvoid reader(int &a) { scanf(\"%d\", &a); }\nvoid reader(double &a) { scanf(\"%lf\", &a); }\nvoid reader(char a[]) { scanf(\"%s\", a); }\nvoid reader(char &a) { scanf(\" %c\", &a); }\nvoid reader(ll &a) { scanf(\"%lld\", &a); }\nvoid reader(ull &a) { scanf(\"%llu\", &a); }\n// void reader(string& a){cin >> a;};\ntemplate<class T, class U> void reader(T& t, U& u) { reader(t); reader(u); }\ntemplate<class T, class U, class V> void reader(T& t, U& u, V& v) { reader(t); reader(u); reader(v); }\n\nvoid writer(const int a, char c) { printf(\"%d\", a); putchar(c); }\nvoid writer(const ll a, char c) { printf(\"%lld\", a); putchar(c); }\nvoid writer(const ull a, char c) { printf(\"%llu\", a); putchar(c); }\nvoid writer(const double a, char c) { printf(\"%.20lf\", a); putchar(c); }\nvoid writer(const char a[]) { printf(\"%s\", a); };\nvoid writer(const char a[], char c) { printf(\"%s\", a); putchar(c); };\nvoid writer(const char a, char c) { putchar(a); putchar(c); };\ntemplate<class T> void writerLn(T t) { writer(t, '\\n'); }\ntemplate<class T, class U> void writerLn(T t, U u) { writer(t, ' '); writer(u, '\\n'); }\ntemplate<class T, class U, class V> void writerLn(T t, U u, V v) { writer(t, ' '); writer(u, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerVec(vector<T> x) { int n = x.size(); int i; if (!n) { putchar('\\n'); return; }rep(i, n - 1) writer(x[i], ' '); writer(x[n - 1], '\\n'); }\n\nvector<string> split(const string &str, char sep) { vector<string> v; stringstream ss(str); string buffer; while (getline(ss, buffer, sep)) { v.push_back(buffer); }return v; }\n// #define int ll\nbool test = 1;\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n#define INF (1 << 28)\null mod = (int)1e9 + 7;\n//.....................\n#define MAX 1000005\nint dp1[MAX+5];\nint dp2[MAX + 5];\nsigned main(void)\n{\n\tint i, j, k;\n\trep(i, MAX) {\n\t\tdp1[i] = INT_MAX;\n\t}\n\tdp1[0] = 0;\n\trep(i, MAX) {\n\t\trep(j, MAX) {\n\t\t\tint now = j*(j + 1)*(j + 2)/6;\n\t\t\tif (i + now > MAX) break;\n\t\t\tif (dp1[i] < dp1[i + now]) {\n\t\t\t\tdp1[i + now] = dp1[i] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i, MAX) {\n\t\tdp2[i] = INT_MAX;\n\t}\n\tdp2[0] = 0;\n\trep(i, MAX) {\n\t\tfor(j=1;;j+=2) {\n\t\t\tint now = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (i + now > MAX) break;\n\t\t\tif (now % 2 == 0) continue;\n\t\t\tif (dp2[i] < dp2[i + now]) {\n\t\t\t\tdp2[i + now] = dp2[i] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, 43) {\n\t//\tprintf(\"dp2[%d] = %d\\n\",i, dp2[i]);\n\t//}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return 0;\n\t\twriterLn(dp1[n], dp2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\n#define MAX 1000000\n\nvoid makelist(int *list, int x) {\n  for (int i = x; i <= MAX; i++) {\n    list[i] = min(list[i], list[i-x]+1);\n  }\n}\n\nint main() {\n  int list1[MAX+10], list2[MAX+10], x, n;\n  for (int i = 1; i <= MAX; i++) {\n    list1[i] = list2[i] = INF;\n  }\n  for (int i = 1; ; i++) {\n    x = i*(i+1)*(i+2)/6;\n    if (x >= MAX) break;\n    makelist(list1, x);\n    if (x & 1) makelist(list2, x);\n  }\n  while (cin >> n, n) {\n    cout << list1[n] << \" \" << list2[n] << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[1000001], dp2[1000001];\n\nint nums[200] = {0};\n\nint main(){\n\n    for(int i = 0;i < 200;i++) nums[i] = i * (i + 1) * (i + 2) / 6;\n\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i = 0;i <= n;i++) dp[i] = dp2[i] = 100002;\n        dp[0] = dp2[0] = 0;\n\n        for(int j = 1;nums[j] <= n;j++) {\n            for(int i = nums[j];i <= n;i++) {\n                if(dp[i] > dp[i - nums[j]] + 1) {\n                    dp[i] = dp[i - nums[j]] + 1;\n                }\n                if(dp2[i] > dp2[i - nums[j]] + 1) {\n                    if(nums[j] % 2 == 1) dp2[i] = dp2[i - nums[j]] + 1;\n                }\n            }\n        }\n        cout << dp[n] << ' ' << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _sel(_1, _2, x, ...) x\n#define repn(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, a, b) for (ll i = (a); i < (b); i++)\n#define rep(i, ...) _sel(__VA_ARGS__, reps, repn)(i, __VA_ARGS__)\n#define reppn(i, n) for (ll i = 1; i <= (n); i++)\n#define repps(i, a, b) for (ll i = (a); i <= (b); i++)\n#define repp(i, ...) _sel(__VA_ARGS__, repps, reppn)(i, __VA_ARGS__)\n#define rrepn(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, a, b) for (ll i = (b) - 1; i >= (a); i--)\n#define rrep(i, ...) _sel(__VA_ARGS__, rreps, rrepn)(i, __VA_ARGS__)\n#define rreppn(i, n) for (ll i = (n); i >= 1; i--)\n#define rrepps(i, a, b) for (ll i = (b); i >= (a); i--)\n#define rrepp(i, ...) _sel(__VA_ARGS__, rrepps, rreppn)(i, __VA_ARGS__)\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define rng(v) (v).begin(), (v).end()\n#define rrng(v) (v).rbegin(), (v).rend()\n#define _shwv(v) for (auto _t1 : v) cerr << _t1 << \" \"; cerr << endl;\n#define dbg(x) cerr << #x << \": \" << (x) << endl;\n#define dbgv(v) cerr << #v << \": \"; _shwv(v);\n#define dbgm(m) cerr << #m << \":\" << endl; for (auto _t2 : m) { _shwv(_t2); }\n\nusing namespace std;\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vc = vector<char>;\nusing vs = vector<string>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvb = vector<vector<bool>>;\nusing vvc = vector<vector<char>>;\nusing vvs = vector<vector<string>>;\n\nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\nconst int DX[4] = {1, 0, -1, 0};\nconst int DY[4] = {0, 1, 0, -1};\n\ntemplate<typename T> inline void prt(T x) { cout << x << endl; }\ntemplate<typename T> inline void getv(T& v) { for (auto& t : v) cin >> t; }\ntemplate<typename T> inline int siz(T& x) { return x.size(); }\ntemplate<typename T> inline ll pow2(T n) { return 1ll << n; }\ntemplate<typename T, typename U> inline int bit(T x, U n) { return x >> n & 1; }\ntemplate<typename T, typename U>\ninline bool umax(T& m, U x) { if (m < x) { m = x; return true; } return false; }\ntemplate<typename T, typename U>\ninline bool umin(T& m, U x) { if (m > x) { m = x; return true; } return false; }\n\n\nint main() {\n    vi n;\n    int m = 0;\n    while (true) {\n        int a; cin >> a;\n        if (a == 0) break;\n        umax(m, a);\n        n.pb(a);\n    }\n    vi dp(m + 1, 0);\n    vi dp2(m + 1, 0);\n    repp(i, m) {\n        dp[i] = INF;\n        dp2[i] = INF;\n        repp(j, INF) {\n            ll num = j * (j + 1) * (j + 2) / 6;\n            if (i < num) break;\n            umin(dp[i], dp[i - num] + 1);\n            if (num % 2 == 1)\n                umin(dp2[i], dp2[i - num] + 1);\n        }\n    }\n    for (auto t : n) {\n        cout << dp[t] << \" \" << dp2[t] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int lim = 1e6 + 100;\nconst int inf = 1e9;\n\nint dp[lim];\nint dp_odd[lim];\n\nint main(){\n    //init dp talbe\n    for(int i=0; i<lim; i++){\n        dp[i] = inf;\n        dp_odd[i] = inf;\n    }\n    dp[0] = 0;\n    dp_odd[0] = 0;\n\n    for(int n=1; n<lim; n++){\n        int num = n * (n+1) * (n+2) / 6;\n        if(num >= lim) break;\n\n        for(int i=num; i<lim; i++){\n            dp[i] = min(dp[i], dp[i - num] + 1);\n            if(num%2 == 1) dp_odd[i] = min(dp_odd[i], dp_odd[i - num] + 1);\n        }\n    }\n\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) return 0;\n        cout << dp[N] << \" \" << dp_odd[N] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200],b[150],c[1000010],d[1000010],k=0,i,j,n;\n\n  for(i=1;i<200;i++)a[i-1]=i*(i+1)*(i+2)/6;\n\n  for(j=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=0;i<1000010;i++)c[i]=d[i]=i;\n\n  for(i=1;i<198;i++)for(j=a[i];j<1000010;j++){\n    c[j]=min(c[j],c[j-a[i]]+1);\n  }\n  for(i=1;i<k-1;i++)for(j=b[i];j<10000010;j++){\n    d[j]=min(d[j],d[j-b[i]]+1);\n  }\n while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\nusing namespace std;\n#define ull unsigned long long\nint memo[150];\nint  dp[1000002];\nint  dp2[1000002];\nvoid inset(){\n\tdp[0]=0;\n\tfill(dp,dp+1000001,10000);\n\tfill(dp2,dp2+1000001,10000);\n\tdp[0]=0;\n\tdp2[0]=0;\n\trep(i,1,150){\n\t\tmemo[i]=i*(i+1)*(i+2),memo[i]/=6;\n\t\trep(j,1,1000001)\n\t\t\tif(j-memo[i]>=0){\n\t\tif(dp[j]>dp[j-memo[i]]+1)dp[j]=dp[j-memo[i]]+1;\n\t\tif(memo[i]&1)if(dp2[j]>dp2[j-memo[i]]+1)dp2[j]=dp2[j-memo[i]]+1;\n\t\t}\n\t}\n\t//rep(i,1,1000001){\n\t//\tif(dp2[i]==0){\n\t//\tprintf(\"[%d]%d\\n\",i,dp2[i]);\n\t//\tbreak;\n\t//\t}\n\t//}\n}\n\n\nint main(void){\n\tinset();\n\tint x;\n\twhile(true){\n\t\tcin>>x;if(x==0)return(0);\n\t\tcout<<dp[x]<<\" \"<<dp2[x]<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[100000];\nint dpodd[100000];\nint num[200];\nint INF = 1000000;\nint main(){\n\tfor(int i = 0; i < 200; i++){\n\t\tnum[i] = (i + 1) * (i + 2) * (i + 3)/ 6;\n\t}\n\tdp[0] = 0;\n\tdpodd[0] = 0;\n\tfor(int i = 1; i < 100000; i++){\n\t\tdp[i] = INF;\n\t\tdpodd[i] = INF;\n\t\tfor(int j = 0; num[j] <= i; j++){\n\t\t\tdp[i] = min(dp[i], dp[i - num[j]] + 1);\n\t\t\tif(num[j] % 2 == 1){\n\t\t\t\tdpodd[i] = min(dpodd[i], dpodd[i - num[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint N;\n\twhile(cin >> N, N){\n\t\tcout << dp[N] << \" \" << dpodd[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvi tetra;\nvi table(1000000, INF);\nint ans;\n\nvoid search(int n, int step);\nint odd_search(int n);\nvoid make_tetra();\nvoid make_odd_tetra();\n\n\nsigned main()\n{\n    make_tetra();\n    make_odd_tetra();\n\n    Int(n);\n\n    while (n) {\n        ans = INF;\n        search(n, 0);\n        cout << ans;\n        cout << \" \" << odd_search(n) << endl;\n        cin >> n;\n    }\n\n    return 0;\n}\n\n\nint odd_search(int n)\n{\n    int ret = INF;\n    if (table[n] != INF) {\n        return table[n];\n    } else {\n        Rep(i, n/2+1) {\n            ret = min(ret, odd_search(n-i) + odd_search(i));\n        }\n    }\n    table[n] = ret;\n    return ret;\n}\n\nvoid search(int n, int step)\n{\n    if (ans <= step) {\n        return;\n    } else if (!n) {\n        ans = step;\n        return ;\n    } else if (n < 0) {\n        return;\n    }\n    for (int i = tetra.size()-1; i >= 0; i--) {\n        if (n >= tetra[i]) {\n            search(n-tetra[i], step+1);\n        }\n    }\n}\n\n\nvoid make_tetra()\n{\n    Rep(i, 181) {\n        tetra.pb(i * (i + 1) * (i + 2) /6);\n    }\n}\n\nvoid make_odd_tetra()\n{\n    for (int i : tetra) {\n        if (i % 2) {\n            table[i] = 1;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define MAXN 1000000\n#define ll long long\n\nll dp[MAXN + 10];\nll Odp[MAXN + 10];\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < MAXN + 10;i++) {\n\t\tdp[i] = i;\n\t\tOdp[i] = i;\n\t}\n\t// n := n???????????£?????¢???\n\t// p := ??£?????¢?????°\n\t// n = 1 p = 1 ?????´???????????????\n\t// n = 2, p = 2*3*4/6 = 4??????\n\tll p;\n\tfor (int n = 2; n <= MAXN;n++) {\n\t\t p = n*(n + 1)*(n + 2) / 6;\n\t\tfor (int i = 0; i + p <= MAXN;i++) {\n\t\t\tdp[i + p] = min(dp[i + p], dp[i] + 1);\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tOdp[i + p] = min(Odp[i + p], Odp[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint N;\n\twhile (cin >> N,N) {\n\t\tcout << dp[N] << \" \" << Odp[N] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n,res =inf;\nconst int MAX = 1000100;\nint solve(int a,int b,int c,vector<int> v, int** dp){\n  if(dp[b][a] == 1) return b;\n  else if(dp[b][a] == -1) return inf;\n  dp[b][a] = -1;\n  if(b == 0) res = inf;\n  if(a == n){\n    res = min(res,b);\n    dp[b][a] = 1;\n    return b;\n  }\n  if(a > n || res < b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v,dp),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < MAX){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    {\n      const size_t s = suqnum.size()*2;\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb1,suqnum,arg) << \" \";\n      rep(i,s) delete[] dp[i];\n    }\n    {\n      const size_t s = odd.size()*2;\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb2,odd,arg)<<endl;\n      rep(i,s) delete[] dp[i];\n    }\n//     queue<pii> q;\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb1,suqnum.size()){\n//         if(p.se+suqnum[i] == n){\n//           cout << p.fi+1<< \" \";\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+suqnum[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n//         }\n//       }\n//     }\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb2,odd.size()){\n//         if(p.se+odd[i] == n){\n//           cout << p.fi+1<< endl;\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+odd[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+odd[i]));\n//         }\n//       }\n//     }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <utility>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\n\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define itrep(i,x) for(auto i=(x).begin(); i!=(x).end();i++)\n#define Sort(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define vec vector\n#define INF (int)1e9\n#define INFL 1e18\n#define MOD 1000000007\n#define pb push_back\n#define MP make_pair\n#define PI 3.1415926535\ntypedef long long int ll;\ntypedef std::pair<int,int> P;\nint D=1;\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\nusing namespace std;\n\nint main(){\n    vector<int> v,oddv;\n    for(ll i=1;;i++){\n        if(i*(i+1)*(i+2)/6<=1000000){\n            v.pb(i*(i+1)*(i+2)/6);\n        }\n        else break;\n    }\n    int ans1[1000010],ans2[1000010];\n    rep(i,0,1000010) ans1[i]=ans2[i]=INF;\n    ans1[0]=0; ans2[0]=0;\n    rep(i,0,1000000){\n        ans1[i]=i; ans2[i]=i;\n        for(int j=0;i>=v[j];j++){\n            ans1[i]=min(ans1[i-v[j]]+1,ans1[i]);\n            if(v[j]%2==1)ans2[i]=min(ans2[i],ans2[i-v[j]]+1);\n        }\n    }\n\n    int n;\n    while(cin>>n&&n){\n        cout<<ans1[n]<<\" \"<<ans2[n]<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    int ans_tmp=0;\n    int ans2_tmp=0;\n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  ans_tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=ans_tmp;\n\t}\n      }\n    }\n\n\n    int ans1=ans_tmp;\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp2[i+coin_ki[j]]=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  ans2_tmp=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  dp2[i+coin_ki[j]]=ans2_tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=ans2_tmp;\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\nvector<int> dp(1e6);\nvector<int> dp2(1e6);\nint num[200];\nvoid solve(){\n    for(int i=1;i<200;i++){\n        for(int j=0;j<1e6;j++){\n            if(j>=num[i]){\n                dp[j]=min(dp[j-num[i]]+1,dp[j]);\n            }\n        }\n    }\n    for(int i=1;i<200;i++){\n        if(num[i]%2==0) continue;\n        for(int j=0;j<1e6;j++){\n            if(j>=num[i]){\n                dp2[j]=min(dp2[j-num[i]]+1,dp2[j]);\n            }\n        }\n    }\n}\nint main(){\n    fill(dp.begin(),dp.end(),INF);\n    fill(dp2.begin(),dp2.end(),INF);\n    dp[0]=0;\n    dp2[0]=0;\n    for(int i=1;i<200;i++){\n        num[i]=i*(i+1)*(i+2)/6;\n    }\n    int n;\n    solve();\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <math.h>\n#include <stdlib.h>\nusing namespace std;\nint main(){\n\tint *a=new int[1000000];\n\tint *b=new int[1000000];\n\tfor(int i=0;i<1000000;i++){\n\t\ta[i]=100000;\n\t\tb[i]=100000;\n\t}\n\tfor(int i=1;i<pow(6000000,0.4)+5;i++){\n\t\tint aa=(i*(i+1)*(i+2))/6;\n\t\tif(aa<1000000){\n\t\t\ta[aa]=1;\n\t\t}\n\t}\n\ta[0]=0;\n\ta[2]=2;\n\ta[3]=3;\n\tfor(int i=4;i<1000000;i++){\n\t\tif(a[i]==1){\n\t\t\tfor(int j=1;j<=1000000/i+2;j++){\n\t\t\t\tfor(int k=0;k<2*i;k++){\n\t\t\t\t\tif(j*i+k<1000000){\n\t\t\t\t\t\ta[j*i+k]=min(a[j*i+k],j+a[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<pow(6000000,0.4)/4+5;i++){\n\t\tint bb=((4*i+1)*(4*i+2)*(4*i+3))/6;\n\t\tif(bb<1000000){\n\t\t\tb[bb]=1;\n\t\t}\n\t}\n\tb[0]=0;\n\tfor(int i=2;i<35;i++){\n\t\tb[i]=i;\n\t}\n\tfor(int i=4;i<1000000;i++){\n\t\tif(b[i]==1){\n\t\t\tfor(int j=1;j<=1000000/i+2;j++){\n\t\t\t\tfor(int k=0;k<3*i;k++){\n\t\t\t\t\tif(j*i+k<1000000){\n\t\t\t\t\t\tb[j*i+k]=min(b[j*i+k],j+b[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0) break;\n\t\tcout<<a[n]<<\" \"<<b[n]<<endl;\n\t}\n    return 0;\n    delete[] a;\n    delete[] b;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long int, long long int> PLL;\n\nvector<long long int>A( 1000001, LLONG_MAX / 6 ), B( 1000001, LLONG_MAX / 6 );\n\nlong long int saikiA( long long int N ) {\n\tif( A[N] == LLONG_MAX / 6 ) {\n\t\tfor( size_t i = 1; i * 2 <= N; i++ ) {\n\t\t\tA[N] = min( A[N], saikiA( i ) + saikiA( N - i ) );\n\t\t}\n\t}\n\treturn A[N];\n}\n\nlong long int saikiB( long long int N ) {\n\tif( B[N] == LLONG_MAX / 6 ) {\n\t\tfor( size_t i = 1; i * 2 <= N; i++ ) {\n\t\t\tB[N] = min( B[N], saikiB( i ) + saikiB( N - i ) );\n\t\t}\n\t}\n\treturn B[N];\n}\n\nint main() {\n\tvector<long long int>X, Y;\n\tfor( size_t i = 1; i < 100; i++ ) {\n\t\tlong long int now = i*(i + 1)*(i + 2) / 6;\n\t\tA[now] = 1;\n\t\tX.emplace_back( now );\n\t\tfor( auto x : X ) {\n\t\t\tA[now + x] = min( A[now + x], 2LL );\n\t\t}\n\t\tif( now % 2 ) {\n\t\t\tB[now] = 1;\n\t\t\tY.emplace_back( now );\n\t\t\tfor( auto x : Y ) {\n\t\t\t\tA[now + x] = min( A[now + x], 2LL );\n\t\t\t}\n\t\t}\n\t}\n\tlong long int N;\n\twhile( cin >> N, N ) {\n\t\tcout << saikiA( N ) << \" \" << saikiB( N ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define MAXNUM 10000\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM];\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//1からMAXまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200],b[200],c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<195;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll N;\nconst int MAX = 1e6+1;\nll dp[MAX];\nll kidp[MAX];\n\nll calc(ll x){\n    return x *(x+1) * (x+2) / 6;    \n}\n\nint main(){\n\n    vector<ll> nums;\n    vector<ll> kinums;\n    int k = 1;\n    for(int i=0; i<190; i++){\n        ll num = calc(k);\n        nums.push_back(num);\n        if(num % 2==1){\n            kinums.push_back(num);\n        }\n        k++;\n        // cout << num << endl;\n    }\n    fill(dp, dp+MAX, 1e9);\n    fill(kidp, kidp+MAX, 1e9);\n    sort(nums.begin(), nums.end());\n    \n    dp[0] = 0;\n    kidp[0] = 0;\n    for(int i=0; i<MAX; i++){\n        for(int j=nums.size()-1; j>=0; j--){\n            ll u = nums[j];\n            if(i - u >= 0 && dp[i] > dp[i-u]+1){\n                dp[i] = dp[i-u] + 1;\n            }\n        }\n        for(int j=kinums.size()-1; j>=0; j--){\n            ll u = kinums[j];\n            if(i - u >= 0 && kidp[i] > kidp[i-u]+1){\n                kidp[i] = min(kidp[i], kidp[i-u] + 1);\n            }\n        }\n    }\n\n\n    while(1){\n        cin >> N;\n        if(!N) break;\n\n        cout << dp[N] << \" \" << kidp[N] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][100000] = {0};\n\nvoid solve(int n) {\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t\tif (dp[i][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=100000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\t//dp[i%2][j] = 0;\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t\tif (dp[i%2][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1000000];\nint dp1[1000000];\n\nvoid init(){\n\n \n  for(int i=0;i<1000000;i++){\n    dp[i]=100000;\n  }\n\n  dp[0]=0;\n  for(int i=1;i<1000000;i++){\n    int j=1;\n    while(i-j*(j+1)*(j+2)/6>=0){\n      dp[i]=min(dp[i],dp[i-j*(j+1)*(j+2)/6]+1);\n      j++;\n    }\n  }\n \n\n\n  for(int i=0;i<1000000;i++){\n    dp1[i]=1000000;\n  }\n  dp1[0]=0;\n  for(int i=1;i<1000000;i++){\n    int j=1; \n    while(i-j*(j+1)*(j+2)/6>=0){\n      if((j*(j+1)*(j+2)/6)%2)\n        dp1[i]=min(dp1[i],dp1[i-j*(j+1)*(j+2)/6]+1);\n      j++;\n    }\n  }\n\n}\n\nvoid f(int n){\n  cout<<dp[n]<<' '<<dp1[n]<<endl;\n}\n\n\nmain(){\n  int n;\n  init();\n  while(true){\n    cin>>n;\n    if(n==0) break;\n    f(n);\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nint main(){\n\n  int a[200];\n  int b[50];\n  for(int i=0;i<200;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(int i=0;i<50;i++)b[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\n  vector<int> dp1;\n  dp1.assign(1500000,0);\n\n  for(int i=0;i<1500000;i++)dp1[i]=i;\n  for(int i=1;i<1500000;i++){\n    for(int j=0;j<200;j++){\n      if(i>=a[j])dp1[i]=min(dp1[i],dp1[i-a[j]]+1);\n    }\n  }\n\n  vector<int> dp2;\n  dp2.assign(1500000,0);\n  for(int i=0;i<1500000;i++)dp2[i]=i;\n  for(int i=0;i<1500000;i++){\n    for(int j=0;j<50;j++){\n      if(i>=b[j])dp2[i]=min(dp2[i],dp2[i-b[j]]+1);\n    }\n  }\n\n  int n;\n  cin >> n;\n  while(n!=0){\n    cout << dp1[n] <<\" \" << dp2[n] << endl;\n    cin >> n;\n  }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <limits>\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst ll INF = 1234567890123456;\n\n#define REP(i,n)   for(int i=0; i<(int)(n); ++i)\n#define FOR(i,b,e) for(int i=(b); i<=(int)(e); ++i)\n\n#define in cin\n#define out cout\n#define pb push_back\nusing namespace std;\n\nvector<ll>a;\nint dp[1000000], oddp[1000000];\n\nint main(){\n\tint n;\n\n\tREP(i,1000000) {\n\t\tdp[i] = i;\n\t\toddp[i] = i;\n\t}\n\tint c=0;\n\tfor (int a = 2;  c<1000000; ++a) {\n\t\tc = (a*(a + 1)*(a + 2)) / 6;\n\t\tif (c > 1000000)break;\n\t\tfor (int i = 0; i <= 1000000; ++i) {\n\t\t\tif (i - c < 0)continue;\n\n\t\t\tdp[i] = min(dp[i], dp[i - c] + 1);\n\t\t\tif (c % 2 == 1) {\n\t\t\t\toddp[i] = min(oddp[i], oddp[i - c] + 1);\n\t\t\t}\n\t\t}\n\n\t}\n\twhile (in >> n) {\n\t\tif (!n) break;\n\t\tout << dp[n] << ' ' << oddp[n] << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <ctime>\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define MOD(x) (x%(mod))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint dp[1000005],odd_dp[1000005];\nvector<int> pol;\n\nvoid init(){\n  REP(i,1,1000){\n    int num=i*(i+1)*(i+2)/6;\n    if(num>1000000)break;\n    pol.pb(num);\n    //cout<<num<<endl;\n  }\n  rep(i,1000005)dp[i]=odd_dp[i]=i;\n}\n\nvoid DP(){\n  bool ok;\n  REP(i,1,pol.size()){\n    ok=true;\n    for(int j=pol[i];j<1000005;j++){\n      if(j-dp[i]>=0)dp[j]=min(dp[j],dp[j-pol[i]]+1);\n      if(pol[i]%2)if(j-odd_dp[i]>=0)odd_dp[j]=min(odd_dp[j],odd_dp[j-pol[i]]+1);\n    }\n  }\n}\n\nint main(){\n  init();\n  DP();\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<odd_dp[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n#define INF 100000000\n#define ll long long\n\nint dp1[1000001];\nint dp2[1000001];\nint main()\n{\n\tvector<ll> poloc;\n\t\n\tint i = 1;\n\twhile (i*(i + 1)*(i + 2) / 6 <= 1000000) {\n\t\tpoloc.push_back(i*(i + 1)*(i + 2) / 6);\n\t\ti++;\n\t}\n\n\tREP(i, 1, 1000001) dp1[i] = dp2[i] = INF;\n\tdp1[0] = dp2[0] = 0;\n\tREP(i, 0, poloc.size()) {\n\t\tREP(j, 0, 1000001) {\n\t\t\tif (j + poloc[i] > 1000000) break;\n\t\t\tdp1[j + poloc[i]] = min(dp1[j + poloc[i]], dp1[j] + 1);\n\t\t}\n\n\t\tif (poloc[i] % 2 == 1) {\n\t\t\tREP(j, 0, 1000001) {\n\t\t\t\tif (j + poloc[i] > 1000000) break;\n\t\t\t\tdp2[j + poloc[i]] = min(dp2[j + poloc[i]], dp2[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint x,y;\nint m[1000005]={};\nint memo[1000005]={};\nvector<int> odd;\nvoid saiki(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << endl;\n  if(n==0) {\n    x=min(x,d);\n  }else if(n>0) {\n    for(i=1;m[i]<=n;i++);\n    i--;\n    //cout << i << \":\" << n << \":\" << m[i] << endl;\n    for(j=i;j>0;j--){\n      if(x>d+1){\n\tsaiki(n-m[j],d+1);\n      }\n    }\n  }\n}\nvoid saiki2(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << endl;\n  if(n==0) {\n    y=min(y,d);\n  }else if(n>0) {\n    for(i=0;odd[i]<=n;i++);\n    i--;\n    //cout << i << \":\" << n << \":\" << odd[i] << endl;\n    for(j=i;j>=0;j--){\n      if(y>d+1){\n\tsaiki2(n-odd[j],d+1);\n      }\n    }\n  }\n}\nint main(){\n  int i,j,k;\n  for(i=1;i<1000005;i++) {\n    m[i]=i*(i+1)*(i+2)/6;\n    if(m[i]%2==1) odd.push_back(m[i]);\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    x=1<<10;y=x;\n    saiki(n,0);saiki2(n,0);\n    cout << x << \" \" <<  y << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000000\nusing namespace std;\n\nint main(){\n int pol[101],ans[N],ans2[N];\n\n for(int i=0;i<N;i++)ans[i]=ans2[i]=N;\n for(int i=1;i<101;i++){\n   pol[i]=i*(i+1)*(i+2)/6,ans[pol[i]]=1;\n   if(pol[i]%2)ans2[pol[i]]=1;\n }\n for(int i=1;i<=N;i++)\n   for(int j=1;j<101;j++){\n     if(i-pol[j]>=0) ans[i]=min(ans[i-pol[j]]+ans[pol[j]],ans[i]);\n     if(i-pol[j]>=0 && pol[j]%2)ans2[i]=min(ans2[i-pol[j]]+ans2[pol[j]],ans2[i]);\n   }\n while(1){\n   \n  int n;\n   cin>>n;\n   if(n==0) break;\n  cout<<ans[n]<<\" \"<<ans2[n]<<endl;\n }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n\n  for(int i=0;i<1111111;i++){ solve(i), solve2(i); }\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define ALL( a )        (a).begin(), (a).end()             \n\nint main() {\n\tint n;\n\tvector<int> a, o;\n\tfor( int i = 1; i * ( i + 1 ) * ( i + 2 ) / 6 < 1000000; i++ ) {\n\t\ta.push_back( i * ( i + 1 ) * ( i + 2 ) / 6 );\n\t\tif( ( i * ( i + 1 ) * ( i + 2 ) / 6 ) % 2 == 1 ) {\n\t\t\to.push_back( i * ( i + 1 ) * ( i + 2 ) / 6 );\n\t\t}\n\t}\n\n\tint tmp[2];\n\twhile( 1 ) {\n\t\tcin >> n; if( n == 0 ) break;\n\t\ttmp[0] = n;\n\t\ttmp[1] = n;\n\t\tint acnt = INT_MAX, ocnt = INT_MAX, tcnt = 0;\n\t\t\n\t\tint i;\n\t\tfor( i = a.size() - 1; i >= 0; i-- ) {\n\t\t\tif( tmp[0] >= a[i] ) break;\n\t\t}\n\t\tfor( i; i >= 0; i-- ){\n\t\t\tint j = i;\n\t\t\twhile( tmp[0] > 0 ) {\n\t\t\t\twhile( tmp[0] >= a[j] ) {\n\t\t\t\t\ttmp[0] -= a[j];\n\t\t\t\t\ttcnt++;\n\t\t\t\t}\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tacnt = min( acnt, tcnt );\n\t\t\ttcnt = 0;\n\t\t\ttmp[0] = n;\n\t\t}\n\n\t\tfor( i = o.size() - 1; i >= 0; i-- ) {\n\t\t\tif( tmp[1] >= o[i] ) break;\n\t\t}\n\t\tfor( i; i >= 0; i-- ) {\n\t\t\tint j = i;\n\t\t\twhile( tmp[1] > 0 ) {\n\t\t\t\twhile( tmp[1] >= o[j] ) {\n\t\t\t\t\ttmp[1] -= o[j];\n\t\t\t\t\ttcnt++;\n\t\t\t\t}\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tocnt = min( ocnt, tcnt );\n\t\t\ttcnt = 0;\n\t\t\ttmp[1] = n;\n\t\t}\n\n\t\tcout << acnt << \" \" << ocnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<queue>\n#include<functional>\n#include<tuple>\n#include<iomanip>\n#include<stack>\n#include<cmath>\n#define ll long long\n#define INF 1000000007\n#define N 1000000\nusing namespace std;\nint main() {\n\tint x = 2,dp[N+1],odddp[N+1];\n\tdp[0] = odddp[0] = 0;\n\tfor (int i = 1; i <= N; ++i) dp[i] = odddp[i] = i;\n\twhile (1) {\n\t\tint y = x * (x + 1)*(x + 2) / 6;\n\t\tif (y > N) break;\n\t\tfor (int i = 0; i + y <= N; ++i) \n\t\t\tdp[i + y] = min(dp[i + y], dp[i] + 1);\n\t\tif (y % 2)\n\t\t\tfor (int i = 0; i + y <= N; ++i)\n\t\t\t\todddp[i + y] = min(odddp[i + y], odddp[i] + 1);\n\t\t++x;\n\t}\n\tint n;\n\twhile (cin >> n , n) {\n\t\tcout << dp[n] << \" \" << odddp[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(void){\n  int size;\n  vector<ll> v(200);\n  for(ll i=1;;i++){\n    if((i*(i+1)*(i+2))/6 > 1000000) break;\n    v[i-1] = (i*(i+1)*(i+2))/6;\n    size = i-1;\n  }\n\n  while(1){\n  int x; cin >> x;\n  if(x == 0) break;\n  int ans = 0;\n  int dp[1000000]; // dp[i] := number of tetrahedron with value i\n  fill(dp, dp+x+1, INT_MAX);\n  dp[0] = 0;\n\n  for(int i = 0; i <= x; i++){\n    for(int j = 0; j < size; j++){\n      if(i+v[j] > x) continue;\n      dp[i + v[j]] = min(dp[i+v[j]], dp[i]+1);\n    }\n  }\n\n  cout << dp[x] << \" \";\n\n  fill(dp, dp+x+1, INT_MAX);\n  dp[0] = 0;\n  for(int i = 0; i <= x; i++){\n    for(int j = 0; j < size; j++){\n      if(i+v[j] > x) continue;\n      if(v[j] % 2 == 0) continue;\n      dp[i + v[j]] = min(dp[i+v[j]], dp[i]+1);\n    }\n  }\n  cout << dp[x] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint dp[200][1000001],Odp[200][1000001];\nint Tn[200],OTn[200];    //Pollocks numberの生成\n\nint main(){\n    int count = 0;\n    for(int i = 1;i < 200;i++){\n        Tn[i-1] = i * (i + 1) * (i + 2) / 6;\n        if(Tn[i-1] % 2 == 1){\n            OTn[count] = Tn[i-1];\n            count++;\n        }\n    }\n    int n = 1000000;\n\n    //正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        dp[0][j] = j;\n    int k;\n    for(int i = 1;Tn[i] <= n;i++)\n        for(int j = 1;j <= n;j++){\n            if(j < Tn[i])\n                dp[i][j] = dp[i-1][j];\n            else dp[i][j] = min(dp[i-1][j],dp[i][j-Tn[i]] + 1);\n            k = i;\n        }\n\n    //正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        Odp[0][j] = j;\n    int k1;\n    for(int i = 1;OTn[i] <= n;i++)\n        for(int j = 1;j <= n;j++){\n            if(j < OTn[i])\n                Odp[i][j] = Odp[i-1][j];\n            else Odp[i][j] = min(Odp[i-1][j],Odp[i][j-OTn[i]] + 1);\n            k1 = i;\n        }\n    while(cin >> n,n)\n        cout << dp[k][n] << ' ' <<  Odp[k1][n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint f[1000000];\n\nint main()\n{\n\tint t_num[182];\n\tint t_num_odd[182];\n\t\n\tint k=0;\n\tfor (int i=1;i<182;++i)\n\t{\n\t\tt_num[i-1] = i*(i+1)*(i+2)/6;\n\t\tif (t_num[i-1] % 2 == 1)\n\t\t{\n\t\t\tt_num_odd[k] = t_num[i-1];\n\t\t\t++k;\n\t\t}\t\t\n\t}\n\t\n\tint n;\n\tcin >> n;\n\t\n\twhile (n)\n\t{\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tfor (int j=0;j<181;++j)\n\t\t\t{\n\t\t\t\tif (i>=t_num[j]) f[i] = min(f[i],f[i-t_num[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << \" \";\n\t\t\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tfor (int j=0;j<k;++j)\n\t\t\t{\n\t\t\t\tif (i>=t_num_odd[j]) f[i] = min(f[i],f[i-t_num_odd[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << endl;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t\tif (dp[i][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=1000000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t\tif (dp[i%2][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define N 1000010\n\nint t1[200];\nint t2[200];\nint dp1[N] = {0};\nint dp2[N] = {0};\n\nint main(){\n\tint i,j,k=2,s;\n\t\n\tt1[1] = 1; t2[1] = 1;\n\tfor(i = 2; i < N; i++){\n\t\tt1[i] = t1[i-1] * (i+2) / (i-1);\n\t\tif(t1[i] > N) break;\n\t\tdp1[t1[i]] = 1;\n\t\tif(t1[i]%2){ dp2[t1[i]] = 1; t2[k++] = t1[i];}\n\t}\n\n\tfor(i = 2, dp1[1] = dp2[1] = 1; i <= N; i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j = 1; t2[j] < i; j++){\n\t\t\tif(!dp2[i] || (1 + dp2[i-t2[j]]) < (dp2[i])){\n\t\t\t\tdp2[i] = 1 + dp2[i-t2[j]];\n\t\t\t}\n\t\t}\n\t\tif(dp1[i]) continue;\n\t\tfor(j = 1; t1[j] < i; j++){\n\t\t\tif(!dp1[i] || (1 + dp1[i-t1[j]]) < (dp1[i])){\n\t\t\t\tdp1[i] = 1 + dp1[i-t1[j]];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(cin >> s, s)\n\t\tcout << dp1[s] << \" \" << dp2[s] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint dp1[MAX+1],dp2[MAX+1];\n\nint main(){\n    //INFで初期化\n    for(int i = 1;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n * 2) /6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;  //ポロック数の生成\n        for(int i = a;i <= MAX;i++){     //正四面体数の個数dp(a以下は必要ない)\n            dp1[i] = min(dp1[i],dp1[i-a] + 1);  //更新しないor左側から更新する\n\n        if(a % 2 == 0)continue;     //偶数の時は次のroopへ\n        for(int i = a;i <= MAX;i++){     //奇数の正四面体数の個数dp(a以下は必要ない)\n            dp2[i] = min(dp2[i],dp2[i-a] + 1);  //更新しないor左側から更新する\n        }\n    }\n\n    //入出力\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#define dMAX 1000000\nusing namespace std;\n\nint n;\nint p[200],pSize, vSize;\nint dp1[dMAX];\nint dp2[dMAX];\nint i,j;\n\n\nint main(){\n\n  for( pSize=0; pSize<200 ; pSize++ ){\n    p[pSize]= pSize*(pSize+1)*(pSize+2)/6;\n  }\n  \n\n  fill_n( dp1,dMAX,INT_MAX );\n  fill_n( dp2,dMAX,INT_MAX );\n\n  dp1[0]=0;\n  for( i=1;i<pSize;i++){\n    for( j=p[i];j<dMAX;j++ )\n      dp1[j] = min( dp1[j],dp1[ j-p[i] ]+1 );\n  }\n\n  dp2[0]=0;\n  for( i=1;i<pSize;i++){\n    if( p[i] & 0x01 ){\n      for( j=p[i];j<dMAX;j++ )\n\tdp2[j] = min( dp2[j],dp2[ j-p[i] ]+1 );\n    }\n  }\n\n  while( cin>>n && n )\n    cout << dp1[ n ] << \" \" << dp2[ n ] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n,res =inf;\nconst int MAX = 1000000;\nint solve(int a,int b,int c,vector<int> v, int** dp){\n  if(dp[b][a] == 1) return b;\n  else if(dp[b][a] == -1) return inf;\n  dp[b][a] = -1;\n  if(b == 0) res = inf;\n  if(a == n){\n    res = min(res,b);\n    dp[b][a] = 1;\n    return b;\n  }\n  if(a > n || res < b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v,dp),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < MAX){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    {\n      const size_t s = suqnum.size();\n      int dp[s][MAX] = {};\n      int *arg[s];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb1,suqnum,arg) << \" \";\n    }\n    {\n      const size_t s = odd.size();\n      int dp[s][MAX] = {};\n      int *arg[s];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb2,odd,arg)<<endl;\n    }\n//     queue<pii> q;\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb1,suqnum.size()){\n//         if(p.se+suqnum[i] == n){\n//           cout << p.fi+1<< \" \";\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+suqnum[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n//         }\n//       }\n//     }\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb2,odd.size()){\n//         if(p.se+odd[i] == n){\n//           cout << p.fi+1<< endl;\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+odd[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+odd[i]));\n//         }\n//       }\n//     }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n;\n    vector<int>v;\n    for(int i=1;(i*(i+1)*(i+2))/6 < 1e6;++i){\n        v.push_back((i*(i+1)*(i+2))/6);\n    }\n    while(cin>>n,n){\n        vector<int>dp(1e6,1e9);\n        vector<int>dp1(1e6,1e9);\n        dp[0]=0;\n        dp1[0]=0;\n        for(int i=0;i<=n;++i){\n            for(int j=0;i+v[j]<1e6 && j<v.size();++j){\n                dp[i+v[j]]=min(dp[i]+1,dp[i+v[j]]);\n                if(v[j]%2==0)continue;\n                dp1[i+v[j]]=min(dp1[i]+1,dp1[i+v[j]]);\n            }\n        }\n        cout<<dp[n]<<\" \"<<dp1[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nvoid append(int t, int n, int table[]) {\n    table[t] = 1;\n    for (int i=0; i<=n-t; i++) {\n        if (table[i] < 0) {\n            continue;\n        }\n        if (table[i+t] < 0) {\n            table[i+t] = table[i]+1;\n        }\n        else {\n            table[i+t] = min(table[i]+1, table[i+t]);\n        }\n    }\n}\n\nint main() {\n    int n;\n    int dp[1000000];\n    int dp_odd[1000000];\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n        for (int i=0; i<=n; i++) {\n            dp[i] = -1;\n            dp_odd[i] = -1;\n        }\n        for (int i=0; true; i++) {\n            int t = i*(i+1)*(i+2)/6;\n            if (t > n) {\n                break;\n            }\n            append(t, n, dp);\n            if (t%2 == 1) {\n                append(t, n, dp_odd);\n            }\n        }\n        cout << dp[n] << ' ' << dp_odd[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int             long long\n#define rep(i, n)       for(int i=0; i<(n); ++i)\n#define REP(i, d, n)    for(int i=(d); i<(n); ++i)\n#define all(v)          v.begin(), v.end()\nusing P = pair<int, int>;\n\ntemplate<class T> \ninline bool chmax(T &a, const T &b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> \ninline bool chmin(T &a, const T &b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return 0;\n}\n\nsigned main() {\n\n    vector<int> tetra;\n    for(int i = 1; ; ++i){\n        int p = i*(i+1)*(i+2) / 6;  // 連続する3つの整数の積は6の倍数なので必ず割り切れる\n        if(p > 1e6){\n            break;\n        }\n        tetra.push_back(p);\n    }\n    int m = tetra.size();\n    \n    vector<int> dp(1e6 + 1, 1LL << 60), dp_odd(1e6 + 1, 1LL << 60);\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    rep(i, 1e6+1){\n        rep(j, m){\n            if(i + tetra[j] >= 1e6){\n                break;\n            }\n            chmin(dp[i+tetra[j]], dp[i]+1);\n            if(tetra[j] % 2){   // 正四面体数が奇数の時\n                chmin(dp_odd[i+tetra[j]], dp_odd[i]+1);\n            }\n        }\n    }\n    \n    int n;\n    while(true){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << dp[n] << ' ' << dp_odd[n] << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a) for (int (i) = 0; (i) < (a); (i)++)\n#define reps(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define MP(a, b) make_pair((a), (b))\n#define pb(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n\n#define MAX 1000000\n\nint dp[MAX];\nint dpk[MAX];\nvector<int> v;\nvector<int> vk;\nint vn = 0;\nint s = 1;\n\n\nint main()\n{\n\tv.pb(1);\n\tvk.pb(1);\n\tfor (int i = 2; ;i++) {\n\t\ts += i;\n\t\tif (s + v[vn] >= MAX) break;\n\t\tv.pb(s+v[vn]);\n\t\tvn++;\n\t\tif (v[vn] % 2) vk.pb(v[vn]);\n\t}\n\tv.pb(MAX+1);\n\tvk.pb(MAX+1);\n\treps(i, 1, MAX) {\n\t\tdp[i] = dp[i-1] + 1;\n\t\tfor (int j = 1; v[j] <= i; j++) {\n\t\t\tdp[i] = min(dp[i], dp[i-v[j]] + 1);\n\t\t}\n\t}\n\treps(i, 1, MAX) {\n\t\tdpk[i] = dpk[i-1] + 1;\n\t\tfor (int j = 1; vk[j] <= i; j++) {\n\t\t\tdpk[i] = min(dpk[i], dpk[i-vk[j]] + 1);\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\twhile(n) {\n\t\tcout << dp[n] << \" \" << dpk[n] << endl;\n\t\tcin >> n;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int a,b,c,n,x[9999],y[9999],X[1000001],Y[1000001];\n  a=b=c=1;\n  while(1){\n    x[a]=c*(c+1)*(c+2)/6;\n    if(x[a]>1000000)break;\n    a++;\n    if(x[a-1]%2==1){\n      y[b]=x[a-1];\n      b++;\n    }\n    c++;\n  }\n\n  X[0]=0;\n  for(int i=1;i<=1000000;i++)X[i]=i;\n  for(int i=1;i<a;i++){\n    for(int j=x[i];j<=1000000;j++){\n      if(X[j]>X[j-x[i]]+1)X[j]=X[j-x[i]]+1;\n    }\n  }\n\n  Y[0]=0;\n  for(int i=1;i<=1000000;i++)Y[i]=i;\n  for(int i=1;i<b;i++){\n    for(int j=y[i];j<=1000000;j++){\n      if(Y[j]>Y[j-y[i]]+1)Y[j]=Y[j-y[i]]+1;\n    }\n  }\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cout<<X[n]<<' '<<Y[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX = 1000000+10;\nstatic const int INF = 1<<30;\n\nint main(){\n    vector<int> dp(MAX,INF);\n    vector<int> odd(MAX,INF);\n    dp[0] = odd[0] = 0;\n    for(int i=1; ; i++){\n        int cur = i*(i+1)*(i+2)/6;\n        if(cur > MAX) break;\n        for(int j=cur; j<MAX; j++){\n            dp[j] = min(dp[j],dp[j-cur]+1);\n            if(cur % 2 != 0) odd[j] = min(odd[j],odd[j-cur]+1);\n        }\n    }\n\n    int N;\n    \n    while(cin>>N){\n        if(N == 0) break;\n        cout<<dp[N]<<\" \"<<odd[N]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[84];\n    int b[22];\n    int t1[1000010],t2[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n\n        for(i = 0; i <= 100005; i++){\n            t1[i] = i;\n        }\n\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= 100005; j++){\n                if(t1[j] > t1[j - a[i]] + 1){\n                    t1[j] = t1[j -a[i]] + 1;\n                }\n            }    \n        }        \n\n        for(i = 0; i <= 100005; i++){\n            t2[i] = i;\n        }\n        \n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= 100005; j++){\n                if(t2[j] > t2[j - b[i]] + 1){\n                    t2[j] = t2[j - b[i]] + 1;\n                }\n            }\n        }\n            \n\n\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << t1[n] << \" \" << t2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst int INF_N = 1e+9;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\n//繰り返し二乗法\nll mod_pow(ll a, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\n//逆元(Eucledean algorithm)\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nusing mP = pair<modint, modint>;\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n\nll dp1[1000005];\nll dp2[1000005];\n\nvoid solve() {\n    rep(i, 1000005) dp1[i] = dp2[i] = INF;\n    dp1[0] = dp2[0] = 0;\n    rep1(i, 1000004){\n        rep1(j, 300){\n            ll tmp = j*(j+1)*(j+2)/6;\n            if(i - tmp >= 0){\n                dp1[i] = min(dp1[i], dp1[i-tmp]+1);\n                if(tmp%2) dp2[i] = min(dp2[i], dp2[i-tmp]+1);\n            }\n            // dp1[i] = min(dp1[i], dp1[i-1]+1);\n            // dp2[i] = min(dp2[i], dp2[i-1]+1);\n        }\n    }\n    int a;\n    while(cin >> a, a){\n        cout << dp1[a] << \" \" << dp2[a] << endl;\n    }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  //cout << fixed << setprecision(10);\n  //init_f();\n  //init();\n  //int t; cin >> t; rep(i, t)solve();\n  solve();\n//   stop\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INF 1<<28\nusing namespace std;\n\nint p[1111111];\nint memo[1111111];\nint memo2[1111111];\n\nint solve(int n){\n  \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n\n  int ans = INF;\n  for(int i=199;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n\n  int ans = INF;\n  for(int i=0;p[i]<=n;i++) if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n\n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n\n  for(int i=0;i<200;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nconst int INF=1e9;\nint main(){\n    vector<int>S;\n    for(int i=1;true;i++){\n        int val=i*(i+1)*(i+2)/6;\n        if(val<=1000000)S.push_back(val);\n        else break;\n    }\n    fill_n(*dp,2*1000001,INF);\n    dp[0][0]=dp[1][0]=0;\n    for(int i=1;i<=1000000;i++){\n        for(int j=0;j<S.size();j++){\n            int val=S[j];\n            if(i-val<0)continue;\n            dp[0][i]=min(dp[0][i],dp[0][i-val]+1);\n            if(val&1)dp[1][i]=min(dp[1][i],dp[1][i-val]+1);\n        }\n    }\n    int n;\n    while(scanf(\"%d\",&n),n){\n        printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <cmath>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#define FOR(i, a) for(i = 0; i < (a); i++)\n#define FORM(i, a) for(i = (a) i >= 0; i--)\n#define INF 100000\nusing namespace std;\nint c[1000], odd[1000];\nint mini[180];\n\nint main(){\nint i, j, W, minimum, l;\n \n\n   for(i = 1; i <= 180; i++){\n\t   c[i] = (i*(i+1)*(i+2))/6;\n   }\n   j = 1;\n   for(i = 1; i <= 180; i++){\n\t   if(c[i] % 2 == 1){\n\t\t   odd[j] = c[i];\n\t\t   j += 1;\n\t   }\n   }\n\n\n   cin >> W;\n\n   while(W != 0){\n\t   minimum = 10000000;\n\t   for(i = 1; i <= 180; i++){\n\t\t   l = W;\n\t\t   if(c[i] > W){\n\t\t\t   break;\n\t\t   }\n\t\t for(j = i; j > 0; j--){\n\t\t\t mini[i] += l / c[j];\n\t\t\t l %= c[j];\n\t\t\t\n\t\t }\n\n\t\t  minimum = min(minimum, mini[i]);\n\t   }\n\n\t   cout << minimum << \" \";\n\t   minimum = 1000000;\n\t   FOR(i, 181){\n\t\t   mini[i] = 0;\n\t   }\n\t      for(i = 1; i <= 180; i++){\n\t\t\t  l = W;\n\t\t   if(odd[i] > W){\n\t\t\t   break;\n\t\t   }\n\t\t for(j = i; j > 0; j--){\n\t\t\t mini[i] += l/odd[j];\n\t\t\t l %= odd[j];\n\t\t\t\n\t\t }\n\n\t\t  minimum = min(minimum, mini[i]);\n\t   }\n\t\t  \n     cout << minimum << endl;\n\t   FOR(i, 181){\n\t\t   mini[i] = 0;\n\t   }\n       \n\t   cin >> W;\n\n   }\n   \n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    int lower,size,rest;\n    State(int lower,int size,int rest) : lower(lower),size(size),rest(rest) {};\n};\n\nint main(){\n    vector<int> v;\n    vector<int> odd;\n    for(int i=1;;i++){\n        int c = i*(i+1)*(i+2)/6;\n        if(c > 1000000) break;\n        v.push_back(c);\n        if(c % 2 == 1) odd.push_back(c);\n    }\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        queue<State> que;\n        que.push(State(0,0,n));\n        int ret;\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                ret = s.size;\n                break;\n            }\n            for(int i=s.lower;v[i] <= s.rest;i++){\n                que.push(State(i,s.size+1,s.rest-v[i]));\n            }\n        }\n        int oret;\n        que = queue<State>();\n        que.push(State(0,0,n));\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                oret = s.size;\n                break;\n            }\n            for(int i=lower_bound(all(odd),s.rest)-odd.begin();\n                i>=0;i--){\n                que.push(State(i,s.size+1,s.rest-odd[i]));\n            }\n            //for(int i=s.lower;odd[i] <= s.rest;i++){\n        }\n        cout << ret << \" \" << oret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nvector<int> P;\nvector<int> oddP;\nint memo[1001001];\nint mome[1001001];\n\nvoid hoge(){\n\n    for(int i=1; ; i++){\n        int p=i*(i+1)*(i+2)/6;\n        if(p>=1001001) break;\n        P.push_back(p);\n    }\n    for(int i=0; i<P.size(); i++){\n        memo[P[i]]=1;\n        if(P[i]%2) mome[P[i]]=1;\n    }\n}\n\nint rec(int n, bool odd){\n\n    if(odd){\n        if(mome[n]!=0) return mome[n];\n    }else{\n        if(memo[n]!=0) return memo[n];\n    }\n    int ret=1001001;\n    for(int i=0; n-P[i]>0; i++){\n        if(odd&&(P[i]%2==0)) continue;\n        ret=min(ret, rec(n-P[i], odd)+1);\n    }\n    if(odd){\n        return mome[n]=ret;\n    }else{\n        return memo[n]=ret;\n    }\n\n}\n\nint main(){\n\n    hoge();\n    bool odd=true;\n    while(1){\n        int N;\n        cin>> N;\n        if(!N) break;\n\n        cout<< rec(N, !odd)<<\" \";\n        cout<< rec(N, odd)<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX (1000000)\n#define INF (1<<30)\n\nint main() {\n  \n  int dp_all[MAX+2], dp_odd[MAX+2];\n  \n  fill(dp_all, dp_all+MAX+1, INF);\n  fill(dp_odd, dp_odd+MAX+1, INF);\n  \n  dp_all[0] = dp_odd[0] = 0;\n  \n  for(int i=1; ; i++) {\n    int num = i*(i+1)*(i+2) / 6;\n    if(num > MAX) break;\n    for(int j=num; j<=MAX; j++) {\n      dp_all[j] = min(dp_all[j], dp_all[j-num]+1);\n      if(num % 2)\n\tdp_odd[j] = min(dp_odd[j], dp_odd[j-num]+1);\n    }\n  }\n  \n  int n;\n  while(cin >> n && n) {\n    cout << dp_all[n] << \" \" << dp_odd[n] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<utility>\n#include<string.h>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define CHMIN(a,b) (a) = min((a),(b))\n#define CHMAX(a,b) (a) = max((a),(b))\n\nint main()\n{\n    int n;\n    while(1==1)\n    {\n        scanf(\"%d\\n\",&n);\n        if(n==0)return 0;\n        int dp[1000005]={};\n        for(int i=1;i<1000005;i++)dp[i]=-1;\n        long long int he[250]={};\n        long long int ohe[63]={};\n        REP(i,250)he[i]=i*(i+1)*(i+2)/6;\n        REP(i,63)ohe[i]=he[i*4+1];\n        for(int i=1;i<=5;i++)\n        {\n            REP(j,n)\n            {\n                if(dp[j]==i-1)\n                {\n                    REP(k,250)\n                    {\n                        if(j+he[k]<=n&&dp[j+he[k]]==-1)\n                        {\n                            dp[j+he[k]]=i;\n                        }\n                    }\n                }\n            }\n            if(dp[n]!=-1)break;\n        }\n        printf(\"%d \",dp[n]);\n        REP(i,1000005)dp[i]=-1;\n        dp[0]=0;\n        for(int i=1;i<=55;i++)\n        {\n            REP(j,n)\n            {\n                if(dp[j]==i-1)\n                {\n                    REP(k,63)\n                    {\n                        if(j+ohe[k]<=n&&dp[j+ohe[k]]==-1)\n                        {\n                            dp[j+ohe[k]]=i;\n                        }\n                    }\n                }\n            }\n            if(dp[n]!=-1)break;\n        }\n        printf(\"%d\\n\",dp[n]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-14\n\n#define all(v) v.begin(),v.end()\n#define INF 1<<30\n#define mp\n#define pb push_back\n\n#define fi\n#define se\n\n#define each\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\n\nint f(int n, int m, vi a){\n\tvi t(n+1,INF);\n\tt[0] = 0;\n\trep(i,m){\n\t\tREP(j,a[i],n+1){\n\t\t\tt[j] = min(t[j],t[j-a[i]]+1);\n\t\t}\n\t}\n\treturn t[n];\n}\n\nint main(){\n\tvi a;\n\tvi ao;\n\tREP(i,1,200){\n\t\ta.pb(i*(i+1)*(i+2)/6);\n\t}\n\trep(i,a.size()){\n\t\tif(a[i]%2==1) ao.pb(a[i]);\n\t}\n\n\t// rep(i,a.size()) cout<<a[i]<<endl;\n\t// cout<<\"=--\"<<endl;\n\t// rep(i,ao.size()) cout<<ao[i]<<endl;\n\n\twhile(1){\n\t\tint n; cin>>n;\n\t\tif(n==0) break;\n\t\tcout<<f(n,a.size(),a)<<\" \"<<f(n,ao.size(),ao)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nusing P   = pair<ll, ll>;\nusing mat = vector<vector<ll>>;\n\nvoid IOS() { ios::sync_with_stdio(false), cin.tie(0); }\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-12;\n\ntemplate <typename T>\nvoid dump(T x) { cout << x << endl; }\nvoid dumpf(ld x, int t) { cout << setprecision(t) << fixed << x << endl; }\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\ninline ll mod(ll a, ll b) {\n\tif (a > 0) return a % b;\n\tif (a % b == 0) return 0;\n\tll x = -a / b + 1;\n\ta += x * b;\n\treturn a % b;\n}\nll powm(ll a, ll b, ll c) {\n\tif (b == 0)\n\t\treturn 1;\n\telse if (b % 2 == 0) {\n\t\tll d = powm(a, b / 2, c);\n\t\treturn (d * d) % c;\n\t} else\n\t\treturn (a * powm(a, b - 1, c)) % c;\n}\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\n//ll dx[4] = {1, 0, -1, 0};\n//ll dy[4] = {0, 1, 0, -1};\n\nconst ll MAX = 1e6;\nll dp[MAX];\nll dp2[MAX];\nint main() {\n\tIOS;\n\tvector<ll> a, a2;\n\tll n   = 1;\n\tll tmp = 2;\n\twhile (tmp < 1e6) {\n\t\ttmp = n * (n + 1) * (n + 2) / 6;\n\t\ta.push_back(tmp);\n\t\tif (tmp % 2 == 1) a2.push_back(tmp);\n\t\tn++;\n\t}\n\tFill(dp, INF);\n\tFill(dp2, INF);\n\tll m  = a.size();\n\tll m2 = a2.size();\n\tdp[0] = dp2[0] = 0;\n\tfor (int i = 1; i <= MAX; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i >= a[j]) dp[i] = min(dp[i], dp[i - a[j]] + 1);\n\t\t}\n\t}\n\tfor (int i = 1; i <= MAX; i++) {\n\t\tfor (int j = 0; j < m2; j++) {\n\t\t\tif (i >= a2[j]) dp2[i] = min(dp2[i], dp2[i - a2[j]] + 1);\n\t\t}\n\t}\n\n\tll i = 1;\n\twhile (i) {\n\t\tcin >> i;\n\t\tif (i == 0) break;\n\t\tcout << dp[i] << \" \" << dp2[i] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<map>\nusing namespace std;\nint a[1001],ta[1001],tta[1001];\nint dp[1000021],dp2[1000010];\nconst int INF=99999999;\nint main(){\n\ta[1]=1,ta[1]=1,tta[1]=1;\n\tint cnt=1;\n\tfor(int i=2;i<=1000;i++)a[i]=i+a[i-1];\n\tfor(int i=2;i<=1000;i++){\n\tta[i]=a[i]+ta[i-1];\n\tif(ta[i]%2==1)tta[++cnt]=ta[i];\n\t}\n\n\tfill(dp,dp+1000001,INF);\n\tfill(dp2,dp2+1000001,INF);\n\tdp[0]=0,dp2[0]=0;\n\tfor(int i=1;i<=200;i++){\n\t\tfor(int j=1;j<=1000000;j++){\n\t\tif(j>=ta[i])dp[j]=min(dp[j],dp[j-ta[i]]+1);\n\t\t}//\n\t}//endfor\n\tfor(int i=1;i<=100;i++){\n\t\tfor(int j=1;j<=1000000;j++){\n\t\tif(j>=tta[i])dp2[j]=min(dp2[j],dp2[j-tta[i]]+1);\n\t\t}\n\t}//endfor\n\tint n;\n\twhile(true){\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}//endwhile\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n   // cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX + 1],dp2[MAX + 2];\n\nint main(){\n    for(int i = 1; i <= MAX; i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1; n * (n + 1) * (n + 2) / 6 <= MAX; n++){\n        int a = n * (n + 1) * (n + 2) / 6;\n        for(int i = a; i <= MAX; i++){\n            dp1[i] = min(dp1[i],dp1[i - a] + 1);\n        }\n        if(a % 2 == 0){\n            continue;\n        }\n        for(int i = a; i <= MAX; i++){\n            dp2[i] = min(dp2[i],dp2[i -a] + 1);\n        }\n    }\n\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"algorithm\"\n#include \"cmath\"\n#include \"iostream\"\n#include \"map\"\n#include \"string\"\n#include \"unordered_map\"\n#include \"vector\"\nconstexpr int MOD = 1000000007;\nconstexpr int INF = 1000000000;\nusing namespace std; // std::を省略して書くことができる\n\nint dp[1000001][2];\nint main() {\n  for (int i = 0; i < 1e6; i++) {\n    dp[i][0] = INF;\n    dp[i][1] = INF;\n  }\n  vector<int> list;\n  vector<int> list_odd;\n  for (int i = 1; i < INF; i++) {\n    int SUM = i * (i + 1) * (i + 2) / 6;\n    if (SUM <= 1e6) {\n      list.push_back(SUM);\n      if (SUM % 2 == 1)\n        list_odd.push_back(SUM);\n    } else {\n      break;\n    }\n  }\n  dp[0][0] = 0;\n  dp[0][1] = 0;\n  for (int i = 0; i < 1e6 + 1; i++) {\n    for (int j = 0; j < 179; j++) {\n      for (int k = 1; k < 10; k++) {\n        if (i + list[j] * k < 1e6 + 1) {\n          dp[i + list[j] * k][0] = min(dp[i + list[j] * k][0], dp[i][0] + k);\n        } else {\n          break;\n        }\n      }\n    }\n\n    for (int j = 0; j < 44; j++) {\n      for (int k = 1; k < 10; k++) {\n        if (i + list_odd[j] * k < 1e6 + 1) {\n          dp[i + list_odd[j] * k][1] =\n              min(dp[i + list_odd[j] * k][1], dp[i][1] + k);\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  int n;\n  cin >> n;\n  while (n != 0) {\n    cout << dp[n][0] << \" \" << dp[n][1] << endl;\n    cin >> n;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[10000];\n    fill(dp,dp + x+1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[201]={0},b[150]={0},k=0,i,j,n;\n  for(i=1;i<201;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<201;j++)if(a[j]%2)b[k++]=a[j];\n    int c[1500001]={0,1,2,3},d[1500001];\n  for(i=1;i<198;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n\nint main(void){\n\tint i, j, n ,small1, small2;\n\tint dp1[1000000],dp2[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp1[i] = dp2[i] = INF;\n\n\t\tdp1[0] = dp2[0] = 0;\n\t\tsmall1 = small2 = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif((small1 > dp1[i] || small2 > dp2[i]) && (dp1[i] != INF || dp2[i] != INF)){\n\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\tif(dp1[(j * (j + 1) * (j + 2)) / 6 + i] > dp1[i] + 1 && dp1[i] != INF)\n\t\t\t\t\t\tdp1[(j * (j + 1) * (j + 2)) / 6 + i] = dp1[i] + 1;\n\t\t\t\t\tif(dp2[(j * (j + 1) * (j + 2)) / 6 + i] > dp2[i] + 1 && ((j * (j + 1) * (j + 2)) / 6) % 2 == 1 && dp2[i] != INF)\n\t\t\t\t\t\tdp2[(j * (j + 1) * (j + 2)) / 6 + i] = dp2[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(small1 > dp1[n])\n\t\t\t\tsmall1 = dp1[n];\n\t\t\tif(small2 > dp2[n])\n\t\t\t\tsmall2 = dp2[n];\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(ll i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(ll i=(a),i##_cond=(b);i<i##_cond;++i)\n#define ROF(i,a,b) for(ll i=(a)-1,i##_cond=(b);i>=i##_cond;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define UNIQUE(v) v.erase(unique(all(v)),v.end())\n#define SUM(a) accumulate(all(a),0)\n#define sz(x) ((ll)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<ll,ll> pii;\n\nconst ll inf = 1ll<<62;\nconst ll mod = 1e9+7;\n\nint main(){\n#define int ll\n  int tmp = 1;\n  vi a, b;\n  while(1){\n    int x = tmp * (tmp + 1) * (tmp + 2) / 6;\n    if(x >= 1000000) break;\n    a.pb(x);\n    if(x & 1) b.pb(x);\n    tmp++;\n  }\n  dump(a,b);\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    vi dpa(n+1,inf),dpb(n+1,inf);\n    dpa[0] = 0;\n    dpb[0] = 0;\n    rep(i,n){\n      for(int j = 0; a[j] <= i + 1; ++j)\n\tfor(int k = 1; a[j] * k <=  i + 1; ++k)\n\t  dpa[i+1] = min(dpa[i+1], dpa[i + 1 - k * a[j]] + k);\n      for(int j = 0; b[j] <= i + 1; ++j)\n\tfor(int k = 1; b[j] * k <= i + 1; ++k)\n\t  dpb[i+1] = min(dpb[i+1], dpb[i + 1 - k * b[j]] + k);\n    }\n    cout << dpa[n] << \" \" << dpb[n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define INF 1000000\n\nint t(int x) { return x*(x+1)*(x+2)/6; }\n\nint dp[1000010];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  Vi one, two, odd;\n  for (int i = 1; t(i) <= 1000000; i++) {\n    one.push_back(t(i));\n    if (t(i)%2) odd.push_back(t(i));\n  }\n\n  for (int a : one) {\n    for (int b : one) {\n      two.push_back(a+b);\n    }\n  }\n  sort(ALL(two));\n\n  REP(i, 1000001) dp[i] = INF;\n  dp[0] = 0;\n  REP(i, 1000000) {\n    for (int a : odd) {\n      if (i+1-a >= 0)\n\tdp[i+1] = min(dp[i+1-a]+1, dp[i+1]);\n    }\n  }  \n\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    if (n == *lower_bound(ALL(one), n)) {\n      cout << 1;\n    } else if (n == *lower_bound(ALL(two), n)) {\n      cout << 2;\n    } else {\n      bool flag = false;\n      for (int a : one) {\n\tif (n - a == *lower_bound(ALL(two), n - a)) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if (flag) {\n\tcout << 3;\n      } else {\n\tfor (int a : two) {\n\t  if (n - a == *lower_bound(ALL(two), n - a)) {\n\t    flag = true;\n\t    break;\n\t  }\n\t}\n\tcout << (flag ? 4 : 5);\n      }\n    }\n\n    cout << ' ' << dp[n] << endl;\n\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n;\n  int table[200]={0};\n  int table_odd[200]={0};\n  int dp1[1000000]={0};\n  int dp2[1000000]={0};\n  for(int i=0,c=0;i<200;i++){\n    table[i]=(i+1)*(i+2)*(i+3)/6;\n    if(table[i]%2==1){\n      table_odd[c++]=table[i];\n    }\n  }\n  for(int i=0;i<1000000;i++){\n    int min1=1<<30;\n    int min2=1<<30;\n    for(int j=0;j<200;j++){\n      if(table[j]!=0 && i>=table[j]){\n\tmin1=min(min1,dp1[i-table[j]]+1);\n      }\n      if(table_odd[j]!=0 && i>=table_odd[j]){\n\tmin2=min(min2,dp2[i-table_odd[j]]+1);\n      }\n    }\n    if(min1 == 1<<30) min1 = 0;\n    if(min2 == 1<<30) min2 = 0;\n\n    dp1[i]=min1;\n    dp2[i]=min2;\n  }\n  while(cin>>n,n){\n    cout<<dp1[n]<<' '<<dp2[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define P pair<int,int>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define endl '\\n'\n#define ll long long\n\n#define INF 1e9;\n#define N 1001000\n\nvector<int> A, B, odd;\nint dp1[N], dp2[N];\n\nvoid init(){\n    A.push_back(1);\n    B.push_back(1);\n    odd.push_back(1);\n\n    for(int i = 1;; i++){\n        int x = A[i-1] + (i + 1);\n        if(x > N) break;\n        else A.push_back(x);\n    }\n    for(int i = 1;; i++){\n        int x = B[i-1] + A[i];\n        if(x > N) break;\n        else B.push_back(x);\n        if(x % 2 == 1) odd.push_back(x);\n    }\n\n    rep(i,N) dp1[i] = INF;\n    rep(i,N) dp2[i] = INF;\n    dp1[0] = 0, dp2[0] = 0;\n    for(int i = 0; i < B.size(); i++){\n        for(int j = 1; j < N; j++){\n            if(j - B[i] >= 0){\n                dp1[j] = min(dp1[j],dp1[j - B[i]] + 1);\n            }\n        }\n    }\n    for(int i = 0; i < odd.size(); i++){\n        for(int j = 1; j < N; j++){\n            if(j - odd[i] >= 0){\n                dp2[j] = min(dp2[j],dp2[j - odd[i]] + 1);\n            }\n        }\n    }\n}\n\nint main() {\n    init();\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//ライブラリゾーン！！！！\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//隣接リスト表現\n\tll to;\n\tld cost;\n};\nstruct E {//辺の情報を入れる変数\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\t/*if (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;*/\n\treturn ((a.x + 1)*(a.y + 1)) < ((b.x + 1)*(b.y + 1));\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//最大公約数\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad＝座標上の2点間の距離\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//等差数列の和\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll x, ll k, ll p) {//最大値、個数\n\tll sum = 1;\n\tfor (int i = 0; i < k; i++) {\n\t\tsum *= (x--);\n\t\tsum %= p;\n\t}\n\treturn sum;\n}//階乗(正）\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res*x%p;\n\t\tx = x*x%p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}//x^n%p\n //#define int long long\nconst long long Inf = 4523372036854775807;\nconst int inf = 1500000000;\n//----------------------------------------------------\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\nint a[3000000];\nint b[3000000];\nvector<int>c;\nsigned main() {\n\tint x = 1;\n\tfor (int i = 1; i < 2500000; i++) {\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\twhile (x*(x+1)*(x+2)/6<=1000000) {\n\t\tc.push_back(x*(x + 1)*(x + 2) / 6);\n\t\tx++;\n\t}\n\tfor (int i = c.size() - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j <= 1000000; j++) {\n\t\t\tif (j + c[i] > 1000000) break;\n\t\t\ta[j + c[i]] = min(a[j] + 1, a[j + c[i]]);\n\t\t\tif (c[i] % 2 == 1) b[j + c[i]] = min(b[j] + 1, b[j + c[i]]);\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tcout << a[n] << \" \" << b[n] << endl;\n\t}\n\tgetchar(); getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint x[9999999][2], a[999], b[999], s, n;\nint main() {\n\ta[0] = 1; b[0] = 1;\n\tfor (int i = 1; i < 300; i++) {\n\t\ta[i] = a[i - 1] + (i + 1)*(i + 2) / 2;\n\t\tif (a[i] % 2 == 1) {\n\t\t\ts++; b[s] = a[i];\n\t\t}\n\t}\n\tn = 1200000;\n\tmemset(x, 127, sizeof(x));\n\tx[0][0] = 0; x[0][1] = 0;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + a[i]][0] = min(x[j + a[i]][0], x[j][0] + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < 50; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + b[i]][1] = min(x[j + b[i]][1], x[j][1] + 1);\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> n; if (!n) { break; }\n\t\tcout << x[n][0] << x[n][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nsigned main(){\n    vector<int>csum;\n    int cnt = 1;\n    for(;;){\n        if(csum.size()&&csum.back()  > 1000000)break;\n        csum.push_back(cnt*(cnt+1)*(cnt+2)/6);\n        cnt ++;\n    }\n    csum.pop_back();\n    int dp1[1000000+1];\n    int dp2[1000000+1];\n    rep(i,1000000+1)dp1[i] = dp2[i] = INF;\n    dp1[0] = dp2[0] = 0;\n    rep(i,1000000+1){\n        if(dp1[i] == INF)continue;\n        rep(j,csum.size()){\n            if(i + csum[j] > 1000000 || csum[j]%2==0)continue;\n            cmin(dp1[i+csum[j]],dp1[i]+1);\n        }\n    }\n    rep(i,1000000+1){\n        if(dp2[i] == INF)continue;\n        rep(j,csum.size()){\n            if(i + csum[j] > 1000000)continue;\n            cmin(dp2[i+csum[j]],dp2[i]+1);\n        }\n    }\n    int n;\n    while(cin >> n,n){\n        cout << dp2[n] << \" \" << dp1[n] << endl;\n        \n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n//#define mt make_tuple\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tvi dp(1000010,inf);\n\tvi dp2(1000010,inf);\n\tdp[0]=dp2[0]=0;\n\tloop(i,1,180)rep(j,1000010){\n\t\tint t=i*(i+1)*(i+2)/6;\n\t\tif(j+t<1000010)dp[j+t]=min(dp[j+t],dp[j]+1);\n\t\tif(t%2&&j+t<1000010)dp2[j+t]=min(dp2[j+t],dp2[j]+1);\n\t}\n\tint n;\n\twhile(cin>>n,n)cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define NEXT(i,n) ((i+1)%(n))\nconst int N = 1000001;\nint dp1[N],dp2[N];  \nmain(){\n  vector<int> simen;\n  REP(i,1,N+1){\n    simen.push_back(i*(i+1)*(i+2)/6);\n    if (simen[i-1] > N+1)break;\n  }\n  \n  cout << simen.size() << endl;\n  dp1[0]=0;\n  dp2[0]=0;\n  REP(i,1,N){\n    dp1[i]=10000000;\n    dp2[i]=10000000;\n    rep(j,simen.size()){\n      if (i-simen[j] < 0)break;\n      dp1[i]=min(dp1[i],dp1[i-simen[j]]+1);\n      if (simen[j]%2 == 1){\n\tdp2[i]=min(dp2[i],dp2[i-simen[j]]+1);\n      }\n    }\n  }\n  \n  int n;\n  while(cin>>n && n){\n    cout << dp1[n] <<\" \" << dp2[n] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint num[100010];\n\tfor(int i=0; i< 100010; i++) num[i] = 10e8;\n\tnum[0] = 0;\n\tfor(int j=0; j< 100010; j++){\n\t\tfor(int i=0; i < 1000; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(10010 <= i*(i+1)*(i+2)/6+j) continue;\n\t\t\tnum[j+m] = min(num[j]+1, num[j+m]);\n\t\t}\n\t}\n\tint num2[100010];\n\tfor(int i=0; i< 100010; i++) num2[i] = 10e8;\n\tnum2[0] = 0;\n\tfor(int j=0; j< 100010; j++){\n\t\tfor(int i=0; i < 1010; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(m%2 == 0) continue;\n\t\t\tif(10010 <= i*(i+1)*(i+2)/6+j) continue;\n\t\t\tnum2[j+m] = min(num2[j]+1, num2[j+m]);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << num[n] << \" \" << num2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nvector<int> tetlist(const int n)\n{\n\tvector<int> ary;\n\tint i = 1;\n\twhile(1)\n\t{\n\t\tif(i*(i+1)*(i+2)/6 > n)\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tary.pb(i*(i+1)*(i+2)/6);\n\t\t  i++;\n\t\t}\n\t}\n\treturn ary;\n}\n\nvector<int> search(const int n)\n{\n\tvector<int> ary(n+1,INF);\n\tconst vector<int> tet = tetlist(n);\n\tconst int len = tet.size();\n\tary[0] = 0;\n\tFOR(i,1,n+1)\n\t{\n\t\tREP(j,len)\n\t\t{\n\t\t\tif(tet[j] > i)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tary[i] = min(ary[i],ary[i-tet[j]]+1);\n\t\t}\n\t}\n\treturn ary;\n}\n\nvector<int> tetlist_o(const int n)\n{\n\tvector<int> ary;\n\tint i = 1;\n\twhile(1)\n\t{\n\t\tif(i*(i+1)*(i+2)/6 > n)\n\t\t\tbreak;\n\t\telse if(((i*(i+1)*(i+2)/6) % 2) == 1)\n\t\t\tary.pb(i*(i+1)*(i+2)/6);\n\t\ti++;\n\t}\n\treturn ary;\n}\n\nvector<int> search_o(const int n)\n{\n\tvector<int> ary(n+1,INF);\n\tconst vector<int> tet = tetlist_o(n);\n\tconst int len = tet.size();\n\tary[0] = 0;\n\tFOR(i,1,n+1)\n\t{\n\t\tREP(j,len)\n\t\t{\n\t\t\tif(tet[j] > i)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tary[i] = min(ary[i],ary[i-tet[j]]+1);\n\t\t}\n\t}\n\treturn ary;\n}\n\nint main(void) {\n  vector<int> a1 = search(1000000);\n  vector<int> a2 = search_o(1000000);\n  while(1)\n  {\n  \tint n;\n  \tcin>>n;\n  \tif(!n)break;\n  \tcout<<a1[n]<<' '<<a2[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a)  (a).begin(),(a).end()\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<long long, long long> Pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long>> vvll;\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1LL << 30;\n\nint main(){\n  vi A(0);\n  vi dp1(1000001, INT_INF), dp2(1000001, INT_INF);\n  for(int i = 1; i*(i+1)*(i+2)/6 < 1000000; i++){\n    int x = i*(i+1)*(i+2)/6;\n    A.push_back(x);\n    dp1.at(x) = 1;\n    if(x%2 == 1) dp2.at(x) = 1;\n  }\n  for(int i = 1; i <= 1000000; i++){\n    for(int j = 0; j < A.size(); j++){\n      if(A.at(j) >= i) break;\n      chmin(dp1.at(i), dp1.at(i-A.at(j))+1);\n      if(A.at(j) % 2 == 1){\n        chmin(dp2.at(i), dp2.at(i-A.at(j))+1);\n      }\n    }\n  }\n  //cout << dp1.at(40) << endl << dp2.at(40) << endl;\n\n\n  queue<int> result;\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    result.push(n);\n  }\n  while(!result.empty()){\n    int x = result.front(); result.pop();\n    cout << dp1.at(x) << ' ' << dp2.at(x) << endl;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint dp[1000001],Odp[1000001];\nint Tn[200],OTn[200]; \nint n = 1000000;\n\nint main(){\n    int count = 0;  //pollocks numberの生成\n    for(int i = 1;i < 200;i++){\n        Tn[i-1] = i * (i + 1) * (i + 2) / 6;\n        if(Tn[i-1] % 2 == 1){\n            OTn[count] = Tn[i-1];\n            count++;\n        }\n    }\n\n    //個数の初期化\n    for(int j = 0;j <= n;j++){\n        dp[j] = j;\n        Odp[j] = j;\n    }\n    \n    for(int i = 0;i < 200;i++){\n        for(int j = OTn[i];j <= n;j++){    //奇数正四面体数の個数の最小値\n            if(j >= OTn[i])\n                Odp[j] = min(Odp[j],Odp[j-OTn[i]] + 1);\n        }\n        for(int j = Tn[i];j <= 1000000;j++){    //正四面体数の個数の最小値\n            if(j >= Tn[i])\n                dp[j] = min(dp[j],dp[j-Tn[i]] + 1);\n        }\n    }\n\n    //入出力\n    while(cin >> n,n)\n        cout << dp[n] << ' ' <<  Odp[n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\n#include<climits>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\nint dx[] = {1, -1, 0, 0, -1, 1, 1, -1};\n#define ceil(a, b) a / b + !!(a % b)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n\nconst int lim = 300;\nconst int lim_ = 1000001;\nint tri[lim];\nint tetra[lim];\nint n;\nint table[lim_];\nint odd[lim_];\nint main() {\n    tri[1] = 1;\n    rrep(i, 2, lim) {\n        tri[i] = tri[i - 1];\n        tri[i] += i;\n    }\n    //cout << tri[lim - 1] << endl;\n    tetra[1] = 1;\n    rrep(i, 2, lim) {\n        tetra[i] = tetra[i - 1];\n        tetra[i] += tri[i];\n    }\n    //rep(i, 5) cout << tetra[i] << \" \"; cout << endl;\n    //cout << tetra[lim - 1] << endl;\n    rep(i, lim_) table[i] = odd[i] = inf;\n    table[0] = odd[0] = 0;\n    rep(i, lim) {\n        rep(j, lim_) {\n            if (table[j] != inf && j + tetra[i] < lim_) {\n                chmin(table[j + tetra[i]], table[j] + 1);\n            }\n        }\n        if (tetra[i] % 2 == 0) continue;\n        rep(j, lim_) {\n            if (odd[j] != inf && j + tetra[i] < lim_) {\n                chmin(odd[j + tetra[i]], odd[j] + 1);\n            }\n        }\n    }\n    \n    while (cin >> n && n) {\n        cout << table[n] << \" \" << odd[n] << endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> poloc;\nvector<int> poloc_odd;\n\nvoid make_poloc()\n{\n\tint n=1;\n\twhile(1){\n\t\tint a = n*(n+1)*(n+2)/6;\n\t\tif(a > 1000000)\n\t\t\tbreak;\n\t\t\n\t\tpoloc.push_back(a);\n\t\tif(a % 2 == 1)\n\t\t\tpoloc_odd.push_back(a); \n\t\tn++;\n\t}\n}\n\nint main()\n{\n\tmake_poloc();\n\n\tint n;\n\tint dp[1000001];\n\tfor(int i=0;i<=1000000;i++){\n\t\tdp[i] = 1000000;\n\t}\n\tdp[0] = 0;\n\tfor(int i=0;i<poloc.size();i++){\n\t\tfor(int j=0;j<=1000000;j++){\n\t\t\t\tif(j+poloc[i] <= 1000000)\n\t\t\t\t\tdp[j+poloc[i]] = min(dp[j+poloc[i]],dp[j]+1);\n\t\t\t\n\t\t}\n\t}\n\tint dpp[1000001] = {0};\n\tfor(int i=0;i<=1000000;i++){\n\t\tdpp[i] = 1000000;\n\t}\n\tdpp[0] = 0;\n\tfor(int i=0;i<poloc_odd.size();i++){\n\t\tfor(int j=0;j<=1000000;j++){\n\t\t\t\tif(j+poloc_odd[i] <= 1000000)\n\t\t\t\t\tdpp[j+poloc_odd[i]] = min(dpp[j+poloc_odd[i]],dpp[j]+1);\n\t\t}\n\t}\n\t\n\twhile(cin >> n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcout << dp[n] << \" \" << dpp[n] << endl;\n\t}\n\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<utility>\n#include<queue>\n#define pi 3.14159\n#define Inf (int)pow(2., 12.)\n\nusing namespace std;\ntypedef std::pair<int, int> mypair;\nqueue<mypair> qu;\n#define M 1000000\n \nint odd[M], all[M];\n \nvoid update(int *ar, int x){\n    for(int i = x; i <= M; ++i){\n        ar[i] = min(ar[i], ar[i - x] + 1);\n    }\n}\n \nint main(){\n\todd[0] = all[0] = 0;\n    for(int i = 1; i <= M; ++i){\n        odd[i] = all[i] = 10000000;\n    }\n \n    for(int i = 1; ; ++i){\n        int x = i * (i + 1) * (i + 2) / 6;\n        if(x > M) break;\n        update(all, x);\n        if(x % 2 == 1) update(odd, x); \n    }\n     \n    int n;\n    while(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << all[n] << \" \" << odd[n] <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nconst int MAX = 1000005;\nconst int MOD = 1000000007;\n\nll dp[2][MAX];\n// dp[i][j] は i番目までで jを作れる時の必要最小個数\nll odp[2][MAX];\n\nint main(){\n  vector<ll> a;\n  while(1){\n    ll c; cin >> c;\n    if(c == 0) break;\n    else a.pb(c);\n  }\n  // dp table初期化\n  rep(i,2) rep(j,MAX) dp[i][j] = INF;\n  dp[0][0] = 0;\n  rep(i,2) rep(j,MAX) odp[i][j] = INF;\n  odp[0][0] = 0;\n  // dp 作成\n  repn(i,200){\n    ll num = i * (i + 1) * (i + 2) / 6;\n    if(num > MAX) break;\n    rep(j,MAX){\n      if(j < num) dp[1][j] = dp[0][j];\n      else dp[1][j] = min(dp[0][j] ,dp[1][j - num] + 1);\n    }\n    rep(j,MAX) dp[0][j] = dp[1][j];\n    if(num % 2 == 1){\n      rep(j,MAX){\n        if(j < num) odp[1][j] = odp[0][j];\n        else odp[1][j] = min(odp[0][j] ,odp[1][j - num] + 1);\n      }\n      rep(j,MAX) odp[0][j] = odp[1][j];\n    }\n  }\n\n  rep(i,a.size()){\n    cout << dp[0][a[i]] << \" \" << odp[0][a[i]] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e7+1;\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i,r,n) for(ll i = (ll)(r); i < (ll)(n); i++)\n#define RFOR(i,r,n) for(ll i=(ll)(n-1);i>=r;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\ntypedef long long int ll;\ntypedef vector<ll> vi;\ntypedef vector < pair<ll, ll > > vp;\ntypedef vector <string> vs;\ntypedef vector <char> vc;\ntypedef list <ll> lst;\n\nll n, k, ans = 0, sum = 0, cnt = 0;\nstring s;\nchar c;\n\n/*--------------------template--------------------*/\n\n\nll dp[1000001];\nll dpOdd[1000001];\n\nint main()\n{\n\tfor (int i = 0; i <= 1000001; i++) {\n\t\tdp[i] = i;\n\t\tdpOdd[i] = i;\n\t}\n\n\tfor (int n = 2; ; n++) {\n\t\tint bNumber = n * (n + 1) * (n + 2) / 6;\n\t\tif (bNumber > 1000001) break;\n\n\t\tfor (int i = 0; i <= 1000001; i++) {\n\t\t\tif (i - bNumber < 0) continue;\n\t\t\tdp[i] = min(dp[i], dp[i - bNumber] + 1);\n\t\t\tif (bNumber % 2 == 1) dpOdd[i] = min(dpOdd[i], dpOdd[i - bNumber] + 1);\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tint Value;\n\t\tcin >> Value;\n\t\tif (!Value) break;\n\t\tcout << dp[Value] << \" \" << dpOdd[Value] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector < vector<bool> >dp(6, vector < bool>(1000001, 0));\n\tdp[0][0] = 1;\n\tREP(i, 5) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool>> dp2(1001, vector<bool>(1000001, 0));\n\tREP(i, 100) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k % 2 == 0)continue;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp2[i][l])dp2[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tREP(i, 5) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \" \";\n\t\tREP(i, 100) {\n\t\t\tif (dp2[i + 1][n]) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<sstream>\n#include<random>\n#include<cassert>\n#include<climits>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int inf = 1e9 + 7;\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\nint dx[] = {1, -1, 0, 0, -1, 1, 1, -1};\n#define ceil(a, b) a / b + !!(a % b)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n\nconst int lim = 300;\nconst int lim_ = 1000001;\nint tri[lim];\nint tetra[lim];\nint n;\nint table[lim_];\nint odd[lim_];\nint main() {\n    tri[1] = 1;\n    rrep(i, 2, lim) {\n        tri[i] = tri[i - 1];\n        tri[i] += i;\n    }\n    //cout << tri[lim - 1] << endl;\n    tetra[1] = 1;\n    rrep(i, 2, lim) {\n        tetra[i] = tetra[i - 1];\n        tetra[i] += tri[i];\n    }\n    //rep(i, 5) cout << tetra[i] << \" \"; cout << endl;\n    //cout << tetra[lim - 1] << endl;\n    rep(i, lim_) table[i] = odd[i] = inf;\n    table[0] = odd[0] = 0;\n    rep(i, lim) {\n        rep(j, lim_) {\n            if (table[j] != inf && j + tetra[i] < lim_) {\n                chmin(table[j + tetra[i]], table[j] + 1);\n            }\n        }\n        if (tetra[i] % 2 == 0) continue;\n        rep(j, lim_) {\n            if (odd[j] != inf && j + tetra[i] < lim_) {\n                chmin(odd[j + tetra[i]], odd[j] + 1);\n            }\n        }\n    }\n    \n    while (cin >> n && n) {\n        cout << table[n] << \" \" << odd[n] << endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> v;\nvector<int> vodd;\nconst int N = 1000001;\n\nint dp[N];\nint dpodd[N];\n\nvoid dodp(int arr[], vector<int>& v) {\n    for (int i = 0; i < N; ++i) {\n        arr[i] = 1000;\n    }\n    arr[0] = 0;\n\n    for (int vi : v) {\n        for (int i = 0; i < N; ++i) {\n            if (i - vi >= 0 && arr[i - vi] != 1000) {\n                arr[i] = min(arr[i], arr[i - vi] + 1);\n            }\n        }\n    }\n}\n\nint main() {\n    v.push_back(1);\n    vodd.push_back(1);\n    int tri = 1;\n    int i = 2;\n    while(v.back() <= 1000000 ) {\n        tri += i;\n        int tmp = v.back() + tri;\n        v.push_back(tmp);\n        if (tmp % 2 == 1) vodd.push_back(tmp);\n        ++i;\n    }\n    // v.size() = 181\n\n    dodp(dp, v);\n    dodp(dpodd, vodd);\n\n    // for (int i = 0; i < N; ++i) {\n    //     cout << dpodd[i] << \" \";\n    // }\n    // cout << endl;\n    while(1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        cout << dp[n] << \" \" << dpodd[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define MAXNUM 1000000\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM];\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//1からMAXまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\t//正四面体数とその中から奇数のものだけを抜きとったものを用意\n\tint sq[200]={0};\n\tint oddsq[200]={0};\n\t//その配列のindexを保存\n\tint index=0;\n\tint indexODD=0;\n\t //dp初期化用の値\n\tint INF=2000000;\n\t\n\tfor(int i=0; (i+1)*(i+2)*(i+3)/6<=1000000; ++i){\n\t\tsq[i]=(i+1)*(i+2)*(i+3)/6;\n\t\tif(sq[i]%2==1) oddsq[indexODD++]=sq[i];\t\n\t\t//printf(\"%3d :%7d\\n\",i, sq[i]);\n\t\tindex=i+1;\n\t}\n\t//printf(\"index= %d, inODD = %d\\n\", index, indexODD);\n\t\n\t//dpA[i]:=数iを正四面体数の和として表すときに必要な正四面体数の数の最小値\t\t\n\tint dpA[1000001];\n\tfill(dpA,dpA+1000001,INF);\n\tdpA[0]=0;\n\t\t\n\tfor(int i=0; i<1000001; ++i){\n\t\tfor(int j=0; j<index; ++j){\n\t\t\tif(i+sq[j]<1000001) dpA[i+sq[j]]=min(dpA[i+sq[j]],dpA[i]+1);\n\t\t\telse break;\t\n\t\t}\t\n\t}\n\t\t\n\t//dpB[i]:=数iを正四面体数の和として表すときに必要な「奇数の」正四面体数の数の最小値\t\t\n\tint dpB[1000001];\n\tfill(dpB,dpB+1000001,INF);\n\tdpB[0]=0;\n\t\t\n\tfor(int i=0; i<1000001; ++i){\n\t\tfor(int j=0; j<indexODD; ++j){\n\t\t\tif(i+oddsq[j]<1000001) dpB[i+oddsq[j]]=min(dpB[i+oddsq[j]],dpB[i]+1);\n\t\t\telse break;\t\n\t\t}\t\n\t}\n\t\t\n\twhile(1){\n\t\tint n;\n\t\tscanf(\" %d\", &n);\n\t\tif(n==0) break;\n\t\tprintf(\"%d %d\\n\", dpA[n], dpB[n]);\n\t}\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nvoid solve()\n{\n  fill(dp, dp + MAX + 1, MAX);\n  fill(dp2, dp2 + MAX + 1, MAX);\n  dp[0] = dp2[0] = 0;\n  vector<int> v;\n  for(int i = 0; ; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    if(t <= MAX)\n      v.push_back(t);\n    else\n      break;\n  }\n  for(int i = 0; i <= MAX; i++){\n    for(int j = 0; j < v.size(); j++){\n      if(i + v[j] <= MAX){\n        if(v[j] & 1)\n          dp2[i + v[j]] = min(dp2[i + v[j]], dp2[i] + 1);\n        dp[i + v[j]] = min(dp[i + v[j]], dp[i] + 1);\n      }\n    }\n  }\n}\n    \nint main()\n{\n  solve();\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0)\n      break;\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define ALL( a )        (a).begin(), (a).end()             \n\nconst int MAX = 1000000;\n\nint\tdp[MAX] = {};\nint oddp[MAX];\n\nint main() {\n\tREP( i, MAX ) dp[i] = oddp[i] = i;\n\n\tint i = 2, x = 4;\n\twhile( x < MAX ) {\n\t\tfor( int j = 0; j + x < MAX; j++ ) {\n\t\t\tdp[j + x] = min( dp[j + x], dp[j] + 1 );\n\t\t\tif( x % 2 == 1 ) {\n\t\t\t\toddp[j + x] = min( oddp[j + x], oddp[j] + 1 );\n\t\t\t}\n\n\t\t\tif( j + x > ( i + 8 ) * ( i + 9 ) * ( i + 10 ) / 2 ) break;\n\t\t}\n\t\ti++;\n\t\tx = i * ( i + 1 ) * ( i + 2 ) / 6;\n\t}\n\n\n\tint n;\n\twhile( 1 ) {\n\t\tcin >> n; if( n == 0 ) break;\n\t\tcout << dp[n] << \" \" << oddp[n] << endl;\n\t}\n\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  //tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define INF (1<<28)\n\nint dp[2][1000001];\n\nint main() {\n    vector<int> a[2];\n    for(int i=1;; i++) {\n        const int k = i*(i+1)*(i+2)/6;\n        if(k>1000000) break;\n        if(k%2) a[0].push_back(k);\n        else a[1].push_back(k);\n    }\n    rep(i, 1000001) dp[0][i] = INF;\n    dp[0][0] = 0;\n    rep(k, a[0].size()) rep(i, 1000001-a[0][k]) {\n        dp[0][i+a[0][k]] = min(dp[0][i+a[0][k]], dp[0][i]+1);\n    }\n    memcpy(dp[1], dp[0], sizeof(dp[0]));\n    rep(k, a[1].size()) rep(i, 1000001-a[1][k]) {\n        dp[0][i+a[1][k]] = min(dp[0][i+a[1][k]], dp[0][i]+1);\n    }\n    for(;;) {\n        int n;\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        printf(\"%d %d\\n\", dp[0][n], dp[1][n]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint dp1[1000000+1], dp2[1000000+1][5]; // 奇数　そうでない\nint main() {\n\n  memset(dp1, -1, sizeof(dp1));\n  memset(dp2, -1, sizeof(dp2));\n  vector <int> memo;\n  int cnt = 0;\n  for (ll i = 1; i*(i+1)*(i+2)/6 <= 1000000; i++) {\n    int val = i*(i+1)*(i+2)/6;\n    memo.push_back(i*(i+1)*(i+2)/6);\n    if (val%2) {\n      cnt++;\n    }\n  }\n\n  for (int i = 0; i < memo.size(); i++) {\n    if (memo[i]%2) {\n      dp1[memo[i]] = 1;\n    }\n    dp2[memo[i]][0] = 1;\n  }\n\n\n  for (int i = 1; i <= 1000000; i++) {\n    for (int j = 0; j < memo.size() && memo[j] < i; j++) {\n      if (memo[j]%2) {\n\tif (dp1[i-memo[j]] != -1) {\n\t  if (dp1[i] == -1) {\n\t    dp1[i] = dp1[i-memo[j]]+1;\n\t  }else {\n\t    dp1[i] = min(dp1[i], dp1[i-memo[j]]+1);\n\t  }\n\t}\n      }\n\n      for (int k = 1; k < 5; k++) {\n\tif (dp2[i-memo[j]][k-1] != -1) {\n\t  if (dp2[i][k] == -1) {\n\t    dp2[i][k] = dp2[i-memo[j]][k-1]+1;\n\t  }else {\n\t    dp2[i][k] = min(dp2[i][k], dp2[i-memo[j]][k-1]+1);\n\t  }\n\t}\n      }\n    }\n  }\n\n  int n;\n  while(true) {\n    cin >> n;\n    if (n == 0) break;\n\n    int ans2;\n    ans2 = 10000000;\n    for (int i = 0; i < 5; i++) {\n      if (dp2[n][i] != -1) {\n\tans2 = min(ans2, dp2[n][i]);\n      }\n    }\n\n    std::cout << ans2 << \" \" << dp1[n] << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define INF 1000000\n\nint t(int x) { return x*(x+1)*(x+2)/6; }\n\nint dp[1000010];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  Vi one, two, odd;\n  for (int i = 1; t(i) <= 1000000; i++) {\n    one.push_back(t(i));\n    if (t(i)%2) odd.push_back(t(i));\n  }\n\n  for (int a : one) {\n    for (int b : one) {\n      two.push_back(a+b);\n    }\n  }\n  sort(ALL(two));\n\n  REP(i, 1000001) dp[i] = INF;\n  dp[0] = 0;\n  REP(i, 1000000) {\n    for (int a : odd) {\n      if (i+1-a >= 0)\n\tdp[i+1] = min(dp[i+1-a]+1, dp[i+1]);\n    }\n  }  \n\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    if (n == *lower_bound(ALL(one), n)) {\n      cout << 1;\n    } else if (n == *lower_bound(ALL(two), n)) {\n      cout << 2;\n    } else {\n      bool flag = false;\n      for (int a : one) {\n\tif (n - a == *lower_bound(ALL(two), n - a)) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if (flag) {\n\tcout << 3;\n      } else {\n\tfor (int a : two) {\n\t  if (n - a == *lower_bound(ALL(two), n - a)) {\n\t    flag = true;\n\t    break;\n\t  }\n\t}\n\tcout << (flag ? 4 : 5);\n      }\n    }\n\n    cout << ' ' << dp[n] << endl;\n\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint prime[200],dprime[100];\nint dp[2000001],ddp[2000001];\nint main(){\n\tint a=1,b=2,count=1,dcount=1;\n\tprime[0]=1,dprime[0]=1;\n\twhile(true){\n\t\ta+=b;\n\t\tb++;\n\t\tif(prime[count-1]+a>=1000000)\n\t\t\tbreak;\n\t\tif((prime[count-1]+a)%2==1){\n\t\t\tdprime[dcount]=prime[count-1]+a;\n\t\t\tdcount++;\n\t\t}\n\t\tprime[count]=prime[count-1]+a;\n\t\tcount++;\n\t}\n\tfor(int i=0;i<=2000000;i++)\n\t\t\tdp[i]=i%4+i/4;\n\tfor(int i=0;i<=999999;i++){\n\t\tfor(int j=0;j<count;j++)\n\t\t\tdp[i+prime[j]]=min(dp[i+prime[j]],dp[i]+1);\n\t}\n\tfor(int i=0;i<=2000000;i++)\n\t\t\tddp[i]=i%35+i/35;\n\tfor(int i=0;i<=999999;i++){\n\t\tfor(int j=0;j<dcount;j++)\n\t\t\tddp[i+dprime[j]]=min(ddp[i+dprime[j]],ddp[i]+1);\n\t}\n\tint n;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcout<<dp[n]<<\" \"<<ddp[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\nll dp[1000010];\nll dp2[1000010];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N; \n\n    VI V; // 正四面体数リスト\n    FOR(n, 1, 1000){\n      ll v = n*(n+1)*(n+2)/6;\n      if(v>1000000){\n        break;\n      }else{\n        V.push_back(v);\n      }\n    }\n    VI V2; // odd only\n    for(ll v : V){\n      if(v%2==1) V2.push_back(v);\n    }\n\n    rep(i, 1000010){\n      dp[i] = i;\n      dp2[i] = i;\n    }\n\n    debug(V.size());\n    debug(V2.size());\n\n    for(ll p : V){\n      rep(i, 1000010){\n        if(i+p>1000010-1) continue;\n        chmin(dp[i+p], dp[i]+1);\n      }\n    }\n\n    for(ll p : V2){\n      rep(i, 1000010){\n        if(i+p>1000010-1) continue;\n        chmin(dp2[i+p], dp2[i]+1);\n      }\n    }\n    \n    while(cin>>N){\n      if(N==0) return 0;\n      p2(dp[N], dp2[N]);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nbool isprime(int n){\n    double rootn = sqrt(n);\n    if (n < 2){\n        return false;\n    }\n    else if (n == 2){\n        return true;\n    }\n    else if (n % 2 == 0){\n        return false;\n    }\n    else{\n        for(int i = 3; i <= rootn; i += 2){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// 空のベクトルを二つ渡す。N (>=2) 以下の素数を primes に順番に入れる。\nvoid prime_vectors(int N, vector<int>& primes, vector<bool>& is_prime){\n    primes = {};\n    is_prime = {};\n    for(int i=0; i<=N; i++){\n        is_prime.push_back(true);\n    }\n\n    primes.push_back(2);\n    for(int j=4; j<=N; j+=2){\n        is_prime[j] = false;\n    }\n\n    int i;\n    for(i=3; i*i<=N; i+=2){\n        if(!is_prime[i]) continue;\n        primes.push_back(i);\n        for(int j=2*i; j<=N; j+=i){\n            is_prime[j] = false;\n        }\n    }\n\n    for(; i<=N; i+=2){\n        if(is_prime[i]){\n            primes.push_back(i);\n        }\n    }\n}\n#define OKASHI 0\n#define AHO 0\n#if OKASHI\n// tet の要素を最小でいくつ足すと n になるか\nint num_of_tet(int n, vector<int> tet){\n    vector<int> min_num(n+1, -1);\n    min_num[0] = 0;\n    bool flag = false;\n    while(min_num[n] == -1){\n        vector<int> new_num(n+1, -1); // new_num[0] = 0;\n        for(int i=0; i<n; i++){\n            if(min_num[i] == -1) continue;\n            for(int j=0; i+tet[j]<=n; j++){\n                if(new_num[i+tet[j]] == -1){\n                    new_num[i+tet[j]] = min_num[i]+1;\n                }\n                else{\n                    new_num[i+tet[j]] = ((new_num[i+tet[j]] < min_num[i]+1)? new_num[i+tet[j]]:min_num[i]+1);\n                }\n            }\n        }\n        min_num = new_num;\n    }\n\n    return min_num[n];\n}\n#else\nvoid num_of_tet(int n, vector<int> tet, vector<int>& res){\n    #if AHO\n    vector<int> min_num(n+1, -1);\n    min_num[0] = 0;\n\n    // O(n^2)\n    for(int i=0; i<n; i++){\n        vector<int> new_num(n+1, -1); // new_num[0] = 0;\n        for(int i=0; i<n; i++){\n            if(min_num[i] == -1) continue;\n            for(int j=0; j<tet.size() && i+tet[j]<=n; j++){\n                if(new_num[i+tet[j]] == -1){\n                    new_num[i+tet[j]] = min_num[i]+1;\n                }\n                else{\n                    new_num[i+tet[j]] = ((new_num[i+tet[j]] < min_num[i]+1)? new_num[i+tet[j]]:min_num[i]+1);\n                }\n            }\n        }\n        min_num = new_num;\n    }\n\n    res = min_num;\n    #else\n    // O(tet.size()*n)?\n    res = vector<int>(n+1, -1);\n    res[0] = 0;\n    for(int i=0; i<tet.size(); i++){\n        for(int j=tet[i]; j<=n; j++){\n            if(res[j] == -1){\n                res[j] = res[j-tet[i]] + 1;\n            }\n            else if(res[j] != -1 && res[j-tet[i]] != -1){\n                res[j] = min(res[j], res[j-tet[i]] + 1);\n            }\n        }\n    }\n    #endif\n}\n#endif\nsigned main(){\n    // cout << fixed << setprecision(10) << flush;\n    int lim = 1000000;\n    vector<int> tet, odd_tet;\n    for(int i=1; i*(i+1)*(i+2)<=6*lim; i++){\n        tet.push_back(i*(i+1)*(i+2)/6);\n        if((i*(i+1)*(i+2)/6) % 2 == 1){\n            odd_tet.push_back(i*(i+1)*(i+2)/6);\n        }\n    }\n\n    #if OKASHI\n    #else\n    vector<int> res1, res2;\n    num_of_tet(lim, tet, res1);\n    num_of_tet(lim, odd_tet, res2);\n    #endif\n    int n;\n    cin >> n;\n\n    vector<int> ans1, ans2;\n    while(n != 0){\n        #if OKASHI\n        ans1.push_back(num_of_tet(n, tet));\n        ans2.push_back(num_of_tet(n, odd_tet));\n        #else\n        ans1.push_back(res1[n]);\n        ans2.push_back(res2[n]);\n        #endif\n        cin >> n;\n    }\n\n    int i;\n    for(i=0; i<ans1.size(); i++){\n        cout << ans1[i] << \" \" << ans2[i] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int INF = 1<<21;\n\nint main(){\n    static int dp[1000000], dpo[1000000];\n    for(int i = 1; i < 1000000; i++)    dp[i] = dpo[i] = INF;\n\n    vector<int> tetra;\n    for(int i = 1; i*(i+1)*(i+2)/6 < 1000000; i++){\n        tetra.push_back(i*(i+1)*(i+2)/6);\n    }\n\n    for(int i = 0; i < tetra.size(); i++){\n        for(int j = tetra[i]; j < 1000000; j++){\n            if(dp[j-tetra[i]] == INF)   continue;\n            \n            dp[j] = min(dp[j], dp[j-tetra[i]]+1);\n            if(tetra[i] % 2)    dpo[j] = min(dpo[j], dpo[j-tetra[i]]+1);\n        }\n    }\n\n    int n;\n    while(cin >> n, n){\n        cout << dp[n] << \" \" << dpo[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define ASC(vec) vec.begin(), vec.end()\t\t// 昇順ソート 例：sort(ASC(vec));\n#define DESC(vec) vec.rbegin(), vec.rend()\t// 降順ソート 例:sort(DESC(vec));\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define Rep(i, n) for(int i = 1; i < n; i++)\n\nconst int mod = 1000000007;\nconst int inf = (int)1e9 + 7;\nconst long long INF = 1LL << 60;\n\nusing ii = pair<int, int>;\nusing ll = long long;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nusing vvb = vector<vector<bool>>;\nusing vii = vector<pair<int, int>>;\n\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nll GCD(ll a, ll b) { return b ? GCD(b, a % b) : a; }\nll LCM(ll a, ll b) { return (a * b) / GCD(a, b); }\nint round_int(int a, int b) { return (a + (b - 1)) / b; }\n\n// 素因数分解; 返り値は(素数, 乗数)のvector配列\nvector<pair<ll, int>> factorize(ll n) {\n\tvector<pair<ll, int>> res;\n\tfor (ll i = 2; i * i <= n; ++i) {\n\t\tif (n % i) continue;\n\t\tres.emplace_back(i, 0);\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\tres.back().second++;\n\t\t}\n\t}\n\tif (n != 1) res.emplace_back(n, 1);\n\treturn res;\n}\n\nconstexpr array<int, 9> dx = { 0, 1, 0, -1, -1, 1, 1, -1, 0 };\nconstexpr array<int, 9> dy = { 1, 0, -1, 0, 1, 1, -1, -1, 0 };\nconstexpr auto MAX = 100000;\n\n// ──────────────────────────────────────────────────────────────────\n\nint dp1[1000000];\nint dp2[1000000];\n\nint main() {\n\tvi a, b;\n\n\tint num = 1;\n\tint val = 1;\n\twhile (val <= 1000000) {\n\t\ta.push_back(val);\n\t\tif (val % 2 == 1) b.push_back(val);\n\t\tval = num * (num + 1) * (num + 2) / 6;\n\t\tnum++;\n\t}\n\n\tmemset(dp1, inf, sizeof(dp1));\n\tmemset(dp2, inf, sizeof(dp2));\n\tdp1[0] = dp2[0] = 0;\n\n\tRep(i, 1000000) {\n\t\trep(j, a.size()) {\n\t\t\tif (i >= a[j]) chmin(dp1[i], dp1[i - a[j]] + 1);\n\t\t}\n\t}\n\tRep(i, 1000000) {\n\t\trep(j, b.size()) {\n\t\t\tif (i >= b[j]) {\n\t\t\t\tchmin(dp2[i], dp2[i - b[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif (!n) break;\n\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n\nint main(void){\n\tint i, j, n, min1;\n\tint dp[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t}\n\t\t}\n\n\t\tmin1 = dp[n];\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",min1,dp[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    ll s4[101];\n    vector<ll> s4_k;\n    REP(i, 101){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    \n    ll n;\n    cin >> n;\n    while(n != 0){\n        vector<ll> dp(n + 1, INF);\n        dp[0] = 0;\n        \n        for(int i = 1; i <= 101; i++){\n            REP(j, n + 1){\n                if(s4[i - 1] <= j){\n                    dp[j] = min(dp[j], dp[j - s4[i - 1]] + 1);\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[n] << ' ';\n        \n        \n        \n        REP(i, s4_k.size() + 1){\n            REP(j, n + 1){\n                dp[j] = INF;\n            }\n        }\n        dp[0] = 0;\n        \n        for(int i = 1; i <= s4_k.size(); i++){\n            REP(j, n + 1){\n                if(s4_k[i - 1] <= j){\n                    dp[j] = min(dp[j], dp[j - s4_k[i - 1]] + 1);\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[n] << endl;\n        \n        \n        \n        cin >> n;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nvector<int> s;\nvector<int> odd_s;\n\nvoid make_shimentai(){\n    for(int i = 1; ; ++i){\n        int sum = i * (i + 1) * (i + 2) / 6;\n\n        if(sum >= 1000000) break;\n\n        s.emplace_back(sum);\n\n        if(sum % 2 == 1) odd_s.emplace_back(sum);\n    }\n}\n\nint solve(int v, vector<int> s){\n    decltype(s)::iterator it = lower_bound(s.begin(), s.end(), v);\n    if(*it != v) it--;\n\n    int ans = INT_MAX;\n    for(;it != s.begin()-1; it--){\n        vector<int>::iterator it_ = it;\n        int v_ = v;\n        int count = 0;\n        while(true){\n            if(v_ == 0) break;\n            if(v_ - *it_ < 0){\n                it_--;\n                continue;\n            }\n\n            v_ -= *it_;\n            count++;\n            if(ans < count) break;\n        }\n        ans = min(ans, count);\n    }\n\n    return ans;\n}\n\nint main(){\n    make_shimentai();\n\n    while(true){\n        int v;\n        cin >> v;\n        if(v == 0) break;\n\n        int ans = solve(v, s);\n        cout << ans << \" \";\n        ans = solve(v, odd_s);\n        cout << ans << \"\\n\";\n    }\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\nint main() {\n  int N = 1000000;\n  vi p;\n  rep1 (i, N) {\n    int temp = i * (i + 1) * (i + 2) / 6;\n    if (temp > N) break;\n    p.push_back(temp);\n  }\n  \n  int m = p.size();\n  vi dp0(N + 1, inf), dp1(N + 1, inf);\n  dp0[0] = dp1[0] = 0;\n  rep (i, N) {\n    rep (j, m) {\n      int i2 = i + p[j];\n      if (i2 > N) break;\n      chmin(dp0[i2], dp0[i] + 1);\n      if (p[j] % 2 == 1) {\n        chmin(dp1[i2], dp1[i] + 1);\n      }\n    }\n  }\n\n  \n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) return 0;\n    cout << dp0[n] << \" \" << dp1[n] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tvi three;\n\tint num = 1, tmp = 0;\n\twhile(tmp <= 100000) {\n\t\ttmp += num;\n\t\tthree.push_back(tmp);\n\t\tnum++;\n\t}\n\n\tvi four;\n\ttmp = 0;\n\tint pos = 0;\n\twhile(tmp <= 100000) {\n\t\ttmp += three[pos];\n\t\tfour.push_back(tmp);\n\t\tpos++;\n\t}\n\tint fsize = four.size();\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvi dp(n+1, INF);\n\t\tvi dpk(n+1, INF);\n\t\tdp[0] = dpk[0] = 0;\n\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, fsize) {\n\t\t\t\tif(i-four[j] >= 0) {\n\t\t\t\t\tdp[i] = min(dp[i-four[j]]+1, dp[i]);\n\t\t\t\t\tif(four[j]%2) {\n\t\t\t\t\t\tdpk[i] = min(dpk[i-four[j]]+1, dpk[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[n] << \" \" << dpk[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ1167\n//\n//  Created by aki33524 on 2014/07/09.\n//  Copyright (c) 2014年 aki33524. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\nconst int MAX_N = 1000000;\nconst int MAX_T = 200;\n\nvector<int> tetras;\nvector<int> oddtetras;\nint dp1[2][MAX_N];\nint dp2[2][MAX_N];\n\nvoid init(){\n    memset(dp1, 0x3f, sizeof(dp1));\n    memset(dp2, 0x3f, sizeof(dp2));\n    \n    for(int i=0; i<MAX_T; i++){\n        int t = i*(i+1)*(i+2)/6;\n        tetras.push_back(t);\n        if(t%2)\n            oddtetras.push_back(t);\n    }\n    \n    for(int i=0; i<tetras.size(); i++)\n        dp1[0][tetras[i]] = 1;\n    for(int i=0; i<tetras.size(); i++){\n        int t = tetras[i];\n        for(int j=0; j<MAX_N; j++){\n            if(j < t){\n                dp1[(i+1)&1][j] = dp1[i&1][j];\n            }else{\n                dp1[(i+1)&1][j] = min(dp1[i&1][j], dp1[(i+1)&1][j-t]+1);\n            }\n        }\n    }\n    \n    for(int i=0; i<oddtetras.size(); i++)\n        dp2[0][oddtetras[i]] = 1;\n    for(int i=0; i<oddtetras.size(); i++){\n        int t = oddtetras[i];\n        for(int j=0; j<MAX_N; j++){\n            if(j < t){\n                dp2[(i+1)&1][j] = dp2[i&1][j];\n            }else{\n                dp2[(i+1)&1][j] = min(dp2[i&1][j], dp2[(i+1)&1][j-t]+1);\n            }\n        }\n    }\n}\n\nint main(int argc, const char * argv[])\n{\n    init();\n    \n    int N;\n    while(cin>>N, N){\n        cout << dp1[tetras.size()&1][N] << \" \" << dp2[oddtetras.size()&1][N] << endl;;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int s4[101];\n    vector<int> s4_k;\n    REP(i, 101){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    \n    int n;\n    cin >> n;\n    while(n != 0){\n        vector<int> dp(n + 1, 1e9);\n        dp[0] = 0;\n        \n        for(int i = 1; i <= 101; i++){\n            REP(j, n + 1){\n                if(s4[i - 1] <= j){\n                    dp[j] = min(dp[j], dp[j - s4[i - 1]] + 1);\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[n] << ' ';\n        \n        \n        \n        REP(i, s4_k.size() + 1){\n            REP(j, n + 1){\n                dp[j] = 1e9;\n            }\n        }\n        dp[0] = 0;\n        \n        for(int i = 1; i <= s4_k.size(); i++){\n            REP(j, n + 1){\n                if(s4_k[i - 1] <= j){\n                    dp[j] = min(dp[j], dp[j - s4_k[i - 1]] + 1);\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[n] << endl;\n        \n        \n        \n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nstd::vector<int> num;\n\nstruct State {\n  int num;\n  int depth;\n  State(int a, int b) {\n    num   = a;\n    depth = b;\n  }\n};\n\nint Solve_all(int n) {\n  bool visited[1000001] = {};\n  std::queue<State> bfs;\n  for (auto x : num) {\n    if (x > n) break;\n    bfs.push(State(x, 1));\n    visited[x] = true;\n  }\n  while (!bfs.empty()) {\n    State newstate = bfs.front();\n    bfs.pop();\n    if (newstate.num == n) {\n      return newstate.depth;\n    }\n    for (auto x : num) {\n      if (newstate.num + x > n) break;\n      if (visited[newstate.num + x]) continue;\n      bfs.push(State(newstate.num + x, newstate.depth + 1));\n      visited[newstate.num + x] = true;\n    }\n  }\n}\n\nint Solve_odd(int n) {\n  bool visited[1000001] = {};\n  std::queue<State> bfs;\n  for (auto x : num) {\n    if (x % 2 == 0) continue;\n    if (x > n) break;\n    bfs.push(State(x, 1));\n    visited[x] = true;\n  }\n  while (!bfs.empty()) {\n    State newstate = bfs.front();\n    bfs.pop();\n    if (newstate.num == n) {\n      return newstate.depth;\n    }\n    for (auto x : num) {\n      if (x % 2 == 0) continue;\n      if (newstate.num + x > n) break;\n      if (visited[newstate.num + x]) continue;\n      bfs.push(State(newstate.num + x, newstate.depth + 1));\n      visited[newstate.num + x] = true;\n    }\n  }\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  for (int n = 1; n < 1000; n++) {\n    int push = n * (n + 1) * (n + 2) / 6;\n    if (n > 1000000) break;\n    num.push_back(push);\n  }\n\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) return 0;\n    cout << Solve_all(n) << \" \" << Solve_odd(n) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint tbl1[1000000],tbl2[1000000];\nint main(){\n  int n = 1000000;\n  int c = 0;\n  for(int i=1;i<n;++i) tbl1[i]=tbl2[i]=i;\n  for(int i=2;;++i){\n    int t = i*(i+1)*(i+2)/6;\n    if(t>=n) break;\n    for(int j=0;j+t<n;++j){\n      if(t%2) tbl2[j+t]=min(tbl2[j+t],tbl2[j]+1);\n      tbl1[j+t]=min(tbl1[j+t],tbl1[j]+1);\n    }\n  }\n  while(cin>>n,n)\n    cout << tbl1[n] << \" \" << tbl2[n] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <utility>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\n\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define itrep(i,x) for(auto i=(x).begin(); i!=(x).end();i++)\n#define Sort(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define vec vector\n#define INF (int)1e9\n#define INFL 1e18\n#define MOD 1000000007\n#define pb push_back\n#define MP make_pair\n#define PI 3.1415926535\ntypedef long long int ll;\ntypedef std::pair<int,int> P;\nint D=1;\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\nusing namespace std;\n\nint main(){\n    vector<int> v,oddv;\n    for(ll i=1;;i++){\n        if(i*(i+1)*(i+2)/6<=2000000){\n            v.pb(i*(i+1)*(i+2)/6);\n        }\n        else break;\n    }\n    int ans1[1000010],ans2[1000010];\n    rep(i,0,1000010) ans1[i]=ans2[i]=INF;\n    ans1[0]=0; ans2[0]=0;\n    rep(i,0,1000000){\n        ans1[i]=i; ans2[i]=i;\n        for(int j=0;i>=v[j];j++){\n            ans1[i]=min(ans1[i-v[j]]+1,ans1[i]);\n            if(v[j]%2==1)ans2[i]=min(ans2[i],ans2[i-v[j]]+1);\n        }\n    }\n\n    int n;\n    while(cin>>n&&n){\n        cout<<ans1[n]<<\" \"<<ans2[n]<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[10000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b ???ans??????????????????????????? */\n\n  for (i = 1; i <= 180; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;\n    int temp = input;\n    int j = 1, min = 1000000000;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n    while (j > 0) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j--;\n      input = temp;\n    }\n    ans[a][0] = min;\n    j = l; \n    min = 1000000000;\n    while (j > 0) {\n      if (tetras[j] % 2 == 0) {\n\tj--;\n\tcontinue;\n      }\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tif (tetras[k] % 2 == 0) {\n\t  k--;\n\t  continue;\n\t}\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j--;\n      input = temp;\n    }\n    ans[a][1] = min;\n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n// clang-format off\n#define ARG4(_1, _2, _3, _4, ...) _4\n#define rep(...) ARG4(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define REP(i, a) FOR(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(...) ARG4(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define RREP(i, a) RFOR(i, 0, a)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= (int)(a); --i)\n#define ALL(c) (c).begin(), (c).end()\n#define pb emplace_back\n#define em emplace\n#define fi first\n#define se second\n#define USE1(...) template <typename __VA_ARGS__> inline\n#define USE2(T, ...) USE1(T, typename __VA_ARGS__)\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n \nusing ll = long long;\ntemplate<typename T> using vec = std::vector<T>;\nUSE2(T,U)bool chmax(T&x,U a){return x<a&&(x=a,1);}\nUSE2(T,U)bool chmin(T&x,U a){return a<x&&(x=a,1);}\nUSE1(T=int)T in(){T x;std::cin>>x;return x;}\nUSE2(T=int,V=vec<T>)V reserved(int n){V v;v.reserve(n);return v;}\nUSE1(T=int)vec<T>in(int n){auto v=reserved<T>(n);rep(i,n)v.pb(in<T>());return v;}\nUSE2(T,U=std::pair<T,int>)vec<U>enume(const vec<T>&x,int s=0){int N=x.size();auto v=reserved<U>(N);rep(i,N)v.pb(x[i],s+i);return v;}\nUSE1(T)vec<T>ndvec(T v,int n){return vec<T>(n,v);}\nUSE2(T,...Ts)auto ndvec(T v,int n,Ts...ns)->vec<decltype(ndvec(v,ns...))>{return ndvec(ndvec(v,ns...),n);}\nUSE1(T)void pr(T x){std::cout<<x<<'\\n';}\nUSE2(T,...Ts)void pr(T x,Ts...xs){std::cout<<x<<' ';pr(xs...);}\nUSE1(T=int)T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\nUSE1(T=int)void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n// }}}\nstruct IoSetup { // {{{\n  IoSetup() {\n    std::ios::sync_with_stdio(0);\n    std::cin.tie(0);\n    std::cout.precision(10);\n    std::cerr.precision(10);\n  }\n} iosetup; //}}}\nusing namespace std;\nconst int inf = 1001001001;\nconst ll infl = 1001001001001001001ll;\nconst int dd[] = {0, 1, 0, -1, 0};\n\nsigned main() {\n  const int M = 1000000;\n  vec<int> tet;\n  rep(i, 1, 1000) {\n    int x = i * (i + 1) * (i + 2) / 6;\n    if (x >= M) break;\n    tet.pb(x);\n  }\n  vec<int> dp(2 * M, inf), dpo(2 * M, inf);\n  dp[0] = dpo[0] = 0;\n  REP(i, M) {\n    for (int x : tet) {\n      chmin(dp[i + x], dp[i] + 1);\n      if (x % 2) chmin(dpo[i + x], dpo[i] + 1);\n    }\n  }\n  int N;\n  while (N = in(), N) {\n    pr(dp[N], dpo[N]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #Sazaの1日1AC\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long mod = 1e9+7;\nconst long long INF = 9e18;\nconst double PI = 3.14159265358979323846;\n\n//マクロ\n//型エイリアス\nusing ll = long long;\nusing P = pair<long long, long long>;\nusing vl = vector<long long>;\nusing vvl = vector<vector<long long>>;\nusing vP = vector<pair<long long, long long>>;\n//ショートカット\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define rep2(i, k, n) for (int i = k; i < n; i++) //半開区間\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define pb push_back\n#define mkp make_pair\n//入力\n#define vin(v, N) for (long long i = 0; i < N; i++) cin >> v.at(i)\n#define lin(n)long long n;cin >> n\n#define chin(x)char x;cin >> x;\n#define sin(s)string s;cin >> s;\n#define vlin(v, N)vector<long long> v(N);for (long long i = 0; i < N; i++)cin >> v.at(i)\n#define max(a, b) max((ll)a, (ll)b)\n#define min(a, b) min((ll)a, (ll)b)\n\n//関数\n//最大公約数\nlong long gcd(long long m, long long n){\n  long long a = max(m, n);\n  long long b = min(m, n);\n  long long r = a % b;\n  while (r != 0){\n    a = b;\n    b = r;\n    r = a % b;\n  }\n  return b;\n}\n// 最小公倍数\nlong long lcd(long long m, long long n){\n  return m * n / gcd(m, n);\n}\n//xのn乗\nlong long power(long long x, long long N){\n  long long ret = 1;\n  for (long long i = 0; i < N; i++)\n    ret *= x;\n  return ret;\n}\n//繰り返し二乗法\nlong long repeat_squaring(long long x, long long n){\n  if (n == 0)\n    return 1;\n  else if (n % 2 == 0)\n  {\n    long long t = repeat_squaring(x, n / 2);\n    return t * t % mod;\n  }\n  else\n    return x * repeat_squaring(x, n - 1);\n}\n//素因数分解(mapで返す)\nmap<long long, long long> factor(long long p){\n  ll p1 = p;\n  map<long long, long long> ret;\n  for (long long i = 2; i * i <= p1; i++)\n  {\n    while (p % i == 0)\n    {\n      ret[i]++;\n      p /= i;\n    }\n  }\n  if (p != 1)\n    ret[p]++;\n  return ret;\n}\n//素数判定\nbool is_prime(long long N){\n  for (long long i = 2; i * i <= N; i++)\n  {\n    if (N % i == 0)\n      return false;\n  }\n  return true;\n}\n//最大値更新\nvoid chmax(long long &a, long long b){\n  a = max(a, b);\n}\n//最小値更新\nvoid chmin(int &a, int b){\n  a = min(a, b);\n}\n\n//構造体\n//Union-Find木\nstruct UnionFind\n{\n  //メンバ変数\n  vector<long long> par; //par[i]:=頂点iの親\n  vector<long long> s;   //s[i]:=頂点iが属する集合の個数(iが根のとき)\n\n  //コンストラクタ\n  UnionFind(long long N) : par(N), s(N){\n    for (long long i = 0; i < N; i++)\n    {\n      par[i] = i; //最初はすべてが根として初期化\n      s[i] = 1;\n    }\n  }\n  //メンバ関数\n  //root(i):=頂点iの根\n  long long root(long long i){\n    if (par[i] == i)\n      return i;\n    par[i] = root(par[i]); //経路圧縮\n    return root(par[i]);   //再帰\n  }\n  //size[i]:=iが属する集合の個数\n  long long size(long long i){\n    return s[root(i)];\n  }\n  //same(x,y) xとyが同じ根を持つか(同じ集合に含まれるか)\n  bool same(long long x, long long y){\n    return root(x) == root(y);\n  }\n  //unite(x,y) xの根をyの根に繋げる(集合を合併)\n  void unite(long long x, long long y){\n    if (!same(x, y)){\n      long long rx = root(x);\n      long long ry = root(y);\n      par[rx] = par[ry];\n      s[ry] = s[rx] + s[ry];\n    }\n  }\n};\n//Binary Indexed Tree\nstruct BIT{\n  vector<long long> bit;\n  long long N;\n\n  BIT(long long n){\n    N = n;\n    bit.resize(N + 1);\n  }\n\n  void add(long long i, long long w){\n    for (long long x = i; x <= N; x += x & -x){\n      bit[x] += w;\n    }\n  }\n  long long sum(long long i){\n    long long ret = 0;\n    for (long long x = i; x > 0; x -= x & -x){\n      ret += bit[x];\n    }\n    return ret;\n  }\n};\n/////////////////⊂('ω'⊂ )))Σ≡GO!/////////////////\n\n\nint main(){\n  //doubleの桁数\n  cout << fixed << setprecision(10);\n\n  vector<int> f(200);\n  vector<int> f2(200);\n  int cnt = 0;\n  for (int i = 0; i < 200; i++)\n  {\n    f[i] = (i + 1) * (i + 2) * (i + 3) / 6;\n    if (f[i] % 2 == 1)\n    {\n      f2[cnt] = f[i];\n      cnt++;\n    }\n  }\n\n  vector<int> dp(3e6, mod);\n  vector<int> dp2(3e6, mod);\n  dp[0] = 0;\n  dp2[0] = 0;\n  for (int i = 0; f[i] <= 1e6; i++)\n  {\n    for (int j = 0; j < 1e6; j++)\n    {\n      //if(j + f[i] > N) break;\n      chmin(dp[j + f[i]], dp[j] + 1);\n    }\n  }\n  for (int i = 0; f2[i] <= 1e6; i++)\n  {\n    for (int j = 0; j < 1e6; j++)\n    {\n      //if(j + f[2] > N) break;\n      chmin(dp2[j + f2[i]], dp2[j] + 1);\n    }\n  }\n\n  while(true){\n    lin(N);\n    if(N == 0) break;\n\n    cout << dp[N] << \" \";\n    cout << dp2[N] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint D[182] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<182 ; i++ ){\n\t\tD[i] = i * (i+1) * (i+2) / 6 ;\n\t}\n}\n\nint cal_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\t//if( dp_map[0][x] != 0 ) return dp_map[0][x] ;\n\t\t//else \n\t\treturn x/D[c] + cal_2( x%D[c] , c-1 ) ;\n\t}\n}\n\nint cal( int m , int q ){\n\tint ans = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans = min( ans , cal_2( m , j ) ) ;\n\t}\n\treturn ans ;\n}\n\nint cal_odd_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( D[c]%2 == 0 ) return cal_odd_2( x , c-1 ) ;\n\t\telse{\n\t\t\t//if( dp_map[1][x] != 0 ) return dp_map[1][x] ;\n\t\t\t//else \n\t\t\treturn x/D[c] + cal_odd_2( x%D[c] , c-1 ) ;\n\t\t}\n\t}\n}\n\nint cal_odd( int m , int q ){\n\tint ans_2 = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans_2 = min( ans_2 , cal_odd_2( m , j ) ) ;\n\t}\n\treturn ans_2 ;\n}\n\nvoid dp(){\n\tint p = 1 ;\n\tfor( int i=1 ; i<=1000000 ; i++ ){\n\t\tif( p < 182 && i >= D[p] ) p++ ;\n\t\tdp_map[0][i] = cal(i,p) ;\n\t\tdp_map[1][i] = cal_odd(i,p) ;\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\nusing namespace std;\n\nint main(){\n   int tetra[181];\n   int dp[MAX+1],dpodd[MAX+1];\n   for(int i=0;i<MAX+1;i++) {dp[i]=i; dpodd[i]=i;}\n   for(int i=1;i<181;i++){\n      tetra[i-1] = i * (i+1) * (i+2) / 6;\n   }\n   for(int i=0;i<180;i++){\n      int p = tetra[i];\n      for(int j=0;p+j <= MAX;j++){\n         if(dp[p+j] > dp[j]) dp[p+j] = dp[j] + 1;\n         if(p%2 == 1){\n            if(dpodd[p+j] > dpodd[j]) dpodd[p+j] = dpodd[j] + 1;\n         }\n      }\n   }\n   while(1){\n      int n;\n      cin >> n;\n      if(n==0) break;\n      cout << dp[n] << \" \" << dpodd[n] << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint coin[100000];\nint coin_ki[100000];\nint dp[100000];\nint dp2[100000];\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    int ans_tmp=0;\n    int ans2_tmp=0;\n\n    \n   \n    int tmp2=0;\n  \n    for(int i=1;i<100000;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    \n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //printf(\"dp[%d]=%d\\n\",i+coin[j],dp[i+coin[j]]);\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    \n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n    \n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  ans2_tmp=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  dp2[i+coin_ki[j]]=ans2_tmp;\n\t  //printf(\"dp2[%d]=%d\\n\",i+coin_ki[j],dp[i+coin_ki[j]]);\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n\n    //for(int i=0;i<count;i++)\n      //printf(\"coin[%d]=%d\\n\",i,coin[i]);\n      //for(int i=0;i<count_ki;i++)\n      //printf(\"coin_ki[%d]=%d\\n\",i,coin_ki[i]);\n\n\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define INF 10000000\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main(void){\n\t\n\tstatic int dp1[1000001],dp2[1000001],n,four[501];\n\t\n\tfill(four,four+501,0);\n\tfill(dp1,dp1+1000001,INF);\n\tfill(dp2,dp2+1000001,INF);\n\t\n\trep(i,501)four[i]=i*(i+1)*(i+2)/6;\n\t\n\tdp1[0]=dp2[0]=0;\n\t\n\tfor(int i=1;i<1000001;i++){\n\t\tfor(int j=1;four[j]<=i;j++){\n\t\t\tdp1[i]=min(dp1[i],dp1[i-four[j]]+1);\n\t\t\tif(four[j]%2)dp2[i]=min(dp2[i],dp2[i-four[j]]+1);\n\t\t}\n\t}\n\t\n\twhile(cin >> n,n)cout << dp1[n] << \" \" << dp2[n] << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nconst int MAX = 1000000;\nint cal(int n) { return n*(n+1)*(n+2)/6; }\nvoid dpru(int* dp, const vector<int>& tet)\n{\n\tfor (int i = 0; i <= MAX; ++i)\n\t\tdp[i] = 1 << 28;\n\tdp[0] = 0;\n\tfor (int i = 1; i <= MAX; ++i)\n\t\tfor (int j = 0; j < tet.size() && i - tet[j] >= 0; ++j)\n\t\t\tmin_swap(dp[i], dp[i - tet[j]] + 1);\n}\nint main()\n{\n\tvector<int> tetra, odd_tetra;\n\tfor (int i = 1; cal(i) <= MAX; ++i)\n\t{\n\t\ttetra.push_back(cal(i));\n\t\tif (cal(i) & 1)\n\t\t\todd_tetra.push_back(cal(i));\n\t}\n\n\tstatic int min_tet[MAX + 1], min_odd_tet[MAX + 1];\n\tdpru(min_tet, tetra);\n\tdpru(min_odd_tet, odd_tetra);\n\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t\tprintf(\"%d %d\\n\", min_tet[n], min_odd_tet[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define MAX 1000000\nvector<int> v, vk;\nvoid Setm(){\n\tfor (int i = 1;; i++){\n\t\tint seti = (i * (i + 1) * (i + 2)) / 6;\n\t\tif (seti > MAX) break;\n\t\tv.push_back(seti);\n\t\tif (seti % 2 != 0) vk.push_back(seti);\n\t}\n}\n\nint main(){\n\tint n;\n\tSetm();\n\twhile (1){\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tint min1 = MAX; //??¶??°+?\\???°??§????¨?????????°\n\t\tint min2 = MAX; //?\\???°??§????¨?????????°\n\t\tvector<int> st1;\n\t\tfor (int i = 0; i < v.size(); i++){\n\t\t\tif (v[i] > n) break;\n\t\t\tst1.push_back(v[i]);\n\t\t}\n\t\tvector<int> st2;\n\t\tfor (int i = 0; i < vk.size(); i++){\n\t\t\tif (v[i] > n) break;\n\t\t\tst2.push_back(vk[i]);\n\t\t}\n\t\twhile (st1.size() != 0){\n\t\t\tint ans = n;\n\t\t\tint cnt = 0;\n\t\t\t\n\t\t\tfor (int i = st1.size() - 1; i >= 0; i--){\n\t\t\t\tif (ans == 0) break;\n\t\t\t\tif (st1[i] <= ans){\n\t\t\t\t\tans -= st1[i];\n\t\t\t\t\tcnt++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin1 = min(min1, cnt);\n\t\t\tst1.erase(st1.end() - 1);\n\t\t}\n\t\twhile (st2.size() != 0){\n\t\t\tint ans = n;\n\t\t\tint cnt = 0;\n\n\t\t\tfor (int i = st2.size() - 1; i >= 0; i--){\n\t\t\t\tif (ans == 0) break;\n\t\t\t\tif (st2[i] <= ans){\n\t\t\t\t\tans -= st2[i];\n\t\t\t\t\tcnt++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin2 = min(min2, cnt);\n\t\t\tst2.erase(st2.end() - 1);\n\t\t}\n\t\tcout << min1 << \" \" << min2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#define MAX (int)1e+6\n\nint main(void){\n  int i,j,n;\n  int a[181],b[46];\n  int dp1[MAX],dp2[MAX];\n\n  b[0] = 0;\n  j = 1;\n  for(i=0;i<181;i++){\n    a[i] = i * (i+1) * (i+2) / 6;\n    if(a[i]&1)b[j++] = a[i];\n  }\n\n  for(i=0;i<MAX;i++)dp1[i] = dp2[i] = 1000000;\n\n  for(i=0;i<MAX;i++){\n    for(j=0;j<181;j++){\n      if(i>a[j])dp1[i] = min(dp1[i],dp1[i-a[j]]+1);\n      else if(i==a[j])dp1[i]=1;\n      else break;\n    }\n  }\n  \n  for(i=0;i<MAX;i++){\n    for(j=0;j<46;j++){\n      if(i>b[j])dp2[i] = min(dp2[i],dp2[i-b[j]]+1);\n      else if(i==b[j])dp2[i]=1;\n      else break;\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp1[n],dp2[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    ll s4[101];\n    vector<ll> s4_k;\n    REP(i, 101){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    \n    ll n;\n    cin >> n;\n    while(n != 0){\n        vector<vector<ll>> dp(102, vector<ll>(n + 1, INF));\n        dp[0][0] = 0;\n        \n        for(int i = 1; i <= 101; i++){\n            REP(j, n + 1){\n                if(s4[i - 1] <= j){\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - s4[i - 1]] + 1);\n                }\n                else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[101][n] << ' ';\n        \n        \n        \n        REP(i, s4_k.size() + 1){\n            REP(j, n + 1){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][0] = 0;\n        \n        for(int i = 1; i <= s4_k.size(); i++){\n            REP(j, n + 1){\n                if(s4_k[i - 1] <= j){\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - s4_k[i - 1]] + 1);\n                }\n                else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[s4_k.size()][n] << endl;\n        \n        \n        \n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define INF 2000000000\n#define int long long int\n#define MOD 1000000007\n#define pb push_back\n#define cin1(n) (cin >> n)\n#define cin2(a,b) (cin >> a >> b)\n#define cin3(a,b,c) (cin >> a >> b >> c)\n#define cout(n) (cout << n << endl)\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define fr first \n#define sc second \n#define EPS (1e-10)\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector< vector<int> > vvi;\ntypedef vector<pair<int,int>> vpii;\ntypedef vector<string> vs;\ntypedef vector<vector<string>> vss;\ntypedef pair<int,int> pii;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint a,b;\nint p,q;\n\n\nint MAX = 1000000;\n\nsigned main() {\n\n\tvi dp(MAX,MAX); // iテ」ツ?ョテヲツュツ」テ・ツ崢崚ゥツ敖「テ、ツスツ禿」ツ?ョテヲツ慊?・ツーツ湘・ツ?凝ヲツ閉ー\n\tvi dpo(MAX,MAX);\n\n\tdp[0] = 0;\n\tdpo[0] = 0;\n\tfor (int i = 0;; i++) {\n\t\tint polo = i * (i + 1) * (i + 2) / 6;\n\t\tif (polo > MAX) break;\n\t\tfor (int j = polo; j < MAX; j++) {\n\t\t\tdp[j] = min(dp[j],dp[j-polo] + 1);\n\t\t}\n\t\tif (polo % 2 == 1) {\n\t\tfor (int j = polo; j < MAX; j++) {\n\t\t\tdpo[j] = min(dpo[j],dpo[j-polo] + 1);\n\t\t}\n\t\t}\n\t}\n\n\twhile(1) {\n\t\tcin1(n);\n\t\tif (n == 0) break;\n\t\tcout << dp[n] << \" \" << dpo[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[MAXNUM], fourodd[MAXNUM];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tlong long int now = 0;\n\tlong long int allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\n\t\tint four = now * (now + 1) * (now + 2) / 6;\n\t\t//cout << four << endl;\n\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\n\t\tif (four > MAXNUM / 2)\n\t\t\tbreak;\n\t}\n\n\t//cout << allcounter << \", \" << oddcounter << endl;\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < allcounter; i++){\n\t\tconst int num_all = fourall[i];\n\n\t\tfor (int j = 1; j < (MAXNUM - num_all); j++){\n\t\t\tall[j + num_all] = min(all[j + num_all], 1 + all[j]);\n\t\t}\n\t}\n\n\tfor (int i = 1; i < oddcounter; i++){\n\t\tconst int num_odd = fourodd[i];\n\n\t\tfor (int j = 1; j < (MAXNUM - num_odd); j++){\n\t\t\todd[j + num_odd] = min(odd[j + num_odd], 1 + odd[j]);\n\t\t}\n\t}\n\n\n\t/*\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; fourall[j] < i; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t\tcout << all[i];\n\t\t}\n\t\tfor (int j = 1; fourodd[j] < i; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t*/\n\n\t//cout << \"a\";\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <fstream>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n//Vector2D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec2D {\n    T x, y;\n\n    Vec2D() = default;\n\n    constexpr Vec2D(T x, T y)\n            : x{x}, y{y} {}\n\n    static constexpr T Dot(const Vec2D &lhs, const Vec2D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y;\n    }\n\n    static constexpr T Cross(const Vec2D &lhs, const Vec2D &rhs) {\n        return {lhs.x * rhs.y - lhs.y * rhs.x};\n    }\n\n    constexpr T dot(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec2D cross(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y;\n    }\n\n    Vec2D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec2D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0;\n    }\n\n    constexpr Vec2D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec2D operator-() const {\n        return {-x, -y};\n    }\n\n\n    constexpr Vec2D operator+(Vec2D rhs) const {\n        return {x + rhs.x, y + rhs.y};\n    }\n\n    constexpr Vec2D operator-(Vec2D rhs) const {\n        return {x - rhs.x, y - rhs.y};\n    }\n\n    template<class U>\n    constexpr Vec2D operator*(U rhs) const {\n        return {x * rhs, y * rhs};\n    }\n\n    template<class U>\n    constexpr Vec2D operator/(U rhs) const {\n        return {x / rhs, y / rhs};\n    }\n\n    constexpr Vec2D &operator+=(const Vec2D &other) {\n        x += other.x;\n        y += other.y;\n        return *this;\n    }\n\n    constexpr Vec2D &operator-=(const Vec2D &other) {\n        x -= other.x;\n        y -= other.y;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec2D<T> operator*(U s, Vec2D<T> v) {\n    return {s * v.x, s * v.y};\n}\n\n//Vector3D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec3D {\n    T x, y, z;\n\n    Vec3D() = default;\n\n    constexpr Vec3D(T x, T y, T z)\n            : x{x}, y{y}, z{z} {}\n\n    constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0) {}\n\n    static constexpr T Dot(const Vec3D &lhs, const Vec3D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n    }\n\n    static constexpr Vec3D Cross(const Vec3D &lhs, const Vec3D &rhs) {\n        return {\n                lhs.y * rhs.z - lhs.z * rhs.y,\n                lhs.z * rhs.x - lhs.x * rhs.z,\n                lhs.x * rhs.y - lhs.y * rhs.x\n        };\n    }\n\n    constexpr T dot(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec3D cross(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y + z * z;\n    }\n\n    Vec3D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec3D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0 && z == 0;\n    }\n\n    constexpr Vec3D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec3D operator-() const {\n        return {-x, -y, -z};\n    }\n\n\n    constexpr Vec3D operator+(Vec3D rhs) const {\n        return {x + rhs.x, y + rhs.y, z + rhs.z};\n    }\n\n    constexpr Vec3D operator-(Vec3D rhs) const {\n        return {x - rhs.x, y - rhs.y, z - rhs.z};\n    }\n\n    template<class U>\n    constexpr Vec3D operator*(U rhs) const {\n        return {x * rhs, y * rhs, z * rhs};\n    }\n\n    template<class U>\n    constexpr Vec3D operator/(U rhs) const {\n        return {x / rhs, y / rhs, z / rhs};\n    }\n\n    constexpr Vec3D &operator+=(const Vec3D &other) {\n        x += other.x;\n        y += other.y;\n        z += other.z;\n        return *this;\n    }\n\n    constexpr Vec3D &operator-=(const Vec3D &other) {\n        x -= other.x;\n        y -= other.y;\n        z -= other.z;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        z *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        z /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec3D<T> operator*(U s, Vec3D<T> v) {\n    return {s * v.x, s * v.y, s * v.z};\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n    set<LL> S;\n    for (LL i = 1; i < 200; i++) {\n        LL data = i * (i + 1) * (i + 2) / 6;\n        S.insert(data);\n    }\n\n    VI arr(S.size());\n    int _i = 0;\n    FOREACH(x, S) {\n        arr[_i] = x;\n        _i++;\n    }\n\n    VI dp(100010);\n    VI dp2(100010);\n    dp[0] = 0;\n    dp2[0] = 0;\n    for (int i = 1; i <= 100008; i++) {\n        dp[i] = dp[i - 1] + 1;\n        REP(j, SZ(arr)) {\n            if (arr[j] <= i) {\n                dp[i] = min(dp[i], dp[i - arr[j]] + 1);\n            } else {\n                break;\n            }\n        }\n    }\n    for (int i = 1; i <= 100008; i++) {\n        dp2[i] = dp2[i - 1] + 1;\n        REP(j, SZ(arr)) {\n            if (arr[j] <= i) {\n                if (arr[j] % 2 == 1) {\n                    dp2[i] = min(dp2[i], dp2[i - arr[j]] + 1);\n                } else {\n                    continue;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n\n    int N;\n    while (true) {\n\n\n        cin >> N;\n\n        if (N == 0) break;\n\n        cout << dp[N] << \" \" << dp2[N] << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\n    int res=0xFFFF;\n    if(maxcnt<cnt) return 0xFFFF;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n    }\n    return res;\n}\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        for(int i=1; ; i*=2) {\n            if((oddres=oddrec(n, 0, 0, i))!=0xFFFF)\n                break;\n        }\n\n        printf(\"%d %d\\n\",res,oddres);\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1167\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nconst int INF = 1<<30;\n\nstd::vector<int> tet;\nstd::vector<int> dp( 1000001, INF ), dpOdd( 1000001, INF );\n\nint main()\n{\n\tfor( int i = 1; i*(i+1)*(i+2)/6 <= 1000000; ++i )\n\t\ttet.push_back( i*(i+1)*(i+2)/6 );\n\n\tdp[0] = dpOdd[0] = 0;\n\trep( i, 1000001 )\n\t{\n\t\trep( j, tet.size() )\n\t\t{\n\t\t\tif( i-tet[j] >= 0 )\n\t\t\t{\n\t\t\t\tdp[i] = std::min( dp[i], dp[i-tet[j]]+1 );\n\t\t\t\n\t\t\t\tif( tet[j]&1 )\n\t\t\t\t\tdpOdd[i] = std::min( dpOdd[i], dpOdd[i-tet[j]]+1 );\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\twhile( scanf( \"%d\", &n ), n )\n\t\tprintf( \"%d %d\\n\", dp[n], dpOdd[n] );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint x,y;\nint m[1000005]={};\nint memo[1000005]={};\nvector<int> odd;\nvoid saiki(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << \":\" << x << endl;\n  if(n==0) {\n    //cout << x << d << endl;\n    x=min(x,d);\n  }else if(n>0) {\n    if(memo[n]>0){\n      x=min(x,memo[n]+d);\n    }else{\n      for(i=1;m[i]<=n;i++);\n      i--;\n      for(j=i;j>0;j--){\n\tif(x>d+1)\n\t  saiki(n-m[j],d+1);\n      }\n      if(x>d+2)\n\tmemo[n]=x-d;\n      //cout << n << \":\" << memo[n]<< endl;\n    }\n  }\n}\nvoid saiki2(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << endl;\n  if(n==0) {\n    y=min(y,d);\n  }else if(n>0) {\n    for(i=0;odd[i]<=n;i++);\n    i--;\n    //cout << i << \":\" << n << \":\" << odd[i] << endl;\n    for(j=i;j>=0;j--){\n      if(y>d+1){\n\tsaiki2(n-odd[j],d+1);\n      }\n    }\n  }\n}\nint main(){\n  int i,j,k;\n  fill(memo,memo+1000005,-1);\n  for(i=1;i<1000005;i++) {\n    m[i]=i*(i+1)*(i+2)/6;\n    if(m[i]%2==1) odd.push_back(m[i]);\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    x=1<<10;y=x;\n    saiki(n,0);saiki2(n,0);\n    cout << x << \" \" <<  y << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\ntypedef vector<int> vi;\nvi ans,ans2;\nconst int inf=1e9;\nint polnum[205];\nint dp[1000005];\nint odddp[1000005];\nint ntet=0;\nvoid ready()\n{\n  for(;;ntet++)\n  {\n    polnum[ntet]=ntet*(ntet+1)*(ntet+2)/6;\n    if(polnum[ntet]>=1000000) break;\n  }\n  for(int i=0;i<=1000000;i++)\n    {\n      dp[i]=odddp[i]=inf;\n    }\n    dp[0]=odddp[0]=0;\n}\n\nint main()\n{\n  ready();\n  int mx=0;\n  for(int i=0;i<5;i++)\n  {\n    for(int j=0;j<=1000000;j++)\n    {\n      for(int k=0;k<ntet;k++)\n      {\n\t\t\t\tif(j+polnum[k]>=1000000) break;\n\t\t\t\tif(polnum[k]%2==1) odddp[j+polnum[k]]=min(odddp[j+polnum[k]],odddp[j]+1);\n\t\t\t\tdp[j+polnum[k]]=min(dp[j+polnum[k]],dp[j]+1);\n\t\t\t\tmx=max(mx,j+polnum[k]);\n\t\t\t\tmx=min(mx,1000000-1);\n      }\n    }\n  }\n  int n;\n  while(cin >> n,n) cout << dp[n]<<\" \" << odddp[n] << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int c1[100000],c2[100000],i,m,p=0,dp1[100001],dp2[100001],k;\n  for(i=0;i*(i+1)*(i+2)/6<=100000;i++){\n    c1[i]=i*(i+1)*(i+2)/6;\n    if(c1[i]%2==1){\n      c2[p]=c1[i]; \n      p++; \n    }\n  }\n  while(1){\n  cin >>m;\n  if(m==0)break;\n  for(int j=0;j<=m;j++){\n    dp1[j]=j;\n    dp2[j]=j;\n    for(int k=0;k<i;k++){\n      if(j-c1[k]>=0)dp1[j]=min(dp1[j],dp1[j-c1[k]]+1);\n      if(k<p)\n\tif(j-c2[k]>=0){\n\tdp2[j]=min(dp2[j],dp2[j-c2[k]]+1);\n       }\n    }\n  }\n  cout << dp1[m]<<\" \"<<dp2[m]<<endl;\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\nint *all, *odd;\n\nint main()\n{\n\tint n, t[100];\n\tint counter = 0;\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tt[counter++] = n;\n\tint maxnum = 0;\n\n\t//入力値の最大を取得\n\tfor (int i = 0; i < counter; i++)\n\t\tmaxnum = max(maxnum, t[i]);\n\n\tall = new int[maxnum+1];\n\todd = new int[maxnum+1];\n\n\n\t//1からmaxnumまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four>maxnum)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からmaxnumまで，配列を埋める.\n\tfor (int i = 1; i <= maxnum; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//出力\n\tfor (int i = 0; i < counter; i++)\n\t\tcout << all[t[i]] << \" \" << odd[t[i]] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    vector<int> sime(1e2*5);\n    for(int i=0;i<sime.size();i++){\n        sime[i]=i*(i+1)*(i+2)/6;\n    }\n    while(cin>>n,n){\n        const int INF=1e7;\n        vector<int> times(n+1,INF);\n                vector<int> odtimes(n+1,INF);   \n        times[0]=0;\n        odtimes[0]=0;\n        for(int k=1;;k++){\n            if(n<sime[k]) break;\n            for(int i=0;i<times.size();i++){\n                if(i-sime[k]>=0) times[i]=min(times[i],times[i-sime[k]]+1);                \n            }\n            if(sime[k]%2==1){\n             for(int i=0;i<odtimes.size();i++){\n                if(i-sime[k]>=0) odtimes[i]=min(odtimes[i],odtimes[i-sime[k]]+1);                \n            }      \n            }\n        }\n        \n        cout<<times[n]<<\" \"<<odtimes[n]<<endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int MAX = 1000005;\nconst int INF = 1 << 29;\n\nint main(){\n    vector<int> dp(MAX, INF), dp_odd(MAX, INF);\n    // j を作るための最小数\n    dp[0] = dp_odd[0] = 0;\n    for(int i = 1; ; i++){\n        int t = i * (i + 1) * (i + 2) / 6;\n        if(t >= MAX) break;\n        for(int j = t; j < MAX; j++){\n            dp[j] = min(dp[j], dp[j - t] + 1);\n            if(t & 1){\n                dp_odd[j] = min(dp_odd[j], dp_odd[j - t] + 1);\n            }\n        }\n    }\n    int n;\n    while(cin >> n, n){\n        cout << dp[n] << \" \" << dp_odd[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[1000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b???ans??????????????????????????? */\n\n  /* ??£?????¢?????°?¨???? */\n  for (i = 1; i < 200; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;  /* input???0??§break */\n    int temp = input; /* input??????????????? */\n    int j = 1, min = input;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n      \n    /* ?????????????????¢?????° */\n    while (j > 1) {\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* tetras[k] > input???????£???°??? */\n            if (tetras[k] > input) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][0] = min;\n      \n    /* ?\\???°?????£?????¢?????°?????? */\n    j = l;  /* j??????????????? */\n    min = input; /* min??????????????? */\n    while (j > 1) {\n        /* ??¶??°?????£?????¢?????°????£???°??? */\n        if (tetras[j] % 2 == 0) {\n            j--;\n            continue;\n        }\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* ??¶??°?????£?????¢?????°????£???°??? */\n            if (tetras[k] % 2 == 0 || tetras[k] > input) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][1] = min;\n      \n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(a) cout << #a << \"=\" << a << endl\nusing namespace std;\n\n\nstruct Point {\n\tint w;\n\tint h;\n\tint taikaku;\n\n\tbool operator<( const Point &right ) const {\n\t\tif (taikaku == right.taikaku) {\n\t\t\treturn h < right.h;\n\t\t}\n\t\telse {\n\t\t\treturn taikaku < right.taikaku;\n\t\t}\n\t}\n};\n\nvector<Point> points;\n\nint main() {\n\tint H,W;\n\n\tfor(int y = 0; y < 150; y++) {\n\t\tfor(int x = 0; x < 150; x++) {\n\t\t\tint xx = x+1;\n\t\t\tint yy = y+1;\n\t\t\t//dump(xx);\n\t\t\t//dump(yy);\n\t\t\tif (xx > yy) {\n\t\t\t\tPoint p;\n\t\t\t\tp.w = xx;\n\t\t\t\tp.h = yy;\n\t\t\t\tp.taikaku = xx*xx + yy*yy;\n\t\t\t\tpoints.push_back(p);\n\t\t\t}\n\t\t}\n\t}\n\t//dump(points.size());\n\n\tsort(points.begin(), points.end());\n\t/*\n\tfor(int i = 0; i < points.size(); i++) {\n\t\tcout << points[i].taikaku << \" \";\n\t}\n\tcout << endl;\n\t*/\n\n\twhile(cin >> H >> W) {\n\t\tif (H == 0 && W == 0) { break; }\n\t\tPoint ans_p;\n\t\tint taikaku = H*H+W*W;\n\t\t//dump(points.size());\n\n\t\tfor(int i = 0; i < points.size(); i++)\n\t\t{\n\t\t\t//cout << points[i].h << \" \" << points[i].w << endl;\n\t\t\tif (points[i].w == W && points[i].h == H) {\n\t\t\t\tans_p = points[i+1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans_p.h << \" \" << ans_p.w << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <queue>\n#include <stack>\n#include <climits>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst ll mod = 1000000007;\nconst int inf = 1e9;\nconst long long INF = 1LL << 60;\n\n\nint main()\n{\n    vector<int> v;\n    int cnt = 1;\n\n    while(true){\n        \n        int tmp = (cnt*(cnt+1)*(cnt+2))/6;\n        if(tmp > 1000000) break;\n        v.push_back(tmp);\n        cnt++;\n    }\n    int s = v.size();\n    int dp[1000005];\n    int  odd[1000005];\n    for(int i = 0; i < 1000005;i++){\n        dp[i] = inf;\n        odd[i] = inf;\n    }\n    dp[0] = 0;\n    dp[1] = 1;\n    odd[0] = 0;\n    odd[1] = 1;\n    for(int i = 0; i < 1000005; i++){\n        for(int j = 0; j < v.size(); j++){\n            if(i + v[j] < 1000005){\n                dp[i+v[j]] = min(dp[i+v[j]],dp[i] + 1); \n                if(v[j] % 2 == 1){\n                    odd[i+v[j]] = min(odd[i+v[j]],odd[i] + 1); \n                }\n            }\n        }\n    }\n    while(true){\n        int x;  cin >> x;\n        if(x == 0) break;\n        cout << dp[x] << ' ' << odd[x] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint prime[200],dprime[100];\nint dp[1000001];\nint main(){\n\tint a=1,b=2,count=1,dcount=1;\n\tprime[0]=1,dprime[0]=1;\n\twhile(true){\n\t\ta+=b;\n\t\tb++;\n\t\tif(prime[count-1]+a>=1000000)\n\t\t\tbreak;\n\t\tif((prime[count-1]+a)%2==1){\n\t\t\tdprime[dcount]=prime[count-1]+a;\n\t\t\tdcount++;\n\t\t}\n\t\tprime[count]=prime[count-1]+a;\n\t\tcount++;\n\t}\n\tint n;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tdp[i]=i;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tint f=1;\n\t\t\twhile(true){\n\t\t\t\tdp[i+prime[f]]=min(dp[i+prime[f]],dp[i]+1);\n\t\t\t\tf++;\n\t\t\t\tif(f==count)\n\t\t\t\t\tbreak;\n\t\t\t\tif(prime[f]>n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n]<<\" \";\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tdp[i]=i;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tint f=1;\n\t\t\twhile(true){\n\t\t\t\tdp[i+dprime[f]]=min(dp[i+dprime[f]],dp[i]+1);\n\t\t\t\tf++;\n\t\t\t\tif(f==dcount)\n\t\t\t\t\tbreak;\n\t\t\t\tif(prime[f]>n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<ll> p;\nvector<ll> o;\nvector<ll> memo(1000001, INF);\n\nll cal(ll n) {\n\tif(memo[n] != INF) return memo[n];\n\telse {\n\t\tll ans = INF;\n\t\tll i = o.size() - 1;\n\t\twhile(i >= 0) {\n\t\t\tif(n - o[i] > 0)\n\t\t\tans = min(ans, 1 + cal(n - o[i]));\n\t\t\t--i;\n\t\t}\n\t\treturn memo[n] = ans;\n\t}\n}\n\nint main(void) {\n\n\tfor(ll i = 0; i * (i + 1) * (i + 2) / 6 <= 1000000; ++i) {\n\t\tp.pb(i * (i + 1) * (i + 2) / 6);\n\t\tif((i * (i + 1) * (i + 2) / 6) % 2 == 1) o.pb(i * (i + 1) * (i + 2) / 6);\n\t}\n\tvector<P> nf;\n\tvector<P> nb;\n\tREP(i, p.size()) {\n\t\tREP(j, p.size()) {\n\t\t\tif(p[i] + p[j] > 1000000) break;\n\t\t\tnf.pb(P(p[i] + p[j], (ll)(p[i] != 0) + (ll)(p[j] != 0)));\n\t\t\tREP(k, p.size()) {\n\t\t\t\tnb.pb(P(p[i] + p[j] + p[k], (ll)(p[i] != 0) + (ll)(p[j] != 0) + (ll)(p[k] != 0)));\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(nb));\n\tmemo[0] = 0;\n\tREP(i, o.size()) {\n\t\tmemo[o[i]] = 1;\n\t}\n\twhile(true) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tll ans1 = INF, ans2 = INF;\n\t\tvector<P>::iterator ite1;\n\t\tvector<P>::iterator ite2;\n\t\tfor(ll i = 0; i < nf.size(); ++i) {\n\t\t\tite1 = lower_bound(ALL(nb), P(n - nf[i].first, -1));\n\t\t\tite2 = upper_bound(ALL(nb), P(n - nf[i].first, INF));\n\t\t\tif(ite1 != nb.end() && ite2 - ite1 > 0) {\n\t\t\t\tans1 = min(ans1, (*ite1).second + nf[i].second);\n\t\t\t}\n\t\t}\n\t\tans2 = cal(n);\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint N;\nint dp[1000001], dpodd[1000001];\n\nint main() {\n\n\t//前計算でdpテーブルを計算。8sもあるのでオーダーは怪しいけど大丈夫のはず\n\tfor (int i = 1; i <= 1000000; i++)dp[i] = 1 << 29, dpodd[i] = 1 << 29;\n\n\tdp[0] = 0, dpodd[0] = 0;\n\tfor (int i = 1;; i++) {\n\t\tint cur = i * (i + 1) * (i + 2) / 6;\n\t\t\n\t\tif (cur > 1000000)break;\n\n\t\tfor (int j = cur; j <= 1000000; j++) {\n\t\t\tif (cur % 2 == 1) {\n\n\t\t\t\tdpodd[j] = min(dpodd[j], dpodd[j - cur] + 1);\n\t\t\t}\n\n\t\t\tdp[j] = min(dp[j], dp[j - cur] + 1);\n\t\t}\n\n\t}\n\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcout << dp[N] << \" \" << dpodd[N] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tvector<int> ttr;\n\tint n = 1;\n\twhile(1){\n\t\tint tr = n*(n+1)*(n+2) / 6;\n\t\tif(tr > 1000000) break;\n\t\tttr.push_back(tr);\n\t\tn++;\n\t}\n\n\tvector<int> dp(1000010,1000000);\n\tvector<int> dp_odd(1000010,1000000);\n\tdp[0] = dp_odd[0] = 0;\n\n\tfor( int i = 0; i < ttr.size(); i++ ){\n\t\tfor( int j = 0; j < 1000000-ttr[i]+1; j++ ){\n\t\t\tdp[j+ttr[i]] = min(dp[j+ttr[i]], dp[j]+1);\n\t\t\tif(ttr[i] % 2) dp_odd[j+ttr[i]] = min(dp_odd[j+ttr[i]], dp_odd[j]+1);\n\t\t}\n\t}\n\n\twhile(cin >> n, n){\n\t\tcout << dp[n] << ' ' << dp_odd[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint List[100];\n\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tList[i]=i*(i+1)*(i+2)/6;\n\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n//\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[1000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b???ans??????????????????????????? */\n\n  /* ??£?????¢?????°?¨???? */\n  for (i = 1; i < 200; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;  /* input???0??§break */\n    int temp = input; /* input??????????????? */\n    int j = 1, min = 1000;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n      \n    /* ?????????????????¢?????° */\n    while (j > 0) {\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][0] = min;\n      \n    /* ?\\???°?????£?????¢?????°?????? */\n    j = l;  /* j??????????????? */\n    min = 1000; /* min??????????????? */\n    while (j > 0) {\n        /* ??¶??°?????£?????¢?????°????£???°??? */\n        if (tetras[j] % 2 == 0) {\n            j--;\n            continue;\n        }\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* ??¶??°?????£?????¢?????°????£???°??? */\n            if (tetras[k] % 2 == 0) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][1] = min;\n      \n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,i,j,k,t=0,a[250]={},b[200]={},c[1000005]={2000000},d[1000005]={1000000};\n  for(i=1;i<250;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(a[i-1]%2==1)b[t++]=a[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<250;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t-1;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<d[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\nvector<int> solve(vector<int> &p) {\n    vector<int> dp(1000010, INF);\n    dp[0] = 0;\n\n    FOR(i, 0, p.size()) {\n        int v = p[i];\n        FOR(j, 0, dp.size()) {\n            if (dp[j] == INF) {\n                continue;\n            }\n            if (j + v < dp.size()) {\n                dp[j + v] = min(dp[j + v], dp[j] + 1);\n            }\n        }\n    }\n\n    return dp;\n}\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    vector<int> p1, p2;\n    FOR(i, 1, 200) {\n        int v = i * (i + 1) * (i + 2) / 6;\n        p1.emplace_back(v);\n        if (v % 2 != 0) {\n            p2.emplace_back(v);\n        }\n    }\n\n    auto ans1 = solve(p1);\n    auto ans2 = solve(p2);\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        cout << ans1[n] << \" \" << ans2[n] << endl;\n    }\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define BORDER (int)1e6\n#define INF (int)1e7\n\nusing namespace std;\n\nint main(){\n\tvector<int> t(1,0),t1(1,0);\n\tint c=1;\n\twhile(t[c-1]<=BORDER){\n\t\tint temp;\n\t\ttemp=c*(c+1)*(c+2)/6;\n\t\tt.push_back(temp);\n\t\tif(temp%2==1 ){\n\t\t\tt1.push_back(temp);\n\t\t}\n\t\tc++;\n\t}\n\n    vector<int> table(BORDER,0),table1(BORDER,0);\n\n    for(int i = 1; i < BORDER; i++){\n        int ans = INF;\n        for(int j = 1; j < t.size(); j++){\n            if(t[j] > i)break;\n            if(i - t[j] >= 0){\n                ans = min( ans, table[i-t[j]]+1);\n            }\n        }\n        table[i] = ans;\n        ans = INF;\n        for(int j = 1; j < t1.size(); j++){\n            if(t1[j] > i) break;\n            if(i - t[j] >= 0){\n                ans = min( ans, table1[ i - t1[j]] + 1);\n            }\n        }\n        table1[i] = ans;\n    }\n\n\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tcout << table[n] << \" \" << table1[n] << endl;\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n  \nusing namespace std;\n\n#define pi 3.141592653589793\n\nint main()\n{\n\tint result[1000001] = {};\n\tint odd_result[1000001] = {};\n\tfill(result, result + 1000000, 1000000);\n\tfill(odd_result, odd_result + 1000000, 1000000);\n\tint trangular_sum = 0, tetrahedral_sum = 0;\n\tresult[0] = 0;\n\todd_result[0] = 0;\n\tfor(int i = 1; tetrahedral_sum < 1000000; i++){\n\t\ttrangular_sum += i;\n\t\ttetrahedral_sum += trangular_sum;\n\t\t// result[trangular_sum] = 1;\n\t\tresult[tetrahedral_sum] = 1;\n\t\tif(tetrahedral_sum % 2 == 1) odd_result[tetrahedral_sum] = 1;\n\t}\n\tfor(int i = 1; i < 1000000; i++){\n\t\tfor(int j = 1; j < i; j++){\n\t\t\tresult[i] = min(result[i], result[i - j] + result[j]);\n\t\t\tif(j % 2 == 1) odd_result[i] = min(odd_result[i], odd_result[i - j] + odd_result[j]);\n\t\t}\n\t\t// cout << i  << \" \" << result[i] << \" \" << odd_result[i] << endl;\n\t}\n\tint n;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << result[n] << \" \" << odd_result[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nvector<int> P;\nvector<int> oddP;\nint memo[1001001];\nint mome[1001001];\n\nvoid hoge(){\n\n    for(int i=1; ; i++){\n        int p=i*(i+1)*(i+2)/6;\n        if(p>=1001001) break;\n        P.push_back(p);\n    }\n    for(int i=0; i<P.size(); i++){\n        memo[P[i]]=1;\n        if(P[i]%2) mome[P[i]]=1;\n    }\n}\n\nint rec(int n, bool odd){\n\n    if(odd){\n        if(mome[n]!=0) return mome[n];\n    }else{\n        if(memo[n]!=0) return memo[n];\n    }\n    int ret=1001001;\n    for(int i=0; n-P[i]>0; i++){\n        if(odd&&(P[i]%2==0)) continue;\n        ret=min(ret, rec(n-P[i], odd)+1);\n    }\n    if(odd){\n        return mome[n]=ret;\n    }else{\n        return memo[n]=ret;\n    }\n\n}\n\nint main(){\n\n    hoge();\n    bool odd=true;\n    while(1){\n        int N;\n        cin>> N;\n        if(!N) break;\n\n        cout<< rec(N, !odd)<<\" \";\n        cout<< rec(N, odd)<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int const M = 1e6+10;\n  // Mより小さい正四面体数を求める。\n  vector<int> tet[2];\n  for (int i=1; i<M; i++) {\n    int t = i * (i+1) * (i+2) / 6;\n    if (t >= M) break;\n    tet[0].push_back(t);\n    if (t % 2 == 1) {\n      tet[1].push_back(t);\n    }\n  }\n  int ans[2][M];\n  for (int i=0; i<=1; i++) { // 両方並行して行う。\n    ans[i][0] = 0;\n    for (int j=1; j<M; j++) {\n      int min = M;\n      for (unsigned int k=0; k<tet[i].size(); k++) {\n\tif (tet[i][k] > j) break;\n\tif (min > ans[i][j-tet[i][k]] + 1) {\n\t  min = ans[i][j-tet[i][k]] + 1;\n\t}\n      }\n      ans[i][j] = min;\n    }\n  }\n  int N;\n  while (scanf(\"%d\", &N) != EOF && N) {\n    printf(\"%d %d\\n\", ans[0][N], ans[1][N]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n\n\nint main() {\n  vector<int> v, ov;\n  for (int i = 1; i*(i+1)*(i+2)/6 < 1000000; i++)\n    v.push_back(i*(i+1)*(i+2)/6);\n\n  vector<int> table(1000000, INT_MAX);\n  vector<int> otable(1000000, INT_MAX);\n  for (int i = 0; i < v.size(); i++) {\n    table[v[i]] = 1;\n    if (v[i] % 2)\n      otable[v[i]] = 1;\n  }\n  \n  for (int i = 1; i < 1000000; i++) {\n    for (int j = 0; j < v.size() && v[j] < i; j++) {\n      table[i] = min(table[v[j]] + table[i-v[j]], table[i]);\n      if (v[j] % 2)\n        otable[i] = min(otable[v[j]] + otable[i-v[j]], otable[i]);\n    }\n    //   cout << i << \" \" << table[i] << endl;\n  }\n\n  int n;\n  while (cin >> n && n)\n    printf(\"%d %d\\n\", table[n], otable[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define INF (1<<29)\n\nint N;\nint a[1010],dp[2][1000010];\n\nvoid make(){\n  int n;\n  for(n = 1; n <= 1000; n++) a[n] = n * (n+1) * (n+2) / 6;\n}\n\nint main(){\n  int i,j,k;\n\n  make();\n\n  for(;;){\n    scanf(\"%d\",&N); if(N == 0) break;\n\n    rep(i,2) rep(j,1000010) dp[i][j] = INF;\n\n    dp[0][0] = dp[1][0] = 0;\n    for(i = 1; a[i] <= N && i < 1010; i++){\n      for(j = 0; j <= N; j++){\n        if(j - a[i] >= 0) dp[0][j] = min(dp[0][j], dp[0][j - a[i]] + 1);\n        if(a[i] % 2 == 1 && j - a[i] >= 0) dp[1][j] = min(dp[1][j], dp[1][j - a[i]] + 1);\n      }\n    }\n\n    cout << dp[0][N] << ' ' << dp[1][N] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint x[200][1000000], n, z[1000], y[1000], p, MAX;\nint main() {\n\tz[0] = 0; for (int i = 1; i < 200; i++) { z[i] = z[i - 1] + (i + 1)*i / 2;}\n\tfor (int i = 1; i < 200; i++) { if (z[i] % 2 == 1) { p++; y[p] = z[i]; } }\n\twhile (true) {\n\t\tMAX = 2147483647; p = 0;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmemset(x, 127, sizeof(x));\n\t\tx[0][0] = 0;\n\t\tfor (int i = 1; i < 200; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (x[i - 1][j] < 2000000000) {\n\t\t\t\t\tfor (int k = 0; k <= (n - j) / z[i]; k++) {\n\t\t\t\t\t\tx[i][j + z[i] * k] = min(x[i][j + z[i] * k], x[i - 1][j] + k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (MAX > x[i][n]) { p = i; MAX = x[i][n]; }\n\t\t}\n\t\tcout << MAX << ' ';\n\t\tMAX = 2147483647;\n\t\tmemset(x, 127, sizeof(x));\n\t\tx[0][0] = 0;\n\t\tfor (int i = 1; i < 50; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (x[i - 1][j] < 2000000000) {\n\t\t\t\t\tfor (int k = 0; k <= (n - j) / y[i]; k++) {\n\t\t\t\t\t\tx[i][j + y[i] * k] = min(x[i][j + y[i] * k], x[i - 1][j] + k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (MAX > x[i][n]) { p = i; MAX = x[i][n]; }\n\t\t}\n\t\tcout << MAX << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nconst int MAX = 200;\n\nint ans;\n\nvector<int> tetra;\nvector<int> odd;\n\nvoid init()\n{\t\n\trep(i,MAX){\n\t\ttetra.push_back(i*(i+1)*(i+2)/6);\n\t}\n\n\trep(i,tetra.size()){\n\t\tif(tetra[i]%2!=0){ \n\t\t\todd.push_back(tetra[i]);\n\t\t}\t\n\t}\n}\n\n\nvoid dfs(int n, int num, int deep, vector<int> &list, int limit)\n{\n\tif(deep > limit){ return; }\n\t\n\tint tmp = num;\n\trep(i,list.size())\n\t{\n\t\ttmp += list[i];\n\t\t\n\t\tif(deep > ans){ return; }\n\t\tif(n == tmp){ ans = min(ans,deep); return; }\n\t\tif(n < tmp){ return; }\n\t\t\n\t\tdfs(n, tmp, deep+1, list, limit);\n\t\ttmp = num;\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\tint N;\n\n\tinit();\n\n\twhile(cin >> N && N)\n\t{\n\t\tint ans_tet,ans_odd;\n\n\t\tans = INT_MAX;\n\t\tdfs(N,0,1,tetra,5);\n\t\tans_tet = ans;\n\t\n\t\tans = INT_MAX;\n\t\tdfs(N,0,1,odd,INT_MAX);\n\t\tans_odd = ans;\n\t\t\n\t\tcout << ans_tet << \" \" << ans_odd << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tstatic int num[1000001],odd[1000001];\n\tvector<int> pol,podd;\n\tfor(int i = 0;i <= 1000000;i++) odd[i] = i;\n\tfor(int i = 1;;i++){\n\t\tint p = i * (i + 1) * (i + 2) / 6;\n\t\tif(p > 1000000) break;\n\t\tpol.push_back(p);\n\t\tnum[p] = 1;\n\t\tif(p % 2) podd.push_back(p);\n\t}\n\tfor(int i = 1;i <= 4;i++){\n\t\tfor(int j = 0;j <= 1000000;j++){\n\t\t\tif(num[j] == i){\n\t\t\t\tfor(int k = 0;k < pol.size();k++){\n\t\t\t\t\tif(j + pol[k] <= 1000000) {\n\t\t\t\t\t\tif(!num[j + pol[k]]) num[j + pol[k]] = i + 1;\n\t\t\t\t\t\telse num[j + pol[k]] = min(num[j + pol[k]],i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i < podd.size();i++){\n\t\tfor(int j = 0;j <= 1000000;j++){\n\t\t\tif(j + podd[i] > 1000000) break;\n\t\t\todd[j + podd[i]] = min(odd[j + podd[i]],odd[j] + 1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n,n){\n\t\tcout << num[n] << \" \" << odd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tlong int ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1002; i++) {\n\t\t\t/*if (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}*/\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1002; i++) {\n\t\t\t/*if (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}*/\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nconst int m = 1000001;\n\nint a[2][200];\nint dp[2][1000004];\n\nint main() {\n\n    int c = 0;\n    for(int i=1;(i*(i+1)*(i+2))<m;i++) {\n        a[0][i-1] = i*(i+1)*(i+2)/6;\n        if(a[0][i-1]%2) {\n            a[1][c] = a[0][i-1];\n            c++;\n        }\n    }\n\n    rep(i, 2)rep(j, m)dp[i][j] = j;\n\n    rep(i, 2)\n        rep(j, 200)\n            rep(k, m)\n                if((k-a[i][j])>=0 && dp[i][k-a[i][j]] < dp[i][k])dp[i][k] = dp[i][k-a[i][j]] + 1;\n\n    int n;\n    while(cin>>n,n)cout<<dp[0][n]<<' '<<dp[1][n]<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 1000000\n\nint main(){\n  int s[200], dp1[MAX], dp2[MAX];\n  for(int i=1;i<200;i++) s[i]=i*(i+1)*(i+2)/6;\n  for(int i=0;i<MAX;i++){\n    dp1[i] = dp2[i] = i;\n    for(int j=1;i>=s[j];j++){\n      dp1[i] = min(dp1[i], dp1[i-s[j]]+1);\n      if(s[j]%2==1){\n        dp2[i] = min(dp2[i], dp2[i-s[j]]+1);\n      }\n    }\n  }\n  int n;\n  while(true){\n    cin >> n;\n    if(n==0) break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint prime[200],dprime[100];\nint dp[1000001];\nint main(){\n\tint a=1,b=2,count=1,dcount=1;\n\tprime[0]=1,dprime[0]=1;\n\twhile(true){\n\t\ta+=b;\n\t\tb++;\n\t\tif(prime[count-1]+a>=1000000)\n\t\t\tbreak;\n\t\tif((prime[count-1]+a)%2==1){\n\t\t\tdprime[dcount]=prime[count-1]+a;\n\t\t\tdcount++;\n\t\t}\n\t\tprime[count]=prime[count-1]+a;\n\t\tcount++;\n\t}\n\tint n;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tdp[i]=i%4+i/4;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tint f=2;\n\t\t\twhile(true){\n\t\t\t\tdp[i+prime[f]]=min(dp[i+prime[f]],dp[i]+1);\n\t\t\t\tf++;\n\t\t\t\tif(f==count)\n\t\t\t\t\tbreak;\n\t\t\t\tif(prime[f]>n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n]<<\" \";\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tdp[i]=i%35+i/35;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tint f=2;\n\t\t\twhile(true){\n\t\t\t\tdp[i+dprime[f]]=min(dp[i+dprime[f]],dp[i]+1);\n\t\t\t\tf++;\n\t\t\t\tif(f==dcount)\n\t\t\t\t\tbreak;\n\t\t\t\tif(prime[f]>n)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<dp[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2510\n\n#include<iostream>\n#include<fstream>\n\n#define N 1000//データの最大個数\n#define ami 0\n#define mami 1\n\nint n = 0;\nint wTime[N] = {};\n\nint sum(int a[]){\n\tint ans = 0;\n\tfor (int i = 0; a[i] != 0; i++)\n\t\tans += a[i];\n\treturn ans;\n}\n\nint timeCalc(int differ, int sum){\n\tbool dp[10000] = {true,};\n\n\t//wTime[0 ? n-2]はsort済み\n\tint time = 0;\n\tint max = 0;\n\n\tfor (int i = 0; i < n - 2; i++){\n\t\tfor (int j = differ; j >= wTime[i]; j--){\n\t\t\tif(dp[j - wTime[i]])dp[j] = true;\n\t\t\tif(dp[j] && time < j)time = j;\n\t\t}\n\t}\n\treturn time;\n}\n\nint main(){\n\tusing namespace std;\n\n\tint rTime[N] = {};\n\tint allTime[2] = {0, 0};\n\n\twhile (true){\n\t\tcin >> n;\n\t\tif (n == 0)break;//終了条件\n\n\t\tfor (int i = 0; i < N; i++){//初期化\n\t\t\trTime[i] = wTime[i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> rTime[i] >> wTime[i];\n\t\t}\n\n\t\tif (n == 1){\n\t\t\tcout << 2 * rTime[0] + wTime[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//読書時間でbubble sort\n\t\tfor (int i = n - 1; i >= 0; i--){\n\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\tif (rTime[j] > rTime[j + 1]){\n\t\t\t\t\tint tmp = rTime[j];\n\t\t\t\t\trTime[j] = rTime[j + 1];\n\t\t\t\t\trTime[j + 1] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//計算開始\n\n\t\t//read\n\t\t//最も読む時間のかかる一つと、その他の全ての和を比較\n\n\t\t//max <= sum\n\t\tif (sum(rTime) >= 2 * rTime[n - 1]){\n\t\t\tcout << sum(rTime) + sum(wTime) << endl;\n\t\t}\n\n\t\t//max > sum\n\t\telse if (sum(rTime) < 2 * rTime[n - 1]){\n\n\t\t\tallTime[ami] = rTime[n - 1];\n\t\t\tallTime[mami] = sum(rTime) - rTime[n - 1];\n\n\t\t\tint differ = allTime[ami] - allTime[mami];\n\n\t\t\tfor (int i = n - 2; i >= 0; i--){\n\t\t\t\tfor (int j = 0; j < i; j++){\n\t\t\t\t\tif (wTime[j] > wTime[j + 1]){\n\t\t\t\t\t\tint tmp = wTime[j];\n\t\t\t\t\t\twTime[j] = wTime[j + 1];\n\t\t\t\t\t\twTime[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint writingTime = timeCalc(differ, allTime[mami]);\n\n\t\t\tcout << sum(rTime) + sum(wTime) + differ - writingTime << endl;\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\nint dpodd[190][1000010] = { 0 };\n//vector<vector<int>> dp;\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP_N(i,n,s) for(ll i=0; i<(ll)n; i+=s)\n#define REP(i,n) REP_N(i,n,1)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nvoid solution(ll output[1000001], int interval) {\n\toutput[0] = 0;\n\tll current_i = interval-1;\n\tREP(i, 1000001) if(i!=0) {\n\t\tll minimum = 1000001;\n\t\tREP(j, current_i+1, interval) if(j!=0) minimum = min(output[i - table[j]] + 1, minimum);\n\t\toutput[i] = minimum;\n\n\t\tif (table[current_i + interval] == i) current_i += interval;\n\t}\n}\n\nint main() {\n\t//freopen(\"Text.txt\", \"r\", stdin);\n\t\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i++]) table[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tsolution(pollock, 1);\n\tsolution(dp, 4);\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma warning(disable: 4244) // 最悪をします\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#define BIT(nr) (1UL << (nr))\n#define int long long\n//#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t//ない環境用\n#define LL_HALFMAX 9223372036854775807 / 2\t//ない環境用\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\n\nusing namespace std;\n\n//デバッグ用カッコの有無\n#ifdef DEBUG\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\to << \"{\"; for (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\tfor (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \" \" : \"\") << v[i]; return o;\n}\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nint dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)\nint dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\nvoid solve() {\n\n}\n\nint all[1000010];\nint odd[1000010];\n\nint proc(int n) {\n\treturn n * (n + 1) * (n + 2) / 6;\n}\n\nsigned main() {\n\trep(i, 1000010) {\n\t\tall[i] = LL_HALFMAX;\n\t\todd[i] = LL_HALFMAX;\n\t}\n\n\tvector<int> s, t;\n\n\tint i = 1;\n\twhile (proc(i) <= 1000000) {\n\t\tif (proc(i) % 2 == 1) {\n\t\t\tt.push_back(proc(i));\n\t\t}\n\t\ts.push_back(proc(i));\n\t\ti++;\n\t}\n\tall[0] = 0;\n\todd[0] = 0;\n\n\t// all\n\tfor (int p : s) {\n\t\trep(j, 1000010) {\n\t\t\tif (j + p <= 1000000) {\n\t\t\t\tchmin(all[j + p], all[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t// odd\n\tfor (int p : t) {\n\t\trep(j, 1000010) {\n\t\t\tif (j + p <= 1000000) {\n\t\t\t\tchmin(odd[j + p], odd[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint ip;\n\t\tcin >> ip;\n\t\tif (ip == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << all[ip] << \" \" << odd[ip] << \"\\n\";\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt) {\n    int res=0xFFFF;\n    if(cnt>100) return 0xFFFF;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i && res>cnt; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1));\n    }\n    return res;\n}\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\",res,oddrec(n, 0, 0));\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#include <string.h>\n\nusing namespace std;\n\n#define MAX_D 100000\n#define MAX_N 1000000\n#define MAX_F 200\n\n#define INF 100000000\n\nint main()\n{\n\tstatic int N[MAX_D], F[MAX_F], dp1[MAX_N], dp2[MAX_N];\n\n\tint c = 0;\n\n\tfor (int i = 0; i < MAX_N; i++) { dp1[i] = INF; dp2[i] = INF; }\n\n\twhile (true)\n\t{\n\t\tcin >> N[c];\n\n\t\tif (N[c] == 0) { break; }\n\n\t\tc++;\n\t}\n\n\tint max = *max_element(N, N + c);\n\n\tfor (int i = 1; i < MAX_F; i++)\n\t{\n\t\tF[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\n\tdp1[0] = 0;\n\tdp2[0] = 0;\n\n\tfor (int i = 1; i <= max; i++)\n\t{\n\t\tfor (int j = 1; j < MAX_F; j++)\n\t\t{\n\t\t\tif (i < F[j])\n\t\t\t{\n\t\t\t\tgoto Exit1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (dp1[i - F[j]] + 1 < dp1[i])\n\t\t\t\t{\n\t\t\t\t\tdp1[i] = dp1[i - F[j]] + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit1:;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= max; i++)\n\t{\n\t\tfor (int j = 1; j < MAX_F; j++)\n\t\t{\n\t\t\tif (F[j] % 2 == 1)\n\t\t\t{\n\t\t\t\tif (i < F[j])\n\t\t\t\t{\n\t\t\t\t\tgoto Exit2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (dp2[i - F[j]] + 1 < dp2[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tdp2[i] = dp2[i - F[j]] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit2:;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < c; i++)\n\t{\n\t\tcout << dp1[N[i]] << ' ' << dp2[N[i]] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\nint n;\nint dp[5000001];\nint dp2[5000001];\n\nint func(int v){\n\tif(dp[v]!=11451419)return dp[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tint j=1;\n\twhile(j*(j+1)*(j+2)/6<=v)j++;\n\tj--;\n\tfor(int i=j;i>=1;i--){\n\t\tcnt=min(cnt,func(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp[v]=cnt+1);\n}\n\nint func2(int v){\n\tif(dp2[v]!=11451419)return dp2[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tint j=1;\n\twhile(j*(j+1)*(j+2)/6<=v)j++;\n\tj--;\n\tfor(int i=j;i>=1;i--){\n\t\tif((i*(i+1)*(i+2)/6)%2!=1)continue;\n\t\tcnt=min(cnt,func2(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp2[v]=cnt+1);\n}\n\nint main(void){\n\tfor(int i=1;i<=2000000;i++)dp[i]=dp2[i]=11451419;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",func(n),func2(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint N;\nint dp[1000001], dpodd[1000001];\n\nint main() {\n\n\t//前計算でdpテーブルを計算。8sもあるのでオーダーは怪しいけど大丈夫のはず\n\n\tfor (int i = 0; i <= 1000000; i++)dp[i] = 1145141919, dpodd[i] = 1145141919;\n\n\tdp[0] = 0, dpodd[0] = 0;\n\tfor (int i = 1; i <= 180; i++) {\n\t\tint cur = i * (i + 1) * (i + 2) / 6;\n\t\tfor (int j = 1; j <= 1000000; j++) {\n\t\t\tif (i % 2 == 1) {\n\t\t\t\tif (j - cur >= 0)dpodd[j] = max(dpodd[j], dpodd[j - 1] + 1);\n\t\t\t}\n\n\t\t\tif (j - cur >= 0)dp[j] = min(dp[j], dp[j - cur] + 1);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcout << dp[N] << \" \" << dpodd[N] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n\nint main(void){\n\tint i, j, n, min1,small;\n\tint dp[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tsmall = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dp[i] < small){\n\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(small > dp[n])\n\t\t\t\tsmall = dp[n];\n\t\t}\n\n\t\tmin1 = dp[n];\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tsmall = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dp[i] < small){\n\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(small > dp[n])\n\t\t\t\tsmall = dp[n];\n\t\t}\n\t\tprintf(\"%d %d\\n\",min1,dp[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll mod=1000000007;\nconst ll LINF=1LL<<60;\nconst int INF=1<<30;\nint main(){\n    vector<int> a;\n    int n = 1;\n    a.pb(0);\n    vector<int> b;\n    int m = 1;\n    b.pb(0);\n    while(n * (n + 1) * (n + 2) / 6 < 1000000){\n        a.pb(n * (n + 1) * (n + 2) / 6);\n        if (((n * (n + 1) * (n + 2) / 6) % 2 )== 1){\n            b.pb(n * (n + 1) * (n + 2) / 6);\n            m++;\n        }\n        n++;\n    }\n    vector<int> dp(1000001,6);\n    dp[0] = 0;\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= 1000000; j++) {\n            if (j - a[i] >= 0){\n                dp[j] = min(dp[j],dp[j - a[i]] + 1);\n            }\n        }\n    }\n\n    vector<int> dp2(1000001,INF);\n    dp2[0] = 0;\n    for(int i = 1; i < m; i++) {\n        for(int j = 1; j <= 1000000; j++) {\n            if (j - b[i] >= 0){\n                dp2[j] = min(dp2[j],dp2[j - b[i]] + 1);\n            }\n        }\n    }\n\n    while(1){\n        int x;cin>>x;\n        if(x == 0){\n            break;\n        }\n        cout << dp[x] << ' ' << dp2[x] << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-14\n\n#define all(v) v.begin(),v.end()\n#define INF 1<<30\n#define mp\n#define pb push_back\n\n#define fi\n#define se\n\n#define each\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\n\nint f(int n, int m, vi a){\n\tvi t(n+1,INF);\n\tt[0] = 0;\n\trep(i,m){\n\t\tREP(j,a[i],n+1){\n\t\t\tt[j] = min(t[j],t[j-a[i]]+1);\n\t\t}\n\t}\n\treturn t[n];\n}\n\nint main(){\n\tvi a;\n\tvi ao;\n\tREP(i,1,200){\n\t\ta.pb(i*(i+1)*(i+2)/6);\n\t}\n\trep(i,a.size()){\n\t\tif(a[i]%2==1) ao.pb(a[i]);\n\t}\n\n\t// rep(i,a.size()) cout<<a[i]<<endl;\n\t// cout<<\"=--\"<<endl;\n\t// rep(i,ao.size()) cout<<ao[i]<<endl;\n\n\twhile(1){\n\t\tint n; cin>>n;\n\t\tif(n==0) break;\n\t\tcout<<f(n,a.size(),a)<<\" \"<<f(n,ao.size(),ao)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    vector<int> v;\n    for (int n = 1; n * (n + 1) * (n + 2) / 6 < 1e6; n++) v.push_back(n * (n + 1) * (n + 2) / 6);\n    //rep(i, v.size()) cout << v[i] << \" \";\n    //cout << v.size() << \"\\n\";\n    // dp[i][j] i番目の正四面体数を使ってjを作る最小数\n    // dp1[i][j] 奇数だけ使う場合\n    int n = v.size(), idx = 0;\n    vector<vector<int>> dp(2, vector<int>(1e6, 1e9)), dp1(2, vector<int>(1e6, 1e9));\n    dp[0][0] = 0;\n    dp1[0][0] = 0;\n    rep(i, n) {\n        rep(j, 1e6) {\n            dp[(i + 1) % 2][j] = dp[i % 2][j];\n            dp1[(i + 1) % 2][j] = dp1[i % 2][j];\n            if (j >= v[i]) dp[(i + 1) % 2][j] = min(dp[i % 2][j], dp[(i + 1) % 2][j - v[i]] + 1);\n            if (v[i] % 2) {\n                if (j >= v[i]) dp1[(i + 1) % 2][j] = min(dp1[i % 2][j], dp1[(i + 1) % 2][j - v[i]] + 1);\n            }\n        }\n    }\n    int x;\n    cin >> x;\n    while (x != 0) {\n        cout << dp[n % 2][x] << \" \" << dp1[n % 2][x] << \"\\n\";\n        cin >> x;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n\n//FILE *in = freopen(\"C\", \"r\", stdin);\n\nint data[] = {1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286, 364, 455, 560, 680, 816, 969, 1140, 1330, 1540, 1771, 2024, 2300, 2600, 2925, 3276, 3654, 4060, 4495, 4960, 5456, 5984, 6545, 7140, 7770, 8436, 9139, 9880, 10660, 11480, 12341, 13244, 14190, 15180, 16215, 17296, 18424, 19600, 20825, 22100, 23426, 24804, 26235, 27720, 29260, 30856, 32509, 34220, 35990, 37820, 39711, 41664, 43680, 45760, 47905, 50116, 52394, 54740, 57155, 59640, 62196, 64824, 67525, 70300, 73150, 76076, 79079, 82160, 85320, 88560, 91881, 95284, 98770, 102340, 105995, 109736, 113564, 117480, 121485, 125580, 129766, 134044, 138415, 142880, 147440, 152096, 156849, 161700, 166650, 171700, 176851, 182104, 187460, 192920, 198485, 204156, 209934, 215820, 221815, 227920, 234136, 240464, 246905, 253460, 260130, 266916, 273819, 280840, 287980, 295240, 302621, 310124, 317750, 325500, 333375, 341376, 349504, 357760, 366145, 374660, 383306, 392084, 400995, 410040, 419220, 428536, 437989, 447580, 457310, 467180, 477191, 487344, 497640, 508080, 518665, 529396, 540274, 551300, 562475, 573800, 585276, 596904, 608685, 620620, 632710, 644956, 657359, 669920, 682640, 695520, 708561, 721764, 735130, 748660, 762355, 776216, 790244, 804440, 818805, 833340, 848046, 862924, 877975, 893200, 908600, 924176, 939929, 955860, 971970, 988260, 1004731};\nint data2[] = {1, 35, 165, 455, 969, 1771, 2925, 4495, 6545, 9139, 12341, 16215, 20825, 26235, 32509, 39711, 47905, 57155, 67525, 79079, 91881, 105995, 121485, 138415, 156849, 176851, 198485, 221815, 246905, 273819, 302621, 333375, 366145, 400995, 437989, 477191, 518665, 562475, 608685, 657359, 708561, 762355, 818805, 877975, 939929, 1004731};\n\nint n;\nint d1[1000010];\nint d2[1000010];\n\nvoid process() {\n\tfill(d1, d1 + n + 1 , -1);\n\tfill(d2, d2 + n + 1 , -1);\n\td1[0] = 0;\n\td2[0] = 0;\n\tfor(int i = 0; i < 181; i++) {\n\t\tfor(int j = data[i]; j <= n; j++) {\n\t\t\tif(d1[j - data[i]] != -1) {\n\t\t\t\tif(d1[j] == -1 || d1[j] > d1[j-data[i]] + 1) {\n\t\t\t\t\td1[j] = d1[j-data[i]] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < 46; i++) {\n\t\tfor(int j = data2[i]; j <= n; j++) {\n\t\t\tif(d2[j - data2[i]] != -1) {\n\t\t\t\tif(d2[j] == -1 || d2[j] > d2[j-data2[i]] + 1) {\n\t\t\t\t\td2[j] = d2[j-data2[i]] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", d1[n], d2[n]);\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint tetrahedron(int);\n\nint index_direct_match(int);\nint index_direct_match_odd(int);\nint index_number(int);\nint index_number_odd(int);\n\nint main(int argc, char const *argv[]) {\n\n  int n;\n  int cnt_min;\n  int cnt_only_odd;\n\n  for(cin >> n;n != 0;cin >> n){\n\n    cout << index_number(n) << \" \" <<  index_number_odd(n) << endl;\n\n  }\n\n  //\n\n  return 0;\n}\n\nint tetrahedron(int k){\n\n  return k*(k+1)*(k+2)/6;\n\n}\n\nint index_number(int index){\n  static int memo[1000]={};\n  if(index>=1 && index<=3) return index;\n  else if(index_direct_match(index)) return 1;\n  else if(memo[index] != 0) return memo[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i++){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number( index - tetrahedron(i) ));\n    }\n    memo[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n\n}\n\nint index_direct_match(int index){\n\n  for(int i=1;i<200;i++){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_direct_match_odd(int index){\n\n  for(int i=1;i<200;i+=4){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_number_odd(int index){\n  static int memo2[1000]={};\n  if(index>=1 && index<=34) return index;\n  else if(index_direct_match_odd(index)) return 1;\n  else if(memo2[index] != 0) return memo2[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i+=4){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number_odd( index - tetrahedron(i) ));\n    }\n    memo2[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long // intで書いたけど心配なときにlong longに変換する\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n#define EACH(i, n) for (auto&& i : n)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n\nint tetranum[200];  // 10^6未満は180番目まで\nint DP[1000001];  // たどり着く最小回数\nint DPodd[1000001];  // 奇数だけでたどり着く最小回数\n\nvoid solve(int num) {\n    cout << DP[num] << \" \" << DPodd[num] << endl;\n}\n\nsigned main() {\n    int N;\n    REP(i, 200) {\n        N = i+1;\n        tetranum[i] = N * (N+1) * (N+2) / 6;\n    }\n\n    REP(i, 1000001) {\n        DP[i] = INF;\n        DPodd[i] = INF;\n    }\n\n    int tnum;\n    REP(i, 200) {\n        tnum = tetranum[i];\n        if(tnum < 1000000) {\n            DP[tnum] = 1;\n            if(tnum % 2 == 1) {\n                DPodd[tnum] = 1;\n            }\n        }\n    }\n\n    REPS(st, 1, 1000000) {\n        REP(i, 200) {\n            tnum = tetranum[i];\n            if (st+tnum < 1000000) {\n                DP[st+tnum] = min(DP[st]+1, DP[st+tnum]);\n                if (tnum % 2 == 1) {\n                    DPodd[st+tnum] = min(DPodd[st]+1, DPodd[st+tnum]);\n                }\n            }\n        }\n    }\n\n    int num;\n    while(true){\n        cin >> num;\n        if(num == 0) {\n            break;\n        } else {\n            solve(num);\n        }\n    }\n\n    return 0;\n}\n\n// https://github.com/kurokoji/.cpp-Template/wiki テンプレートについて\n// http://www.creativ.xyz/dump-cpp-652 dump()について\n// https://gist.github.com/rigibun/7905920 色々\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INT_INF = 2147483647;\nconst long long LL_INF = 1LL<<60;\nconst long long MOD = 1000000007;\n\n#define CLR(a) memset((a), 0, sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint main(void){\n    VI p;\n    FOR(i,1,1000){\n        if(i*(i+1)*(i+2)/6 > 1e6) break;\n        p.push_back(i*(i+1)*(i+2)/6);\n    }\n\n    VI dp(1e6,INT_INF);\n    dp[0] = 0;\n    for(int i : p){\n        for(int j = i; j < 1e6; j++) chmin(dp[j], dp[j-i]+1);\n    }\n    VI dp1(1e6,INT_INF);\n    dp1[0] = 0;\n    for(int i : p){\n        if(i%2 == 0) continue;\n        for(int j = i; j < 1e6; j++) chmin(dp1[j], dp1[j-i]+1);\n    }\n\n    int x; cin >> x;\n    while(x != 0){\n        cout << dp[x] << \" \" << dp1[x] << en;\n        cin >> x;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n\n  for(int i=0;i<1111111;i+=10){ solve(i), solve2(i); }\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dp1[1000005], dp2[1000005];\nvoid makeDP(){\n  vector<int> v1;\n  vector<int> v2;\n  int tn = 1;\n  while(1){\n      int tmp = tn*(tn+1)*(tn+2)/6;\n      if(tmp < 1000000){\n        v1.push_back(tmp);\n        if(tmp % 2 != 0) v2.push_back(tmp);\n      }else{\n        break;\n      }\n      tn++;\n  }\n  REP(i,0,1000005) dp1[i] = i, dp2[i] = i;\n  REP(i,1,180){\n    REP(j,0,1000005){\n      if(j-v1[i] >= 0) dp1[j] = min(dp1[j], dp1[j-v1[i]] + 1);\n    }\n  }\n  REP(i,1,45){\n    REP(j,0,1000005){\n      if(j-v2[i] >= 0) dp2[j] = min(dp2[j], dp2[j-v2[i]] + 1);\n    }\n  }\n}\n\nint main() {\n\n  makeDP();\n\n  int N;\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    cout<<dp1[N]<<\" \"<<dp2[N]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define M 1111111\n#define F 2222\n\n#define INF 1000000000\n\nint dp1[M];\nint dp2[M];\n\nint main(){\n\t\n\tvector<int> num;\n\t\n\tint sum=0;\n\treps(i,1,M){\n\t\tsum = sum+(i+1)*i/2;\n\t\tif(sum>M)break;\n\t\tnum.push_back(sum);\n\t}\n\t\n\tvector<int> numodd;\n\trep(i,num.size()){\n\t\tif(num[i]%2==1)numodd.push_back(num[i]);\n\t}\n\t\n\trep(i,M)dp1[i]=dp2[i]=INF;\n\tdp1[0]=dp2[0]=0;\n\t\n\trep(i,M){\n\t\trep(j,num.size()){\n\t\t\tif(i-num[j]>=0)dp1[i] = min(dp1[i] , dp1[i-num[j]]+1);\n\t\t}\n\t}\n\trep(i,M){\n\t\trep(j,numodd.size()){\n\t\t\tif(i-numodd[j]>=0)dp2[i] = min(dp2[i] , dp2[i-numodd[j]]+1);\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,i,j,k,t=0,a[200]={},b[200]={},c[1000005]={1000000},d[1000005]={1000000};\n  for(i=1;i<201;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(a[i-1]%2==1)b[t++]=a[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<200;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<b[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define rep(i,n) for(int i=0, i##_len=(int)(n); i<i##_len; i++)\n#define reps(i,n) for(int i=1 , i##_len=(int)(n);i<=i##_len;i++)\n#define rrep(i,n) for(int i=((int)(n)-1);i>=0;i--)\n#define rreps(i,n) for(int i=((int)(n));i>0;i--)\n#define all(x) (x).begin(), (x).end()\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define solve(a) ((a)?\"Yes\":\"No\")\ntypedef vector<long long> V;\ntypedef vector<V> VV;\ntypedef pair<long long , long long> P;\ntypedef vector<P> VP;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1;} return 0;}\nconst long long INFLL = 1LL<<62;\nconst int INF = 1<<30;\nconst double PI=acos(-1);\nint main(){\n    int n=1000010;\n    vector<int>em(260,0);\n    for(int i=0;i<250;i++){\n        em[i]=i*(i+1)*(i+2)/6;\n      //  clog<<em[i]<<endl;\n    }\n    vector<pair<int,int>>dp(1000010,mp(INF,INF));\n    while(1){\n        dp[0] = mp(0, 0);\n        for (int i = 0; em[i] <= n; i++)\n        {\n            for (int j = 0; j + em[i] <= n; j++)\n            {\n                chmin(dp[j + em[i]].F, dp[j].F + 1);\n                if (em[i] % 2 == 1)\n                {\n                    chmin(dp[j + em[i]].S, dp[j].S + 1);\n                }\n            }\n        }\n        cin>>n;\n        if(n==0){\n            break;\n        }\n        \n\n        cout << dp[n].F<<\" \"<<dp[n].S << endl;\n    }\n    \n   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[60]={0},c[200001]={0,1,2,3},d[200001],k=0,i,j,n;\n  for(i=1;i<100;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<99;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\nconst int MAX = 1000100;\nconst int INF = 1<<29;\n\nint adp[MAX], odp[MAX];\n\nint main() {\n    for (int i = 0; i < MAX; ++i) adp[i] = odp[i] = MAX;\n    adp[0] = 0;\n    odp[0] = 0;\n    \n    for (int i = 1;; ++i) {\n        int num = i * (i+1) * (i+2) / 6;\n        if (num >= MAX) break;\n    \n        for (int j = num; j < MAX; ++j) {\n            adp[j] = min(adp[j], adp[j-num]+1);\n            if (num & 1) odp[j] = min(odp[j], odp[j-num]+1);\n        }\n    }\n    \n    int n;\n    while (scanf(\"%d\", &n)) {\n        if (n == 0) break;\n        printf(\"%d %d\\n\", adp[n], odp[n]);\n    }\n        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector < vector<bool> >dp(6, vector < bool>(100001, 0));\n\tdp[0][0] = 1;\n\tREP(i, 5) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<bool>> dp2(1001, vector<bool>(100001, 0));\n\tREP(i, 1000) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k % 2 == 0)continue;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp2[i][l])dp2[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tREP(i, 5) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \" \";\n\t\tREP(i, 5) {\n\t\t\tif (dp2[i + 1][n]) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define INF (1<<29)\n\nint N;\nint a[1010];\n\nvoid make(){\n  int n;\n  for(n = 1; n <= 1000; n++) a[n] = n * (n+1) * (n+2) / 6;\n}\n\nint dfs1(int depth, int v, int cnt){ //cout << depth << ' ' << v << endl;\n  int i, ret = INF;\n\n  if(v == 0) return cnt;\n  if(v < 0 || v < a[depth]) return INF;\n\n  int K = (v / a[depth]) + 1;\n  rep(i,K) ret = min(ret, dfs1(depth + 1, v - i*a[depth], cnt + i));\n\n  return ret;\n}\n\nint dfs2(int depth, int v, int cnt){ //cout << depth << ' ' << v << endl;\n  int i, ret = INF;\n\n  if(v == 0) return cnt;\n  if(v < 0 || v < a[depth]) return INF;\n  if(a[depth] % 2 == 0) return dfs2(depth + 1, v, cnt);\n\n  int K = (v / a[depth]) + 1;\n  rep(i,K) ret = min(ret, dfs2(depth + 1, v - i*a[depth], cnt + i));\n\n  return ret;\n}\n\nint main(){\n\n  make();\n\n  for(;;){\n    scanf(\"%d\",&N); if(N == 0) break;\n//    int i; rep(i,10) cout << a[i] << endl;\n    cout << dfs1(1,N,0) << ' ' << dfs2(1,N,0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp1[1000001], dp2[1000001];\nint solve(vector<int> const& v, int n, int dp[]) {\n  for (int i = 0; i <= n; i++)\n    dp[i] = i;\n  for (int i = 0; i < v.size(); i++) {\n    for (int j = v[i]; j <= n; j++) {\n      dp[j] = min(dp[j], dp[j-v[i]] + 1);\n    }\n  }\n  return dp[n];\n}\n\nint main(void) {\n  vector<int> tetra, tetra_odd;\n\n  for (int i = 1; ; i++) {\n    int t = (i*(i+1)*(i+2) / 6);\n    if (t > 1000000)\n      break;\n    tetra.push_back(t);\n    if (t % 2 == 1)\n      tetra_odd.push_back(t);\n  }\n\n  solve(tetra, 1000000, dp1);\n  solve(tetra_odd, 1000000, dp2);\n\n  int n;\n  while (cin >> n, n) {\n    cout << dp1[n] << ' ' << dp2[n] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint z1[1000000] = { 0 };\nint z2[1000000] = { 0 };\n\nvoid pollock(int n) {\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= n; i++) {\n\t\tz1[i*(i + 1)*(i + 2) / 6] = 1;\n\t\tif ((i*(i + 1)*(i + 2) / 6) % 2 == 1) z2[i*(i + 1)*(i + 2) / 6] = 1;\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (z1[i] == 0 || (z1[i] != 0 && z1[j] + z1[i - j] < z1[i])) z1[i] = z1[j] + z1[i - j];\n\t\t\tif (z2[i] == 0 || (z2[i] != 0 && z2[j] + z2[i - j] < z2[i])) z2[i] = z2[j] + z2[i - j];\n\t\t}\n\t}\n\n\tcout << z1[n] << \" \" << z2[n] << endl;\n}\n\nint main() {\n\tifstream fin(\"C\");\n\tint n;\n\tfin >> n;\n\tpollock(n);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define lper(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define at(x,i) get<i>(x);\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\nll modfac(ll a){\n    ll ans=1;\n    while(a>1){\n        ans*=a;\n        ans%=1000000007;\n        a--;\n    }\n    return ans;\n}\nll modinv(ll a,ll m) {\n    ll b = m, u = 1, v = 0;\n    while (b) {\n        ll t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m; \n    if (u < 0) u += m;\n    return u;\n}\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) {}\n\n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint main(){\n    vl v,w;\n    rep(i,200){\n        ll x=(i+1)*(i+2)*(i+3)/6;\n        if(x>1000000)break;\n        v.pb(x);\n        if(x%2==1)w.pb(x);\n    }\n    ll sz=v.size();\n    vl dp(1000001,inf);\n    dp[0]=0;\n    rep(i,sz){\n        rep(j,1000001){\n            if(j<v[i])continue;\n            chmin(dp[j],dp[j-v[i]]+1);\n        }\n    }\n    ll ssz=w.size();\n    vl ddp(1000001,inf);\n    ddp[0]=0;\n    rep(i,ssz){\n        rep(j,1000001){\n            if(j<w[i])continue;\n            chmin(ddp[j],ddp[j-w[i]]+1);\n        }\n    }\n    while(true){\n        ll a;cin >> a;\n        if(a==0)break;\n        cout << dp[a] << \" \" <<ddp[a] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint dp[2][1000010], adp[2][1000010];\nint INF = 1e9;\n\nvoid solve() {\n\tfor (int i=0; i<2; i++) {\n\t\tfill(dp[i], dp[i]+1000010, INF);\n\t\tfill(adp[i], adp[i]+1000010, INF);\n\t}\n\t\n\tdp[0][0] = 0;\n\t//adp[0][0] = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint nw = i%2, nx = (i+1)%2;\n\t\tint add = i * (i+1) * (i+2) / 6;\n\t\tif (add > n) break;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (add <= j) {\n\t\t\t\tdp[nx][j] = min(dp[nw][j], dp[nx][j-add] + 1);\n\t\t\t} else {\n\t\t\t\tdp[nx][j] = dp[nw][j];\n\t\t\t}\n\t\t\t/*\n\t\t\tif (add%2==0) {\n\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t} else {\n\t\t\t\tif (add <= j) {\n\t\t\t\t\tadp[nx][j] = min(adp[nw][j], adp[nx][j-add] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tadp[0][0] = 0;\n\tint p = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint add = i * (i+1) * (i+2) / 6;\n\t\tif (add%2 == 0) continue;\n\t\tif (add > n) break;\n\t\t\n\t\tint nw = p%2, nx = (p+1)%2;\n\t\tp++;\n\t\t\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (add <= j) {\n\t\t\t\tadp[nx][j] = min(adp[nw][j], adp[nx][j-add] + 1);\n\t\t\t} else {\n\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = INF, ans2 = INF;\n\tfor (int i=0; i<2; i++) {\n\t\tans1 = min(ans1, dp[i][n]);\n\t\tans2 = min(ans2, adp[i][n]);\n\t}\n\tcout << ans1 << \" \" << ans2 << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int NMAX=1000001;\n\nint main()\n{\n\tstatic int p[200];\n\tfor(int i=0;i<200;i++)\n\t\tp[i]=(i+1)*(i+2)*(i+3)/6;\n\t\n\tstatic int a[NMAX],b[NMAX];\n\tfor(int i=0;i<NMAX;i++)\n\t\ta[i]=b[i]=i;\n\tfor(int i=0;i<200;i++){\n\t\tfor(int j=p[i];j<NMAX;j++)\n\t\t\ta[j]=min(a[j],a[j-p[i]]+1);\n\t\tif(!(p[i]&1)) continue;\n\t\tfor(int j=p[i];j<NMAX;j++)\n\t\t\tb[j]=min(b[j],b[j-p[i]]+1);\n\t}\n\t\n\tfor(int n;cin>>n,n;)\n\t\tcout<<a[n]<<\" \"<<b[n]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <stack>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\nconst ll MAX_N = 1000005;\n// const ll MAX_N = 200;\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  vector<ll> table(205); // table[n] .. n(n+1)(n+2)/6\n  rep(i,205) {\n    table[i] = i*(i+1)*(i+2)/6;\n  }\n  // dp[i] .. min count to represent i.\n  vector<ll> dp(MAX_N, INF);\n  dp[0] = 0;\n  dp[1] = 1;\n  rep(i,MAX_N) {\n    rep(j,205) {\n      if (table[j] > i) { break; }\n      assert(i-table[j] >= 0);\n      chmin(dp[i], dp[i-table[j]] + 1);\n    }\n  }\n  // printvec(dp);\n\n  // dp2[i] .. min count to represent i when using only odd.\n  vector<ll> dp2(MAX_N, INF);\n  dp2[0] = 0;\n  rep(i,MAX_N) {\n    rep(j,205) {\n      if (table[j] > i) { break; }\n      assert(i-table[j] >= 0);\n      if (table[j]%2 == 0) { continue; } // even\n      chmin(dp2[i], dp2[i-table[j]] + 1);\n      // cout << \"j:\" << j << endl;\n      // cout << \"table[j]:\" << table[j] << endl;\n      // cout << \"i:\" << i << endl;\n      // cout << \"dp2[i]:\" << dp2[i] << endl;\n      // cout << \"dp2[i-table[i]]:\" << dp2[i-table[j]] << endl;\n    }\n  }\n\n  while (true) {\n    ll n;\n    cin >> n;\n    if (n == 0) { break; }\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MAX=1e6+10;\nusing namespace std;\nint main(){\n    vector<int>precal;\n    vector<int>dp(MAX,MAX);\n    vector<bool>flag(MAX,false);\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=(int)(upper_bound(precal.begin(),precal.end(),i)-precal.begin());\n        for(int j=0; j<=index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX,MAX);\n    vector<bool>oddflag(MAX,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=(int)(upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin());\n        for(int j=0;j<=index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\n\nll cal(ll n){return n*(n+1)*(n+2)/6;}\n\nll dp[1000010],dp2[1000010];\n\nint main(){\n\tll N;\n\tvector<ll> v;\n\tfor(int i=0;cal(i)<=1000000;i++)v.push_back(cal(i));\n\tll M=v.size();\n\tfor(int i=0;i<1000010;i++)dp2[i]=INF;\n\tdp2[0]=0;\n\tfor(int i=0;i<1000010;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tif(i-v[j]<0)break;\n\t\t\tdp2[i]=min(dp2[i],dp2[i-v[j]]+1);\n\t\t}\n\t}\n\tvector<ll> v_k;\n\tfor(int i=0;cal(i)<=1000000;i++){\n\t\tll x=cal(i);\n\t\tif(cal(i)%2==0)continue;\n\t\tv_k.push_back(cal(i));\n\t}\n\tfor(int i=0;i<1000010;i++)dp[i]=INF;\n\tdp[0]=0;\n\tfor(int i=0;i<1000010;i++){\n\t\tfor(int j=0;j<v_k.size();j++){\n\t\t\tif(i-v_k[j]<0)break;\n\t\t\tdp[i]=min(dp[i],dp[i-v_k[j]]+1);\n\t\t}\n\t}\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0)break;\n\t\tcout<<dp2[N]<<\" \"<<dp[N]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    //int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    //int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",1,2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[1000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b ???ans??????????????????????????? */\n\n  for (i = 1; i < 200; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;\n    int temp = input;\n    int j = 1, min = 1000000000;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n    while (j > 0) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j--;\n      input = temp;\n    }\n    ans[a][0] = min;\n    j = l; \n    min = 1000000000;\n    while (j > 0) {\n      if (tetras[j] % 2 == 0) {\n\tj--;\n\tcontinue;\n      }\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tif (tetras[k] % 2 == 0) {\n\t  k--;\n\t  continue;\n\t}\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j--;\n      input = temp;\n    }\n    ans[a][1] = min;\n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nll dp1[1000005],dp2[1000005];\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    vector<int> v;\n    vector<pair<int,int> > ans;\n    int INF=1000004;\n    for(int i=1;;i++){\n    \tn=i*(i+1)*(i+2)/6;\n    \tif(n>=INF)break;\n    \tv.pb(n);\n    }\n    n=1000004;\n    for(int i=1;i<=n;i++){\n    \tdp1[i]=dp2[i]=mod;\n    }\n    dp1[0]=dp2[0]=0;\n    for(auto& i:v){\n    \tfor(int j=i;j<=n;j++){\n    \t\tdp1[j]=min(dp1[j-i]+1,dp1[j]);\n    \t}\n    \tif(i%2){\n    \t\tfor(int j=i;j<=n;j++){\n    \t\t\tdp2[j]=min(dp2[j-i]+1,dp2[j]);\n    \t\t}\n        }\n    }\n    while(1){\n    \tcin>>n;\n    \tif(n==0)break;\n    \tans.pb(make_pair(dp1[n],dp2[n]));\n    }\n    for(auto& i:ans){\n    \tcout << i.first<<\" \"<<i.second<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tvector<int>q;\n\tloop(i,1,10000000){\n\t\tint tmp=i*(i+1)*(i+2)/6;\n\t\tif(tmp>1000000)break;\n\t\tq.pb(tmp);\n\t}\n\tvector<int>out(1000010);\n\trep(i,1000010)out[i]=inf;\n\tout[0]=0;\n\trep(i,q.size())loop(j,q[i],1000010)out[j]=min(out[j],out[j-q[i]]+1);\n\t\n\tvector<int>out2(1000010);\n\trep(i,1000010)out2[i]=inf;\n\tout2[0]=0;\n\trep(i,q.size()){\n\t\tif(q[i]%2==0)continue;\n\t\tloop(j,q[i],1000010)out2[j]=min(out2[j],out2[j-q[i]]+1);\n\t}\n\tint n;\n\twhile(cin>>n,n)cout<<out[n]<<\" \"<<out2[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1000000\n\nint main() {\n\tvector<int> tn;\n\tfor(int i = 1; i < 100; i++) {\n\t\ttn.push_back(i*(i+1)*(i+2)/6);\n\t}\n\n\tint dp[N] = {0};\n\tint dp_odd[N] = {0};\n\n\tfor(int i = 0; i < N; i++) {\n\t\tdp[i] = -1;\n\t\tdp_odd[i] = -1;\n\t}\n\tfor(int t:tn) {\n\t\tdp[t] = 1;\n\t\tif(t%2 == 1)\n\t\t\tdp_odd[t] = 1;\n\t}\n\n\treverse(tn.begin(), tn.end());\n\n\tfor(int t:tn) {\n\t\tfor(int i = N-1; i >= 1; i--) {\n\t\t\tif(dp[i] == -1) continue;\n\t\t\tfor(int j = 1; i+j*t < N && dp[i+j*t] == -1; j++) {\n\t\t\t\tif(dp[i+j*t] == -1) dp[i+j*t] = dp[i]+j;\n\t\t\t\telse dp[i+j*t] = min(dp[i+j*t], dp[i]+j);\n\t\t\t}\n\n\t\t\tif(t%2 == 1) {\n\t\t\t\tif(dp_odd[i] == -1) continue;\n\t\t\t\tfor(int j = 1; i+j*t < N && dp_odd[i+j*t] == -1; j++) {\n\t\t\t\t\tif(dp_odd[i+j*t] == -1) dp_odd[i+j*t] = dp_odd[i]+j;\n\t\t\t\t\telse dp_odd[i+j*t] = min(dp_odd[i+j*t], dp_odd[i]+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint n;\n\twhile(cin >> n && n) {\n\t\tcout << dp[n] << \" \" << dp_odd[n] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\nint main()\n{\n  std::vector<int> data;\n  while(true){\n    int n;\n    std::cin >> n;\n    if(n!=0) data.push_back(n);\n    else break;\n  }\n  std::vector<long long> num_tet;\n  std::vector<long long> num_odd_tet;\n  for (int i = 1; i < 200; i++){\n    long long num = i*(i+1)*(i+2)/6;\n    num_tet.push_back(num);\n    if(num%2==1) {\n      // std::cout << \"i \"<<i << std::endl;\n      num_odd_tet.push_back(num);\n    }\n    // std::cout << \"num \"<< num << std::endl;\n  }\n  //dp[i+1][j] i番目までの正四面体数で整数jを実現するための最小手数\n  int inf = std::numeric_limits<int>::max();\n  // std::vector<std::vector<long long>> dp(num_tet.size()+5, std::vector<long long>(1e6+100, inf));\n  // std::vector<int> ad(1e6);  // std::vector<std::vector<int>> dp((int)num_tet.size()+5, std::vector<int>(1e6, inf));\n\n  std::vector<long long> dp(1e6+100, inf);\n  dp[0] = 0;\n  for (int i = 0; i < num_tet.size() ; i++){\n    std::vector<long long> new_dp(1e6+100, inf);\n    for (int j = 0; j < 1e6+10; j++){\n      if(j-num_tet[i] < 0) new_dp[j] = dp[j];\n      else new_dp[j] = std::min(dp[j], new_dp[j-num_tet[i]]+1);\n    }\n    dp = new_dp;\n  }\n\n  std::vector<long long> odd_dp(1e6+100, inf);\n  odd_dp[0] = 0;\n  for (int i = 0; i < num_odd_tet.size(); i++){\n    std::vector<long long> new_odd_dp(1e6+100, inf);\n    for (int j = 0; j < 1e6+10; j++){\n      if(j-num_odd_tet[i] < 0) new_odd_dp[j] = odd_dp[j];\n      else new_odd_dp[j] = std::min(odd_dp[j], new_odd_dp[j-num_odd_tet[i]]+1);\n    }\n    odd_dp = new_odd_dp;\n  }\n\n  for(const auto& d: data){\n    std::cout << dp[d]<< \" \"<< odd_dp[d] << std::endl;\n  }\n  // std::cout << dp[40] << std::endl;\n  // for (int i = 0; i < data.size(); i++){\n  //   std::cout  <<i << \" \"<<i<< std::endl;\n  // }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MAX=1e6+10;\nusing namespace std;\nint main(){\n    vector<int>precal;\n    vector<int>dp(MAX,MAX);\n    vector<bool>flag(MAX+10,false);\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=(int)(upper_bound(precal.begin(),precal.end(),i)-precal.begin());\n        for(int j=0; j<=index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX,MAX);\n    vector<bool>oddflag(MAX+10,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=(int)(upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin());\n        for(int j=0;j<=index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000005LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\nstatic const int N = 1000005;\n\nint n;\nll K;\nint dp[N],dpo[N];\nll pollock[N],oollock[N];\nll pmax,omax;\nint cmax;\nint a;\n\nint pol()\n{\n\tscanf(\"%d\",&n);\n\tif(n==0)return -1;\n\tif(cmax>=n){\n\t\ta = dpo[n];\n\t\treturn dp[n];\n\t}\n\twhile(pollock[pmax]<=n){\n\t\tpmax++;\n\t\tpollock[pmax] = pmax*(pmax+1)*(pmax+2)/6;\n\t\tif(pollock[pmax]%2==1){\n\t\t\tomax++;\n\t\t\toollock[omax]=pollock[pmax];\n\t\t}\n\t}\n\tint k=1,j=1,s=1,f=1;\n\tfor(int i=cmax+1;i<=n;i++){\n\t\twhile(pollock[j]<=i)j++;\n\t\tint minv = 9;\n\t\tfor(int c=1;c<j;c++){\n\t\t\tminv = min(minv,dp[i-pollock[c]]+1);\n\t\t}\n\t\tdp[i] = minv;\n\n\t\twhile(oollock[k]<=i&&k<=omax){\n\t\t\tk++;\n\t\t}\n\t\tminv = 99;\n\t\tint c;\n\t\tfor(c=1;c<k;c++){\n\t\t\tminv = min(minv,dpo[i-oollock[c]]+1);\n\t\t}\n\t\tdpo[i] = minv;\n\t\t//printf(\"(%d:%d)\",i,k);\n\t}\n\tcmax=n;\n\ta = dpo[n];\n\treturn dp[n];\n}\nint main(){\n\tpmax=0;\n\tcmax=omax=0;\n\tdp[0]=0;\n\tdpo[0]=0;\n\tpollock[0]=oollock[0]=0;\n\twhile(1){\n\t\tint p = pol();\n\t\tif(p==-1)return 0;\n\t\tprintf(\"%d %d\\n\",p,a);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nint tetra(int n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nvoid solve(int n)\n{\n  for(int i = 1; tetra(i) <= n; i++){\n    if(tetra(i) & 1)\n      dp2[tetra(i)] = 1;\n    dp[tetra(i)] = 1;\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; j <= n; j++){\n      if(dp[j] == i){\n        for(int k = 1; j + tetra(k) <= n; k++){\n          dp[j + tetra(k)] = min(i + 1, dp[j + tetra(k)]);\n        }\n      }\n      if(dp2[j] == i){\n        for(int k = 1; j + tetra(k) <= n; k++){\n          if(tetra(k) & 1)\n            dp2[j + tetra(k)] = min(i + 1, dp2[j + tetra(k)]);\n        }\n      }\n    }\n  }\n}\n    \nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD = 1e9 + 7;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    std::vector<int> v, odd;\n    for (int i = 1; i * (i + 1) * (i + 2) / 6 <= 6 * 1e6; i++)\n    {\n        int tmp = i * (i + 1) * (i + 2) / 6;\n        v.push_back(tmp);\n        if (tmp % 2)\n            odd.push_back(tmp);\n    }\n    std::vector<int> dp(1e6 + 1), odddp(1e6 + 1);\n    for (int i = 1; i <= 1e6; i++)\n    {\n        dp[i] = i;\n        odddp[i] = i;\n    }\n    for (int i = 1; i <= 1e6; i++)\n    {\n        for (int j = 0; j < (int)v.size(); j++)\n        {\n            if (i - v[j] >= 0)\n                dp[i] = min(dp[i], dp[i - v[j]] + 1);\n        }\n        for (int j = 0; j < (int)odd.size(); j++)\n        {\n            if (i - odd[j] >= 0)\n                odddp[i] = min(odddp[i], odddp[i - odd[j]] + 1);\n        }\n    }\n    while (cin >> n, n)\n    {\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate<class T> inline bool chmax(T &a, T b) {\n\tif (a < b) { a = b; return true; }\n\treturn false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b) {\n\tif (a > b) { a = b; return true; }\n\treturn false;\n}\n\nconst int INF = 1e8;\n\nint main() {\n\tvector<int> v;\n\tfor (int i = 1; ; i++) {\n\t\tint t = (i * (i + 1) * (i + 2)) / 6;\n\t\tif (t >= 1e6) break;\n\t\tv.push_back(t);\n\t}\n\tvector<int> dp1(1000005, INF);\n\tvector<int> dp2(1000005, INF);\n\tdp1[0] = 0;\n\tdp2[0] = 0;\n\trep(i, 1000005) {\n\t\trep(j, (int)v.size()) {\n\t\t\tif (i < v[j]) continue;\n\t\t\tchmin(dp1[i], dp1[i - v[j]] + 1);\n\t\t\tif (v[j] % 2 == 1) chmin(dp2[i], dp2[i - v[j]] + 1); \n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(void){\n  int size;\n  vector<ll> v(200);\n  for(ll i=1;;i++){\n    if((i*(i+1)*(i+2))/6 > 1000000) break;\n    v[i-1] = (i*(i+1)*(i+2))/6;\n    size = i-1;\n  }\n  int dp1[1000000]; // dp[i] := number of tetrahedron with value i\n  int dp2[1000000]; // dp[i] := number of tetrahedron with value i\n  fill(dp1, dp1+1000000+1, INT_MAX);\n  fill(dp2, dp2+1000000+1, INT_MAX);\n  dp1[0] = dp2[0] = 0;\n\n  for(int i = 0; i <= 1000000; i++){\n    for(int j = 0; j < size; j++){\n      if(i+v[j] > 1000000) continue;\n      dp1[i + v[j]] = min(dp1[i+v[j]], dp1[i]+1);\n    }\n  }\n\n\n  for(int i = 0; i <= 1000000; i++){\n    for(int j = 0; j < size; j++){\n      if(i+v[j] > 1000000) continue;\n      if(v[j] % 2 == 0) continue;\n      dp2[i + v[j]] = min(dp2[i+v[j]], dp2[i]+1);\n    }\n  }\n\n  while(1){\n    int x; cin >> x;\n    if(x == 0) break;\n    int ans = 0;\n    cout << dp1[x] << \" \";\n    cout << dp2[x] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n \n#define ll long long\n \nusing namespace std;\nint main(void){\n    ll  n, a[100000], b[100000], sum = 0, cntA=0, cntB=0, dp[100000][100000];\n    while(cin >> n, n){\n        int k=1;\n        while(sum < n){\n            sum = k * (k+1) * (k+2) / 6;\n            if(sum <= n){\n\t            a[k] = sum;\n\t            cntA++;\n\t            if(k%2 == 1){\n\t                b[k] = sum;\n\t                cntB++;\n\t            }\n            }\n            k++;\n        }\n        for(int i=cntA;i>=0;i--){\n        \tfor(int j=0;j<=n;j++){\n        \t\tdp[i][j] = 0;\n            }\n        }\n        for(int i=cntA-1;i>=0;i--){\n            for(int j=0;j<=n;j++){\n            \tif(j<a[i]){\n            \t\tdp[i][j] = dp[i+1][j];\n        \t\t\tcout << dp[i][j];\n        \t\t}else{\n    \t\t\t\tdp[i][j] = min(dp[i+1][j], dp[i+1][j-a[i]] + 1);\n        \t\t}\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tint v[200];\n        int dpA[1000000], dpB[1000000];\n\tfor (int i = 0; i<=200; i++) v[i] = i * (i + 1)*(i + 2) / 6;\n\tdpA[0] = dpB[0] = 0;\n\tfor (int i = 1; i<1000000; i++) {\n\t\tdpA[i] = dpB[i] = i;\n\t\tfor (int j = 0; i - v[j] >= 0; j++) {\n\t\t\tdpA[i] = min(dpA[i], dpA[i - v[j]] + 1);\n\t\t\tif (v[j] % 2 == 1)\n\t\t\t\tdpB[i] = min(dpB[i], dpB[i - v[j]] + 1);\n\t\t}\n\t}\n\twhile (cin >> N, N)\n\t\tcout << dpA[N] << \" \" << dpB[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "///\n// File:  1167.cpp\n// Author: ymiyamoto\n//\n// Created on Sat Dec  2 18:27:58 2017\n//\n\n#include <algorithm>\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nuint32_t polloc(uint32_t n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nstatic array<int32_t, 1000001> dp;\nstatic array<int32_t, 1000001> odddp;\n\nint32_t main()\n{\n  for (uint32_t i = 0; i < dp.size(); i++) {\n    dp[i] = odddp[i] = i;\n  }\n\n  vector<int64_t> pollocs;\n  for (uint32_t i = 0; i <= 181; i++) {\n    pollocs.push_back(polloc(i));\n  }\n\n  for (int64_t i = 0; i < (int64_t)dp.size(); i++) {\n    for (int64_t j = 0; j < (int64_t)pollocs.size(); j++) {\n      if (i - pollocs[j] >= 0) {\n        dp[i] = min(dp[i], dp[i - pollocs[j]] + 1);\n        if (pollocs[j] % 2 == 1) {\n          odddp[i] = min(odddp[i], odddp[i - pollocs[j]] + 1);\n        }\n      }\n    }\n  }\n\n  while (true) {\n    uint32_t n;\n    cin >> n;\n    if (n == 0) break;\n    cout << dp[n] << \" \" << odddp[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1000100\nint dp[N], odd[N];\n#define reps(i,n,m) for(int i=int(n);i<int(m);i++)\n#define rep(i,n) reps(i,0,n)\nint func(int x) {\n\treturn x*(x+1)*(x+2)/6;\n}\nint main() {\n\tint num = 1;\n\tint a;\n\trep(i,N) {\n\t\tdp[i]=N;\n\t\todd[i]=N;\n\t}\n\twhile((a=func(num)) < N){\n\t\tdp[a] = 1;\n\t\tif(a%2==1) odd[a]=1;\n\t\treps(i,1,N-a) {\n\t\t\tif(dp[i]!=N) {\n\t\t\t\tdp[i+a] = min(dp[i+a], dp[i]+1);\n\t\t\t}\n\t\t\tif(a%2==1 && odd[i]!=N) {\n\t\t\t\todd[i+a]=min(odd[i+a], odd[i]+1);\n\t\t\t}\n\t\t}\n\t\tnum++;\n\t}\n\tint x;\n\twhile(cin>>x&&x!=0) {\n\t\tcout<<dp[x]<<\" \"<<odd[x]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define uniq(x) (x).erase(unique(all(x)),(x).end())\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef std::priority_queue<int> IntPrioQueue; //Z->A\ntypedef std::priority_queue<int, std::vector<int>, std::greater<int> > IntReversePrioQueue; //A->Z\n\nconst int MAX = 100010;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst int MOD = 1000000007;\n\nvector <int> sq, odsq;\nint N, mn[MAX], od[MAX];\n\nvoid solve(void){\n    int n = 1;\n    fill(mn, mn+MAX, INF);\n    fill(od, od+MAX, INF);\n    mn[0] = od[0] = 0;\n    while(n*(n+1)*(n+2)/6<MAX) {\n        sq.pb(n*(n+1)*(n+2)/6);\n        mn[n*(n+1)*(n+2)/6] = 1;\n        if (n*(n+1)*(n+2)/6%2) {\n            odsq.pb(n*(n+1)*(n+2)/6);\n            od[n*(n+1)*(n+2)/6] = 1;\n        }\n        n++;\n    }\n    Rep(1, MAX-1, k) {\n        int mini = INF, miniod = INF;\n        for (int q : sq) {\n            if (q >= k) break;\n            mini = min(mini, k/q + mn[k%q]);\n        }\n        for (int q : odsq) {\n            if (q >= k) break;\n            miniod = min(miniod, k/q + od[k%q]);\n        }\n        mn[k] = min(mini, mn[k]);\n        od[k] = min(miniod, od[k]);\n    }\n    while (1) {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        printf(\"%d %d\\n\", mn[N], od[N]);\n    }\n}\n\nint main(void){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tvector<int>e(1000000, MOD);\n\te[0] = 0;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tfor (int j = 1; j < 1000; j++) {\n\t\t\tint box = i + j * (j + 1)*(j + 2) / 6;\n\t\t\tif (box >= 1000000)break;\n\t\t\te[box] = min(e[box], e[i] + 1);\n\t\t}\n\t}\n\tvector<int>o(1000000, MOD);\n\to[0] = 0;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tfor (int j = 1; j < 1000; j += 4) {\n\t\t\tint box = i + j * (j + 1)*(j + 2) / 6;\n\t\t\tif (box >= 1000000)break;\n\t\t\to[box] = min(o[box], o[i] + 1);\n\t\t}\n\t}\n\tcin >> N;\n\twhile (N) {\n\t\tcout << e[N] << \" \" << o[N] << endl;\n\t\tcin >> N;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint prime[180],oddprime[100];\nint dp[200][1000000];\nint main(){\n\tint count=1,oddcount=1;\n\tprime[0]=1,oddprime[0]=1;\n\twhile(true){\n\t\tprime[count]=prime[count-1]*(count+3)/count;\n\t\tif(prime[count]%2==1){\n\t\t\toddprime[oddcount]=prime[count];\n\t\t\toddcount++;\n\t\t}\n\t\tif(prime[count]>=1000000)\n\t\t\tbreak;\n\t\tcount++;\n\t}\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)\n\t\tbreak;\n\tfor(int i=0;i<=n;i++)\n\t\tdp[0][i]=i;\n\tfor(int i=1;i<count;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tdp[i][j]=100000;\n\tfor(int i=1;i<count;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=j;k>=0;k-=prime[i])\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+(j-k)/prime[i]);\n\tcout<<dp[count-1][n]<<\" \";\n\tfor(int i=1;i<oddcount;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tdp[i][j]=100000;\n\tfor(int i=1;i<oddcount;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tfor(int k=j;k>=0;k-=oddprime[i])\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+(j-k)/oddprime[i]);\n\tcout<<dp[oddcount-1][n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint x[8000000][2], a[999], b[999], s, n;\nint main() {\n\ta[0] = 1; b[0] = 1;\n\tfor (int i = 1; i < 300; i++) {\n\t\ta[i] = a[i - 1] + (i + 1)*(i + 2) / 2;\n\t\tif (a[i] % 2 == 1) {\n\t\t\ts++; b[s] = a[i];\n\t\t}\n\t}\n\tn = 1200000;\n\tmemset(x, 127, sizeof(x));\n\tx[0][0] = 0; x[0][1] = 0;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + a[i]][0] = min(x[j + a[i]][0], x[j][0] + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < 50; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + b[i]][1] = min(x[j + b[i]][1], x[j][1] + 1);\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> n; if (!n) { break; }\n\t\tcout << x[n][0] << x[n][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1 << 9\n#define MAX 1000001\nusing namespace std;\n\nint pollock[200];\nint pollock2[200] = {INF};\nint dp[MAX];\nint dpo[MAX];\n\nvoid calcDpo() {\n  for (int i = 0; i < MAX; i++)\n    dpo[i] = i;\n  for (int i = 0; i < 200; i++) {\n    if (pollock2[i] > MAX) break;\n    for (int j = pollock2[i]; j < MAX - 1; j++) {\n      dpo[j] = min(dpo[j], dpo[j - pollock2[i]] + 1);\n    }\n  }\n}\n\nvoid calcDp() {\n  for (int i = 0; i < MAX; i++)\n    dp[i] = i;\n  for (int i = 1; i < 200; i++) {\n    if (pollock[i] > MAX) break;\n    for (int j = pollock[i]; j < MAX - 1; j++) {\n      dp[j] = min(dp[j], dp[j - pollock[i]] + 1);\n    }\n  }\n}\n\nvoid calcPollock() {\n  for (int i = 0; i < 200; i++) {\n    pollock[i] = i * (i + 1) * (i + 2) / 6;\n  }\n  pollock2[0] = 0;\n  int j = 1;\n  for (int i = 0; i < 200; i++) {\n    if (pollock[i] % 2)\n      pollock2[j++] = pollock[i];\n  }\n}\n\nint main() {\n  calcPollock();\n  calcDp();\n  calcDpo();\n  \n\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) return 0;\n\n    cout << dp[n] << ' ' << dpo[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[1000], fourodd[1000];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM * 2)\n\t\t\tbreak;\n\n\t}\n\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t\tif (i > fourodd[j])\n\t\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\t}\n\n\t\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1000001];\nint memo2[1000001];\n \nint solve(int n){\n\n  if(!n) return 0;\n  if(memo[n]) return memo[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n; i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(memo2[n]) return memo2[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++){\n    if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n  }\n   \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  for(int i=0;i<=181;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i++) solve(i), solve2(i);\n   \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\ntemplate<typename T>\nvoid dump(T a, int n) { for (int i = 0; i < n; i++) cout << a[i] << (i == n - 1 ? '\\n' : ' '); }\n\ntemplate<typename T>\nvoid dump(T a) { dump<T>(a, a.size()); }\n\nint main(void) {\n\tVI as({1, 4, 10, 20, 35});\n\tVI bs({1, 35});\n\tconst int LIM = 1000000;\n\tconst int INF = INT_MAX;\n\n\tVI dpa(LIM + 1, INF);\n\tVI dpb(LIM + 1, INF);\n\tdpa[0] = 0;\n\tdpb[0] = 0;\n\t\n\tfor (int i = 0; i < LIM; i++) {\n\t\tif (dpa[i] != INF) {\n\t\t\tfor (auto a : as) {\n\t\t\t\tint n = i + a;\n\t\t\t\tif (n <= LIM) {\n\t\t\t\t\tdpa[n] = min(dpa[n], dpa[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dpb[i] != INF) {\n\t\t\tfor (auto b : bs) {\n\t\t\t\tint n = i + b;\n\t\t\t\tif (n <= LIM) {\n\t\t\t\t\tdpb[n] = min(dpb[n], dpb[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int N; cin >> N, N;) {\n\t\tcout << dpa[N] << \" \" << dpb[N] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[3000][3000];\nchar field[200][200];\n\nll max_p[1000010],min_p[1000010];\n\nvoid func(){\n  max_p[0] = min_p[0] = 0;\n  rep(i,1,1000010){\n    min_p[i] = max_p[i] = i;\n    rep(j,1,1000010){\n      // 正四面体\n      ll test = j * (j + 1) * (j + 2) / 6;\n      // インデックス\n      if(i - test < 0)break;\n      min_p[i] = min(min_p[i] ,min_p[i - test] + 1);\n      if(test % 2)max_p[i] = min(max_p[i],max_p[i - test] + 1);\n    }\n  }\n}\n\nint main(){\n  func();\n  while(cin >> n,n){\n    cout << min_p[n] << \" \" << max_p[n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nconst int INF = 100000000;\n\nint main(){\n\n\tint n;\n//\tint dp[1000001];\n\tvector<int> dp(1000001,0);\n\tvector<int> dp2(1000001,0);\n\twhile(cin >> n && n != 0){\n\t\tvector<int> triNum;\n\t\tint sum = 1;\n\t\tint idx = 2;\n\t\tint allSum = 0;\n\t\twhile(sum <= 1000000){\n\t\t\tallSum += sum;\n\t\t\ttriNum.push_back(allSum);\n\t\t\tsum += idx;\n\t\t\tidx++;\n\t\t}\n\t\tfill(dp.begin(),dp.end(),INF);\n\t\tfill(dp2.begin(),dp2.end(),INF);\n\t\tdp[1] = 1;\n\t\tdp[2] = 2;\n\t\tdp[3] = 3;\n\t\tdp[0] = 0;\n\n\t\tdp2[1] = 1;\n\t\tdp2[2] = 2;\n\t\tdp2[3] = 3;\n\t\tdp2[0] = 0;\n\n\n\t\tfor(int i = 4; i <= n; i++){\n\t\t\tfor(int j = 0; j < triNum.size(); j++){\n\t\t\t\tif(i - triNum[j] == 0){\n\t\t\t\t\tif(triNum[j] % 2)\n\t\t\t\t\t\tdp2[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(i - triNum[j] < 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(triNum[j] % 2)\n\t\t\t\t\tdp2[i] = min(dp2[i],dp2[i-triNum[j]]+1);\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < triNum.size(); j++){\n\t\t\t\tif(i - triNum[j] == 0){\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(i - triNum[j] < 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdp[i] = min(dp[i],dp[i-triNum[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nint v[1000];\nint main()\n{\n\tint n;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j <= 1000000; j++)\n\t\t{\n\t\t\tif (j == 0)dp[i][j] = 0;\n\t\t\telse dp[i][j] = 999999;\n\t\t}\n\t}\n\tfor (int i = 1;;i++)\n\t{\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif (k > 1000000)break;\n\t\tv[i - 1] = k;\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t{\n\t\t\tfor (int j = 0;; j++)\n\t\t\t{\n\t\t\t\tif (i + v[j] > n)break;\n\t\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]],dp[0][i] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t{\n\t\t\tfor (int j = 0;;j++)\n\t\t\t{\n\t\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\t\tif (i + v[j] > n)break;\n\t\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nlong dp[1000000];\nlong dpo[1000000];\n\nint main(){\n    int N;\n    dp[0] = 0;\n    dp[0] = 0;\n    for(int i = 1;i < 1000000;i++){\n            dp[i] = 1000000;\n            dpo[i] = 1000000;\n        }\n    for(int i= 0;i < 1000;i++){\n        long a = (i * (i + 1) * (i + 2)) / 6;\n        for(int j = a;j < 1000000;j++){\n            dp[j] = min(dp[j],dp[j - a] + 1);\n            if(a % 2 == 1){\n                dpo[j] = min(dpo[j],dpo[j - a] + 1);\n            }\n        }\n    }\n    for(int i = 0;;i++){\n        scanf(\"%d\",&N);\n        if(N == 0){\n            break;\n        }\n        printf(\"%ld %ld\\n\",dp[N],dpo[N]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LOOP(n) for (int _i = 0; _i < (n); _i++)\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define RREP(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, r, n) for (int i = (r); i < (n); ++i)\n#define ALL(obj) begin(obj), end(obj)\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<int, int>;\nusing Graph = vector<vector<int>>;\n\nconst int INF = 2100100100;\nconst int MOD = 1e9 + 7;\n\n// 多次元 vector 生成\ntemplate <class T>\nvector<T> make_vec(size_t a) {\n    return vector<T>(a);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t a, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\nint N, M, K, Q, W, H, R, C;\nvector<int> p;\nvector<int> podd;\nint dp[1100000], dp2[1100000];\n\nint main() {\n    // cin.tie(0);\n    // ios::sync_with_stdio(false);\n\n    int id = 1;\n    int v = id * (id + 1) * (id + 2) / 6;\n    while (v < 1010000) {\n        p.push_back(v);\n        if (v % 2 == 1) podd.push_back(v);\n        id++;\n        v = id * (id + 1) * (id + 2) / 6;\n    }\n\n    REP(i, 1010000) { dp[i] = INF; }\n    dp[0] = 0;\n    REP(i, 1010000) {\n        REP(j, (int)p.size()) {\n            if (i - p[j] < 0) break;\n            chmin(dp[i], dp[i - p[j]] + 1);\n        }\n    }\n\n    REP(i, 1010000) { dp2[i] = INF; }\n    dp2[0] = 0;\n    REP(i, 1010000) {\n        REP(j, (int)podd.size()) {\n            if (i - podd[j] < 0) break;\n            chmin(dp2[i], dp2[i - podd[j]] + 1);\n        }\n    }\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\tstd::vector<int> shimen;\n\nint calc_shimen(int pnum){\n\tstatic int num = 0;\n\tstatic int kai1 = 0;\n\tstatic int kai2 = 0;\n\tstatic int i = 0;\n//\t 2 3 4  5\n//\t1 3 6 10 15\n//\t 1 4 10 20 35\n\twhile (1){\n\t\tif (num > pnum) break;\n\t\tkai2++;\n\t\tkai1 += kai2;\n\t\tnum += kai1;\n\t\tshimen.push_back(num);\n\t//\tstd::cout << num << \"\\n\";\n\t\ti++;\n\t}\n\treturn i-2;\n}\n\nint main(void){\n\tint num, cnum, i, h, c1, cmin, cmin2, k;\n\n\tshimen.reserve(1000);\n\twhile (1){\n\t\tstd::cin >> num;\n\t\tif (!num) break;\n\t\t\n\t\tcmin = 0;\n\t\tc1 = 0;\n\t\th = calc_shimen(num);\n\t\twhile (h >= 1){\n\t\t\ti = h;\n\t\t\tcnum = num;\n\n\n\t\t\tk = shimen[i];\n\t\t//\tstd::cout << \"begin i:\" << i << \", k:\" << k << \"\\n\";\n\t\t//\tif (cmin <= 0 || num / k < cmin){\n\t\t\t\tc1 = 0;\n\t\t\t\twhile (i >= 0){\n\t\t\t\t\tk = shimen[i];\n\t\t\t\t\tc1 += cnum / k;\n\t\t\t\t\tcnum -= cnum / k*k;\n\t\t\t\t//\tstd::cout << \"k:\" << k << \", cnum:\" << cnum << \", c1:\" << c1 << \"\\n\";\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tif (cmin <= 0 || cmin>c1) cmin = c1;\n\n\t\t//\t}\n\t\t\th--;\n\t\t}\n\n\t\tcmin2 = 0;\n\t\tc1 = 0;\n\t\th = calc_shimen(num);\n\t\twhile (h >= 1){\n\t\t\ti = h;\n\t\t\tcnum = num;\n\n\n\t\t\tk = shimen[i];\n\t\t//\tstd::cout << \"begin i:\" << i << \", k:\" << k << \"\\n\";\n\t\t\t//\tif (cmin <= 0 || num / k < cmin){\n\t\t\tc1 = 0;\n\t\t\twhile (i >= 0){\n\t\t\t\tif ((k = shimen[i]) % 2){\n\t\t\t\t\tc1 += cnum / k;\n\t\t\t\t\tcnum -= cnum / k*k;\n\t\t\t\t//\tstd::cout << \"k:\" << k << \", cnum:\" << cnum << \", c1:\" << c1 << \"\\n\";\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (cmin2 <= 0 || cmin2>c1) cmin2 = c1;\n\n\t\t\t//\t}\n\t\t\th--;\n\t\t}\n\n\t\tstd::cout << cmin << \" \" << cmin2 << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\n//vector<vector<int>> dp;\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//dp.resize(C_N + 2);\n\t\t/*for (int i = 0; i < C_N + 2; i++) {\n\t\t\tdp[i].resize(N + 2);\n\t\t}*/\n\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t/*for (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}*/\n\t\t/*for (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\t\t*/\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define reps(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint dp[1000000] = {};\nint dp_o[1000000] = {};\nvector<int>n, n_o;\nint DP(int num) {\n\tif (dp[num] != 0)return dp[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP(n[cnt]) + DP(num - n[cnt]), rec);\n\t\tcnt++;\n\t\tif (n[cnt] > num)break;\n\t}\n\tdp[num] = rec;\n\treturn rec;\n\n}\nint DP_o(int num) {\n\tif (dp_o[num] != 0)return dp_o[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 0;\n\twhile (1) {\n\t\trec = min(DP(n_o[cnt]) + DP(num - n_o[cnt]), rec);\n\t\tcnt++;\n\t\tif (n_o[cnt] > num)break;\n\t}\n\tdp_o[num] = rec;\n\treturn rec;\n\n}\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tll cnt1 = 0, cnt2 = 0;\n\t\n\treps(i, 1, 1000000) {\n\t\tcnt1 += i;\n\t\tcnt2 += cnt1;\n\t\tdp[cnt2] = 1;\n\t\tn.push_back(cnt2);\n\t\tif (cnt2 % 2 == 1) {\n\t\t\tdp_o[cnt2] = 1;\n\t\t\tn.push_back(cnt2);\n\t\t}\n\t}\n\twhile (1) {\n\t\tint Q;\n\t\tcin >> Q;\n\t\tif (Q == 0)break;\n\t\tcout << DP(Q) << \" \";\n\t\tcout << DP_o(Q) << endl;\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1167\n#include<iostream>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int number;\n\nconst number NMAX = 1e6 + 8;\n\nint dp[NMAX], odp[NMAX];\n\nint main() {\n  REP(i, NMAX) {\n    dp[i] = odp[i] = i;\n  }\n  for (number i = 2; i * (i + 1) * (i + 2) / 6 < NMAX; i++) {\n    int tetr = i * (i + 1) * (i + 2) / 6;\n    int limit = min(NMAX, (i + 2) * (i + 3) * (i + 4) / 6 + 8);\n    for (number j = tetr; j < limit; j++) {\n      dp[j] = min(dp[j], dp[j - tetr] + 1);\n    }\n\n    if (tetr % 2 != 0) {\n      int limit = min(NMAX, (i + 10) * (i + 11) * (i + 12) / 6 + 8);\n      for (number j = tetr; j < limit; j++) {\n        odp[j] = min(odp[j], odp[j -tetr] + 1);\n      }\n    }\n  }\n\n  int n;\n  while (cin >> n and n) {\n    cout << dp[n] << \" \" << odp[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T> inline bool chmax(T &a, T b){if (a < b){a = b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if (a > b){a = b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\nconst double EPS = 1e-9;\n\nconst int MAX_N = 512;\nconst int MAX = 1e6 + 10;\nint sum[MAX_N];\nint dp[MAX];\nint odddp[MAX];\n\nvoid init() {\n    for (int i = 1; i < MAX_N; i++) {\n        sum[i] = i * (i + 1) * (i + 2) / 6;\n    }\n    for (int i = 1; i < MAX; i++) {\n        dp[i] = odddp[i] = i;\n    }\n    for (int i = 1; i < MAX_N; i++) {\n        for (int j = 0; j + sum[i] < MAX; j++) {\n            chmin(dp[j + sum[i]], dp[j] + 1);\n            if (chmin(odddp[j + sum[i]], (sum[i] % 2 % 2 ? odddp[j] + 1 : INF))) {\n                //if (j + sum[i] <= 40) {DEBUG(j)DEBUG(sum[i])DEBUG(j + sum[i])puts(\"\");}\n            }\n        }\n    }\n}\n\nvoid solve(int n) {\n    cout << dp[n] << \" \" << odddp[n] << endl;\n}\n\nsigned main(void) {\n    LL n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    init();\n    while (cin >> n, n) {\n        solve(n);\n        //return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\nconst int MOD=1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  std::vector<int> v,odd;\n  for(int i=1;i*(i+1)*(i+2)/6<=6*1e6;i++){\n      int tmp=i*(i+1)*(i+2)/6;\n      v.push_back(tmp);\n      if(tmp%2) odd.push_back(tmp);\n  }\n  std::vector<int> dp(1e6+1),odddp(1e6+1);\n  for(int i=1;i<=1e6;i++){\n      dp[i]=i;odddp[i]=i;\n  }\n  for(int i=1;i<=1e6;i++){\n      for(int j=0;j<(int)v.size();j++){\n          if(i-v[j]>=0) dp[i]=min(dp[i],dp[i-v[j]]+1);\n      }\n      for(int j=0;j<(int)odd.size();j++){\n          if(i-odd[j]>=0) odddp[i]=min(odddp[i],odddp[i-odd[j]]+1);\n      }\n  }\n  while(cin>>n,n){\n      cout<<dp[n]<<\" \"<<odddp[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint main()\n{\n\tvector<int> dp(MAX, INF), res(MAX, INF), four, odd;\n\tfor (int i = 1; i * (i + 1) * (i + 2) / 6 < MAX; i++) {\n\t\tfour.push_back(i * (i + 1) * (i + 2) / 6);\n\t\tdp[i * (i + 1) * (i + 2) / 6] = 1;\n\t\tif (i * (i + 1) * (i + 2) / 6 % 2) {\n\t\t\todd.push_back(i * (i + 1) * (i + 2) / 6);\n\t\t\tres[i * (i + 1) * (i + 2) / 6] = 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = MAX - 1; j >= 0; j--) {\n\t\t\tif (dp[j] != INF) {\n\t\t\t\tfor (int k = 0; k < four.size() && j + four[k] < MAX;k++) {\n\t\t\t\t\tdp[j + four[k]] = min(dp[j + four[k]], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << ' ';\n\t\twhile (res[n] == INF) {\n\t\t\tfor (int j = MAX - 1; j >= 0; j--) {\n\t\t\t\tif (res[j] != INF) {\n\t\t\t\t\tfor (int k = 0; k < odd.size() && j + odd[k] < MAX; k++) {\n\t\t\t\t\t\tres[j + odd[k]] = min(res[j + odd[k]], res[j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#define INF (int)(1e9)\nusing namespace std;\n\nint sankaku[111];\nint simen[111];\nint simen2[111];\nint maxi,maxj;\nint dp[111111];\nint dp2[111111];\nvoid solve(){\n  int i,j,t;\n  int n=111111;\n  for(i=0;i<n;i++){\n    dp[i]=dp2[i]=INF;\n  }\n  dp[0]=dp2[0]=0;\n  for(i=0;i<=maxj;i++){\n    t=simen[i];\n    for(j=t;j<=n;j++){\n      dp[j]=min(dp[j],dp[j-t]+1);\n    }\n  }\n\n  for(i=0;i<=maxi;i++){\n    t=simen2[i];\n    for(j=t;j<=n;j++){\n      dp2[j]=min(dp2[j],dp2[j-t]+1);\n    }\n  }\n\n\n}\n\n\nint main(void){\n  int n,i,j,t;\n  t=i=j=1;\n  sankaku[0]=1;\n  simen[0]=1;\n  simen2[0]=1;\n  while(simen[j-1]<111111){\n    sankaku[j]=sankaku[j-1]+j+1;\n    simen[j]=simen[j-1]+sankaku[j];\n    t=simen[j++];\n    if(t%2==1) simen2[i++]=t;\n  }\n  maxi=i;\n  maxj=j;\n  solve();\n  while(scanf(\"%d\",&n),n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint p[200],q[50],dp1[1000000],dp2[1000000],n;\n\nint main(){\n\trep(i,200)p[i]=(i+1)*(i+2)*(i+3)/6;\n\trep(i,50)q[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\tfor(int i=1;i<1e6;i++){\n\t\tdp1[i]=dp2[i]=INF;\n\t\trep(j,200)if(p[j]<=i)dp1[i]=min(dp1[i],dp1[i-p[j]]+1);\n\t\trep(j,50)if(q[j]<=i)dp2[i]=min(dp2[i],dp2[i-q[j]]+1);\n\t}\n\twhile(cin>>n&&n){\n\t\tcout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  //while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",n,n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define INF (1<<29)\n\nint N;\nint a[1010],dp[2][1000010];\n\nvoid make(){\n  int n;\n  for(n = 1; n <= 1000; n++) a[n] = n * (n+1) * (n+2) / 6;\n}\n\nint main(){\n  int i,j,k;\n\n  make();\n\n  rep(i,2) rep(j,1000010) dp[i][j] = INF;\n\n  dp[0][0] = dp[1][0] = 0;\n  for(i = 1; a[i] <= 1000000 && i < 1010; i++){\n    for(j = 0; j <= 1000000; j++){\n      if(j - a[i] >= 0) dp[0][j] = min(dp[0][j], dp[0][j - a[i]] + 1);\n      if(a[i] % 2 == 1 && j - a[i] >= 0) dp[1][j] = min(dp[1][j], dp[1][j - a[i]] + 1);\n    }\n  }\n\n  for(;;){\n    scanf(\"%d\",&N); if(N == 0) break;\n    cout << dp[0][N] << ' ' << dp[1][N] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint tetrahedron(int);\n\nint index_direct_match(int);\nint index_direct_match_odd(int);\nint index_number(int);\nint index_number_odd(int);\n\nint main(int argc, char const *argv[]) {\n\n  int n;\n  int cnt_min;\n  int cnt_only_odd;\n\n  for(cin >> n;n != 0;cin >> n){\n\n    cout << index_number(n) << \" \" <<  index_number_odd(n) << endl;\n\n  }\n\n  //\n\n  return 0;\n}\n\nint tetrahedron(int k){\n\n  return k*(k+1)*(k+2)/6;\n\n}\n\nint index_number(int index){\n  static int memo[1000]={};\n  if(index>=1 && index<=3) return index;\n  else if(index_direct_match(index)) return 1;\n  else if(memo[index] != 0) return memo[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i++){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number( index - tetrahedron(i) ));\n    }\n    memo[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n\n}\n\nint index_direct_match(int index){\n\n  for(int i=1;i<200;i++){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_direct_match_odd(int index){\n\n  for(int i=1;i<200;i+=4){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_number_odd(int index){\n  static int memo2[1000]={};\n  if(index>=1 && index<=34) return index;\n  else if(index_direct_match_odd(index)) return 1;\n  else if(memo2[index] != 0) return memo2[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i+=4){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number_odd( index - tetrahedron(i) ));\n    }\n    memo2[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dp1[1000001];\nint dp2[1000001];\n\nint const INF = 1<<29;\n\nint main() {\n    fill(dp1, dp1+1000001, INF);\n    fill(dp2, dp1+1000001, INF);\n    \n    dp1[0] = dp2[0] = 0;\n    \n    for(int i=1;;i++) {\n      int n = i*(i+1)*(i+2)/6;\n      if(n>1000000) break;\n      for(int j=n; j<=1000000; j++) {\n\tdp1[j] = min(dp1[j], dp1[j-n]+1);\n\tif(n%2) {\n\t  dp2[j] = min(dp2[j], dp2[j-n]+1);\n\t}\n      }\n    }\n    \n  int N;\n  while(cin >> N && N) {\n    cout << dp1[N] << ' ' << dp2[N] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1e6+1;\n\nvector<int> tetra;\nint all[MAX];\nint odd_only[MAX];\n\nvoid prepare() {\n    for (int i=1; i*(i+1)*(i+2)/6<MAX; ++i) {\n        tetra.push_back(i*(i+1)*(i+2)/6);\n    }\n\n    fill_n(all, MAX, INT_MAX);\n    all[0] = 0;\n    fill_n(odd_only, MAX, INT_MAX);\n    odd_only[0] = 0;\n\n    for (int t: tetra) {\n        for (int i=0; i+t<MAX; ++i) {\n            all[i+t] = min(all[i+t], all[i]+1);\n            if (t % 2) odd_only[i+t] = min(odd_only[i+t], odd_only[i]+1);\n        }\n    }\n}\n\nint main() {\n    prepare();\n    int n;\n    while (cin >> n, n) {\n        cout << all[n] << \" \" << odd_only[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n/*\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tvi four;\n\tint n = 1;\n\twhile(true) {\n\t\tint num = n*(n+1)*(n+2)/6;\n\t\tif(num > 1000000) {\n\t\t\tbreak;\t\n\t\t} else {\n\t\t\tfour.push_back(num);\n\t\t\tn++;\n\t\t}\n\t}\n\tint fsize = four.size();\n\n\twhile(cin >> n, n) {\n\t\t//vi dp(n+1, INF);\n\t\t//vi dpk(n+1, INF);\n\t\tint dp[1000001], dpk[1000001];\n\t\tFOR(i, 1, 1000000) {\n\t\t\tdp[i] = dpk[i] = INF;\n\t\t}\n\n\t\tdp[0] = dpk[0] = 0;\n\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, fsize) {\n\t\t\t\tif(i-four[j] >= 0) {\n\t\t\t\t\tdp[i] = min(dp[i-four[j]]+1, dp[i]);\n\t\t\t\t\tif(four[j]%2) {\n\t\t\t\t\t\tdpk[i] = min(dpk[i-four[j]]+1, dpk[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[n] << \" \" << dpk[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n\nint dp[100000];\nint dp_odd[100000];\nint main(){\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    for(int i=1; i<100000; i++){\n        dp[i] = -1;\n        dp_odd[i] = -1;\n    }\n    for(int n=1; n*(n+1)*(n+2)/6 < 100000; n++){\n        bool isodd = false;\n        int p = n*(n+1)*(n+2)/6;\n        if(p%2 == 1) isodd = true;\n        for(int k=1; p*k < 100000; k++){\n            for(int i=0; i+p*k < 100000; i++){\n                if(dp[i] != -1){\n                    if(dp[i+p*k] != -1){\n                        dp[i+p*k] = std::min(dp[i+p*k], dp[i] + k);\n                        if(isodd) dp_odd[i+p*k] = std::min(dp_odd[i+p*k], dp_odd[i] + k);\n                    }else{\n                        dp[i+p*k] = dp[i] + k;\n                        if(isodd) dp_odd[i+p*k] = dp_odd[i] + k;\n                    }\n                }\n            }\n        }\n    }\n    int x;\n    scanf(\"%d\",&x);\n    while(x!=0){\n        printf(\"%d %d\\n\", dp[x], dp_odd[x]);\n        scanf(\"%d\",&x);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nvector<unsigned int> triq,subtriq;\nmap<unsigned int,unsigned int> cld,subcld;\nvoid addtriq(unsigned int max){\n\twhile(triq.back()<max){\n\t\ttriq.push_back((triq.size()+1)*(triq.size()+2)*(triq.size()+3)/6);\n\t\tif(triq.back()%2==1)subtriq.push_back(triq.back());\n\t}\n\treturn;\n}\n\nunsigned int calc(unsigned int cur,vector<unsigned int>& list,map<unsigned int,unsigned int>& cld,unsigned int& cmin,unsigned int cstp){\n\tunsigned int sub,ret=-1;\n\tmap<unsigned int,unsigned int>::iterator it;\n\tif(cstp>=cmin){\n\t\tcld.insert(pair<unsigned int,unsigned int>(cur,-1));\n\t\treturn -1;\n\t}\n\tit=cld.find(cur);\n\tif(it!=cld.end()){\n\t\treturn (*it).second;\n\t}\n\tfor(vector<unsigned int>::reverse_iterator ri=list.rbegin();ri!=list.rend();++ri){\n\t\tint d=cur-(*ri);\n\t\tif(d==0){\n\t\t\tcmin=cstp;\n\t\t\treturn cstp;\n\t\t}\n\t\tif(d>0){\n\t\t\tsub=calc(d,list,cld,cmin,cstp+1);\n\t\t\tif(sub<ret)ret=sub;\n\t\t}\n\t}\n\tcld.insert(pair<unsigned int,unsigned int>(cur,ret));\n\treturn ret;\n}\n\nint main(){\n\ttriq.push_back(1);\n\tsubtriq.push_back(1);\n\twhile(true){\n\t\tunsigned int n,cmin;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\taddtriq(n);\n\t\tcmin=-1;\n\t\tcalc(n,triq,cld,cmin,1);\n\t\tcout<<cmin<<' ';\n\t\tcmin=-1;\n\t\tcalc(n,subtriq,subcld,cmin,1);\n\t\tcout<<cmin<<endl;\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tvector<int> dp1(1000000,1000000);\n\tdp1[0] = 0;\n\tvector<int> dp2(1000000,1000000);\n\tdp2[0] = 0;\n\tfor(int i=1;i*(i+1)*(i+2)<1000000;i++){\n\t\tint x = i*(i+1)*(i+2)/6;\n\t\tfor(int j=0;j<1000000-x;j++){\n\t\t\tdp1[j+x] = min(dp1[j+x],dp1[j] + 1);\n\t\t\tif(x%2 == 1) dp2[j+x] = min(dp2[j+x],dp2[j] + 1);\n\t\t}\n\t}\n\t\n\tint a;\n\twhile(cin >> a,a > 0){\n\t\tcout << dp1[a] << \" \" << dp2[a] << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\n    int res=0xFFFF;\n    if(maxcnt<cnt) return 0xFFFF;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n    }\n    return res;\n}\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        if((oddres=oddrec(n, 0, 0, 1))==0xFFFF) {\n            for(int i=2; ; i=i*3/2) {\n                if((oddres=oddrec(n, 0, 0, i))!=0xFFFF)\n                    break;\n            }\n        }\n\n        printf(\"%d %d\\n\",res,oddres);\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint d[182] = {} ;\nint D[182] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<182 ; i++ ){\n\t\td[i] = d[i-1] + i ;\n\t\tD[i] = D[i-1] + d[i] ;\n\t}\n}\n\nint cal_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse return x/D[c] + cal_2( x%D[c] , c-1 ) ;\n}\n\nint cal( int m , int q ){\n\tint ans = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans = min( ans , cal_2( m , j ) ) ;\n\t}\n\treturn ans ;\n}\n\nint cal_odd_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( D[c]%2 == 0 ) return cal_odd_2( x , c-1 ) ;\n\t\telse return x/D[c] + cal_odd_2( x%D[c] , c-1 ) ;\n\t}\n}\n\nint cal_odd( int m , int q ){\n\tint ans_2 = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans_2 = min( ans_2 , cal_odd_2( m , j ) ) ;\n\t}\n\treturn ans_2 ;\n}\n\nvoid dp(){\n\tint p = 1 ;\n\t\n\tfor( int i=1 ; i<=1000000 ; i++ ){\n\t\tif( i < 182 && i >= D[p] ) p++ ;\n\t\tdp_map[0][i] = cal(i,p) ;\n\t\tdp_map[1][i] = cal_odd(i,p) ;\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int R = 1000000+1;\nint dp1[R],dp2[R],T[144];\n\nvoid solve(void) {\n    for (int i = 1; i < R; i++) dp1[i] = dp2[i] = R;\n    for (int i = 1; i < 145; i++) T[i-1] = i*(i+1)*(i+2)/6;\n    for (int i = 0; i < 144; i++) {\n        int t = T[i];\n        for (int j = t; j < R; j++) {\n            if (dp1[j-t] < R) dp1[j] = min(dp1[j], dp1[j-t]+1);\n            if (t%2 == 0) continue;\n            if (dp2[j-t] < R) dp2[j] = min(dp2[j], dp2[j-t]+1);\n        }\n    }\n}\n\nint main(void){\n    solve();\n    while (1) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        printf(\"%d %d\\n\",dp1[N],dp2[N]);\n    }\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\n\nvoid solve(int n) {\n\tbool **dp = new bool*[6];\n\tfor (int i=0; i<6; i++) {\n\t\tdp[i] = new bool[MAX+10];\n\t\tfor (int j=0; j<MAX+10; j++)\n\t\t\tdp[i][j] = 0;\n\t}\n\n\tfor (int i=0; i<N; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tfor (int i=0; i<5; i++) {\n\t\tif (dp[i][n]) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i=0; i<6; i++)\n\t\tdelete [] dp[i];\n\tdelete [] dp;\n\n\n\t// \n\tbool **dp2 = new bool*[n+5];\n\tfor (int i=0; i<n+5; i++) {\n\t\tdp2[i] = new bool[MAX+10];\n\t\tfor (int j=0; j<MAX+10; j++)\n\t\t\tdp2[i][j] = 0;\n\t}\n\n\tfor (int i=0; i<M; i++)\n\t\tdp2[0][D[i]] = 1;\n\t\n\tfor (int i=1; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp2[i-1][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp2[i][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tfor (int i=0; i<n; i++) {\n\t\tif (dp2[i][n]) {\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i=0; i<6; i++)\n\t\tdelete [] dp2[i];\n\tdelete [] dp2;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( (i*(i+1)*(i+2)/6)%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/06/29 Tazoe\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> P;\n\tP.push_back(1);\n\n\tfor(int i=0; ; i++){\n\t\tint p = P[i]*(i+4)/(i+1);\n\n\t\tif(p>=1000000)\n\t\t\tbreak;\n\n\t\tP.push_back(p);\n\t}\n/*\n\tfor(int i=0; i<P.size(); i++){\n\t\tcout << P[i] << endl;\n\t}\n*/\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tint DP[1000000];\n\t\tint DP2[1000000];\n\t\tDP[0] = 0;\n\t\tDP2[0] = 0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tDP[i] = 1000000;\n\t\t\tDP2[i] = 1000000;\n\t\t}\n\n\t\tfor(int i=0; P[i]<=n; i++){\n\t\t\tfor(int j=0; j+P[i]<=n; j++){\n\t\t\t\tif(DP[j]+1<DP[j+P[i]]){\n\t\t\t\t\tDP[j+P[i]] = DP[j]+1;\n\t\t\t\t}\n\n\t\t\t\tif(P[i]%2==1 && DP2[j]+1<DP2[j+P[i]]){\n\t\t\t\t\tDP2[j+P[i]] = DP2[j]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << DP[n] << ' ' << DP2[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n \nusing namespace std;\n\nusing ll = long long;\n\nvector<int> v, v1;\n\nint main(){\n\tfor(int i = 1;i * (i + 1) * (i + 2) / 6 <= 1e6;i++){\n\t\tv.push_back(i * (i + 1) * (i + 2) / 6);\n\t}\n\tfor(int i = 1;i * (i + 1) * (i + 2) / 6 <= 1e6;i++){\n\t\t//cout<<i*(i+1)*(i+2)/6<<endl;\n\t\tif(i * (i + 1) * (i + 2) / 6 % 2 == 1)v1.push_back(i * (i + 1) * (i + 2) / 6);\n\t}\n\tint n = 1e6;\n\tvector<vector<int>> dp(2, vector<int>(n + 1, 1e9));\n\t\tdp[0][0] = 0;\n\t\tfor(int i = 0;i < v.size();i++){\n\t\t\tfor(int j = 0;j < n + 1;j++){\n\t\t\t\tdp[(i + 1)%2][j] = min(dp[i%2][j], dp[(i + 1)%2][j]);\n\t\t\t\tif(j + v[i] > n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdp[(i + 1)%2][j + v[i]] = min(dp[(i + 1)%2][j + v[i]], dp[i % 2][j] + 1);\n\t\t\t\tdp[(i + 1)%2][j + v[i]] = min(dp[(i + 1)%2][j] + 1, dp[(i + 1)%2][j + v[i]]);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>> dp1(2, vector<int>(n + 1, 1e9));\n\t\tdp1[0][0] = 0;\n\t\tfor(int i = 0;i < v1.size();i++){\n\t\t\tfor(int j = 0;j < n + 1;j++){\n\t\t\t\tdp1[(i + 1)%2][j] = min(dp1[i%2][j], dp1[(i + 1)%2][j]);\n\t\t\t\tif(j + v1[i] > n){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdp1[(i + 1)%2][j + v1[i]] = min(dp1[(i + 1)%2][j + v1[i]], dp1[i%2][j] + 1);\n\t\t\t\tdp1[(i + 1)%2][j + v1[i]] = min(dp1[(i + 1)%2][j] + 1, dp1[(i + 1)%2][j + v1[i]]);\n\t\t\t}\n\t\t}\n\twhile(cin >> n){\n\t\tif(n == 0)return 0;\n\t\t\n\t\tcout<<dp.back()[n]<<\" \"<<dp1.back()[n]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_n = static_cast<int>(1e6);\nint dp[max_n],odp[max_n];\nvector<int> odd,all;\n\nint main() {\n\n    for(int i=1; i*(i+1)*(i+2)/6<max_n; i++){\n        if((i*(i+1)*(i+2)/6)%2 == 1){\n            odd.push_back(i*(i+1)*(i+2)/6);\n        }\n        all.push_back(i*(i+1)*(i+2)/6);\n    }\n\n    memset(dp,1000000,sizeof(dp));\n    memset(odp,1000000, sizeof(odp));\n    dp[0] = 0;\n    odp[0] = 0;\n\n    for(int i=1; i<max_n; i++){\n        for(int j=0; j<all.size(); j++){\n            if(i-all[j] < 0) {\n                break;\n            }\n            dp[i] = min(dp[i],dp[i-all[j]] + 1);\n        }\n    }\n\n    for(int i=1; i<max_n; i++){\n        for(int j=0; j<odd.size(); j++){\n            if(i-odd[j] < 0) {\n                break;\n            }\n            odp[i] = min(odp[i],odp[i-odd[j]] + 1);\n        }\n    }\n\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << dp[n] << \" \" << odp[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n;\n    vector<int>v;\n    int m=0;\n    for(int i=1;(i*(i+1)*(i+2))/6 < 1e6;++i){\n        v.push_back((i*(i+1)*(i+2))/6);\n        m++;\n    }\n    while(cin>>n,n){\n        vector<int>dp(1e6,1e9);\n        vector<int>dp1(1e6,1e9);\n        dp[0]=0;\n        dp1[0]=0;\n        for(int i=0;i<=n;++i){\n            for(int j=0;j<m;++j){\n                if(i+v[j]>=1e6){\n                    m=j;\n                    break;\n                }\n                dp[i+v[j]]=min(dp[i]+1,dp[i+v[j]]);\n                if(v[j]%2==0)continue;\n                dp1[i+v[j]]=min(dp1[i]+1,dp1[i+v[j]]);\n            }\n        }\n        cout<<dp[n]<<\" \"<<dp1[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n) ; i++)\n#define rrep(i,n) for(int i = n-1; i >= 0 ; i--)\nconstexpr auto INF = 2147483647;\ntypedef long long ll;\n\nint tri(int a){\n  return a*(a+1)/2*(a+2)/3;\n};\n\nstatic const int MAX = 1000005;\n\nint main(){\n  int x, max_n;\n  int DP[MAX], DP_ODD[MAX], tri_list[200];\n  vector<int> tri_list_odd;\n  fill(DP, DP+MAX,INF);\n  fill(DP_ODD,DP_ODD+MAX,INF);\n  rep(i,200){\n    tri_list[i] = tri(i+1);\n    if(tri_list[i]%2 != 0) tri_list_odd.emplace_back(tri_list[i]);\n  } \n  DP[0] = 0;\n  DP_ODD[0] = 0;\n  rep(i,200){\n    for(int j = tri_list[i];j<MAX;j++){\n      DP[j] = min(DP[j], DP[j-tri_list[i]]+1);\n    }\n  }\n  rep(i,tri_list_odd.size()){\n    for(int j = tri_list_odd[i];j<MAX;j++){\n      DP_ODD[j] = min(DP_ODD[j],DP_ODD[j-tri_list_odd[i]]+1);\n    }\n  }\n\n  while(true){\n    cin >> x;\n    if(x == 0)break;\n    cout << DP[x] << \" \" << DP_ODD[x] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define repb(i, n) for(int i = n;i >= 0;i--)\n#define reps(i, m, n) for(int i = m;i < n;i++)\n#define repsb(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\ntypedef long long ll;\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\nusing namespace std;\n\n#define N 1000000\n\nint fa[N];\nint sa[N];\nvoid cal(void){\n int cl;\n fa[0]=0;\n sa[0]=0;\n reps(i,1,N){\n   fa[i]=sa[i]=i;\n   reps(j,1,INF){\n     cl=j*(j+1)*(j+2)/6;\n     if(cl>i) break;\n     fa[i]=min(fa[i],fa[i-cl]+1);\n     if(cl&1)  sa[i]=min(sa[i],sa[i-cl]+1);\n   }\n }\n}\nint main(int argc, char const *argv[]) {\n cal();\n int t;\n while (true) {\n   cin>>t;\n   if(t==0)  break;\n   printf(\"%d %d\\n\",fa[t],sa[t] );\n }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n \n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n \nusing namespace std;\n \nconst int MAX = 1000100;\n \nvector<int> list;\nvector<int> odd;\n \nvoid init()\n{\n    for(int i=1;;i++)\n    {\n        int num = i*(i+1)*(i+2)/6;\n        if(num > MAX){ break; }\n        list.push_back(num);\n        if(num % 2){ odd.push_back(num); }\n    }\n \n    return;\n}\n \nint main()\n{\n    init();\n     \n    vector<int> dp(MAX,MAX);\n    vector<int> odd_dp(MAX,MAX);\n     \n    dp[0] = 0;\n    odd_dp[0] = 0;\n    \n    cout << list.size() << endl;\n\n    rep(i,list.size()){\n        rep(j,MAX){\n            dp[j] = min(dp[j], dp[j - list[i]] + 1);    \n        }\n    }\n \n    rep(i,odd.size()){\n        rep(j,MAX){\n            odd_dp[j] = min(odd_dp[j], odd_dp[j - odd[i]] + 1); \n        }\n    }\n     \n    int N;\n    while(cin >> N && N){\n        cout << dp[N] << \" \" << odd_dp[N] << endl;  \n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX (1000000)\n#define INF (1<<30)\n\nint main() {\n  \n  int dp_all[MAX+2], dp_odd[MAX+2];\n  \n  fill(dp_all, dp_all+MAX+1, INF);\n  fill(dp_odd, dp_odd+MAX+1, INF);\n  \n  dp_all[0] = dp_odd[0] = 0;\n  \n  for(int i=1; ; i++) {\n    int num = i*(i+1)*(i+2) / 6;\n    if(num > MAX) break;\n    for(int j=num; j<=MAX; j++) {\n      dp_all[j] = min(dp_all[j], dp_all[j-num]+1);\n      if(num % 2)\n\tdp_odd[j] = min(dp_odd[j], dp_odd[j-num]+1);\n    }\n  }\n  \n  int n;\n  while(cin >> n && n) {\n    cout << dp_all[n] << \" \" << dp_odd[n] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvi llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\n\nint beam_width=100;\n\nint bfs(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n        }\n        if(i<target){\n            q.pb(i);\n            mm=i;\n        }\n        if(i>target) break;\n    }\n    //auto mm=*max_element(beginend(q));\n    int cnt=0;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(llist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,llist){\n                if(k+x>target) break;\n                // if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.pb(k+x);\n            }\n\n            \n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) {q.pb(i);mm=i;}\n        if(i>target) break;\n    }\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    //out(mm);\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(oddlist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                //if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.pb(k+x);\n            }\n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    int mm=0;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n        mm=max(mm,n);\n    }\n    map<int,pii> m;\n    makeList(mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        //int ans2=0;\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n, dp[1000000], dp2[1000000];\n\nvoid solve() {\n  memset(dp, -1, sizeof dp);\n  memset(dp2, -1, sizeof dp2);\n  \n  dp[0] = dp2[0] = 0;\n  for (int i = 1; i < 10000; i += 1) {\n    dp[i] = dp2[i] = i;\n    for (int j = 1;; j += 1) {\n      int s = j * (j + 1) * (j + 2) / 6;\n      if (s > i) break;\n      dp[i] = min(dp[i], dp[i - s] + 1);\n      if (s % 2) {\n        dp2[i] = min(dp2[i], dp2[i - s] + 1);\n      }\n    }\n  }\n  cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  \n  \n  while (cin>>n, n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define Rep(b, e, i) for (int i = b; i <= e; i++)\n#define Repr(e, b, i) for (int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n - 1, i)\n#define repr(n, i) Repr(n - 1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(v) push_back(v)\n#define uniq(v) (v).erase(unique(all(v)), (v).end())\n#define bitcnt(x) __builtin_popcount(x)\n#define fst first\n#define snd second\n#define Pqaz(T) priority_queue<T, vector<T>, greater<T>>\n#define Pqza(T) priority_queue<T>\n#define put(x) cout << x;\n#define putsp(x) cout << x << ' ';\n#define putbd cout << \"---------------------------------------------\" << endl;\n#define putln(x) cout << x << endl;\n#define debug(x) cerr << #x << \"=\" << x << endl;\n#define ENJYU std::ios::sync_with_stdio(false) std::cin.tie(0);\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef complex<double> comp;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<double> vecd;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\ntypedef vector<vecd> matd;\n\ntemplate <class T>\nostream &operator<<(ostream &o, const vector<T> &v)\n{\n\to << \"{\";\n\tfor (int i = 0; i < (int)v.size(); i++) o << (i > 0 ? \", \" : \"\") << v[i];\n\to << \"}\";\n\treturn o;\n}\n\nconst int MAX = 1000000;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst ll INFL = 1e18;\nconst ll MOD = 1000000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\n//********************************template END****************************************//\n\nvoid solve()\n{\n\tvec memo, odds;\n\tint n = 1, res = -1;\n\twhile(res <= MAX)\n\t{\n\t\tres = n * (n + 1) * (n + 2) / 6;\n\t\tmemo.pb(res);\n\t\tif (res&1) odds.pb(res);\n\t\tn++;\n\t}\n\n\tvec dp1(MAX+1, INF), dp2;\n\tdp1[0] = 0;\n\tdp2 = dp1;\n\n\trep(MAX, m)\n\t{\n\t\tdp1[m] = min(dp1[m], m);\n\t\tdp2[m] = min(dp2[m], m);\n\t\tfor (int x : memo)\n\t\t{\n\t\t\tif (m < x) break;\n\t\t\tdp1[m] = min(dp1[m - x] + 1, dp1[m]);\n\t\t}\n\t\tfor (int x : odds)\n\t\t{\n\t\t\tif (m < x) break;\n\t\t\tdp2[m] = min(dp2[m - x] + 1, dp2[m]);\n\t\t}\n\t}\n\n\twhile (~scanf(\"%d\", &n))\n\t{\n\t\tif (n == 0) break;\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\t//cout << \"yui(*-v・)yui\" << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 100001;\nconst int INF = 1<<27;\nvector<int> N3, N4;\n\nvoid makeN3() {\n  N3.push_back(0);\n  for(int i = 1, s = 1; s <= MAX_N; s += ++i) {\n    N3.push_back(s);\n  }\n}\n\nvoid makeN4() {\n  N4.push_back(0);\n  for(int i = 1, s = N3[1]; s <= MAX_N; s += N3[++i]) {\n    N4.push_back(s);\n  }\n}\n\nint solve(int N, bool oddOnly) {\n  int T[MAX_N];\n  fill(T, T+N+1, INF);\n  T[0] = 0;\n  for(int i = 1; i <= N; ++i) {\n    for(int j = 1; j < N4.size() && N4[j] <= i; ++j) {\n      if(oddOnly && N4[j]%2 == 0) continue;\n      T[i] = min(T[i], T[i-N4[j]] + 1);\n    }\n  }\n  return T[N];\n}\n\nint main() {\n  int N;\n  makeN3();\n  makeN4();\n  while(cin >> N && N) {\n    cout << solve(N,false) << \" \" << solve(N,true) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector < vector<bool> >dp(201, vector < bool>(1000001, 0));\n\tdp[0][0] = 1;\n\tREP(i, 5) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 6)REP(j, 1000001)dp[i][j] = 0;\n\tdp[0][0] = 1;\n\tREP(i, 200) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k % 2 == 0)continue;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tREP(i, 5) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \" \";\n\t\tREP(i, 200) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MAX 1000000\n\nint calc(int n) { return n*(n + 1)*(n + 2) / 6; }\nint p[200];\nint p1[200];\nint dp[MAX] = { 0 };\nint dp1[MAX] = { 0 };\n\nint func(int n, int P[], int DP[])\n{\n\tif (n <= 0)return MAX;\n\tif (DP[n] != 0)return DP[n];\n\telse\n\t{\n\t\tint min_t = MAX;\n\t\tint i = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (P[i] <= n && n <= P[i + 1])break;\n\t\t\tif (P[i] == 1004731)\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int t = i; t>0; t--)\n\t\t{\n\t\t\tint temp = func(n - P[t], P, DP);\n\t\t\tif (min_t > temp + 1)\n\t\t\t{\n\t\t\t\tmin_t = temp + 1;\n\t\t\t}\n\t\t}\n\t\tDP[n] = min_t;\n\t\treturn DP[n];\n\t}\n}\n\nint main()\n{\n\tint index = 1;\n\tFOR(i, 1, 200)\n\t{\n\t\tint temp = calc(i);\n\t\tif (temp > 1004731)break;\n\t\tp[i] = temp;\n\t\tdp[p[i]] = 1;\n\t\tif (temp % 2 == 1)\n\t\t{\n\t\t\tp1[index] = temp;\n\t\t\tdp1[p1[index]] = 1;\n\t\t\tindex++;\n\t\t}\n\t}\n\twhile (1)\n\t{\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)return 0;\n\t\tcout << func(N, p, dp) << \" \" << func(N, p1, dp1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/06/29 Tazoe\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n\tvector<int> P;\n\tP.push_back(1);\n\n\tfor(int i=0; ; i++){\n\t\tint p = P[i]*(i+4)/(i+1);\n\n\t\tif(p>=1000000)\n\t\t\tbreak;\n\n\t\tP.push_back(p);\n\t}\n/*\n\tfor(int i=0; i<P.size(); i++){\n\t\tcout << P[i] << endl;\n\t}\n*/\n\tint DP[1000000];\n\tint DP2[1000000];\n\tDP[0] = 0;\n\tDP2[0] = 0;\n\tfor(int i=1; i<1000000; i++){\n\t\tDP[i] = 1000000;\n\t\tDP2[i] = 1000000;\n\t}\n\n\tfor(int i=0; P[i]<1000000; i++){\n\t\tfor(int j=0; j+P[i]<1000000; j++){\n\t\t\tif(DP[j]+1<DP[j+P[i]]){\n\t\t\t\tDP[j+P[i]] = DP[j]+1;\n\t\t\t}\n\n\t\t\tif(P[i]%2==1 && DP2[j]+1<DP2[j+P[i]]){\n\t\t\t\tDP2[j+P[i]] = DP2[j]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tcout << DP[n] << ' ' << DP2[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  vector<int> sime(181),kisi(46);\n  for(int i=0;i<=180;i++){\n    sime[i]=(i+1)*(i+2)*(i+3)/6;\n  }\n  for(int i=0;i<=45;i++){\n    kisi[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n  }\n  vector<int> ans(1000001,100000),kians(1000001,100000);\n  ans[0]=0;\n  for(int i=1;i<=1000000;i++){\n    for(int j=0;j<=180;j++){\n      if(i-sime[j]>=0){\n        ans[i]=min(ans[i],ans[i-sime[j]]+1);\n      }\n    }\n  }\n  kians[0]=0;\n  for(int i=1;i<=1000000;i++){\n    for(int j=0;j<=45;j++){\n      if(i-kisi[j]>=0){\n        kians[i]=min(kians[i],kians[i-kisi[j]]+1);\n      }\n    }\n  }\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    cout << ans[n] SP kians[n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N 1000000\n#define INFINITY 2000000000\nusing namespace std;\nint main(){\n  int n,cpn,data[N],i,cnt,minv,cal,l;\n  for(i=1;i<=N;i++) data[i]=(i*(i+1)*(i+2))/6;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    cnt=n;\n    cpn=n;\n    minv=INFINITY;\n    l=0;\n    while(cnt){\n      n=cpn;\n      cal=0;\n      for(i=n-l;i>=1;i--){\n\tcal+=n/data[i];\n\tn%=data[i];\n      }\n      minv=min(minv,cal);\n      cnt--;\n      l++;\n    }\n    cout << minv;\n    n=cpn;\n    cnt=n;\n    minv=INFINITY;\n    l=0;\n    while(cnt){\n      n=cpn;\n      cal=0;\n      for(i=n-l;i>=1;i--){\n\tif(data[i]%2==1){\n\t  cal+=n/data[i];\n\t  n%=data[i];\n\t}\n      }\n      minv=min(minv,cal);\n      cnt--;\n      l++;\n    }\n    cout << ' ' << minv << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[200]={0},c[1000001],d[1000001],k=0,i,j,n;\n\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=0;i<1000000;i++)c[i]=d[i]=i;\n\n  for(i=1;i<195;i++)for(j=a[i];j<a[i+1];j++){\n    if(j>1000000)break;\n    c[j]=c[j-a[i]]+1;\n  }\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++){\n    if(j>1000000)break;\n    d[j]=d[j-b[i]]+1;\n  }\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    long long i;\n    int n;\n    long long j = 0;\n    int a[84];\n    int b[22];\n    long long t[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nint tetrahedral_number (int n)\n{\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\nint tetrahedral_number (std::vector<int>* vec, std::vector<int>* indices)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i] * tetrahedral_number ((*indices)[i]);\n    }\n\n    return num;\n}\n\nint tetrahedral_number (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i] * tetrahedral_number (i + 1);\n    }\n    return num;\n}\n\nint vector_sum (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i];\n    }\n\n    return num;\n}\n\nstd::vector<int>* approx_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    //std::cout <<  \"base:\";\n\n    while (tmp_n != 0)\n    {\n\n        int i = 0;\n\n        while (i++, tetrahedral_number (i + 1) <= tmp_n);\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (i);\n        }\n\n        (*solution)[i-1] = (*solution)[i-1] + 1;\n\n\n        tmp_n = tmp_n - tetrahedral_number (i);\n\n    }\n\n\n    return solution;\n}\n\nstd::vector<int>* improve_pollock_solution (std::vector<int>* base, int total)\n{\n\n    int dim = base->size ();\n\n    auto iterated_v = new std::vector<int> (*base);\n\n    std::vector<int>* solution = base;\n\n    int vsum = 0;\n\n    int approx_sum = 5;\n\n    while ((vsum = vector_sum (iterated_v)) > 0)\n    {\n        //print_vector (iterated_v);\n\n        if (tetrahedral_number (iterated_v) == total && vsum <= approx_sum)\n        {\n            if (vector_sum (solution) > vsum)\n            {\n                solution = new std::vector<int> (*iterated_v);\n                approx_sum = vsum;\n                //return solution;\n            }\n        }\n\n\n        if ((*iterated_v)[0] > 0)\n        {\n            (*iterated_v)[0] = (*iterated_v)[0] - 1;\n        }\n        else\n        {\n            for (int index = 1; index < dim; index++)\n            {\n                if ((*iterated_v)[index] != 0)\n                {\n                    (*iterated_v)[index] = (*iterated_v)[index] - 1;\n\n                    for (index = index - 1; index >= 0; index--)\n                    {\n                        (*iterated_v)[index] = approx_sum - vector_sum (iterated_v);\n                    }\n\n                    int i = 0;\n                    for (i = dim - 1; i > 0; i--)\n                    {\n                        if ((*iterated_v)[i] != 0)\n                        {\n                            break;\n                        }\n                    }\n\n                    if (tetrahedral_number (i+1) * approx_sum < total)\n                    {\n                        return solution;\n                    }\n\n                    break;\n                }\n            }\n\n        }\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* approx_odd_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    while (tmp_n != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= tmp_n; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (cnt);\n        }\n\n        (*solution)[cnt-1] = (*solution)[cnt-1] + 1;\n\n        tmp_n = tmp_n - tetrahedral_number (odd_i);\n\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* improve_odd_pollock_solution (std::vector<int>* base, int total)\n{\n\n    int dim = base->size ();\n\n    auto iterated_v = new std::vector<int> (*base);\n\n    std::vector<int>* solution = base;\n\n\n    auto tetra_indices = new std::vector<int> (dim);\n\n    int n_copy = total;\n\n    while (n_copy != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= n_copy; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n\n        (*tetra_indices)[cnt-1] = odd_i;\n\n        int tetra_num = tetrahedral_number (odd_i);\n\n        while (n_copy >= tetra_num)\n        {\n            n_copy = n_copy - tetra_num;\n        }\n\n    }\n\n    int vsum = 0;\n\n    int approx_sum = vector_sum (iterated_v);\n\n    while ((vsum = vector_sum (iterated_v)) > 0)\n    {\n\n        if (tetrahedral_number (iterated_v, tetra_indices) == total)\n        {\n\n            if (vector_sum (solution) > vsum)\n            {\n                solution = new std::vector<int> (*iterated_v);\n                approx_sum = vsum;\n            }\n        }\n\n\n        if ((*iterated_v)[0] > 0)\n        {\n            (*iterated_v)[0] = (*iterated_v)[0] - 1;\n        }\n        else\n        {\n            for (int index = 1; index < dim; index++)\n            {\n                if ((*iterated_v)[index] != 0)\n                {\n                    (*iterated_v)[index] = (*iterated_v)[index] - 1;\n\n                    for (index = index - 1; index >= 0; index--)\n                    {\n                        (*iterated_v)[index] = approx_sum - vector_sum (iterated_v);\n                    }\n\n                    int i = 0;\n                    for (i = dim - 1; i > 0; i--)\n                    {\n                        if ((*iterated_v)[i] != 0)\n                        {\n                            break;\n                        }\n                    }\n\n                    if (tetrahedral_number ((*tetra_indices)[i+1]) * approx_sum < total)\n                    {\n                        return solution;\n                    }\n\n                    break;\n                }\n            }\n\n        }\n    }\n\n\n\n    return solution;\n\n}\n\nint main ()\n{\n\n    int n = 0;\n    while (std::cin >> n, n != 0)\n    {\n\n        auto b = approx_least_number_by_tetrahedral (n);\n\n        auto s = improve_pollock_solution (b,n);\n        \n        int normal = vector_sum (s);\n\n        auto ob = approx_odd_least_number_by_tetrahedral (n);\n\n        auto os = improve_odd_pollock_solution (ob, n);\n\n        int odd =vector_sum (os);\n\n        std::cout << normal << \" \" << odd <<  std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000\nusing namespace std;\n\nconst int M = 1000000;\nint N, base1[M + 1], base2[M + 2], dp1[M + 1], dp2[M + 1];\n\nint dfs1(int n) {\n  if(dp1[n] > 0) return dp1[n];\n  if(base1[n]) return dp1[n] = 1;\n\n  int ret = INF;\n  REP(i, 1, n - 1) ret = min(ret, dfs1(i) + dfs1(n - i));\n  return dp1[n] = ret;\n}\n\nint dfs2(int n) {\n  if(dp2[n] > 0) return dp2[n];\n  if(base2[n]) return dp2[n] = 1;\n\n  int ret = INF;\n  REP(i, 1, n - 1) ret = min(ret, dfs2(i) + dfs2(n - i));\n  return dp2[n] = ret;\n}\n\nint main(void) {\n  REP(i, 1, M) dp1[i] = dp2[i] = 0;\n  for(int i = 1, n; n = i * (i + 1) * (i + 2) / 6, n <= M; i++) {\n    base1[n] = 1;\n    if(n % 2 == 1) base2[n] = 1;\n  }\n\n  while(cin >> N, N) {\n    cout << dfs1(N) << \" \" << dfs2(N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n//#define int long long\nconst int N = 1e6 + 10;\nconst int INF = 1e9 + 10;\n\nint main() {\n  vector<int> v, vv;\n  for(int i = 1; i * (i + 1) * (i + 2) / 6 < N; ++i) v.push_back(i * (i + 1) * (i + 2) / 6);\n  REP(i, v.size()) if(v[i] % 2) vv.push_back(v[i]);\n  vector<int> dp(N, INF), dp_odd(N, INF);\n  dp[0] = dp_odd[0] = 0;\n  REP(i, v.size()) for(int j = v[i]; j < N; ++j) dp[j] = min(dp[j], dp[j - v[i]] + 1);\n  REP(i, vv.size()) for(int j = vv[i]; j < N; ++j) dp_odd[j] = min(dp_odd[j], dp_odd[j - vv[i]] + 1);\n  int n;\n  while(cin >>n && n) cout <<dp[n] <<\" \" <<dp_odd[n] <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\n\nint main() {\n    int table[1000000];\n    int max;\n    for (int i = 1; i < 1000000; i++) {\n        table[i] = i * (i + 1) * (i + 2) / 6;\n        if (table[i] >= 1000000) {\n            max = i - 1;\n            break;\n        }\n    }\n\n    int m;\n    while (cin >> m, m) {\n        bool used[1000000];\n        fill_n((bool *)used, 1000000, false);\n        priority_queue<ppiii, vector<ppiii>, greater<ppiii>> q;\n        q.push({{0, 0}, 1});\n        while (!q.empty()) {\n            ppiii p = q.top(); q.pop();\n            int count = p.first.first;\n            int total = p.first.second;\n            int now = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << \" \";\n                break;\n            }\n\n            for (int i = now; i < max; i++) {\n                int sum = table[i] + total;\n                if (sum <= m && !used[sum]) {\n                    q.push({{count+1, sum}, i});\n                    used[sum] = true;\n                }\n            }\n        }\n        while(!q.empty())\n            q.pop();\n        fill_n((bool *)used, 1000000, false);\n        q.push({{0, 0}, 1});\n        while (!q.empty()) {\n            ppiii p = q.top(); q.pop();\n            int count = p.first.first;\n            int total = p.first.second;\n            int now = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << endl;\n                break;\n            }\n\n            for (int i = now; i < max; i++) {\n                int sum = table[i] + total;\n                if (table[i] % 2 && sum <= m && !used[sum]) {\n                    q.push({{count+1, sum}, i});\n                    used[sum] = true;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int i,j,n,three[1000],four[1000],four_2[1000],c[1000],c_2[1000];\n\n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < n; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < n; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int a[200],b[50],n,p;\n  bool c[1000000],d[1000000];\n  a[0]=0;\n  p=0;\n  j=0;\n  for(i=1;a[i-1]<1000000;i++){\n    p+=i;\n    a[i]=a[i-1]+p;\n    if(a[i]%2){\n      b[j]=a[i];\n      j++;\n    }\n  }\n  while(cin>>n&&n){\n    memset(c,0,n);\n    c[0]=1;\n    for(i=1;;i++){\n      memset(d,0,n);\n      for(j=0;j<n;j++){\n\tif(c[j]){\n\t  for(k=0;j+a[k]<n;k++)\n\t    d[j+a[k]]=1;\n\t  if(j+a[k]==n)\n\t    break;\n\t}\n      }\n      if(j!=n)\n\tbreak;\n      memcpy(c,d,n);\n    }\n    cout<<i<<\" \";\n    for(i=0;b[i+1]<=n;i++);\n    for(j=0;n;i--){\n      j+=n/b[i];\n      n-=n/b[i]*b[i];\n    }\n    cout<<j<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\n//const int INF = 1107110711071107;\n\nint dp[200][1000001];\nint dp_odd[40][1000001];\nint four[210];\nint x;\n\nsigned main() {\n  Rep(i, 210) four[i] = i * (i+1) * (i+2) / 6;\n  \n  memset(dp, 1e6+1, sizeof(dp));\n  Rep(i, 1000001) dp[1][i] = i;\n  Rrep(i, 2, 200) {\n    Rep(j, 1000001) {\n      dp[i][j] = min(dp[i][j], dp[i-1][j]);\n      if ( j+four[i] <= 1000000 ) {\n\tdp[i][j+four[i]] = min(dp[i][j+four[i]], dp[i][j]+1);\n      }\n    }\n  }\n\n  memset(dp_odd, 1e6+1, sizeof(dp_odd));\n  Rep(i, 1000001) dp_odd[1][i] = i;\n  Rrep(i, 2, 40) {\n    Rep(j, 1000001) {\n      dp_odd[i][j] = min(dp_odd[i][j], dp_odd[i-1][j]);\n      if ( j+four[(i-1)*4+1] <= 1000000 ) {\n\tdp_odd[i][j+four[(i-1)*4+1]] = min(dp_odd[i][j+four[(i-1)*4+1]], dp_odd[i][j]+1);\n      }\n    }\n  }\n \n  while ( cin >> x, x ) {\n    cout << dp[199][x] << \" \" << dp_odd[39][x] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1167\n#include<iostream>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int number;\n\nconst number NMAX = 1e6 + 8;\n\nint dp[NMAX], odp[NMAX];\n\nint main() {\n  REP(i, NMAX) {\n    dp[i] = odp[i] = i;\n  }\n  for (number i = 2; i * (i + 1) * (i + 2) / 6 < NMAX; i++) {\n    int tetr = i * (i + 1) * (i + 2) / 6;\n    int limit = min(NMAX, (i + 2) * (i + 3) * (i + 4) / 6 + 8);\n    for (number j = tetr; j < limit; j++) {\n      dp[j] = min(dp[j], dp[j - tetr] + 1);\n    }\n\n    if (tetr % 2 != 0) {\n      int limit = min(NMAX, NMAX);\n      for (number j = tetr; j < limit; j++) {\n        odp[j] = min(odp[j], odp[j -tetr] + 1);\n      }\n    }\n  }\n\n  int n;\n  while (cin >> n and n) {\n    cout << dp[n] << \" \" << odp[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int num[201],log[1000001],logo[1000001];\n  for(int i=1; i<200; i++){\n    num[i] = i*(i+1)*(i+2)/6;\n  }\n  for(int i= 0; i<1000001; i++){\n    log[i] = logo[i] = i;\n    for(int j=1; j<201; j++){\n      if(num[j]>i){break;}\n      if(log[i]>log[i-num[j]]){log[i] = log[i-num[j]]+1;}\n      if(num[j]%2){\n\tif(logo[i]>logo[i-num[j]]){logo[i] = logo[i-num[j]]+1;}\n      }\n    }\n  }\n  int n;\n  while(cin >>n,n){\n    cout <<log[n]<<\" \"<<logo[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    vector<int> dp(1000001, 1e9);\n    vector<int> dp2(1000001, 1e9);\n    dp[0] = dp2[0] = 0;\n    for(int i=1; i*(i+1)*(i+2)/6 <= 1000000; ++i) {\n        int l = i*(i+1)*(i+2)/6;\n        for(int j=0; j+l<=1000000; ++j) {\n            dp[j+l] = min(dp[j+l], dp[j] + 1);\n        }\n        if(l % 2 == 1) {\n            for(int j=0; j+l<=1000000; ++j) {\n                dp2[j+l] = min(dp2[j+l], dp2[j] + 1);\n            }\n        }\n    }\n\n\n    int n;\n    while(cin >> n, n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define trace1(a)                    cout<<#a<<\": \"<<a<<endl\n#define trace2(a,b)                  cout<<#a<<\": \"<<a<<\" | \", trace1(b)\n#define trace3(a,b,c)                cout<<#a<<\": \"<<a<<\" | \", trace2(b,c)\n#define trace4(a,b,c,d)              cout<<#a<<\": \"<<a<<\" | \", trace3(b,c,d)\n#define trace5(a,b,c,d,e)            cout<<#a<<\": \"<<a<<\" | \", trace4(b,c,d,e)\n#define trace6(a,b,c,d,e,f)          cout<<#a<<\": \"<<a<<\" | \", trace5(b,c,d,e,f)\n#define trace7(a,b,c,d,e,f,g)        cout<<#a<<\": \"<<a<<\" | \", trace6(b,c,d,e,f,g)\n#define trace8(a,b,c,d,e,f,g,h)      cout<<#a<<\": \"<<a<<\" | \", trace7(b,c,d,e,f,g,h)\n#define trace9(a,b,c,d,e,f,g,h,i)    cout<<#a<<\": \"<<a<<\" | \", trace8(b,c,d,e,f,g,h,i)\n#define trace10(a,b,c,d,e,f,g,h,i,j) cout<<#a<<\": \"<<a<<\" | \", trace9(b,c,d,e,f,g,h,i,j)\n#define rep(i,a,b)      for(int (i)=(int)(a);(i)<(int)(b); ++(i))\n#define reps(i,a,b,c)   for(int (i)=(int)(a);(i)<(int)(b); (i)+=(c))\n#define rrep(i,a,b)     for(int (i)=(int)(a);(i)>=(int)(b);--(i))\n#define rreps(i,a,b,c)  for(int (i)=(int)(a);(i)>=(int)(b);(i)-=(c))\n#define fore(x,a)       for(auto &x:a)\n#define foreach(i,a)    for(auto i=(a).begin(); i!=(a).end(); ++i)\n#define rforeach(i,a)   for(auto i=(a).rbegin();i!=(a).rend();++i)\n#define all(a)  (a).begin(), (a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define isin(i,a,b) ((a) <= (i) && (i) <= (b))\n#define uni(a) (a).erase(unique(all(a)),(a).end())\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(a) ((long long)(a).size())\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\nusing ll  = long long;          using vi  = vector<int>;\nusing ld  = long double;        using vl  = vector<ll>;\nusing unit= unsigned;           using vvi = vector<vi>;\nusing ull = unsigned long long; using vvl = vector<vl>;\nusing pii = pair<int,int>;      using vpii= vector<pii>;\nusing pil = pair<int,ll>;       using vpil= vector<pil>;\nusing pli = pair<ll,int>;       using vpli= vector<pli>;\nusing pll = pair<ll,ll>;        using vpll= vector<pll>;\nvoid _main(); int main(){ cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntemplate<class T>string join(const v(T)&v){ stringstream s; rep(i,0,sz(v))s<<' '<<v[i]; return s.str().substr(1); }\ntemplate<class T>istream &operator>>(istream&i, v(T)&v){ fore(x,v){ i >> v; } return i; }\ntemplate<class T>ostream &operator<<(ostream&o, const v(T)&v){ o<<\"[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const deque<T>&v){ o<<\"deq[\"; fore(x,v)o<<x<<\",\"; o<<\"]\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_set<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>ostream &operator<<(ostream&o, const unordered_multiset<T>&v){ o<<\"{\"; fore(x,v)o<<x<<\",\"; o<<\"}\"; return o; }\ntemplate<class T1,class T2>ostream &operator<<(ostream &o, const pair<T1,T2>&p){ o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class TK,class TV>ostream &operator<<(ostream &o, const unordered_map<TK,TV>&m){ o<<\"{\"; fore(x,m)o<<x.fi<<\"=>\"<<x.se<<\",\"; o<<\"}\"; return o; }\ntemplate<class T>void YES(T c){ if(c) cout<<\"YES\"<<endl; else cout<<\"NO\"<<endl; }\ntemplate<class T>void Yes(T c){ if(c) cout<<\"Yes\"<< endl; else cout<<\"No\"<<endl; }\ntemplate<class T>void POSS(T c){ if(c) cout<<\"POSSIBLE\"<<endl; else cout<<\"IMPOSSIBLE\"<<endl; }\ntemplate<class T>void Poss(T c){ if(c) cout<<\"Possible\"<<endl; else cout<<\"Impossible\"<<endl; }\ntemplate<class T>bool chmax(T &a,const T &b){ return a<b?(a=b,true):false; }\ntemplate<class T>bool chmin(T &a,const T &b){ return a>b?(a=b,true):false; }\ntemplate<class T>T gcd(T a,T b){ return b?gcd(b,a%b):a; }\ntemplate<class T>T lcm(T a,T b){ return a/gcd(a,b)*b; }\nconst double  EPS = 1e-10;\nconst double  PI  = acos(-1.0);\nconst int     INF = 1001002003;\nconst ll      LINF= 1001002003004005006LL;\nconst int DX[] = { -1, 0, 1, 0 , -1,-1, 1, 1 };\nconst int DY[] = {  0, 1, 0,-1 , -1, 1,-1, 1 };\n\nconstexpr int M = 1e6;\nconstexpr int n = 181;\n\nvoid _main() {\n  vi nums(n);\n  rep(i,1,n+1) nums[i-1] = i*(i+1)*(i+2)/6;\n  vi dpall(M+1,INF), dpodd(M+1,INF);\n  dpall[0] = dpodd[0] = 0;\n  rep(i,1,M) {\n    for (int j=0; nums[j]<=i; ++j) {\n      chmin(dpall[i], dpall[i-nums[j]]+1);\n      if (nums[j]&1) chmin(dpodd[i], dpodd[i-nums[j]]+1);\n    }\n  }\n  vpii ans;\n  while (true) {\n    int x;\n    cin >> x;\n    if (x == 0) break;\n    ans.eb(dpall[x],dpodd[x]);\n  }\n  fore(x,ans) cout << x.fi << \" \" << x.se << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint dp[1000001] , dp2[1000001];\n\nvector<int> item;\n\nint main(){\n\tint n;\n\tfor(int i = 1 ; i * (i+1) * (i+2) / 6 <= 1000000 ; i++) item.push_back(i * (i+1) * (i+2) / 6);\n\trep(i,1000001) dp[i] = 9999;\n\trep(i,1000001) dp2[i]= 9999;\n\tdp[0] = dp2[0] = 0;\n\n\tfor(int i = 0 ; i <= 1000000 ; i++){\n\t\tfor(int j = 0 ; j < item.size() && item[j]+i <= 1000000 ; j++){\n\t\t\tdp[i + item[j]] = min(dp[i + item[j]] , dp[i] + 1);\n\t\t}\n\t}\n\tfor(int i = 0 ; i <= 1000000 ; i++){\n\t\tfor(int j = 0 ; j < item.size() && item[j]+i <= 1000000 ; j++){\n\t\t\tif(item[j] % 2) dp2[i + item[j]] = min(dp2[i + item[j]] , dp2[i] + 1);\n\t\t}\n\t}\n\t\n\twhile(cin >> n && n){\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint dp[2][1000010], adp[2][1000010];\nint INF = 1e9;\n\nvoid solve() {\n\tfor (int i=0; i<2; i++) {\n\t\tfill(dp[i], dp[i]+1000010, INF);\n\t\tfill(adp[i], adp[i]+1000010, INF);\n\t}\n\t\n\tdp[0][0] = 0;\n\tadp[0][0] = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint nw = i%2, nx = (i+1)%2;\n\t\tint add = i * (i+1) * (i+2) / 6;\n\t\tif (add > n) break;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (add <= j) {\n\t\t\t\tdp[nx][j] = min(dp[nw][j], dp[nx][j-add] + 1);\n\t\t\t} else {\n\t\t\t\tdp[nx][j] = dp[nw][j];\n\t\t\t}\n\t\t\t\n\t\t\tif (add%2==0) {\n\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t} else {\n\t\t\t\tif (add <= j) {\n\t\t\t\t\tadp[nx][j] = min(adp[nw][j], adp[nx][j-add] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = INF, ans2 = INF;\n\tfor (int i=0; i<2; i++) {\n\t\tans1 = min(ans1, dp[i][n]);\n\t\tans2 = min(ans2, adp[i][n]);\n\t}\n\tcout << ans1 << \" \" << ans2 << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define  M 1e6\nusing namespace std;\ntypedef long long int ll;\nvector<ll> x,y;\nll f(int n){\n\treturn n*(n+1)*(n+2)/6;\n}\nvoid make(void){\n\tint i=1;\nwhile(f(i)<M){\nx.push_back(f(i));\nif(f(i)%2==1){\n\ty.push_back(f(i));\n}\n\ti++;\n}\n}\nint main(void){\n\tmake();\nvector<ll> num(M,6),num2(M,1000000);\nfor(ll i=0;i<x.size();i++){\nnum[x[i]]=1;\n}\nfor(ll i=0;i<y.size();i++){\n\tnum2[y[i]]=1;\n}\nfor(ll i=0;i<x.size();i++){\n\tfor(ll j=x[i];j<M;j++){\n\t\tnum[j]=min(num[j],num[j-x[i]]+1);\n\t}\n}\nfor(ll i=0;i<y.size();i++){\n\tfor(ll j=y[i];j<M;j++){\n\t\tnum2[j]=min(num2[j],num2[j-y[i]]+1);\n\t}\n}\nint n;\n\nwhile(1){\n\tcin>>n;\n\tif(n==0)break;\n\n\tcout<<num[n]<<\" \"<<num2[n]<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nvector<int> pol;\nvector<int> pol_odd;\nint dp1[1000100],dp2[1000100];\nint main()\n{\n\tfor(int i=0;i<=1000000;i++)dp1[i]=dp2[i]=INF;\n\tdp1[0]=dp2[0]=0;\n\tfor(int i=1;;i++)\n\t{\n\t\tint k=i*(i+1)*(i+2)/6;\n\t\tif(k>1000000)break;\n\t\tpol.pb(k);\n\t\tif(k%2)pol_odd.pb(k);\n\t}\n\tfor(int i=0;i<=1000000;i++)\n\t{\n\t\tfor(int j=0;j<pol.size();j++)\n\t\t{\n\t\t\tif(i<pol[j])break;\n\t\t\tdp1[i]=min(dp1[i],dp1[i-pol[j]]+1);\n\t\t}\n\t}\n\tfor(int i=0;i<=1000000;i++)\n\t{\n\t\tfor(int j=0;j<pol_odd.size();j++)\n\t\t{\n\t\t\tif(i<pol_odd[j])break;\n\t\t\tdp2[i]=min(dp2[i],dp2[i-pol_odd[j]]+1);\n\t\t}\n\t}\n\tcout << \"preculc finished\" << endl;\n\twhile(1)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e8;\n\nsigned\nmain(){\n\tint n;\n\tvector<int> odd, four;\n\tfor(int i=1;i*(i+1)*(i+2)<=6*1e6;i++)\n\t{\n\t\t\tint tmp = i*(i+1)*(i+2)/ 6;\n\t\t\tif(tmp %2 == 1) odd.push_back(tmp);\n\t\t\tfour.push_back(tmp);\n\t}\n\n\t//初期化\n\tvector<int> dp(1e6+5, MAX), dp_odd(1e6+5, MAX);\n\tdp[0] = 0;\n\n\tfor(int i=1;i<=1e6;i++)\n\t{\n\t\t\tfor(int j=0;j<four.size() and four[j]<=i;j++)\n\t\t\t{\n\t\t\t\t\tdp[i] = min(dp[i], dp[i-four[j]]+1);\n\t\t\t}\n\t}\n\n\tdp_odd[0] = 0;\n\n\tfor(int i=1;i<=1e6;i++)\n\t{\n\t\t\tfor(int j=0;j<odd.size() and odd[j]<=i;j++)\n\t\t\t{\n\t\t\t\t\tdp_odd[i] = min(dp_odd[i], dp_odd[i-odd[j]]+1);\n\t\t\t}\n\t}\n\n\twhile(cin >> n && n!=0)\n\t{\n\t\t\tcout << dp[n] << \" \" << dp_odd[n] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint main(){\n\tint ans[1000000];\n\tint bns[1000000];\n\tfor(int i=0;i<1000000;i++){\n\t\tif(i==0){\n\t\t\tans[i] = 0;\n\t\t\tbns[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tans[i] = INF;\n\t\tbns[i] = INF;\n\t\tfor(int j=0;i-j*(j+1)*(j+2)/6>=0&&j<200;j++){\n\t\t\tans[i] = min(ans[i],ans[i-j*(j+1)*(j+2)/6]+1);\n\t\t\tif(j*(j+1)*(j+2)/6%2==1) bns[i] = min(bns[i],bns[i-j*(j+1)*(j+2)/6]+1);\n\t\t}\n\t}\n\twhile(true){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\telse printf(\"%d %d\\n\",ans[n],bns[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n#define ALL(v) (v).begin(), (v).end()\n#define coutd(n) cout << fixed << setprecision(n)\n#define ll long long int\n#define vl vector<ll>\n#define vi vector<int>\n\nusing namespace std;\n\nint limit = 1e6;\n\nint memo(const int cur, vi &dp, const vi &list) {\n  if (dp[cur] != limit)\n    return dp[cur];\n  for (const auto li : list) {\n    if (cur - li >= 0) {\n      dp[cur] = min(dp[cur], memo(cur - li, dp, list) + 1);\n    }\n  }\n  return dp[cur];\n}\n\nint main() {\n  vi list, oddList;\n  for (int i = 1; i * (i + 1) * (i + 2) / 6 < limit; i++) {\n    int num = i * (i + 1) * (i + 2) / 6;\n    list.push_back(num);\n    if (num % 2 == 1)\n      oddList.push_back(num);\n  }\n\n  vi dp(1e6, limit), dpOdd(1e6, limit);\n  dp[0] = dpOdd[0] = 0;\n  FOR(i, 1, 1e6) {\n    memo(i, dp, list);\n    memo(i, dpOdd, oddList);\n  }\n\n  while (true) {\n    int k;\n    cin >> k;\n    if (k == 0)\n      break;\n    cout << dp[k] << \" \" << dpOdd[k] << \"\\n\";\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Pollok's conjecture\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 1000000\ntypedef long long ll;\nvector<ll> v1;\nvector<ll> v2;\nll num1[1000001], num2[1000001];\n\nint main(){\n  ll tmp;\n  for(ll i=1; (tmp=(i*(i+1)*(i+2)/6))<1000000; i++){\n      v1.push_back(tmp);\n      if(tmp%2==1)\n\tv2.push_back(tmp);\n    }\n\n  for(ll i=0; i<=1000000; i++){num1[i]=i; num2[i]=i;}\n  for(ll i=1; i<v1.size(); i++){\n    for(ll j=0; j<=1000000; j++){\n      if(v1[i]<=j)num1[j]=min(num1[j], num1[j-v1[i]]+1);\n    }\n  }\n  for(ll i=1; i<v2.size(); i++){\n    for(ll j=0; j<=1000000; j++){\n      if(v2[i]<=j)num2[j]=min(num2[j], num2[j-v2[i]]+1);\n    }\n  }\n  ll n;\n  while(cin>>n, !(n==0)){\n    cout<<num1[n]<<\" \"<<num2[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint x,y;\nint m[1000005]={};\nint memo[1000005]={};\nint memo2[1000005]={};\nvector<int> odd;\nvoid saiki(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << \":\" << x << endl;\n  if(n==0) {\n    //cout << x << d << endl;\n    x=min(x,d);\n  }else if(n>0) {\n    if(memo[n]>0){\n      x=min(x,memo[n]+d);\n    }else{\n      for(i=1;m[i]<=n;i++);\n      i--;\n      int b=x;\n      for(j=i;j>0;j--){\n\tif(x>d+1)\n\t  saiki(n-m[j],d+1);\n      }\n      if(x<b)\n\tmemo[n]=x-d;\n\t\n      //cout << n << \":\" << memo[n]<< endl;\n    }\n  }\n}\nvoid saiki2(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << endl;\n  if(n==0) {\n    y=min(y,d);\n  }else if(n>0) {\n    if(memo2[n]>0){\n      y=min(y,memo2[n]+d);\n    }else{\n      for(i=0;odd[i]<=n;i++);\n      i--;\n      int b=y;\n      //cout << i << \":\" << n << \":\" << odd[i] << endl;\n      for(j=i;j>=0;j--){\n\tif(y>d+1){\n\t  saiki2(n-odd[j],d+1);\n\t}\n      }\n      if(y<b)\n\tmemo2[n]=y-d;\n    }\n  }\n}\nint main(){\n  int i,j,k;\n  fill(memo,memo+1000005,-1);\n  fill(memo2,memo2+1000005,-1);\n  for(i=1;i<1000005;i++) {\n    m[i]=i*(i+1)*(i+2)/6;\n    if(m[i]%2==1) odd.push_back(m[i]);\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    x=1<<10;y=x;\n    saiki(n,0);saiki2(n,0);\n    cout << x << \" \" <<  y << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_NUM = 1000000;\nconst int INF = 100000000;\n\nint table[2][MAX_NUM];\nint tet[2][1000];\n\nint calc(int num,int m)\n{\n    if(table[m][num]!=INF) {\n        return table[m][num];\n    } else {\n        for(int i=1; tet[m][i]<num; i++) {\n            table[m][num]=min(table[m][num],calc(num-tet[m][i],m)+1);\n        }\n        return table[m][num];\n    }\n}\n\nint main()\n{\n    for(int i=0; i<MAX_NUM; i++) {\n        table[0][i] = INF;\n        table[1][i] = INF;\n    }\n\n    for(int i=1; i*(i+1)*(i+2)/6<MAX_NUM; i++) {\n        int t=i*(i+1)*(i+2)/6;\n        table[0][t] = 1;\n        tet[0][i] = t;\n\n        if(t%2 == 1) {\n            table[1][t] = 1;\n            tet[1][i] = t;\n        }\n    }\n\n    int in;\n    while(cin>>in && in!=0) {\n        cout<<calc(in,0)<<\" \"<<calc(in,1)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\nusing pci = pair<char, int>;\nusing vpci = vector<pci>;\n#define out(S) cout<<(S)<<endl;\n#define REP(i,b) for(int i=0;i<(b);i++)\n#define rREP(i,b) for(int i=(b)-1;i>=0;i--)\n#define FOR(i,a,b) for(size_t i=(a);i<(b);i++)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define Foreach(item,collection) for(auto item:collection)\n#define mod(i) ((i) % (ll)(1e9 + 7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a * modpow((ll)b,(ll)(1e9 + 5))))\n#define Yes out(\"Yes\")\n#define No out(\"No\")\n#define NO out(\"NO\")\n#define YES out(\"YES\")\n#define INF 1e10;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define IfOut(condition,text) if((condition)){out(text);return 0;}\n#define IfeOut(condition,itext,etext) if(condition){out(itext);return 0;}else{out(etext);return 0;}\n#define Select(collection,condition,result) Foreach(i,collection){result+=condition;}\n#define GetAuto(_N,vect) {cin>>_N;vect.resize(_N);REP(i,_N){cin>>vect[i];}}\n#define beginend(vec) (vec).begin(),(vec).end()\n#define pb(item) push_back(item)\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) { ll prime; double sqrtmax = sqrt(max); vector<ll> primeVec, searchVec; FOR(i, 2, max + 1) searchVec.push_back(i); do { prime = searchVec[0]; primeVec.push_back(prime); auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; }); searchVec.erase(itr, searchVec.end()); } while (prime < sqrtmax); primeVec.reserve(primeVec.size() + searchVec.size()); primeVec.insert(primeVec.end(), beginend(searchVec)); return primeVec; }\nbool isPrime(ll x) { if (x == 2) return true; if (x < 2 || x % 2 == 0) return false; ll i = 3; while (i <= sqrt(x)) { if (x%i == 0) return false; i += 2; }return true; }\n\n\nvi dp, odddp;\nint main() {\n\tint N;\n\tint p = 4;\n\tREP(i, 1000001) {\n\t\tdp.pb(i);\n\t\todddp.pb(i);\n\t}\n\tint n = 3;\n\twhile (p<=1000000)\n\t{\n\t\tfor (int i = 0; i+p <=1000000; i++)\n\t\t{\n\t\t\tdp[i + p] = min(dp[i + p], dp[i] + 1);\n\t\t}\n\t\tif (p % 2 == 1) {\n\t\t\tfor (int i = 0; i + p <= 1000000; i++)\n\t\t\t{\n\t\t\t\todddp[i + p] = min(odddp[i + p], odddp[i] + 1);\n\t\t\t}\n\t\t}\n\n\t\tp = n*(n + 1)*(n + 2) / 6;\n\t\tn++;\n\t}\n\n\t\n\n\twhile (cin>>N,N)\n\t{\n\t\tcout << dp[N] << \" \" << odddp[N] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dp[2][1000010];\nint data[1000010];\nint main(){\n\tint index=1;\n\twhile(index*(index+1)*(index+2)/6 < 10000000){\n\t\tdata[index-1] = index*(index+1)*(index+2)/6;\n\t\tindex++;\n\t}\n\tfill(dp[0],dp[0]+1000000,INF);\n\tfill(dp[1],dp[1]+1000000,INF);\n\tdp[0][0] = dp[1][0] = 0;\n\trep(i,1000000){\n\t\trep(j,index){\n\t\t\tif(i+data[j] < 1000000){\n\t\t\t\tdp[0][i+data[j]] = min(dp[0][i+data[j]],dp[0][i]+1);\n\t\t\t\tif(data[j] % 2 == 1){\n\t\t\t\t\tdp[1][i+data[j]] = min(dp[1][i+data[j]],dp[1][i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\n\twhile(scanf(\"%d\",&N),N){\n\t\tprintf(\"%d %d\\n\",dp[0][N],dp[1][N]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint num[100010];\n\tfor(int i=0; i< 100010; i++) num[i] = 10e8;\n\tnum[0] = 0;\n\tfor(int j=0; j< 100010; j++){\n\t\tfor(int i=1; i < 1000; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(10010 <= i*(i+1)*(i+2)/6+j) continue;\n\t\t\tnum[j+m] = min(num[j]+1, num[j+m]);\n\t\t}\n\t}\n\tint num2[100010];\n\tfor(int i=0; i< 100010; i++) num2[i] = 10e8;\n\tnum2[0] = 0;\n\tfor(int j=0; j< 100010; j++){\n\t\tfor(int i=1; i < 1010; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(m == 0) continue;\n\t\t\tif(m%2 == 0) continue;\n\t\t\tif(10010 <= i*(i+1)*(i+2)/6+j) continue;\n\t\t\tnum2[j+m] = min(num2[j]+1, num2[j+m]);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << num[n] << \" \" << num2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF INT_MAX/3\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define debug(x) cout<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cout<<#x\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nvi num;\nvi num_odd;\nint N;\nint N_odd;\nint dp[1000001];\nint dpdp[1000001];\n\nvoid init(){\n    int t=1;\n    int i=1;\n    while(t<1000000){\n        num.EB(t);\n        i++;\n        t = i*(i+1)*(i+2)/6;\n    }\n    N = num.size();\n\n    for(i=0;i<N;i++){\n        if(num[i]%2==1) num_odd.emplace_back(num[i]);\n    }\n    N_odd = num_odd.size();\n}\n\nvoid solve(int n){\n    for(int i=0;i<=n;i++) dp[i] = INF,dpdp[i]= INF;\n    dp[0]=0;\n    for(int i=0;i<N;i++){\n        for(int j=num[i];j<=n;j++){\n            dp[j] = min(dp[j],dp[j-num[i]]+1);\n        }\n    }\n\n\n    dpdp[0] = 0;\n    for(int i=0;i<N_odd;i++){\n        for(int j=num_odd[i];j<=n;j++){\n            dpdp[j] = min(dpdp[j],dpdp[j-num_odd[i]]+1);\n        }\n    }\n}\n\nint main(){\n    init();\n    int n;\n\n    for(int i=0;i<1000001;i++) dp[i] = INF,dpdp[i]= INF;\n    dp[0] = 0;\n    dpdp[0] = 0;\n\n    solve(1000000);\n\n    while(cin>>n){\n        if(n==0) break;\n        cout << dp[n] << \" \" << dpdp[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n;\n\tint i1,i2;\n\tint nn;\n\tint p;\n\tint min;\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\n\t\tvector<int> pollock(n+1,0);\n\t\tvector<int> pollock2(n+1,0);\n\t\tvector<int> p;\n\t\tvector<int> p2;\n\t\tnn=1;\n\n\t\tfor(i1=1;i1<=n;i1++){\t\t\t\n\n\t\t\tif(i1==(nn*(nn+1)*(nn+2))/6  && i1%2==1){\n\t\t\t\tp.push_back(i1);\n\t\t\t\tp2.push_back(i1);\n\t\t\t\tnn++;\n\t\t\t\tpollock[i1]=1;\n\t\t\t\tpollock2[i1]=1;\n\t\t\t}\n\t\t\telse if(i1==(nn*(nn+1)*(nn+2))/6){\n\t\t\t\tnn++;\n\t\t\t\tp.push_back(i1);\n\t\t\t\tpollock[i1]=1;\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock2[i1]=min+1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p.size();i2++){\n\t\t\t\t\tif((pollock[i1-p[i2]])<min){\n\t\t\t\t\t\tmin=pollock[i1-p[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock[i1]=min+1;\n\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock2[i1]=min+1;\n\t\t\t}\n\t\t\t//cout<<pollock[i1]<<\" \";\n\n\t\t}\n\n\t\tcout << pollock[n] << \" \" << pollock2[n] << endl;\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint p(int i){\n  return i * (i + 1) * (i + 2) / 6;\n}\n\n\nint main(void){\n\n  int n = 100000;\n\n      /* ???????¨??????? */\n      int ans1[n+1];\n      int ans2[n+1];\n      for(int i = 1 ; i < n + 1 ; i++){\n        ans1[i+1] = -1;\n        ans2[i+1] = -1;\n      }\n\n      for(int i = 1 ; p(i) < n + 1 ; i++){\n        ans1[p(i)] = 1;\n        if(p(i) % 2 == 1){ ans2[p(i)] = 1; }\n      }\n\n      for(int i = 2 ; i <= n ; i++){\n        if(ans1[i] == 1){\n        }else{\n          int min = 100000;\n          for(int j = 1 ; j < i ; j++){\n            if(ans1[j] + ans1[i - j] < min){\n              min = ans1[j] + ans1[i - j];\n            }\n          }\n          ans1[i] = min;\n        }\n      }\n\n      for(int i = 2 ; i <= n ; i++){\n        if(ans2[i] == 1){\n        }else{\n          int min = 100000;\n          for(int j = 1 ; j < i ; j++){\n            if(ans2[j] + ans2[i - j] < min){\n              min = ans2[j] + ans2[i - j];\n            }\n          }\n          ans2[i] = min;\n        }\n      }\n\n\n\n  while(1){\n    cin >> n;\n    if(n == 0){return 0;}\n\n    cout << ans1[n] << \" \" << ans2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_NUM = 1000000;\nconst int INF = 1000000000;\n\nint table[2][MAX_NUM];\nint tet[2][1000];\n\nint calc(int num,int m)\n{\n    if(table[m][num]!=INF) {\n        return table[m][num];\n    } else {\n        for(int i=1; tet[m][i]<=num; i++) {\n            table[m][num]=min(table[m][num],calc(num-tet[m][i],m)+1);\n        }\n        return table[m][num];\n    }\n}\n\nint main()\n{\n    for(int i=0; i<MAX_NUM; i++) {\n        table[0][i] = INF;\n        table[1][i] = INF;\n    }\n\n    for(int i=1; i*(i+1)*(i+2)/6<MAX_NUM; i++) {\n        int t=i*(i+1)*(i+2)/6;\n        table[0][t] = 1;\n        tet[0][i] = t;\n\n        if(t%2 == 1) {\n            table[1][t] = 1;\n            tet[1][i] = t;\n        }\n    }\n\n    int in;\n    while(cin>>in && in!=0) {\n        cout<<calc(in,0)<<\" \"<<calc(in,1)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;a[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++)for(k=a[j];k<=1000000;k++){\n    if(a[j]>b[k+1])break;\n    b[k]=min(b[k],b[k-a[j]]+1);\n    if(a[j]%2)c[k]=min(c[k],c[k-a[j]]+1);\n  }\nwhile(cin>>n,n)cout<<b[n]<<' '<<c[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint d[182] = {} ;\nint D[182] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<182 ; i++ ){\n\t\td[i] = d[i-1] + i ;\n\t\tD[i] = D[i-1] + d[i] ;\n\t}\n}\n\nint cal_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( dp_map[0][x] != 0 ) return dp_map[0][x] ;\n\t\telse return x/D[c] + cal_2( x%D[c] , c-1 ) ;\n\t}\n}\n\nint cal( int m , int q ){\n\tint ans = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans = min( ans , cal_2( m , j ) ) ;\n\t}\n\treturn ans ;\n}\n\nint cal_odd_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( D[c]%2 == 0 ) return cal_odd_2( x , c-1 ) ;\n\t\telse{\n\t\t\tif( dp_map[1][x] != 0 ) return dp_map[1][x] ;\n\t\t\telse return x/D[c] + cal_odd_2( x%D[c] , c-1 ) ;\n\t\t}\n\t}\n}\n\nint cal_odd( int m , int q ){\n\tint ans_2 = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans_2 = min( ans_2 , cal_odd_2( m , j ) ) ;\n\t}\n\treturn ans_2 ;\n}\n\nvoid dp(){\n\tint p = 1 ;\n\tfor( int i=1 ; i<=1000000 ; i++ ){\n\t\tif( i < 182 && i >= D[p] ) p++ ;\n\t\tdp_map[0][i] = cal(i,p) ;\n\t\tdp_map[1][i] = cal_odd(i,p) ;\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 30;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define debug(x) cerr << #x << \": \" << x << endl;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nll dp[1100000], dpo[1100000];\n\nint main() {\n\n    rep(i, 1100000) dp[i] = INF, dpo[i] = INF;\n    dp[0] = 0, dpo[0] = 0;\n\n    rep(i, 1100000-1) {\n        for(ll j = 1; j * (j+1) * (j+2) / 6 <= 1e6; j++) {\n            ll x = j * (j+1) * (j+2) / 6;\n            if(i >= x) {\n                chmin(dp[i], dp[i - x] + 1);\n                if(x % 2 == 1) chmin(dpo[i], dpo[i - x] + 1);\n            }\n        }\n    }\n\n    ll n;\n    while(cin >> n) {\n        if (!n) return 0;\n\n        cout << dp[n] << \" \" << dpo[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i,a,n) for(ll i=a;i<(ll)(n);i++)\n\nint main(){\n    int dp[1000001];\n    int odp[1000001];\n    rep(i, 1000001){\n        dp[i] = odp[i] = i;\n    }\n\n    for(int n=3, p=4; p<=1000000; n++){\n        for(ll i=0; i+p<=1000000; i++){\n            dp[i+p] = min(dp[i+p], dp[i]+1);\n        }\n\n        if(p%2 == 1){\n            for(int i = 0; i+p <= 1000000; i++){\n                odp[i+p] = min(odp[i+p], odp[i] + 1);\n            }\n        }\n\n        p = n*(n+1)*(n+2)/6;\n    }\n    while(true){\n        ll n; cin>>n;\n        if(n == 0) break;\n        cout << dp[n] << \" \" << odp[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define N 1000000\n\nusing namespace std;\n\nint min(int a,int b){\n\tif(a>=b)return b;\n\telse return a;\n}\n\nint main(){\n\n\n\tint *data;\n\tint *data2;\n\tdata = new int[N];\n\tdata2= new int[N];\n\tint *square;\n\tint squareLength=0;\n\n\tint *square2;\n\tint square2Length=0;\n\n\tsquare = new int[N];\n\tsquare2= new int[N];\n\n\tfor(int i=0;i<N;i++){\n\t\tdata[i]=N;\n\t\tdata2[i]=N;\n\t}\n\n\tfor(int i=1;i*(i+1)*(i+2)/6 <=N;i++){\n\t\tdata[i*(i+1)*(i+2)/6]=1;\n\t\tsquare[squareLength]=i*(i+1)*(i+2)/6;\n\t\tsquareLength++;\n\t\tif((i*(i+1)*(i+2)/6 %2)==1){\n\t\t\tdata2[i*(i+1)*(i+2)/6]=1;\n\t\t\tsquare2[square2Length]=i*(i+1)*(i+2)/6;\n\t\t\tsquare2Length++;\n\t\t}\n\t}\n\n/*\n\tfor(int i=0;i<squareLength;i++){\n\t\tcout<<square[i]<<endl;\n\t}\n*/\n\tfor(int i=1;i<N;i++){\n\t\tfor(int j=0;j<squareLength;j++){\n\t\t\tif(i-square[j]<0)continue;\n\t\t\tdata[i] = min(data[i],data[i-square[j]]+1);\n\t\t}\n\t\tfor(int j=0;j<square2Length;j++){\n\t\t\tif(i-square2[j]<0)continue;\n\t\t\tdata2[i] = min(data2[i],data2[i-square2[j]]+1);\n\t\t}\n\t}\n\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\n\t\tcout<<data[n]<<\" \"<<data2[n]<<endl;\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\n\n#define MAX 1000000\n\nint dp1[MAX+1], dp2[MAX+1];\nint tetraNum[200];\n\nint main(void)\n{\n    \n    rep(i, 200) {\n        tetraNum[i] = i*(i+1)*(i+2)/6;\n    }\n\n    rep(i, MAX+1) dp1[i] = dp2[i] = i;\n\n    rep(i, MAX + 1) {\n        rep(j, 200) {\n            if(i + tetraNum[j] <= MAX) dp1[i + tetraNum[j]] = min(dp1[i + tetraNum[j]], dp1[i] + 1);\n            if(tetraNum[j]%2 && i + tetraNum[j] <= MAX) dp2[i + tetraNum[j]] = min(dp2[i + tetraNum[j]], dp2[i] + 1);\n        }\n    }\n\n    while(1) {\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    int lower,size,rest;\n    State(int lower,int size,int rest) : lower(lower),size(size),rest(rest) {};\n};\n\nint main(){\n    vector<int> v;\n    vector<int> odd;\n    for(int i=1;;i++){\n        int c = i*(i+1)*(i+2)/6;\n        if(c > 1000000) break;\n        v.push_back(c);\n        if(c % 2 == 1) odd.push_back(c);\n    }\n    int M = 1000010;\n    vector<int> answer(M,1 << 30);\n    vector<int> answer_odd(M,1 << 30);\n    answer[0] = 0;\n    answer_odd[0] = 0;\n    for(int i=0;i<M;i++){\n        int nex;\n        for(int j=0;j<v.size() && (nex=i+v[j]) < M;j++){\n            answer[nex] = min(answer[i] + 1,answer[nex]);\n        }\n        for(int j=0;j<odd.size() && (nex=i+odd[j]) < M;j++){\n            answer_odd[nex] = min(answer_odd[i] + 1,answer_odd[nex]);\n        }\n    }\n\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        cout << answer[n] << \" \" << answer_odd[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    for(int i=1;i<=x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)\n\tbreak;\n      count++;\n      if(tmp%2==1)\n\tcount_ki++;\n    }\n\n    int coin[count];\n    int coin_ki[count_ki];\n    int tmp2=0;\n  \n    for(int i=1;i<count+1;i++){\n      coin[i-1]=i*(i+1)*(i+2)/6;\n      if(coin[i-1]%2==1)\n\tcoin_ki[tmp2++]=coin[i-1];\n    }\n  \n    //printf(\"%d\\n\",count_ki);\n\n    /*for(int i=0;i<count_ki;i++){\n      printf(\"coin[%d]=%d\\n\",i,coin_ki[i]);\n      }*/\n\n    int dp[x+1];\n    fill(dp,dp + x + 1,100000);\n  \n\n    /*for(int i=0;i<=x;i++)\n      printf(\"dp[%d]=%d\\n\",i,dp[i]);\n    */\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,i,j,k,t=0,a[250]={},b[200]={},c[1000005]={2000000},d[1000005]={2000000};\n  for(i=1;i<250;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(a[i-1]%2==1)b[t++]=a[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<250;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<b[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <list>\n#include <set>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\nusing namespace std;\n#define REP(n) for(int i=0;i<n;i++)\n#define N 1000001\n#define POL 180\nint pol[POL];\nint pol2[POL];\nint dp1[N];\nint dp2[N];\nint num;\n\nvoid solve1() {\n    REP(N) dp1[i] = N;\n    dp1[0] = 0;\n    REP(5) {\n        for(int k=0;k<N;k++) {\n            if(dp1[k] == i) {\n                for(int j=0;j<POL;j++) \n                    if(k+pol[j] <=N)\n                        dp1[k+pol[j] ] = min(dp1[k+pol[j]],dp1[k]+1);\n            }\n        }\n    }\n}\n\nint solve2(int n) {\n    REP(N) dp2[i] = N;\n    dp2[0] = 0;\n    for(int cnt =0;;cnt++){\n        for(int i=0;i<N;i++) {\n            if(dp2[i] == cnt) {\n//                cout << i << \" \"  << \" \" << dp2[i] << endl;\n                for(int j=0;j<num;j++) {\n                if(i+pol2[j] <= N) {\n                dp2[i+pol2[j] ] = min(dp2[i+pol2[j]],dp2[i]+1);\n                if(i+pol2[j] == n) return dp2[i+pol2[j]];\n                }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    num = 0;\n    REP(POL){\n        pol[i] = (i+1)*(i+2)*(i+3)/6;\n        if(pol[i]%2 == 1) pol2[num++] = pol[i];\n    }\n    solve1();\n//    REP(30) cout << dp1[i];\n    int q;\n    while(cin >> q && q) {\n        cout << dp1[q] << \" \" << solve2(q) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) (X).begin(),(X).end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\n#define MAXINT 1000001\nvi d,d2;\nint main(){\n\tint t = 1;\n\twhile(1){\n\t\tint tmp = t*(t+1)*(t+2)/6;\n\t\tif(tmp>MAXINT) break;\n\t\td.pb(tmp);\n\t\tif(tmp%2==1) d2.pb(tmp);\n\t\tt++;\n\t}\n\n\tint dp[MAXINT];\n\tint dp2[MAXINT];\n\tREP(i,MAXINT){\n\t\tdp[i] = 500; dp2[i] = 500;\n\t}\n\tREP(i,d.size()) dp[d[i]] = 1;\n\tREP(i,d2.size()) dp2[d2[i]] = 1;\n\tREP(i,MAXINT){\n\t\tREP(k,d.size()){\n\t\t\tif(i+d[k]>=MAXINT) continue;\n\t\t\tdp[i+d[k]] = min(dp[i+d[k]],dp[i]+1);\n\t\t}\n\t}\n\tREP(i,MAXINT){\n\t\tREP(k,d2.size()){\n\t\t\tif(i+d2[k]>=MAXINT) break;\n\t\t\tdp2[i+d2[k]] = min(dp2[i+d2[k]],dp2[i]+1);\n\t\t}\n\t}\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint dp[2][1000010], adp[2][1000010];\nint INF = 1e9;\nint add[200], oadd[200];\n\nvoid solve() {\n\tfor (int i=0; i<2; i++) {\n\t\tfill(dp[i], dp[i]+1000010, INF);\n\t\tfill(adp[i], adp[i]+1000010, INF);\n\t}\n\t\n\tdp[0][0] = 0;\n\t//adp[0][0] = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint nw = i%2, nx = (i+1)%2;\n\t\tif (add[i] > n) break;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (add[i] <= j) {\n\t\t\t\tdp[nx][j] = min(dp[nw][j], dp[nx][j-add[i]] + 1);\n\t\t\t} else {\n\t\t\t\tdp[nx][j] = dp[nw][j];\n\t\t\t}\n\t\t\t/*\n\t\t\tif (add%2==0) {\n\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t} else {\n\t\t\t\tif (add <= j) {\n\t\t\t\t\tadp[nx][j] = min(adp[nw][j], adp[nx][j-add] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\t\n\tadp[0][0] = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint nw = i % 2, nx = (i+1)%2;\n\t\tif (oadd[i]%2 == 0) continue;\n\t\tif (oadd[i] > n) break;\n\t\t\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (oadd[i] <= j) {\n\t\t\t\tadp[nx][j] = min(adp[nw][j], adp[nx][j-oadd[i]] + 1);\n\t\t\t} else {\n\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = INF, ans2 = INF;\n\tfor (int i=0; i<2; i++) {\n\t\tans1 = min(ans1, dp[i][n]);\n\t\tans2 = min(ans2, adp[i][n]);\n\t}\n\tcout << ans1 << \" \" << ans2 << endl;\n}\n\nint main() {\n\tint p = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tadd[i] = i * (i+1) * (i+2) / 6;\n\t\tif (add[i] % 2 == 1) oadd[p++] = add[i];\n\t}\n\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  const int N = 1000000;\n  int dp1[N+1], dp2[N+1], n;\n  \n  for(int i=0;i<=N;i++)dp1[i] = dp2[i] = N;\n  dp1[0] = dp2[0] = 0;\n  \n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      dp1[nxt] = min(dp1[nxt],dp1[j] + 1);\n      if(val&1)dp2[nxt] = min(dp2[nxt],dp2[j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  while(cin>>n,n)cout << dp1[n] << \" \" << dp2[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(ll i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(ll i=(a),i##_cond=(b);i<i##_cond;++i)\n#define ROF(i,a,b) for(ll i=(a)-1,i##_cond=(b);i>=i##_cond;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define UNIQUE(v) v.erase(unique(all(v)),v.end())\n#define SUM(a) accumulate(all(a),0)\n#define sz(x) ((ll)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<ll,ll> pii;\n\nconst ll inf = 1ll<<62;\nconst ll mod = 1e9+7;\n\n#define n 1000000\n\nint main(){\n#define int ll\n  int tmp = 1;\n  vi a, b;\n  while(1){\n    int x = tmp * (tmp + 1) * (tmp + 2) / 6;\n    if(x >= 1000000) break;\n    a.pb(x);\n    if(x & 1) b.pb(x);\n    tmp++;\n  }\n  dump(a,b);\n  \n  vi dpa(n+1,inf),dpb(n+1,inf);\n  dpa[0] = 0;\n  dpb[0] = 0;\n  rep(i,n){\n    for(int j = 0; a[j] <= i + 1; ++j)\n      for(int k = 1; a[j] * k <=  i + 1; ++k)\n\tdpa[i+1] = min(dpa[i+1], dpa[i + 1 - k * a[j]] + k);\n    for(int j = 0; b[j] <= i + 1; ++j)\n      for(int k = 1; b[j] * k <= i + 1; ++k)\n\tdpb[i+1] = min(dpb[i+1], dpb[i + 1 - k * b[j]] + k);\n  }\n  while(1){\n    int m;\n    cin >> m;\n    if(m == 0) break;\n\n    cout << dpa[m] << \" \" << dpb[m] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    const int N = 999999;\n\n    vector<int> num1(N+1, -1);\n    vector<int> num2(N+1, -1);\n    num1[0] = 0;\n    num2[0] = 0;\n    for(int i=1; ; ++i){\n        int tmp = i*(i+1)*(i+2)/6;\n        if(tmp > N)\n            break;\n        for(int j=0; j+tmp<=N; ++j){\n            if(num1[j] >= 0 && (num1[j+tmp] == -1 || num1[j]+1 < num1[j+tmp])){\n                num1[j+tmp] = num1[j]+1;\n            }\n        }\n        if(tmp % 2 == 1){\n            for(int j=0; j+tmp<=N; ++j){\n                if(num2[j] >= 0 && (num2[j+tmp] == -1 || num2[j]+1 < num2[j+tmp])){\n                    num2[j+tmp] = num2[j]+1;\n                }\n            }\n        }\n    }\n\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            break;\n        cout << num1[n] << ' ' << num2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dpt1[1000001];\nint dpt2[1000001];\nbool dpb1[1000001];\nbool dpb2[1000001];\nint tr[1000];\nint sq[1000];\n\nint dp1(int s) {\n  if(dpb1[s])\n    return dpt1[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    r = dp1(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt1[s] = m + 1;\n  dpb1[s] = true;\n  return m + 1;\n}\n\nint dp2(int s) {\n  if(dpb2[s])\n    return dpt2[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    if(sq[i]%2 == 0)\n      continue;\n    r = dp2(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt2[s] = m + 1;\n  dpb2[s] = true;\n  return m + 1;\n}\n\nint main() {\n\n  for(int i=1; i < 1000; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  dpt1[0] = 0;\n  dpb1[0] = true;\n  dpt2[0] = 0;\n  dpb2[0] = true;\n  int n;\n  while(cin >> n, n) {\n    cout << dp1(n) << \" \" << dp2(n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint func(int n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint solve1(int n, int j)\n{\n  int c = 0, m = 1000000;\n  for(int i = j; n >= 0; i--){\n    while(n >= func(i)){\n      c++;\n      n -= func(i);\n    }\n    if(n == 0)\n      break;\n  }\n  m = min(m, c);\n  return m;\n}\n\nint solve2(int n, int j)\n{\n  int c = 0, m = 1000000;\n  for(int i = j; n >= 0; i--){\n    while(n >= func(i) && (func(i) & 1)){\n      c++;\n      n -= func(i);\n    }\n    if(n == 0)\n      break;\n  }\n  m = min(m, c);\n  return m;\n} \n\n\n\t\n\t\n\n\nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      int m1, m2;\n      m1 = m2 = 1000000;\n      int k = 1;\n      while(n >= func(k)) \n\tk++;\n      for(int i = k - 1; i >= 1; i--){\n\tm1 = min(m1, solve1(n, i));\n\tm2 = min(m2, solve2(n, i));\n      }\n      cout << m1 << \" \" << m2 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 100000000\nusing namespace std;\n\nint main(){\n  int simen[200]={};\n  for(int i=0;i<200;i++)simen[i] = (i+1) * (i+2) * (i+3) / 6;\n  int dp[1000005], kisudp[1000005];\n  for(int i=0;i<1000005;i++){dp[i] = inf; kisudp[i] = inf;}\n  dp[0]=0;kisudp[0]=0;\n  for(int k=0;k<200;k++)for(int i=1;i<1000005;i++){\n    if(i >= simen[k])dp[i] = min(dp[i], dp[i-simen[k]] + 1);\n  }\n  for(int k=0;k<200;k++)for(int i=1;i<1000005;i++){\n    if(i >= simen[k] && simen[k]%2 == 1)kisudp[i] = min(kisudp[i], kisudp[i-simen[k]] + 1);\n  }\n\n  while(1){\n    int N;\n    scanf(\"%d\", &N);\n    if(N==0)break;\n    else printf(\"%d %d\\n\", dp[N], kisudp[N]);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1000000;\nconst int INF = 1<<29;\n\nint main() {\n    vector<int> dp(MAX, INF), odddp(MAX, INF);\n    dp[0] = odddp[0] = 0;\n    for (int i = 1;; ++i) {\n        int num = i * (i+1) * (i+2) / 6;\n        if (num >= MAX) break;\n        for (int j = num; j < MAX; ++j) {\n            dp[j] = min(dp[j], dp[j-num]+1);\n            if (num % 2 == 1) odddp[j] = min(odddp[j], odddp[j-num]+1);\n        }\n    }\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#include <iostream>\n#include <vector>\n// #include <map>\n// #include <string>\n// #include <algorithm>\n// #include <numeric>\n// #include <limits>\n\nusing namespace std;\n\nusing uint = unsigned int;\n\nconst uint s = 1.E6;\n\nuint ans[s];\nuint ans_odd[s];\n\ninline uint regularTetrahedronNum(uint n) {\n\treturn n * (n + 1) * (n + 2) / 6;\n}\n\ninline void update(uint rt_num) {\n\tfor (uint i = rt_num; i < s; i++) {\n\t\tans[i] = min(ans[i], ans[i - rt_num] + 1);\n\t}\n\tif (rt_num % 2 == 0) {\n\t\treturn;\n\t}\n\tfor (uint i = rt_num; i < s; i++) {\n\t\tans_odd[i] = min(ans_odd[i], ans_odd[i - rt_num] + 1);\n\t}\n}\n\nvoid print() {\n\tstd::cout << \"debug \" << std::endl; // debug\n\tfor (uint i = 0; i < s; i++) {\n\t\tcout << i << \": \" << ans[i] << \" \" << ans_odd[i] << endl;\n\t}\n}\n\nint main() {\n\tfor (uint i = 0; i < s; i++) {\n\t\tans[i] = i;\n\t\tans_odd[i] = i;\n\t}\n\tfor (uint i = 2; i < s; i++ ) {\n\t\tauto num = regularTetrahedronNum(i);\n\t\tif (num > s) {\n\t\t\tbreak;\n\t\t}\n\t\tupdate(num);\n\t}\n\n\t//print();\n\twhile (true) {\n\t\tuint tmp;\n\t\tcin >> tmp;\n\t\tif (tmp == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcout << ans[tmp] << \" \" << ans_odd[tmp] << endl;\n\n\t}\n\n\t//std::cout << \"\\e[38;5;0m\\e[48;5;40m --- end ---  \\e[m\" << std::endl; // debug\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<utility>\n#include<queue>\n#define pi 3.14159\n#define Inf (int)pow(2., 12.)\n\nusing namespace std;\ntypedef std::pair<int, int> mypair;\nqueue<mypair> qu;\n#define M 1000000\n \nint odd[M+10], all[M+10];\n \nvoid update(int *ar, int x){\n    for(int i = x; i <= M; ++i){\n        ar[i] = min(ar[i], ar[i - x] + 1);\n    }\n}\n \nint main(){\n\todd[0] = all[0] = 0;\n    for(int i = 1; i <= M; ++i){\n        odd[i] = all[i] = 10000000;\n    }\n \n    for(int i = 1; ; ++i){\n        int x = i * (i + 1) * (i + 2) / 6;\n        if(x > M) break;\n        update(all, x);\n        if(x % 2 == 1) update(odd, x); \n    }\n     \n    int n;\n    while(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << all[n] << \" \" << odd[n] <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint x[9999999][2], a[999], b[999], s, n;\nint main() {\n\ta[0] = 1; b[0] = 1;\n\tfor (int i = 1; i < 300; i++) {\n\t\ta[i] = a[i - 1] + (i + 1)*(i + 2) / 2;\n\t\tif (a[i] % 2 == 1) {\n\t\t\ts++; b[s] = a[i];\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> n; if (!n) { break; }\n\t\tmemset(x, 127, sizeof(x));\n\t\tx[0][0] = 0; x[0][1] = 0;\n\t\tfor (int i = 0; i < 300; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tx[j + a[i]][0] = min(x[j + a[i]][0], x[j][0] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << x[n][0] << ' ';\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tx[j + b[i]][1] = min(x[j + b[i]][1], x[j][1] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << x[n][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int i,j,n,three[1000],four[1000],four_2[1000],c[1000],c_2[1000];\n\n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i*i < n; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < n; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define INF 1000010\nusing namespace std;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nvector<int> num(200);\nvector<int> num_odd(200);\nvector<int> dp(1000011,INF);\nvector<int> dp_odd(1000011,INF);\nint main()\n{\n\tint i = 0;\n\twhile(i <= 185)\n\t{\n\t\tlong tmp = i*(i+1)*(i+2)/6;\n\t\tnum[i] = tmp;\n\t\tif(num[i] % 2) num_odd.push_back(tmp);\n\t\ti++;\n\t}\n\tdp[0] = dp_odd[0] = 0;\n\tfor(int i=0; i<num.size(); i++)\n\t{\n\t\tfor(int j=num[i]; j<=1000000; j++)\n\t\t{\n\t\t\tdp[j] = min(dp[j], dp[j - num[i]] + 1);\n\t\t}\n\t}\n\tfor(int i=0; i<num_odd.size(); i++)\n\t{\n\t\tfor(int j=num_odd[i]; j<=1000000; j++)\n\t\t{\n\t\t\tdp_odd[j] = min(dp_odd[j], dp_odd[j - num_odd[i]] + 1);\n\t\t}\n\t}\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tcout << dp[N] << \" \" << dp_odd[N] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000000;\nint tri[200];\nint dp[MAX], o_dp[MAX];\n\nint main()\n{\n\tfor (int i = 0; i < 200; i++) {\n\t\ttri[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tdp[0] = 0;\n\to_dp[0] = 0;\n\n\tfor (int i = 1; i < MAX; i++) {\n\t\tdp[i] = i;\n\t\to_dp[i] = i;\n\n\t\tfor (int j = 1; i - tri[j] >= 0; j++) {\n\t\t\tdp[i] = min(dp[i], dp[i - tri[j]] + 1);\n\n\t\t\tif (tri[j] % 2 == 1) {\n\t\t\t\to_dp[i] = min(o_dp[i], o_dp[i - tri[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << dp[n] << \" \" << o_dp[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nll odd[1010101];\nll al[1010101];\n\nint main(){\n\trep(i,1e6+1){\n\t\tal[i] = inf;\n\t\todd[i] = inf;\n\t}\n\tal[0] = 0;\n\todd[0] = 0;\n\tREP(i,1,200){\n\t\trep(j,1e6){\n\t\t\tll t = i*(i+1)*(i+2)/6;\n\t\t\tif(t+j > 1e6) break;\n\t\t\tif(t & 1) chmin(odd[t+j], odd[j]+1);\n\t\t\tchmin(al[t+j],al[j]+1);\n\t\t}\n\t}\n\twhile(1){\n\t\tll n; cin >> n;\n\t\tif(!n) break;\n\t\tprint2(al[n], odd[n]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1000001];\nint memo2[1000001];\n \nint solve(int n){\n\n  if(!n) return 0;\n  if(memo[n]) return memo[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n; i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(memo2[n]) return memo2[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++){\n    if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n  }\n   \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  for(int i=0;i<=181;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i+=1000) solve(i), solve2(i);\n   \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,i,j,k,t=0,a[250]={},b[200]={},c[1000005]={1000000},d[1000005]={1000000};\n  for(i=1;i<250;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(a[i-1]%2==1)b[t++]=a[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<250;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<b[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\nint c[300];\nvector<int> d;\nint a[10000000],b[10000000];\n\nvoid f(int n){\n\n  int j=1;\n  FOR(i,1,n+1){\n    if(c[j+1]==i){\n      a[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,1,j+1){\n        res = min(res,(i/c[k])+a[i%c[k]]);\n      }\n      a[i] = res;\n    }\n  }\n\n\n  j = 0;\n  FOR(i,1,n+1){\n    if(d[j+1]==i){\n      b[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,0,j+1){\n        res = min(res,(i/d[k])+b[i%d[k]]);\n      }\n      b[i] =res;\n    }\n  \n  }\n\n\n\n\n}\n\nvoid g(int n){\n  cout<<a[n]<<' '<<b[n]<<endl;\n}\n\n\nint main(){\n\n  for(int i=1;i<200;i++){\n    c[i] = (i*(i+1)*(i+2))/6;\n   if(c[i]%2){\n     d.push_back(c[i]);\n   }\n  }\n\n  f(1000000);\n\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    g(n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define pb push_back\n#define dump(x)  cout << \" \"<< #x << \" = \" << (x) << endl;\ntypedef long long ll;\ntypedef complex<int> P;\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\nconst int MAXN = 1e6;\nint ans[MAXN], ans2[MAXN];\n\nvector<int> v, v2;\nvoid f(vector<int> &v, int ans[]){\n\tfor(int i=0;i<MAXN;i++){\n\t\tans[i] = i;\n\t}\n\tfor(int i=1;i<v.size();i++){\n\t\tfor(int j=v[i];j<MAXN;j++){\n\t\t\tans[j] = min(ans[j], ans[j - v[i]] + 1);\n\t\t}\n\t}\n\treturn;\n}\nvoid ini(){\n\tfor(int i=1;i<MAXN;i++){\n\t\tint a = i * (i+1) * (i+2) / 6;\n\t\tif(a > MAXN) break;\n\t\tv.pb(a);\n\t\tif(a%2) v2.pb(a);\n\t}\n\tf(v, ans);\n\tf(v2, ans2);\n\treturn;\n}\n\nbool solve(int n){\n\t\n\tcout<< ans[n]<< \" \"<< ans2[n]<< endl;\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\tini();\n\tint n;\n\twhile(cin>> n, n) solve(n);\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repr(i,a,n) for(int i=a;i>=n;i--)\n#define INF 999999999\n#define pb(a) push_back(a)\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef vector<pii> VP;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\n\nint main() {\n    int n;\n    int a[1000];\n    int b[1000];\n    int dp1[1000000];\n    int dp2[1000000];\n    while(cin >> n) {\n        if(n == 0) break;\n        rep(i,0,1000) {\n            a[i] = 0;\n            b[i] = 0;\n        }\n\n        int cnt = 0;\n        for(int i = 1; i * (i+1) * (i+2) / 6 <= n; i++) {\n            a[i-1] = i * (i+1) * (i+2) / 6;\n\n            if(i * (i+1) * (i+2) / 6 % 2 == 1) {\n                b[cnt] = i * (i+1) * (i+2) / 6;\n                cnt++;\n            }\n        }\n\n/*\n        for(int i = 1; i * (i+1) * (i+2) / 6 <= n; i++) {\n            cout << a[i-1] << endl;\n        }\n\n        cout << endl;\n\n        for(int i = 0; b[i] != 0; i++) {\n            cout << b[i] << endl;\n        }\n*/\n\n        rep(i,0,1000000) {\n            dp1[i] = i;\n            dp2[i] = i;\n        }\n\n        int k = 0;\n        while(a[k] != 0) {\n            rep(j,0,n+1) {\n                dp1[j+a[k]] = min(dp1[j+a[k]], dp1[j] + 1);\n            }\n            k++;\n        }\n\n        k = 0;\n        while(b[k] != 0) {\n            rep(j,0,n+1) {\n                dp2[j+b[k]] = min(dp2[j+b[k]], dp2[j] + 1);\n            }\n            k++;\n        }\n\n        cout << dp1[n] << \" \"<< dp2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[MAXNUM], fourodd[MAXNUM];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tlong long int now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM * 2)\n\t\t\tbreak;\n\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// 模範解答\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1000100;\nconst int INF = 1<<29;\n\nint main() {\n    vector<int> dp(MAX, INF), odddp(MAX, INF);\n    dp[0] = odddp[0] = 0;\n    for (int i = 1;; ++i) {\n        int num = i * (i+1) * (i+2) / 6;\n        if (num >= MAX) break;\n        for (int j = num; j < MAX; ++j) {\n            dp[j] = min(dp[j], dp[j-num]+1);\n            if (num & 1) odddp[j] = min(odddp[j], odddp[j-num]+1);\n        }\n    }\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[200];\nint dp1[1000001];\nint dp2[1000001];\nint main(){\n    int a;\n    for(int i=0;i<200;i++){\n        b[i]=i*(i+1)*(i+2)/6;\n    }\n    for(int i=0;i<1000001;i++)dp1[i]=dp2[i]=99999999;\n    dp1[0]=dp2[0]=0;\n    for(int i=0;i<1000001;i++){\n        for(int j=1;j<200;j++){\n            if(i+b[j]<=1000000)dp1[i+b[j]]=min(dp1[i+b[j]],dp1[i]+1);\n            if(b[j]%2&&i+b[j]<=1000000)dp2[i+b[j]]=min(dp2[i+b[j]],dp2[i]+1);\n        }\n    }\n    while(scanf(\"%d\",&a),a){\n        printf(\"%d %d\\n\",dp1[a],dp2[a]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n/*\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n*/\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst static int MAX=1000005;\nconst static int INF=(1<<28);\nint T[MAX];\nint res(int n){\n\tvector<int> C;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=n;i++){\n\t\tC.push_back(i*(i+1)*(i+2)/6);\n\t}\n\t\n\t\n\tfor(int i=0;i<=n;i++){\n\t\tT[i]=INF;\n\t}\n\t\n\tT[0]=0;\n\t\n\tint k=C.size();\n\t\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j+C[i]<=n;j++){\n\t\t\tT[j+C[i]]=min(T[j+C[i]],T[j]+1);\n\t\t}\n\t}\n\treturn T[n];\n}\n\nint odd(int n){\n\tvector<int> C;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=n;i++){\n\t\tint t=i*(i+1)*(i+2)/6;\n\t\tif(t%2==1){\n\t\t\tC.push_back(t);\n\t\t}\n\t}\t\n\tfor(int i=0;i<=n;i++){\n\t\tT[i]=INF;\n\t}\n\t\n\tT[0]=0;\n\t\n\tint k=C.size();\n\t\n\tfor(int i=0;i<k;i++){\n\t\tfor(int j=0;j+C[i]<=n;j++){\n\t\t\tT[j+C[i]]=min(T[j+C[i]],T[j]+1);\n\t\t}\n\t}\n\treturn T[n];\t\n}\n\nint main()\n{\n\tint n;\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tint a=res(n);\n\t\tint b=odd(n);\n\t\tcout<<a<<\" \"<<b<<endl;\n\t}\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1000100;\nconst int INF = 1<<29;\n\nint main() {\n    vector<int> dp(MAX, INF), odddp(MAX, INF);\n    dp[0] = odddp[0] = 0;\n    for (int i = 1;; ++i) {\n        int num = i * (i+1) * (i+2) / 6;\n        if (num >= MAX) break;\n        for (int j = num; j < MAX; ++j) {\n            dp[j] = min(dp[j], dp[j-num]+1);\n            if (num & 1) odddp[j] = min(odddp[j], odddp[j-num]+1);\n        }\n    }\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n,p;\n  for(i=1;a[i-1]<1000000;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0,p=i;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<p;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst ll MOD=10000;\nconst ll INF=1000000010;\nconst int MAX=100001;\nint dx[8]={0,1,0,-1,1,-1,1,-1};\nint dy[8]={1,0,-1,0,1,-1,-1,1};\nint main(){\n\tint s[110];\n\tfor(int i=0;i<110;i++){\n\t\ts[i]=(i+1)*(i+2)*(i+3)/6;\n\t\tcout<<s[i]<<endl;\n\t}\n\tint n;\n\twhile(cin>>n,n){\n\t\tint nn=n;\n\t\tint c=0;\n\t\twhile(n){\n\t\t\tc++;\n\t\t\tint ss;\n\t\t\tfor(int i=0;i<110;i++){\n\t\t\t\tif(s[i]>n){\n\t\t\t\t\tss=s[i-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn-=ss;\n\t\t}\n\t\tcout<<c<<\" \";\n\t\tn=nn;\n\t\tc=0;\n\t\twhile(n){\n\t\t\tc++;\n\t\t\tint ss;\n\t\t\tfor(int i=0;i<110;i++){\n\t\t\t\tif(s[i]>n){\n\t\t\t\t\tss=i-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=ss;i>=0;i--){\n\t\t\t\tif(s[i]%2){\n\t\t\t\t\tss=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn-=ss;\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][100010] = {0};\n\nvoid solve(int n) {\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t\tif (dp[i][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=100000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t\tif (dp[i%2][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n//正四面体数を返す\nint getRt(int n){\n\treturn (n) * (n + 1) * (n + 2) / 6;\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\t\n\twhile(1){\n\t\tint n, tmp;\n\t\tcin >> n;\n\t\tif( n == 0 ) break;\n\n\t\t//nに最も近く、かつn以下の正四面体数は？\n\t\tint p = 0;\n\t\tfor(int i = 1; getRt(i) <= n; i++)\n\t\t\tp = i;\n\n\t\t//■■■■奇数以外の正四面体数を含む場合■■■■\n\t\tvector<int> cntlist;\n\t\tfor(int i = p; i >= 1; i--) {\n\t\t\tint cnt = 0;\n\t\t\ttmp = n;\n\t\t\tfor(int j = i; j >= 1; j--) {\n\t\t\t\tcnt += tmp / getRt(j);\n\t\t\t\ttmp %= getRt(j);\n\t\t\t}\n\t\t\tcntlist.push_back(cnt);\n\t\t}\n\t\tsort(cntlist.begin(), cntlist.end());\n\t\tcout << cntlist.at(0) << \" \";\n\n\t\t//■■■■奇数の正四面体数のみの場合■■■■\n\t\tvector<int> cntlist2;\n\t\tfor(int i = p; i >= 1; i--) {\n\t\t\tint cnt = 0;\n\t\t\ttmp = n;\n\t\t\tfor(int j = i; j >= 1; j--) {\n\t\t\t\tif( getRt(j) % 2 == 0 ) continue;\n\t\t\t\tcnt += tmp / getRt(j);\n\t\t\t\ttmp %= getRt(j);\n\t\t\t}\n\t\t\tcntlist2.push_back(cnt);\n\t\t}\n\t\tsort(cntlist2.begin(), cntlist2.end());\n\t\tcout << cntlist2.at(0) << endl;\n\n\t}\n\n\t//while(1){}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n\nll dp[1000001];\nll dp2[1000001];\n\nint main() {\n\n    for (int i=1; i<=1000000; ++i) {\n        dp[i] = dp2[i] = i;\n        for (int n=1;;++n) {\n            int p = n*(n+1)*(n+2)/6;\n            if (i < p) break;\n            dp[i] = min(dp[i], dp[i-p]+1);\n            if (p%2) {\n                dp2[i] = min(dp2[i], dp2[i-p]+1);\n            }\n        }\n    }\n\n    int n;\n    while (cin >> n and n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint D[182] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<182 ; i++ ){\n\t\tD[i] = i * (i+1) * (i+2) / 6 ;\n\t}\n}\n\nint cal_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( dp_map[0][x] != 0 ) return dp_map[0][x] ;\n\t\telse return x/D[c] + cal_2( x%D[c] , c-1 ) ;\n\t}\n}\n\nint cal( int m , int q ){\n\tint ans = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans = min( ans , cal_2( m , j ) ) ;\n\t}\n\treturn ans ;\n}\n\nint cal_odd_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( D[c]%2 == 0 ) return cal_odd_2( x , c-1 ) ;\n\t\telse{\n\t\t\tif( dp_map[1][x] != 0 ) return dp_map[1][x] ;\n\t\t\telse return x/D[c] + cal_odd_2( x%D[c] , c-1 ) ;\n\t\t}\n\t}\n}\n\nint cal_odd( int m , int q ){\n\tint ans_2 = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans_2 = min( ans_2 , cal_odd_2( m , j ) ) ;\n\t}\n\treturn ans_2 ;\n}\n\nvoid dp(){\n\tint p = 1 ;\n\tfor( int i=1 ; i<=1000000 ; i++ ){\n\t\tif( p < 182 && i >= D[p] ) p++ ;\n\t\tdp_map[0][i] = cal(i,p) ;\n\t\tdp_map[1][i] = cal_odd(i,p) ;\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nll memo[110];\nll memo2[110];\n\nll calc(int n) {\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint dfs(int depth, int n) {\n  int ans = 9999;\n  if (memo[n] != 0) return memo[n];\n  for (int i = n; i >= 1; i--) {\n    ll t = calc(i);\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      memo[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs(depth + 1, n - t));\n  }\n  memo[n] = ans;\n  return ans;\n}\n\nint dfs_odd(int depth, int n) {\n  int ans = 9999;\n  if (memo2[n] != 0) return memo2[n];\n  for (int i = n; i >= 1; i--) {\n    if (i % 2 == 0) continue;\n    ll t = calc(i);\n    if (t % 2 == 0) continue;\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      memo2[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs_odd(depth + 1, n - t));\n  }\n  memo2[n] = ans;\n  return ans;\n}\n  \nint main() {\n  int N;\n  while (cin >> N, N != 0) {\n    for (int i = 0; i < 110; i++) {\n      memo[i] = 0;\n      memo2[i] = 0;\n   }\n    cout << dfs(1, N) << \" \" << dfs_odd(1, N) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int NUM = 222;\nconst int MAX_N = 1010101;\nconst int INF = 1001001001;\n\nll tri[NUM];\nll tet[NUM];\nll dp_a[MAX_N];\nll dp_o[MAX_N];\n\nint main() {\n    for (int i = 1; i < NUM; i++) {\n        tri[i] = tri[i - 1] + i;\n    }\n    for (int i = 1; i < NUM; i++) {\n        tet[i] = tet[i - 1] + tri[i];\n    }\n    fill(dp_a, dp_a + MAX_N, INF);\n    fill(dp_o, dp_o + MAX_N, INF);\n    dp_a[0] = dp_o[0] = 0;\n    for (int i = 0; i < NUM; i++) {\n        for (int j = tet[i]; j <= MAX_N; j++) {\n            dp_a[j] = min(dp_a[j], dp_a[j - tet[i]] + 1);\n            if (tet[i] & 1) dp_o[j] = min(dp_o[j], dp_o[j - tet[i]] + 1);\n        }\n    }\n    int n;\n    while (cin >> n && n) {\n        cout << dp_a[n] << ' ' << dp_o[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tvi four;\n\tint n = 1;\n\twhile(true) {\n\t\tint num = n*(n+1)*(n+2)/6;\n\t\tif(num > 100000) {\n\t\t\tbreak;\t\n\t\t} else {\n\t\t\tfour.push_back(num);\n\t\t\tn++;\n\t\t}\n\t}\n\tint fsize = four.size();\n\n\twhile(cin >> n, n) {\n\t\tvi dp(n+1, INF);\n\t\tvi dpk(n+1, INF);\n\t\tdp[0] = dpk[0] = 0;\n\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, fsize) {\n\t\t\t\tif(i-four[j] >= 0) {\n\t\t\t\t\tdp[i] = min(dp[i-four[j]]+1, dp[i]);\n\t\t\t\t\tif(four[j]%2) {\n\t\t\t\t\t\tdpk[i] = min(dpk[i-four[j]]+1, dpk[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[n] << \" \" << dpk[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    const long long size = 1000000;\n    vector<long long> memo(size, -1);\n    vector<long long> odd(size, -1);\n    memo[0] = 0; odd[0] = 0;\n\n    for (int i=0; i<size; i++) {\n        memo[i] = i; odd[i] = i;\n    }\n\n    for (long long i=2; i<200; i++) {\n        const long long pNum = (i * (i+1) * (i+2)) / 6;\n        for (long long j=0; j<size; j++) {\n            if (j-pNum >= 0) {\n                memo[j] = min(memo[j-pNum]+1, memo[j]);\n\n                if (pNum % 2 == 1) {\n                    odd[j] = min(odd[j-pNum]+1, odd[j]);\n                }\n            }\n        }\n    }\n\n    long long n; while (cin >> n, n != 0) {\n        cout << memo[n] << \" \" << odd[n] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint mint[1000000], mink[1000000];\nint main() {\n\tmemset(mint, 0x3f, sizeof(mint));\n\tmemset(mink, 0x3f, sizeof(mink));\n\tfor (int i = 1;; i++) {\n\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\tif (a >= 1000000)break;\n\t\tfor (int j = a; j < 1000000; j++) {\n\t\t\tmint[j] = min(mint[j], mint[j - a] + 1);\n\t\t\tif (a & 1)mink[j] = min(mink[j], mink[j - a] + 1);\n\t\t}\n\t}\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t\tprintf(\"%d %d\\n\", mint[n], mink[n]);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\nusing pci = pair<char, int>;\nusing vpci = vector<pci>;\n#define out(S) cout<<(S)<<endl;\n#define REP(i,b) for(size_t i=0;i<(b);i++)\n#define rREP(i,b) for(int i=(b)-1;i>=0;i--)\n#define FOR(i,a,b) for(size_t i=(a);i<(b);i++)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define Foreach(item,collection) for(auto item:collection)\n#define mod(i) ((i) % (ll)(1e9 + 7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a * modpow((ll)b,(ll)(1e9 + 5))))\n#define Yes out(\"Yes\")\n#define No out(\"No\")\n#define NO out(\"NO\")\n#define YES out(\"YES\")\n#define INF 1e10;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define IfOut(condition,text) if((condition)){out(text);return 0;}\n#define IfeOut(condition,itext,etext) if(condition){out(itext);return 0;}else{out(etext);return 0;}\n#define beginend(vec) (vec).begin(),(vec).end()\n#define pb(item) push_back(item)\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nbool isPrime(ll x) {if (x == 2) return true;if (x < 2 || x % 2 == 0) return false;ll i = 3;while (i <= sqrt(x)) {if (x%i == 0) return false;i += 2;}return true;}\n\nvl dd(int max) {\n\tvl rt;\n\tint n = 1;\n\twhile (true)\n\t{\n\t\tll next = n*(n + 1)*(n + 2) / 6;\n\t\tif (max  <= next) { rt.pb(next); break; }\n\t\trt.pb(next);\n\t\tn++;\n\t}\n\treturn rt;\n}\n\nvl llist;\n\nint bfs(int target) {\n\tdeque<ll> q;\n\tForeach(i, llist) {\n\t\tif (i == target) { return 1; }\n\t\telse if (i < target) q.pb(i);\n\t}\n\tint cnt = 2;\n\twhile (1){\n\t\tset<ll> next;\n\t\tint ss = q.size();\n\t\tFOR(i, 0, ss) {\n\t\t\tint x = q.front();\n\t\t\tq.pop_front();\n\t\t\tForeach(k, llist) {\n\t\t\t\tif (k + x > target) break;\n\t\t\t\tif (k + x == target) { next.clear(); q.clear(); return cnt; }\n\t\t\t\tif (k + x < target) next.insert(k + x);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tdeque<ll> nn;\n\t\tForeach(i, next) nn.pb(i);\n\t\tq.resize(next.size());\n\t\tq = nn;\n\t\tnn.deque::clear();\n\t}\n}\n\nint bfs2(int target) {\n\tdeque<ll> q;\n\tvl oddlist = llist;\n\tremoveAll(oddlist, [](ll x) {return x % 2 == 0; });\n\tForeach(i, oddlist) {\n\t\tif (i == target) { return 1; }\n\t\telse if (i < target) q.pb(i);\n\t}\n\tint cnt = 2;\n\twhile (1) {\n\t\tset<ll> next;\n\t\tint ss = q.size();\n\t\tFOR(i, 0, ss) {\n\t\t\tint x = q.front();\n\t\t\tq.pop_front();\n\t\t\tForeach(k, oddlist) {\n\t\t\t\tif (k + x > target) break;\n\t\t\t\tif (k + x == target) { next.clear(); q.clear(); return cnt; }\n\t\t\t\tif (k + x < target) next.insert(k + x);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tdeque<ll> nn;\n\t\tForeach(i, next) nn.pb(i);\n\t\tq.resize(next.size());\n\t\tq = nn;\n\t\tnn.deque::clear();\n\t}\n}\n\nint main() {\n\tvi query;\n\tint k;\n\twhile (cin >> k, k)query.pb(k);\n\tauto mm = max_element(beginend(query));\n\tllist = dd(*mm);\n\t//ShowAll(llist);\n\tForeach(q, query) {\n\t\tcout << bfs(q) << \" \" << bfs2(q) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MAX_VAL = 1e6;\nint min_n = MAX_VAL;\n\nvoid makePyramidal(vector<int>* pyramidal, vector<int>* odd_pyramidal, const int& max_val) {\n    for (int i = 1; ; i++) {\n        int val = i * (i+1) * (i+2) / 6;\n        if (val > max_val) { break; }\n        pyramidal->push_back(val);\n        if (val % 2) { odd_pyramidal->push_back(val); }\n    }\n    reverse(pyramidal->begin(), pyramidal->end());\n    reverse(odd_pyramidal->begin(), odd_pyramidal->end());\n}\n\nvoid searchPyramidal(const vector<int>& pyramidal, const int& val, const int& i, const int& n) {\n    //cout << val << \" \"<< i << \" \" << n << endl;\n    if (val < 0 or i >= pyramidal.size() or n >= min_n) { return; }\n    if (val == 0) {\n        min_n = n;\n        return;\n    }\n    searchPyramidal(pyramidal, val - pyramidal[i], i, n + 1);\n    searchPyramidal(pyramidal, val - pyramidal[i], i + 1, n + 1);\n    searchPyramidal(pyramidal, val, i + 1, n);\n}\n\npair<int,int> solve(const vector<int>& pyramidal, const vector<int>& odd_pyramidal, const int& val) {\n    min_n = MAX_VAL;\n    searchPyramidal(pyramidal, val, 0, 0);\n    int a = min_n;\n\n    min_n = MAX_VAL;\n    searchPyramidal(odd_pyramidal, val, 0, 0);\n    int b = min_n;\n\n    return make_pair(a, b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    vector<int> pyramidal;\n    vector<int> odd_pyramidal;\n    makePyramidal(&pyramidal, &odd_pyramidal, MAX_VAL);\n\n    int val;\n    while (true) {\n        cin >> val;\n        if (val == 0) { break; }\n        auto p = solve(pyramidal, odd_pyramidal, val);\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define reps(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\nconst ll mod = ll(1e9) + 7;\nconst int INF = int(1e9);\n\nint dp[1000000] = {};\nint dp_o[1000000] = {};\nmap<int, int>mp, mp_o;\nint DP(int num) {\n\tif (dp[num] != 0)return dp[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 1;\n\twhile (1) {\n\t\trec = min(DP(mp[cnt]) + DP(num - mp[cnt]), rec);\n\t\tcnt++;\n\t\tif (mp[cnt] > num)break;\n\t}\n\tdp[num] = rec;\n\treturn rec;\n\n}\nint DP_o(int num) {\n\tif (dp_o[num] != 0)return dp_o[num];\n\tif (num == 0)return 0;\n\tint rec = INF;\n\tint cnt = 1;\n\twhile (1) {\n\t\trec = min(DP(mp_o[cnt]) + DP(num - mp_o[cnt]), rec);\n\t\tcnt++;\n\t\tif (mp_o[cnt] > num)break;\n\t}\n\tdp_o[num] = rec;\n\treturn rec;\n\n}\n\nint main() {\n\tcin.sync_with_stdio(false);\n\tll cnt1 = 1, cnt2 = 1;\n\tdp[1] = 1, dp[1] = 1;\n\tmp[1] = 1, mp_o[1] = 1;\n\tint cnt_o = 2;\n\treps(i, 2, 1000001) {\n\t\tcnt1 += i;\n\t\tcnt2 += cnt1;\n\t\tdp[cnt2] = 1;\n\t\tmp[i] = cnt2;\n\t\tif (cnt2 % 2 == 1) {\n\t\t\tdp_o[cnt2] = 1;\n\t\t\tmp[cnt_o] = cnt2;\n\t\t\tcnt_o++;\n\t\t}\n\t}\n\twhile (1) {\n\t\tint Q;\n\t\tcin >> Q;\n\t\tif (Q == 0)break;\n\t\tcout << DP(Q) << \" \";\n\t\tcou << DP_o(Q) << endl;\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[1000000], dp2[1000000];\nint main() {\n\tv.pb(0);\n\tll n, now = 1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)i*(i + 1)*(i + 2) / 6;\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 100000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 100000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], i / v[j] + dp2[i%v[j]]);\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 1000000;\nint main(){\n  vector<int> dp1(1000000, INF);\n  vector<int> dp2(1000000, INF);\n  dp1[0] = 0;\n  dp2[0] = 0;\n  for (int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    for (int j = t; j <= 1000000; j++){\n      dp1[j] = min(dp1[j], dp1[j - t] + 1);\n    }\n    if (t % 2 == 1){\n      for (int j = t; j <= 1000000; j++){\n        dp2[j] = min(dp2[j], dp2[j - t] + 1);\n      }\n    }\n  }\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    cout << dp1[N] << ' ' << dp2[N] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cmath>\n#include <climits>\n//#include \"h.h\"\nusing namespace std;\n\n#define ll long long\n#define pint pair<int, int>\n#define pll pair<ll, ll>\n#define pb push_back\n#define mp make_pair\n#define pm(first, second) pb(mp(first, second))\n#define SPACE \" \"\n#define fpf first.first\n#define fps first.second\n#define spf second.first\n#define sps second.second\n\n#define all(X) (X).begin(), (X).end()\n\nint main(){\n\n\tvector<ll> TPN, TPN_ODD;\n\n\t//pre_calc\n\tint cnt = 1;\n\tdo{\n\t\tTPN.pb(cnt * (cnt + 1) * (cnt + 2) / 6);\n\t\tif((cnt * (cnt + 1) * (cnt + 2) / 6)%2 == 1){\n\t\t\tTPN_ODD.pb(cnt * (cnt + 1) * (cnt + 2) / 6);\n\t\t}\n\t\tcnt ++;\n\t}while(cnt * (cnt + 1) * (cnt + 2) / 6 <= 1000000);\n\tint TPNSize = TPN.size(), TPN_ODDSize = TPN_ODD.size();\n\n\t//cout << \"TPNSize = \" << TPNSize << endl;\n\t//cout << \"TPN_ODDSize = \" << TPN_ODDSize << endl;\n\n\tvector<ll> V1(1000001), V2(1000001);\n\tV1[0] = 0;\n\tfor(ll i = 1; i < 1000001; i ++){\n\t\tll ret = 100;\n\t\tfor(ll j = 0; j < TPNSize && TPN[j] <= i; j ++){\n\t\t\tret = min(ret, 1 + V1[i - TPN[j]]);\n\t\t}\n\t\tV1[i] = ret;\n\t}\n\tV2[0] = 0;\n\tfor(ll i = 1; i < 1000001; i ++){\n\t\tll ret = 100;\n\t\tfor(ll j = 0; j < TPN_ODDSize && TPN_ODD[j] <= i; j ++){\n\t\t\tret = min(ret, 1 + V2[i - TPN_ODD[j]]);\n\t\t}\n\t\tV2[i] = ret;\n\t}\n\n\t//solve\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0)break;\n\n\t\tcout << V1[N] << \" \" << V2[N] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nbool   dp[6][1000001];\nbool dp2[38][1000001];\n\nint main(){\n  int n=1;\n  vector<int> vec, vec2;\n  int tmp=0;\n  while(tmp<=1000000){\n    tmp+=n*(n+1)/2;\n    vec.pb(tmp);\n    if(tmp%2==1) vec2.pb(tmp);\n    n++;\n  }\n  // dp[i][j] : i???????????£???j?????°????????????\n  dp[0][0]=true;\n  repl(i,1,5+1){\n    for(int upd : vec){\n      rep(j, 1000001){\n        dp[i][j] = dp[i][j] | dp[i-1][j];\n        if(j-upd>=0 && dp[i-1][j-upd]) dp[i][j] = true;\n      }\n    }\n  }\n  dp2[0][0]=true;\n  repl(i,1,38){\n    for(int upd : vec2){\n      rep(j, 1000001){\n        dp2[i][j] = dp2[i][j] | dp2[i-1][j];\n        if(j-upd>=0 && dp2[i-1][j-upd]) dp2[i][j] = true;\n      }\n    }\n  }\n\n  while(cin>>n, n){\n    int res=1;\n    while(dp[res][n]==false) res++;\n    cout<<res<<\" \";\n    res=1;\n    while(dp2[res][n]==false) res++;\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define INF 100000000\n\n\nint main(){\n\tint table1[201]={};\n\tvector<int> table2;\n\tfor(int i=1;i<201;i++){\n\t\ttable1[i-1]=i*(i+1)*(i+2)/6;\n\t\tif(table1[i-1]%2!=0){\n\t\t\ttable2.push_back(table1[i-1]);\n\t\t}\n\t}\n\tint count1[1000001];\n\tint count2[1000001];\n\tfor(int i=0;i<1000001;i++){\n\t\tcount1[i]=INF;\n\t\tcount2[i]=INF;\n\t}\n\tcount1[0]=0;\n\tcount2[0]=0;\n\tcount1[1]=1;\n\tcount2[1]=1;\n\tfor(int i=2;i<1000001;i++){\n\t\tfor(int j=0;j<201;j++){\n\t\t\tif(table1[j]>i)break;\n\t\t\tcount1[i] = min(count1[i],count1[i-table1[j]]+1);\n\t\t}\n\t}\n\tfor(int i=2;i<1000001;i++){\n\t\tfor(int j=0;j<201;j++){\n\t\t\tif(table2[j]>i)break;\n\t\t\tcount2[i] = min(count2[i],count2[i-table2[j]]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tcout << count1[n] << \" \" << count2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1000001;\nconst int INF = 1e+8;\n \nint f(int n){\n\treturn (n * (n + 1) * (n + 2)) / 6;\n}\n\nint main(){\n\tvector<int> v, w;\n\tfor(int i=1 ; f(i) < MAX_N ; i++ ){\n\t\tv.push_back( f(i) );\n\t\tif( f(i) % 2 == 1 ){\n\t\t\tw.push_back( f(i) );\n\t\t}\n\t}\n\t\n\t// dp[i] := 整数 i を正四面体数の和で表すときの個数の最小値\n\tint dp[MAX_N];\n\tint dp2[MAX_N];\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tdp[i] = dp2[i] = INF;\n\t}\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tdp[ v[i] ] = 1;\n\t}\n\tfor(int i=0 ; i < w.size() ; i++ ){\n\t\tdp2[ w[i] ] = 1;\n\t}\n\tfor(int i=1 ; i < MAX_N ; i++ ){\n\t\tif( dp[i] != INF ){\n\t\t\tfor(int j=0 ; j < v.size() && i + v[j] < MAX_N ; j++ ){\n\t\t\t\tdp[ i + v[j] ] = min( dp[i+v[j]] , dp[i] + 1 );\n\t\t\t}\n\t\t}\n\t\tif( dp2[i] != INF ){\n\t\t\tfor(int j=0 ; j < w.size() && i + w[j] < MAX_N ; j++ ){\n\t\t\t\tdp2[ i + w[j] ] = min( dp2[i+w[j]] , dp2[i] + 1 );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint dp[100001];\nint dp2[100001];\nvector<int> vi;\n\nvoid solve(){\n\tfor(int i=1;i*(i+1)*(i+2)/6 <= 100000;i++){\n\t\tvi.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tfill(dp,dp+100001,9999999);\n\tfill(dp2,dp2+100001,9999999);\n\t\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor(int i=0;i<100000;i++){\n\t\tif(dp[i] != 9999999){\n\t\t\tfor(int j=0;j<vi.size();j++){\n\t\t\t\tif(i+vi[j] <= 100000){\n\t\t\t\t\tdp[i+vi[j]] = min(dp[i+vi[j]],dp[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp2[i] != 9999999){\n\t\t\tfor(int j=0;j<vi.size();j++){\n\t\t\t\tif(i+vi[j] <= 100000 && vi[j]%2 == 1){\n\t\t\t\t\tdp2[i+vi[j]] = min(dp2[i+vi[j]],dp2[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tsolve();\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[1000], fourodd[1000];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\tcout << \"a\";\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000000];\nint v[1000];\nint main()\n{\n\tint n;\n\tfor (int j = 0; j < 1000000; j++)\n\t{\n\t\tdp[0][j] = 999999;\n\t\tdp[1][j] = 999999;\n\t}\n\tdp[0][0] = 0;\n\tdp[1][0] = 0;\n\tfor (int i = 1;i < 1000; i++)\n\t{\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif (k >= 1000000)break;\n\t\tv[i - 1] = k;\n\t}\n\tfor (int i = 0; i < 1000000; i++)\n\t{\n\t\tfor (int j = 0;j < 1000; j++)\n\t\t{\n\t\t\tif (i + v[j] >= 1000000)break;\n\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]], dp[0][i] + 1);\n\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t}\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline int setbit(int n) { return (1 << n) - 1; }\ninline bool contains(int x, int min, int max) { return x >= min && x < max; } // max含まない\n\nvoid solve()\n{\n\tint testcases = INF;\n\tint M = 1e6 + 1;\n\tvector<int> t1, t2;\n\tfor (int i = 0; i * (i + 1) * (i + 2) / 6 < M; i++)\n\t{\n\t\tint x = i * (i + 1) * (i + 2) / 6;\n\t\tt1.push_back(x);\n\t\tif (x & 1) t2.push_back(x);\n\t}\n\n\tvector<int> a1(1e6 + 1, INF); a1[0] = 0;\n\tvector<int> a2(1e6 + 1, INF); a2[0] = 0;\n\n\tfor (auto x : t1)\n\tfor (int j = x; j < M; j++)\n\t\ta1[j] = min(a1[j], a1[j - x] + 1);\n\n\n\tfor (auto x : t2)\n\tfor (int j = x; j < M; j++)\n\t\ta2[j] = min(a2[j], a2[j - x] + 1);\n\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!(N)) { break; }\n\t\tWRITE(a1[N], a2[N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nchar table[1000000][1],tablek[1000000];\nint po[182];\n\nint main(){\n\tint i,j,k,n;\n\t\n\tmemset(po,0,sizeof(po));\n\tmemset(table,0,sizeof(table));\n\tmemset(tablek,0,sizeof(tablek));\n\t\n\tfor(i=1;i<182;i++){\n\t\tpo[i]=i*(i+1)*(i+2)/6;\n\t\tif(po[i]<1000000)table[po[i]][0]=1;\n\t}\n\t\n\tfor(i=1;i<5;i++){\n\t\tfor(j=1;j<1000000;j++){\n\t\t\tif(table[j][0]==i){\n\t\t\t\tfor(k=1;k<182;k++){\n\t\t\t\t\tif(j+po[k]>=1000000)break;\n\t\t\t\t\tif(table[j+po[k]][0]==0)table[j+po[k]][0]=i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tn=1000000-1;\n\t\n\tfor(i=1;i<182;i++){\n\t\tif(po[i]<1000000 && po[i]%2==1){\n\t\t\ttablek[po[i]]=1;\n\t\t\t--n;\n\t\t}\n\t}\n\tprintf(\"a\\n\");\n\tfor(i=1;n>0;i++){\n\t\tfor(j=1;j<1000000;j++){\n\t\t\tif(tablek[j]==i){\n\t\t\t\tfor(k=1;k<182;k++){\n\t\t\t\t\tif(j+po[k]>=1000000)break;\n\t\t\t\t\tif(tablek[j+po[k]]==0 && po[k]%2==1){\n\t\t\t\t\t\ttablek[j+po[k]]=i+1;\n\t\t\t\t\t\t--n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<36;i++)printf(\"%d\\n\",tablek[i]);\n\t\n\twhile(scanf(\"%d\",&n)>=0){\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",table[n][0],tablek[n]);\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[1000010]={0};\nint dp2[1000010]={0};\nint List[200];\n\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tList[i]=i*(i+1)*(i+2)/6;\n\tfor(i=1;i<=1000000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nconst int tetra_size = 185;\nint tetra[tetra_size];\nint tri[tetra_size];\nvoid settetra(){\n\ttetra[0] = 0;\n\ttri[0] = 0;\n\tfor(int i = 1; i < tetra_size; i++){\n\t\ttri[i] = tri[i-1] + i;\n\t\ttetra[i] = tetra[i-1] + tri[i];\n\t}\n}\n\nint dp[1000001];\nint dpodd[1000001];\nvoid setdp(){\n\tfill(dp, dp+1000001, INF);\n\tdp[0] = 0;\n\tfill(dpodd, dpodd+1000001, INF);\n\tdpodd[0] = 0;\n\tfor(int i = tetra_size ; i >= 1; i--){\n\t\tfor(int j = 0; j + tetra[i] < 1000001; j++ ){\n\t\t\tif(dp[j] == INF) continue;\n\t\t\tdp[j+tetra[i]] = min(dp[j]+1, dp[j+tetra[i]]);\n\t\t\tif(tetra[i]%2 == 1) dpodd[j+tetra[i]] = min(dpodd[j]+1, dpodd[j+tetra[i]]);\n\t\t}\n\t}\n}\n\nint main(){\n\tsettetra();\n\tsetdp();\n\tint n;\n\twhile(cin >> n, n){\n\t\t//cout << tetra[n]  << endl;\n\t\tcout << dp[n] << ' ' <<  dpodd[n]  << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvi llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\n\nint beam_width=15000;\n\nint bfs(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n        }\n        if(i<target){\n            q.pb(i);\n            mm=i;\n        }\n        if(i>target) break;\n    }\n    //auto mm=*max_element(beginend(q));\n    int cnt=0;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(llist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,llist){\n                if(k+x>target) break;\n                // if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.pb(k+x);\n            }\n\n            \n        }\n        sort(beginend(next));\n        next.erase( unique(beginend(next)),next.end());\n        int ns=next.size();\n        REP(i,ns-beam_width){\n            next.pop_front();\n        }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) {q.pb(i);mm=i;}\n        if(i>target) break;\n    }\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    //out(mm);\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(oddlist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                //if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.pb(k+x);\n            }\n        }\n        sort(beginend(next));\n        next.erase( unique(beginend(next)),next.end());\n        int ns=next.size();\n        REP(i,ns-beam_width){\n            next.pop_front();\n        }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    int mm=0;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n        mm=max(mm,n);\n    }\n    map<int,pii> m;\n    makeList(mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        //int ans2=0;\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nint dp[1000000];\nint dp_odd[1000000];\n\nint main(){\n\n\tmemset(dp,0x3f,sizeof(dp));\n\tmemset(dp_odd,0x3f,sizeof(dp_odd));\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdp_odd[0] = 0;\n\tdp_odd[1] = 1;\n\n\tfor(int i=0;i<=1000000;i++){\n\t\tfor(int j=1;j<=1000000;j++){\n\t\t\tint b = (j)*(j+1)*(j+2)/6;\n\t\t\tif(i+b >= 1000000) break;\n\t\t\tdp[i+b] = min(dp[i+b],dp[i] + 1);\n\t\t\tif(b % 2){\n\t\t\t\tdp_odd[i+b] = min(dp_odd[i+b],dp_odd[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tprintf(\"%d %d\\n\",dp[n],dp_odd[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 1000000\nusing ll = long long;\n\nint main(){\n    vector<ll> v;\n    vector<ll> odd_v;\n\n    for(ll i = 1; i < MAX; ++i){\n        ll num = i * (i + 1) * (i + 2) / 6;\n        v.push_back(num);\n        if(num & 1) odd_v.push_back(num);\n    }\n\n    int dp[MAX];\n    int odd_dp[MAX];\n    fill(dp, dp+MAX, INT_MAX);\n    fill(odd_dp, odd_dp+MAX, INT_MAX);\n    dp[0] = 0;\n    odd_dp[0] = 0;\n\n    for(int i = 0; i < MAX; ++i){\n        for(int j = 0; j < v.size(); ++j){\n            if(i - v[j] >= 0) dp[i] = min(dp[i - v[j]] + 1, dp[i]);\n            else break;\n        }\n\n        for(int j = 0; j < odd_v.size(); ++j){\n            if(i - odd_v[j] >= 0) odd_dp[i] = min(odd_dp[i - odd_v[j]] + 1, odd_dp[i]);\n            else break;\n        }\n    }\n\n    while(true){\n        int n; cin >> n;\n        if(!n) break;\n\n        cout << dp[n] << ' ' << odd_dp[n] << endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\n//int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint h;\nvector<int> vv;\nvector<int> vvb;\n\nint dp[1000000]={};\nint dpb[1000000]={};\nvoid pir_cal(){\n\tfor(int i=1;i<1000000;i++){\n\t\tdp[i]=1000000;\n\t\tdpb[i]=1000000;\n\t}\n\tfor(int i=1;i<200;i++){\n\t\tll j=(ll)i*(i+1)*(i+2)/6;\n\t\tif(j>=1000000){\n\t\t\tbreak;\n\t\t}\n\t\tvv.push_back(j);\n\t\tdp[j]=1;\n\t\tif(j%2==1){\n\t\t\tvvb.push_back(j);\n\t\t\tdpb[j]=1;\n\t\t}\n\t}\n\t/*for(int i=0;i<vv.size();i++)\n\t\tcout<<vv[i]<<endl;*/\n}\n\nvoid cal_dp(){\n\t\n\tfor(int i=1;i<1000000;i++){\n\t\t\n\t\tfor(int j=0;j<vv.size()&&vv[j]<i;j++){\n\t\t\tdp[i]=min(dp[i],dp[i-vv[j]]+1);\n\t\t\t\n\t\t}\n\t\tfor(int j=0;j<vvb.size()&&vvb[j]<i;j++){\n\t\t\tdpb[i]=min(dpb[i],dpb[i-vvb[j]]+1);\n\t\t\t\n\t\t}\n\t\t\n\t}\n}\n\t\t\nint main(){\n\tpir_cal();\n\tcal_dp();\n\twhile(1){\n\t\tcin>>h;\n\t\tif(h==0)break;\n\t\tprintf(\"%d %d\\n\",dp[h],dpb[h]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  vector<int> smt(1,0);\n  vector<int> ksmt(1,0);\n  int a;\n  for(int i=1;i<10000;i++){\n    a=i*(i+1)*(i+2)/6;\n    smt.push_back(a);\n    if(a%2==1)ksmt.push_back(a);\n    if(a>100000)break;\n  }\n  while(1){\n    cout <<smt.size()<<\" \"<<ksmt.size()<<endl;\n    int dp1[86][100000]={};\n    int dp2[23][100000]={};\n    //cout <<\"2\"<<endl;\n    int n;\n    cin >> n;\n    if(n==0)break;\n    //\n    for(int i=1;i<n;i++){\n      dp1[1][i]=i;\n      dp1[0][i]=i;\n      dp2[1][i]=i;\n      dp2[0][i]=i;\n    }\n    //all\n    for(int i=1;i<smt.size();i++){\n      if(smt[i]>n){\n\tcout << dp1[i-1][n]<<\" \";\n\tbreak;\n      }\n      for(int j=1;j<=n;j++){\n\tif(smt[i]>j) dp1[i][j]=dp1[i-1][j];\n\telse{\n\t  dp1[i][j]=min(dp1[i-1][j],dp1[i][j-smt[i]]+1);\n\t}\n      }\n    }\n    //kisuu\n    for(int i=1;i<smt.size();i++){\n      if(ksmt[i]>n){\n\tcout << dp2[i-1][n]<<endl;\n\tbreak;\n      }\n      for(int j=1;j<=n;j++){\n\tif(ksmt[i]>j) dp2[i][j]=dp2[i-1][j];\n\telse{\n\t  dp2[i][j]=min(dp2[i-1][j],dp2[i][j-ksmt[i]]+1);\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define INF 1000000\n\ninline int t(int x) { return x*(x+1)*(x+2)/6; }\n\nint dp[1000010];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  Vi one, two, odd;\n  for (int i = 1; t(i) <= 1000000; i++) {\n    one.push_back(t(i));\n    if (t(i)%2) odd.push_back(t(i));\n  }\n\n  for (int a : one) {\n    for (int b : one) {\n      two.push_back(a+b);\n    }\n  }\n  sort(ALL(two));\n\n  dp[0] = 0;\n  REP(i, 1000000) {\n    dp[i+1] = INF;\n    for (int a : odd) {\n      if (i+1-a < 0) break;\n      dp[i+1] = min(dp[i+1-a]+1, dp[i+1]);\n    }\n  }  \n\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    if (n == *lower_bound(ALL(one), n)) {\n      cout << 1;\n    } else if (n == *lower_bound(ALL(two), n)) {\n      cout << 2;\n    } else {\n      bool flag = false;\n      for (int a : one) {\n\tif (n - a == *lower_bound(ALL(two), n - a)) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if (flag) {\n\tcout << 3;\n      } else {\n\tfor (int a : two) {\n\t  if (n - a == *lower_bound(ALL(two), n - a)) {\n\t    flag = true;\n\t    break;\n\t  }\n\t}\n\tcout << (flag ? 4 : 5);\n      }\n    }\n\n    cout << ' ' << dp[n] << endl;\n\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    constexpr int MAX = 1000000;\n    ll now = 1;\n    vector<ll> v;\n    while(now*(now+1)*(now+2)/6 <= MAX) {\n        ll t = now*(now+1)*(now+2)/6;\n        v.push_back(t);\n        now++;\n    }\n    vector<int> dp1(MAX+1, INF);\n    vector<int> dp2(MAX+1, INF);\n    dp1[0] = dp2[0] = 0;\n    for(auto t : v) {\n        for(int i=0; i+t<=MAX; ++i) {\n            dp1[i+t] = min(dp1[i+t], dp1[i] + 1);\n            if(t & 1) {\n                dp2[i+t] = min(dp2[i+t], dp2[i] + 1);\n            }\n        }\n    }\n    int n;\n    while(cin >> n, n) {\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define POL_MAX 200\n#define N_MAX 1000000\nusing namespace std;\n\nint N;\nint dp[N_MAX+1];\nint odd_dp[N_MAX+1];\nconst int INF = INT_MAX / 3;\n\nint main(){\n\n\tint n=1;\n\tint value=0;\n\tvector<int> pol, kisu_pol;\n\twhile(true) {\n\t\tvalue = n*(n+1)*(n+2) / 6;\n\t\tif (value >= N_MAX) { break; }\n\t\tpol.push_back(value);\n\t\tif (value % 2 != 0) { kisu_pol.push_back(value); }\n\t\tn++;\n\t}\n\n\trep(j, N_MAX+1) { dp[j] = j; }\n\tREP(j, 1, N_MAX+1) {\n\t\tREP(i, 1, pol.size()) {\n\t\t\tif(j<pol[i]) break;\n\t\t\tdp[j] = min(dp[j], dp[j-pol[i]] + 1);\n\t\t}\n\t}\n\t\n\trep(j, N_MAX+1) { odd_dp[j] = j; }\n\tREP(j, 1, N_MAX+1) {\n\t\tREP(i, 1, kisu_pol.size()) {\n\t\t\tif(j<kisu_pol[i]) break;\n\t\t\todd_dp[j] = min(odd_dp[j], odd_dp[j-kisu_pol[i]] + 1);\n\t\t}\n\t}\n\t\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tcout << dp[N] << \" \" << odd_dp[N] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_N 1000000\n\nint ans[MAX_N+10];\nint oddAns[MAX_N+10];\n\nvoid solve(int N){\n  cout<<ans[N]<<\" \"<<oddAns[N]<<endl;\n}\n\nint main(){\n  int res=0;\n  int sum=0;\n  vector<int> num;\n  vector<int> oddNum;\n  for(int i=1;i<=185;i++){\n    sum+=i;\n    res+=sum;\n    if(res%2) oddNum.push_back(res);\n    num.push_back(res);\n  }\n\n  for(int i=1;i<=MAX_N;i++){\n    ans[i]=MAX_N;\n    oddAns[i]=MAX_N;\n  }\n\n  for(int j=0;j<num.size();j++){\n    for(int i=0;i<=MAX_N;i++){\n      if(i+num[j]<=MAX_N) ans[i+num[j]]=min(ans[i+num[j]],ans[i]+1);\n    }\n    if(num[j]%2){\n      for(int i=0;i<=MAX_N;i++){\n        if(i+num[j]<=MAX_N) oddAns[i+num[j]]=min(oddAns[i+num[j]],oddAns[i]+1);\n      }\n    }\n  }\n\n  while(1){\n    int N;\n    cin>>N;\n    if(N==0) break;\n    solve(N);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define REP(i,l,n) for(int i=l;i<n;++i)\nint ans = 0;\nint oddans = 0;\nint pol[180];\nint oddpol[50];\nint oddpolcount = 0;\nint memo[100000];\nint oddmemo[1000000];\nint memorep(int n);\nint oddmemorep(int n);\nusing namespace std;\nint main() {\n  pol[0] = 1;\n  oddpol[oddpolcount++] = 1;\n  int def = 3;\n  int defdef = 3;\n  REP(i,1,180){\n    pol[i] = pol[i-1] + def;\n    if(pol[i]%2==1) oddpol[oddpolcount++] = pol[i];\n    def += defdef++;\n  }\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    ans = memorep(n);\n    oddans = oddmemorep(n);\n    cout << ans << \" \" << oddans << endl;\n  }\n  return 0;\n}\n\nint memorep(int n){\n  if(memo[n]!=0) return memo[n];\n  int result;\n  int min = 100000;\n  for(int i = 179;i>=0;i--){\n    result = n-pol[i];\n    if(result == 0){\n      return memo[n] = 1;\n    }\n    if(result > 0){\n      result = memorep(result) + 1;\n      if(min > result) min = result;\n    }\n  }\n  return memo[n] = min;\n}\n\nint oddmemorep(int n){\n  if(oddmemo[n]!=0) return oddmemo[n];\n  int result;\n  int min = 1000000;\n  for(int i = oddpolcount-1;i>=0;i--){\n    result = n-oddpol[i];\n    if(result == 0){\n      return oddmemo[n] = 1;\n    }\n    if(result > 0){\n      result = oddmemorep(result) + 1;\n      if(min > result) min = result;\n    }\n  }\n  return oddmemo[n] = min;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = (1<<30)-1;\n\nint dp1[1000045], dp2[1000045];\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return (false);\n    \n    cout << dp1[N] << \" \" << dp2[N] << endl;\n    return (true);\n}\n\nint main() {\n    fill_n(dp1, 1000045, INF);\n    fill_n(dp2, 1000045, INF);\n    \n    dp1[0] = 0;\n    dp2[0] = 0;\n    for (int i = 0; i <= 1000000; i++) {\n        for (int j = 1; i + j * (j + 1) * (j + 2) / 6 <= 1000000; j++) {\n            int val = j*(j+1)*(j+2)/6;\n            dp1[i + val] = min(dp1[i + val], dp1[i] + 1);\n            if (val & 1) dp2[i + val] = min(dp2[i + val], dp2[i] + 1);\n        }\n    }\n    while (solve());\n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;n<=p[i];i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;n<=p[i];i++) if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<185;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[100][100] = {{0}, {0}};\n\n  for (i = 1; i <= 180; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  int a = 0;\n  while (cin >> input) {\n    if (input == 0) break;\n    int temp = input;\n    int j = 1, min = 1000000000;\n    while (tetras[j] <= input) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j++;\n      input = temp;\n    }\n    ans[a][0] = min;\n    j = 1, min = 1000000000;\n    while (tetras[j] <= input) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tif (tetras[k] % 2 == 0) {\n\t  k--;\n\t  continue;\n\t}\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j++;\n      input = temp;\n    }\n    ans[a][1] = min;\n    a++;\n  }\n\n  int b;\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\nusing namespace std;\n\nvector<int> n;\nvoid mkn(){\n  n.push_back(1);\n  for(int i=2;n[i-2]<1005000;i++){\n    n.push_back(i*(i+1)*(i+2)/6);\n  }\n}\n\n\nvector<int> dp;\nvector<int> dp2;\nvoid mktable(){\n  dp.resize(1000100);\n  dp2.resize(1000100);\n  for(int i=0;i<dp.size();i++){\n    dp[i]=1000100;\n    dp2[i]=1000100;\n  }\n  dp[0]=dp2[0]=0;\n  for(int i=0;i<n.size();i++){\n    for(int j=0;j<dp.size();j++){\n      if(n[i]%2==1){\n        if(j-n[i]>=0){\n          dp2[j]=min(dp2[j],dp2[j-n[i]]+1);\n        }else{\n          dp2[j]=dp2[j];\n        }\n      }\n      if(j-n[i]>=0){\n        dp[j]=min(dp[j],dp[j-n[i]]+1);\n      }else{\n        dp[j]=dp[j];\n      }\n    }\n  }\n}\n\nvoid init(){\n  n.clear();\n  dp.clear();\n  mkn();\n  mktable();\n}\n\nbool solve(){\n  int a;\n  cin>>a;\n  if(a==0){\n    return false;\n  }\n  cout<<dp[a]<<\" \"<<dp2[a]<<endl;\n  return true;\n}\nint main(){\n  init();\n  while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <tuple>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <bitset>\nusing namespace std;\nusing ll=long long;\nusing intpair=pair<int,int>;\nusing intpv=vector<intpair>;\nusing llpair=pair<ll,ll>;\nusing llpv=vector<llpair>;\nusing intvec=vector<int>;\nusing llvec=vector<ll>;\nusing intq=queue<int>;\nusing llq=queue<ll>;\nusing intmat=vector<intvec>;\nusing llmat=vector<llvec>;\nusing pairmat=vector<llpv>;\n#define matrix(T) vector<vector<T>>\n#define PI 3.141592653589793\n#define INTINF 1<<30\n#define LLINF 1LL<<60\n#define MPRIME 1000000007\n#define pqueue priority_queue\n#define pushb push_back\n#define all(name) name.begin(),name.end()\n#define rall(name) name.rbegin(),name.rend()\n#define ABS(x) ( (x)>0 ? (x) : -(x) )\n#define gsort(vbeg,vend) sort(vbeg,vend,greater<>())\n#define init(v) for(auto &a_: v) cin>>a_\n#define out(n) cout<<n<<endl\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nll GCD(ll a, ll b) { //最大公約数\n\tif(a==0||b==0) return 0;\n\tif(a<b) swap(a,b);\n\tll tmp = a%b;\n\twhile(tmp!=0) {\n\t\ta = b;\n\t\tb = tmp;\n\t\ttmp = a%b;\n\t}\n\treturn b;\n}\n\nll binpow(ll a, ll ex, ll p) { //繰り返し二乗法\n\tll result=1LL;\n\twhile(ex>0) {\n\t\tif(ex&1) result=result*a%p;\n\t\tex>>=1;\n\t\ta=a*a%p;\n\t}\n\treturn result;\n}\n\nll Fact(ll x, ll p) { //階乗\n\tll f=1;\n\tfor(ll i=2; i<=x; i++) {\n\t\tf*=i;\n\t\tf%=p;\n\t}\n\treturn f;\n}\n\nll nPr(ll n, ll r) {\n\tif(n<r) return 0;\n\n\tll result=1LL;\n\tfor(ll i=0; i<r; i++) result*=n-i;\n\treturn result;\n}\n\nll nPrP(ll n, ll r, ll p) { // mod pにおけるnPr\n\tif(n<r) return 0;\n\n\tll result=1LL;\n\tfor(int i=0; i<r; i++) {\n\t\tresult*=n-i;\n\t\tresult%=p;\n\t}\n\treturn result;\n}\n\nll nCr(ll n, ll r) {\n\tif (n == r) { return 1; }\n\tif (r > n) { return 0; }\n\n\tif (r > n / 2) { r = n - r; }\n\n\tif (n == 0) { return 0; }\n\tif (r == 0) { return 1; }\n\tif (r == 1) { return n; }\n\n\tdouble result = 1;\n\tfor (double i = 1; i <= r; i++) {\n\t\tresult *= (n - i + 1) / i;\n\t}\n\n\treturn (ll)result;\n}\n\nllvec fact,inv,factinv;\nvoid prenCrP(ll n, ll p) {\n\tfact.resize(n+1);\n\tinv.resize(n+1);\n\tfactinv.resize(n+1);\n\tfact[0]=fact[1]=inv[1]=factinv[0]=factinv[1]=1LL;\n\tfor(ll i=2LL; i<=n; i++) {\n\t\tfact[i]=fact[i-1]*i%p;\n\t\tinv[i]=p-inv[p%i]*(p/i)%p;\n\t\tfactinv[i]=factinv[i-1]*inv[i]%p;\n\t}\n}\nll nCrP(ll n, ll r, ll p) { // mod pにおけるnCr\n\tif (r > n) return 0;\n\treturn fact[n]*factinv[r]%p*factinv[n-r]%p;\n}\n\nllvec fact2,inv2,factinv2;\nvoid prenCrP2(ll n, ll r, ll p) { // nがバカでかいときに使う, 計算量はr依存\n\tfact2.resize(r+1);\n\tinv2.resize(r+1);\n\tfactinv2.resize(r+1);\n\tfact2[0]=n%p, fact2[1]=n%p*(n-1)%p;\n\tinv2[1]=factinv2[0]=factinv2[1]=1LL;\n\tfor(ll i=2LL; i<=r; i++) {\n\t\tfact2[i]=fact2[i-1]*(n-i)%p;\n\t\tinv2[i]=p-inv2[p%i]*(p/i)%p;\n\t\tfactinv2[i]=factinv2[i-1]*inv2[i]%p;\n\t}\n}\nll nCrP2(ll r, ll p) {\n\treturn fact2[r-1]*factinv2[r]%p;\n}\n\nint DigitNum(ll n) { //桁数\n\tint digit=0;\n\tll wari=1LL;\n\twhile(n/wari) {\n\t\tdigit++;\n\t\twari*=10;\n\t}\n\treturn digit;\n}\n\nbool IsPrime(ll num) { //素数判定\n\tif (num < 2) return false;\n\telse if (num == 2) return true;\n\telse if (num % 2 == 0) return false; // 偶数はあらかじめ除く\n\n\tdouble sqrtNum = sqrt(num);\n\tfor (ll i = 3; i <= sqrtNum; i += 2)\n\t{\n\t\tif (num % i == 0)\n\t\t{\n\t\t\t// 素数ではない\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// 素数である\n\treturn true;\n}\n\nvector<ll> Divisor(ll x) { // 約数列挙\n\tvector<ll> result;\n\tll i=1LL;\n\tfor( ; i*i<x; i++) {\n\t\tif(x%i) continue;\n\t\tresult.push_back(i);\n\t\tresult.push_back(x/i);\n\t}\n\tif(i*i==x&&x%i==0)\n\t\tresult.push_back(i);\n\t\n\tsort(result.begin(),result.end());\n\treturn result;\n}\n\nvector<llpair> PrimeFact(ll x) { // 素因数分解 {素因数,指数}\n\tvector<llpair> result;\n\tll ex=0LL;\n\tif(x%2==0) {\n\t\twhile(x%2==0) {\n\t\t\tx/=2;\n\t\t\tex++;\n\t\t}\n\t\tresult.push_back({2,ex});\n\t}\n\n\tfor(ll i=3LL; i*i<=x; i+=2) {\n\t\tif(x%i) continue;\n\n\t\tex=0LL;\n\t\twhile(x%i==0) {\n\t\t\tx/=i;\n\t\t\tex++;\n\t\t}\n\t\tresult.push_back({i,ex});\n\t}\n\n\tif(x!=1) result.push_back({x,1});\n\n\treturn result;\n}\n\nbool Palind(string s) { //回文判定\n\treturn s == string(s.rbegin(), s.rend());\n}\n\nstruct Union_Find {\n\tvector<int> parent; //親\n\tvector<int> num; //根としたときの木サイズ\n\n\tUnion_Find(int N) : parent(N),num(N,1) {\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tparent[i]=i;\n\t\t}\n\t}\n\n\tint root(int x) {\n\t\tif(parent[x]==x) return x;\n\t\treturn parent[x]=root(parent[x]);\n\t}\n\n\tvoid merge(int x, int y) {\n\t\tint xrt=root(x);\n\t\tint yrt=root(y);\n\t\tif(xrt==yrt) return;\n\t\tparent[xrt]=yrt;\n\t\tnum[yrt]+=num[xrt];\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x)==root(y);\n\t}\n\n\tint size(int x) {\n\t\treturn num[root(x)];\n\t}\n};\n\nstruct Ford_Fulkerson {\n\tstruct _edge {\n\t\tint next;\n\t\tint rev; // 逆辺の_edgeがG[next][rev]に存在する\n\t\tll cap;\n\t};\n\n\tvector<vector<_edge>> G;\n\tvector<bool> used;\n\n\tFord_Fulkerson(int N) : G(N),used(N) {}\n\n\tvoid add_edge(int from, int to, ll cap) {\n\t\tG[from].push_back((_edge){to,(int)G[to].size(),cap});\n\t\tG[to].push_back((_edge){from,(int)G[from].size()-1,0});\n\t}\n\n\tll f_dfs(int s, int t, ll flow) {\n\t\tif(s==t) return flow;\n\t\tused[s]=true;\n\t\tfor(_edge &ed : G[s]) {\n\t\t\tif(!used[ed.next] && ed.cap>0) {\n\t\t\t\tll captmp=f_dfs(ed.next,t,min(flow,ed.cap));\n\t\t\t\tif(captmp>0) {\n\t\t\t\t\ted.cap-=captmp;\n\t\t\t\t\tG[ed.next][ed.rev].cap+=captmp;\n\t\t\t\t\treturn captmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0LL;\n\t}\n\n\tll max_flow(int s, int t) {\n\t\tll res=0LL;\n\t\twhile(1) { // 最大になるまで繰り返し\n\t\t\tused.assign(used.size(),false);\n\t\t\tll restmp=f_dfs(s,t,LLINF);\n\t\t\tif(restmp==0) return res;\n\t\t\tres+=restmp;\n\t\t}\n\t}\n};\n\n\nint N;\nint dp[1000000];\nint dpodd[1000000];\n\nvoid input() {\n\tcin>>N;\n}\n\nvoid calc() {\n\tfor(int i=1; i<1000000; i++) dp[i]=dpodd[i]=INTINF;\n\tdp[0]=dpodd[0]=0;\n\tint num=1;\n\tfor(int i=1; num<1000000; i++,num=i*(i+1)*(i+2)/6) {\n\t\tfor(int j=0; j+num<1000000; j++) chmin(dp[j+num],dp[j]+1);\n\t\tif(num%2==1)\n\t\t\tfor(int j=0; j+num<1000000; j++) chmin(dpodd[j+num],dpodd[j]+1);\n\t}\n}\n\nvoid solve() {\n\tcout<<dp[N]<<\" \"<<dpodd[N]<<endl;\n}\n\nint main() {\n\tcalc();\n\twhile(1) {\n\t\tinput();\n\t\tif(N==0) break;\n\t\tsolve();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30)\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int yon[200] = {};\n    rep(i,0,200){\n        yon[i] = i*(i+1)*(i+2)/6;\n    }\n//    vector<vector<int> > dp1(1000001,vector<int>()),dp2(1000001,vector<int>());\n    vector<int> dp1(1000001,INF),dp2(1000001,INF);\n    dp1[0] = dp2[0] = 0;\n    for(int i = 0; i < 1000001; i++){\n        rep(j,0,200){\n            if(i + yon[j] < 1000001){\n                dp1[i + yon[j]] = min(dp1[i] + 1,dp1[i + yon[j]]);\n                if(yon[j] % 2){\n                    dp2[i + yon[j]] = min(dp2[i] + 1,dp2[i + yon[j]]);\n                }\n            }\n        }\n    }\n\n    while(true){\n        int tmp;\n        cin >> tmp;\n        if(tmp == 0) break;\n        cout << dp1[tmp] << \" \" << dp2[tmp] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[10000];\n    //fill(dp,dp + x+1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[190]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    ll s4[201];\n    vector<ll> s4_k;\n    REP(i, 201){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    vector<ll> dp1(1000001, INF), dp2(1000001, INF);\n    dp1[0] = 0;\n    REP(i, 201){\n        REP(j, 1000001){\n            if(s4[i] <= j){\n                dp1[j] = min(dp1[j], dp1[j - s4[i]] + 1);\n            }\n        }\n    }\n    \n    dp2[0] = 0;\n    REP(i, s4_k.size()){\n        REP(j, 1000001){\n            if(s4_k[i] <= j){\n                dp2[j] = min(dp2[j], dp2[j - s4_k[i]] + 1);\n            }\n        }\n    }\n    \n    ll n;\n    cin >> n;\n    \n    while(n != 0){\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n        \n        cin >> n;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<ll> p;\nvector<ll> o;\nvector<ll> memo(1000001, INF);\n\nll cal(ll n) {\n\tif(memo[n] != INF) return memo[n];\n\telse {\n\t\tll ans = INF;\n\t\tll i = o.size() - 1;\n\t\twhile(i >= 0) {\n\t\t\tans = min(ans, 1 + cal(n - o[i]));\n\t\t\t--i;\n\t\t}\n\t\treturn memo[n] = ans;\n\t}\n}\n\nint main(void) {\n\n\tfor(ll i = 0; i * (i + 1) * (i + 2) / 6 <= 1000000; ++i) {\n\t\tp.pb(i * (i + 1) * (i + 2) / 6);\n\t\tif((i * (i + 1) * (i + 2) / 6) % 2 == 1) o.pb(i * (i + 1) * (i + 2) / 6);\n\t}\n\tvector<P> nf;\n\tmap<ll, ll> nb;\n\tREP(i, p.size()) {\n\t\tREP(j, p.size()) {\n\t\t\tif(p[i] + p[j] > 1000000) continue;\n\t\t\tnf.pb(P(p[i] + p[j], (ll)(p[i] != 0) + (ll)(p[j] != 0)));\n\t\t\tREP(k, p.size()) {\n\t\t\t\tif(nb.count(p[i] + p[j] + p[k]) != 0)\n\t\t\t\tnb[p[i] + p[j] + p[k]] = min(nb[p[i] + p[j] + p[k]], (ll)(p[i] != 0) + (ll)(p[j] != 0) + (ll)(p[k] != 0));\n\t\t\t\telse\n\t\t\t\tnb[p[i] + p[j] + p[k]] = (ll)(p[i] != 0) + (ll)(p[j] != 0) + (ll)(p[k] != 0);\n\t\t\t}\n\t\t}\n\t}\n\tmemo[0] = 0;\n\tREP(i, o.size()) {\n\t\tmemo[o[i]] = 1;\n\t}\n\twhile(true) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tll ans1 = INF, ans2 = INF;\n\t\tREP(i, nf.size()) {\n\t\t\tif(nb.count(n - nf[i].first) != 0) {\n\t\t\t\tans1 = min(ans1, nf[i].second + nb[n - nf[i].first]);\n\t\t\t}\n\t\t}\n\t\tans2 = cal(n);\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\n\nconst int H = 1000001;\n\nint ans[H];\nint anso[H];\n\nvoid build() {\n\n    iota(ans, ans + H, 0);\n    iota(anso, anso + H, 0);\n\n    for (int n = 2, q; (q = n*(n + 1)*(n + 2) / 6) < H; ++n) {\n        for (int i = 0; i+q < H; ++i)\n            minset(ans[i + q], ans[i] + 1);\n        if (q%2)\n            for (int i = 0; i + q < H; ++i)\n                minset(anso[i + q], anso[i] + 1);\n    }\n\n}\n\nvoid solve() {\n    int k;\n    while (scanner >> k, k > 0) {\n        printer << ans[k] << ' ' << anso[k] << '\\n';\n    }\n}\n\nint main() {\n\n    build(); solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NUM 200\nvector<long long int>data1( NUM );\nvector<long long int>data2;\nvector<long long int>memo1;\nvector<long long int>memo2;\n\nlong long int saiki1( long long int N ) {\n\tif( N < 0 ) {\n\t\treturn INT_MAX / 6;\n\t}\n\tif( memo1[N] != INT_MAX / 6 ) {\n\t\treturn memo1[N];\n\t}\n\tlong long int ret = INT_MAX / 6;\n\tauto ite = lower_bound( data1.begin(), data1.end(), N );\n\twhile( ite != data1.begin() ) {\n\t\tret = min( ret, saiki1( N - (*ite) ) + 1 );\n\t\tite--;\n\t}\n\tif( ret == INT_MAX / 6 ) {\n\t\tret = N;\n\t}\n\treturn memo1[N] = ret;\n}\n\nlong long int saiki2( long long int N ) {\n\tif( N < 0 ) {\n\t\treturn INT_MAX / 6;\n\t}\n\tif( memo2[N] != INT_MAX / 6 ) {\n\t\treturn memo2[N];\n\t}\n\tlong long int ret = INT_MAX / 6;\n\tauto ite = lower_bound( data2.begin(), data2.end(), N );\n\twhile( ite != data2.begin() ) {\n\t\tret = min( ret, saiki2( N - (*ite) ) + 1 );\n\t\tite--;\n\t}\n\n\tif( ret == INT_MAX / 6 ) {\n\t\tret = N;\n\t}\n\treturn memo2[N] = ret;\n}\n\nint main() {\n\tmemo1.resize( 1e6, INT_MAX / 6 );\n\tmemo2.resize( 1e6, INT_MAX / 6 );\n\tiota( data1.begin(), data1.end(), 1 );\n\tfor( size_t i = 1; i < NUM; i++ ) {\n\t\tdata1[i] += data1[i - 1];\n\t}\n\tfor( size_t i = 1; i < NUM; i++ ) {\n\t\tdata1[i] += data1[i - 1];\n\t}\n\tfor( size_t i = 0; i < NUM; i++ ) {\n\t\tif( data1[i] % 2 ) {\n\t\t\tdata2.emplace_back( data1[i] );\n\t\t}\n\t}\n\tlong long int N;\n\twhile( cin >> N, N ) {\n\t\tcout << saiki1( N ) << \" \" << saiki2( N ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<deque>\n#include<numeric>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<limits>\n#include<functional>\n#include<unordered_set>\n#include<iomanip>\n#include<cassert>\n#include<regex>\n#include<bitset>\n#include<complex>\n#include<chrono>\n#include<random>\n#define rep(i,a) for(int i=(int)0;i<(int)a;++i)\n#define rrep(i,a) for(int i=(int)a-1;i>=0;--i)\n#define REP(i,a,b) for(int i=(int)a;i<(int)b;++i)\n#define RREP(i,a,b) for(int i=(int)a-1;i>=b;--i)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nusing ll=long long;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\n\nll gcd(ll n, ll m) {\n\tll tmp;\n\twhile (m!=0) {\n\t\ttmp = n % m;\n\t\tn = m;\n\t\tm = tmp;\n\t}\n\treturn n;\n}\n\nll lcm(ll n, ll m) {\n\treturn abs(n) / gcd(n, m)*abs(m);//gl=xy\n}\n \ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \nusing namespace std;\n\nint n;\n\nint f[205];\nvector<int>dp,dp2;\n\nvoid calc(){\n  for(int i=1;i<=200;++i){\n    f[i]=(i*(i+1)*(i+2))/6;\n  }\n}\n\nvoid solve(){\n  //個数制限なしナップサック1dver\n  dp.resize(1e6+5,1e6),dp2.resize(1e6+5,1e6);\n  dp[0]=0;dp2[0]=0;\n  rep(i,200){\n    rep(j,1e6+5){\n      if(j-f[i]>=0)chmin(dp[j],dp[j-f[i]]+1);\n    }\n  }\n  rep(i,200){\n    rep(j,1e6+5){\n      if(f[i]%2==1){\n        if(j-f[i]>=0)chmin(dp2[j],dp2[j-f[i]]+1);\n      }\n    }\n  }\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n  cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n  calc();\n  solve();\n  while(1){\n    cin>>n;\n    if(n==0)return 0;\n    cout<<dp[n]<<\" \"<<dp2[n]<<\"\\n\";\n  }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 1e9\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int dp[1000010]={};\n  int dpki[1000010]={};\n  int n;\n  for(int i=0;i<1000010;i++){\n    dp[i]=dpki[i]=i;\n  }\n  for(int i=2;((i*(i+1)*(i+2))/6)<1000001;i++){\n    int num=(i*(i+1)*(i+2))/6;\n    for(int j=0;j+num<=1000000;j++){\n      if((num%2)){\n\tdpki[j+num]=min(dpki[j]+1,dpki[j+num]);\n      }\n      dp[j+num]=min(dp[j]+1,dp[j+num]);\n    }\n  }\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dpki[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define IOS std::cin.tie(0),std::ios::sync_with_stdio(false)\n\nnamespace idaten {\n\n\tusing namespace std;\n\tusing ll = int_fast64_t;\n\tusing ull = uint_fast64_t;\n\tusing P = std::pair<int64_t, int64_t>;\n\ttemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\n\ttemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\n\ttemplate<class Type>struct is_vector : std::false_type {};\n\ttemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\n\ttemplate <typename T> inline std::ostream& operator << (std::ostream& out, const std::vector<T>& v) {\n\t\tif (v.empty())return out;\n\t\tconstexpr bool is_vector_v = is_vector<T>::value;\n\t\tif (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n\t\telse for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n\t\treturn out;\n\t}\n\tinline void put() {}\n\ttemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\n\ttemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\n\tinline void putn() {}\n\ttemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\n\tvoid solve() {\n\t\tIOS;\n\t\tvector<int> pre;\n\t\tint m = 1e6;\n\t\tfor (int i = 1;; i++) {\n\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\tif (t <= m) {\n\t\t\t\tpre.push_back(t);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> dp(m + 1, INT_MAX), dp2(m + 1, INT_MAX);\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\tREP(i, m) {\n\t\t\tREP(j, pre.size()) {\n\t\t\t\tif (i + pre[j] <= m) {\n\t\t\t\t\tchmin(dp[i + pre[j]], dp[i] + 1);\n\t\t\t\t\tif (pre[j] % 2 == 1) {\n\t\t\t\t\t\tchmin(dp2[i + pre[j]], dp2[i] + 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n;\n\t\tcin >> n;\n\t\twhile (n) {\n\t\t\tput(dp[n], dp2[n]);\n\t\t\tcin >> n;\n\t\t}\n\t}\n} // namespace idaten\n\nint main() {\n\tidaten::solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nbool solveBarance(string str){\n\n\tstack<char> st;\n\n\tfor(int i=0;str[i]!='.';i++){\n\t\tif(str[i]=='(' || str[i]=='['){\n\t\t\tst.push(str[i]);\n\t\t}\n\t\telse if(str[i]==']'){\n\t\t\tif(st.size()==0) return false;\n\t\t\tif(st.top()=='[') st.pop();\n\t\t\telse return false;\n\t\t}\n\t\telse if(str[i]==')'){\n\t\t\tif(st.size()==0) return false;\n\t\t\tif(st.top()=='(') st.pop();\n\t\t\telse return false;\n\t\t}\n\t\t\t\n\t}\n\n\tif(st.size()!=0) return false;\n\treturn true;\n}\n\nint main(void){\n\tstring str;\n\twhile(true){\n\t\tgetline(cin,str);\n\t\tif(str[0]=='.') break;\n\t\tcout << (solveBarance(str)?\"yes\":\"no\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint main() {\n\tvector<int> p;\n\tvector<int> op;\n\n\tfor (int i = 1;;i++) {\n\t\tint n = ((i + 1) * (i + 2) * (i)) / 6;\n\t\tif (n >= 1000000)break;\n\t\tif (n % 2 == 1) {\n\t\t\top.push_back(n);\n\t\t}\n\t\tp.push_back(n);\n\t}\n\n\tint *ans = new int[1000000];\n\tint *oans=new int[1000000];\n\n\tfor (int i = 0;i < 1000000;i++) {\n\t\tans[i] = oans[i] = i;\n\t}\n\tfor (int i = 1;i < 1000000;i++) {\n\t\tfor (int j = 0;;j++) {\n\t\t\tif (j >= p.size())break;\n\t\t\tif (p[j] > i)break;\n\t\t\tans[i] = min(ans[i], 1 + ans[i - p[j]]);\n\t\t}\n\t\tfor (int j = 0;;j++) {\n\t\t\tif (j >= op.size())break;\n\t\t\tif (op[j] > i)break;\n\t\t\toans[i] = min(oans[i], 1 + oans[i - op[j]]);\n\t\t}\n\t}\n\tint tmp;\n\twhile (1) {\n\t\tcin >> tmp;\n\t\tif (tmp == 0)break;\n\t\tcout << ans[tmp] << \" \" << oans[tmp] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconstexpr int N=1000000;\n\nint main() {\n  std::vector<int> all, odd;\n\n  for (int i=1; true; ++i) {\n    int n=i*(i+1)*(i+2)/6;\n    if (n > 1000000)\n      break;\n\n    all.push_back(n);\n    if (n % 2 == 1)\n      odd.push_back(n);\n  }\n\n  std::vector<int> dp_all(N, N), dp_odd(N, N);\n  dp_all[0] = dp_odd[0] = 0;\n  dp_all[1] = dp_odd[1] = 1;\n  for (int i=1; i<N; ++i) {\n    for (int a: all) {\n      if (a > i) break;\n\n      dp_all[i] = std::min(dp_all[i], dp_all[i-a]+1);\n    }\n\n    for (int o: odd) {\n      if (o > i) break;\n\n      dp_odd[i] = std::min(dp_odd[i], dp_odd[i-o]+1);\n    }\n  }\n\n  while (true) {\n    int q;\n    scanf(\"%d\", &q);\n    if (q == 0)\n      break;\n\n    printf(\"%d %d\\n\", dp_all[q], dp_odd[q]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nint p[1000001];\nint memo[1000001][6];\nint memo2[1000001];\n\nint solve(int n, int count){\n\n  if(!n) return 0;\n  if(n <= 0 || !count) return INF;\n  if(memo[n][count]) return memo[n][count];\n\n  int ans = INF;\n  for(int i=0;p[i]<=n; i++){\n    ans = min(ans, solve(n-p[i], count-1)+1);\n  }\n\n  return memo[n][count] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n\n  int ans = INF;\n  for(int i=0;p[i]<=n; i++){\n    if(!(p[i]%2)) continue;\n    ans = min(ans, solve2(n-p[i])+1);\n  }\n\n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n\n  for(int i=0;i<=1000000;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i++) solve(n, 5), solve2(i);\n\n  while(cin >> n, n)\n    cout << solve(n, 5) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 1e6+10\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\nusing namespace std;\n#define int ll\n\nvector<int>precal;\nvector<int>dp(MAX,MAX);\nvector<bool>flag(MAX+10,false);\nsigned main(){\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=(int)(upper_bound(precal.begin(),precal.end(),i)-precal.begin());\n        for(int j=0; j<=index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX,MAX);\n    vector<bool>oddflag(MAX+10,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=(int)(upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin());\n        for(int j=0;j<=index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 2;\ndouble eps = 1e-11;\n\nint dp[2][1000010];\nint dpodd[2][1000010];\n\nint main() {\n    int num[200];\n    int oddnum[200];\n    int odd = 1;\n    int N = 1000000;\n    for (int i = 1; i < 200; i++) {\n        num[i] = i * (i + 1) * (i + 2) / 6;\n        if (num[i] % 2 == 1) {\n            oddnum[odd] = num[i];\n            odd++;\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        fill(dp[i], dp[i] + N + 10, iinf);\n        fill(dpodd[i], dpodd[i] + N + 10, iinf);\n    }\n    dp[0][0] = 0;\n    int last = 0;\n    for (int i = 1; i < 200; i++) {\n        fill(dp[i % 2], dp[i % 2] + N + 10, iinf);\n        if (num[i] > N) {\n            last = i - 1;\n            break;\n        }\n        for (int j = 0; j <= N; j++) {\n            if (j < num[i]) {\n                dp[i % 2][j] = dp[(i + 1) % 2][j];\n            } else {\n                dp[i % 2][j] = min(dp[(i + 1) % 2][j], dp[i % 2][j - num[i]] + 1);\n            }\n        }\n    }\n    dpodd[0][0] = 0;\n    int oddlast = 0;\n    for (int i = 1; i < odd; i++) {\n        fill(dpodd[i % 2], dpodd[i % 2] + N + 10, iinf);\n        if (oddnum[i] > N) {\n            oddlast = i - 1;\n            break;\n        }\n        for (int j = 0; j <= N; j++) {\n            if (j < oddnum[i]) {\n                dpodd[i % 2][j] = dpodd[(i + 1) % 2][j];\n            } else {\n                dpodd[i % 2][j] = min(dpodd[(i + 1) % 2][j], dpodd[i % 2][j - oddnum[i]] + 1);\n            }\n        }\n    }\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        cout << dp[last % 2][n] << \" \" << dpodd[oddlast % 2][n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n  vector<int> sqNum;\n  vector<int> oddSqNum;\n  for(int i=1; i<202; i++){\n    int num = i*(i+1)*(i+2)/6;\n    sqNum.PB( num );\n    if(num%2==1)\n      oddSqNum.PB( num );\n  }\n\n  int n;\n  while(cin>>n,n){\n\n    int dp[n+1], oddDp[n+1];  // the number of 4-sq to represent i\n    fill( dp, dp+n+1, INF );\n    fill( oddDp, oddDp+n+1, INF );\n    dp[0] = 0;\n    oddDp[0] = 0;\n\n    REP(i,n+1){\n      REP(j,sqNum.size()){\n\tif( i-sqNum[j] >= 0 ){\n\t  dp[i] = min( dp[i], dp[i-sqNum[j]]+1 );\n\t}\n      }\n\n      REP(j,oddSqNum.size()){\n\tif( i-oddSqNum[j] >= 0 ){\n\t  oddDp[i] = min( oddDp[i], oddDp[i-oddSqNum[j]]+1 );\n\t}\t\n      }\n    }\n\n    cout << dp[n] << \" \" << oddDp[n] << endl;\n\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nchar ans1[1000001],ans2[1000001];\n\nint main(){\n    int t[181];\n    \n    for(int i = 1;i <= 180;++i)\n        t[i] = i * (i + 1) * (i + 2) / 6;\n    \n    ans1[0] = ans2[0] = 0;\n    \n    for(int i = 1;i <= 1000000;++i){\n        ans1[i] = 5;\n        ans2[i] = 40;\n    }\n    \n    for(int i = 1;i <= 180;++i)\n        for(int j = i;j <= 180 && t[i] + t[j] <= 1000000;++j)\n            for(int k = j;k <= 180 && t[i] + t[j] + t[k] <= 1000000;++k)\n                ans1[ t[i] + t[j] + t[k] ] = 3;\n    \n    for(int i = 1;i <= 180;++i)\n        for(int j = i;j <= 180 && t[i] + t[j] <= 1000000;++j)\n            ans1[ t[i] + t[j] ] = 2;\n    \n    for(int i = 1;i <= 180;++i)\n        ans1[ t[i] ] = 1;\n    \n    for(int i = 1;i <= 1000000;++i){\n        if(ans1[i] == 3){\n            for(int j = 1;j <= 180 && i + t[j] <= 1000000;++j)\n                if(ans1[i + t[j]] == 5) ans1[i + t[j]] = 4;\n        }\n    }\n    \n    for(int i = 1;i <= 180;++i){\n        int x = t[i];\n        \n        if(x & 1)\n            for(int j = x;j <= 1000000;++j)\n                if(1 + ans2[j - x] < ans2[j]) ans2[j] = 1 + ans2[j - x];\n    }\n    \n    int n;\n    \n    while(true){\n        scanf(\"%d\",&n);\n        \n        if(n == 0) break;\n        \n        printf(\"%d %d\\n\",ans1[n],ans2[n]);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lpin(a,i,n) for(int i=0;i<n;i++){cin>>a[i];}\n\nvoid calc(int a[],int f){\n  for(int i=f*(f+1)*(f+2)/6;i<=1000000;i++){\n    if(a[i]==0) a[i]=a[i-f*(f+1)*(f+2)/6]+1;\n    else if(a[i]>a[i-f*(f+1)*(f+2)/6]+1) a[i]=a[i-f*(f+1)*(f+2)/6]+1;\n  }\n}\n\nint x[1000001],b[1000001];\nint main(){\n  for(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    calc(x,i);\n  }\n  for(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    if(i*(i+1)*(i+2)/6%2==1){\n    calc(b,i);\n    }\n  }\n  while(1){\n    int z;\n    cin>>z;\n    if(z==0) break;\n    cout<<x[z]<<\" \"<<b[z]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MAX 1004732\n\nint calc(int n) { return n*(n + 1)*(n + 2) / 6; }\nint p[200];\nint p1[200];\n//int dp[MAX] = { 0 };\n//int dp1[MAX] = { 0 };\n\nint func(int n, int P[], int DP[])\n{\n\tif (n <= 0)return MAX;\n\tif (DP[n] != 0)return DP[n];\n\telse\n\t{\n\t\tint min_t = MAX;\n\t\tint i = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (P[i] <= n && n <= P[i + 1])break;\n\t\t\tif (P[i] == 1004731)\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int t = i; t>0; t--)\n\t\t{\n\t\t\tint temp = func(n - P[t], P, DP);\n\t\t\tif (min_t > temp + 1)\n\t\t\t{\n\t\t\t\tmin_t = temp + 1;\n\t\t\t}\n\t\t}\n\t\tDP[n] = min_t;\n\t\treturn DP[n];\n\t}\n}\n\nint main()\n{\n\tint *dp, *dp1;\n\tdp = new int[MAX];\n\tdp1 = new int[MAX];\n\tREP(i, MAX)\n\t{\n\t\tdp[i] = 0;\n\t\tdp1[i] = 0;\n\t}\n\tint index = 1;\n\tFOR(i, 1, 200)\n\t{\n\t\tint temp = calc(i);\n\t\tif (temp > 1004731)break;\n\t\tp[i] = temp;\n\t\tdp[p[i]] = 1;\n\t\tif (temp % 2 == 1)\n\t\t{\n\t\t\tp1[index] = temp;\n\t\t\tdp1[p1[index]] = 1;\n\t\t\tindex++;\n\t\t}\n\t}\n\twhile (1)\n\t{\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcout << func(N, p, dp) << \" \" << func(N, p1, dp1) << endl;\n\t}\n\tdelete[] dp;\n\tdelete[] dp1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define INF 999999999\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nvector<int> py, od;\nint pol[1000000], odd[1000000];\n\nvoid tri(){\n\tfor(int i=0;i*i*i<=6000000;i++){\n\t\tpy.push_back(i*(i+1)*(i+2)/6);\n\t\tif((i*(i+1)*(i+2)/6)%2==1)od.push_back(i*(i+1)*(i+2)/6);\n\t}\n\t//cout << py.size() << \" \" << od.size() << endl;\n}\n\nvoid tab_pol(){\n\tpol[0] = 0;\n\tint ans, ins;\n\tfor(int i=1;i<1000000;i++){\n\t\tans = i;\n\t\tfor(int j=1;py[j]<=i&&j<py.size();j++){\n\t\t\tins = 1 + pol[i-py[j]];\n\t\t\tif(ins < ans) ans = ins;\n\t\t}\n\t\tpol[i] = ans;\n\t}\n}\n\n\nvoid tab_odd(){\n\todd[0] = 0;\n\tint ans, ins;\n\tfor(int i=1;i<1000000;i++){\n\t\tans = i;\n\t\tfor(int j=1;od[j]<=i&&j<od.size();j++){\n\t\t\tins = 1 + odd[i-od[j]];\n\t\t\tif(ins < ans) ans = ins;\n\t\t}\n\t\todd[i] = ans;\n\t}\n}\n\nint main(){\n\ttri();\n\t//cout << \"tri\" <<endl;\n\ttab_pol();\n\t//cout << \"pol\" <<endl;\n\ttab_odd();\n\tint n;\n\t\n\twhile(1){\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tcout << pol[n] << \" \" << odd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP_N(i,n,s) for(ll i=0; i<(ll)n; i+=s)\n#define REP(i,n) REP_N(i,n,1)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nvoid solution(ll output[1000001], int interval) {\n\toutput[0] = 0;\n\tll current_i = 1-interval;\n\tREP(i, 1000001) if(i!=0) {\n\t\tll minimum = 1000001;\n\t\tREP_N(j, current_i+1, interval) if(j!=0) minimum = min(output[i - table[j]] + 1, minimum);\n\t\toutput[i] = minimum;\n\n\t\tif (table[current_i + interval] == i) current_i += interval;\n\t}\n}\n\nint main() {\n\t//freopen(\"Text.txt\", \"r\", stdin);\n\t\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i++]) table[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tsolution(pollock, 1);\n\tsolution(dp, 4);\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define NMAX 1000000\nint main(){\n  vector<int> L;\n  int i=1;\n  while (true){\n    int t=i*(i+1)*(i+2)/6;\n    if (t>NMAX) break;\n    L.push_back(t);\n    i++;\n  }\n  int E[NMAX];\n  int O[NMAX];\n  for (int i=0;i<NMAX;i++){\n    E[i]=i;\n    O[i]=i;\n  }\n  for (int i=0;i<NMAX;i++)\n    for (int j=0;j<L.size();j++){\n      if (L[j]>i) break;\n      int c=i/L[j]+E[i%L[j]];\n      E[i]=min(E[i],c);\n      if (L[j]%2==1){\n        c=i/L[j]+O[i%L[j]];\n        O[i]=min(O[i],c);\n      }\n    }\n  while (true){\n    int n;\n    cin>>n;\n    if (n==0) return 0;\n    cout<<E[n]<<\" \"<<O[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\nint dp1[1000001];\nint dp2[1000001];\n\nset<int> por;\nvector<int> porv;\nset<int> pork;\nvector<int> porkv;\n\nint rec1(int n) {\n\tif(n < 0) return INF;\n\tif(dp1[n] != INF) return dp1[n];\n\tif(por.count(n) != 0) return 1;\n\tint res = INF;\n\tREP(i, porv.size()) {\n\t\tres = min(res, rec1(n - porv[i] ) + 1);\n\t}\n\treturn dp1[n] = res;\n}\n\nint rec2(int n) {\n\tif(n < 0) return INF;\n\tif(dp2[n] != INF) return dp2[n];\n\tif(pork.count(n) != 0) return 1;\n\tint res = INF;\n\tREP(i, porkv.size()) {\n\t\tres = min(res, rec2(n - porkv[i]) + 1);\n\t}\n\treturn dp2[n] = res;\n}\n\nint main() {\n\tREP(i, 1000001) dp1[i] = dp2[i] = INF;\n\tdp1[0] = 0;\n\tdp2[0] = 0;\n\tint buf = 1;\n\twhile(buf * (buf + 1) * (buf + 2) / 6 <= pow(10, 6)) {\n\t\tpor.insert(buf * (buf + 1) * (buf + 2) / 6);\n\t\tporv.pb(buf * (buf + 1) * (buf + 2) / 6);\n\t\tif((buf * (buf + 1) * (buf + 2) / 6) % 2 == 1) {\n\t\t\tpork.insert(buf * (buf + 1) * (buf + 2) / 6);\n\t\t\tporkv.pb(buf * (buf + 1) * (buf + 2) / 6);\n\t\t}\n\t\t++buf;\n\t}\n\twhile(1) {\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tcout<<rec1(n)<<\" \"<<rec2(n)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main (){\n  int dp1[1000001];\n  int dp2[1000001];\n  vector<int> shi;\n  vector<int> shiki;\n\n  for(int j=0;j<=1000000;j++) dp1[j] = dp2[j] = j;\n    \n  for(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n    shi.push_back(i*(i+1)*(i+2)/6);\n    if(shi[i-1]%2 == 1) shiki.push_back(shi[i-1]);\n  }\n\n  for(int i=0;i<shi.size();i++)\n    for(int j=1;j<=1000000;j++)\n      if(j>=shi[i]) dp1[j] = min(dp1[j],dp1[j-shi[i]]+1);\n\n  for(int i=0;i<shiki.size();i++)\n    for(int j=1;j<=1000000;j++){\n      if(j>=shiki[i]) dp2[j] = min(dp2[j],dp2[j-shiki[i]]+1);\n    }\n\n\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) break;\n    cout << dp1[n]<< \" \"<< dp2[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\nconst ll INF = 1LL << 50;\n\nconst ll mod = 1e9 + 7;\n\nconst ll nmax = 1000000;\n\nll dp[nmax];\nll dp2[nmax];\n\nint main() {\n  fill(dp, dp + nmax, INF);\n  fill(dp2, dp2 + nmax, INF);\n\n  auto f = [](ll x) { return x * (x + 1) * (x + 2) / 6; };\n\n  dp[0] = 0;\n  dp2[0] = 0;\n\n  rep(i, nmax) {\n    ll n = 1;\n    while (true) {\n      ll fn = f(n);\n      if (i - fn < 0) break;\n      chmin(dp[i], dp[i - fn] + 1);\n      if (fn % 2 == 1) chmin(dp2[i], dp2[i - fn] + 1);\n      n++;\n    } // while\n  } // i\n\n  while (true) {\n    int N;\n    cin >> N;\n    if (N == 0) break;\n    cout << dp[N] << \" \" << dp2[N] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n/*sqrt<3>(NMAX)==100*/\n\nint Nkake[100+1];\nint g[1000001]={0};\nint k[1000001]={0};\n\nint main(){\n\n\tint N;\n\t\n\tfor(int i=1;i<=100;i++){\n\t\tNkake[i]=i*(i+1)*(i+2)/6;\n\t}\n\n\tfor(int i=0;i<=1000000;i++){\n\t\tfor(int j=1;j<100;j++){\n\t\t\tif(i+Nkake[j]<=1000000){\n\t\t\t\tif(g[Nkake[j]+i]==0||g[Nkake[j]+i]>g[i]+1) g[Nkake[j]+i]=g[i]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<=1000000;i++){\n\t\tfor(int j=1;j<100;j++){\n\t\t\tif(Nkake[j]%2==1&&i+Nkake[j]<=1000000){\n\t\t\t\tif(k[Nkake[j]+i]==0||k[Nkake[j]+i]>k[i]+1) k[Nkake[j]+i]=k[i]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\n\t\tcout<<g[N]<<\" \"<<k[N]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-8;\n\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n#define MAX_N 1000000\nint memo[MAX_N+1];\n\nint plc(int n) { return n * (n + 1) * (n + 2) / 6; }\n\nint solve(int n, bool skip_even) {\n  fill(memo, memo+MAX_N+1, 1<<30);\n  for (int i = 1; plc(i) <= n; i++) {\n    if (skip_even && plc(i) % 2 == 0) continue;\n    memo[plc(i)] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; plc(j) <= i; j++) {\n      if (skip_even && plc(j) % 2 == 0) continue;\n      memo[i] = min(memo[i], memo[i-plc(j)] + 1);\n    }\n  }\n  return memo[n];\n}\n\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int n;\n  while (cin >> n, n) {\n    cout << solve(n, false) << \" \" << solve(n, true) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(a)     (a).begin(),(a).end()\n#define VI         vector<int>\n#define MOD 1000000007\n\nusing ll = long long int;\nusing P = pair<int,int>;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n//const ll INF=(ll)1e19;\nconst int INF=(1<<30);\n\nint MAX=1000000;\nint dp1[1000001];\nint dp2[1000001];\n\nint main(){\n  REP(i,MAX+1)dp1[i] = INF;\n  dp1[0]=0;\n  REP(i,MAX+1)dp2[i] = INF;\n  dp2[0]=0;\n\n  for(int i=0; ; i++){\n    int x=i*(i+1)*(i+2)/6;\n    if(x >= MAX)break;\n\n    FOR(i,x,MAX+1){\n      dp1[i] = min(dp1[i-x]+1, dp1[i]);\n      if(x%2==1)dp2[i] = min(dp2[i-x]+1, dp2[i]);\n    }\n  }\n\n\n  while(true){\n    int n;\n    cin >> n;\n    if(n==0)break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n  return(0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\nusing namespace std;\n\nint all[10000], odd[10000];\nset<int> allfour, oddfour;\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2+1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n /2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\n\n\nint main()\n{\n\tint n, t[100];\n\tint counter = 0;\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tt[counter++] = n;\n\tint maxnum = 0;\n\n\t//入力値の最大を取得\n\tfor (int i = 0; i < counter; i++)\n\t\tmaxnum = max(maxnum, t[i]);\n\n\t//1からmaxnumまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four>maxnum)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からmaxnumまで，配列を埋める.\n\tfor (int i = 1; i <= maxnum; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//出力\n\tfor (int i = 0; i < counter; i++)\n\t\tcout << all[t[i]] << \" \" << odd[t[i]] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int dp[1000010]={};\n  int dp2[1000010]={};\n  for(int i=1;i<=1000000;i++){dp[i]=INF;dp2[i]=INF;}\n  vector<ll> gu;\n  vector<ll> ki;\n  ll cnt=1;\n  while(1){\n    if((cnt*(cnt+1)*(cnt+2)/6)>1000000)break;\n    if(((cnt*(cnt+1)*(cnt+2))/6)%2)ki.pb(cnt*(cnt+1)*(cnt+2)/6);\n    else gu.pb(cnt*(cnt+1)*(cnt+2)/6);\n    cnt++;\n  }\n  dp[1]=1;\n  dp2[1]=1;\n  for(int i=1;i<1000000;i++){\n    for(int j=0;j<gu.size();j++){\n      if(i+gu[j]>1000000)break;\n      dp[i+gu[j]]=min(dp[i+gu[j]],(dp[i]+1));\n    }\n    for(int j=0;j<ki.size();j++){\n      if(i+ki[j]>1000000)break;\n      dp[i+ki[j]]=min(dp[i+ki[j]],(dp[i]+1));\n      dp2[i+ki[j]]=min(dp2[i+ki[j]],(dp2[i]+1));\n    }\n  }\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\nconst int inf = 1000000009;\n\nint main() {\n    vector<vector<int>> memo(85, vector<int>(1000000, inf));\n    vector<vector<int>> odd_memo(85, vector<int>(1000000, inf));\n    for (int i=0; i<1000000; i++) {\n        memo[0][i] = 0;\n        odd_memo[0][i] = 0;\n    }\n\n    for (int i=0; i<1000000; i++) {\n        memo[1][i] = i;\n        odd_memo[1][i] = i;\n    }\n\n    for (int l=2; l<(int)memo.size(); l++) {\n        const int n = (l*(l+1)*(l+2))/6;\n        for (int i=0; i<(int)memo[l].size(); i++) {\n            if(i-n == 0) {\n                memo[l][i] = 1;\n            } else if(i-n > 0) {\n                memo[l][i] = min(memo[l][i-n]+1, memo[l-1][i]);\n            } else {\n                memo[l][i] = memo[l-1][i];\n            }\n\n            if (l%2==1) {\n                if(i-n == 0) {\n                    odd_memo[l][i] = 1;\n                } else if(i-n > 0) {\n                    odd_memo[l][i] = min(odd_memo[l][i-n]+1, odd_memo[l-1][i]);\n                } else {\n                    odd_memo[l][i] = odd_memo[l-1][i];\n                }\n            } else {\n                odd_memo[l][i] = odd_memo[l-1][i];\n            }\n        }\n    }\n\n    int n; \n    while (cin >> n, n!=0) {\n        cout << memo[memo.size()-1][n] << \" \" << odd_memo[odd_memo.size()-1][n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1001001001;\ntypedef pair<int, int> P;\n\nint d[1000001];\n\nint main()\n{\n\tint tet[1001];\n\tfor (int i = 1; i <= 1000; i++){\n\t\ttet[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\t\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfill(d, d + 1000001, INF);\n\t\tqueue<P> que;\n\t\tfor (que.push(P(0, 0)); que.size(); que.pop()){\n\t\t\tP p = que.front();\n\t\t\tif (d[p.first] <= p.second) continue;\n\t\t\td[p.first] = p.second;\n\t\t\tif (p.first == n) break;\n\t\t\t\n\t\t\tfor (int i = 1; p.first + tet[i] <= n; i++){\n\t\t\t\tque.push(P(p.first + tet[i], p.second + 1));\n\t\t\t}\n\t\t}\n\t\tcout << d[n];\n\t\t\n\t\tfill(d, d + 1000001, INF);\n\t\twhile (!que.empty()) que.pop();\n\t\tfor (que.push(P(0, 0)); que.size(); que.pop()){\n\t\t\tP p = que.front();\n\t\t\tif (d[p.first] <= p.second) continue;\n\t\t\td[p.first] = p.second;\n\t\t\tif (p.first == n) break;\n\t\t\t\n\t\t\tfor (int i = 1; p.first + tet[i] <= n; i++){\n\t\t\t\tif (tet[i] % 2 == 0) continue;\n\t\t\t\tque.push(P(p.first + tet[i], p.second + 1));\n\t\t\t}\n\t\t}\n\t\tcout << \" \" << d[n] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(ll i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(ll i=(a),i##_cond=(b);i<i##_cond;++i)\n#define ROF(i,a,b) for(ll i=(a)-1,i##_cond=(b);i>=i##_cond;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define UNIQUE(v) v.erase(unique(all(v)),v.end())\n#define SUM(a) accumulate(all(a),0)\n#define sz(x) ((ll)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<ll,ll> pii;\n\nconst ll inf = 1ll<<62;\nconst ll mod = 1e9+7;\n\n#define n 1000000\n\nint main(){\n#define int ll\n  int tmp = 1;\n  vi a, b;\n  while(1){\n    int x = tmp * (tmp + 1) * (tmp + 2) / 6;\n    if(x >= 1000000) break;\n    a.pb(x);\n    if(x & 1) b.pb(x);\n    tmp++;\n  }\n  dump(a,b);\n  \n  vi dpa(n+1,inf),dpb(n+1,inf);\n  dpa[0] = 0;\n  dpb[0] = 0;\n  rep(i,n){\n    for(int j = 0; j < sz(a) and a[j] <= i + 1; ++j)\n\tdpa[i+1] = min(dpa[i+1], dpa[i + 1 - a[j]] + 1);\n    for(int j = 0; j < sz(b) and b[j] <= i + 1; ++j)\n\tdpb[i+1] = min(dpb[i+1], dpb[i + 1 - b[j]] + 1);\n  }\n  while(1){\n    int m;\n    cin >> m;\n    if(m == 0) break;\n\n    cout << dpa[m] << \" \" << dpb[m] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint main()\n{\n\tvector<int> dp(MAX, INF), res(MAX, INF), four, odd;\n\tfor (int i = 1; i * (i + 1) * (i + 2) / 6 < MAX; i++) {\n\t\tfour.push_back(i * (i + 1) * (i + 2) / 6);\n\t\tif (i * (i + 1) * (i + 2) / 6 % 2)\n\t\t\todd.push_back(i * (i + 1) * (i + 2) / 6);\n\t}\n\tdp[0] = res[0] = 0;\n\tfor (int j = 0; j < MAX; j++) {\n\t\tif (dp[j] != INF) {\n\t\t\tfor (int k = 0; k < four.size() && j + four[k] < MAX;k++) {\n\t\t\t\tdp[j + four[k]] = min(dp[j + four[k]], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < MAX; j++) {\n\t\tif (res[j] != INF) {\n\t\t\tfor (int k = 0; k < odd.size() && j + odd[k] < MAX; k++) {\n\t\t\t\tres[j + odd[k]] = min(res[j + odd[k]], res[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tios::sync_with_stdio(false);\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << ' ' << res[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;n[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)ki[j]=all[j]=j;\n  for(j=2;j<i;j++){\n    for(k=n[j];k<=1000000;k++){\n      b[k]=min(b[k],b[k-a[j]]+1);\n      if(n[j]%2){\n        c[k]=min(c[k],c[k-a[j]]+1);\n      }\n    }\n  }\nwhile(cin>>n,n){\ncout<<b[a]<<' '<<c[a]<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n\nint t[1000*1000+1];\nint ot[1000*1000+1];\n\nvoid init() {\n    fill(t, t+1000*1000+1, INF);\n    fill(ot, ot+1000*1000+1, INF);\n    for (int i = 1; ; i++) {\n        int n = i * (i+1) * (i+2) / 6;\n        if (n > 1000*1000) break;\n        t[n] = 1;\n        if (n % 2) ot[n] = 1;\n    }\n\n    for (int i = 1; i <= 1000*1000; i++) {\n        for (int j = 1; ; j++) {\n            int p = j * (j+1) * (j+2) / 6;\n            if (i <= p) break;\n            t[i] = min(t[i], t[i-p] + 1);\n            if (p % 2) ot[i] = min(ot[i], ot[i-p] + 1);\n        }\n    }\n}\n\nint main() {\n    init();\n    int n;\n    while (scanf(\"%d\", &n), n) {\n        printf(\"%d %d\\n\", t[n], ot[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    const int INF = 1 << 30;\n    vector<int> dp1(1000000, INF), dp2(1000000, INF);\n    dp1[0] = dp2[0] = 0;\n    for (int i = 0; i < 1000000; ++i) {\n        for (int j = 1; ; ++j) {\n            int num = j * (j + 1) * (j + 2) / 6;\n            if (i + num >= 1000000) break;\n            dp1[i + num] = min(dp1[i + num], dp1[i] + 1);\n            if (num % 2 == 1) dp2[i + num] = min(dp2[i + num], dp2[i] + 1);\n        }\n    }\n    int n;\n    while (cin >> n, n) {\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nvector<int> tetra;\nvector<int> tetra_odd;\n\nint dp[MAX_N+1];\nint dp_odd[MAX_N+1];\n\nvoid init() {\n\tint n = 1;\n\twhile (true){\n\t\tint m = n * (n + 1) * (n + 2) / 6;\n\t\tif (m > MAX_N) {\n\t\t\tbreak;\n\t\t}\n\t\ttetra.push_back(m);\n\t\tif (m % 2 == 1) {\n\t\t\ttetra_odd.push_back(m);\n\t\t}\n\t\tn++;\n\t}\n}\n\nvoid solve() {\n\tdp[0] = dp_odd[0] = 0;\n\tfor (int i = 1; i <= MAX_N; i++) {\n\t\tint ans = MAX_N;\n\t\tint ans_odd = MAX_N;\n\t\tfor (int j = 0; tetra[j] <= i; j++) {\n\t\t\t//cout << i << \" \" << tetra[j] << endl;\n\t\t\tans = min(ans, dp[i-tetra[j]]);\n\t\t}\n\t\t\n\t\tfor (int j = 0; tetra_odd[j] <= i; j++) {\n\t\t\tans_odd = min(ans_odd, dp_odd[i-tetra_odd[j]]);\n\t\t}\n\t\tdp[i] = ans + 1;\n\t\tdp_odd[i] = ans_odd + 1;\n\t\t//cout << i << \" \" << dp[i] << \" \" << dp_odd[i] << endl;\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcout << dp[n] << \" \" << dp_odd[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 10007;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\n\nint dp[1001000],dp2[1001000];\nvector<int> pollock, pollock2;\nint main() {\n\tfor (int i = 1;; i++) {\n\t\tLL num = i*(i + 1)*(i + 2)/6;\n\n\t\tif (num > 1000000)break;\n\n\t\tif (num % 2 == 1)pollock2.emplace_back(num);\n\t\tpollock.emplace_back(num);\n\t}\n\t//cout << 1 << endl;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tdp[i] = dp2[i] = i;\n\t}\n\t//cout << 2 << endl;\n\tfor (int i = 1; i < pollock.size(); i++) {\n\t\tfor (int j = pollock[i]; j <= 1000000; j++) {\n\t\t\tdp[j] = min(dp[j], dp[j - pollock[i]] + 1);\n\t\t}\n\t}\n\t//cout << 3 << endl;\n\tfor (int i = 1; i < pollock2.size(); i++) {\n\t\tfor (int j = pollock2[i]; j <= 1000000; j++) {\n\t\t\tdp2[j] = min(dp2[j], dp2[j - pollock2[i]] + 1);\n\t\t}\n\t}\n\t//cout << 4 << endl;\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    /*for(int i=1;i<=x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)\n\tbreak;\n      count++;\n      if(tmp%2==1)\n\tcount_ki++;\n\t}*/\n\n    int coin[x];\n    int coin_ki[x];\n    //fill(coin,coin + x + 1,-1);\n    //fill(coin_ki,coin_ki + x + 1,-1);\n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      coin[i-1]=i*(i+1)*(i+2)/6;\n      count++;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki++;\n      }\n      if(coin[i-1]>x)break;\n    }\n\n    int dp[x+1];\n    fill(dp,dp + x + 1,100000);\n  \n\n    /*for(int i=0;i<=x;i++)\n      printf(\"dp[%d]=%d\\n\",i,dp[i]);\n    */\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[10000];\n    fill(dp,dp + x+1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\nusing namespace std;\n#define ull unsigned long long\nint memo[150];\nint  dp[1000002];\nint  dp2[1000002];\nvoid inset(){\n\tdp[0]=0;\n\tfill(dp,dp+1000001,10000);\n\tfill(dp2,dp2+1000001,10000);\n\tdp[0]=0;\n\tdp2[0]=0;\n\trep(i,1,200){\n\t\tmemo[i]=i*(i+1)*(i+2),memo[i]/=6;\n\t\trep(j,1,1000001)\n\t\t\tif(j-memo[i]>=0){\n\t\tif(dp[j]>dp[j-memo[i]]+1)dp[j]=dp[j-memo[i]]+1;\n\t\tif(memo[i]&1)if(dp2[j]>dp2[j-memo[i]]+1)dp2[j]=dp2[j-memo[i]]+1;\n\t\t}\n\t}\n\t//rep(i,1,1000001){\n\t//\tif(dp2[i]==0){\n\t//\tprintf(\"[%d]%d\\n\",i,dp2[i]);\n\t//\tbreak;\n\t//\t}\n\t//}\n}\n\n\nint main(void){\n\tinset();\n\tint x;\n\twhile(true){\n\t\tcin>>x;if(x==0)return(0);\n\t\tcout<<dp[x]<<\" \"<<dp2[x]<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nconst int max_num = 1000010;\nint main(){\n  vector<int> tetra;\n  int x = 1;\n  int num = 1;\n  while(num <= max_num){\n    if (num != 1) tetra.push_back(num);\n    x++;\n    num = (x * (x+1) * (x+2)) / 6;\n  }\n  int m = tetra.size();\n  vector<int> dp(max_num);\n  vector<int> dp2(max_num);\n  rep(i, max_num){\n    dp[i] = i;\n    dp2[i] = i;\n    rep(j, m){\n      if (i - tetra[j] < 0) break;\n      dp[i] = min(dp[i], dp[i - tetra[j]] + 1);\n      if (tetra[j] % 2 == 1)\n        dp2[i] = min(dp2[i], dp2[i - tetra[j]] + 1);\n    }\n  }\n  while(1){\n    int n;\n    cin >> n;\n    if (n == 0) break;\n    cout << dp[n] << ' ' << dp2[n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[1000000],dp2[1000000];\nint main() {\n\tv.pb(1);\n\tll n,now=1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)i*(i + 1)*(i + 2) / 6;\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 100000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 100000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\t\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], i / v[j] + dp2[i%v[j]]);\n\t\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma GCC target(\"avx512f,avx512dq,avx512cd,avx512bw,avx512vl\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")*/\n#include<bits/stdc++.h>\nusing namespace std;\n\nint INF=1000000000;\nint dp[1000001],dp_odd[1000001],n,ans1,ans2;\n\nint main(){\n    int i,j;\n    //dpテーブルの初期化\n    for(i=0;i<1000001;i++){\n        dp[i]=INF;\n        dp_odd[i]=INF;\n    }\n    dp[0]=0;\n    dp_odd[0]=0;\n\n    //前計算\n    for(i=1;i<=181;i++){\n        n=(i*(i+1)*(i+2))/6;\n        for(j=0;j<1000001;j++){\n            if(dp[j]!=INF && j+n<=1000000){\n                dp[j+n]=min(dp[j+n],dp[j]+1);\n            }\n        }\n        if(n%2==1){\n            for(j=0;j<1000001;j++){\n                if(dp_odd[j]!=INF && j+n<=1000000){\n                    dp_odd[j+n]=min(dp_odd[j+n],dp_odd[j]+1);\n                }\n            }   \n        }\n    }\n\n    while(cin>>n,n!=0)cout<<dp[n]<<\" \"<<dp_odd[n]<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int N;\n    vector<int> poloc;\n    vector<int> odd_poloc;\n    int t = 1;\n    while (1)\n    {\n        if (t * (t + 1) * (t + 2) / 6>1000000)\n            break;\n        poloc.push_back(t * (t + 1) * (t + 2) / 6);\n        if ((t * (t + 1) * (t + 2) / 6)%2 == 1)\n            odd_poloc.push_back(t * (t + 1) * (t + 2) / 6);\n        t++;\n    }\n    vector<int> dp(1000001, 10000000), dp2(1000001, 10000000);\n    dp[0] = 0;\n    for (int i = 0; i < 1000000; i++)\n    {\n        for (int j = 0; j < poloc.size(); j++)\n        {\n            if (i + poloc[j] > N)\n                break;\n            dp[i + poloc[j]] = min(dp[i + poloc[j]], dp[i] + 1);\n        }\n    }\n    dp2[0] = 0;\n    for (int i = 0; i < 1000000; i++)\n    {\n        for (int j = 0; j < odd_poloc.size(); j++)\n        {\n            if (i + odd_poloc[j] > N)\n                break;\n            dp2[i + odd_poloc[j]] = min(dp2[i + odd_poloc[j]], dp2[i] + 1);\n        }\n    }\n    while (cin >> N, N)\n    {\n        cout << dp[N] << \" \" << dp2[N] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\nreturn 0;\n    int res=0xFFFF;\n    if(maxcnt<cnt) return 0xFFFF;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n    }\n    return res;\n}\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        for(int i=1; ; i*=2) {\n            if((oddres=oddrec(n, 0, 0, i))!=0xFFFF)\n                break;\n        }\n\n        printf(\"%d %d\\n\",res,oddres);\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nint dp[1000010];\nint dpodd[1000010];\n\nsigned main() {\n\tvector<int> v, vo;\n\n\tfor (int i = 1; i <= 1000000; i++) {\n\t\tdp[i] = INT_MAX;\n\t\tdpodd[i] = INT_MAX;\n\t}\n\t\n\tfor (int i = 1; true; i++) {\n\t\tint num = i * (i + 1) * (i + 2) / 6;\n\t\tif (num > 1000000) break;\n\t\t\n\t\tv.push_back(num);\n\t\tif (num % 2) vo.push_back(num);\n\t}\n\n\tfor (int i = 1; i <= 1000000; i++) {\n\t\tfor (int num : v) {\n\t\t\tif (num > i) break;\n\t\t\tdp[i] = min(dp[i], dp[i - num] + 1);\n\t\t}\n\t\tfor (int num : vo) {\n\t\t\tif (num > i) break;\n\t\t\tdpodd[i] = min(dpodd[i], dpodd[i - num] + 1);\n\t\t}\n\t}\n\n\tint input;\n\tcin >> input;\n\n\twhile (input) {\n\t\tcout << dp[input] << ' ' << dpodd[input] << endl;\n\n\t\tcin >> input;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing VI = vector<int>;\nusing VL = vector<ll>;\nusing loop = int;\ntemplate<class T> using PQ = priority_queue<T, vector<T>, greater<T>>;\n#define FOR(i,a,n) for(loop (i)=(a);(i)<(n);++(i))\n#define eFOR(i,a,n) for(loop (i)=(a);(i)<=(n);++(i))\n#define rFOR(i,a,n) for(loop (i)=(n)-1;(i)>=(a);--(i))\n#define erFOR(i,a,n) for(loop (i)=(n);(i)>=(a);--(i))\n#define each(i, a) for(auto &i : a)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\n#define all(i) (i).begin(),(i).end()\n#define out(y,x) ((y) < 0 || h <= (y) || (x) < 0 || w <= (x))\n#define line cout << \"------------------------\\n\" \n#define ENDL(i,n) ((i) == (n) - 1 ? \"\\n\" : \" \")\n//#define stop system(\"pause\") //comment out this on AOJ.\nconstexpr ll INF = 1000000000;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr ll MOD = 998244353;\nconstexpr ld eps = 1e-10;\nconstexpr ld pi = 3.1415926535897932;\ntemplate<class T>inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T>inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; }return false; }\ninline void init() { cin.tie(nullptr); cout.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); }\ntemplate<class T>inline istream& operator>>(istream& is, vector<T>& v) { for (auto& elemnt : v)is >> elemnt; return is; }\ntemplate<class T, class U>inline istream& operator>>(istream& is, pair<T, U>& p) { is >> p.first >> p.second; return is; }\ntemplate<class T>inline vector<T> vec(size_t a) { return vector<T>(a); }\ntemplate<class T>inline vector<T> defvec(T def, size_t a) { return vector<T>(a, def); }\ntemplate<class T, class... Ts>inline auto vec(size_t a, Ts... ts) { return vector<decltype(vec<T>(ts...))>(a, vec<T>(ts...)); }\ntemplate<class T, class... Ts>inline auto defvec(T def, size_t a, Ts... ts) { return vector<decltype(defvec<T>(def, ts...))>(a, defvec<T>(def, ts...)); }\n\nint main() {\n    init();\n\n    constexpr int Max = 1000000;\n    VI s;\n    for (int i = 1, a = 0, b = 0; b <= Max; ++i) {\n        a += i;\n        b += a;\n        s.push_back(b);\n    }\n    int m = s.size();\n\n    auto dp = defvec<int>(Max, Max + 1, 2);\n    dp[0][0] = 0;\n    each(i, s)eFOR(j, 0, Max - i)FOR(k, 0, 2) {\n        chmin(dp[i + j][k | ((i & 1) == 0)], dp[j][k] + 1);\n    }\n    \n    for (int n; cin >> n && n;)cout << min(dp[n][0], dp[n][1]) << \" \" << dp[n][0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <fstream>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n//Vector2D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec2D {\n    T x, y;\n\n    Vec2D() = default;\n\n    constexpr Vec2D(T x, T y)\n            : x{x}, y{y} {}\n\n    static constexpr T Dot(const Vec2D &lhs, const Vec2D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y;\n    }\n\n    static constexpr T Cross(const Vec2D &lhs, const Vec2D &rhs) {\n        return {lhs.x * rhs.y - lhs.y * rhs.x};\n    }\n\n    constexpr T dot(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec2D cross(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y;\n    }\n\n    Vec2D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec2D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0;\n    }\n\n    constexpr Vec2D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec2D operator-() const {\n        return {-x, -y};\n    }\n\n\n    constexpr Vec2D operator+(Vec2D rhs) const {\n        return {x + rhs.x, y + rhs.y};\n    }\n\n    constexpr Vec2D operator-(Vec2D rhs) const {\n        return {x - rhs.x, y - rhs.y};\n    }\n\n    template<class U>\n    constexpr Vec2D operator*(U rhs) const {\n        return {x * rhs, y * rhs};\n    }\n\n    template<class U>\n    constexpr Vec2D operator/(U rhs) const {\n        return {x / rhs, y / rhs};\n    }\n\n    constexpr Vec2D &operator+=(const Vec2D &other) {\n        x += other.x;\n        y += other.y;\n        return *this;\n    }\n\n    constexpr Vec2D &operator-=(const Vec2D &other) {\n        x -= other.x;\n        y -= other.y;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec2D<T> operator*(U s, Vec2D<T> v) {\n    return {s * v.x, s * v.y};\n}\n\n//Vector3D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec3D {\n    T x, y, z;\n\n    Vec3D() = default;\n\n    constexpr Vec3D(T x, T y, T z)\n            : x{x}, y{y}, z{z} {}\n\n    constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0) {}\n\n    static constexpr T Dot(const Vec3D &lhs, const Vec3D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n    }\n\n    static constexpr Vec3D Cross(const Vec3D &lhs, const Vec3D &rhs) {\n        return {\n                lhs.y * rhs.z - lhs.z * rhs.y,\n                lhs.z * rhs.x - lhs.x * rhs.z,\n                lhs.x * rhs.y - lhs.y * rhs.x\n        };\n    }\n\n    constexpr T dot(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec3D cross(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y + z * z;\n    }\n\n    Vec3D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec3D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0 && z == 0;\n    }\n\n    constexpr Vec3D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec3D operator-() const {\n        return {-x, -y, -z};\n    }\n\n\n    constexpr Vec3D operator+(Vec3D rhs) const {\n        return {x + rhs.x, y + rhs.y, z + rhs.z};\n    }\n\n    constexpr Vec3D operator-(Vec3D rhs) const {\n        return {x - rhs.x, y - rhs.y, z - rhs.z};\n    }\n\n    template<class U>\n    constexpr Vec3D operator*(U rhs) const {\n        return {x * rhs, y * rhs, z * rhs};\n    }\n\n    template<class U>\n    constexpr Vec3D operator/(U rhs) const {\n        return {x / rhs, y / rhs, z / rhs};\n    }\n\n    constexpr Vec3D &operator+=(const Vec3D &other) {\n        x += other.x;\n        y += other.y;\n        z += other.z;\n        return *this;\n    }\n\n    constexpr Vec3D &operator-=(const Vec3D &other) {\n        x -= other.x;\n        y -= other.y;\n        z -= other.z;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        z *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        z /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec3D<T> operator*(U s, Vec3D<T> v) {\n    return {s * v.x, s * v.y, s * v.z};\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n    set<LL> S;\n    for (LL i = 1; i < 200; i++) {\n        LL data = i * (i + 1) * (i + 2) / 6;\n        S.insert(data);\n    }\n\n    VI arr(S.size());\n    int _i = 0;\n    FOREACH(x, S) {\n        arr[_i] = x;\n        _i++;\n    }\n\n    VI dp(100010);\n    VI dp2(100010);\n    dp[0] = 0;\n    dp2[0] = 0;\n    for (int i = 1; i <= 100008; i++) {\n        dp[i] = dp[i - 1] + 1;\n        REP(j, SZ(arr)) {\n            if (arr[j] <= i) {\n                dp[i] = min(dp[i], dp[i - arr[j]] + 1);\n            } else {\n                break;\n            }\n        }\n    }\n    for (int i = 1; i <= 100008; i++) {\n        dp2[i] = dp2[i - 1] + 1;\n        REP(j, SZ(arr)) {\n            if (arr[j] <= i) {\n                if (arr[j] % 2 == 1) {\n                    dp2[i] = min(dp2[i], dp2[i - arr[j]] + 1);\n                } else {\n                    continue;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    //SHOW_VECTOR(dp2);\n\n    while (true) {\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        cout << dp[N] << \" \" << dp2[N] << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n \n#define rep(i, n) for(int i=0; i<(n); ++i)\n\nconst int size = 200;\nconst int limit = 1000001;\nint dp[limit], dp_odd[limit];\nint tetra[size], odd[size];\n\nint main(void){\n    int size_odd = 0;\n    for(int i=1; i<size+1; ++i) {\n        ll t = i*(i+1)*(i+2)/6;\n        tetra[i-1] = t;\n        if(t%2==1) {odd[size_odd]=t; size_odd++;}\n    }\n    int inf = numeric_limits<int>::max();\n    rep(i, limit) dp[i] = dp_odd[i] = inf;\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    rep(i, size) {\n        for(int j=tetra[i]; j<limit; ++j) \n            dp[j] = min(dp[j-tetra[i]]+1, dp[j]);\n    }\n    rep(i, size_odd) {\n        for(int j=odd[i]; j<limit; ++j) \n            dp_odd[j] = min(dp_odd[j-odd[i]]+1, dp_odd[j]);\n    }\n\n    int n;\n    while(cin >> n && n) {\n        cout << dp[n] << \" \";\n        cout << dp_odd[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nclass Solver {\n};\n\nint main() {\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tvector<long>vals;\n\t\tlong now = 1;\n\t\twhile (true) {\n\t\t\tlong val = (now * (now + 1) * (now + 2)) / 6;\n\t\t\tif (val > n)break;\n\t\t\tvals.emplace_back(val);\n\t\t\tnow++;\n\t\t}\n\t\tvector<int> cnts(n + 1, 1e9);\n\t\tvector<int> oddCnts(n + 1, 1e9);\n\t\tcnts[0] = 0;\n\t\toddCnts[0] = 0;\n\t\tfor (int i = 0; i < vals.size(); i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tif (j + vals[i] <= n) {\n\t\t\t\t\tcnts[j + vals[i]] = min(cnts[j + vals[i]], cnts[j] + 1);\n\t\t\t\t}\n\t\t\t\tif (vals[i] % 2 == 1 && j + vals[i] <= n) {\n\t\t\t\t\toddCnts[j + vals[i]]\n\t\t\t\t\t\t= min(oddCnts[j + vals[i]], oddCnts[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnts[n] << ' ' << oddCnts[n] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, S, E) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 2099999999LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\n\nvoid solve()\n{\n\tll N=180;\n\tvll sim, kim;\n\trep(i, 0, N-1){\n\t\tll val = i*(i+1)*(i+2)/6;\n\t\tsim.push_back(val);\n\t\tif (val%2==1){\n\t\t\tkim.push_back(val);\n\t\t}\n\t}\n\tll K = (ll)kim.size();\n\n\tvll S;\n\twhile (true){\n\t\tll s;  cin >> s;\n\t\tif (s==0) break;\n\t\tS.push_back(s);\n\t}\n\tll maxS = MaxE(S);\n\n\tvll ans1, ans2;\n\t{\n\t\tvll dp(maxS+1, INF);\n\t\tauto Dp = [&](ll s)->ll&{\n\t\t\tstatic ll inf = INF;\n\t\t\tif (s<0) return inf;\n\t\t\treturn dp[s];\n\t\t};\n\t\trep(s, 0, maxS){\n\t\t\tdp[s] = s;\n\t\t}\n\t\trep(i, 1, N-1){\n\t\t\tif (sim[i] > maxS) break;\n\t\t\trep(s, 0, maxS){\n\t\t\t\tchmin(Dp(s), Dp(s-sim[i])+1);\n\t\t\t}\n\t\t}\n\n\t\tEACH(s, S){\n\t\t\tll val = dp[s];\n\t\t\tans1.push_back(val);\n\t\t}\n\t}\n\t{\n\t\tvll dp(maxS+1, INF);\n\t\tauto Dp = [&](ll s)->ll&{\n\t\t\tstatic ll inf = INF;\n\t\t\tif (s<0) return inf;\n\t\t\treturn dp[s];\n\t\t};\n\t\trep(s, 0, maxS){\n\t\t\tdp[s] = s;\n\t\t}\n\n\t\trep(i, 1, K-1){\n\t\t\tif (kim[i] > maxS) break;\n\t\t\trep(s, 0, maxS){\n\t\t\t\tchmin(Dp(s), Dp(s-kim[i])+1);\n\t\t\t}\n\t\t}\n\n\t\tEACH(s, S){\n\t\t\tll val = dp[s];\n\t\t\tans2.push_back(val);\n\t\t}\n\t}\n\trep(i, 0, (ll)ans1.size()-1){\n\t\tcout << ans1[i] << ' ';\n\t\tcout << ans2[i] << '\\n';\n\t}\n\n\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\n\n//FILE *in = freopen(\"C\", \"r\", stdin);\n\nint data[] = {1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286, 364, 455, 560, 680, 816, 969, 1140, 1330, 1540, 1771, 2024, 2300, 2600, 2925, 3276, 3654, 4060, 4495, 4960, 5456, 5984, 6545, 7140, 7770, 8436, 9139, 9880, 10660, 11480, 12341, 13244, 14190, 15180, 16215, 17296, 18424, 19600, 20825, 22100, 23426, 24804, 26235, 27720, 29260, 30856, 32509, 34220, 35990, 37820, 39711, 41664, 43680, 45760, 47905, 50116, 52394, 54740, 57155, 59640, 62196, 64824, 67525, 70300, 73150, 76076, 79079, 82160, 85320, 88560, 91881, 95284, 98770, 102340, 105995, 109736, 113564, 117480, 121485, 125580, 129766, 134044, 138415, 142880, 147440, 152096, 156849, 161700, 166650, 171700, 176851, 182104, 187460, 192920, 198485, 204156, 209934, 215820, 221815, 227920, 234136, 240464, 246905, 253460, 260130, 266916, 273819, 280840, 287980, 295240, 302621, 310124, 317750, 325500, 333375, 341376, 349504, 357760, 366145, 374660, 383306, 392084, 400995, 410040, 419220, 428536, 437989, 447580, 457310, 467180, 477191, 487344, 497640, 508080, 518665, 529396, 540274, 551300, 562475, 573800, 585276, 596904, 608685, 620620, 632710, 644956, 657359, 669920, 682640, 695520, 708561, 721764, 735130, 748660, 762355, 776216, 790244, 804440, 818805, 833340, 848046, 862924, 877975, 893200, 908600, 924176, 939929, 955860, 971970, 988260, 1004731};\nint data2[] = {1, 35, 165, 455, 969, 1771, 2925, 4495, 6545, 9139, 12341, 16215, 20825, 26235, 32509, 39711, 47905, 57155, 67525, 79079, 91881, 105995, 121485, 138415, 156849, 176851, 198485, 221815, 246905, 273819, 302621, 333375, 366145, 400995, 437989, 477191, 518665, 562475, 608685, 657359, 708561, 762355, 818805, 877975, 939929, 1004731};\n\nint n;\nint d1[1000010];\nint d2[1000010];\n\nvoid process() {\n\tfill(d1, d1 + n + 1 , 0x7fffffff);\n\tfill(d2, d2 + n + 1 , 0x7fffffff);\n\td1[0] = 0;\n\td2[0] = 0;\n\tfor(int i = 0; i < 181; i++) {\n\t\tfor(int j = data[i]; j <= n; j++) {\n\t\t\t//if(d1[j - data[i]] != -1) {d1[j] == -1 || \n\t\t\t\tif(d1[j] > d1[j-data[i]] + 1) {\n\t\t\t\t\td1[j] = d1[j-data[i]] + 1;\n\t\t\t\t}\n\t\t\t//}\n\t\t}\n\t}\n\tfor(int i = 0; i < 46; i++) {\n\t\tfor(int j = data2[i]; j <= n; j++) {\n\t\t\t//if(d2[j - data2[i]] != -1) {d2[j] == -1 || \n\t\t\t\tif(d2[j] > d2[j-data2[i]] + 1) {\n\t\t\t\t\td2[j] = d2[j-data2[i]] + 1;\n\t\t\t\t}\n\t\t\t//}\n\t\t}\n\t}\n\n\t//printf(\"%d %d\\n\", d1[n], d2[n]);\n}\n\nint main() {\n\tn = 1000000;\n\tprocess();\n\twhile(true) {\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tprintf(\"%d %d\\n\", d1[n], d2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\tstd::vector<int> shimen;\n\nint calc_shimen(int pnum){\n\tstatic int num = 0;\n\tstatic int kai1 = 0;\n\tstatic int kai2 = 0;\n\tstatic int i = 0;\n//\t 2 3 4  5\n//\t1 3 6 10 15\n//\t 1 4 10 20 35\n\twhile (1){\n\t\tif (num > pnum) break;\n\t\tkai2++;\n\t\tkai1 += kai2;\n\t\tnum += kai1;\n\t\tshimen.push_back(num);\n\t//\tstd::cout << num << \"\\n\";\n\t\ti++;\n\t}\n\treturn i-2;\n}\n\nint main(void){\n\tint num, cnum, i, h, c1, cmin, cmin2, k;\n\n\tshimen.reserve(1000);\n\twhile (1){\n\t\tstd::cin >> num;\n\t\tif (!num) break;\n\t\t\n\t\tcmin = 0;\n\t\tc1 = 0;\n\t\th = calc_shimen(num);\n\t\twhile (h >= 1){\n\t\t\ti = h;\n\t\t\tcnum = num;\n\n\n\t\t\tk = shimen[i];\n\t\t//\tstd::cout << \"begin i:\" << i << \", k:\" << k << \"\\n\";\n\t\t//\tif (cmin <= 0 || num / k < cmin){\n\t\t\t\tc1 = 0;\n\t\t\t\twhile (i >= 0){\n\t\t\t\t\tk = shimen[i];\n\t\t\t\t\tc1 += cnum / k;\n\t\t\t\t\tcnum -= cnum / k*k;\n\t\t\t\t//\tstd::cout << \"k:\" << k << \", cnum:\" << cnum << \", c1:\" << c1 << \"\\n\";\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tif (cmin <= 0 || cmin>c1) cmin = c1;\n\n\t\t//\t}\n\t\t\th--;\n\t\t}\n\n\t\tcmin2 = 0;\n\t\tc1 = 0;\n\t\th = calc_shimen(num);\n\t\twhile (h >= 1){\n\t\t\ti = h;\n\t\t\tcnum = num;\n\n\n\t\t\tk = shimen[i];\n\t\t//\tstd::cout << \"begin i:\" << i << \", k:\" << k << \"\\n\";\n\t\t\t//\tif (cmin <= 0 || num / k < cmin){\n\t\t\tc1 = 0;\n\t\t\twhile (i >= 0){\n\t\t\t\tif ((k = shimen[i]) % 2){\n\t\t\t\t\tc1 += cnum / k;\n\t\t\t\t\tcnum -= cnum / k*k;\n\t\t\t\t//\tstd::cout << \"k:\" << k << \", cnum:\" << cnum << \", c1:\" << c1 << \"\\n\";\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (cmin2 <= 0 || cmin2>c1) cmin2 = c1;\n\n\t\t\t//\t}\n\t\t\th--;\n\t\t}\n\n\t\tstd::cout << cmin << \" \" << cmin2 << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define REP2(i,x,n) for(int i=x; i<(n); i++)\n#define PRINT(x) cout<<(x)<<endl\n#define INF 1000000000000 // 10^12\n#define MOD 1000000007 // 10^9+7\n#define PB push_back\n#define MP make_pair\n\nconst int MAX_N = 1000000;\n\nint N;\n\nint dp[MAX_N + 1], dp_odd[MAX_N + 1];\n\nint main() {\n    vector<int> tetra, tetra_odd;\n    for (int i = 1; i <= 200; i++) {\n        int a = i * (i+1) * (i+2) / 6;\n        tetra.PB(a);\n        if (a % 2 == 1) tetra_odd.PB(a);\n    }\n\n    REP(i, MAX_N + 1) {\n        dp[i] = MOD;\n        dp_odd[i] = MOD;\n    }\n    dp[0] = 0;\n    dp_odd[0] = 0;\n\n    REP(i, MAX_N) {\n        REP(j, tetra.size()) {\n            if (i + tetra[j] <= MAX_N) dp[i + tetra[j]] = min(dp[i + tetra[j]], dp[i] + 1);\n        }\n        REP(j, tetra_odd.size()) {\n            if (i + tetra_odd[j] <= MAX_N) dp_odd[i + tetra_odd[j]] = min(dp_odd[i + tetra_odd[j]], dp_odd[i] + 1);\n        }\n    }\n    \n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        printf(\"%d %d\\n\", dp[N], dp_odd[N]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define M 1000000\n#define INF 10000000\n\n#define min(a,b) (a<b?a:b)\n\nint main() {\n\tint n;\n\tvector<int> fn, fno;\n\tstatic int dp[M+1], odp[M+1];\n\tfor(int i=1; i<=100; ++i) {\n\t\tfn.push_back(i*(i+1)*(i+2)/6);\n\t\tif(fn[i-1]%2==1) fno.push_back(fn[i-1]);\n\t}\n\tfor(int i=0; i<=M; ++i) dp[i] = odp[i] = INF;\n\tdp[0] = 0; dp[1] = 1; odp[0] = 0; odp[1] = 1;\n\tfor(int i=2; i<=M; ++i) {\n\t\tfor(int j=0; j<100; ++j) {\n\t\t\tif(i-fn[j]>=0) dp[i] = min(dp[i], dp[i-fn[j]]+1);\n\t\t\telse break;\n\t\t}\n\t\tfor(int j=0; j<(signed)fno.size(); ++j) {\n\t\t\tif(i-fno[j]>=0) odp[i] = min(odp[i], odp[i-fno[j]]+1);\n\t\t\telse break;\n\t\t}\n\t}\n\t\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tcout << dp[n] << \" \" << odp[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#define REP(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define MAX_N 1000000\n#define MAX_P 190\ntypedef unsigned int uint;\nint p[MAX_P];\nint op[MAX_P];\nchar pn[MAX_N];\nchar opn[MAX_N];\n\nint main()\n{\n\tREP(i,MAX_P) p[i]=i*(i+1)*(i+2)/6;\n\n\tREP(i,MAX_P)for(int j=i;j<MAX_N;j++)\n\t{\n\t\tif((j*(j+1)*(j+2)/6)%2 ==1)\n\t\t{\n\t\t\top[i]=j*(j+1)*(j+2)/6;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tREP(i,MAX_P) pn[i]=opn[i]=i;\n\tfor(int i=2;i<MAX_N;i++)\n\t{\n\t\tif(p[i]>MAX_N) break;\n\n\t\tfor(int j=p[i];j<MAX_N+1;j++)\n\t\t{\n\t\t\tpn[j] = min((uint)pn[j-p[i] ]+1,(uint)pn[j]);\n\t\t\t//cout <<(int) pn[j];\n\t\t}\n\t\t//cout << endl;\n\t}\t\n\n\tfor(int i=2;i<MAX_N;i++)\n\t{\n\t\tif(op[i]>MAX_N) break;\n\n\t\tfor(int j=op[i];j<MAX_N+1;j++)\n\t\t{\n\t\t\topn[j] = min((uint)(opn[j-op[i] ]+1),(uint)opn[j]);\n\t\t}\n\t}\n\n\n\t\n\tint n;\n\twhile(cin >> n &&n)\n\t{\n\t\n\n\n\n\n\t\tcout << (uint)pn[n]  <<\" \" << (uint)opn[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\n\nint oddrec(int target, int sum, int cnt) {\n    int res=0xFFFF;\n    if(sum == target) return cnt;\n    for(int i=oddlist.size()-1; 0<=i && res>cnt; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1));\n    }\n    return res;\n}\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    int listcnt, oddlistcnt;\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\",res,oddrec(n, 0, 0));\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define MAXNUM 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM];\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//1からMAXまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp1[1000001],dp2[1000001];\nint main(){\n  int c1[100000],c2[100000],i,m,p=0,k;\n  for(i=0;i*(i+1)*(i+2)/6<=1000000;i++){\n    c1[i]=i*(i+1)*(i+2)/6;\n    if(c1[i]%2==1){\n      c2[p]=c1[i]; \n      p++; \n    }\n  }\n  for(int j=0;j<=1000000;j++){\n    dp1[j]=j;\n    dp2[j]=j;\n    for(int k=0;k<i;k++){\n      if(j-c1[k]>=0)dp1[j]=min(dp1[j],dp1[j-c1[k]]+1);\n      if(k<p){\n\tif(j-c2[k]>=0){\n\tdp2[j]=min(dp2[j],dp2[j-c2[k]]+1);\n       }\n      }\n    }\n  }\n\n  while(1){\n  cin >>m;\n  if(m==0)break;\n\n  cout << dp1[m]<<\" \"<<dp2[m]<<endl;\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <queue>\n#include <string>\n#define REP(i,a,b) for (int i = a; i < (b); i++)\n#define sz(t) int(t.size())\n#define INF 1000000000\nconst int DIV = 1000000000 + 7;\nusing namespace std;\ntypedef long long ll;\n\nint main(void) {\n    vector<int> ps;\n    // vector<int> ps_odd;\n    REP(i, 1, 182) {\n        int val = i * (i + 1) * (i + 2) / 6;\n        ps.push_back(val);\n        // if (val % 2 == 1) {\n        //     ps_odd.push_back(val);\n        // }\n    }\n    vector<int> dp(1000005, INF);\n    vector<int> dp_odd(1000005, INF);\n\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    REP(i, 0, ps.size()) {\n        int p = ps[i];\n        REP(j, 0, 1000005) {\n            if (j >= p) {\n                dp[j] = min(dp[j - p] + 1, dp[j]);\n                if (p % 2 == 1) {\n                    dp_odd[j] = min(dp_odd[j - p] + 1, dp_odd[j]);\n                }\n            }\n        }\n    }\n\n    for (;;) {\n        int x;\n        cin >> x;\n        if (x == 0) {\n            break;\n        }\n        cout << dp[x] << ' ' << dp_odd[x] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n \nusing namespace std;\n \nconst int SIZE = 181 + 1;\nconst int MAX = 1000000;\n \nint T[SIZE];\nint cost1[MAX], cost2[MAX];\n \nint main( void )\n{  \n    for(int i=0; i < SIZE; ++i) T[i] = i * (i + 1) * (i + 2) / 6;\n \n    fill(cost1, cost1+MAX, MAX);\n    fill(cost2, cost2+MAX, MAX + MAX);\n    cost1[0] = cost2[0] = 0;\n    for(int i=0; i < MAX; ++i) {\n        //if(cost1[i] < 6) {\n            for(int j=0; j < SIZE; ++j) {\n                if(i + T[j] < MAX && cost1[i] < 5)\n                    cost1[i + T[j]] = min(cost1[i + T[j]], cost1[i] + 1);\n                if(T[j] & 1) {\n                    if(i + T[j] < MAX)\n                        cost2[i + T[j]] = min(cost2[i + T[j]], cost2[i] + 1);\n                }\n            }\n    }\n    int n;\n    while(cin >> n, n) {\n        cout << cost1[n] << ' ' << cost2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nint v[1000];\nint main()\n{\n\tint n;\n\tfor (int j = 0; j <= 1000000; j++)\n\t{\n\t\tdp[0][j] = 999999;\n\t\tdp[1][j] = 999999;\n\t}\n\tdp[0][0] = 0;\n\tdp[1][0] = 0;\n\tfor (int i = 1;; i++)\n\t{\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif (k > 1000000)break;\n\t\tv[i - 1] = k;\n\t}\n\tfor (int i = 0; i <= 1000000; i++)\n\t{\n\t\tfor (int j = 0;; j++)\n\t\t{\n\t\t\tif (i + v[j] > 1000000)break;\n\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]], dp[0][i] + 1);\n\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t}\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    vector<int> table;\n    int cur = 1;\n    int bound = 1e+6;\n    for(;;){\n        ll val = (ll)cur * (cur + 1) * (cur + 2) / 6;\n        if(val > bound) break;\n        table.emplace_back(val);\n        ++cur;\n    }\n    vector<int> dp(bound, INF);\n    dp[0] = 0;\n    vector<int> dp2 = dp;\n    for(int x : table){\n        for(int i = 0; i < bound - x; ++i){\n            chmin(dp[i + x], dp[i] + 1);\n            if(x % 2)   chmin(dp2[i + x], dp2[i] + 1);\n        }\n    }\n    \n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)  return 0;\n        cout << dp[n] << ' ' << dp2[n] << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * aoj/1167_2nd/main.cpp\n */\n\n// C++ 14\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring> // memset\n#include <cassert>\n\nusing namespace std;\n\n#define ll long long\n\n#define loop(__x, __start, __end) for(int __x = __start; __x < __end; __x++)\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\n\nconst ll MAX_N = 1000100;\nll N;\nll P[180];\nll dp[MAX_N];\nll dp_odd[MAX_N];\n\nvoid build() {\n  for (int n=1; n<=180; n++) {\n    P[n-1] = n * (n+1) * (n+2) / 6;\n  }\n}\n\n\nbool input() {\n  cin >> N;\n  if (N==0) return false;\n  return true;\n}\n\nvoid receive() {\n  for (ll n=1; n<MAX_N; n++) {\n    for (int i=0; i<180; i++) {\n      if (i==0) { dp[n] = n; dp_odd[n] = n; continue; } // P[i] = 1 (奇数)\n      if (n-P[i]>=0) chmin(dp[n], dp[n-P[i]] + 1);\n      if (n-P[i]>=0 and P[i] % 2 == 1) chmin(dp_odd[n], dp_odd[n-P[i]] + 1);\n    }\n  }\n}\n\nvoid solve() {\n  cout << dp[N] << \" \" << dp_odd[N] << endl;\n}\n\nint main() {\n  // cout.precision(15);\n  build();\n  receive();\n  while (input()) solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nconst int INF = 100000000;\n\nint main(){\n\n\tint n;\n//\tint dp[1000001];\n\tvector<int> dp(1000001,0);\n\tvector<int> dp2(1000001,0);\n\t\tvector<int> triNum;\n\t\tint sum = 1;\n\t\tint idx = 2;\n\t\tint allSum = 0;\n\t\twhile(sum <= 1000000){\n\t\t\tallSum += sum;\n\t\t\ttriNum.push_back(allSum);\n\t\t\tsum += idx;\n\t\t\tidx++;\n\t\t}\n\t\tfill(dp.begin(),dp.end(),INF);\n\t\tfill(dp2.begin(),dp2.end(),INF);\n\t\tdp[1] = 1;\n\t\tdp[2] = 2;\n\t\tdp[3] = 3;\n\t\tdp[0] = 0;\n\n\t\tdp2[1] = 1;\n\t\tdp2[2] = 2;\n\t\tdp2[3] = 3;\n\t\tdp2[0] = 0;\n\n\n\t\tfor(int i = 4; i <= 1000001; i++){\n\t\t\tfor(int j = 0; j < triNum.size(); j++){\n\t\t\t\tif(i - triNum[j] == 0){\n\t\t\t\t\tif(triNum[j] % 2)\n\t\t\t\t\t\tdp2[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(i - triNum[j] < 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(triNum[j] % 2)\n\t\t\t\t\tdp2[i] = min(dp2[i],dp2[i-triNum[j]]+1);\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < triNum.size(); j++){\n\t\t\t\tif(i - triNum[j] == 0){\n\t\t\t\t\tdp[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(i - triNum[j] < 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdp[i] = min(dp[i],dp[i-triNum[j]]+1);\n\t\t\t}\n\t\t}\n\n\twhile(cin >> n && n != 0){\n\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\nint dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= 50; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[84];\n    int b[22];\n    int t[10000];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tconst int MAXN = 1000000;\n\n\tVI dpAll( MAXN, INT_MAX ), dpOdd( MAXN, INT_MAX );\n\tdpAll[0] = dpOdd[0] = 0;\n\tREP( i, 0, MAXN )\n\t{\n\t\tREP( j, 1, 1000001 )\n\t\t{\n\t\t\tconst int s = j * ( j + 1 ) * ( j + 2 ) / 6;\n\t\t\tif ( MAXN <= i + s )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdpAll[ i + s ] = min( dpAll[ i + s ], dpAll[i] + 1 );\n\t\t\tif ( s % 2 )\n\t\t\t{\n\t\t\t\tdpOdd[ i + s ] = min( dpOdd[ i + s ], dpOdd[i] + 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << dpAll[n] << ' ' << dpOdd[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvvi tetra(2);\nvvi dp(2, vi(1e6, 1e6));\n\nvoid preset() {\n    int n;\n    for (int i=0; (n = i*(i+1)*(i+2)/6) < 1e6; i++) {\n        tetra[0].push_back(n);\n        if (n % 2 == 1) tetra[1].push_back(n);\n    }\n\n    for (int i=0; i<2; i++) {\n        dp[i][0] = 0;\n        for (int k : tetra[i]) {\n            for (int j=k; j<1e6; j++) {\n                dp[i][j] = min(dp[i][j], dp[i][j-k]+1);\n            }\n        }\n    }\n}\n\nint main() {\n    preset();\n\n    int a;\n    while (cin >> a) {\n        if (a == 0) break;\n        cout << dp[0][a] << \" \" << dp[1][a] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n,i,j,k,t=0,a[250]={},b[200]={},c[1000005]={2000000},d[1000005]={1000000};\n  for(i=1;i<250;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(a[i-1]%2==1)b[t++]=a[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<250;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t-1;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<d[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n    int i, input, tetras[181] = {0}, ans[1000000][2] = {{0}, {0}};\n    int a = 0, b = 0; /* a, b???ans??????????????????????????? */\n\n    /* ??£?????¢?????°?¨???? */\n    for (i = 1; i < 181; i++) {\n        tetras[i] = i * (i+1) * (i+2) / 6;\n    }\n\n    while (cin >> input) {\n        if (input == 0) break;  /* input???0??§break */\n        int temp = input; /* input??????????????? */\n        int j = 1, min = input; /* min???????????????input */\n        /* tetras????????§input??\\?????§????????§??????????????¢??? */\n        while (tetras[j] <= input) j++;\n        j--;\n        int l = j; /* j ??????????????? */\n      \n        /* ?????????????????¢?????° */\n        while (j > 1) {\n            int n = 0;\n            int k = j;\n            while (1) {\n                /* tetras[k] > input???????£???°??? */\n                if (tetras[k] > input) {\n                    k--;\n                    continue;\n                }\n                input -= tetras[k];\n                if (input > 0) {\n                    n++;\n                } else if (input == 0) {\n                    n++;\n                    break;\n                }else {\n                    input += tetras[k];\n                    k--;\n                    continue;\n                }\n            }\n            if (min > n) min = n;\n            j--;\n            input = temp;\n        }\n        ans[a][0] = min;\n      \n        /* ?\\???°?????£?????¢?????°?????? */\n        j = l;  /* j??????????????? */\n        min = input; /* min??????????????? */\n        while (j > 1) {\n            /* ??¶??°?????£?????¢?????°????£???°??? */\n            if (tetras[j] % 2 == 0) {\n                j--;\n                continue;\n            }\n            int n = 0;\n            int k = j;\n            while (1) {\n                /* ??¶??°?????£?????¢?????°????£???°??? */\n                if (tetras[k] % 2 == 0 || tetras[k] > input) {\n                    k--;\n                    continue;\n                }\n                input -= tetras[k];\n                if (input > 0) {\n                    n++;\n                } else if (input == 0) {\n                    n++;\n                    break;\n                }else {\n                    input += tetras[k];\n                    k--;\n                    continue;\n                }\n            }\n            if (min > n) min = n;\n            j--;\n            input = temp;\n        }\n        ans[a][1] = min;\n      \n        a++;\n    }\n\n    for (b = 0; b < a; b++) {\n        cout << ans[b][0] << ' ' << ans[b][1] << endl;\n    }\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;n<=p[i] && i<181;i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;n<=p[i] && i<181;i++) if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <stdio.h>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <time.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> Pii;\ntypedef pair<int, ll> Pil;\ntypedef pair<ll, ll> Pll;\ntypedef pair<ll, int> Pli;\n\n#define fi first\n#define se second\n#define mp make_pair\n \nconst ll MOD = 1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll INF = 1ll << 60;\nconst double PI = 2 * asin(1);\n\nvoid yes() {printf(\"yes\\n\");}\nvoid no() {printf(\"no\\n\");}\nvoid Yes() {printf(\"Yes\\n\");}\nvoid No() {printf(\"No\\n\");}\nvoid YES() {printf(\"YES\\n\");}\nvoid NO() {printf(\"NO\\n\");}\n\nll N;\nvector <ll> All, Odd;\nint C1[int(1e6 + 5)], C2[int(1e6 + 5)];\nint Prepare(){\n  ll cnt = 1, now = 1;\n  while (now < 1e6){\n    now = cnt * (cnt + 1) * (cnt + 2) / 6;\n    All.push_back(now);\n    if (now % 2 != 0) Odd.push_back(now);\n    cnt++;\n  }\n\n  queue <int> que; que.push(0);\n  while (!que.empty()){\n    int Q = que.front(); que.pop();\n    for (int i = 0; i < All.size(); i++){\n      int num = Q + All[i];\n      if (num > 1e6) break;\n      if (C1[num] == 0){\n        C1[num] = C1[Q] + 1; que.push(num);\n      }\n    }\n  }\n  que.push(0);\n  while (!que.empty()){\n    int Q = que.front(); que.pop();\n    for (int i = 0; i < Odd.size(); i++){\n      int num = Q + Odd[i];\n      if (num > 1e6) break;\n      if (C2[num] == 0){\n        C2[num] = C2[Q] + 1; que.push(num);\n      }\n    }\n  }\n  return 0;\n}\n\n\nint main(){\n  Prepare();\n  while (cin >> N){\n    if (N == 0) return 0;\n    cout << C1[N] << \" \" << C2[N] << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint all[1000001];\nint odd[1000001];\n\nint const INF = 1<<29;\n\nint main() {\n  \n  fill(all, all+1000001, INF);\n  fill(odd, odd+1000001, INF);\n  \n  all[0] = odd[0] = 0;\n  \n  for(int i=1; ; i++) {\n    int n = i*(i+1)*(i+2);\n    if(n > 1000000) break;\n    for(int j=n; j<=1000000; j++) {\n      all[j] = min(all[j-n]+1, all[j]);\n      if(n % 2) {\n\todd[j] = min(odd[j-n]+1, odd[j]);\n      }\n    }\n  }\n  \n  int N;\n  while(cin >> N && N) {\n    cout << all[N] << ' ' << odd[N] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MAX = 1000000;\nconst int INF = 1<<29;\nint main(){\n  vector<int> dp_1(MAX+1,INF);\n  vector<int> dp_2(MAX+1,INF);\n  vector<int> poll(1000,0);\n  for(int i = 0;i < 200;i++)poll[i] = i*(i+1)*(i+2)/6;\n  dp_1[0] = 0;\n  dp_2[0] = 0;\n  for(int i = 1;i < MAX;i++){\n    dp_1[i] = i;\n    dp_2[i] = i;\n    for(int j = 0;i-poll[j]>=0;j++){\n      dp_1[i] = min(dp_1[i],dp_1[i-poll[j]]+1);\n      if(poll[j] % 2 == 1)dp_2[i] = min(dp_2[i],dp_2[i-poll[j]]+1);\n    }\n  }\n  int n;\n  //  cout << \"aaaaaa\" << endl;\n  while(cin >> n,n != 0){\n    cout << dp_1[n] << \" \" << dp_2[n] << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint z1[1000000] = { 0 };\nint z2[1000000] = { 0 };\n\nvoid pollock(int n) {\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= n; i++) {\n\t\tz1[i*(i + 1)*(i + 2) / 6] = 1;\n\t\tif ((i*(i + 1)*(i + 2) / 6) % 2 == 1) z2[i*(i + 1)*(i + 2) / 6] = 1;\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (z1[i] == 0 || (z1[i] != 0 && z1[j] + z1[i - j] < z1[i])) z1[i] = z1[j] + z1[i - j];\n\t\t\tif (z2[i] == 0 || (z2[i] != 0 && z2[j] + z2[i - j] < z2[i])) z2[i] = z2[j] + z2[i - j];\n\t\t}\n\t}\n\n\tcout << z1[n] << \" \" << z2[n] << endl;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tpollock(n);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[1000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b???ans??????????????????????????? */\n\n  /* ??£?????¢?????°?¨???? */\n  for (i = 1; i < 200; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;  /* input???0??§break */\n    int temp = input; /* input??????????????? */\n    int j = 1, min = 1000;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n      \n    /* ?????????????????¢?????° */\n    while (j > 0) {\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][0] = min;\n      \n    /* ?\\???°?????£?????¢?????°?????? */\n    j = l;  /* j??????????????? */\n    min = 1000; /* min??????????????? */\n    while (j > 0) {\n        /* ??¶??°?????£?????¢?????°????£???°??? */\n        if (tetras[j] % 2 == 0) {\n            j--;\n            continue;\n        }\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* ??¶??°?????£?????¢?????°????£???°??? */\n            if (tetras[k] % 2 == 0) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][1] = min;\n      \n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  vector<int> v(200);\n  FOR(i,0,200) v[i] = i * (i + 1) * (i + 2) / 6;\n\n  int dp[1000006];\n  FOR(i,0,1000006) dp[i] = 1e9;\n  dp[0] = 0;\n  FOR(i,0,1000006) {\n    FOR(j,0,v.size()) {\n      if(i - v[j] >= 0) dp[i] = min(dp[i], dp[i - v[j]] + 1);\n    }\n  }\n\n  int dp_even[1000006];\n  FOR(i,0,1000006) dp_even[i] = 1e9;\n  dp_even[0] = 0;\n  FOR(i,0,1000006) {\n    FOR(j,0,v.size()) {\n      if(v[j]%2 == 0) continue;\n      if(i - v[j] >= 0) dp_even[i] = min(dp_even[i], dp_even[i - v[j]] + 1);\n    }\n  }\n  while(cin>>n,n) {\n    cout << dp[n] << \" \" << dp_even[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint p[200],q[50];\n\nint f(int n,int m,int c){\n\tif(c==4&&n>0)return 5;\n\tif(n<10)return min(c+n/4+n%4,5);\n\tint rec=5,i=0;\n\twhile(p[i]<n/(4-c))i++;\n\tfor(i;p[i]<=m;i++)rec=min(rec,f(n-p[i],min(p[i],n-p[i]),c+1));\n\treturn rec;\n}\n\nint g(int n,int m,int c){\n\tif(n<165)return c+n/35+n%35;\n\tint rec=99999;\n\tfor(int i=1;p[i]<=m;i++)rec=min(rec,f(n-p[i],min(p[i],n-p[i]),c+1));\n\treturn rec;\n}\n\nint main(){\n\tfor(int i=0;(i+1)*(i+2)*(i+3)/6<=1000000;i++)p[i]=(i+1)*(i+2)*(i+3)/6;\n\tfor(int i=0;(4*i+1)*(4*i+2)*(4*i+3)/6<=1000000;i++)q[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\tint N;\n\twhile(cin>>N){\n\t\tif(!N)return 0;\n\t\tcout<<f(N,N,0)<<\" \"<<g(N,N,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\n//vector<vector<int>> dp;\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//dp.resize(C_N + 2);\n\t\t/*for (int i = 0; i < C_N + 2; i++) {\n\t\t\tdp[i].resize(N + 2);\n\t\t}*/\n\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[60]={0},c[200001]={0,1,2,3},d[200001],k=0,i,j,n;\n  for(i=1;i<100;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<99;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\ntypedef pair<int,int> p;\n\nint main()\n{\n\t\n\tvector<int> all(1000001),odd(1000001);\n\tfor(int i=0;i<=1000000;i++){\n\t\tall[i]=odd[i]=i; //??¨???1???????????´???\n\t}\n\t\n\t\n\tfor(int i=1;;i++){\n\t\tint x=i*(i+1)*(i+2)/6;\n\t\tif(x>1000000) break;\n\t\t\n\t\tfor(int j=0;j<=1000000;j++){\n\t\t\tif(j-x<0) continue;\n\t\t\t\n\t\t\tall[j]=min(all[j],all[j-x]+1);\n\t\t\tif(x%2) odd[j]=min(odd[j],odd[j-x]+1);\n\t\t}\n\t}\n\t\t\t\n\tint n;\n\twhile(cin>>n,n){\n\t\t\n\t\tcout<<all[n]<<\" \"<<odd[n]<<endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    long long i;\n    int n;\n    long long j = 0;\n    int a[84];\n    int b[22];\n    long long t[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n#define MAX 1000000\n\nvector<int> nums,odds;\n\nint  dp[MAX+1];\nint dp2[MAX+1];\n\nint dfs(int n, int *memo, vector<int> &vec){\n  if(memo[n]!=-1) return memo[n];\n  int ret = INF;\n  for(int nxt : vec){\n    if(n==nxt) return 1;\n    if(n>nxt) ret = min(ret, dfs(n-nxt, memo, vec)+1);\n  }\n  return memo[n] = ret;\n}\n\nint main(){\n  int tmp=0, n=1;\n  while(tmp<=MAX){\n    tmp+=n*(n+1)/2;\n    nums.pb(tmp);\n    if(tmp%2==1) odds.pb(tmp);\n    n++;\n  }\n\n  fill(dp, dp+MAX+1, -1);\n  fill(dp2, dp2+MAX+1, -1);\n\n  dp[0] = dp2[0] = 0;\n\n  // ??§????????????????????????????????¨?????°?????°????¢????????????????\n  reverse(all(nums));\n  reverse(all(odds));\n\n  while(cin>>n, n){\n    cout << dfs(n, dp, nums) << \" \" << dfs(n, dp2, odds) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##_len=(int)(n);i<i##_len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nint tetr[131];\nint dp1[2][1234567];\nint dp2[2][1234567];\nsigned main() {\n    REP(i,130) tetr[i]=(i+1)*(i+2)*(i+3)/6;\n    fill(ALL(dp1[0]),INF);\n    fill(ALL(dp1[1]),INF);\n    fill(ALL(dp2[0]),INF);\n    fill(ALL(dp2[1]),INF);\n\n    dp1[0][0]=0;\n    dp2[0][0]=0;\n    REP(i,130) {\n        REP(j,1000010) {\n            if(dp1[i%2][j]!=INF) {\n                for(int k=0; j+tetr[i]*k<=100010; k++) {\n                    if(j+tetr[i]*k<=1000010)\n                        chmin(dp1[(i+1)%2][j+tetr[i]*k],dp1[i%2][j]+k);\n                }\n            }\n        }\n    }\n    REP(i,130) {\n        REP(j,1000010) {\n            if(tetr[i]%2==0) {\n                chmin(dp2[(i+1)%2][j],dp2[i%2][j]);\n                continue;\n            }\n            if(dp2[i%2][j]!=INF) {\n                for(int k=0; j+tetr[i]*k<=100010; k++) {\n                    if(j+tetr[i]*k<=1000010)\n                        chmin(dp2[(i+1)%2][j+tetr[i]*k],dp2[i%2][j]+k);\n                }\n            }\n        }\n    }\n\n    while(1) {\n        int n;\n        cin>>n;\n        if(n==0) break;\n        cout<<dp1[0][n]<<\" \"<<dp2[0][n]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    //int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  //tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    //int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",1,2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <cmath>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#define FOR(i, a) for(i = 0; i < (a); i++)\n#define FORM(i, a) for(i = (a) i >= 0; i--)\n#define INF 100000\nusing namespace std;\nint c[1000], odd[1000];\nint mini[1000001];\nint miniodd[1000001];\nint main(){\nint i, j, W, minimumc, minimumodd, l;\n \n\n   for(i = 1; i <= 200; i++){\n\t   c[i] = (i*(i+1)*(i+2))/6;\n   }\n   j = 1;\n   for(i = 1; i <= 200; i++){\n\t   if(c[i] % 2 == 1){\n\t\t   odd[j] = c[i];\n\t\t   j += 1;\n\t   }\n   }\n\n  FOR(i, 1000000){\n\t  mini[i] = 10000000;\n\t  miniodd[i] = 10000000;\n  }\n  mini[0] = 0;\n  miniodd[0] = 0;\n   for(j = 1; j <= 180; j++){\n\t for(i = c[j]; i <= 1000000; i++){\n\t   mini[i] = min(mini[i], mini[i - c[j]] + 1);\n\t }\n   }\n      for(j = 1; j <= 50; j++){\n\t for(i = odd[j]; i <= 1000000; i++){\n\t   miniodd[i] = min(miniodd[i], miniodd[i - odd[j]] + 1);\n\t }\n   }\n   \n\t  cin >> W;\n\n\t  while(W != 0){\n\t\t  cout << mini[W] << \" \" << miniodd[W] << endl;\n\n\t\t  cin >> W;\n\t  }\n\n   \n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n;\n\tint i1,i2;\n\tint nn;\n\tint min;\n\tint num;\n\tint max;\n\tvector<int> v;\n\t\n\t\n\n\tmax=0;\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tif(max<n) max=n;\n\t\tv.push_back(n);\n\t\t\n\t}\n\n\tvector<int> pollock(max+1,0);\n\tvector<int> pollock2(max+1,0);\n\tvector<int> p;\n\tvector<int> p2;\n\tnn=1;\n\tnum=(nn*(nn+1)*(nn+2))/6;\n\n\tfor(i1=1;i1<=max;i1++){\t\t\t\n\n\t\tif(i1==num) {\n\t\t\tif(i1%2==1){\n\t\t\t\tp.push_back(i1);\n\t\t\t\tp2.push_back(i1);\n\t\t\t\tnn++;\n\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6;\n\t\t\t\tpollock[i1]=1;\n\t\t\t\tpollock2[i1]=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnn++;\n\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6;\n\t\t\t\tp.push_back(i1);\n\t\t\t\tpollock[i1]=1;\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock2[i1]=min+1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmin=100000;\n\t\t\tfor(i2=0;i2<p.size();i2++){\n\t\t\t\tif((pollock[i1-p[i2]])<min){\n\t\t\t\t\tmin=pollock[i1-p[i2]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpollock[i1]=min+1;\n\n\t\t\tmin=100000;\n\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpollock2[i1]=min+1;\n\t\t}\n\t\t\t//cout<<pollock[i1]<<\" \";\n\t}\n\n\tfor(i1=0;i1<v.size();i1++){\n\n\t\tcout << pollock[v[i1]] << \" \" << pollock2[v[i1]] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n \n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n \nusing namespace std;\n \ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n \n \n \nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n \nint n = 0;\n \n \n \nvoid input() {\n    CI n;\n}\n \n \nvoid proce_odd() {\n    vector<int> tetra;\n    int num = 1;\n \n    int i = 0;\n    int remain = 0;\n    int maxx = 0;\n \n    while (true) {\n \n        if (i * (i + 1) * (i + 2) / 6 > n && (i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n            i--;\n            auto ite = tetra.end();\n            ite--;\n            maxx = *ite;\n            break;\n        }\n        if ((i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n            tetra.push_back(i * (i + 1) * (i + 2) / 6);\n        }\n        i++;\n    }\n \n    remain = n - maxx;\n    vector<int>::iterator it_end = tetra.end();\n    vector<int>::iterator it_last = tetra.end();\n    --it_end;\n \n    int num_min = 1000001;\n    while (1) {\n        while (remain > 0) {\n            num++;\n            ++it_end;\n            it_end = lower_bound(tetra.begin(), it_end, remain);\n            --it_end;\n \n            remain -= *it_end;\n        }\n        if (num_min > num) {\n            num_min = num;\n        }\n        num = 1;\n        remain = n - *--it_last;\n        if (remain == n - 1)break;\n        it_end = it_last;\n    }\n \n    CO num_min E;\n \n}\n \nvoid proce() {\n    vector<int> tetra;\n    int num = 1;\n \n    int i = 0;\n    int remain = 0;\n    int maxx = 0;\n \n    while (true) {\n \n        if (i * (i + 1) * (i + 2) / 6 > n) {\n            i--;\n            maxx = i * (i + 1) * (i + 2) / 6;\n            break;\n        }\n        tetra.push_back(i * (i + 1) * (i + 2) / 6);\n        i++;\n    }\n \n    remain = n - maxx;\n    vector<int>::iterator it_end = tetra.end();\n    vector<int>::iterator it_last = tetra.end();\n    --it_end;\n \n    int num_min = 1000001;\n    while (1) {\n        while (remain > 0) {\n            num++;\n            ++it_end;\n            it_end = lower_bound(tetra.begin(), it_end, remain);\n            --it_end;\n \n            remain -= *it_end;\n        }\n        if (num_min > num) {\n            num_min = num;\n        }\n        num = 1;\n        remain = n - *--it_last;\n        if (remain == n - 1)break;\n        it_end = it_last;\n    }\n \n    CO num_min;\n \n \n}\n \nint main(void) {\n    while (true) {\n        input();\n        if (n == 0)break;\n \n        proce();\n \n        CO ' ';\n \n        proce_odd();\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nnamespace Solver {\n\n    int N;\n    vector<int> m1, m2;\n    inline bool Read() {\n        cin >> N;\n        return N != 0;\n    }\n\n    int dfs(int n, bool odd)\n    {\n        if ( odd && m2[n] != -1) return m2[n];\n        if (!odd && m1[n] != -1) return m1[n];\n\n        int ans = 1e6, t = -1, tt = -1;\n        for (int i = 1000; i >= 1; i--) {\n            int vol = ((i * (i + 1) * (i + 2)) / 6);\n            if (odd && vol % 2 != 1) continue;\n\n            int rest = n - vol;\n            if (rest < 0) continue;\n            int p = ans;\n            ans = min(ans, dfs(rest, odd) + 1);\n            if (ans != p) {\n                t = i;\n                tt = rest;\n            }\n        }\n\n        if ( odd) m2[n] = ans;\n        if (!odd) m1[n] = ans;\n        return ans;\n    }\n\n    inline void Work() {\n        cout << dfs(N, false) << \" \" << dfs(N, true) << endl;\n    }\n\n    inline void Solve() {\n\n        m1.resize(10e6 + 1, -1);\n        m2.resize(10e6 + 1, -1);\n        m1[0] = m2[0] = 0;\n\n        while (Read()) Work();\n    }\n}\n\nint main() {\n    Solver::Solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<deque>\n#include<map>\n#include<bitset>\nusing namespace std;\n// using ll = long long;\n\n#define rep(i, n) for(int i = 0;i < (n);i++)\n#define repr(i, n) for(int i = (n);i >= 0;i--)\n#define repf(i, m, n) for(int i = (m);i < (n);i++)\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1;} return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1;} return 0;}\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n///////////////////////////////////////////////\n\nint dp[1001001], dp2[1001001];\n\nint main() {\n    int n;\n    int inf = 1e6+10;\n    vector<int> a(201);\n    repf(i,1,201) {\n        a[i] = i*(i+1)*(i+2)/6;\n    }\n    memset(dp, inf, sizeof(dp));\n    memset(dp2, inf, sizeof(dp2));\n    dp[0] = dp2[0] = 0;\n        \n    repf(i,1,201) rep(j,1e6+1) {\n        int nj = j+a[i];\n        if (nj > 1e6+1) continue;\n        chmin(dp[nj] ,dp[j]+1);\n        if (a[i]%2==1) chmin(dp2[nj] ,dp2[j]+1);\n    }\n\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        cout << dp[n] << ' ' << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tvector<int> dp(1000000, INT_MAX / 2);\n\tdp[0] = 0;\n\tvector<int> _dp = dp;\n\tfor (int i = 1; i <= 200; i++) {\n\t\tint x = i * (i + 1) * (i + 2) / 6;\n\t\tfor (int j = x; j < 1000000; j++)\n\t\t\tdp[j] = min(dp[j], dp[j - x] + 1);\n\t\tif (x % 2 == 1)\n\t\t\tfor (int j = x; j < 1000000; j++)\n\t\t\t\t_dp[j] = min(_dp[j], _dp[j - x] + 1);\n\t}\n\tfor (;;) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tcout << dp[n] << ' ' << _dp[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1500001]={0,1,2,3},d[1500001],k=0,i,j,n;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<198;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\nint index;\nint fourth[201];\nint odd[201];\nint mintable[1500000];\nint mintableOdd[1500000];\n\nvoid init(){\n\tfourth[0] = 0;\n\todd[0] = 0;\n\tindex = 0;\n\tfor(int i = 1; i <= 200; i++){\n\t\tfourth[i] = (i*(i+1)*(i+2))/6;\n\t\tmintable[fourth[i]] = 1;\n\t\tif(fourth[i]%2){\n\t\t\todd[++index] = fourth[i];\n\t\t\tmintableOdd[odd[index]] = 1;\n\t\t}\n\t}\n}\n\nint dfs(int n){\n\tfor(int i = 2; i <= n/i; i++){\n\t\tif(n%i==0){\n\t\t\treturn min(dfs(n/i)*i, mintable[n]);\n\t\t}\n\t}\n\treturn mintable[n];\n}\n\nint dfsOdd(int n){\n\tfor(int i = 3; i <= n/i; i+=2){\n\t\tif(n%i==0){\n\t\t\treturn min(dfsOdd(n/i)*i, mintableOdd[n]);\n\t\t}\n\t}\n\treturn mintableOdd[n];\n}\n\nint countFourth(int n){\n\tint min = 10000;\n\tfor(int i = 200; i >= 1; i--){\n\t\tif(n>=fourth[i]){\n\t\t\tint tmp = n;\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j >= 1; j--){\n\t\t\t\twhile(tmp>=fourth[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp -= fourth[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = min>count?count:min; \n\t\t}\n\t}\n\treturn min;\n}\n\nint countFourthOdd(int n){\n\tint min = 10000;\n\tfor(int i = index; i >= 1; i--){\n\t\tif(n>=odd[i]){\n\t\t\tint tmp = n;\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j >= 1; j--){\n\t\t\t\twhile(tmp>=odd[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp -= odd[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin = min>count?count:min; \n\t\t}\n\t}\n\treturn min;\n}\n\nint main(){\n\tmemset(mintable, 0, sizeof(mintable));\n\tinit();\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(mintable[i]&&mintableOdd[i]) continue;\t\t\n\t\t\tmintable[i] = countFourth(i);\n\t\t\tmintable[i] = dfs(i);\n\t\t\tmintableOdd[i] = countFourthOdd(i);\n\t\t\tmintableOdd[i] = dfsOdd(i);\n\t\t}\n\t\tcout << mintable[n] << \" \" << mintableOdd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dpt1[1000001];\nint dpt2[1000001];\nbool dpb1[1000001];\nbool dpb2[1000001];\nint tr[1000];\nint sq[1000];\n\nint dp1(int s) {\n  if(dpb1[s])\n    return dpt1[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    r = dp1(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt1[s] = m + 1;\n  dpb1[s] = true;\n  return m + 1;\n}\n\nint dp2(int s) {\n  if(dpb2[s])\n    return dpt2[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    if(sq[i]%2 == 0)\n      continue;\n    r = dp2(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt2[s] = m + 1;\n  dpb2[s] = true;\n  return m + 1;\n}\n\nint main() {\n\n  for(int i=1; i < 1000; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  dpt1[0] = 0;\n  dpb1[0] = true;\n  dpt2[0] = 0;\n  dpb2[0] = true;\n  int n;\n  while(cin >> n, n) {\n    cout << dp1(n) << \" \" << dp2(n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main() {\n    int table[1000000];\n    int max;\n    for (int i = 1; i < 1000000; i++) {\n        table[i] = i * (i + 1) * (i + 2) / 6;\n        if (table[i] >= 1000000) {\n            max = i - 1;\n            break;\n        }\n    }\n\n    int m;\n    while (cin >> m, m) {\n        bool used[1000000];\n        fill_n((bool *)used, 1000000, false);\n        priority_queue<pii, vector<pii>, greater<pii>> q;\n        q.push({0, 0});\n        while (!q.empty()) {\n            pii p = q.top(); q.pop();\n            int count = p.first;\n            int total = p.second;\n            if (used[total])\n                continue;\n            used[total] = true;\n\n            // goal\n            if (total == m) {\n                cout << count << \" \";\n                break;\n            }\n\n            for (int i = 1; i < max; i++) {\n                if (table[i] + total <= m)\n                    q.push({count+1, table[i] + total});\n            }\n        }\n        while(!q.empty())\n            q.pop();\n        fill_n((bool *)used, 1000000, false);\n        q.push({0, 0});\n        while (!q.empty()) {\n            pii p = q.top(); q.pop();\n            int count = p.first;\n            int total = p.second;\n            if (used[total])\n                continue;\n            used[total] = true;\n\n            // goal\n            if (total == m) {\n                cout << count << endl;\n                break;\n            }\n\n            for (int i = 1; i < max; i++) {\n                if (table[i] % 2 && table[i] + total <= m)\n                    q.push({count+1, table[i] + total});\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint func(int m, int p, vector<int> &q, int mi){\n//\tcout << m << \" \" << p << \"\\n\";\n\tif(p == -1) return 0;\n\tint d = m / q[p];\n\tif(mi < d) return d;\n\tint np = upper_bound(q.begin(), q.end(), m-d*q[p])-1-q.begin();\n\treturn d + func(m - d * q[p], np, q, mi);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<int> a, b;\n\tfor(int i=1; i*(i+1)*(i+2)/6<1e6; ++i){\n\t\tint t = i*(i+1)*(i+2)/6;\n\t\ta.push_back(t);\n\t\tif(t % 2 == 1) b.push_back(t);\n\t}\n//\tfor(int i=0; i<a.size(); ++i)\n//\t\tcout << a[i] << \"\\n\";\n//\tcout << a.size() << \"\\n\";\n//\tcout << b.size() << \"\\n\";\n//\tfor(int i=0; i<b.size(); ++i)\n//\t\tcout << b[i] << \"\\n\";\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) return 0;\n\t\tint x = n, y = n;\n\t\tfor(int i=a.size()-1; i>=0; --i){\n\t\t\tif(a[i] > n) continue;\n\t\t\tx = min(x, func(n, i, a, x));\n\t\t}\n\t\tfor(int i=b.size()-1; i>=0; --i){\n\t\t\tif(b[i] > n) continue;\n\t\t\ty = min(y, func(n, i, b, y));\n\t\t}\n\t\tcout << x << \" \" << y << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n\n  const int N=100000;\n  int dp[N], oddDp[N];\n  const int M=200;\n  int p[M];\n\n  p[0]=INF;\n  for(int i=1; i<M; i++){\n    int num = i*(i+1)*(i+2)/6;\n    p[i]=num;\n  }\n\n  fill( dp, dp+N, INF );\n  fill( oddDp, oddDp+N, INF );\n  dp[0] = 0;\n  oddDp[0] = 0;\n\n  REP(i,N){\n\n    REP(j,M){\n      if( i-p[j] >= 0 ){\n\tif( p[j] %2 == 1 )\n\t  oddDp[i] = min( oddDp[i], oddDp[i-p[j]]+1 );\n\tdp[i] = min( dp[i], dp[i-p[j]]+1 );\n      }\n    }\n\n  }\n\n  int n;\n  while(cin>>n,n){\n    cout << dp[n] << \" \" << oddDp[n] << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int SIZE = 181 + 1;\nconst int MAX = 1000000;\n\nint T[SIZE];\nint cost1[MAX], cost2[MAX];\n\nint main( void )\n{\t\n\tfor(int i=0; i < SIZE; ++i) T[i] = i * (i + 1) * (i + 2) / 6;\n\n\tfill(cost1, cost1+MAX, MAX);\n\tfill(cost2, cost1+MAX, MAX);\n\tcost1[0] = cost2[0] = 0;\n\tfor(int i=0; i < MAX; ++i) {\n\t\t//if(cost1[i] < 6) {\n\t\t\tfor(int j=0; j < SIZE; ++j) {\n\t\t\t\tif(i + T[j] < MAX && cost1[i] < 5)\n\t\t\t\t\tcost1[i + T[j]] = min(cost1[i + T[j]], cost1[i] + 1);\n\t\t\t\tif(T[j] & 1) {\n\t\t\t\t\tif(i + T[j] < MAX)\n\t\t\t\t\t\tcost2[i + T[j]] = min(cost2[i + T[j]], cost2[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n) {\n\t\tcout << cost1[n] << ' ' << cost2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX + 1], dp2[MAX + 1];\n\nint main()\n{\n    for (int i = 1; i <= MAX; i++)\n    {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for (int n = 1; n * (n + 1) * (n + 2) / 6 <= MAX; n++)\n    {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp1[i] = min(dp1[i], dp1[i - a] + 1);\n        }\n        if (a % 2 == 0)\n            continue;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp2[i] = min(dp2[i], dp2[i - a] + 1);\n        }\n    }\n\n    while (1)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n            break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n#define int long long\n\nvoid solve() {\n    set<int> se;\n    for(int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000100; ++i) {\n        se.insert(i * (i + 1) * (i + 2) / 6);\n    }\n    int dp[1000100], dp1[1000100];\n    rep(i, 1000100) dp[i] = dp1[i] = INF;\n    dp[0] = dp1[0] = 0;\n    for(auto& x: se) {\n        rep(i, 1000100) {\n            if(i + x < 1000100) chmin(dp[i + x], dp[i] + 1);\n            if(i + x < 1000100 && x % 2 == 1) chmin(dp1[i + x], dp1[i] + 1);\n        }\n    }\n\tint n;\n    while(cin >> n) {\n        if(n == 0) break;\n        cout << dp[n] << \" \" << dp1[n] << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\n\nvector<ll> table, table2;\n\nll dp[2][2][1001000];\n\nint main() {\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= 1000000; i++) {\n\t\ttable.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif ((i*(i + 1)*(i + 2) / 6) % 2 == 1)table2.push_back(i*(i + 1)*(i + 2) / 6);\n\t}\n\tcout << table.size() << endl;\n\tREP(i, 2) {\n\t\tREP(j, 2) {\n\t\t\tREP(k, 1001000)dp[i][j][k] = INF;\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tdp[1][0][0] = 0;\n\n\tREP(i, table.size()) {\n\t\tint num = table[i];\n\t\tREP(j, 1000000) {\n\t\t\tif (j - num >= 0) {\n\t\t\t\tdp[0][(i + 1) % 2][j] = min(dp[0][(i + 1) % 2][j - num] + 1, dp[0][i % 2][j]);\n\t\t\t}\n\t\t\telse dp[0][(i + 1) % 2][j] = dp[0][i % 2][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < table2.size(); i++) {\n\t\tint num = table2[i];\n\t\t//cout << num << endl;\n\t\tREP(j, 1000000) {\n\t\t\tif (j - num >= 0) {\n\t\t\t\tdp[1][(i + 1) % 2][j] = min(dp[1][(i + 1) % 2][j - num] + 1, dp[1][i % 2][j]);\n\t\t\t}\n\t\t\telse dp[1][(i + 1) % 2][j] = dp[1][i % 2][j];\n\t\t}\n\t}\n\t\n\twhile (cin >> n&&n) {\n\t\tcout << dp[0][table.size() % 2][n] << \" \"\n\t\t\t<< dp[1][table2.size() % 2][n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dpt1[1000001];\nint dpt2[1000001];\nbool dpb1[1000001];\nbool dpb2[1000001];\nint tr[1000];\nint sq[1000];\n\nint dp1(int s) {\n  if(dpb1[s])\n    return dpt1[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    r = dp1(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt1[s] = m + 1;\n  dpb1[s] = true;\n  return m + 1;\n}\n\nint dp2(int s) {\n  if(dpb2[s])\n    return dpt2[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; i < 1000; i++) {\n    if(s-sq[i] < 0) break;\n    if(sq[i]%2 == 0)\n      continue;\n    r = dp2(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt2[s] = m + 1;\n  dpb2[s] = true;\n  return m + 1;\n}\n\nint main() {\n\n  for(int i=1; i < 1000; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  dpt1[0] = 0;\n  dpb1[0] = true;\n  dpt2[0] = 0;\n  dpb2[0] = true;\n  int n;\n  while(cin >> n, n) {\n    cout << dp1(n) << \" \" << dp2(n) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 1000001\nusing namespace std;\nconst int infty = 1<<25;\nint main()\n{\n  int allnum = 0;\n  int oddnum = 0;\n  static int KAll[MAX];\n  static int KOdd[MAX];\n  static int Answer1[MAX];\n  static int Answer2[MAX];\n  Answer1[0]=0;\n  Answer2[0]=0;\n\n  int n = 1;\n  while( true ){\n    int t = n*(n+1)*(n+2) / 6;\n    if( t >= MAX ) break;\n    KAll[allnum++]=t;\n    if( t % 2 == 1 ){\n      KOdd[oddnum++]=t;\n    }\n    ++n;\n  }\n  \n  for(int i = 1; i < MAX; ++i){\n    Answer2[i] = Answer1[i] = infty;\n    for(int j = 0; j < allnum && i - KAll[j] >= 0; ++j){\n      Answer1[i] = min(Answer1[i], 1+Answer1[i-KAll[j]]);\n    }\n    for(int j = 0; j < oddnum && i - KOdd[j] >= 0; ++j){\n      Answer2[i] = min(Answer2[i], 1+Answer2[i-KOdd[j]]);\n    }\n  }\n  \n  while(true){\n    int N;\n    scanf(\"%d\", &N);\n    if( N == 0 ) break;\n    printf(\"%d %d\\n\", Answer1[N], Answer2[N]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\nint dpodd[190][1000010] = { 0 };\n//vector<vector<int>> dp;\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nvector<int>nums;\nvector<int>oddnums;\n\nvector<vector<short>>memo(100001, vector<short>(190,-1));\nvector<vector<short>>oddmemo(100001, vector<short>(50,-1));\n\nint getans(const int num, const int used,const int atime) {\n\tif (memo[num][used] != -1) {\n\t\treturn memo[num][used];\n\t}\n\telse {\n\t\tif (num == 0)return memo[num][used] = 0;\n\t\tif (atime > 10)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <= used; ++i) {\n\t\t\tint minusnum = nums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 10) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getans(num - minusnum, i, atime + 1)+1);\n\t\t}\n\n\t\treturn memo[num][used] = ans;\n\t}\n}\nint getoddans(const int num, const int used, const int atime) {\n\tif (oddmemo[num][used] != -1) {\n\t\treturn  oddmemo[num][used];\n\t}\n\telse {\n\t\tif (num == 0)return oddmemo[num][used] = 0;\n\t\tif (atime > 100)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <= min(int(oddnums.size()),used); ++i) {\n\t\t\tint minusnum = oddnums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 100) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getoddans(num - minusnum, i, atime + 1) + 1);\n\t\t}\n\n\t\treturn  oddmemo[num][used] = ans;\n\t}\n}\nint main() {\n\tfor (int i = 1; i < 181; ++i) {\n\t\tnums.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (((i*(i + 1)*(i + 2)) / 6) % 2) {\n\n\t\t\n\t\t\toddnums.push_back((i*(i + 1)*(i + 2)) / 6);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tint normalans = getans(n, 189, 0);;\n\t\tint oddans = getoddans(n, 47, 0);\n\n\t\tcout << normalans << \" \" << oddans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nusing namespace std;\n\nconst int MAX_N = 1000000;\nconst int INF = 1 << 29;\n\nvoid solve(int n)\n{\n\tint dp[MAX_N], dp_odd[MAX_N];\n\tfill_n(dp, n + 1, INF);\n\tfill_n(dp_odd, n + 1, INF);\n\t\n\tdp[0] = 0;\n\tdp_odd[0] = 0;\n\tREP(i, 100) {\n\t\tint m = (i + 1) * (i + 2) * (i + 3) / 6;\n\t\tif(m > n) break;\n\t\tFOR(j, m, n + 1) {\n\t\t\tif(m % 2) dp_odd[j] = min(dp_odd[j], dp_odd[j - m] + 1);\n\t\t\tdp[j] = min(dp[j], dp[j - m] + 1);\n\t\t}\n\t}\n\t\n\tprintf(\"%d %d\\n\", dp[n], dp_odd[n]);\n}\n\nint main()\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n), n) solve(n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define MAX 1000000\nusing namespace std;\n\nint tetra[200];\nint dp[MAX];\nint dp2[MAX];\n\nint main(void){\n\tint n;\n\tmemset(dp,MAX,sizeof(dp));\n\tmemset(dp2,MAX,sizeof(dp2));\n\tdp[0]=dp2[0]=0;\n\tfor(int i=1;i<200;i++)\n\t\ttetra[i]=i*(i+1)*(i+2)/6;\n\tfor(int i=1;i<200;i++){\n\t\tfor(int j=0;j<MAX;j++){\n\t\t\tif(j+tetra[i]>=MAX)\n\t\t\t\tcontinue;\n\t\t\tdp[j+tetra[i]]=min(dp[j+tetra[i]],dp[j]+1);\n\t\t\tif(tetra[i]%2)\n\t\t\t\tdp2[j+tetra[i]]=min(dp2[j+tetra[i]],dp2[j]+1);\n\t\t}\n\t}\n\twhile(cin >>n,n)\n\t\tcout << dp[n] <<\" \" << dp2[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[100]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include<algorithm>\n\nusing namespace std;\n\nint n, a[200], dp[200][1000001] , dp2[200][1000001], m;\n\nvoid set() {\n\n\tfor (int i = 0; i < 1000000; i++) {\n\t\ta[i] = 1;\n\n\t\tfor (int j = 1; j <= 3; j++) {\n\t\t\ta[i] *= (i + j);\n\t\t}\n\n\t\ta[i] /= 6;\n\n\t\tif (a[i] > 1000000) {\n\t\t\tm = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\n\tset();\n\n\twhile (true) {\n\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tint b;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c = 1;\n\n\t\t\tfor (int j = 1; j <= 3; j++) {\n\t\t\t\tc *= (i + j);\n\t\t\t}\n\t\t\tc /= 6;\n\n\t\t\t//cout << \"c:\" << c << endl;\n\n\t\t\tif (c <= n) {\n\t\t\t\tb = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= b+1; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tdp[i][j] = INT32_MAX;\n\t\t\t\tdp2[i][j] = INT32_MAX;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][0] = 0;\n\t\tdp2[0][0] = 0;\n\t\tfor (int i = 0; i <= b; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\t\tif (j + k*a[i] <= n) {\n\t\t\t\t\t\tif(dp[i][j] != INT32_MAX)dp[i+1][j + k*a[i]] = min(dp[i+1][j + k*a[i]], dp[i][j] + k);\n\n\t\t\t\t\t\tif (dp2[i][j] != INT32_MAX) {\n\t\t\t\t\t\t\tif (a[i] % 2 == 1 || k == 0) {\n\t\t\t\t\t\t\t\tdp2[i + 1][j + k*a[i]] = min(dp2[i + 1][j + k*a[i]], dp2[i][j] + k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*for (int i = 0; i <= b; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tcout << dp2[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\tint ans = dp[b + 1][n];\n\t\tint ans2 = dp2[b + 1][n];\n\n\t\tcout << ans << \" \" << ans2 << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\n return 0;\n    int res=0xFFFF;\n    if(maxcnt<cnt) return 0xFFFF;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n    }\n    return res;\n}\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        for(int i=1; ; i*=2) {\n            if((oddres=oddrec(n, 0, 0, i))!=0xFFFF)\n                break;\n        }\n\n        printf(\"%d %d\\n\",res,oddres);\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n\n  for(i=1;i<191;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=c[j-b[i]]+1;\n\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint x[4999999][2], a[999], b[999], s, n;\nint main() {\n\ta[0] = 1; b[0] = 1;\n\tfor (int i = 1; i < 300; i++) {\n\t\ta[i] = a[i - 1] + (i + 1)*(i + 2) / 2;\n\t\tif (a[i] % 2 == 1) {\n\t\t\ts++; b[s] = a[i];\n\t\t}\n\t}\n\tmemset(x, 127, sizeof(x));\n\tx[0][0] = 0; x[0][1] = 0;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + a[i]][0] = min(x[j + a[i]][0], x[j][0] + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < 50; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + b[i]][1] = min(x[j + b[i]][1], x[j][1] + 1);\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> n; if (!n) { break; }\n\t\tcout << x[n][0] << x[n][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 1100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nll dp1[MAX];\nll dp2[MAX];\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\tvector<ll> all, odd;\n\tfor (ll i = 1; i * (i + 1) * (i + 2) / 6 <= MAX; i++) {\n\t\tll nx = i * (i + 1) * (i + 2) / 6;\n\t\tall.push_back(nx);\n\t\tif (nx & 1) odd.push_back(nx);\n\t}\n\tfor (ll i = 0; i < MAX; i++) dp1[i] = INF, dp2[i] = INF;\n\tdp1[0] = 0;\n\tdp2[0] = 0;\n\tfor (ll i = 0; i < MAX; i++) {\n\t\tfor (ll e : all) {\n\t\t\tif (i + e < MAX) chmin(dp1[i + e], dp1[i] + 1);\n\t\t}\n\t}\n\tfor (ll i = 0; i < MAX; i++) {\n\t\tfor (ll e : odd) {\n\t\t\tif (i + e < MAX) chmin(dp2[i + e], dp2[i] + 1);\n\t\t}\n\t}\n\twhile (1) {\n\t\tll n; scanf(\"%lld\", &n);\n\t\tif (n == 0) break;\n\t\tprintf(\"%lld %lld\\n\", dp1[n], dp2[n]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[1000], fourodd[1000];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM * 2)\n\t\t\tbreak;\n\n\t}\n\tcout << \"ok\" << endl;\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t\tif (i > fourodd[j])\n\t\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\t}\n\n\tcout << \"a\";\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <vector>\nusing namespace std;\n\nint n;\nvector<int> tetora;\nvector<int> dp(1000001, 10000);\nvector<int> dp2(1000001, 100000);\n\nvoid msk()\n{\n    dp[0] = dp2[0] = 0;\n\n    for (int i = 1;; i++)\n    {\n        int tmp = i * (i + 1) * (i + 2) / 6;\n        if (tmp > 1000000)\n            break;\n\n        for (int j = tmp; j < 1000001; j++)\n        {\n            dp[j] = min(dp[j], dp[j - tmp] + 1);\n            if (tmp % 2 != 0)\n            {\n                dp2[j] = min(dp2[j], dp2[j - tmp] + 1);\n            }\n        }\n    }\n}\n\nint main()\n{\n    msk();\n    while (1)\n    {\n        scanf(\"%d\", &n);\n        if (n == 0)\n            return 0;\n        printf(\"%d %d\\n\", dp[n], dp2[n]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint list[1000];\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n\t\tlist[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;list[j]<=i-1;j+=2)if(!dp2[i] || dp2[list[j]]+dp2[i-list[j]] < dp2[i]) dp2[i]=dp2[list[j]]+dp2[i-list[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;list[j]<=i-1;j++) if(!dp1[i] || dp1[list[j]]+dp1[i-list[j]] < dp1[i]) dp1[i]=dp1[list[j]]+dp1[i-list[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MAX=1e6+10;\nusing namespace std;\nint main(){\n    vector<int>precal;\n    vector<int>dp(MAX,MAX);\n    vector<bool>flag(MAX,false);\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=(int)(upper_bound(precal.begin(),precal.end(),i)-precal.begin());\n        for(int j=0; j<=index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX,MAX);\n    vector<bool>oddflag(MAX,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=(int)(upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin());\n        for(int j=0;j<=index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n\n  while(cin>>n,n){\n    cout<<c[n]<<' ';\n    for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\ncout<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n#define MAXSIZE 10000000;\n#define INF 100000000;\n\nbool comp(const pair<string,int> a, const pair<string,int> b) {\n  if (a.first != b.first)\n    return a.first < b.first; // 高い順に並べたいので演算子を逆に\n  else{\n      return a.second > b.second;\n  }\n}\n\nint Dx[6] = { 0, 0, 1, 1,-1,-1};\nint Dy[6] = { 1,-1, 1, 0, 0,-1};\n\n//priority_queue<long long int,vector<long long int>, greater<long long int>> PQ;\n//priority_queue<long long int> PQ1;\nint main(){\n    int b[201] = {0};\n    int dp[1000001] = {0};\n    int dpOdd[1000001] = {0};\n\n    for(int i = 0;i<201;i++){\n        b[i] = i*(i+1)*(i+2)/6;\n    }\n\n    for(int i = 0;i<1000001;i++){\n        dp[i] = dpOdd[i] = 99999999;\n    }\n    dp[0] = 0;dpOdd[0] = 0;\n    for(int i = 0;i<1000001;i++){\n        for(int j = 0;j < 201;j++){\n            if(i+b[j] <= 1000000)dp[i+b[j]] = min(dp[i+b[j]] , dp[i]+1);\n            if((b[j]%2 == 1 )&& (i+b[j] <= 1000000))dpOdd[i+b[j]] = min(dpOdd[i+b[j]] , dpOdd[i]+1);\n        }\n    }\n\n    int N;\n\n    while (cin >>N,N){\n        cout <<dp[N]<<\" \"<<dpOdd[N]<<endl;\n    }\n\n\n\n    return 0;\n}\n\n/*Syakutori\nwhile(cin >>b && b)){\n      ll t = 1;\n      long long int ansS = 1,ansT=0;\n      long long int sum = 0;\n\n      for(ll s = 1;s < 50000000;s++){\n\n        while(t <  50000000 && sum+Rsum[t] < b){\n          sum += Rsum[t];\n          t++;\n        }\n        if(b == sum+Rsum[t]){\n          if(ansT - ansS < t-s){\n            ansS = s;\n            ansT = t;\n          }\n          cout <<ansS<<\" \"<<ansT-ansS + 1<<endl;\n          break;\n        }\n        if(t == s)++t;\n        else sum -= Rsum[s];\n        }\n    }\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst int MAX_N=1e6;\nconst int MAX_M=180;\n\nint dp[MAX_N];\nint dp2[MAX_N];\n\nint main(){\n\tREP(i,MAX_N){\n\t\tdp[i]=dp2[i]=i;\n\t}\n\tFOR(i,2,MAX_M+1){\n\t\tint p=i*(i+1)*(i+2)/6;\n\t\tFOR(j,p,MAX_N){\n\t\t\tdp[j]=min(dp[j],dp[j-p]+1);\n\t\t\tif (p&1){\n\t\t\t\tdp2[j]=min(dp2[j],dp2[j-p]+1);\n\t\t\t}\n\t\t}\n\t}\n\tint N;\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tprintf(\"%d %d\\n\",dp[N],dp2[N]);\n\t\t}\n\t}while(N);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 10007;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\n\nint dp[1001000],dp2[1001000];\nvector<int> pollock, pollock2;\nint main() {\n\tfor (int i = 1;; i++) {\n\t\tLL num = i*(i + 1)*(i + 2)/6;\n\n\t\tif (num > 1000000)break;\n\n\t\tif (num % 2 == 0)pollock2.emplace_back(num);\n\t\tpollock.emplace_back(num);\n\t}\n\t//cout << 1 << endl;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tdp[i] = dp2[i] = i;\n\t}\n\t//cout << 2 << endl;\n\tfor (int i = 1; i < pollock.size(); i++) {\n\t\tfor (int j = pollock[i]; j <= 1000000; j++) {\n\t\t\tdp[j] = min(dp[j], dp[j - pollock[i]] + 1);\n\t\t}\n\t}\n\t//cout << 3 << endl;\n\tfor (int i = 1; i < pollock2.size(); i++) {\n\t\tfor (int j = pollock2[i]; j <= 1000000; j++) {\n\t\t\tdp2[j] = min(dp2[j], dp2[j - pollock2[i]] + 1);\n\t\t}\n\t}\n\t//cout << 4 << endl;\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n;\nvector<int> vec, vec2;\nint dp[1000005], dp2[1000005];\n\nint main(void)\n{\n  for(long long i = 1; i*(i+1)*(i+2)/6 <= 1000000; i++){\n    long long x = i*(i+1)*(i+2)/6;\n    if(x % 2) vec2.push_back(x);\n    vec.push_back(x);\n  }\n  //for(int i = 0 ;i < vec.size(); i++) cout << vec[i] << \" \"; cout << endl;\n\n  for(int i = 0; i <= 1000000; i++) dp[i] = dp2[i] = 1e9;\n  dp[0] = dp2[0] = 0;\n  for(int i = 0; i < 1000000; i++){\n    for(int j = 0; j < vec.size(); j++){\n      if(i+vec[j] <= 1000000) dp[i+vec[j]] = min(dp[i+vec[j]], dp[i]+1);\n    }\n    for(int j = 0; j < vec2.size(); j++){\n      if(i+vec2[j] <= 1000000) dp2[i+vec2[j]] = min(dp2[i+vec2[j]], dp2[i]+1);\n    }\n  }\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bits/stdc++.h>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(X, S, E) for (int(X) = (S); (X) < (E); ++(X))\n#define rrep(X, S, E) for (int(X) = (E)-1; (X) >= (S); --(X))\n#define arep(X, Y) for (auto(X) : Y)\n#define all(X) (X).begin(), (X).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sc second\n#define print(x) cout << x << endl\n#define printDouble(x) cout << fixed << setprecision(13) << x << endl\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing decendingQueue = priority_queue<ll, vl>;              //降順\nusing ascendingQueue = priority_queue<ll, vl, greater<ll>>; //昇順\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst int INT_INF = 1e9;\nconst ll LL_INF = 1e18;\nconst int mod = 1000000007;\n\ntemplate <class T> void mySort(vector<T> &X, bool isAscending) {\n  // 昇順\n  if (isAscending) {\n    sort(all(X));\n  } else {\n    // 降順\n    sort(all(X), greater<T>());\n  }\n}\n\nlong long gcd(long long m, long long n) {\n  if (m < n)\n    return gcd(n, m);\n  if (n == 0)\n    return m;\n  return gcd(n, m % n);\n}\n\nlong long lcm(long long m, long long n) {\n  // m * nでlong型のオーバフローを発生させないため、先に割り算から行う\n  return m * (n / gcd(m, n));\n}\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint &operator+=(const mint a) {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a) {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res -= a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod - 2); }\n  mint &operator/=(const mint a) { return (*this) *= a.inv(); }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res /= a;\n  }\n};\n\n// combination mod prime\n// https://www.youtube.com/watch?v=8uowVvQ_-Mo&feature=youtu.be&t=1619\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n) : fact(n + 1), ifact(n + 1) {\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i)\n      fact[i] = fact[i - 1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i)\n      ifact[i - 1] = ifact[i] * i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n)\n      return 0;\n    return fact[n] * ifact[k] * ifact[n - k];\n  }\n};\n\nvector<long long> SieveOfEratosthenes(int max) {\n  vector<long long> sieve;\n  vector<long long> primes;\n\n  for (int i = 1; i < max + 1; ++i) {\n    sieve.push_back(i);\n  }\n\n  sieve[0] = 0;\n  for (int i = 2; i < max + 1; ++i) {\n    if (sieve[i - 1] != 0) {\n      primes.push_back(sieve[i - 1]);\n      for (int j = 2 * sieve[i - 1]; j < max + 1; j += sieve[i - 1]) {\n        sieve[j - 1] = 0;\n      }\n    }\n  }\n  return primes;\n}\n\nclass UnionFindTree {\nprivate:\n  vector<int> par;\n  vector<int> rnk;\n  vector<int> siz;\n\npublic:\n  UnionFindTree(int n) {\n    par.assign(n, -1);\n    rnk.assign(n, -1);\n    siz.assign(n, -1);\n\n    for (int i = 0; i < n; ++i) {\n      par[i] = i;\n      rnk[i] = 0;\n      siz[i] = 1;\n    }\n  }\n\n  int find(int x) {\n    if (par[x] == x)\n      return x;\n    else\n      return par[x] = find(par[x]);\n  }\n\n  bool same(int x, int y) { return find(x) == find(y); }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y)\n      return;\n    if (rnk[x] < rnk[y]) {\n      par[x] = y;\n      siz[y] += siz[x];\n    } else {\n      par[y] = x;\n      siz[x] += siz[y];\n      if (rnk[x] == rnk[y])\n        ++rnk[x];\n    }\n  }\n\n  int size(int x) {\n    x = find(x);\n    return siz[x];\n  }\n};\n\nclass Edge {\npublic:\n  ll from;\n  ll to;\n  ll cost;\n\n  Edge() {}\n  Edge(ll from, ll to, ll cost) {\n    this->from = from;\n    this->to = to;\n    this->cost = cost;\n  }\n\n  bool operator<(const Edge &edge) const {\n    return cost < edge.cost; //昇順\n  }\n};\n\nclass Graph {\npublic:\n  ll nodes; // ノード数\n  vector<Edge> edges;\n\n  Graph() {}\n  Graph(ll nodes) { this->nodes = nodes; }\n  void addEdge(ll from, ll to, ll cost) {\n    this->edges.push_back(Edge(from, to, cost));\n  }\n};\n\n// クラスカル法\n// 連結グラフの最小全域木を求める\nclass Kruskal {\nprivate:\n  Graph graph;\n  vector<Edge> MinimumSpanningTree;\n  ll minimumCost;\n  void searchMinimumSpanningTree() {\n    UnionFindTree uf(graph.nodes);\n    sort(all(graph.edges));\n    for (auto edge : graph.edges) {\n      if (!uf.same(edge.from, edge.to)) {\n        uf.unite(edge.from, edge.to);\n        MinimumSpanningTree.push_back(edge);\n      }\n    }\n  }\n\npublic:\n  Kruskal(Graph graph) { this->graph = graph; }\n  ll getMinimumSpanningTreeCost() {\n    searchMinimumSpanningTree();\n    ll cost = 0;\n    for (auto tr : MinimumSpanningTree) {\n      cost += tr.cost;\n    }\n    return cost;\n  }\n};\n\n// ダイクストラ法 O((E+V)logV)\n// 最小経路問題を解くためのアルゴリズム。辺の重みに負数を含む場合は利用不可\n// 無向グラフの場合はコメントアウト箇所をコメントイン\nclass Dijkstra {\nprivate:\n  Graph graph;\n  map<ll, vector<Edge>> fromPaths;\n  vl distances;\n  vl srcs;\n\npublic:\n  Dijkstra(Graph graph) {\n    this->graph = graph;\n    for (auto edge : graph.edges) {\n      fromPaths[edge.from].push_back(edge);\n      // fromPaths[edge->to].push_back(Edge(edge->to, edge->from, edge->cost));\n    }\n  }\n  void searchMinimumPathFrom(ll src) {\n    // 複数回呼ばれる度に計算する\n    distances = vl(graph.nodes + 1, LL_INF);\n    srcs = vl(graph.nodes + 1, LL_INF);\n\n    // 距離が近い順番に捜査していく\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n    distances[src] = 0;\n    srcs[src] = -1;\n\n    pq.push(mp(0ll, src));\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      double uw = pq.top().first;\n      pq.pop();\n\n      if (distances[u] < uw) {\n        continue;\n      };\n\n      for (auto edge : fromPaths[u]) {\n        int v = edge.to;\n        ll w = edge.cost;\n        if (distances[v] > distances[u] + w) {\n          distances[v] = distances[u] + w;\n          srcs[v] = u;\n          pq.push(mp(distances[v], v));\n        }\n      }\n    }\n  };\n  ll getDistance(ll n) { return distances[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// ベルマンフォード O(|V||E|)\n// 負コストが含まれていても最短経路問題を解くためのアルゴリズム。閉路の検出も可能\n// 有向グラフ\nclass BellmanFord {\nprivate:\n  Graph graph;\n  // 閉路が含まれるかは個々のノードごとに管理する必要あり\n  vector<bool> hasNegativeCycles;\n  vector<ll> distances;\n  vl srcs;\n\npublic:\n  BellmanFord(Graph graph) {\n    ll nodes = graph.nodes + 1;\n\n    this->graph = graph;\n    distances = vector<ll>(nodes, LL_INF);\n    hasNegativeCycles = vector<bool>(nodes, false);\n  }\n  void searchMinimumPathFrom(ll src) {\n    distances[src] = 0;\n\n    for (ll i = 0; i < graph.nodes - 1; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] != LL_INF) {\n          chmin(distances[v], distances[u] + w);\n        }\n      }\n    }\n\n    for (auto edge : graph.edges) {\n      ll u = edge.from;\n      ll v = edge.to;\n      ll w = edge.cost;\n      if (distances[u] == LL_INF) {\n        continue;\n      }\n      if (distances[u] + w < distances[v]) {\n        hasNegativeCycles[v] = true;\n      }\n    }\n\n    for (ll i = 0; i < graph.nodes; i++) {\n      for (auto edge : graph.edges) {\n        ll u = edge.from;\n        ll v = edge.to;\n        ll w = edge.cost;\n        if (distances[u] == LL_INF) {\n          continue;\n        }\n        chmin(distances[v], distances[u] + w);\n        if (hasNegativeCycles[u] == true) {\n          hasNegativeCycles[v] = true;\n        }\n      }\n    }\n  }\n  ll getDistance(ll n) { return distances[n]; }\n  bool hasNegativeCycle(ll n) { return hasNegativeCycles[n]; }\n  ll getFrom(ll n) { return srcs[n]; }\n};\n\n// O(V^3) 有向グラフ\nclass WarshallFloyd {\nprivate:\n  Graph graph;\n  int nodes = this->graph.nodes + 1;\n  vector<vector<ll>> distances;\n\npublic:\n  WarshallFloyd(Graph graph) {\n    this->graph = graph;\n    nodes = this->graph.nodes + 1;\n    this->distances = vector<vector<ll>>(nodes, vector<ll>(nodes, LL_INF));\n    for (auto edge : graph.edges) {\n      int from = edge.from;\n      int to = edge.to;\n      int cost = edge.cost;\n      distances[from][to] = cost;\n    }\n  }\n  void searchMinimumPath() {\n    for (int k = 0; k < nodes; k++) {\n      for (int i = 0; i < nodes; i++) {\n        for (int j = 0; j < nodes; j++) {\n          if (distances[i][k] == LL_INF || distances[k][j] == LL_INF) {\n            continue;\n          }\n          if (distances[i][k] + distances[k][j] < distances[i][j]) {\n            distances[i][j] = distances[i][k] + distances[k][j];\n          }\n        }\n      }\n    }\n  }\n  ll getDistance(int from, int to) { return distances[from][to]; }\n};\n\ntemplate <typename T> class SegmentTree {\n  int n = 1; // 最下段のノード数. ただし、2の冪乗\n  vector<T> data;\n\n  T init;                      // 初期値\n  function<T(T, T)> mergeFunc; // 子ノードのmerge方法\n\npublic:\n  SegmentTree(int N, function<T(T, T)> _mergeFunc, T _init) {\n    mergeFunc = _mergeFunc;\n    init = _init;\n\n    while (n < N) {\n      n *= 2;\n    }\n\n    data = vector<T>(n * 2 - 1, _init); // 2の冪乗で確保が必要\n  }\n\n  // i番目の値(0-indexed)をxに変更\n  // O(logN)\n  void update(int i, T v) {\n    // 葉のノード\n    i += n - 1;\n    data[i] = v;\n\n    // 親も更新\n    while (i > 0) {\n      i = (i - 1) / 2; //親のindex\n      data[i] =\n          mergeFunc(data[i * 2 + 1], data[i * 2 + 2]); //親から見た子のindex\n    }\n  }\n\n  // i番目の値を返却\n  T get(int i) { return data[i + n - 1]; }\n\n  // [a, b)のmergeFuncを求めるクエリ\n  // ノードk（空間[l, r)が担当）が答える. ノード0の根から探索する\n  // 呼び出しはquery(a, b). その他の引数は再帰処理のため\n  // O(logN)\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    // 最初の呼び出し\n    if (r < 0) {\n      return query(a, b, k, l, n);\n    }\n\n    // 区間が被らない場合\n    if (r <= a || b <= l) {\n      return init;\n    }\n\n    // 完全に含む場合\n    if (a <= l && r <= b) {\n      return data[k];\n    }\n\n    // 部分的に含む場合. 子ノードに聞く\n    T left = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T right = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\n    return mergeFunc(left, right);\n  }\n};\n\nint main() {\n\n  vi regular_tetrahedron;\n  int i = 1;\n  while (true) {\n    int n = i * (i + 1) * (i + 2) / 6;\n    if (n > 1e6) {\n      break;\n    }\n    regular_tetrahedron.push_back(n);\n    i++;\n  }\n\n  vi dp0(1e6 + 5, INT_INF); // 正四面体数\n  vi dp1(1e6 + 5, INT_INF); // 奇数の正四面体数のみ\n\n  int rs = regular_tetrahedron.size();\n  rep(i, 0, rs) {\n    int rn = regular_tetrahedron[i];\n    chmin(dp0[rn], 1);\n    rep(j, 0, 1e6 + 1) {\n      int jj = j - rn;\n      if (jj >= 0) {\n        chmin(dp0[j], dp0[jj] + 1);\n        chmin(dp1[j], dp1[jj] + 1);\n      }\n    }\n  }\n\n  rep(i, 0, rs) {\n    int rn = regular_tetrahedron[i];\n    if (rn % 2 == 0) {\n      continue;\n    }\n\n    chmin(dp1[rn], 1);\n    rep(j, 0, 1e6 + 1) {\n      int jj = j - rn;\n      if (jj >= 0) {\n        chmin(dp1[j], dp1[jj] + 1);\n      }\n    }\n  }\n\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    cout << dp0[n] << \" \" << dp1[n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint x[8000000][2], a[999], b[999], s, n;\nint main() {\n\ta[0] = 1; b[0] = 1;\n\tfor (int i = 1; i < 300; i++) {\n\t\ta[i] = a[i - 1] + (i + 1)*(i + 2) / 2;\n\t\tif (a[i] % 2 == 1) {\n\t\t\ts++; b[s] = a[i];\n\t\t}\n\t}\n\tn = 1200000;\n\tmemset(x, 127, sizeof(x));\n\tx[0][0] = 0; x[0][1] = 0;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + a[i]][0] = min(x[j + a[i]][0], x[j][0] + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < 50; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + b[i]][1] = min(x[j + b[i]][1], x[j][1] + 1);\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> n; if (!n) { break; }\n\t\tcout << x[n][0] << ' ' << x[n][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define print(a) cout<<a<<endl;\nint aaa[200] = {}, bbb[200] = {}, counta=1,countb=1, ansa, ansb, xxx[1100000] = {}, yyy[1100000] = {};\n\nint foo(int n, int x){//cout<<n<<\" \"<<x<<\" \"<<xxx[x]<<endl;;\n\tint mi = 1000000;\n\tif(xxx[n]) return xxx[n]+x;\n\tif(x > 5) return mi;\n\tfor(int i = counta-1; i >= 1; i--){\n\t\tif(aaa[i] < n){\n\t\t\tmi = min(foo(n-aaa[i],x+1), mi);\n\t\t//\tif(mi - n == 1)break;\n\t\t} //else if(aaa[i] < n/2) break;\n\t}\n\t\n\txxx[n] = mi;\n\treturn mi;\n}\nint boo(int n, int x){//cout<<n<<\" \"<<x<<\" \"<<yyy[n]<<endl;cin>>ansb;\n\tint mi = 1000000;\n\tif(yyy[n]) return yyy[n]+x;\n\tfor(int i = countb-1; i >= 1; i--){\n\t//\tcout<<bbb[i]<<\" \"<<n<<endl;\n\t\tif(bbb[i] < n){\n\t\t\tmi = min(boo(n-bbb[i],x+1), mi);\n\t\t\t//if(mi - n == 1)break;\n\t\t}// else if(bbb[i] < n/2) break;\n\t}\n\t//cout<<\"aaaa \"<<n<<\" \"<<x<<\" \"<<mi<<endl;\n\tyyy[n] = mi;\n\treturn mi;\n}\n\nint main(){\n\tint i, n, abc;\n\tfor(i = 1; abc <= 1000000; i++){\n\t\tabc = (i*(i+1)*(i+2))/6;\n\t\txxx[abc] = 1;\n\t\tif(abc%2 == 1){\n\t\t\tyyy[abc] = 1;\n\t\t\tbbb[countb++] = abc;\n\t\t}\n\t\taaa[counta++] = abc;\n\t//\tcout<<counta<<\" \"<<i<<\" \"<<abc<<endl;;\n\t}\n\tprint(1);\n\tfor(i = 1; i <= 100000; i++){\n\t\txxx[i] = foo(i, 0);\n\t\tyyy[i] = boo(i, 0);\n\t}\n\tprint('a');\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tcout<<foo(n,0)<<\" \"<<boo(n,0)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define MAX 1000001\n\nlong long int flag[MAX] = {};\nlong long int flag2[MAX] = {};\n\nint main() {\n\n\tvector< long long int > l, l2;\n\n\tfor( long long int i = 1; ; i++ ) {\n\n\t\tlong long int a = i * ( i + 1 ) * ( i + 2 ) / 6;\n\n\t\tif ( a >= MAX ) break;\n\n\t\tl.push_back( a );\n\t\tif ( ( a % 2 ) != 0 ) l2.push_back( a );\n\n\t}\n\t\n\tfor ( long long int i = 1; i < MAX; i++ ) {\n\t\tflag[i] = MAX + 1;\n\t\tflag2[i] = MAX + 1;\n\t}\n\n\tfor ( long long int i = 0; i < l.size(); i++ ) {\n\t\tfor ( long long int j = 0; j + l[i] < MAX; j++ ) {\n\t\t\tflag[ j + l[i] ] = min( flag[ j + l[i] ], flag[ j ] + 1 );\n\t\t}\n\t}\n\tfor ( long long int i = 0; i < l2.size(); i++ ) {\n\t\tfor ( long long int j = 0; j + l2[i] < MAX; j++ ) {\n\t\t\tflag2[ j + l2[i] ] = min( flag2[ j + l2[i] ], flag2[ j ] + 1 );\n\t\t}\n\t}\n\n\twhile( true ) {\n\n\t\tlong long int in;\n\t\tcin >> in;\n\t\tif ( in == 0 ) break;\n\n\t\tcout << flag[in] << \" \" << flag2[in] << endl;\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\n\ntypedef long long ll;\n\nll f(ll n) {\n\treturn n * (n+1) * (n+2) / 6;\n}\n\nvector<int> makeS(int mod, int d) {\n\tint n = 1;\n\tvector<int> res;\n\twhile (1) {\n\t\tif ( f(n) > N ) break;\n\t\tif ( f(n) % mod == d ) {\n\t\t\tres.push_back( f(n) );\n\t\t}\n\t\t++n;\n\t}\n\treturn res;\n}\n\nconst int inf = 1e9;\nconst int maxN = 1000000;\nint dp[maxN+1];\nint solve(const vector<int>& s) {\n\tfill(dp, dp+maxN, inf); dp[0] = 0;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\tint nj = j + s[i];\n\t\t\tif (nj <= N) {\n\t\t\t\tdp[nj] = min(dp[nj], dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[N];\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tvector<int> s0 = makeS(1, 0);\n\t\tvector<int> s1 = makeS(2, 1);\n\t\tcout << solve(s0) << \" \" << solve(s1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1];\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      if(dp[0][nxt]>dp[0][j])dp[0][nxt] = dp[0][j] + 1;\n      if( (val&1) && (dp[1][nxt]>dp[1][j]))dp[1][nxt] = dp[1][j] + 1;\n    }\n    val *= (i+3), val /= i;\n  }\n\n  int n;\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define MAX 1000000\n\nint calc(int n) { return n*(n + 1)*(n + 2) / 6; }\nint p[200];\nint p1[200];\nint dp[MAX] = { 0 };\nint dp1[MAX] = { 0 };\n\nint func(int n, int P[], int DP[])\n{\n\tif (n <= 0)return MAX;\n\tif (DP[n] != 0)return DP[n];\n\telse\n\t{\n\t\tint min_t = MAX;\n\t\tint i = 0;\n\t\twhile (1)\n\t\t{\n\t\t\tif (P[i] <= n && n <= P[i + 1])break;\n\t\t\tif (P[i] == 1004731)\n\t\t\t{\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor (int t = i; t>0; t--)\n\t\t{\n\t\t\tif (min_t > func(n - P[t], P, DP) + 1)\n\t\t\t{\n\t\t\t\tmin_t = func(n - P[t], P, DP) + 1;\n\t\t\t}\n\t\t}\n\t\tDP[n] = min_t;\n\t\treturn DP[n];\n\t}\n}\n\nint main()\n{\n\tint index = 1;\n\tFOR(i, 1, 200)\n\t{\n\t\tint temp = calc(i);\n\t\tif (temp > 1004731)break;\n\t\tp[i] = temp;\n\t\tdp[p[i]] = 1;\n\t\tif (temp % 2 == 1)\n\t\t{\n\t\t\tp1[index] = temp;\n\t\t\tdp1[p1[index]] = 1;\n\t\t\tindex++;\n\t\t}\n\t}\n\twhile (1)\n\t{\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)return 0;\n\t\tcout << func(N, p, dp) << \" \" << func(N, p1, dp1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nusing P = pair<int,int>;\n#define rep(i,N) for(int (i)=0;(i) < (N); (i)++)\n\nint main(){\n    const int MAX = 1000000;\n    vector<int> tetra,tetra_odd;\n    vector<int> ans(MAX+1,MAX), ans_odd(MAX+1,MAX);\n    ans[0] = 0;\n    ans_odd[0] = 0;\n\n    int n=1;\n    while(n*(n+1)*(n+2) / 6 <= MAX){\n        int k = n*(n+1)*(n+2) / 6;\n        tetra.emplace_back(k);\n        if(k&1) tetra_odd.emplace_back(k);\n        n++;\n    }\n\n    for(int i=0;i<=MAX;i++){\n        for(int j=0;j<tetra.size();j++){\n            if(i-tetra[j] < 0) continue;\n            ans[i] = min(ans[i],ans[i-tetra[j]]+1);\n        }\n    }\n\n    for(int i=0;i<=MAX;i++){\n        for(int j=0;j<tetra_odd.size();j++){\n            if(i-tetra_odd[j] < 0) continue;\n            ans_odd[i] = min(ans_odd[i],ans_odd[i-tetra_odd[j]]+1);\n        }\n    }\n\n    int N;\n    while(cin >> N, N != 0){\n        cout << ans[N] << \" \" << ans_odd[N] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\nconst int mod = 1e9 + 7;\nint dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\nint dx[] = {1, -1, 0, 0, -1, 1, 1, -1};\n#define ceil(a, b) a / b + !!(a % b)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\nint table[3000001];\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int tetra[201];\n    tetra[0] = 0;\n    rrep(i, 1, 201) tetra[i] = i * (i + 1) * (i + 2) / 6;\n    int dp[1000001];\n    rep(i, 1000001) dp[i] = i;\n    int dp2[1000001];\n    rep(i, 1000001) dp2[i] = i;\n    rep(i, 201) {\n        rep(j, 1000001) {\n            if (j + tetra[i] < 1000001) {\n                chmin(dp[j + tetra[i]], dp[j] + 1);\n                if (tetra[i] % 2 != 0) chmin(dp2[j + tetra[i]], dp2[j] + 1);\n            }\n        }\n    }\n    int n;\n    while (cin >> n && n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dp[1000010];\nint dp2[1000010];\n\nsigned main() {\n\tint n;\n\trep(i, 0, 1000010) {\n\t\tdp[i] = 10;\n\t\tdp2[i] = 10000000;\n\t}\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\trep(i, 1, 200) {\n\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\tif (a > 1000000) break;\n\t\trep(j, 0, 1000001) {\n\t\t\tif (j + a > 1000000) break;\n\t\t\tdp[j + a] = min(dp[j + a], dp[j] + 1);\n\t\t\tif (a % 2 == 0) continue;\n\t\t\tdp2[j + a] = min(dp2[j + a], dp2[j] + 1);\n\t\t}\n\t}\n\twhile (cin >> n && n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[1000], fourodd[1000];\n\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four > MAXNUM * 2)\n\t\t\tbreak;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\n\t}\n\t//cout << \"ok\" << endl;\n\t//cout << allcounter << endl;\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\t//cout << i << \":\" << all[i] << endl;\n\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t//cout << \"aaa\" << endl;\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n//https://onlinejudge.u-aizu.ac.jp/problems/1167\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define bit(k) (1LL<<(k))\ntypedef long long ll;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = 1e9;\nconst ll INFLL = 1e18;\nconst ll MOD = 1e9+7;\nconst double PI = acos(-1.0);\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n/*------------------------------------/\nfor library*/\n\n/*------------------------------------*/\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    vector<ll> dp(1000005,INF);\n    vector<ll> dp2(1000005,INF);\n    dp[0] = dp2[0] = 0;\n    for(int i = 1; i <=1000000;i++){\n        for(int j = 1;;j++){\n            int num = (j * (j + 1) * (j + 2))/6;\n            if(i-num < 0)break;\n            chmin(dp[i],dp[i-num] + 1);\n            if(num % 2 == 1){\n                chmin(dp2[i],dp2[i-num] + 1);\n            }\n        }\n    }\n    while(1){\n        int N;\n        cin>>N;\n        if(N == 0)break;\n        cout<<dp[N]<<\" \"<<dp2[N]<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int N,S[1000],SS[1000],SSS[1000],P[100001],OP[100001],a=0;\n  S[0]=0;P[0]=0;OP[0]=0;\n  for(int i=1;i<100001;i++){\n    OP[i]=P[i]=10000001;\n  }\n  for(int i=1;i<190;i++){\n    S[i]=S[i-1]+i;\n  }\n  SS[0]=0;\n  for(int i=1;i<190;i++){\n    SS[i]=SS[i-1]+S[i];\n    if(SS[i]%2==1)SSS[a++]=SS[i];\n  }\n  for(int i=0;i<a;i++){\n    for(int j=SSS[i];j<100001;j++){\n      OP[j]=min(OP[j],OP[j-SSS[i]]+1);\n    }\n  }\n  for(int i=1;i<190;i++){\n    for(int j=SS[i];j<100001;j++){\n      P[j]=min(P[j],P[j-SS[i]]+1);\n    }\n  }\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    cout<<P[N]<<\" \"<<OP[N]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\nusing namespace std;\n\nvoid pol(vector<int> vt,set<int> s,int N){\n\tint count=1;\n\twhile(s.find(N)==s.end()){\n\t\tcount++;\n\t\tset<int> tmps;\n\t\tfor(auto itr=s.begin();itr!=s.end();itr++){\n\t\t\tfor(auto itr2=vt.begin();itr2!=vt.end();itr2++){\n\t\t\t\ttmps.insert(*itr + *itr2);\n\t\t\t}\n\t\t}\n\t\ts=tmps;\n\t}\n\n\tcout<<count<<\" \";\n\n\treturn;\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tint num=0,dnum=0;\n\t\tset<int> s,sodd;\n\t\tvector<int> vt,vtodd;\n\t\tfor(int i=1;num<=N;i++){\n\t\t\tdnum+=i;\n\t\t\tnum+=dnum;\n\t\t\tif(num>N) break;\n\t\t\tvt.push_back(num);\n\t\t\ts.insert(num);\n\t\t\tif(num%2) {\n\t\t\t\tsodd.insert(num);\n\t\t\t\tvtodd.push_back(num);\n\t\t\t}\n\t\t}\n\t\tpol(vt,s,N);\n\t\tpol(vtodd,sodd,N);\n\t\tp(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define itrep(it, a) for(it = (a).begin(); it != (a).end(); it++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 30)\nusing namespace std;\n\nint dp1[2000050];\nint dp2[2000050];\n\nvoid solve(){\n    vector<int> va;\n    vector<int> vb;\n    for(int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; i++){\n        int a = i * (i + 1) * (i + 2) / 6;\n        va.push_back(a);\n        if(a % 2 == 1) vb.push_back(a);\n    }\n    rep(i,1000005){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    dp1[0] = dp2[0] = 0;\n\n    for(int j = va.size() - 1; j >= 0; j--){\n        rep(i, 1000000){\n            if(dp1[i] != INF && dp1[i + va[j]] == INF){\n                dp1[i + va[j]] = dp1[i] + 1;\n            }\n        }\n    }\n    for(int j = vb.size() - 1; j >= 0; j--){\n        rep(i, 1000000){\n            if(dp2[i] != INF && dp2[i + vb[j]] == INF){\n                dp2[i + vb[j]] = dp2[i] + 1;\n            }\n        }\n    }\n}\n\nint main(){\n    int n;\n    solve();\n    while(cin >> n, n){\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repr(i,a,n) for(int i=a;i>=n;i--)\n#define INF 999999999\n#define pb(a) push_back(a)\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef vector<pii> VP;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\n\nint main() {\n    int n;\n    int a[1000];\n    int b[1000];\n    int dp1[1000000];\n    int dp2[1000000];\n    while(cin >> n) {\n        if(n == 0) break;\n        rep(i,0,1000) {\n            a[i] = 0;\n            b[i] = 0;\n        }\n\n        int cnt = 0;\n        for(int i = 1; i * (i+1) * (i+2) / 6 <= n; i++) {\n            int t = i * (i+1) * (i+2) / 6;\n            a[i-1] = t;\n\n            if(t % 2 == 1) {\n                b[cnt] = t;\n                cnt++;\n            }\n        }\n\n/*\n        for(int i = 1; i * (i+1) * (i+2) / 6 <= n; i++) {\n            cout << a[i-1] << endl;\n        }\n\n        cout << endl;\n\n        for(int i = 0; b[i] != 0; i++) {\n            cout << b[i] << endl;\n        }\n*/\n\n        rep(i,0,1000000) {\n            dp1[i] = i;\n            dp2[i] = i;\n        }\n\n        int k = 0;\n        while(1) {\n            if(a[k] != 0 || b[k] != 0) {\n                rep(j,0,n+1) {\n                    dp1[j+a[k]] = min(dp1[j+a[k]], dp1[j] + 1);\n                    dp2[j+b[k]] = min(dp2[j+b[k]], dp2[j] + 1);\n                }\n            }\n            else break;\n            k++;\n        }\n\n        cout << dp1[n] << \" \"<< dp2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_NUM = 1000000;\nconst int INF = 1000000000;\n\nint table[2][MAX_NUM];\nint tet[2][1000];\n\nint calc(int num,int m)\n{\n    if(table[m][num]!=INF) {\n        return table[m][num];\n    } else {\n        for(int i=1; tet[m][i]<num; i++) {\n            table[m][num]=min(table[m][num],calc(num-tet[m][i],m)+1);\n        }\n        return table[m][num];\n    }\n}\n\nint main()\n{\n    for(int i=0; i<MAX_NUM; i++) {\n        table[0][i] = INF;\n        table[1][i] = INF;\n    }\n\n    for(int i=1; i*(i+1)*(i+2)/6<MAX_NUM; i++) {\n        int t=i*(i+1)*(i+2)/6;\n        table[0][t] = 1;\n        tet[0][i] = t;\n\n        if(t%2 == 1) {\n            table[1][t] = 1;\n            tet[1][i] = t;\n        }\n    }\n\n    int in;\n    while(cin>>in && in!=0) {\n        cout<<calc(in,0)<<\" \"<<calc(in,1)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nconst int INF = 1e+8;\n\nusing namespace std;\n\nint main() {\n  int m=1e+6;\n  vector<int> dp1(2*m, INF), dp2(2*m, INF);\n  dp1[0]=dp2[0]=0;\n  REP(i,200) {\n    int t=i*(i+1)*(i+2)/6;\n    if (t>m) break;\n    REP(j,m){\n      dp1[j+t] = min(dp1[j+t], dp1[j]+1);\n      if(t%2) dp2[j+t] = min(dp2[j+t], dp2[j]+1);\n    }\n  }\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    cout<<dp1[n]<<' '<<dp2[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\nconst int inf = 1000000009;\n\nint main() {\n    vector<vector<int>> memo(85, vector<int>(1000000, inf));\n    vector<vector<int>> odd_memo(85, vector<int>(1000000, inf));\n    for (int i=0; i<1000000; i++) {\n        memo[0][i] = 0;\n        odd_memo[0][i] = 0;\n    }\n\n    for (int i=0; i<1000000; i++) {\n        memo[1][i] = i;\n        odd_memo[1][i] = i;\n    }\n\n    for (int l=2; l<(int)memo.size(); l++) {\n        const int n = (l*(l+1)*(l+2))/6;\n        for (int i=0; i<(int)memo[l].size(); i++) {\n            if(i-n == 0) {\n                memo[l][i] = 1;\n            } else if(i-n > 0) {\n                memo[l][i] = min(memo[l][i-n]+1, memo[l-1][i]);\n            } else {\n                memo[l][i] = memo[l-1][i];\n            }\n\n            if (l%2==1) {\n                if(i-n == 0) {\n                    odd_memo[l][i] = 1;\n                } else if(i-n > 0) {\n                    odd_memo[l][i] = min(odd_memo[l][i-n]+1, odd_memo[l-1][i]);\n                } else {\n                    odd_memo[l][i] = odd_memo[l-1][i];\n                }\n            } else {\n                odd_memo[l][i] = odd_memo[l-1][i];\n            }\n        }\n    }\n\n    int n; \n    while (cin >> n, n!=0) {\n        cout << memo[memo.size()-1][n] << \" \" << odd_memo[odd_memo.size()-1][n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nmain {\n  vector<int> dp1(1000001), dp2(1000001);\n  iota(all(dp1), 0), iota(all(dp2), 0);\n  for (int g = 2;; g++) {\n    int p = g * (g + 1) * (g + 2) / 6;\n    if (p > 1000000) break;\n    for (int i = p; i <= 1000000; i++) cmin(dp1[i], dp1[i - p] + 1);\n    if (odd(p)) {\n      for (int i = p; i <= 1000000; i++) cmin(dp2[i], dp2[i - p] + 1);\n    }\n  }\n  while (true) {\n    int n = in();\n    if (n == 0) break;\n    cout << dp1[n] << ' ' << dp2[n] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint dp[2][1000010], adp[2][1000010];\nint INF = 1e9;\nint add[200], oadd[200];\n\nvoid solve() {\n\tfor (int i=0; i<2; i++) {\n\t\tfill(dp[i], dp[i]+1000010, INF);\n\t\tfill(adp[i], adp[i]+1000010, INF);\n\t}\n\t\n\tdp[0][0] = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint nw = i%2, nx = (i+1)%2;\n\t\tfor (int j=0; j<=1000000; j++) {\n\t\t\tif (add[i] <= j) {\n\t\t\t\tdp[nx][j] = min(dp[nw][j], dp[nx][j-add[i]] + 1);\n\t\t\t} else {\n\t\t\t\tdp[nx][j] = dp[nw][j];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tadp[0][0] = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint nw = i % 2, nx = (i+1)%2;\n\t\t\n\t\tfor (int j=0; j<=1000000; j++) {\n\t\t\tif (oadd[i] <= j) {\n\t\t\t\tadp[nx][j] = min(adp[nw][j], adp[nx][j-oadd[i]] + 1);\n\t\t\t} else {\n\t\t\t\tadp[nx][j] = adp[nw][j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid qer() {\t\n\tint ans1 = INF, ans2 = INF;\n\tfor (int i=0; i<2; i++) {\n\t\tans1 = min(ans1, dp[i][n]);\n\t\tans2 = min(ans2, adp[i][n]);\n\t}\n\tcout << ans1 << \" \" << ans2 << endl;\n}\n\nint main() {\n\tint p = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tadd[i] = i * (i+1) * (i+2) / 6;\n\t\tif (add[i] % 2 == 1) oadd[p++] = add[i];\n\t}\n\tsolve();\n\t\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\tqer();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define INF 100000000\nusing namespace std;\n\nconst int SIZE = 1000000 + 1;\nint N;\nint dp1[SIZE], dp2[SIZE];\n\nint main(void) {\n  REP(i, 0, SIZE) dp1[i] = dp2[i] = INF;\n  for(int i = 1, n; n = i * (i + 1) * (i + 2) / 6, n < SIZE; i++) {\n    dp1[n] = 1;\n    if(n % 2 == 1) dp2[n] = 1;\n    for(int j = 1; j + n < SIZE; j++) {\n      dp1[j + n] = min(dp1[j + n], dp1[j] + 1);\n      if(n % 2 == 1) dp2[j + n] = min(dp2[j + n], dp2[j] + 1);\n    }\n  }\n\n  while(cin >> N, N) cout << dp1[N] << \" \" << dp2[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    int ans1=dp[x];\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n    int ans2=dp[x];\n    ///*/\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int R = 1000001;\nint dp1[R],dp2[R],T[160];\n\nvoid solve(void) {\n    for (int i = 1; i < R; i++) dp1[i] = dp2[i] = R;\n    for (int i = 1; i < 161; i++) T[i-1] = i*(i+1)*(i+2)/6;\n    for (int i = 0; i < 160; i++) {\n        int t = T[i];\n        for (int j = t; j < R; j++) {\n            if (dp1[j-t] < R) dp1[j] = min(dp1[j], dp1[j-t]+1);\n            if (t%2 == 0) continue;\n            if (dp2[j-t] < R) dp2[j] = min(dp2[j], dp2[j-t]+1);\n        }\n    }\n}\n\nint main(void){\n    solve();\n    while (1) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        printf(\"%d %d\\n\",dp1[N],dp2[N]);\n    }\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 1e9\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int dp[1000010]={};\n  int dp2[1000010]={};\n  for(int i=1;i<=1000000;i++){dp[i]=INF;dp2[i]=INF;}\n  vector<ll> gu;\n  vector<ll> ki;\n  ll cnt=1;\n  while(1){\n    if((cnt*(cnt+1)*(cnt+2)/6)>1000000)break;\n    if(((cnt*(cnt+1)*(cnt+2))/6)%2)ki.pb(cnt*(cnt+1)*(cnt+2)/6);\n    else gu.pb(cnt*(cnt+1)*(cnt+2)/6);\n    cnt++;\n  }\n  dp[1]=1;\n  dp2[1]=1;\n  for(int i=1;i<1000000;i++){\n    for(int j=0;j<gu.size();j++){\n      if(i+gu[j]>1000000)break;\n      dp[i+gu[j]]=min(dp[i+gu[j]],(dp[i]+1));\n    }\n    for(int j=0;j<ki.size();j++){\n      if(i+ki[j]>1000000)break;\n      dp[i+ki[j]]=min(dp[i+ki[j]],(dp[i]+1));\n      dp2[i+ki[j]]=min(dp2[i+ki[j]],(dp2[i]+1));\n    }\n  }\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    /*for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }*/\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 1e+6;\nconst int INF = 1e+8;\n\nint f(int n){\n\treturn n * (n+1) * (n+2) / 6;\n}\n\nint dp[2][MAX_N+1] = {0};\n\nint main(){\n\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\tdp[0][i] = dp[1][i] = INF;\n\t}\n\tfor(int i=1 ; f(i) < MAX_N ; i++ ){\n\t\tdp[0][f(i)] = 1;\n\t\tif( f(i) % 2 )\n\t\t\tdp[1][f(i)] = 1;\n\t}\n\tfor(int i=1 ; i < MAX_N ; i++ ){\n\t\tif( dp[0][i] != INF ){\n\t\t\tfor(int j=1 ; i + f(j) < MAX_N ; j++ ){\n\t\t\t\tdp[0][i+f(j)] = min( dp[0][i+f(j)] , dp[0][i]+1 );\n\t\t\t}\n\t\t}\n\t\tif( dp[1][i] != INF ){\n\t\t\tfor(int j=1 ; i + f(j) < MAX_N ; j++ ){\n\t\t\t\tif( f(j) % 2 )\n\t\t\t\t\tdp[1][i+f(j)] = min( dp[1][i+f(j)] , dp[1][i]+1 );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\twhile( cin >> n , n ){\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define N (int)1e6\nusing namespace std;\n\nint main(){\n  int n,tmp,dp[N+1],dp_odd[N+1];\n  vector<int> plc;\n\n  for(int i=0;i<=N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(int i=1;;i++){\n    plc.push_back(tmp);\n    tmp *= i+3; tmp /= i;\n    if(tmp>N)break;\n  }\n  \n  for(int i=0;i<=N;i++){\n    for(int j=0;j<(int)plc.size();j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\nconst int INF = 1e9;\nconst int MOD = 1000000007;\n\nint MX = 1000000;\nvector<int> polo;\nvector<int> dp0(MX+1,-1);\nvector<int> dp1(MX+1,-1);\n\nint dfs0(int x = MX){\n        if(dp0.at(x) >= 0) return dp0.at(x);\n        int res = INF;\n        for(auto p:polo){\n                if(x-p < 0) break;\n                res = min(res,dfs0(x-p)+1);\n        }\n        return dp0.at(x) = res;\n}\n\nint dfs1(int x = MX){\n        if(dp1.at(x) >= 0) return dp1.at(x);\n        int res = INF;\n        for(auto p:polo){ \n                if(p%2 == 0) continue;\n                if(x-p < 0) break;\n                res = min(res,dfs1(x-p)+1);\n        }\n        return dp1.at(x) = res;\n}\n\n\nint main() {\n        int i = 1;\n        while(1){\n                int x = i*(i+1)*(i+2)/6;\n                if(x > MX) break;\n                polo.push_back(x);\n                i++;\n        }\n        \n        dp0.at(0) = 0;\n        dp1.at(0) = 0;\n        \n        dfs0();\n        dfs1();\n        \n        while(1){\n                int p;\n                cin >> p;\n                if(p==0) break;\n                cout << dp0.at(p) << \" \" << dp1.at(p) << endl;\n        }\n    \n        return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvi dp(1000001,INF), dp2(1000001,INF);\n\tdp[0] = 0; dp2[0] = 0;\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= 1000000; ++i) {\n\t\tint k = i*(i + 1)*(i + 2) / 6;\n\t\t\n\t\tREP(j, 1000001-k) {\n\t\t\tdp[j + k] = min(dp[j + k], dp[j] + 1);\n\t\t}\n\t}\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= 1000000; ++i) {\n\t\tint k = i*(i + 1)*(i + 2) / 6;\n\t\tif (k % 2 == 0)continue;\n\t\n\t\tREP(j, 1000001 - k) {\n\t\t\tdp2[j + k] = min(dp2[j + k], dp2[j] + 1);\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tcout << dp[n] <<\" \"<<dp2[n]<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <math.h>\n#include <string>\n#include <numeric>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#define ll long long\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep1(i,n) for(ll i=1;i<n;++i)\n#define mrep(i,n) for(ll i=n;i>=0;--i)\n#define all(a) (a).begin(),(a).end()\n#define vl vector<ll>\n#define vvl vector<vector<ll> >\n#define vb vector<bool>\n#define vvb vector<vector<bool> >\n#define pl pair<ll,ll>\n#define inf 1001001001001001000\n//#define mod 1000000007\n#define mod 2\n#define pi 3.1415926535\nusing namespace std;\nstruct __INIT{\n    __INIT(){\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout<<fixed<<setprecision(15);\n    }\n}__init;\n\nll dp[1004732];\nll dp2[1004732];\n\nint main(void){\n    vl sikaku;\n    vl skisu;\n    ll N=185;\n    rep(n,N){\n        sikaku.push_back((n*(n+1)*(n+2))/6);\n    }\n    rep(i,1004732){\n        dp2[i] = inf;\n        dp[i] = inf;\n    }\n    dp2[0] = 0;\n    dp[0] = 0;\n    rep(i,185) rep(j,1004732){\n        if(j < sikaku[i]) continue;\n        dp2[j] = min(dp2[j],dp2[j-sikaku[i]]+1);\n        if(sikaku[i]%2 == 1) dp[j] = min(dp[j],dp[j-sikaku[i]]+1);\n    }\n    while(true){\n        ll n;\n        cin>>n;\n        if(n == 0) break;\n        cout<<dp2[n]<<\" \"<<dp[n]<<endl;;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n  vector<int> rets;\n  vector<int> rets_odd;\n\n  vector<int> options;\n  int M = 1000000;\n  for (int i = 1;; ++i) {\n    int a = i * (i + 1) * (i + 2) / 6;\n    if (a > M)\n      break;\n    options.push_back(a);\n  }\n\n  int dp[M + 1];\n  for (int i = 0; i < M + 1; ++i)\n    dp[i] = 1000000000;\n  for (int i = 0; i < options.size(); ++i)\n    dp[options[i]] = 1;\n  for (int i = 1; i < M; ++i) {\n    if (dp[i + 1] == 1)\n      continue;\n    for (int j = 0; j < options.size(); ++j) {\n      if (options[j] > i)\n        continue;\n      if (dp[i - options[j] + 1] != 1000000000) {\n        dp[i + 1] = min(dp[i + 1], dp[i - options[j] + 1] + 1);\n      }\n    }\n  }\n\n  vector<int> options_odd;\n  for (int i = 1;; ++i) {\n    int a = i * (i + 1) * (i + 2) / 6;\n    if (a > M)\n      break;\n    if (a % 2 == 1)\n      options_odd.push_back(a);\n  }\n\n  int dp_odd[M + 1];\n  for (int i = 0; i < M + 1; ++i)\n    dp_odd[i] = 1000000000;\n  for (int i = 0; i < options_odd.size(); ++i)\n    dp_odd[options_odd[i]] = 1;\n  for (int i = 1; i < M; ++i) {\n    if (dp_odd[i + 1] == 1)\n      continue;\n    for (int j = 0; j < options_odd.size(); ++j) {\n      if (options_odd[j] > i)\n        continue;\n      if (dp_odd[i - options_odd[j] + 1] != 1000000000) {\n        dp_odd[i + 1] = min(dp_odd[i + 1], dp_odd[i - options_odd[j] + 1] + 1);\n      }\n    }\n  }\n\n  while (true) {\n    int n;\n    cin >> n;\n\n    if (n == 0)\n      break;\n\n    rets.push_back(dp[n]);\n    rets_odd.push_back(dp_odd[n]);\n\n  }\n\n  for (int i = 0; i < rets.size(); ++i)\n    cout << rets[i] << \" \" << rets_odd[i] << endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint dp[1000001],Odp[1000001];\nint Tn[200],OTn[200]; \n\nint main(){\n    int count = 0;  //pollocks numberの生成\n    for(int i = 1;i < 200;i++){\n        Tn[i-1] = i * (i + 1) * (i + 2) / 6;\n        if(Tn[i-1] % 2 == 1){\n            OTn[count] = Tn[i-1];\n            count++;\n        }\n    }\n    int n = 1000000;\n\n    //正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        dp[j] = j;\n    int k;\n    for(int i = 0;i < 200;i++)\n        for(int j = Tn[i];j <= 1000000;j++){\n            if(j >= Tn[i])\n                dp[j] = min(dp[j],dp[j-Tn[i]] + 1);\n            k = i;\n        }\n\n    //奇数正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        Odp[j] = j;\n    int k1;\n    for(int i = 0;i <= 200;i++)\n        for(int j = OTn[i];j <= n;j++){\n            if(j >= OTn[i])\n                Odp[j] = min(Odp[j],Odp[j-OTn[i]] + 1);\n            k1 = i;\n        }\n    while(cin >> n,n)\n        cout << dp[k][n] << ' ' <<  Odp[k1][n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000\nusing namespace std;\n\nconst int M = 1000000;\nint N, base1[M + 1], base2[M + 2], dp1[M + 1], dp2[M + 1];\n\nint dfs1(int n) {\n  if(dp1[n] >= 0) return dp1[n];\n  if(base1[n]) return dp1[n] = 1;\n\n  int ret = INF;\n  REP(i, 1, n - 1) {\n    if(!base1[i]) continue;\n    ret = min(ret, dfs1(i) + dfs1(n - i));\n  }\n  return dp1[n] = ret;\n}\n\nint dfs2(int n) {\n  if(dp2[n] >= 0) return dp2[n];\n  if(base2[n]) return dp2[n] = 1;\n\n  int ret = INF;\n  REP(i, 1, n - 1) {\n    if(!base2[i]) continue;\n    ret = min(ret, dfs2(i) + dfs2(n - i));\n  }\n  return dp2[n] = ret;\n}\n\nint main(void) {\n  REP(i, 1, M) dp1[i] = dp2[i] = -1, base1[i] = base2[i] = 0;\n  for(int i = 1, n; n = i * (i + 1) * (i + 2) / 6, n <= M; i++) {\n    base1[n] = 1;\n    if(n % 2 == 1) base2[n] = 1;\n  }\n\n  while(cin >> N, N) {\n    cout << dfs1(N) << \" \" << dfs2(N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint List[100];\n\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tList[i]=i*(i+1)*(i+2)/6;\n\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n//\tsetpolloc();\n\twhile(cin>>n,n){\n//\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\n\n\nint main(){\n  int n;\n  int res[200] = {};\n  res[1] = 1;\n  rep(i,2,200){\n    res[i] = (res[i-1]*(i+2))/(i-1);\n    //cout << i  << \"  \" << res[i] << endl;\n  }\n  \n  //cout << (180/120*179*178*177*176)/(3*2*1) << endl;\n  int dp[2000000] = {};\n  int dps[2000000] = {};\n  REP(i,1e6+1){\n    dp[i] = 100;\n    dps[i] = 10000000;\n  }\n  rep(i,1,181){\n    dp[res[i]] = 1;\n    if(res[i]%2 == 1){\n      dps[res[i]] = 1;\n    }\n  }\n  //cout << dps[5] << endl;\n  REP(i,1e6+1){\n    for(int j = 1;j < 181;j++){\n      if(dp[i] != 0){\n\tdp[i+res[j]] = min(dp[i+res[j]],dp[i]+1);\n\t\n      }\n      if(dps[i] != 0){\n\tif(res[j]%2 == 1)\n\t  dps[i+res[j]] = min(dps[i+res[j]], dps[i]+1);\n\t\n      }\n      \n    }\n    \n  }\n  while(cin >> n, n){\n\n    cout << dp[n] << \" \" << dps[n] << endl; \n\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(ll i=0;i<(num);++i)\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto pitr=c.begin();pitr!=c.end();++pitr){cout<<*pitr;if(next(pitr,1)!=c.end())cout<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=ll>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=ll,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\ntemplate<typename T>\nbool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>\nbool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\tvll Q(200),O;\n\tREP(i,200){\n\t\tQ[i] = (i+1ll)*(i+2ll)*(i+3ll)/6ll;\n\t\tif(Q[i]%2) O.push_back(Q[i]);\n\t}\n\n\tvll dp(1000010),dp2(1000010);\n\tREP(i,1000010){\n\t\tdp[i]=1ll<<60;\n\t\tdp2[i]=1ll<<60;\n\t}\n\tdp[0]=0,dp2[0]=0;\n\tint X=Q.size(),Y=O.size();\n\tREP(i,X){\n\t\tREP(j,1000000){\n\t\t\tif(j+Q[i]<=1000000) chmin(dp[j+Q[i]],dp[j]+1);\n\t\t}\n\t}\n\tREP(i,Y){\n\t\tREP(j,1000000){\n\t\t\tif(j+O[i]<=1000000) chmin(dp2[j+O[i]],dp2[j]+1);\n\t\t}\n\t}\n\twhile(true){\n\t\tint N=in();\n\t\tif(!N) break;\n\t\t\n\t\tout(dp[N],dp2[N]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (long long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (long long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1000001;\nconst int INF = 1<<27;\nvector<int> N3, N4;\nint T[2][MAX_N];\n\nvoid makeN4() {\n  for(int n = 1; ; ++n) {\n    int s = n*(n+1)*(n+2)/6;\n    if(s >= MAX_N) break;\n    N4.push_back(s);\n  }\n}\n\nvoid solve(bool oddOnly) {\n  int *t = T[oddOnly];\n  fill(t, t+MAX_N, INF);\n  t[0] = 0;\n  /*\n  for(int j = 0; j < N4.size(); ++j) {\n    if(oddOnly && N4[j]%2 == 0) continue;\n    for(int i = N4[j]; i < MAX_N; ++i) {\n      t[i] = min(t[i], t[i-N4[j]] + 1);\n    }\n  }\n  */\n  for(int i = 1; i < MAX_N; ++i) {\n    for(int j = 0; j < N4.size() && N4[j] <= i; ++j) {\n      if(oddOnly && N4[j]%2 == 0) continue;\n      t[i] = min(t[i], t[i-N4[j]] + 1);\n    }\n  }\n\n}\n\nint main() {\n  makeN4();\n  solve(false);\n  solve(true);\n  int N;\n  while(cin >> N && N) {\n    cout << T[0][N] << \" \" << T[1][N] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define INF 0x7FFFFFFF\n\nint main(void){\n\tint i, j, k, n, min1;\n\tint dp[1000001];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tfor(k = 0;k < n;k++){\n\t\t\tfor(i = n;i >= 0;i--){\n\t\t\t\tif(dp[i] != INF){\n\t\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n\t\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[n] == 1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmin1 = dp[n];\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tfor(k = 0;k < n;k++){\n\t\t\tfor(i = n;i >= 0;i--){\n\t\t\t\tif(dp[i] != INF){\n\t\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n\t\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[n] == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d %d\\n\",min1,dp[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi v;\n\t\tFOR(i, 1, INF) {\n\t\t\tv.push_back(i*(i + 1)*(i + 2) / 6);\n\t\t\tif (v[i - 1] >= n)break;\n\t\t}\n\t\tint m = v.size();\n\t\tvi dp(n + 1,INF);\n\t\tdp[0] = 0;\n\t\tREP(i, m) {\n\t\t\tREP(j, n + 1) {\n\t\t\t\tif (j >= v[i]) dp[j] = min(dp[j], dp[j - v[i]] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << \" \";\n\n\t\tREP(j, n + 1) {\n\t\t\tdp[j] = INF;\n\t\t}\n\n\t\tdp[0] = 0;\n\t\tREP(i, m) {\n\t\t\tif (v[i] % 2 == 0) continue;\n\n\t\t\tREP(j, n + 1) {\n\t\t\t\tif(j>=v[i])dp[j] = min(dp[j], dp[j - v[i]] + 1);\n\t\t\t}\n\n\t\t}\n\t\tcout << dp[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define mp make_pair\nconst int inf=1e9+7;\nconst ll mod=1e9+7;\n\nint DP1[1000001];\nint DP2[1000001];\n\nint main() {\n    vector<int> oldarr, newarr;\n    for(int i=1;i<200;++i){\n        if(i*(i+1)/2*(i+2)/3>1000000) break;\n        DP1[i*(i+1)/2*(i+2)/3] = 1;\n        oldarr.push_back(i*(i+1)/2*(i+2)/3);\n    }\n    for(int i=2;i<6;++i){\n        newarr.clear();\n        for(int j=0;j<oldarr.size();++j){\n            for(int k=1;k<200;++k){\n                if(oldarr[j]+k*(k+1)/2*(k+2)/3>1000000) break;\n                if(DP1[oldarr[j]+k*(k+1)/2*(k+2)/3]==0){\n                    DP1[oldarr[j]+k*(k+1)/2*(k+2)/3] = i;\n                    newarr.push_back(oldarr[j]+k*(k+1)/2*(k+2)/3);\n                }\n            }\n        }\n        oldarr = newarr;\n    }\n\n    oldarr.clear();\n    for(int i=1;i<200;++i){\n        if(i*(i+1)/2*(i+2)/3>1000000) break;\n        if((i*(i+1)/2*(i+2)/3) % 2 == 1){\n            DP2[i*(i+1)/2*(i+2)/3] = 1;\n            oldarr.push_back(i*(i+1)/2*(i+2)/3);\n        }\n    }\n    bool ans = true;\n    while(ans){\n        ans = false;\n        newarr.clear();\n        for(int j=0;j<oldarr.size();++j){\n            for(int k=1;k<200;++k){\n                if(oldarr[j]+k*(k+1)/2*(k+2)/3>1000000) break;\n                if((k*(k+1)/2*(k+2)/3) % 2 == 1){\n                    if(DP2[oldarr[j]+k*(k+1)/2*(k+2)/3]==0){\n                        ans = true;\n                        DP2[oldarr[j]+k*(k+1)/2*(k+2)/3] = DP2[oldarr[j]] + 1;\n                        newarr.push_back(oldarr[j]+k*(k+1)/2*(k+2)/3);\n                    }\n                }\n            }\n        }\n        oldarr = newarr;\n    }\n    int tmp;\n    while(true){\n        cin>>tmp;\n        if(tmp==0) break;\n        cout<<DP1[tmp]<<\" \"<<DP2[tmp]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\nint ress;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\n  int res=0xFFFF;\n  if(maxcnt<cnt) return 0xFFFE;\n  if(sum == target) return cnt;\n  for(int i=oddlistcnt-1; 0<=i; i--) {\n    if(sum+oddlist[i] > target) continue;\n    res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n    if(res==0xFFFE) break;\n  }\n  return res;\n}\nvoid mama(int x){\n  if(x==0) return;\n  int tmp[oddlistcnt];\n  memset(tmp,0,sizeof(tmp));\n  for(int i=0;i<oddlistcnt;i++){\n    tmp[i]=x/oddlist[i];\n    if(tmp[i]==0) {\n      ress+=tmp[i-1];\n//    cout << ress << endl;\n      mama(x-tmp[i-1]*oddlist[i-1]);\n      break;\n    }\n  }\n}\n\n\nint main(void) {\n  for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n    list.push_back(i*(i+1)*(i+2)/6);\n    if(i*(i+1)*(i+2)/6 % 2)\n      oddlist.push_back(i*(i+1)*(i+2)/6);\n  }\n\n\n  listcnt = list.size();\n  oddlistcnt = oddlist.size();\n  while(true) {\n    int n;\n    scanf(\"%d\",&n);\n    if(!n) break;\n\n    int res=5, oddres=1000;\n    for(int i=listcnt-1; 0<=i; i--) {\n      if(list[i]>n) continue;\n      if(list[i]==n){ res=1; break; }\n      if(res<=2) continue;\n      for(int j=listcnt-1; 0<=j; j--) {\n        if(list[i] + list[j]>n) continue;\n        if(list[i] + list[j]==n) res=2;\n        if(res<=3) continue;\n        for(int k=listcnt-1; 0<=k; k--) {\n          if(list[i] + list[j] + list[k]>n) continue;\n          if(list[i] + list[j] + list[k]==n) res=3;\n          if(res<=4) continue;\n          for(int l=listcnt-1; 0<=l; l--) {\n            if(list[i] + list[j] + list[k] + list[l]>n) continue;\n            if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n            if(res<=4) break;\n          }\n        }\n      }\n    }\n\n    /*        if((oddres=oddrec(n, 0, 0, 1))>=0xFFFE) {\n              for(int i=2; ; i=i*3/2) {\n              if((oddres=oddrec(n, 0, 0, i))<0xFFFE)\n              break;\n              }\n              }\n\n              printf(\"%d %d\\n\",res,oddres);\n\n     * p    */\n    ress=0;\n    mama(n);\n    printf(\"%d %d\\n\",res,ress);\n  }\n\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\n\nvector<int> table;\n\nint dp[2][100][1001000];\n\nint main() {\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= 100000; i++) {\n\t\ttable.push_back(i*(i + 1)*(i + 2) / 6);\n\t}\n\tREP(i, 2) {\n\t\tREP(j, 100) {\n\t\t\tREP(k, 1001000)dp[i][j][k] = INF;\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tdp[1][0][0] = 0;\n\n\tREP(i, table.size()) {\n\t\tint num = table[i];\n\t\tREP(j, 1000000 + 1) {\n\t\t\tif (j + num <= 1000000) {\n\t\t\t\tdp[0][i + 1][j + num] = min(dp[0][i][j] + 1, dp[0][i][j + num]);\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tdp[1][i + 1][j + num] = min(dp[1][i][j] + 1, dp[1][i][j + num]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (cin >> n&&n) {\n\t\tcout << dp[0][table.size()][n] << \" \"\n\t\t\t<< dp[0][table.size()][n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n//#include <fstream>\t// require freopen\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\ntypedef pair<int,int> P;\n\nvector<P> p;\n\nvoid make_pollock (void )\n{\n\tfor (int i = 1; i <= 85; i++ ){\n\t\tll ans = (ll)i*(i+1LL)*(i+2LL)/6LL;\n\t\tp.push_back (P ((int)ans, i )  );\n\t} // end rep\n}\n\nint main()\n{\n\n\tp.clear();\n\tmake_pollock();\n\tint N = 1000000;\n\tvector <int> dp1 (N+1, INF ), dp2 (N+1, INF );\n\tdp1[0] = 0;\n\tfor (int i = 0; i < p.size(); i++ ){\n\t\tint m = p[i].first;\n\t\tfor (int j = m; j <= N; j++ ){\n\t\t\tif (dp1[j] > dp1[j - m] + 1 ){\n\t\t\t\tdp1[j] = dp1[j - m] + 1;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\tdp2[0] = 0;\n\tfor (int i = 0; i < p.size(); i++ ){\n\t\tif (p[i].first % 2 == 0 ) continue;\n\t\tint m = p[i].first;\n\t\tfor (int j = m; j <= N; j++ ){\n\t\t\tif (dp2[j] > dp2[j - m] + 1 ){\n\t\t\t\tdp2[j] = dp2[j - m] + 1;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n//\tfreopen (\"testcase.PC2\", \"r\", stdin );\n\tint n;\n\twhile (cin >> n && n ){\n\t\tP res = P(0, 0 );\n\t\tres.first = dp1[n];\n\t\tres.second = dp2[n];\t\n\t\tcout << res.first << ' ' << res.second << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\nint dp[500];\nint dp1[11111500];\nint dp2[11111100];\nint main(){\n    dp[1]=1;\n    for(int i=2;i<210;i++){\n        dp[i]=dp[i-1]+i;\n    }\n    for(int i=2;i<210;i++){\n        dp[i]=dp[i-1]+dp[i];\n    }\n   // fill(dp,dp+400,0);\n    fill(dp1,dp1+1111100,99999999);\n    fill(dp2,dp2+1111100,99999999);\n    dp1[0]=0;dp2[0]=0;\n    for(int i=1;i<210;i++){\n        int now=dp[i];\n        for(int k=now;k<1100000;k++){\n            if(dp1[k]>dp1[k-now]+1){\n                dp1[k]=dp1[k-now]+1;\n            }\n        }\n    }\n    for(int i=1;i<300;i++){\n        int now=dp[i];\n        if(now%2==0)\n            continue;\n        for(int k=now;k<1100000;k++){\n            if(dp2[k]>dp2[k-now]+1)\n                dp2[k]=dp2[k-now]+1;\n        }\n    }\n    int n;\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint a[180];\nint ans[1000001];\nint ansb[1000001];\nconst int INF=1<<28;\n\nint main()\n{\n\tfor(int i=1;i<=180;i++)\n\t{\n\t\ta[i-1]=i*(i+1)*(i+2);\n\t\ta[i-1]/=6;\n\t}\n\tans[0]=0;\n\tansb[0]=0;\n\tfor(int i=1;i<=1000000;i++)\n\t{\n\t\tans[i]=10;\n\t\tansb[i]=INF;\n\t\tfor(int j=0;j<180&&i-a[j]>=0;j++)\n\t\t{\n\t\t\tans[i]=min(ans[i],ans[i-a[j]]+1);\n\t\t\tif(j%4==0)ansb[i]=min(ansb[i],ansb[i-a[j]]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tcout<<ans[n]<<\" \"<<ansb[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\nusing vl=vector<ll>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvl llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){f=false;}\n        llist.pb(next);\n        n++;\n    }\n}\n\nint bfs(int target){\n    si q;\n    Foreach(i,llist) {if(i==target){return 1;}if(i<=target){q.insert(i);}}\n    auto mm=*max_element(beginend(q));\n    int cnt=(target-mm)/mm;\n    target=(target)%mm+mm;\n    Foreach(i,q) if(i==target) return cnt+1;\n    cnt+=2;\n    while(1){\n        si next;\n        Foreach(x,q){\n            Foreach(k,llist){\n                if(k+x>target) break;\n                if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.insert(k+x);\n            }\n        }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    si q;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) q.insert(i);\n        if(i>target) break;\n    }\n    auto mm=*max_element(beginend(q));\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    Foreach(i,q)if(target==i) return cnt+1;\n    cnt+=2;\n    while (1)\n    {\n        si next;\n        Foreach(x,q){\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.insert(k+x);\n            }\n        }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n    }\n    auto mm=max_element(beginend(query));\n    makeList(*mm);\n    oddlist=llist;\n    removeAll(oddlist,[](ll x){return x%2==0;});\n    Foreach(i,query){\n        cout<<bfs(i)<<\" \"<<bfs2(i)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF INT_MAX/3\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define debug(x) cout<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cout<<#x\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nvi num;\nvi num_odd;\nint N;\nint N_odd;\nint dp[1000001];\nint dpdp[1000001];\n\nvoid init(){\n    int t=1;\n    int i=1;\n    while(t<1000000){\n        num.EB(t);\n        i++;\n        t = i*(i+1)*(i+2)/6;\n    }\n    N = num.size();\n\n    for(i=0;i<N;i++){\n        if(num[i]%2==1) num_odd.emplace_back(num[i]);\n    }\n    N_odd = num_odd.size();\n}\n\nvoid solve(int n){\n    for(int i=0;i<=n;i++) dp[i] = INF,dpdp[i]= INF;\n    dp[0]=0;\n    for(int i=0;i<N;i++){\n        for(int j=num[i];j<=n;j++){\n            dp[j] = min(dp[j],dp[j-num[i]]+1);\n        }\n    }\n\n\n    dpdp[0] = 0;\n    for(int i=0;i<N_odd;i++){\n        for(int j=num_odd[i];j<=n;j++){\n            dpdp[j] = min(dpdp[j],dpdp[j-num_odd[i]]+1);\n        }\n    }\n}\n\nint main(){\n    init();\n    int n;\n\n    for(int i=0;i<1000001;i++) dp[i] = INF,dpdp[i]= INF;\n    dp[0] = 0;\n    dpdp[0] = 0;\n\n    solve(1000000);\n\n    while(cin>>n){\n        if(n==0) break;\n        cout << dp[n] << \" \" << dpdp[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int MAX_N = 1000001;\nconst int INF = 1<<27;\nvector<int> N3, N4;\nint T[MAX_N];\n\nvoid makeN3() {\n  N3.push_back(0);\n  for(int i = 1, s = 1; s <= MAX_N; s += ++i) {\n    N3.push_back(s);\n  }\n}\n\nvoid makeN4() {\n  N4.push_back(0);\n  for(int i = 1, s = N3[1];\n      i < N3.size() && s <= MAX_N; s += N3[++i]) {\n    N4.push_back(s);\n  }\n}\n\nint solve(int N, bool oddOnly) {\n  fill(T, T+N+1, INF);\n  T[0] = 0;\n  for(int i = 1; i <= N; ++i) {\n    for(int j = 1; j < N4.size() && N4[j] <= i; ++j) {\n      if(oddOnly && N4[j]%2 == 0) continue;\n      T[i] = min(T[i], T[i-N4[j]] + 1);\n    }\n  }\n  return T[N];\n}\n\nint main() {\n  int N;\n  makeN3();\n  makeN4();\n  while(cin >> N && N) {\n    cout << solve(N,false) << \" \" << solve(N,true) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://ei1333.github.io/luzhiled/\n// http://beet-aizu.hatenablog.com/entry/2017/01/04/113233\n// http://www.prefield.com/algorithm/\n#include <bits/stdc++.h>\nconstexpr char bn = '\\n';\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\nusing vd = vector<ld>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vvl = vector<vector<ll>>;\nusing vvd = vector<vector<ld>>;\nusing vvs = vector<vector<string>>;\nusing vvb = vector<vector<bool>>;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\nusing Graph = vector<vector<ll>>;\nconst ll INF = 1LL << 60;\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\nconst ll tl= 1000000007;\n#define REP(i, n) for (ll i = 0; i < n; i++)\n#define REREP(i, n) for (ll i = n; i >= 0; i--)\n#define FOR(i, a, n) for (ll i = a; i < n; i++)\n#define REFOR(i, n, a) for (ll i = n; i >= a; i--)\n#define CLR(mat,f) memset(mat, f, sizeof(mat))\n#define IN(a, b, x) (a<=x&&x<=b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() ) //被り削除\n#define debug cout << \"line : \" << __LINE__ << \" debug\" << endl;\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ind(...) long double __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << endl;} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#define in1(A) REP(i,A.size()) in(A[i]);\n#define in2(A,B) REP(i,A.size()) in(A[i],B[i]);\n#define in3(s,t,u) REP(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) REP(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\nstruct Point{ ld x,y; };\nld dist(Point a, Point b){return sqrt(abs(a.x-b.x)*abs(a.x-b.x)+abs(a.y-b.y)*abs(a.y-b.y));} // ２点間の距離 \nll gcd(ll a, ll b) { return b != 0 ? gcd(b, a % b) : a; }\nll lcm(ll a,ll b){ return a / gcd(a,b) * b;} \nll modpow(ll a, ll n, ll mod) {\n  ll res = 1;\n   while (n > 0) {\n      if (n & 1) res = res * a % mod;\n      a = a * a % mod;\n      n >>= 1;\n  }\n  return res;\n}\nll fact(ll n){ if(n < 2) return 1; return (n * fact(n-1))%tl; } //階乗\ninline ll updiv(ll a,ll b){ return (a + b - 1) / b; } //切り上げ\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate <class A, class B> inline bool chmax(A &a, const B &b) { return b > a && (a = b, true); }\ntemplate <class A, class B> inline bool chmin(A &a, const B &b) { return b < a && (a = b, true); }\n#define YES(n) ((n) ? \"YES\" : \"NO\"  )\n#define Yes(n) ((n) ? \"Yes\" : \"No\"  )\n#define yes(n) ((n) ? \"yes\" : \"no\"  )\n//-------------------------------------------------------------------------------------------------\n\nint main(){\n    init();\n    size_t sz= 1000000; \n    vl dp1(sz,INF);\n    vl A; // oddeven\n    vl dp2(sz,INF);\n    vl B;// odd\n    dp1[0]=0; dp2[0]=0;\n    ll fig=1;\n    while(fig*(fig+1)*(fig+2)/6<1000000){\n        ll p= fig*(fig+1)*(fig+2)/6;\n        A.pb(p);\n        if(p&1){\n            B.pb(p);\n        }\n        fig++;\n    }\n    REP(i,sz){\n        REP(k,sz(A)){\n            if(i+A[k]<sz){\n                chmin(dp1[i+A[k]], dp1[i]+1);\n            }  \n        }\n    }\n    REP(i,sz){\n        REP(k,sz(B)){\n            if(i+B[k]<sz){\n                chmin(dp2[i+B[k]], dp2[i]+1);\n            }  \n        }\n    }\n    ll n;\n    while(cin >> n && n){\n        out(dp1[n],dp2[n]);\n    }\n    \n\n    // out();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\nint main() {\n    ll s4[101];\n    vector<ll> s4_k;\n    for(ll i = 0; i < 101; i++){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    vector<ll> dp1(1000001, INF), dp2(1000001, INF);\n    dp1[0] = 0;\n    REP(i, 101){\n        REP(j, 1000001){\n            if(s4[i] <= j){\n                dp1[j] = min(dp1[j], dp1[j - s4[i]] + 1);\n            }\n        }\n    }\n    \n    dp2[0] = 0;\n    REP(i, s4_k.size()){\n        REP(j, 1000001){\n            if(s4_k[i] <= j){\n                dp2[j] = min(dp2[j], dp2[j - s4_k[i]] + 1);\n            }\n        }\n    }\n    \n    ll n;\n    cin >> n;\n    \n    while(n != 0){\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n        \n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 1000000\n#define INFINITY 2000000000\nusing namespace std;\nint dp[N],data[N];\nvector<int> data2;\nint DP(int);\nint DP2(int);\nint main(){\n  int i,out,out2,n,c;\n  data2.push_back(0);\n  for(i=1;i<N;i++){\n    data[i]=i*(i+1)*(i+2)/6;\n    if(data[i]>N){\n      c=i;\n    }\n    if(data[i]%2==1){\n      data2.push_back(data[i]);\n    }\n  }\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    out=DP(n);\n    out2=DP2(n);\n    cout << out << ' ' << out2 << endl;\n  }\n  return 0;\n}\nint DP(int n){\n  int i,j,minret,s;\n  for(i=1;i<N;i++){\n    if(data[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[i]=INFINITY;\n  dp[0]=0;\n  for(i=1;i<=s;i++){\n    for(j=data[i];j<=n;j++){\n      dp[j]=min(dp[j],dp[j-data[i]]+1);\n    }\n  }\n  return dp[n];\n}\nint DP2(int n){\n  int i,j,minret,s,len;\n  len=data2.size();\n  for(i=1;i<len;i++){\n    if(data2[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[i]=INFINITY;\n  dp[0]=0;\n  for(i=1;i<=s;i++){\n    for(j=data2[i];j<=n;j++){\n      dp[j]=min(dp[j],dp[j-data2[i]]+1);\n    }\n  }\n  return dp[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nint main()\n{\n\tint n;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j <= 1000000; j++)\n\t\t{\n\t\t\tif (j == 0)dp[i][j] = 0;\n\t\t\telse dp[i][j] = 999999;\n\t\t}\n\t}\n\tvector<int> v;\n\tfor (int i = 1;;i++)\n\t{\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif (k > 1000000)break;\n\t\tv.push_back(k);\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < v.size(); j++)\n\t\t\t{\n\t\t\t\tif (i + v[j] > n)break;\n\t\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]],dp[0][i] + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < v.size();j++)\n\t\t\t{\n\t\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\t\tif (i + v[j] > n)break;\n\t\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i <(n); ++i)\nusing namespace std;\n\nconst int N = 1010101, M = 200;\n\nint main() {\n    vector<int> A(M + 1, 1);\n    rep(_, 3) rep(i, M) A[i + 1] += A[i];\n    vector<int> dp(N, N), ep(N, N);\n    dp[0] = 0;\n    ep[0] = 0;\n    for(auto &n : A) rep(i, N) {\n        if(i + n < N) {\n            dp[i + n] = min(dp[i + n], dp[i] + 1);\n            if(n % 2) ep[i + n] = min(ep[i + n], ep[i] + 1);\n        }\n    }\n    int N;\n    while(cin >> N) {\n        if(!N) break;\n        cout << dp[N] << \" \" << ep[N] << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  int v[110];\n  FOR(i,0,110) v[i] = i * (i + 1) * (i + 2) / 6;\n\n  int dp[1000006];\n  FOR(i,0,1000006) dp[i] = 1e9;\n  dp[0] = 0;\n  FOR(i,0,1000006) {\n    FOR(j,0,110) {\n      if(i - v[j] >= 0) dp[i] = min(dp[i], dp[i - v[j]] + 1);\n    }\n  }\n\n  int dp_even[1000006];\n  FOR(i,0,1000006) dp_even[i] = 1e9;\n  dp_even[0] = 0;\n  FOR(i,0,1000006) {\n    FOR(j,0,110) {\n      if(v[j]%2 == 0) continue;\n      if(i - v[j] >= 0) dp_even[i] = min(dp_even[i], dp_even[i - v[j]] + 1);\n    }\n  }\n  while(cin>>n,n) {\n    cout << dp[n] << \" \" << dp_even[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n  vector<int> sqNum;\n  vector<int> oddSqNum;\n  for(int i=1; i<202; i++){\n    int num = i*(i+1)*(i+2)/6;\n    sqNum.PB( num );\n    if(num%2==1)\n      oddSqNum.PB( num );\n  }\n\n  int N=100000;\n  int dp[N], oddDp[N];\n  fill( dp, dp+N, INF );\n  fill( oddDp, oddDp+N, INF );\n  dp[0] = 0;\n  oddDp[0] = 0;\n\n  REP(i,N){\n    REP(j,sqNum.size()){\n      if( i-sqNum[j] >= 0 ){\n\tdp[i] = min( dp[i], dp[i-sqNum[j]]+1 );\n      }\n    }\n\n    REP(j,oddSqNum.size()){\n      if( i-oddSqNum[j] >= 0 ){\n\toddDp[i] = min( oddDp[i], oddDp[i-oddSqNum[j]]+1 );\n      }\t\n    }\n  }\n\n  int n;\n  while(cin>>n,n){\n    cout << dp[n] << \" \" << oddDp[n] << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//type\ntypedef long long ll;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n//x * y * 1.0 can cause overflow\n//constant\n#define inf (int)(1e9+7)\n#define mod (ll)(1e9+7)\n#define eps 1e-10\nint di[] = {0, 0, -1, 1, -1, 1, -1, 1}; //右、左、マイナス、プラス\nint dj[] = {1, -1, 0, 0, -1, 1, 1, -1};\n//omission\n#define eb emplace_back\n#define F first\n#define S second\n#define SZ(x) ((int)(x).size())\n//manip\ntemplate<class T> bool chmax(T &a, T &b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<class T> bool chmin(T &a, T &b) {if (a > b) {a = b; return 1;} return 0;}\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end(), v.end());\n#define fill(x, y) memset(x, y, sizeof(x))\n#define ceil(a, b) a / b + !!(a % b)\ntemplate<class T> T power(T a, T b)\n{return b ? power(a * a % inf, b / 2) * (b % 2 ? a : 1) % inf : 1;}\n#define LB(v, x) (int)(lower_bound(v.begin(), v.end(), x) - v.begin())\n#define UB(v, x) (int)(upper_bound(v.begin(), v.end(), x) - v.begin())\n//loop\n#define rep(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define rep3(i, st, n) for (int i = st; i < n; ++i)\n//algorithm\n//double pointer, l start, how many adds, can be 0 -> init r = l, sum = 0\n//bfs, not x, y, i, j\n//not !(i % 2), i % 2 == 0\n\nint dp[1000007];\nint dpodd[1000007];\nint main() {\n    //cast caution\n    //look constraints always\n    cin.tie(0); ios::sync_with_stdio(false);\n    \n    \n    \n    \n    \n    \n    \n    int cand[200] = {0};\n    cand[0] = 0;\n    rep3(i, 1, 200) {\n        cand[i] = i * (i + 1) * (i + 2) / 6;\n    }\n    \n    int n;\n    while (cin >> n && n) {\n        rep(i, n + 1) {dp[i] = dpodd[i] = i;}\n        rep3(i, 1, 183) {\n            if (cand[i] > n + 1) break;\n            rep3(j, cand[i], n + 1) {\n                if (j > n + 1) break;\n                dp[j] = min(dp[j], dp[j - cand[i]] + 1);\n                if (cand[i] % 2 != 0) dpodd[j] = min(dpodd[j], dpodd[j - cand[i]] + 1);\n            }\n            //rep(i, n + 1) cout << dp[i] << \" \"; cout << endl;\n        }\n        cout << dp[n] << \" \" << dpodd[n] << endl;\n        \n        \n        \n        \n        \n    }\n    \n    \n    \n    \n    \n    \n}\n//cast caution\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF INT_MAX/3\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define debug(x) cout<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cout<<#x\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nvi num;\nvi num_odd;\nint N;\nint N_odd;\n\nvoid init(){\n    int t=1;\n    int i=1;\n    while(t<1000000){\n        num.EB(t);\n        i++;\n        t = i*(i+1)*(i+2)/6;\n    }\n    N = num.size();\n\n    for(i=0;i<N;i++){\n        if(num[i]%2==1) num_odd.emplace_back(num[i]);\n    }\n    N_odd = num_odd.size();\n}\n\nvoid solve(int n){\n    vvi dp(N+1,vi(n+10,INF));\n    for(int i=0;i<N;i++) dp[i][0]=0;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<=n;j++){\n            if(j-num[i]>=0){\n                dp[i+1][j] = min(dp[i][j],dp[i+1][j-num[i]]+1);\n            }else{\n                dp[i+1][j] = dp[i][j];\n            }\n        }\n    }\n\n\n\n    cout << dp[N][n] << \" \";\n\n\n    dp.shrink_to_fit();\n    dp.resize(N_odd+1,vi(n+10,INF));\n\n    for(int i=0;i<N_odd;i++) dp[i][0]=0;\n\n\n    for(int i=0;i<N_odd;i++){\n        for(int j=0;j<=n;j++){\n            if(j-num_odd[i]>=0) dp[i+1][j] = min(dp[i][j],dp[i+1][j-num_odd[i]]+1);\n            else dp[i+1][j] = dp[i][j];\n        }\n    }\n    //for(int i=0;i<5;i++){\n    //    for(int j=0;j<=n;j++){\n    //        printf(\"%02d \",dp[i][j]);\n    //    }\n    //    cout << endl;\n    //}\n    cout << dp[N_odd][n] << endl;\n}\n\nint main(){\n    init();\n    int n;\n\n\n    while(cin>>n){\n        if(n==0) break;\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define print(a) cout<<a<<endl;\nint aaa[200] = {}, bbb[200] = {}, counta=1,countb=1, ansa, ansb = 0, xxx[1100000] = {}, yyy[1100000] = {};\n\nint foo(int n, int x){//cout<<n<<\" \"<<x<<\" \"<<xxx[x]<<endl;;\n\tint mi = 1000000;\n\tif(xxx[n]) return xxx[n]+x;\n\tif(x > 5) return mi;\n\tfor(int i = counta-1; i >= 1; i--){\n\t\tif(aaa[i] < n){\n\t\t\tmi = min(foo(n-aaa[i],x+1), mi);\n\t\t\tif(mi - n == 1)break;\n\t\t} else if(aaa[i] < n/2) break;\n\t}\n\t\n\txxx[n] = mi;\n\treturn mi;\n}\nint boo(int n, int x){//if(ansb){cout<<n<<\" B \"<<x<<\" \"<<yyy[n]<<endl;}\n\tint mi = 1000000;\n\tif(yyy[n]) return yyy[n]+x;\n\tfor(int i = countb-1; i >= 1; i--){\n\t\t//if(ansb)cout<<bbb[i]<<\" \"<<n<<endl;\n\t\tif(bbb[i] < n){\n\t\t\tmi = min(boo(n-bbb[i],x+1), mi);\n\t\t\tif(mi - n == 1)break;\n\t\t} else if(bbb[i] < n/2) break;\n\t}\n\t//if(ansb)cout<<\"aaaa \"<<n<<\" \"<<x<<\" \"<<mi<<endl;\n\tyyy[n] = mi;\n\treturn mi;\n}\n\nint main(){\n\tint i, n, abc;\n\tfor(i = 1; abc <= 1000000; i++){\n\t\tabc = (i*(i+1)*(i+2))/6;\n\t\txxx[abc] = 1;\n\t\tif(abc%2 == 1){\n\t\t\tyyy[abc] = 1;\n\t\t\tbbb[countb++] = abc;\n\t\t}\n\t\taaa[counta++] = abc;\n\t//\tcout<<counta<<\" \"<<i<<\" \"<<abc<<endl;;\n\t}\n//\tprint(1);\n\tfor(i = 1; i <= 1000000; i++){//cout<<i<<endl;\n\t\txxx[i] = foo(i, 0);//cout<<i<<endl;\n\t\tyyy[i] = boo(i, 0);//if(i == 966077) cout<<xxx[i]<<\" \"<<yyy[i]<<endl;\n\t}\t//cout<<\"b\"<<endl;\n\t/*for(int i = 1; i <= 1000000; i++){\n\t\t//cout<<i<<\" \"<<yyy[i]<<endl;\n\t//\tif(yyy[i+1]-yyy[i] > 1)cout<<yyy[i+1]<<\" \"<<yyy[i]<<\" \"<<i+1<<i<<endl;\n\t}*/\n//\tprint('a');//ansb = 1;\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tcout<<foo(n,0)<<\" \"<<boo(n,0)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <fstream>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n//Vector2D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec2D {\n    T x, y;\n\n    Vec2D() = default;\n\n    constexpr Vec2D(T x, T y)\n            : x{x}, y{y} {}\n\n    static constexpr T Dot(const Vec2D &lhs, const Vec2D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y;\n    }\n\n    static constexpr T Cross(const Vec2D &lhs, const Vec2D &rhs) {\n        return {lhs.x * rhs.y - lhs.y * rhs.x};\n    }\n\n    constexpr T dot(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec2D cross(const Vec2D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y;\n    }\n\n    Vec2D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec2D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0;\n    }\n\n    constexpr Vec2D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec2D operator-() const {\n        return {-x, -y};\n    }\n\n\n    constexpr Vec2D operator+(Vec2D rhs) const {\n        return {x + rhs.x, y + rhs.y};\n    }\n\n    constexpr Vec2D operator-(Vec2D rhs) const {\n        return {x - rhs.x, y - rhs.y};\n    }\n\n    template<class U>\n    constexpr Vec2D operator*(U rhs) const {\n        return {x * rhs, y * rhs};\n    }\n\n    template<class U>\n    constexpr Vec2D operator/(U rhs) const {\n        return {x / rhs, y / rhs};\n    }\n\n    constexpr Vec2D &operator+=(const Vec2D &other) {\n        x += other.x;\n        y += other.y;\n        return *this;\n    }\n\n    constexpr Vec2D &operator-=(const Vec2D &other) {\n        x -= other.x;\n        y -= other.y;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec2D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec2D<T> operator*(U s, Vec2D<T> v) {\n    return {s * v.x, s * v.y};\n}\n\n//Vector3D\n//--------------------------------------------\ntemplate<class T>\nstruct Vec3D {\n    T x, y, z;\n\n    Vec3D() = default;\n\n    constexpr Vec3D(T x, T y, T z)\n            : x{x}, y{y}, z{z} {}\n\n    constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0) {}\n\n    static constexpr T Dot(const Vec3D &lhs, const Vec3D &rhs) {\n        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n    }\n\n    static constexpr Vec3D Cross(const Vec3D &lhs, const Vec3D &rhs) {\n        return {\n                lhs.y * rhs.z - lhs.z * rhs.y,\n                lhs.z * rhs.x - lhs.x * rhs.z,\n                lhs.x * rhs.y - lhs.y * rhs.x\n        };\n    }\n\n    constexpr T dot(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    constexpr Vec3D cross(const Vec3D &rhs) const {\n        Dot(*this, rhs);\n    }\n\n    T magnitude() const {\n        return std::sqrt(sqrMagnitude());\n    }\n\n    constexpr T sqrMagnitude() const {\n        return x * x + y * y + z * z;\n    }\n\n    Vec3D normalized() const {\n        return *this / magnitude();\n    }\n\n    Vec3D normalize() {\n        *this = normalized();\n        return *this;\n    }\n\n    constexpr bool isZero() const {\n        return x == 0 && y == 0 && z == 0;\n    }\n\n    constexpr Vec3D operator+() const {\n        return *this;\n    }\n\n    constexpr Vec3D operator-() const {\n        return {-x, -y, -z};\n    }\n\n\n    constexpr Vec3D operator+(Vec3D rhs) const {\n        return {x + rhs.x, y + rhs.y, z + rhs.z};\n    }\n\n    constexpr Vec3D operator-(Vec3D rhs) const {\n        return {x - rhs.x, y - rhs.y, z - rhs.z};\n    }\n\n    template<class U>\n    constexpr Vec3D operator*(U rhs) const {\n        return {x * rhs, y * rhs, z * rhs};\n    }\n\n    template<class U>\n    constexpr Vec3D operator/(U rhs) const {\n        return {x / rhs, y / rhs, z / rhs};\n    }\n\n    constexpr Vec3D &operator+=(const Vec3D &other) {\n        x += other.x;\n        y += other.y;\n        z += other.z;\n        return *this;\n    }\n\n    constexpr Vec3D &operator-=(const Vec3D &other) {\n        x -= other.x;\n        y -= other.y;\n        z -= other.z;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator*=(U s) {\n        x *= s;\n        y *= s;\n        z *= s;\n        return *this;\n    }\n\n    template<class U>\n    constexpr Vec3D &operator/=(U s) {\n        x /= s;\n        y /= s;\n        z /= s;\n        return *this;\n    }\n\n};\n\ntemplate<class T, class U>\ninline constexpr Vec3D<T> operator*(U s, Vec3D<T> v) {\n    return {s * v.x, s * v.y, s * v.z};\n}\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n    set<LL> S;\n    for (LL i = 1; i < 200; i++) {\n        LL data = i * (i + 1) * (i + 2) / 6;\n        S.insert(data);\n    }\n\n    VI arr(S.size());\n    int _i = 0;\n    FOREACH(x, S) {\n        arr[_i] = x;\n        _i++;\n    }\n\n\n\n\n\n    VI dp(1000010);\n    VI dp2(1000010);\n    dp[0] = 0;\n    dp2[0] = 0;\n    for (int i = 1; i <= 1000008; i++) {\n        dp[i] = dp[i - 1] + 1;\n        REP(j, SZ(arr)) {\n            if (arr[j] <= i) {\n                dp[i] = min(dp[i], dp[i - arr[j]] + 1);\n            } else {\n                break;\n            }\n        }\n    }\n    for (int i = 1; i <= 1000008; i++) {\n        dp2[i] = dp2[i - 1] + 1;\n        REP(j, SZ(arr)) {\n            if (arr[j] <= i) {\n                if (arr[j] % 2 == 1) {\n                    dp2[i] = min(dp2[i], dp2[i - arr[j]] + 1);\n                } else {\n                    continue;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n\n    int N;\n    while (true) {\n\n\n        cin >> N;\n\n        if (N == 0) break;\n\n        cout << dp[N] << \" \" << dp2[N] << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint INF = (1LL << 30) - 1;\nint MOD = 1e9+7;\nvector<int> V,W;\nint MAX_NUM = 1000000;\nvector<int> table(MAX_NUM);\nP dp(int N){\n    P ans;\n    table.assign(N+1,INF);\n    table[0] = 0;\n    rep(i,0,V.size()){\n        rep(j,0,N+1){\n            if(j + V[i] > N)break;\n            table[j + V[i]] = min(table[j + V[i]], table[j] + 1);\n        }\n    }\n    ans.first = table[N]; \n    table.assign(N+1,INF);\n    table[0] = 0;\n    rep(i,0,W.size()){\n        rep(j,0,N+1){\n            if(j - W[i] >= 0)table[j] = min(table[j], table[j - W[i]] + 1);\n        }\n    }\n    ans.second = table[N];\n    return ans;\n}\nmain(){\n    for(int i = 1;i * (i + 1) * (i + 2) / 6 <= MAX_NUM;i++){\n        int num = i * (i + 1) * (i + 2) / 6; \n        V.push_back(num);\n        if(i % 4 == 1)W.push_back(num);\n    }\n\n    int N;\n    cin >> N;\n    while(N){\n        auto ans = dp(N);\n        cout << ans.first << \" \" << ans.second << endl;\n        cin >> N;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main(){\n  int lim = 1e6;\n  vector<int> cube;\n  for(int i=1;;i++){\n    int c = i*(i+1)*(i+2)/6;\n    if(c>lim)break;\n    cube.push_back(c);\n  }\n\n  vector<int> dp1(lim+1,INF), dp2(lim+1,INF);\n  dp1[0] = dp2[0] = 0;\n\n  for(int i=1;i<=lim;i++){\n    for(int c : cube){\n      if(i+c<=lim){\n\tdp1[i+c] = min(dp1[i+c], dp1[i]+1);\n\tif(c%2==0){\n\t  dp2[i+c] = min(dp2[i+c], dp2[i]+1);\n\t}\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n){\n    if(n==0)break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n/*\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int Max = 1000000;\n\nvoid update(vector<int> &v,int x){\n  for(int i=x; i<Max; ++i){\n    v[i] =min(v[i-x]+1,v[i]);\n  }\n}\n \nint main(){\n  vector<int> a(Max,Max);\n  vector<int> o(Max,Max);\n\n  a[0]=0;\n  o[0]=0;\n  for(int i=0;;++i){\n    int tmp = i*(i+1)*(i+2)/6;\n    if(tmp>Max)break;\n    update(a,tmp);\n    if(tmp&1)update(o,tmp);\n  }\n  int n;\n  while(cin >> n,n){\n    cout << a[n] << \" \" << o[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\n\n#define arrsize 500000\n\nll memo[arrsize];\nll memo2[arrsize];\n\nll calc(int n) {\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint dfs(int depth, int n) {\n  int ans = 9999;\n  if (n < arrsize && memo[n] != 0) return memo[n];\n  for (int i = sqrt(n); i >= 1; i--) {\n    \n    ll t = calc(i);\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < arrsize) {\n\tmemo[n] = depth;\n      }\n      return depth;\n    }\n    ans = min(ans, dfs(depth + 1, n - t));\n  }\n  if (n < arrsize)\n    memo[n] = ans;\n  return ans;\n}\n\nint dfs_odd(int depth, int n) {\n  int ans = 9999;\n  if (n < arrsize && memo2[n] != 0) return memo2[n];\n  for (int i = sqrt(n); i >= 1; i--) {\n    ll t = calc(i);\n    if (t % 2 == 0) continue;\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < arrsize)\n\tmemo2[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs_odd(depth + 1, n - t));\n  }\n  if (n < arrsize)\n    memo2[n] = ans;\n  return ans;\n}\n  \nint main() {\n  int N;\n  while (cin >> N, N != 0) {\n    for (int i = 0; i < arrsize; i++) {\n      memo[i] = 0;\n      memo2[i] = 0;\n   }\n    cout << dfs(1, N) << \" \" << dfs_odd(1, N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n\nint main(void){\n\tint i, j, n, min1,small;\n\tint dp[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tsmall = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dp[i] < small){\n\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(small > dp[n])\n\t\t\t\tsmall = dp[n];\n\t\t}\n\n\t\tmin1 = dp[n];\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tsmall = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dp[i] < small){\n\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(small > dp[n])\n\t\t\t\tsmall = dp[n];\n\t\t}\n\t\tprintf(\"%d %d\\n\",min1,dp[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nint dp[1000001];\nint x;\n\nint four(int n) {\n  return n * (n+1) * (n+2) / 6;\n}\n\nint calc(int n, int sum) {\n  //cout << n << \" \" << sum << endl;\n  if ( dp[sum] ) return dp[sum];\n  if ( sum == x ) return 0;\n  if ( sum > x || n > 200 ) return INF;\n\n  int ret = INF;\n  if ( sum+four(n) <= x ) {\n    ret = min(ret, calc(n, sum+four(n)) + 1);\n    ret = min(ret, calc(n+1, sum+four(n)) + 1);\n  }\n  ret = min(ret, calc(n+1, sum));\n\n  return dp[sum] = ret;\n}\n\nint calc_odd(int n, int sum) {\n  //cout << n << \" \" << sum << endl;\n  if ( dp[sum] ) return dp[sum];\n  if ( sum == x ) return 0;\n  if ( sum > x || n > 200 ) return INF;\n\n  int ret = INF;\n  if ( sum+four(n) <= x ) {\n    ret = min(ret, calc_odd(n, sum+four(n)) + 1);\n    ret = min(ret, calc_odd(n+4, sum+four(n)) + 1);\n  }\n  ret = min(ret, calc_odd(n+4, sum));\n\n  return dp[sum] = ret;\n}\n\nsigned main() {\n  while ( cin >> x, x ) {\n    memset(dp, 0, sizeof(dp));\n    cout << calc(1, 0) << \" \";\n    memset(dp, 0, sizeof(dp));\n    cout << calc_odd(1, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\tint tri[200];\n\tstatic int ansA[1000000], ansB[1000000];\n\tfor(int i=0;i<200;i++) tri[i] = i*(i+1)*(i+2)/6;\n\tansA[0] = ansB[0] = 0;\n\tfor(int i=1;i<1000000;i++){\n\t\tansA[i] = ansB[i] = i;\n\t\tfor(int j=0;i-tri[j]>=0;j++){\n\t\t\tansA[i] = min(ansA[i], ansA[i-tri[j]]+1);\n\t\t\tif(tri[j]%2==1)\n\t\t\t\tansB[i] = min(ansB[i], ansB[i-tri[j]]+1);\n\t\t}\n\t}\n\twhile(cin >> N, N)\n\t\tcout << ansA[N] << \" \" << ansB[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint p[200],q[50];\n\nint f(int n,int m,int c){\n\tif(c==4&&n>0)return 5;\n\tif(n<10)return min(c+n/4+n%4,5);\n\tint rec=5,i=0;\n\twhile(p[i]<n/(4-c))i++;\n\tfor(i;p[i]<=m;i++)rec=min(rec,f(n-p[i],min(p[i],n-p[i]),c+1));\n\treturn rec;\n}\n\nint g(int n,int m,int c){\n\tif(n<165)return c+n/35+n%35;\n\tint rec=99999;\n\tfor(int i=1;p[i]<=m;i++)rec=min(rec,f(n-p[i],min(p[i],n-p[i]),c+1));\n\treturn rec;\n}\n\nint main(){\n\tfor(int i=0;(i+1)*(i+2)*(i+3)/6<=1000000;i++)p[i]=(i+1)*(i+2)*(i+3)/6;\n\tfor(int i=0;(4*i+1)*(4*i+2)*(4*i+3)/6<=1000000;i++)q[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\tint N;\n\twhile(cin>>N){\n\t\tcout<<f(N,N,0)<<\" \"<<g(N,N,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for(int i = (int)(n - 1); i >= 0; --i)\n#define RFOR(i, a, b) for(int i = (int)(b - 1); i >= (int)(a); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef vector<vll> vvll;\n\nconst int INF = (int)1e9;\n\nint main() {\n  vi pollock;\n  for(int i = 0, v; ( v = i * (i + 1) * (i + 2) / 6) <= 1000000; i++) {\n    pollock.push_back(v);\n  }\n\n  vi dpall(1000001, INF);\n  vi dpodd(1000001, INF);\n  dpall[0] = dpodd[0] = 0;\n  for (auto m : pollock) {\n    for(int i = 0; i + m < dpall.size(); i++) {\n      dpall[i + m] = min(dpall[i + m], dpall[i] + 1);\n    }\n    if (m % 2 == 1) {\n      for(int i = 0; i + m < dpodd.size(); i++) {\n        dpodd[i + m] = min(dpodd[i + m], dpodd[i] + 1);\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    printf(\"%d %d\\n\", dpall[n], dpodd[n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 1000001\n\nint main(void){\n\tint i, j, n ,c, small1, small2;\n\tint dp1[1000000],dp2[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp1[i] = dp2[i] = INF;\n\t\tdp1[0] = dp2[0] = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tsmall1 = dp1[n]; small2 = dp2[n];\n\t\t\tif(small1 > dp1[i] && dp1[i] != INF ||small2 > dp2[i] && dp2[i] != INF){\n\t\t\t\tfor(j = 1,c = j * (j + 1) * (j + 2);c / 6 + i <= n;j++,c = j * (j + 1) * (j + 2)){\n\t\t\t\t\tif(dp1[c / 6 + i] > dp1[i] + 1 && dp1[i] != INF)\n\t\t\t\t\t\tdp1[c / 6 + i] = dp1[i] + 1;\n\t\t\t\t\tif(dp2[c / 6 + i] > dp2[i] + 1 && (c / 6) % 2 == 1 && dp2[i] != INF)\n\t\t\t\t\t\tdp2[c / 6 + i] = dp2[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\nstatic const int INF = (int)1e8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) for (int i=0; i<(int)(n); ++i)\n#define FOREQ(i,k,n) for (int i=(k); i<=(int)(n); ++i)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FIND(m,w) ((m).find(w)!=(m).end())\nint MAX_N = 1000001;\nint main(void){\n  int dp[MAX_N];\n  int dp2[MAX_N];\n  vector<int> four;\n  REP(i,MAX_N) dp[i] = INF;\n  REP(i,MAX_N) dp2[i] = INF;\n  dp[0] = 0;\n  dp2[0] = 0;\n  for(int i=1; i*(i+1)*(i+2)/6<=MAX_N; i++){\n    four.push_back(i*(i+1)*(i+2)/6);\n  }\n  REP(i,four.size())FOR(j,four[i],MAX_N){\n    dp[j] = min(dp[j],dp[j-four[i]]+1);\n    if(four[i]%2) dp2[j] = min(dp2[j],dp2[j-four[i]]+1);\n  }\n  int N;\n  while(cin>>N,N)cout<<dp[N]<<\" \"<<dp2[N]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  const int N = 1000000;\n  int dp[2][N+1],n;\n\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      dp[0][nxt] = min(dp[0][nxt],dp[0][j] + 1);\n      if(val&1)dp[1][nxt] = min(dp[1][nxt],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1000000\n\nint main() {\n\tint dp[N] = {0}, dp_odd[N] = {0};\n\n\tfor(int i = 1; i < N; i++)\n\t\tdp[i] = dp_odd[i] = N;\n\n\tfor(int i = 1; i < N; i++) {\n\t\tint t = i*(i+1)*(i+2)/6;\n\t\tif(t > N) break;\n\t\tfor(int j = t; j < N; j++) dp[j] = min(dp[j], dp[j-t]+1);\n\t\tif(t%2 == 1) for(int j = t; j < N; j++) dp_odd[j] = min(dp_odd[j], dp_odd[j-t]+1);\n\t}\n\n\tint n;\n\twhile(cin >> n && n) {\n\t\tcout << dp[n] << \" \" << dp_odd[n] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MAX=1e6+10;\nusing namespace std;\nint main(){\n    vector<int>precal;\n    vector<int>dp(MAX,MAX);\n    vector<bool>flag(MAX,false);\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=upper_bound(precal.begin(),precal.end(),i)-precal.begin();\n        for(int j=0; j<=index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX,MAX);\n    vector<bool>oddflag(MAX,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin();\n        for(int j=0;j<=index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <climits>\nusing namespace std;\n\n#define MAX 1000000\nusing ll = long long;\n\nint main(){\n    vector<ll> v;\n    vector<ll> odd_v;\n\n    for(ll i = 1; i <= MAX; ++i){\n        ll num = i * (i + 1) * (i + 2) / 6;\n        v.push_back(num);\n        if(num & 1) odd_v.push_back(num);\n    }\n\n    while(true){\n        int n; cin >> n;\n        if(!n) break;\n\n        vector<int> dp(n+1, INT_MAX);\n        vector<int> odd_dp(n+1, INT_MAX);\n        dp[0] = 0;\n        odd_dp[0] = 0;\n\n        for(int i = 0; i <= n; ++i){\n            for(int j = 0; j < v.size(); ++j){\n                if(n < v[j]) break;\n                if(i - v[j] >= 0){\n                    dp[i] = min(dp[i - v[j]] + 1, dp[i]);\n                }\n            }\n\n            for(int j = 0; j < odd_v.size(); ++j){\n                if(n < odd_v[j]) break;\n                if(i - odd_v[j] >= 0){\n                    odd_dp[i] = min(odd_dp[i - odd_v[j]] + 1, odd_dp[i]);\n                }\n            }\n        }\n        cout << dp[n] << ' ' << odd_dp[n] << endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX = 1e6+5;\nint dp1[MAX];\nint dp2[MAX];\n\nvoid init(int n){\n    int INF = 1e9;\n    for(int j=0;j<=n;j++){\n        dp1[j] = INF;\n        dp2[j] = INF;\n    }\n    dp1[0] = 0;\n    dp2[0] = 0;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    vector<int> a;\n    vector<int> b;\n    for(int i=1;i<100000;i++){\n        int ret = i*(i+1)*(i+2)/6;\n        if(ret > 1e6) break;\n        a.push_back(ret);\n        if(ret %2 == 1) b.push_back(ret);\n\n    }\n    init(1e6);\n    for(int i=0;i<180;i++){\n        if(a[i] > 1e6) break;\n        for(int j=0;j<=1e6;j++){\n            int p = j+a[i];\n            if(p > 1e6) break;\n            dp1[p] = min(dp1[p], dp1[j]+1);\n        }\n    }\n    for(int i=0;i<b.size();i++){\n        if(b[i] > 1e6) break;\n        for(int j=0;j<=1e6;j++){\n            int p = j+b[i];\n            if(p > 1e6) break;\n            dp2[p] = min(dp2[p], dp2[j]+1);\n        }\n    }\n\n\n\n\n\n    int n;\n    while(cin>>n){\n        if(n==0) break;\n        cout << dp1[n] << \" \";\n        cout << dp2[n] << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\nsigned main(){\n    vector<int> s3;\n    rep(i, 1e6){\n        if(i == 0){\n            s3.push_back(0);\n            continue;\n        }\n        s3.push_back(s3[i-1] + i);\n        if(s3[i] >= 1e6){\n            break;\n        }\n    }\n\n\n    vector<int> s4;\n    for(int i = 0; s3[i] < 1e6; i++){\n        if(i == 0){\n            s4.push_back(0);\n            continue;\n        }\n        s4.push_back(s4[i-1] + s3[i]);\n        if(s4[i] > 1e6){\n            break;\n        }\n    }\n\n    int n = (int)s4.size();\n    vector<int> dp1(1e6, INF);\n    dp1[0] = 0;\n    for(int i = 1; i < n; i++){\n        rep(j, 1e6){\n            if(j + s4[i] >= 1e6 || dp1[j] == INF){\n                continue;\n            }\n            dp1[j + s4[i]] = min(dp1[j + s4[i]], dp1[j] + 1);\n        }\n    }\n\n    vector<int> dp2(1e6, INF);\n    dp2[0] = 0;\n    for(int i = 1; i < n; i++){\n        if(s4[i] % 2 == 0){\n            continue;\n        }\n        rep(j, 1e6){\n            if(j + s4[i] >= 1e6 || dp2[j] == INF){\n                continue;\n            }\n            dp2[j + s4[i]] = min(dp2[j + s4[i]], dp2[j] + 1);\n        }\n    }\n\n    while(true){\n        int x;\n        cin >> x;\n\n        if(x == 0){\n            break;\n        }\n        cout << dp1[x] << \" \" << dp2[x] << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<iostream>\n#include<iomanip>\n#include<set>\n#include<string>\n#include<math.h>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, ll> P;\n\n//--------------\n///#define DEBUG\n//--------------\n\n#ifdef DEBUG\n\t#define debugprint(x) cout<<x<<\" \"\n\t#define debugendl cout<<endl\n\t#define debug(x) x\n#else\n\t#define debugprint(x)\n\t#define debugendl\n\t#define debug(x)\n#endif\n\nclass zahyo{\n\tpublic:\n\tint x;\n\tint y;\n\tzahyo(){\n\t\tx=0;\n\t\ty=0;\n\t}\n\tzahyo(int x_,int y_){\n\t\tx=x_;\n\t\ty=y_;\n\t}\n\tvoid print(){\n\t\tcout<<x<<\" \"<<y;\n\t}\n\tzahyo operator+(zahyo add){\n\t\tadd.x=this->x+add.x;\n\t\tadd.y=this->y+add.y;\n\t\treturn add;\n\t}\n\tzahyo operator-(zahyo add){\n\t\tadd.x=this->x-add.x;\n\t\tadd.y=this->y-add.y;\n\t\treturn add;\n\t}\n\tzahyo operator*(int t){\n\t\tzahyo temp;\n\t\ttemp.x=this->x*t;\n\t\ttemp.y=this->y*t;\n\t\treturn temp;\n\t}\n\tzahyo operator%(int t){\n\t\tzahyo temp(this->x%t,this->y%t);\n\t\treturn temp;\n\t}\n\tzahyo operator/(int t){\n\t\tzahyo temp(this->x/t,this->y/t);\n\t\treturn temp;\n\t}\n\tbool operator==(const zahyo add) const{\n\t\tif(add.x==this->x and add.y==this->y){return true;}\n\t\telse{return false;}\n\t}\n\tbool operator!=(const zahyo add) const{\n\t\tif(add.x==this->x or add.y==this->y){return false;}\n\t\telse{return true;}\n\t}\n\tbool operator<(const zahyo add) const{\n\t\tif(this->x<add.x){return true;}\n\t\telse if(this->x==add.x and this->y<add.y){return true;}\n\t\telse{return false;}\n\t}\n\tbool operator>(const zahyo add) const{\n\t\tif(this->x>add.x){return true;}\n\t\telse if(this->x==add.x and this->y>add.y){return true;}\n\t\telse{return false;}\n\t}\n\tvoid input(){\n\t\tcin>>x>>y;\n\t}\n};\n\nbool IsInBoard(int x,int maxx, int y,int maxy){\n\tif(x>=0 and x<maxx and y>=0 and y<maxy){\n\t\treturn true;\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nint dpall[1000001];\nint dpodd[1000001];\n\nint sqnum(int n){\n\treturn (n*(n+1)*(n+2))/6;\n}\n\nint main(){\n\tint n;\n\tdpall[0]=0;dpodd[0]=0;\n\tfor(int i=1;i<1000000;i++){\n\t\tdpall[i]=i;\n\t\tdpodd[i]=i;\n\t}\n\tfor(int i=1;i<=1000000;i++){\n\t\tfor(int j=1;j<200;j++){\n\t\t\tif(sqnum(j)>i){break;}\n\t\t\telse{\n\t\t\t\tdpall[i]=min(dpall[i],dpall[i-sqnum(j)]+1);\n\t\t\t\tif(sqnum(j)%2==1){\n\t\t\t\t\tdpodd[i]=min(dpodd[i],dpodd[i-sqnum(j)]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0){break;}\n\t\tcout<<dpall[n]<<\" \"<<dpodd[n]<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst int SIZE = 300;\nconst int N = 1000000;\nint p[SIZE+1];\nint dp1[N+1], dp2[N+1];\n\nvoid make_pollock (void )\n{\n\tfor (int i = 0; i <= SIZE; i++ ){\n\t\tll ans = (ll)i*(i+1LL)*(i+2LL)/6LL;\n\t\tp[i] = (int)ans;\n\t} // end for\n}\n\nvoid make_dp (void )\n{\n\tdp1[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ ){\n\t\t\tif (dp1[j] > dp1[j - m] + 1 ){\n\t\t\t\tdp1[j] = dp1[j - m] + 1;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tif (p[i] % 2 == 0 ) continue;\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ ){\n\t\t\tif (dp2[j] > dp2[j - m] + 1 ){\n\t\t\t\tdp2[j] = dp2[j - m] + 1;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end for\t\n}\n\t\nint main()\n{\n\tmemset (p, 0, sizeof (p ) );\n\tfill (dp1, dp1+N+1, INF );\n\tfill (dp2, dp2+N+1, INF );\n\n\tmake_pollock();\n\tmake_dp ();\n\n\tint n;\n\twhile (cin >> n && n ){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef long long ll;\n\nint simen[201];\n\nint dp1[2][1000001];\nint dp2[2][1000001];\n\nint main()\n{\n\tfor(int i=1;i<201;i++)\n\t{\n\t\tsimen[i]=i*(i+1)*(i+2)/6;\n\n\t}\n\tfill(dp1[0],dp1[1],1e8-1);\n\tdp1[0][0]=0;\n\tfor(int i=1;i<201;i++)\n\t{\n\t\tfor(int j=0;j<1000001;j++)\n\t\t{\n\t\t\tif(j<simen[i])\n\t\t\t\tdp1[i&1][j]=dp1[(i-1)&1][j];\n\t\t\telse\n\t\t\t\tdp1[i&1][j]=min(dp1[i&1][j-simen[i]]+1,dp1[(i-1)&1][j]);\n\t\t}\n\t}\n\tfill(dp2[0],dp2[1],1e8-1);\n\tdp2[0][0]=0;\n\tfor(int i=1;i<201;i++)\n\t{\n\t\tfor(int j=0;j<1000001;j++)\n\t\t{\n\t\t\tif(simen[i]%2==0 || j<simen[i])\n\t\t\t\tdp2[i&1][j]=dp2[(i-1)&1][j];\n\t\t\telse\n\t\t\t\tdp2[i&1][j]=min(dp2[i&1][j-simen[i]]+1,dp2[(i-1)&1][j]);\n\t\t}\n\t}\n\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcout<<dp1[0][n]<<\" \"<<dp2[0][n]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX], dp2[MAX];\n\nint main()\n{\n    for (int i = 1; i <= MAX; i++)\n    {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    for (int n = 1; n * (n + 1) * (n + 2) / 6 <= MAX; n++)\n    {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp1[i] = min(dp1[i], dp1[i - a]);\n        }\n        if (a % 2 == 0)\n            continue;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp2[i] = min(dp2[i], dp2[i - a]);\n        }\n    }\n    while (1)\n    {\n        cin >> n;\n        if (n == 0)\n            break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> T, T_odd, A(M,INF), odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  odd[0] = 0;\n  T.push_back(1);\n  T_odd.push_back(1);\n  while(t < 1000000){\n    T.push_back(t);\n    if (t%2) T_odd.push_back(t);\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  odd.push_back(M);\n  for(int i = 0; i < T.size(); ++i){\n    for(int j = 1; j <= 5; ++j){\n      for(int k = 0; k < T[i] && k+T[i]*j < M; ++k){\n\tA[k+T[i]*j] = min(A[k+T[i]*j],A[k]+j);\n      }\n    }\n  }\n  for(int i = 0; i < T_odd.size()-1; ++i){\n    for(int j = 1; j < 10; ++j){\n      for(int k = 0; k+T_odd[i]*j < M; ++k){\n\todd[k+T_odd[i]*j] = min(odd[k+T_odd[i]*j],odd[k]+j);\n      }\n    }\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* C ????§????: ?????? */\n#include<bits/stdc++.h>\n#define dump(a) cout << (#a) << (a) << endl\nusing namespace std;\n\n#define MAX_SIZE 2000002\n\n//pollok\nint memo_cnt[MAX_SIZE]; //MAX_SIZE??????\nvector<int> all_pks;\nvector<int> kisu_pks;\n\n//P=pk??????, index=pks????????¨?????´???\nint dfs(const int P, vector<int> &pks)\n{\n\t//dump(level);\n\tif (P == 0) { return 0; }\n\tif (memo_cnt[P] != -1) { return memo_cnt[P]; } //?????¢????????\\\n\t\n\tint min_depth = INT_MAX;\n\t//100??????\n\tfor(int i=0; i<pks.size(); i++) { //??§?????????\n\t\tint next_P = P-pks[i];\n\t\tif (next_P >= 0) {\n\t\t\tint depth = dfs(next_P, pks) + 1; //????????°???????????????\n\t\t\tmin_depth = min(min_depth,depth); //????°????????????°\n\t\t}\n\t\t//?????????????????´???????¬?\n\t}\n\t//???????????¢???\n\tmemo_cnt[P] = min_depth;\n\t\n\treturn min_depth;\n}\n\nint main() {\n\tint n=1;\n\twhile(true) {\n\t\tint pk = n * (n+1) * (n+2) / 6;\n\t\tif (pk >= MAX_SIZE){ break; }\n\n\t\tall_pks.push_back(pk);\n\t\tif (pk % 2 != 0) { kisu_pks.push_back(pk); }\n\t\tn++;\n\t}\n\treverse(begin(all_pks),end(all_pks));\n\treverse(begin(kisu_pks),end(kisu_pks));\n\n\tint P;\n\twhile(cin >> P) {\n\t\tif (P == 0) { break; }\n\n\t\tint index=0; //\n\t\tint left=0,right=0;\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tleft = dfs(P, all_pks);\n\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tright = dfs(P, kisu_pks);\n\t\tcout << left << \" \" << right << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nvector<int> list;\nvector<int> kisu;\n\nint dp1[1001000];\nint dp2[1001000];\n\nint main() {\n\tint i;\n\tfor(i=1;;i++){\n\t\tint yon=i*(i+1)*(i+2)/6;\n\t\tif(yon>1000000)break;\n\t\tlist.push_back(yon);\n\t\tif(yon%2==1)kisu.push_back(yon);\n\t}\n\tfor(i=0;i<1001000;i++){\n\t\tdp1[i]=dp2[i]=i;\n\t}\n\tfor(i=0;i<1001000;i++){\n\t\tint j;\n\t\tfor(j=0;j<list.size();j++){\n\t\t\tif(i-list[j]<0)break;\n\t\t\tchmin(dp1[i],dp1[i-list[j]]+1);\n\t\t}\n\t\tfor(j=0;j<kisu.size();j++){\n\t\t\tif(i-kisu[j]<0)break;\n\t\t\tchmin(dp2[i],dp2[i-kisu[j]]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(n=in()){\n\t\tcout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int SIZE = 200;\nconst int N = 1000002;\nint p[SIZE+1];\nint dp1[N], dp2[N];\n\nvoid make_pollock (void )\n{\n\tmemset (p, 0, sizeof (p ) );\n\n\tfor (int i = 0; i <= SIZE; i++ )\n\t\tp[i] = i*(i+1)*(i+2)/6;\n}\n\nvoid make_dp (void )\n{\n\tfill (dp1, dp1+N, INF );\n\tfill (dp2, dp2+N, INF );\n\n\tdp1[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tif (dp1[j] > dp1[j - m] + 1 )\n\t\t\t\tdp1[j] = dp1[j - m] + 1;\n\t} // end for\n\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tif (p[i] % 2 == 0 ) continue;\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tif (dp2[j] > dp2[j - m] + 1 )\n\t\t\t\tdp2[j] = dp2[j - m] + 1;\n\t} // end for\t\n}\n\t\nint main()\n{\n\tmake_pollock();\n\tmake_dp ();\n\n\tint n;\n\twhile (cin >> n && n )\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nll f(ll n) {\n    return n * (n+1) * (n+2) / 6;\n}\nvector<ll> make_dp(const vector<ll>& v, ll n) {\n    vector<ll> dp(n+1, linf);\n    dp[0] = 0;\n    rep(i, v.size()) rep(j, n+1) {\n        ll nj = j + v[i];\n        if (nj <= n) chmin(dp[nj], dp[j]+1);\n    }\n    return dp;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    vector<ll> v1, v2;\n    for (ll i = 1; f(i) <= ll(1e6); ++i) {\n        v1.pb(f(i));\n        if (f(i) % 2 == 1) v2.pb(f(i));\n    }\n    vector<ll> dp1 = make_dp(v1, ll(1e6));\n    vector<ll> dp2 = make_dp(v2, ll(1e6));\n    while (cin >> n, n) {\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n\nint main(void){\n\tint i, j, k, n, min1;\n\tint dp[1000001];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tfor(k = 0;k < n;k++){\n\t\t\tfor(i = n;i >= 0;i--){\n\t\t\t\tif(dp[i] != INF){\n\t\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n\t\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[n] == 1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmin1 = dp[n];\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tfor(k = 0;k < n;k++){\n\t\t\tfor(i = n;i >= 0;i--){\n\t\t\t\tif(dp[i] != INF){\n\t\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n\t\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[n] == 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d %d\\n\",min1,dp[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\nusing namespace std;\n\nint count_block(int n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint main()\n{\n  int block_num = 0;\n  int cnt = 1;\n  vector<int> block_nums;\n  while (true)\n  {\n    block_num = count_block(cnt);\n    if (block_num > 1000000)\n    {\n      break;\n    }\n    block_nums.push_back(block_num);\n    cnt += 1;\n  }\n  int size_block_nums = block_nums.size();\n  vector<int> dp(1000000 + 1, INF);\n  vector<int> odd_dp(1000000 + 1, INF);\n  dp.at(0) = 0;\n  odd_dp.at(0) = 0;\n  for (int i = 0; i < 1000000; ++i)\n  {\n    for (int j = 0; j < size_block_nums; ++j)\n    {\n      int next_num = i + block_nums.at(j);\n      if (next_num > 1000000)\n      {\n        break;\n      }\n      int temp = dp.at(i) + 1;\n      if (dp.at(i + block_nums.at(j)) > temp)\n      {\n        dp.at(i + block_nums.at(j)) = temp;\n      }\n      if (block_nums.at(j) % 2 == 1)\n      {\n        temp = odd_dp.at(i) + 1;\n        if (odd_dp.at(i + block_nums.at(j)) > temp)\n        {\n          odd_dp.at(i + block_nums.at(j)) = temp;\n        }\n      }\n    }\n  }\n  while (true)\n  {\n    int n;\n    cin >> n;\n    if (n == 0)\n    {\n      break;\n    }\n    // for (int i = 0; i < block_nums.size(); ++i)\n    // {\n      //   cout << block_nums.at(i) << endl;\n      // }\n    cout << dp.at(n) << ' ' << odd_dp.at(n) << endl;\n\n    // for (int i = 0; i < n + 1; ++i)\n    // {\n    //   dp.at(i) = INF;\n    // }\n    // dp.at(0) = 0;\n    // for (int i = 0; i < n; ++i)\n    // {\n    //   for (int j = 0; j < size_block_nums; ++j)\n    //   {\n    //     if (block_nums.at(j) % 2 == 0)\n    //     {\n    //       // cout << block_nums.at(j) << endl;\n    //       continue;\n    //     }\n    //     int next_num = i + block_nums.at(j);\n    //     if (next_num > n)\n    //     {\n    //       break;\n    //     }\n    //     int temp = dp.at(i) + 1;\n    //     if (dp.at(i + block_nums.at(j)) > temp)\n    //     {\n    //       dp.at(i + block_nums.at(j)) = temp;\n    //     }\n    //   }\n    // }\n    // // for (int i = 0; i < n + 1; ++i)\n    // // {\n    // //   cout << dp.at(i) << endl;\n    // // }\n    // cout << dp.at(n) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main() {\n    for(int i = 1;i <= MAX;i++) {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n + 2) / 6 <= MAX;n++) {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for(int i = a;i <= MAX;i++) {\n            dp1[i] = min(dp1[i],dp1[i - a] + 1);\n        }\n        if(a % 2 == 0)continue;\n        for(int i = a;i <= MAX;i++) {\n            dp2[i] = min(dp2[i],dp2[i - a] + 1);\n        }\n    }\n\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint ele[1000001];\nint dp1[1000001];\nint dp2[1000001];\n\nint main() {\n  rep(i, 181) ele[i] = (i + 1) * (i + 2) * (i + 3) / 6;\n  vector<int> nn;\n  while (1) {\n    int n;\n    cin >> n;\n    if (n < 1) break;\n    nn.push_back(n);\n  }\n  memset(dp1, 1, sizeof(dp1));\n  memset(dp2, 1, sizeof(dp2));\n\n  dp1[0] = 0;\n  dp2[0] = 0;\n  rep(i, 1000001) rep(j, 180) {\n    if (i + ele[j] > 1000001) break;\n    dp1[i + ele[j]] = min(dp1[i + ele[j]], dp1[i] + 1);\n    if (ele[j] % 2 == 1) dp2[i + ele[j]] = min(dp2[i + ele[j]], dp2[i] + 1);\n  }\n\n  for (int n : nn) {\n    printf(\"%d %d\\n\", dp1[n], dp2[n]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 1e6 + 10;\nconst int INF = 1e9;\n\nint dp[2][MAX];\n\nvoid solve(){\n  vector<int> tetra;\n  int v = 1, cnt = 2;\n  while(v < MAX){\n    tetra.push_back(v);\n    v = cnt * (cnt+1) * (cnt+2) / 6;\n    cnt++;\n  }\n  for(int i = 0 ; i < MAX ; i++) dp[0][i] = dp[1][i] = INF;\n  \n  dp[0][0] = dp[1][0] = 0;\n  for(int v = 0 ; v <= MAX ; v++){  \n    for(int i = 0 ; i < (int)tetra.size() ; i++){\n      if(v + tetra[i] > MAX) continue;\n      dp[0][v + tetra[i]] = min(dp[0][v+tetra[i]], dp[0][v] + 1);\n      if(tetra[i] % 2) dp[1][v + tetra[i]] = min(dp[1][v+tetra[i]], dp[1][v] + 1);\n    }\n  }\n}\n\nint main(){\n  solve();\n  int N;\n  while(cin >> N, N) cout << dp[0][N] << ' ' << dp[1][N] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\nint dp[200][1000010], adp[200][1000010];\nint INF = 1e9;\n\nvoid solve() {\n\tfor (int i=0; i<200; i++) {\n\t\tfill(dp[i], dp[i]+1000010, INF);\n\t\tfill(adp[i], adp[i]+1000010, INF);\n\t}\n\t\n\tdp[0][0] = 0;\n\tadp[0][0] = 0;\n\tfor (int i=0; i<200; i++) {\n\t\tint add = i * (i+1) * (i+2) / 6;\n\t\tif (add > n) break;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (add <= j) {\n\t\t\t\tdp[i+1][j] = min(dp[i][j], dp[i + 1][j-add] + 1);\n\t\t\t} else {\n\t\t\t\tdp[i+1][j] = dp[i][j];\n\t\t\t}\n\t\t\t\n\t\t\tif (add%2==0) {\n\t\t\t\tadp[i+1][j] = adp[i][j];\n\t\t\t} else {\n\t\t\t\tif (add <= j) {\n\t\t\t\t\tadp[i + 1][j] = min(adp[i][j], adp[i + 1][j-add] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tadp[i + 1][j] = adp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans1 = INF, ans2 = INF;\n\tfor (int i=0; i<200; i++) {\n\t\tans1 = min(ans1, dp[i][n]);\n\t\tans2 = min(ans2, adp[i][n]);\n\t}\n\tcout << ans1 << \" \" << ans2 << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n\nusing namespace std;\n\n#define LIM 1000001\n\nlong int n, tet[501] = {0}, dp[LIM] = {0}, dp_odd[LIM] = {0};\n\nvoid solve()\n{\n\tfor(int j = 0; j < LIM; j++)\n\t{\n\t\tfor(int i = 1; j+tet[i] < LIM; i++)\n\t\t{\n\t\t\tif( dp[j+tet[i]] > dp[j] + 1 )\n\t\t\t\tdp[j+tet[i]] = dp[j] + 1;\n\t\t}\n\t}\n\n\tfor(int j = 0; j < LIM; j++)\n\t{\n\t\tfor(int i = 1; j+tet[i] < LIM; i++)\n\t\t{\n\t\t\tif( dp_odd[j+tet[i]] > dp_odd[j] + 1 && tet[i] % 2 == 1)\n\t\t\t\tdp_odd[j+tet[i]] = dp_odd[j] + 1;\n\t\t}\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\tfor( int i = 1; i < 501; i++)\n\t\ttet[i] = i*(i+1)*(i+2)/6;\n\n\tfor( int i = 1; i < LIM; i++)\n\t{\n\t\tdp[i] = INT_MAX;\n\t\tdp_odd[i] = INT_MAX;\n\t}\n\n\tsolve();\n\n\twhile( cin >> n, n)\n\t{\n\t\tcout << dp[n] << \" \";\n\t\tcout << dp_odd[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP_N(i,n,s) for(ll i=0; i<(ll)n; i+=s)\n#define REP(i,n) REP_N(i,n,1)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nvoid solution(ll output[1000001], int interval) {\n\toutput[0] = 0;\n\tll current_i = 1;\n\tREP(i, 1000001) if(i!=0) {\n\t\tll minimum = 1000001;\n\t\tREP_N(j, current_i+1, interval) if(j!=0) minimum = min(output[i - table[j]] + 1, minimum);\n\t\toutput[i] = minimum;\n\n\t\tif (table[current_i + interval] == i) current_i += interval;\n\t}\n}\n\nint main() {\n\t\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i++]) table[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tsolution(pollock, 1);\n\tsolution(dp, 4);\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nusing usize = ::std::size_t;\nusing u64 = ::std::uint_least64_t;\n\n#define v(n) n*(n+1)*(n+2)/6\n\nint main(int argc, char *argv[])\n{\n    // input from txt （提出時にこの箇所は削除すること）\n    //ifstream in(\"in.txt\");\n    //cin.rdbuf(in.rdbuf());\n \n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    static constexpr u64 Inf = ::std::numeric_limits<u64>::max() / 2;\n    \n    vector<u64> dp(1000001, Inf);\n    vector<u64> dp2(1000001, Inf);\n    dp[0] = 0;\n    dp2[0] = 0;\n    //int ti = clock();\n    \n    for (int i = 1; i <= 600; i++) {\n        for (int j = v(i); j <= 1000000; j++) {\n            for (int k = 1; j - k*v(i) >= 0 && k <= 5; k++) {\n                dp[j] = min(dp[j], dp[j - k * v(i)] + k);\n            }\n        }\n    }\n    \n    for (int i = 1; i <= 600; i += 4) {\n        for (int j = v(i); j <= 1000000; j++) {\n            for (int k = 1; j - k*v(i) >= 0; k++) {\n                if (dp2[j] <= dp2[j - k * v(i)] + k) {\n                    break;\n                }\n                dp2[j] = min(dp2[j], dp2[j - k * v(i)] + k);\n            }\n        }\n    }\n    \n    //cout << (1.0 * (clock() - ti) / CLOCKS_PER_SEC) << endl;\n    \n    u64 N;\n    while (cin >> N, N) {\n        cout << dp[N]  << \" \" << dp2[N] << endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nint dp[200][1000001];\nint dp_odd[40][1000001];\nint four[210];\nint x;\n\nsigned main() {\n  Rep(i, 210) four[i] = i * (i+1) * (i+2) / 6;\n  \n  memset(dp, 1e6+1, sizeof(dp));\n  Rep(i, 1000001) dp[1][i] = i;\n  Rrep(i, 2, 200) {\n    Rep(j, 1000001) {\n      dp[i][j] = min(dp[i][j], dp[i-1][j]);\n      if ( j+four[i] <= 1000000 ) {\n\tdp[i][j+four[i]] = min(dp[i][j+four[i]], dp[i][j]+1);\n      }\n    }\n  }\n\n  memset(dp_odd, 1e6+1, sizeof(dp_odd));\n  Rep(i, 1000001) dp_odd[1][i] = i;\n  Rrep(i, 2, 40) {\n    Rep(j, 1000001) {\n      dp_odd[i][j] = min(dp_odd[i][j], dp_odd[i-1][j]);\n      if ( j+four[(i-1)*4+1] <= 1000000 ) {\n\tdp_odd[i][j+four[(i-1)*4+1]] = min(dp_odd[i][j+four[(i-1)*4+1]], dp_odd[i][j]+1);\n      }\n    }\n  }\n \n  while ( cin >> x, x ) {\n    cout << dp[199][x] << \" \" << dp_odd[39][x] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint x,y;\nint m[1000005]={};\nint memo[1000005]={};\nint memo2[1000005]={};\nvector<int> odd;\nvoid saiki(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << \":\" << x << endl;\n  if(n==0) {\n    //cout << x << d << endl;\n    x=min(x,d);\n  }else if(n>0) {\n    if(memo[n]>0){\n      x=min(x,memo[n]+d);\n    }else{\n      for(i=1;m[i]<=n;i++);\n      i--;\n      int b=x;\n      for(j=i;j>0;j--){\n\tif(x>d+1)\n\t  saiki(n-m[j],d+1);\n      }\n      if(x>b)\n\tmemo[n]=x-d;\n      //cout << n << \":\" << memo[n]<< endl;\n    }\n  }\n}\nvoid saiki2(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << endl;\n  if(n==0) {\n    y=min(y,d);\n  }else if(n>0) {\n    if(memo2[n]>0){\n      y=min(y,memo2[n]+d);\n    }else{\n      for(i=0;odd[i]<=n;i++);\n      i--;\n      int b=y;\n      //cout << i << \":\" << n << \":\" << odd[i] << endl;\n      for(j=i;j>=0;j--){\n\tif(y>d+1){\n\t  saiki2(n-odd[j],d+1);\n\t}\n      }\n      if(y>b)\n\tmemo2[n]=y-d;\n    }\n  }\n}\nint main(){\n  int i,j,k;\n  fill(memo,memo+1000005,-1);\n  fill(memo2,memo2+1000005,-1);\n  for(i=1;i<1000005;i++) {\n    m[i]=i*(i+1)*(i+2)/6;\n    if(m[i]%2==1) odd.push_back(m[i]);\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    x=1<<10;y=x;\n    saiki(n,0);saiki2(n,0);\n    cout << x << \" \" <<  y << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<numeric>\n\n#define INF (1<<28)\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=(j);i<=(k);i++)\n#define fs first\n#define sc second\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint dp1[181][1000000];\nint dp2[181][1000000];\nint main(){\n\tvi v1,v2;\n\tfor(int i=1;;i++){\n\t\tint t = i * (i+1) * (i+2) / 6;\n\t\tif (t > 1000000) break;\n\t\tv1.pb(t);\n\t\tif(t&1)v2.pb(t);\n\t}\n\trep(i,1000000) dp1[0][i] = dp2[0][i] = i;\n\trep(i,v1.size()-1){\n\t\trep(j,1000000){\n\t\t\tdp1[i+1][j] = dp1[i][j];\n\t\t\tif(j>=v1[i+1])\n\t\t\t\tdp1[i+1][j] = min(dp1[i+1][j], dp1[i+1][j-v1[i+1]] + 1);\n\t\t}\n\t}\n\trep(i,v2.size()-1){\n\t\trep(j,1000000){\n\t\t\tdp2[i+1][j] = dp2[i][j];\n\t\t\tif(j>=v2[i+1])\n\t\t\t\tdp2[i+1][j] = min(dp2[i+1][j], dp2[i+1][j-v2[i+1]]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n,n){\n\t\tcout << dp1[v1.size()-1][n] << \" \" << dp2[v2.size()-1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n  \nint main(void){\n    int i, j, n, min1,small;\n    int dp[1000000];\n    scanf(\"%d\",&n);\n    while(n != 0){\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(small > dp[i]){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n            if(small > dp[n])\n                small = dp[n];\n            if(dp[n] == 1)\n                break;\n        }\n  \n        min1 = dp[n];\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(dp[i] < small){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n            if(small > dp[n])\n                small = dp[n];\n            if(dp[n] == 1)\n               break;\n        }\n        printf(\"%d %d\\n\",min1,dp[n]);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nint pol[185];\nvector<int> oddPol;\nint minN[1000000];\nint oddN[1000000];\nint main(){\n    for(int i=1;i<1000000;i++){\n        minN[i]=5;\n        oddN[i]=1000000;\n    }\n    for(int i=1;i<=180;i++){\n        pol[i]=i*(i+1)*(i+2)/6;\n        minN[pol[i]]=1;\n        if(pol[i]%2==1){\n            oddPol.push_back(pol[i]);\n            oddN[pol[i]]=1;\n        }\n    }\n    for(int i=1;i<1000000;i++){\n        for(int j=1;pol[j]<=i && j<=180 && i+pol[j]<1000000;j++){\n            minN[i+pol[j]]=min(minN[i+pol[j]],minN[i]+1);\n        }\n        for(int j=0;oddPol[j]<=i && j<oddPol.size() && i+oddPol[j]<1000000;j++){\n            oddN[i+oddPol[j]]=min(oddN[i+oddPol[j]],oddN[i]+1);\n        }\n    }\n    /*for(int i=1;i<=40;i++){\n        cout<<i<<\":\"<<oddN[i]<<endl;\n    }*/\n    int n;\n    while(cin>>n,n!=0){\n        cout<<minN[n]<<\" \"<<oddN[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1500001]={0,1,2,3},d[1500001],k=0,i,j,n,p;\n  for(i=1;a[i-1]<1100000;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0,p=i;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<p-1;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nPollocks conjecture\nhttps://onlinejudge.u-aizu.ac.jp/problems/1167\n*/\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1000100;\nconst int INF = 1<<29;\n\nint main() {\n    vector<int> dp_all(MAX, INF), dp_odd(MAX, INF);\n    dp_all[0] = dp_odd[0] = 0;\n    for (int i = 1;; ++i) {\n        int num = i * (i+1) * (i+2) / 6;\n        if (num >= MAX) break;\n        for (int j = num; j < MAX; ++j) {\n            dp_all[j] = min(dp_all[j], dp_all[j-num]+1);\n            if (num & 1) dp_odd[j] = min(dp_odd[j], dp_odd[j-num]+1);\n        }\n    }\n\n    //for(int i=0; i<MAX; i++) cout << dp_all[i] << \" \" << dp_odd[i] << endl;\n    int n;\n    while (cin >> n, n!=0) {\n        cout << dp_all[n] << \" \" << dp_odd[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n;\n\nvector<ll> table, table2;\n\nll dp[2][2][1001000];\n\nint main() {\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= 100000; i++) {\n\t\ttable.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif ((i*(i + 1)*(i + 2) / 6) % 2 == 1)table2.push_back(i*(i + 1)*(i + 2) / 6);\n\t}\n\tREP(i, 2) {\n\t\tREP(j, 2) {\n\t\t\tREP(k, 1001000)dp[i][j][k] = INF;\n\t\t}\n\t}\n\tdp[0][0][0] = 0;\n\tdp[1][0][0] = 0;\n\n\tREP(i, table.size()) {\n\t\tint num = table[i];\n\t\tREP(j, 1000000) {\n\t\t\tif (j - num >= 0) {\n\t\t\t\tdp[0][(i + 1) % 2][j] = min(dp[0][(i + 1) % 2][j - num] + 1, dp[0][i % 2][j]);\n\t\t\t}\n\t\t\telse dp[0][(i + 1) % 2][j] = dp[0][i % 2][j];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < table2.size(); i++) {\n\t\tint num = table2[i];\n\t\t//cout << num << endl;\n\t\tREP(j, 1000000) {\n\t\t\tif (j - num >= 0) {\n\t\t\t\tdp[1][(i + 1) % 2][j] = min(dp[1][(i + 1) % 2][j - num] + 1, dp[1][i % 2][j]);\n\t\t\t}\n\t\t\telse dp[1][(i + 1) % 2][j] = dp[1][i % 2][j];\n\t\t}\n\t}\n\t\n\twhile (cin >> n&&n) {\n\t\tcout << dp[0][table.size() % 2][n] << \" \"\n\t\t\t<< dp[1][table2.size() % 2][n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[10000];\n    fill(dp,dp + x+1,100000);\n  \n/*\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tvi three;\n\tint num = 1, tmp = 0;\n\twhile(tmp <= 100000) {\n\t\ttmp += num;\n\t\tthree.push_back(tmp);\n\t\tnum++;\n\t}\n\n\tvi four;\n\ttmp = 0;\n\tint pos = 0;\n\twhile(tmp <= 100000) {\n\t\ttmp += three[pos];\n\t\tfour.push_back(tmp);\n\t\tpos++;\n\t}\n\tint fsize = four.size();\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tvi dp(n+1, INF);\n\t\tvi dpk(n+1, INF);\n\t\tdp[0] = dpk[0] = 0;\n\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, fsize) {\n\t\t\t\tif(i-four[j] >= 0) {\n\t\t\t\t\tdp[i] = min(dp[i-four[j]]+1, dp[i]);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 1, n) {\n\t\t\tREP(j, fsize) {\n\t\t\t\tif(i-four[j] >= 0) {\n\t\t\t\t\tif(four[j]%2) {\n\t\t\t\t\t\tdpk[i] = min(dpk[i-four[j]]+1, dpk[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[n] << \" \" << dpk[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\nconst double EPS = 1e-8;\n\ntemplate<typename T> T chmax(T& a, const T& b){return a = (a > b ? a : b);}\ntemplate<typename T> T chmin(T& a, const T& b){return a = (a < b ? a : b);}\n\nint main(){\n    vi v;\n    REP(i, 1, 1e3) {\n        v.push_back(i*(i+1)*(i+2)/6);\n        if(v.back() > 1e6) break;\n    }\n    vl dp1(1e6+10, INF), dp2(1e6+10, INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for(auto&& x : v) {\n        for(int i = 0; i+ x < dp1.size(); ++i) {\n            chmin(dp1[i+x], dp1[i]+1);\n            if(x&1LL) chmin(dp2[i+x], dp2[i]+1);\n        }\n    }\n    int n;\n    while(cin >> n && n) {\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i, n) for(int i=0;i<(n);i++)\n \nconst int m = 1000001;\n \nint dp[2][1000001];\n \nint main() {\n \n    rep(i, 2)rep(j, m)dp[i][j] = j;\n \n    for(int i=1,a;a=i*(i+1)*(i+2)/6,a<m;i++)\n        rep(k, m-a) {\n            if(dp[0][k]< dp[0][k+a])dp[0][k+a] = dp[0][k] + 1;\n            if(a%2 && dp[1][k] < dp[1][k+a])dp[1][k+a] = dp[1][k] + 1;\n        }\n \n    for(int n;cin>>n,n;)cout<<dp[0][n]<<' '<<dp[1][n]<<endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> T sum(vector<T> &v, int s = 0, int t = inf) {\n    T ret = 0;\n    rep(i, s, min(sz(v), t))ret += v[i];\n    return ret;\n}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    return ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    return ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &m) {\n    for (auto &&v:m) os << v << \" \";\n    return os;\n}\nconstexpr bool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = max(res, v);\n    }\n    return res;\n}\nint min(vi &a) {\n    int res = a[0];\n    fora(v, a) {\n        res = min(res, v);\n    }\n    return res;\n}\nint N, M, H, W;\nvi A,B,C;\n\nsigned main() {\n    int N;\n    vi A;\n    vi O;\n    rep(i,1, 1000000){\n        A+= (i)*(i+1)*(i+2)/6;\n        if(A.back() > k6)break;\n        if(A.back()%2){\n            O+=A.back();\n        }\n    }\n    vi dp(k6*3+100,inf);\n    vi dpo(k6*3+1000,inf);\n    dp[0]=0;\n    dpo[0]=0;\n    rep(v, k6){\n        fora(a, A){\n            chmi(dp[v+a], dp[v]+1);\n        }\n        fora(a, O){\n            chmi(dpo[v+a], dpo[v]+1);\n        }\n    }\n    while(1) {\n        cin>>N;\n        if(N==0)break;\n        cout<<dp[N]<< \" \"<<dpo[N]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      //if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n\t//}\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##_len=(int)(n);i<i##_len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nint tetr[200];\nint dp1[1234567];\nint dp2[1234567];\nsigned main() {\n    REP(i,200) tetr[i]=(i+1)*(i+2)*(i+3)/6;\n    REP(i,1000010) {\n        dp1[i]=i;\n        dp2[i]=i;\n    }\n    REP(i,200) {\n        REP(j,1000010) {\n            if(dp1[j]!=INF) {\n                if(j+tetr[i]<=1000010) chmin(dp1[j+tetr[i]],dp1[j]+1);\n            }\n            if(tetr[i]%2==0) {\n                continue;\n            }\n            if(dp2[j]!=INF) {\n                if(j+tetr[i]<=1000010) chmin(dp2[j+tetr[i]],dp2[j]+1);\n            }\n        }\n    }\n    while(1) {\n        int n;\n        cin>>n;\n        if(n==0) break;\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n#define NDEBUG //NDEBUG??????????????????????????´???assert?????????????????????????????????NDEBUG????????????????????¨\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef vector<int> vi;\nconst int INF = 1e9-1;\n\n\nint tetrahedral(int n) {\n    assert( (n*(n+1)*(n+2)) % 6 == 0);\n    return n*(n+1)*(n+2)/6;\n}\n\nint tetrahedralOdd(int n) {\n    n = n*4-3;\n    assert( (n*(n+1)*(n+2)) % 6 == 0);\n    return n*(n+1)*(n+2)/6;\n}\n\nint iMaxForTetrahedral(int x) { //?????¶??°x??\\???????????§?????£?????¢?????°???i?????????\n    assert(x>0);\n    \n    int i = 1;\n    while(tetrahedral(i)<=x) i++;\n    \n    return --i;\n}\n\nint iMaxForTetrahedralOdd(int x) { //?????¶??°x??\\???????????§????\\???°??£?????¢?????°???i?????????\n    assert(x>0);\n    \n    int i = 1;\n    while(tetrahedralOdd(i)<=x) i++;\n    \n    return --i;\n}\n\n\n\nint main(){\n    \n    int N; //??£?????¢?????°????????????????????????????????????????????°\n    \n    while(1) {\n        cin >> N;\n        if(N==0) break;\n        \n        vi T;\n        T.push_back(0); //T[0] = 0\n        rep(i,1,N+1) T.push_back(INF); //T[1] ... T[N] = INF\n        \n        rep(i, 1, iMaxForTetrahedral(N)+1 ) {\n            rep(j, tetrahedral(i), N+1) {\n                T[j] = min( T[j], T[j-tetrahedral(i)] + 1 );\n                \n//                disp(i);\n//                disp(j);\n//                \n//                disp(tetrahedral(i));\n//                \n//                \n//                dout<<\"N = \";\n//                rep(i,0,N+1) disP(i);\n//                dout<<endl;\n//                dispAll(T, N+1);\n//                dout<<\"----------T\\n\";\n            }\n        }\n        \n        \n        \n        \n        vi S;\n        S.push_back(0); //S[0] = 0\n        rep(i,1,N+1) S.push_back(INF); //S[1] ... S[N] = INF\n        \n        rep(i, 1, iMaxForTetrahedralOdd(N)+1 ) {\n            rep(j, tetrahedralOdd(i), N+1) {\n                S[j] = min( S[j], S[j-tetrahedralOdd(i)] + 1 );\n                \n//                disp(i);\n//                disp(j);\n//                \n//                dout<<\"N = \";\n//                rep(i,0,N+1) disP(i);\n//                dout<<endl;\n//                dispAll(S, N+1);\n//                dout<<\"----------S\\n\";\n            }\n        }\n        \n        \n        cout << T[N] << \" \" << S[N] << endl;\n    \n    }\n    \n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define from_to(from, to, i) for(int i=from;i<=to;i++)\n\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 1000010;\nconst int INF = 1<<29;\n\nint main(int argc, char const* argv[])\n{\n    vector<int> V;\n    for (int i = 1; i*(i+1)*(i+2)/6 < MAX; i++) {\n        V.push_back(i*(i+1)*(i+2)/6);\n    }\n\n    int all[MAX], odd[MAX];\n    fill(all, all+MAX, INF);\n    fill(odd, odd+MAX, INF);\n\n    all[0] = odd[0] = 0;\n    for (int v : V) {\n        loop (v, i) {\n            for (int j = 1; i+v*j < MAX; j++) {\n                all[i+v*j] = min(all[i+v*j], all[i+v*(j-1)] + 1);\n\n                if (v%2) {\n                    odd[i+v*j] = min(odd[i+v*j], odd[i+v*(j-1)] + 1);\n                }\n            }\n        }\n    }\n\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        printf(\"%d %d\\n\", all[n], odd[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define MAX 1000000\nusing namespace std;\n\nint tetra[110];\nint dp[MAX];\nint dp2[MAX];\n\nint main(void){\n\tint n;\n\tmemset(dp,MAX,sizeof(dp));\n\tmemset(dp2,MAX,sizeof(dp2));\n\tdp[0]=dp2[0]=0;\n\tfor(int i=1;i<110;i++)\n\t\ttetra[i]=i*(i+1)*(i+2)/6;\n\tfor(int i=1;i<110;i++){\n\t\tfor(int j=0;j<MAX;j++){\n\t\t\tif(j+tetra[i]>=MAX)\n\t\t\t\tcontinue;\n\t\t\tdp[j+tetra[i]]=min(dp[j+tetra[i]],dp[j]+1);\n\t\t\tif(tetra[i]%2)\n\t\t\t\tdp2[j+tetra[i]]=min(dp2[j+tetra[i]],dp2[j]+1);\n\t\t}\n\t}\n\twhile(cin >>n,n)\n\t\tcout << dp[n] <<\" \" << dp2[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<ll> p;\nvector<ll> o;\nvector<ll> memo(1000001, INF);\n\nll cal(ll n) {\n\tif(memo[n] != INF) return memo[n];\n\telse {\n\t\tll ans = INF;\n\t\tll i = o.size() - 1;\n\t\twhile(i >= 0) {\n\t\t\tif(n - o[i] > 0)\n\t\t\tans = min(ans, 1 + cal(n - o[i]));\n\t\t\t--i;\n\t\t}\n\t\treturn memo[n] = ans;\n\t}\n}\n\nint main(void) {\n\n\tfor(ll i = 0; i * (i + 1) * (i + 2) / 6 <= 1000000; ++i) {\n\t\tp.pb(i * (i + 1) * (i + 2) / 6);\n\t\tif((i * (i + 1) * (i + 2) / 6) % 2 == 1) o.pb(i * (i + 1) * (i + 2) / 6);\n\t}\n\tvector<P> nf;\n\tmap<ll, ll> nb;\n\tREP(i, p.size()) {\n\t\tREP(j, p.size()) {\n\t\t\tif(p[i] + p[j] > 1000000) continue;\n\t\t\tnf.pb(P(p[i] + p[j], (ll)(p[i] != 0) + (ll)(p[j] != 0)));\n\t\t\tREP(k, p.size()) {\n\t\t\t\tif(nb.count(p[i] + p[j] + p[k]) != 0)\n\t\t\t\tnb[p[i] + p[j] + p[k]] = min(nb[p[i] + p[j] + p[k]], (ll)(p[i] != 0) + (ll)(p[j] != 0) + (ll)(p[k] != 0));\n\t\t\t\telse\n\t\t\t\tnb[p[i] + p[j] + p[k]] = (ll)(p[i] != 0) + (ll)(p[j] != 0) + (ll)(p[k] != 0);\n\t\t\t}\n\t\t}\n\t}\n\tmemo[0] = 0;\n\tREP(i, o.size()) {\n\t\tmemo[o[i]] = 1;\n\t}\n\twhile(true) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tll ans1 = INF, ans2 = INF;\n\t\tREP(i, nf.size()) {\n\t\t\tif(nb.count(n - nf[i].first) != 0) {\n\t\t\t\tans1 = min(ans1, nf[i].second + nb[n - nf[i].first]);\n\t\t\t}\n\t\t}\n\t\tans2 = cal(n);\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\nusing P = pair<int,int>;\n\n/* 大文字を小文字に変換 */\nchar tolower(char c) {return (c + 0x20);}\n/* 小文字を大文字に変換 */\nchar toupr(char c) {return (c - 0x20);}\n\n// if('A'<=s[i] && s[i]<='Z') s[i] += 'a'-'A';\n\n/*\nstring s = \"abcdefg\"\ns.substr(4) \"efg\"\ns.substr(0,3) \"abc\"\ns.substr(2,4) \"cdef\"\n\n// イテレータ要素のインデックス\ndistance(A.begin(), itr);\n*/\n\nconst int MAX_N = 1000000;\nconst int INF = 1000100100;\n\nint main()\n{\n    int ans = -1;\n    int n = 0;\n    int n_odd = 0;\n    vector<int> pol;\n    vector<int> pol_odd;\n    while(true){\n        n++;\n        ans = n*(n+1)*(n+2)/6;\n        if(ans <= 1000000){\n            pol.push_back(ans);\n            if(ans % 2 == 1){\n                pol_odd.push_back(ans);\n                n_odd++;\n            }\n        }else{\n            n--;\n            break;\n        }\n    }\n\n    /*\n    vector<vector<int> > dp(n, vector<int>(MAX_N+1));\n    rep(i,n) rep(j,MAX_N+1) dp[i][j] = INF;\n    rep(j,MAX_N+1) dp[0][j] = j;\n    */\n\n    vector<int> dp(MAX_N+1);\n    rep(i,MAX_N+1) dp[i] = i;\n\n    for(int i=1; i<n; i++){\n        rep(j,MAX_N+1){\n            if(j<pol[i]) continue;\n            else{\n                // dp[i][j] = min(min(dp[i-1][j], dp[i-1][j-pol[i]] + 1), dp[i][j-pol[i]]+1);\n                dp[j] = min(dp[j-pol[i]]+1, dp[j]);\n            }\n        }\n    }\n\n    /*\n    vector<vector<int> > dp_odd(n_odd, vector<int>(MAX_N+1));\n    rep(i,n_odd) rep(j,MAX_N+1) dp_odd[i][j] = INF;\n    rep(j,MAX_N+1) dp_odd[0][j] = j;\n    */\n\n    vector<int> dp_odd(MAX_N+1);\n    rep(i,MAX_N+1) dp_odd[i] = i;\n\n    for(int i=1; i<n_odd; i++){\n        rep(j,MAX_N+1){\n            if(j<pol_odd[i]) continue;\n            else{\n                dp_odd[j] = min(dp_odd[j-pol_odd[i]]+1, dp_odd[j]);\n            }\n        }\n    }    \n    \n\n    \n    while(true){\n        int N; cin >> N;\n\n        if(N == 0) break;\n\n        printf(\"%d %d\\n\", dp[N], dp_odd[N]);\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\nstruct multi {\n  ll first;\n  ll second;\n  ll third;\n};\nbool multicomp(const multi &a, const multi &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll func(vl &kouho, ll c) {\n  vl DP(c + 1, llINF);\n  vl prev(c + 1, llINF);\n  DP[0] = 0;\n  while (true) {\n    prev = DP;\n    AUTO(a, kouho) {\n      if (a >= c)\n        continue;\n      REP(i, c - a + 1) {\n        if (prev[i] < llINF)\n          DP[i + a] = min(prev[i] + 1, prev[i + a]);\n      }\n    }\n    if (DP[c] < llINF)\n      break;\n  }\n  return DP[c];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  vl all;\n  vl odd;\n  ll score = 0;\n  ll i = 1;\n  vector<pll> ans;\n  while (score < 1e6 + 1) {\n    score = (i * (i + 1) * (i + 2)) / 6;\n    if (score % 2 == 1)\n      odd.push_back(score);\n    all.push_back(score);\n    i++;\n  }\n  sort(ALL(odd), REV(ll));\n  sort(ALL(all), REV(ll));\n\n  while (true) {\n    ll n;\n    cin >> n;\n    if (n == 0)\n      break;\n    ans.push_back(make_pair(func(all, n), func(odd, n)));\n  }\n\n  AUTO(a, ans) { cout << a.first << \" \" << a.second << endl; }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint pol(int n){\n    return n*(n+1)*(n+2)/6;\n}\n\nint main(){\n    vector<int> any(1000001),odd(1000001);\n    for(int i=1;i<=1000000;i++){\n        any[i]=odd[i]=i;\n    }\n    for(int n=2;pol(n)<=1000000;n++){\n        int p = pol(n);\n        for(int i=0;i+p<=1000000;i++){\n            any[p+i]=min(any[p+i],any[i]+1);\n        }\n    }\n    for(int n=2;pol(n)<=1000000;n++){\n        int p = pol(n);\n        if(p%2==0) continue;\n        for(int i=0;i+p<=1000000;i++){\n            odd[p+i]=min(odd[p+i],odd[i]+1);\n        }\n    }\n    int n;\n    while(cin>>n,n){\n        cout<<any[n]<<' '<<odd[n]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<string>\n#include<map>\n#include<string.h>\n#include<complex>\n#include<math.h>\n#include<queue>\n#include <functional>\n#include<time.h>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef pair<int, int> pint;\ntypedef pair<llint, llint> pllint;\ntypedef vector<int> vint;\ntypedef vector<llint> vllint;\ntypedef vector<pint> vpint;\ntypedef vector<string> vstring;\ntypedef vector<pair<llint, llint>> vpllint;\ntypedef vector<vector<int>> vvint;\ntypedef vector<vector<llint>> vvllint;\ntypedef vector<vector<pint>> vvpint;\ntypedef vector<bool> vbool;\ntypedef vector<vbool> vvbool;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define drep(i,n) for(int i=n-1;0<=i;i--)\n#define yes(ans) if(ans)cout<<\"yes\"<<endl;else cout<<\"no\"<<endl;\n#define Yes(ans) if(ans)cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;\n#define YES(ans) if(ans)cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;\n#define POSSIBLE(ans) if(ans)cout<<\"POSSIBLE\"<<endl;else cout<<\"IMPOSSIBLE\"<<endl;\n#define Pi 3.1415926535897932384626\n#define mod llint(1e9+7)\n#define Inf 2147483647\n#define llInf 9223372036854775807\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define isin(n,i) 0<=i&&i<n\n\nclass UnionFind {\npublic:\n\t//親の番号を格納する。親だった場合は-(その集合のサイズ)\n\tvector<int> Parent;\n\n\t//作るときはParentの値を全て-1にする\n\t//こうすると全てバラバラになる\n\tUnionFind(int N) {\n\t\tParent = vector<int>(N, -1);\n\t}\n\n\t//Aがどのグループに属しているか調べる\n\tint root(int A) {\n\t\tif (Parent[A] < 0) return A;\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\n\t//自分のいるグループの頂点数を調べる\n\tint size(int A) {\n\t\treturn -Parent[root(A)];//親をとってきたい\n\t}\n\n\t//AとBをくっ付ける\n\tbool connect(int A, int B) {\n\t\t//AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B) {\n\t\t\t//すでにくっついてるからくっ付けない\n\t\t\treturn false;\n\t\t}\n\n\t\t//大きい方(A)に小さいほう(B)をくっ付けたい\n\t\t//大小が逆だったらひっくり返しちゃう。\n\t\tif (size(A) < size(B)) swap(A, B);\n\n\t\t//Aのサイズを更新する\n\t\tParent[A] += Parent[B];\n\t\t//Bの親をAに変更する\n\t\tParent[B] = A;\n\n\t\treturn true;\n\t}\n};\n\n//セグ木・0-indexed・非再帰・(大きさ・単位元)で初期化\ntemplate<typename T>\nstruct SegTree {\n\t//比較関数の型\n\tusing F = function<T(T, T)>;\n\t//二分木を配列で表したもの\n\tvector<T>seg;\n\t//木の半分の大きさ\n\tint siz;\n\t//単位元\n\tconst T unit;\n\t//比較する関数\n\tconst F f;\n\n\t//大きさn、unit(単位元)でsegtreeを初期化する\n\tSegTree(int n, const T unit, const F f) : unit(unit), f(f) {\n\t\tsiz = 1;\n\t\twhile (siz < n)siz <<= 1;\n\t\tseg.assign(siz * 2 - 1, unit);\n\t\tsiz--;\n\t}\n\n\t//k番目にtを入力\n\tvoid set(int k, const T& t) {\n\t\tseg[k + siz] = t;\n\t}\n\n\t//fによって木を構築する\n\tvoid build() {\n\t\tfor (int i = siz - 1; 0 <= i; i--) {\n\t\t\tseg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n\t\t}\n\t}\n\n\tT operator[](const int i) {\n\t\treturn seg[i + siz];\n\t}\n\n\t//k番目をxに更新する\n\tvoid update(int k, T x) {\n\t\tk += siz;\n\t\tseg[k] = x;\n\t\twhile (0 < k) {\n\t\t\tk = (k - 1) >> 1;\n\t\t\tseg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\n\t//[a,b)について、fした結果を返す\n\t//半開区域のためa以上b未満の位置を指す\n\tT query(int a, int b) {\n\t\tT l = unit, r = unit;\n\t\tfor (a += siz, b += siz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (!(a & 1))l = f(seg[a++], l);\n\t\t\tif (!(b & 1))r = f(seg[--b], r);\n\t\t}\n\t\treturn f(l, r);\n\t}\n};\n\n//aとbの最大公約数を求めるよ\nlong long GCD(long long a, long long b) {\n\tif (b == 0) return a;\n\telse return GCD(b, a % b);\n}\n\n// 返り値: a と b の最大公約数\n// ax + by = gcd(a, b) を満たす (x, y) が格納される\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tlong long d = extGCD(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\n\n//nCrを1000000007で割った余りを求める\nllint nCr(llint n, llint r) {\n\tllint ans = 1;\n\tfor (llint i = 0; i < r; i++) {\n\t\tans *= n - i;\n\t\tans %= 1000000007;\n\t}\n\tfor (llint i = 1; i <= r; i++) {\n\t\tans *= modinv(i, 1000000007);\n\t\tans %= 1000000007;\n\t}\n\treturn ans;\n}\n\n//aのb乗をmodで割った余りを求める\nllint power(llint a, llint b) {\n\tif (b == 1)return a;\n\tif (b == 0)return 1;\n\tllint tmp = power(a, (llint)b / 2);\n\ttmp *= tmp;\n\ttmp %= mod;\n\tif (b % 2 == 1) {\n\t\ttmp *= a;\n\t\ttmp %= mod;\n\t}\n\treturn tmp;\n}\n\nbool next_combination(llint& sub, int length) {\n\tllint x = sub & -sub, y = sub + x;\n\tsub = (((sub & ~y) / x) >> 1) | y;\n\treturn sub < (llint)(1 << (llint)length);\n}\n\nint main() {\n\t//table[i]=i番目の三角錐数\n\tvint table(299);\n\trep(i, 299) {\n\t\ttable[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tvpint ans;\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\t\tpint nans;\n\t\tvint dp1(n + 1, Inf);\n\t\tdp1[0] = 0;\n\t\tfor (int i = 298; 1 <= i; i--) {\n\t\t\tfor (int j = table[i]; j <= n; j++) {\n\t\t\t\tif (dp1[j - table[i]] != Inf) {\n\t\t\t\t\tdp1[j] = min(dp1[j], dp1[j - table[i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnans.first = dp1[n];\n\t\tvint dp2(n + 1, Inf);\n\t\tdp2[0] = 0;\n\t\tfor (int i = 298; 1 <= i; i--) {\n\t\t\tif (table[i] % 2 != 1)continue;\n\t\t\tfor (int j = table[i]; j <= n; j++) {\n\t\t\t\tif (dp2[j - table[i]] != Inf) {\n\t\t\t\t\tdp2[j] = min(dp2[j], dp2[j - table[i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnans.second = dp2[n];\n\t\tans.pb(nans);\n\t}\n\trep(i, ans.size())cout << ans[i].first << \" \" << ans[i].second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint N;\nint dp[1000001], dpodd[1000001];\n\nint main() {\n\n\t//前計算でdpテーブルを計算。8sもあるのでオーダーは怪しいけど大丈夫のはず\n\n\tfor (int i = 0; i <= 1000000; i++)dp[i] = 1145141919, dpodd[i] = 1145141919;\n\n\tdp[0] = 0, dpodd[0] = 0;\n\tfor (int i = 1;; i++) {\n\t\tint cur = i * (i + 1) * (i + 2) / 6;\n\n\t\tif (cur > 1000000)continue;\n\n\t\tfor (int j = cur; j <= 1000000; j++) {\n\t\t\tif (i % 2 == 1) {\n\t\t\t\tdpodd[j] = min(dpodd[j], dpodd[j - cur] + 1);\n\t\t\t}\n\n\t\t\tdp[j] = min(dp[j], dp[j - cur] + 1);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcout << dp[N] << \" \" << dpodd[N] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1000000;\nconst int INF = 1<<29;\n\nint main() {\n    vector<int> dp(MAX, INF), odddp(MAX, INF);\n    dp[0] = odddp[0] = 0;\n    for (int i = 1;; ++i) {\n        int num = i * (i+1) * (i+2) / 6;\n        if (num >= MAX) break;\n        for (int j = num; j < MAX; ++j) {\n            dp[j] = min(dp[j], dp[j-num]+1);\n            if (num & 1) odddp[j] = min(odddp[j], odddp[j-num]+1);\n        }\n    }\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tlong int ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1000001;\nconst int INF = 1<<27;\nvector<int> N3, N4;\nint T[2][MAX_N];\n\nvoid makeN4() {\n  for(int n = 1; ; ++n) {\n    int s = n*(n+1)*(n+2)/6;\n    if(s >= MAX_N) break;\n    N4.push_back(s);\n  }\n}\n\nvoid solve(bool oddOnly) {\n  int *t = T[oddOnly];\n  fill(t, t+MAX_N, INF);\n  t[0] = 0;\n\n  for(int j = 0; j < N4.size(); ++j) {\n    if(oddOnly && N4[j]%2 == 0) continue;\n    for(int i = N4[j]; i < MAX_N; ++i) {\n      t[i] = min(t[i], t[i-N4[j]] + 1);\n    }\n  }\n  /*\n  for(int i = 1; i < MAX_N; ++i) {\n    for(int j = 0; j < N4.size() && N4[j] <= i; ++j) {\n      if(oddOnly && N4[j]%2 == 0) continue;\n      t[i] = min(t[i], t[i-N4[j]] + 1);\n    }\n  }\n  */\n}\n\nint main() {\n  makeN4();\n  solve(false);\n  solve(true);\n  int N;\n  while(cin >> N && N) {\n    cout << T[0][N] << \" \" << T[1][N] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000100;\n\nvector<int> tetras;\nvector<int> oddTetras;\n\nint dp[MAX];\nint oddDp[MAX];\n\nint main() {\n\tfor (int i = 1; i < 200; i++) {\n\t\tint n = i * (i + 1) * (i + 2) / 6;\n\t\ttetras.push_back(n);\n\t\tif (n % 2 == 1)\n\t\t\toddTetras.push_back(n);\n\t}\n\n\tfor (int i = 0; i < MAX; i++) {\n\t\tdp[i] = oddDp[i] = i;\n\t}\n\tfor (int i = 1; i < MAX; i++) {\n\t\tfor (int j = 0; tetras[j] <= i; j++) {\n\t\t\tdp[i] = min(dp[i], dp[i - tetras[j]] + 1);\n\t\t}\n\t\tfor (int j = 0; oddTetras[j] <= i; j++) {\n\t\t\toddDp[i] = min(oddDp[i], oddDp[i - oddTetras[j]] + 1);\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n , n != 0) {\n\t\tcout << dp[n] << \" \" << oddDp[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL << 30)\n#define LLINF (1LL << 60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dp1[1000010], dp2[1000010];\nsigned main(void) {\n  VL a, b;\n  FOR(i, 1, 500) {\n    int tmp = i * (i + 1) * (i + 2) / 6;\n    if (tmp % 2)\n      b.PB(tmp);\n    a.PB(tmp);\n  }\n  //cout << a[100] << a[150] << \" \" << a[200] << endl;\n  //cout << b.size() << endl;\n  //a 200?????§???b 100?????§\n\n  REP(i, 1000001) dp1[i] = dp2[i] = i;\n  FOR(i, 1, 200) {\n    FOR(j, a[i], 1000001) {\n      dp1[j] = min(dp1[j], dp1[j-a[i]] + 1);\n    }\n  }\n  FOR(i, 1, 100) {\n    FOR(j, b[i], 1000001) {\n      dp2[j] = min(dp2[j], dp2[j-b[i]] + 1);\n    }\n  }\n\n  //REP(i, 50) cout << dp1[i] << \" \"; cout << endl;\n  //REP(i, 50) cout << dp2[i] << \" \"; cout << endl;\n\n  int n;\n  while (true) {\n    cin >> n;\n    if(!n) break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1];\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=2;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      dp[0][nxt] = min(dp[0][nxt],dp[0][j] + 1);\n      if(val&1)dp[1][nxt] = min(dp[1][nxt],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  int n;\n  while(cin >> n,n)cout << dp[0][n] << \" \" << dp[1][n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    ll s4[101];\n    vector<ll> s4_k;\n    s4[0] = 1;\n    for(int i = 1; i < 101; i++){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    \n    ll n;\n    cin >> n;\n    while(n != 0){\n        vector<ll> dp(n + 1, INF);\n        dp[0] = 0;\n        \n        REP(i, 101){\n            REP(j, n + 1){\n                if(s4[i] <= j){\n                    dp[j] = min(dp[j], dp[j - s4[i]] + 1);\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[n] << ' ';\n        \n        \n        \n        REP(i, n + 1){\n            dp[i] = INF;\n        }\n        dp[0] = 0;\n        \n        for(int i = 0; i < s4_k.size(); i++){\n            REP(j, n + 1){\n                if(s4_k[i] <= j){\n                    dp[j] = min(dp[j], dp[j - s4_k[i]] + 1);\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[n] << endl;\n        \n        \n        \n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[300][1000001];\n\nint odd(int n,int w){\n  for(int i=0;i<=w;i++)\n    for(int j=0;j<=n;j++){\n      dp[i][j]=99999999;\n      if(i==0)dp[i][j]=j;\n      if(j==0)dp[i][j]=0;\n    }\n\n    for(int i=1;i<=w;i++){\n      for(int j=1;j<=n;j++){\n\tif((i*(i+1)*(i+2)/6)%2==0){\n\t  dp[i][j]=dp[i-1][j];\n\t}else if(j<i*(i+1)*(i+2)/6){\n\t  dp[i][j]=dp[i-1][j];\n\t}else{\n\t  dp[i][j]=min(dp[i-1][j],dp[i][j-i*(i+1)*(i+2)/6]+1);\n\t}\n\t//cout << \"dp[\" << i << \"][\" << j <<\"]:\"<< dp[i][j] << endl;\n      }\n    }\n    return dp[w][n];\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    int w=0;\n    while(w*(w+1)*(w+2)/6 < n){\n      w++;\n    }\n    for(int i=0;i<=w;i++)\n      for(int j=0;j<=n;j++){\n\tdp[i][j]=99999999;\n\tif(i==0)dp[i][j]=j;\n\tif(j==0)dp[i][j]=0;\n      }\n    for(int i=1;i<=w;i++){\n      for(int j=1;j<=n;j++){\n\tif(j<i*(i+1)*(i+2)/6){\n\t  dp[i][j]=dp[i-1][j];\n\t}else{\n\t  dp[i][j]=min(dp[i-1][j],dp[i][j-i*(i+1)*(i+2)/6]+1);\n\t}\n\t//cout << \"dp[\" << i << \"][\" << j <<\"]:\"<< dp[i][j] << endl;\n      }\n    }\n    cout << dp[w][n] << \" \" << odd(n,w) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nstatic const int MAX =1000001;\nstatic const int INF = 1500000;\nint Min[MAX]; //memo for speeding things up\nint odd[MAX]; // same\n\n// this is the improved version to 1167.cpp\nvoid memo(){\n   /*\n     Same as problem 17.1 in the book Algo and Data Struct\n     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_1_A\n\n    */\n\n    /*\n      Made the program substantially faster by making a memo of two different array with one loop\n\n      \n\n     */\n    \n    Min[0]=0;\n    Min[1]=1;\n    odd[0]=0;\n    odd[1]=1;\n    int i,j;\n    for(i=0;i<MAX;i++){\n\tfor(j=1;j<MAX;j++){\n\t    int b=(j*(j+1)*(j+2))/6;\n\t    if (i+b>MAX)break;\n\t    Min[i+b]=min(Min[i+b],Min[i]+1);\n\t    if(b%2){\n\t\todd[i+b]=min(odd[i+b],odd[i]+1);\n\t    }\n\t }\n     }\n }\n\n\n int main(){\n     int n;\n\n     int i;\n     memset(Min,INF,sizeof(Min));\n     memset(odd,INF,sizeof(odd));\n     memo();\n    \n\n    while(1){\n\tcin >>n;\n\tif(n==0)break;\n\n\tcout << Min[n] << \" \" << odd[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int dp[1000010]={};\n  int dp2[1000010]={};\n  for(int i=1;i<=1000000;i++)dp[i]=dp2[i]=INF;\n  vector<ll> gu;\n  vector<ll> ki;\n  ll cnt=1;\n  while(1){\n    if(cnt*(cnt+1)*(cnt+2)/6>1000000)break;\n    if(((cnt*(cnt+1)*(cnt+2))/6)%2)ki.pb(cnt*(cnt+1)*(cnt+2)/6);\n    else gu.pb(cnt*(cnt+1)*(cnt+2)/6);\n  }\n  dp[1]=1;\n  dp2[1]=1;\n  for(int i=1;i<1000000;i++){\n    for(int j=0;j<gu.size();j++){\n      if(i+gu[j]>1000000)break;\n      dp[i+gu[j]]=min(dp[i+gu[j]],dp[i]+1);\n    }\n    for(int j=0;j<ki.size();j++){\n      if(i+ki[j]>1000000)break;\n      dp[i+ki[j]]=min(dp[i+ki[j]],dp[i]+1);\n      dp2[i+ki[j]]=min(dp[i+ki[j]],dp2[i]+1);\n    }\n  }\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nvector <int> c;\nvector <int> a,b;\n\nint main() {\n\n\n  c.push_back(0);\n  for(int i=1;c[i-1]<=1000010;i++) c.push_back(i*(i+1)*(i+2)/6);\n   \n  for(int i=0;i<=1000001;i++) {\n    a.push_back(i);\n    b.push_back(i);\n  }\n  \n  for(int i=0;i<c.size();i++) {\n    for(int j=1;j<=1000000;j++) {\n      \n      if(j-c[i] >=0) { \n     \n\tif(a[j-c[i]] >= 0) a[j] = min(a[j], a[j-c[i]]+1);\n\n\tif(c[i] % 2 == 1 && b[j-c[i]] >=0){\n\t  b[j] = min(b[j],b[j-c[i]]+1);\n\t}\n      }\n      \n    }\n  }\n\n while(1) {\n    int m;\n  cin >> m;\n  if(m == 0) break;\n  \n  cout << a[m] <<\" \" << b[m] << endl;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct P{\n  int sum;\n  char k,n;\n  P(){}\n  P(int S,int K,int N){ sum=S;k=K;n=N; }\n};\n\nint a[200];\n\nint main(){\n  int n, ans1,ans2;\n  queue<P> q;\n  P p;\n\n  for( int i=1;i<200 ; i++ )\n    if( (a[i]=i*(i+1)*(i+2)/6)>1000000 )\n      break;\n\n  int size,n2;\n  while( cin>>n && n ){\n\n    ans1=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<200;i++ ){\n      if( a[i]==n ){\n\tans1=1; size=i+1;\n\tbreak;\n      }\n      if( a[i]<n ) q.push( P(a[i],i,1) );\n      else{\n\tsize=i; break;\n      }\n    }\n    while( !ans1 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      if( binary_search( a,a+size, n-p.sum ) ){\n\tans1=n2; break;\n      }\n      for( int i=p.k,j;i<size;i++ ){\n\tj=p.sum+a[i];\n\tq.push( P(j,i,n2) );\n      }\n    }\n\n    ans2=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<size;i++ ){\n      if( a[i]%2==1 ){\n\tif( a[i]==n ){ ans2=1; break; }\n\tq.push( P(a[i],i,1) );\n      }\n    }\n    while( !ans2 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      int mm=n-p.sum;\n      if( mm%2==1 && binary_search( a,a+size,mm ) ){\n\tans2=n2; break;\n      }\n      for( int i=p.k,j;i<size;i++ ){\n\tif( a[i]%2==1 ){\n\t  j=p.sum+a[i];\n\t  q.push( P(j,i,n2) );\n\t}\n      }\n    }\n    \n    cout << ans1 << \" \" << ans2 << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nchar table[1000000][1],tablek[1000000];\nint po[182];\n\nint main(){\n\tint i,j,k,n;\n\t\n\tmemset(po,0,sizeof(po));\n\tmemset(table,0,sizeof(table));\n\tmemset(tablek,0,sizeof(tablek));\n\t\n\tfor(i=1;i<182;i++){\n\t\tpo[i]=i*(i+1)*(i+2)/6;\n\t\tif(po[i]<1000000)table[po[i]][0]=1;\n\t}\n\t\n\tfor(i=1;i<5;i++){\n\t\tfor(j=1;j<1000000;j++){\n\t\t\tif(table[j][0]==i){\n\t\t\t\tfor(k=1;k<182;k++){\n\t\t\t\t\tif(j+po[k]>=1000000)break;\n\t\t\t\t\tif(table[j+po[k]][0]==0)table[j+po[k]][0]=i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tn=1000000-1;\n\t\n\tfor(i=1;i<182;i++){\n\t\tif(po[i]<1000000 && po[i]%2==1){\n\t\t\ttablek[po[i]]=1;\n\t\t\t--n;\n\t\t}\n\t}\n\tfor(i=1;n>0;i++){\n\t\tfor(j=1;j<1000000;j++){\n\t\t\tif(tablek[j]==i){\n\t\t\t\tfor(k=1;k<182;k++){\n\t\t\t\t\tif(j+po[k]>=1000000)break;\n\t\t\t\t\tif(tablek[j+po[k]]==0 && po[k]%2==1){\n\t\t\t\t\t\ttablek[j+po[k]]=i+1;\n\t\t\t\t\t\t--n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile(scanf(\"%d\",&n)>=0){\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",table[n][0],tablek[n]);\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 1000001\nint dp[N], dp_o[N];\n\nint main(void) {\n  for (int i = 0; i < N; i++) {\n    dp[i] = i;\n    dp_o[i] = i;\n  }\n  \n  for (int i = 2; i < N; i++) {\n    int p = i * (i + 1) * (i + 2) / 6;\n    if (p > N) break;\n    for (int j = 0; j < N - p; j++)\n      dp[j+p] = min(dp[j+p], dp[j] + 1);\n    if(p % 2 == 1) {\n      for(int j = 0; j < N - p; j++) \n\tdp_o[j + p] = min(dp_o[j + p], dp_o[j] + 1);\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    cout << dp[n] << \" \" << dp_o[n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\n#define min(a, b) ((a < b) ? a : b)\n\nusing namespace std;\n\nconst int SIZE = 181 + 1;\nconst int MAX = 1000000;\n\nint T[SIZE];\nint cost1[MAX], cost2[MAX];\n\nint main( void )\n{\t\n\tfor(int i=0; i < SIZE; ++i) T[i] = i * (i + 1) * (i + 2) / 6;\n\n\tmemset(cost1, 9, sizeof(cost1));\n\tfor(int i=0; i < MAX; ++i) cost2[i] = MAX;\n\tcost1[0] = cost2[0] = 0;\n\tfor(int i=0; i < MAX; ++i) {\n\t\tif(cost1[i] < 6) {\n\t\t\tfor(int j=0; j < SIZE; ++j) {\n\t\t\t\tif(i + T[j] < MAX)\n\t\t\t\t\tcost1[i + T[j]] = min(cost1[i + T[j]], cost1[i] + 1);\n\t\t\t}\n\t\t}\n\t\tif(cost2[i] < MAX) {\n\t\t\tfor(int j=0; j < SIZE; ++j) {\n\t\t\t\tif(T[j] & 1) {\n\t\t\t\t\tif(i + T[j] < MAX)\n\t\t\t\t\t\tcost2[i + T[j]] = min(cost2[i + T[j]], cost2[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n) {\n\t\tcout << cost1[n] << ' ' << cost2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint tbl1[1000001];\nint tbl2[1000001];\nint tet(int x){ return x*(x+1)*(x+2)/6; }\nint solve1(int n){\n  if(n<0) return 1000;\n  if(n==0) return 0;\n  if(tbl1[n]) return tbl1[n];\n  int ret = 1000;\n  for(int i=1;tet(i)<=n;++i)\n    ret = min(ret,1+solve1(n-tet(i)));\n  return tbl1[n] = ret;\n}\nint solve2(int n){\n  if(n<0) return 1000;\n  if(n==0) return 0;\n  if(tbl2[n]) return tbl2[n];\n  int ret = 1000;\n  for(int i=1;tet(i)<=n;++i)\n    if(tet(i)%2)\n      ret = min(ret,1+solve2(n-tet(i)));\n  return tbl2[n] = ret;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    cout << solve1(n) << \" \" << solve2(n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <set>\n#include <algorithm>\n\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst long long INF = 1LL<<60;\nconst double PI=3.14159265358979323846;\nconst int NMAX=100005;\nusing namespace std;\n\nvector<ll> f;\nll ans[1000001];\nll ans_odd[10000001];\n\nint main(){\n    for(ll i = 1; i < 240; i++){\n        ll tmp = i*(i+1)*(i+2)/6;\n        if(tmp > 1000000) break;\n        f.push_back(tmp);\n    }\n    for(int i = 0; i <= 1000000; i++){\n        ans[i] = INF;\n        ans_odd[i] = INF;\n    }\n    ans[0] = 0;\n    ans[1] = 1;\n    ans_odd[0] = 0;\n    ans_odd[1] = 1;\n    for(ll i = 0; i <= 1000000; i++){\n        for(int j = 0; j < f.size(); j++){\n            if(i+f[j] > 1000000) break;\n            ans[i+f[j]] = min(ans[i+f[j]], ans[i]+1);\n            if((f[j]%2)==1){\n                ans_odd[i+f[j]] = min(ans_odd[i+f[j]], ans_odd[i]+1);\n            }\n        }\n    }\n    while(true){\n        ll n;\n        cin >> n;\n        if(n == 0) break;\n        cout << ans[n] << \" \" << ans_odd[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(const T a, const T b){return a>=0 ? a/b : (a+1)/b-1;}\ntemplate<class T> T div_ceil(const T a, const T b){return a>=0 ? (a-1)/b+1 : a/b;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 1000010;\n\nint dp[2][MAX];\nvector<int> x[2];\n\nvoid solve(int c){\n    rep(i, MAX) dp[c][i] = MAX;\n    dp[c][0] = 0;\n    rep(i, MAX)if(dp[c][i] < MAX){\n        for(int j: x[c]){\n            if(i+j >= MAX) break;\n            chmin(dp[c][i+j], dp[c][i] + 1);\n        }\n    }\n}\n\nint f(int i){\n    return i*(i+1)*(i+2) / 6;\n}\n\nint main(){\n    for(int i=1; f(i)<=MAX; ++i){\n        x[0].push_back(f(i));\n        if(f(i) % 2 == 1) x[1].push_back(f(i));\n    }\n    rep(i, 2) solve(i);\n    int n;\n    while(scanf(\"%d\", &n) && n){\n        printf(\"%d %d\\n\", dp[0][n], dp[1][n]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[10000000], dp2[10000000];\nint main() {\n\tv.pb(0);\n\tll n, now = 1, now2 = 1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)(i*(i + 1)*(i + 2) / 6);\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 1000000) {\n\t\tif (i < 2) { dp[i] = i; dp2[i] = i;continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], (ll)i / ss[j] + dp[i%ss[j]]);\n\t\tif (i >= v[now2 + 1])++now2;\n\t\tdp2[i] = i / v[now2] + dp2[i%v[now2]];\n\t\tfor (int j = now2 - 1; j >= 1; --j)dp2[i] = min(dp2[i], (ll)i / v[j] + dp2[i%v[j]]);\n\t}\n\twhile (cin >> n, n) {\n\t\trep(i, n)cout << i << \"ha\" << dp[i] << endl;\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1000000007;\n\n#define vec                vector<int>\n#define vecll              vector<ll>\n#define vecd               vector<double>\n#define vecst              vector<string>\n#define vecb               vector<bool>\n#define vec2(var, n, m)    vector<vector<int>>  var(n, vector<int>(m, INF))\n#define vecb2(var, n, m)   vector<vector<bool>> var(n, vector<bool>(m, false))\n#define vecll2(var, n, m)  vector<vector<ll>>   var(n, vector<ll>(m, 0))\n\n#define rep(i,n)         for(ll i=(ll)0; i<(ll)n; i++)\n#define REP(i,m,n)       for(ll i=(ll)m; i<(ll)n; i++)\n#define arr(var, n)      vec var(n); rep(i,n){cin >> var[i];}\n#define arrll(var, n)    vecll var(n); rep(i,n){cin >> var[i];}\n#define arrst(var, n)    vecst var(n); rep(i,n){cin >> var[i];}\n#define all(var)         (var).begin(), (var).end()\n#define sortall(var)     sort(all(var))\n#define uniqueall(v)     v.erase(unique(v.begin(), v.end()), v.end());\n#define f_sum(var)       accumulate(all(var), 0)\n#define f_sumll(var)     accumulate(all(var), 0LL)\n#define chmin(v1, v2)    v1 = min(v1, v2)\n#define chmax(v1, v2)    v1 = max(v1, v2)\n#define pb(var)          push_back(var)\n#define prt(var)         cout << (var) << \"\\n\"\n#define prtd(n, var)     cout << fixed << setprecision(n) << (var) << \"\\n\"\n#define prtfill(n, var)  cout << setw(n) << setfill('0') << (var);\n#define prt2(v1, v2)     cout << (v1) << \" \" << (v2) << \"\\n\"\n#define prt3(v1, v2, v3) cout << (v1) << \" \" << (v2) << \" \" << (v3) << \"\\n\"\n#define prtall(v)        rep(i,v.size()){cout<<v[i]<<(i!=v.size()-1?\" \":\"\\n\");}\nvoid prtok(bool ok){prt(ok ? \"Yes\" : \"No\");}\n//----------------------------------------------------------------\n\nint main(void) {\n  int n = 1000000;\n  int INF = 1e9;\n  vec dp1(n+1, INF), dp2(n+1, INF);\n  vec simen, simen_odd;\n  REP(i,1,200){\n    int tmp = i*(i+1)*(i+2)/6;\n    if(tmp>1000000) break;\n    simen.pb(tmp);\n    if(tmp%2==1) simen_odd.pb(tmp);\n  }\n  dp1[0]=0;\n  dp2[0]=0;\n\n  REP(i,1,1000000){\n    rep(j,simen.size()){\n      if(i-simen[j]>= 0) chmin(dp1[i], dp1[i-simen[j]]+1);\n    }\n    rep(j,simen_odd.size()){\n      if(i-simen_odd[j]>= 0) chmin(dp2[i], dp2[i-simen_odd[j]]+1);\n    }\n  }\n\n  while(1){\n    int q;\n    cin >> q;\n    if(q==0) break;\n\n    prt2(dp1[q], dp2[q]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,m,n) for(int i=(m); i<(int)(n); i++)\n#define RREP(i,m,n) for(int i=(int)(n-1); i>=m; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define fi first\n#define se second\n#define debug(...) {cerr<<\"[L\"<<__LINE__<<\"] \"; _debug(__VA_ARGS__);}\n\ntemplate<typename T>\nstring join(const vector<T>&v, string del=\", \"){ stringstream s;\n    for(auto x : v) s << del << x; return s.str().substr(del.size());\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<T>&v){\n    if(v.size()) o << \"[\" << join(v) << \"]\"; return o;\n}\ntemplate<typename T>\nostream& operator<<(ostream& o, const vector<vector<T> >&vv){\n    int l = vv.size();\n    if(l){ o<<endl; rep(i,l) o << (i==0 ? \"[ \" : \",\\n  \" ) << vv[i] << (i==l-1 ? \" ]\" : \"\"); }\n    return o;\n}\ninline void _debug(){cerr<<endl;}\ntemplate<class First, class... Rest>\nvoid _debug(const First& first, const Rest&... rest){cerr<<first<<\" \";_debug(rest...);}\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nconst double PI = (1*acos(0.0));\nconst double EPS = 1e-9;\nconst int INF = 0x3f3f3f3f;\nconst ll INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst ll mod = 1e9 + 7;\n\ninline void finput(string filename) {\n    freopen(filename.c_str(), \"r\", stdin);\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    // finput(\"./input\");\n    vi sn(1100);\n    REP(i,1,1100) sn[i] = i*(i+1)*(i+2) / 6;\n    vi dp1(1000010, INF);\n    vi dp2(1000010, INF);\n    dp1[0] = 0;\n    rep(i,1000010){\n        rep(j,1100){\n            if(i - sn[j] >= 0)\n                dp1[i] = min(dp1[i], dp1[i-sn[j]] + 1);\n        }\n    }\n    dp2[0] = 0;\n    rep(i,1000010){\n        rep(j,1100){\n            if(i - sn[j] >= 0 && sn[j] & 1)\n                dp2[i] = min(dp2[i], dp2[i-sn[j]] + 1);\n        }\n    }\n    int x;\n    while(cin >> x){\n        if(x == 0) break;\n        cout << dp1[x] << \" \" << dp2[x] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX + 1], dp2[MAX + 1];\n\nint main()\n{\n    for (int i = 1; i < MAX; i++)\n    {\n        dp1[i] = INF;\n        dp1[i] = INF;\n    }\n    for (int n = 1; n * (n + 1) * (n + 2) <= MAX; n++)\n    {\n        int a = n * (n + 1) * (n + 2);\n        for (int i = a; i < MAX; i++)\n        {\n            dp1[i] = min(dp1[i], dp1[i - a] + 1);\n        }\n        if (a % 2 == 0)\n            continue;\n        for (int i = a; i < MAX; i++)\n        {\n            dp2[i] = min(dp2[i], dp2[i - a] + 1);\n        }\n    }\n\n    while (1)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n            break;\n        cout << dp1[n] << \"\" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lpin(a,i,n) for(int i=0;i<n;i++){cin>>a[i];}\n\nvoid calc(int a[],int f){\n  for(int i=f*(f+1)*(f+2)/6;i<=1000000;i++){\n    if(a[i]==0) a[i]=a[i-f*(f+1)*(f+2)/6]+1;\n    else if(a[i]>a[i-f*(f+1)*(f+2)/6]+1) a[i]=a[i-f*(f+1)*(f+2)/6]+1;\n  }\n}\n\nint x[1000000],b[1000000];\nint main(){\n  for(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    calc(x,i);\n  }\n  for(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    if(i*(i+1)*(i+2)/6%2==1)\n    calc(b,i);\n  }\n  while(1){\n    int z;\n    cin>>z;\n    if(z==0) break;\n    cout<<x[z]<<\" \"<<b[z]-3<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[202];\n    int b[202];\n    vector<int> t1(1000010, 0),t2(1000010, 0);\n    for(i = 0; i < 200; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    /*cout << a[82] << b[20] << endl;\n    for(i = 0; i < 200; i++){\n        cout << \"a[\" << i << \"] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 200; i++){\n        cout << \"b[\" << i << \"] = \" << b[i] << endl;\n    }*/\n\n        for(i = 0; i <= 1000005; i++){\n            t1[i] = i;\n        }\n\n        for(i = 0; i <= 179; i++){\n            for(j = a[i]; j <= 1000005; j++){\n                if(t1[j] > t1[j - a[i]] + 1){\n                    t1[j] = t1[j -a[i]] + 1;\n                }\n            }    \n        }        \n\n        for(i = 0; i <= 1000005; i++){\n            t2[i] = i;\n        }\n        \n        for(i = 0; i <= 44; i++){\n            for(j = b[i]; j <= 1000005; j++){\n                if(t2[j] > t2[j - b[i]] + 1){\n                    t2[j] = t2[j - b[i]] + 1;\n                }\n            }\n        }\n            \n\n\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << t1[n] << \" \" << t2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvi tetra, odd_tetra;\nvi table(1000001, INF), dp(1000001, INF);\n\nvoid make_tetra();\nvoid make_odd_tetra();\n\n\nsigned main()\n{\n    make_tetra();\n    make_odd_tetra();\n\n    Int(n);\n\n    while (n) {\n        cout << dp[n] << \" \" << table[n] << endl;\n        cin >> n;\n    }\n\n    return 0;\n}\n\n\nvoid make_tetra()\n{\n    Rep(i, 181) {\n        tetra.pb(i * (i + 1) * (i + 2) /6);\n    }\n    dp[0] = 0;\n    Rep(x, 1000000) {\n        int ret = INF;\n        for (int i : tetra) {\n            if (x < i) {\n                break;\n            } else {\n                ret = min(ret, dp[x - i] + 1);\n            }\n        }\n        dp[x] = ret;\n    }\n}\n\nvoid make_odd_tetra()\n{\n    for (int i : tetra) {\n        if (i % 2) {\n            odd_tetra.pb(i);\n            table[i] = 1;\n        }\n    }\n    table[0] = 0;\n    Rep(x, 1000000) {\n        int ret = INF;\n        for (int i : odd_tetra) {\n            if (x < i) {\n                break;\n            } else {\n                ret = min(ret, table[x - i] + 1);\n            }\n        }\n        table[x] = ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",1,2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n#define MAX 1000000\n\nint  dp[MAX+1];\nint dp2[MAX+1];\n\nint main(){\n  vector<int> nums,odds;\n\n  int tmp=0, n=1;\n  while(tmp<=MAX){\n    tmp+=n*(n+1)/2;\n    nums.pb(tmp);\n    if(tmp%2==1) odds.pb(tmp);\n    n++;\n  }\n\n  fill(dp, dp+MAX+1, INF);\n  fill(dp2, dp2+MAX+1, INF);\n  dp[0]=0; dp2[0]=0;\n\n  repl(i,1,MAX+1){\n    for(int nxt : nums){\n        if(i<nxt) continue;\n        dp[i] = min(dp[i], dp[i-nxt]+1);\n    }\n    for(int nxt : odds){\n        if(i<nxt) continue;\n        dp2[i] = min(dp2[i], dp2[i-nxt]+1);\n    }\n  }\n\n  while(scanf(\"%d\", &n), n){\n    printf(\"%d %d\\n\", dp[n], dp2[n]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N (int)1e6\nusing namespace std;\n\nint main(){\n  int n,tmp,dp[N],dp_odd[N];\n  int plc[1000],num;\n\n  for(int i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n \nint main(void){\n    int i, j, n, min1,small;\n    int dp[200000];\n    scanf(\"%d\",&n);\n    while(n != 0){\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(small > dp[i]){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n            if(small > dp[n])\n                small = dp[n];\n            if(dp[n] == 1)\n                break;\n        }\n \n        min1 = dp[n];\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(dp[i] < small){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n            if(small > dp[n])\n                small = dp[n];\n            if(dp[n] == 1)\n               break;\n        }\n        printf(\"%d %d\\n\",min1,dp[n]);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long int, long long int> PLL;\n\nint main() {\n\t//vector<long long int>A( 1000001, LLONG_MAX / 6 ), B( 1000001, LLONG_MAX / 6 );\n\tvector<long long int>X, Y;\n\tfor( size_t i = 1; i < 1000; i++ ) {\n\t\tlong long int now = i*(i + 1)*(i + 2) / 6;\n\t\tX.push_back( now );\n\t\tif( now % 2 ) {\n\t\t\tY.push_back( now );\n\t\t\t//cout << now << endl;\n\t\t}\n\t}\n\tlong long int N;\n\twhile( cin >> N, N ) {\n\t\tpriority_queue<PLL, vector<PLL>, greater<PLL>>que, que2;\n\t\tque.push( make_pair( 0, N ) );\n\t\tset<PLL>SPLL;\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tif( now.second == 0 ) {\n\t\t\t\tcout << now.first << \" \";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong long int i = 0;\n\t\t\twhile( now.second >= X[i] ) {\n\t\t\t\tauto next = make_pair( now.first + 1, now.second - X[i] );\n\t\t\t\tif( SPLL.find( next ) == SPLL.end() ) {\n\t\t\t\t\tSPLL.insert( next );\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tque = que2;\n\t\tque.push( make_pair( 0, N ) );\n\t\tSPLL.clear();\n\t\twhile( que.size() ) {\n\t\t\tauto now = que.top(); que.pop();\n\t\t\tif( now.second == 0 ) {\n\t\t\t\tcout << now.first << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong long int i = 0;\n\t\t\twhile( now.second >= Y[i] ) {\n\t\t\t\tauto next = make_pair( now.first + 1, now.second - Y[i] );\n\t\t\t\tif( SPLL.find( next ) == SPLL.end() ) {\n\t\t\t\t\tSPLL.insert( next );\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// -*- coding: utf-8 -*-\n// Last-Updated : <2014/06/18 23:38:15 by samui>\n\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <climits>\n#define MP(a, b) make_pair(a, b)\n#define X first\n#define Y second\n#define rep(i,n) for(int (i) = 0; (i) < (int)(n); ++(i))\n#define rer(i,l,n) for(int (i) = l; (i) <= (int)(n); ++(i))\n#define reu(i,l,n) for(int (i) = l; (i) < (int)(n); ++(i))\ntemplate<typename T,typename U> inline void amin(T &x,U y){ if(y<x) x = y;}\ntemplate<typename T,typename U> inline void amax(T &x,U y){ if(x<y) x = y;}\ntemplate<typename TYPE,std::size_t SIZE>\nstd::size_t len(const TYPE (&array)[SIZE]){return SIZE;}\nint answer(int A);\nint main(int argc, char *argv[])\n{\n  int i;\n  while(std::cin>>i){\n    if(i == 0){\n      break;\n    }\n    answer(i);\n  }\n  return 0;\n}\nint answer(int A)\n{\n  \n  int N = A;\n  float e = 1000000;\n  rep(i,A){\n    if(  std::abs(i*(i+1)*(i+2)/6-A) <= e  ){\n      e = std::abs(i*(i+1)*(i+2)/6-A);\n      N = i;\n    }else{\n      N+=2; // N+1でいいが。\n      break;\n    }\n  }\n\n  std::vector<int> s(N);\n  std::vector<int> dp(A+1,1000000000);\n  std::vector<int> dp2(A+1,1000000000);\n  dp[0] = 0;\n  dp2[0] = 0;\n  rep(i,N){\n    s[i] = i*(i+1)*(i+2)/6;\n  }\n\n  rep(i,A+1){\n    rep(j,s.size()){\n      if(i-s[j]>=0){\n\tamin(dp[i],dp[i-s[j]]+1);\n      }\n      if(i-s[j]>=0 && s[j]%2 == 1){\n\tamin(dp2[i],dp2[i-s[j]]+1);\n      }\n    }\n  }\n\n  std::cout<<dp[A]<<\" \"<<std::flush;\n  std::cout<<dp2[A]<<std::endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, (n))\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nint main(){\n\tint N;\n\tint f[200];\n\tstatic int dp1[1000000], dp2[1000000];\n\trep(i, 200) f[i] = i*(i+1)*(i+2)/6;\n\tdp1[0] = dp2[0] = 0;\n\tREP(i, 1, 1000000){\n\t\tdp1[i] = dp2[i] = i;\n\t\tfor(int j=0; f[j]<=i; j++){\n\t\t\tdp1[i] = min(dp1[i], dp1[i-f[j]]+1);\n\t\t\tif(f[j]%2==1) dp2[i] = min(dp2[i], dp2[i-f[j]]+1);\n\t\t}\n\t}\n\twhile(cin >> N, N)\n\t\tcout << dp1[N] << \" \" << dp2[N] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1e7\n\nusing namespace std;\n\nint main(){\n\tvector<int> t(1,0),t1(1,0);\n\tint c=1;\n\twhile(t[c-1]<=(int)1e6){\n\t\tint temp;\n\t\ttemp=c*(c+1)*(c+2)/6;\n\t\tt.push_back(temp);\n\t\tif(temp%2==1 ){\n\t\t\tt1.push_back(temp);\n\t\t}\n\t\tc++;\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\t\n\t\tint num,num1;\n\t\tnum=distance(t.begin(),upper_bound(t.begin(),t.end(),n)-1);\n\t\tnum1=distance(t1.begin(),upper_bound(t1.begin(),t1.end(),n)-1);\n\n\t\tvector<vector<int> > s(num+1,vector<int>(n+1,INF));\n\t\tvector<vector<int> > s1(num1+1,vector<int>(n+1,INF));\n\t\t\n\t\tfor(int i=0;i<=n;i++){\n\t\t\ts[0][i]=0;\n\t\t\ts[0][i]=0;\n\t\t\ts[1][i]=i;\n\t\t\ts1[1][i]=i;\n\t\t}\n\t\tfor(int i=0;i<=num;i++) s[i][0]=0;\n\t\tfor(int i=0;i<=num1;i++) s1[i][0]=0;\n\n\t\tfor(int i=2;i<=num;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j-t[i]>=0){\n\t\t\t\t\ts[i][j]=min(s[i-1][j],s[i][j-t[i]]+1);\n\t\t\t\t}\n\t\t\t\telse s[i][j]=s[i-1][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=2;i<=num1;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j-t1[i]>=0){\n\t\t\t\t\ts1[i][j]=min(s1[i-1][j],s1[i][j-t1[i]]+1);\n\t\t\t\t}\n\t\t\t\telse s1[i][j]=s1[i-1][j];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tfor(int j=0;j<s[i].size();j++){\n\t\t\t\tif(s[i][j]==INF) cout << \"0\";\n\t\t\t\telse cout << s[i][j];\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << s[num][n] << \" \" << s1[num1][n] << endl;\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[10001],k=0,i,j,n;\n\n  for(i=1;i<191;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=c[j-b[i]]+1;\n\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint x,y;\nint m[1000005]={};\nint memo[1000005]={};\nvector<int> odd;\nvoid saiki(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << endl;\n  if(n==0) {\n    x=min(x,d);\n  }else if(n>0) {\n    for(i=1;m[i]<=n;i++);\n    i--;\n    //cout << i << \":\" << n << \":\" << m[i] << endl;\n    for(j=i;j>0;j--){\n      if(x>d+1){\n\tsaiki(n-m[j],d+1);\n      }\n    }\n  }\n}\nvoid saiki2(int n,int d){\n  int i,j;\n  //cout << n << \":\" << d << endl;\n  if(n==0) {\n    y=min(y,d);\n  }else if(n>0) {\n    for(i=0;odd[i]<=n;i++);\n    i--;\n    //cout << i << \":\" << n << \":\" << odd[i] << endl;\n    for(j=i;j>=0;j--){\n      if(y>d+1){\n\tsaiki2(n-odd[j],d+1);\n      }\n    }\n  }\n}\nint main(){\n  int i,j,k;\n  for(i=1;i<1000005;i++) {\n    m[i]=i*(i+1)*(i+2)/6;\n    if(m[i]%2==1) odd.push_back(m[i]);\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    x=1<<10;y=x;\n    saiki(n,0);saiki2(n,0);\n    cout << x << \" \" <<  y << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<typename T> using V = std::vector<T>;\nusing Vi = V<int>;\nusing VVi = V<V<int>>;\nusing Vl = V<ll>;\nusing VVl = V<V<ll>>;\nusing Vs = V<string>;\n\ntemplate<typename T1, typename T2> using P = std::pair<T1, T2>;\nusing Pii = P<int, int>;\nusing Pll = P<ll, ll>;\nusing Pdd = P<double, double>;\n\ntemplate<typename T1, typename T2> using M = std::map<T1, T2>;\nusing Mii = M<int, int>;\nusing Msi = M<string, int>;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REP2(i,s,e) for(int i=(int)(s);i<(int)(e);++i)\n#define RREP(i,s,e) for(int i=(int)(s);i>=(int)(e);--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin(),ie=(c).end();i!=ie;++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double PI = acos(-1);\nconst ll MOD = 1e9+7;\n\nint n;\nstring s;\n\nint main() {\n    Vi v, vodd;\n    int i = 1, val = i*(i+1)*(i+2)/6;\n    while (val < 1e6) {\n        v.push_back(val);\n        if (val%2 == 1) vodd.push_back(val);\n        i++; val = i*(i+1)*(i+2)/6;\n    }\n    Vl dp(1e6, 1e18), dpodd(1e6, 1e18);\n    dp[0] = 0; dpodd[0] = 0;\n    REP(i, 1e6) REP(j, v.size()) {\n        if (i >= v[j]) dp[i] = min(dp[i-v[j]]+1, dp[i]);\n    }\n    REP(i, 1e6) REP(j, vodd.size()) {\n        if (i >= vodd[j]) dpodd[i] = min(dpodd[i-vodd[j]]+1, dpodd[i]);\n    }\n\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        printf(\"%lld %lld\\n\", dp[n], dpodd[n]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main(){\n  int lim = 1e6;\n  vector<int> cube;\n  for(int i=1;;i++){\n    int c = i*(i+1)*(i+2)/6;\n    if(c>lim)break;\n    cube.push_back(c);\n  }\n\n  vector<int> dp1(lim+1,INF), dp2(lim+1,INF);\n  dp1[0] = dp2[0] = 0;\n\n  for(int i=1;i<=lim;i++){\n    for(int c : cube){\n      if(i+c<=lim){\n\tdp1[i+c] = min(dp1[i+c], dp1[i]+1);\n\tif(c%2==0){\n\t  dp2[i+c] = min(dp2[i+c], dp2[i]+1);\n\t}\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n){\n    if(n==0)break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n//Pollock's conjecture\n#include <bits/stdc++.h>\n#if LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\nusing namespace std;\nusing ll=long long;\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\ntemplate<class T>bool chmax(T &a, const T &b) {if (a<b) { a=b; return 1; } return 0;}\ntemplate<class T>bool chmin(T &a, const T &b) {if (b<a) { a=b; return 1; } return 0;}\nll calc_vol(ll n){\n\treturn n*(n+1)*(n+2)/6;\n}\nconstexpr ll INF=2LL<<60;\n\nint main(){\n#if LOCAL&01\n\tstd::ifstream in(\"./test/sample-1.in\");\n\t//std::ifstream in(\"./input.txt\");\n\tstd::cin.rdbuf(in.rdbuf());\n#else\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#endif\n\n\tll val=1e+6;\n\tll limit=1;\n\tvector<ll> vols0(2),vols1(2);\n\tvols0[0]=0; vols1[0]=0;\n\tvols0[1]=1; vols1[1]=1;\n\twhile(calc_vol(limit+1)<=val){\n\t\tauto v=calc_vol(limit+1);\n\t\tvols0.push_back(v);\n\t\tif(v%2==1)vols1.push_back(v);\n\t\tlimit++;\n\t}\n\n\tauto mktbl = [&val](vector<ll>& dp, const auto& vols){\n\t\tdp[0]=0;\n\t\tll lim = vols.size()-1;\n\t\tFOR(i,0,lim){\n\t\t\tll vol=vols.at(i+1);\n\t\t\tdump(vol);\n\t\t\tFOR(j,0,val+1){\n\t\t\t\tif(j-vol>=0)chmin(dp[j],dp[j-vol]+1);\n\t\t\t}\n\t\t}\n\t};\n\tvector<ll> dp0(val+1,INF);\n\tmktbl(dp0,vols0);\n\n\tvector<ll> dp1(val+1,INF);\n\tmktbl(dp1,vols1);\n\n\twhile(true){\n\t\tll t; cin>>t;\n\t\tif(t==0)break;\n\t\tcout<<dp0[t]<<\" \"<<dp1[t]<<endl;\n\t}\n\n\treturn 0;\n}\n\nll solve(const ll val){\n\tll limit=1;\n\twhile(calc_vol(limit+1)<=val){\n\t\tlimit++;\n\t}\n\tdump(limit,calc_vol(limit));\n\n\tvector<ll> dp(val+1,INF);\n\tdp[0]=0;\n\tFOR(i,0,limit+1){\n\t\tll vol=calc_vol(i+1);\n\t\tFOR(j,0,val+1){\n\t\t\t//chmin(dp[i+1][j],dp[i][j]);\n\t\t\tif(j-vol>=0)chmin(dp[j],dp[j-vol]+1);\n\t\t\t//if(j-vol>=0)chmin(dp[j],dp[j-vol]+1);\n\t\t}\n\t}\n\tdump(dp);\n\n\treturn dp[val];\n}\nll solve2(const ll val){\n\tll limit=1;\n\tvector<ll> vols(2);\n\tvols[0]=0;\n\tvols[1]=1;\n\twhile(calc_vol(limit+1)<=val){\n\t\tauto v=calc_vol(limit+1);\n\t\tif(v%2==1)vols.push_back(v);\n\t\tlimit++;\n\t}\n\tdump(limit,calc_vol(limit));\n\n\tvector<ll> dp(val+1,INF);\n\tdp[0]=0;\n\tlimit = vols.size()-1;\n\tFOR(i,0,limit){\n\t\t//ll n2=lim2i(i);\n\t\t//ll vol=calc_vol(n2);\n\t\tll vol=vols.at(i+1);\n\t\tdump(vol);\n\t\tFOR(j,0,val+1){\n\t\t\t//chmin(dp[i+1][j],dp[i][j]);\n\t\t\tif(j-vol>=0)chmin(dp[j],dp[j-vol]+1);\n\t\t\t//if(j-vol>=0)chmin(dp[j],dp[j-vol]+1);\n\t\t}\n\t}\n\tdump(dp);\n\n\treturn dp[val];\n}\nint main_() {\n#if LOCAL&01\n\tstd::ifstream in(\"./test/sample-1.in\");\n\t//std::ifstream in(\"./input.txt\");\n\tstd::cin.rdbuf(in.rdbuf());\n#else\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#endif\n\t//solve2(40); return 0;\n\twhile(true){\n\t\tll t; cin>>t;\n\t\tif(t==0)break;\n\t\tcout<<solve(t)<<\" \"<<solve2(t)<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX_N = 1e6;\nint dp[MAX_N + 1], dp_odd[MAX_N + 1];\n\nvoid Init()\n{\n    int nth = 1;\n    int tetra = 0;\n    for (int i = 1; i <= MAX_N; ++i)\n        dp[i] = dp_odd[i] = INF;\n\n    while (tetra <= MAX_N) {\n        tetra = (nth * (nth + 1) * (nth + 2)) / 6;\n        if (tetra % 2 == 0) {\n            for (int i = 0; i + tetra <= MAX_N; ++i)\n                dp[i + tetra] = min(dp[i + tetra], dp[i] + 1);\n        }\n        else {\n            for (int i = 0; i + tetra <= MAX_N; ++i) {\n                dp[i + tetra] = min(dp[i + tetra], dp[i] + 1);\n                dp_odd[i + tetra] = min(dp_odd[i + tetra], dp_odd[i] + 1);\n            }\n        }\n\n        nth++;\n    }\n}\n\nint main()\n{\n    Init();\n\n    int n;\n    while (cin >> n, n) {\n        cout << dp[n] << \" \" << dp_odd[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////ここまでOK\n    int dp[100000];\n    //fill(dp,dp + x + 1,100000);\n  \n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int  N = 1000100;\n\nint t1[200];\nint t2[200];\nint dp1[N] = {0};\nint dp2[N] = {0};\n\nint main(){\n\tint i,j,k=2,s;\n\t\n\tt1[1] = t2[1] = dp1[1] = dp2[1] = 1;\n\tfor(i = 2; i < 200; i++){\n\t\tt1[i] = t1[i-1] * (i+2) / (i-1);\n\t\tif(t1[i] > 1e+6) break;\n\t\tdp1[t1[i]] = 1;\n\t\tif(t1[i]%2){ dp2[t1[i]] = 1; t2[k++] = t1[i];}\n\t}\ncout << t2[199];\n\tfor(i = 2; i < N; i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j = 1; t2[j] < i && j < 200; j++){\n\t\t\tif((1 + dp2[i-t2[j]]) < (dp2[i])){\n\t\t\t\tdp2[i] = 1 + dp2[i-t2[j]];\n\t\t\t}\n\t\t}\n\t\tif(dp1[i]) continue;\n\t\tfor(j = 1; t1[j] < i; j++){\n\t\t\tif((1 + dp1[i-t1[j]]) < (dp1[i])){\n\t\t\t\tdp1[i] = 1 + dp1[i-t1[j]];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(cin >> s, s)\n\t\tcout << dp1[s] << ' ' << dp2[s] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int N,i=0,a,cnt=0;\n  int f[1000];\n  int dp[1000000],odp[1000000];\n  while(1){\n    f[i]=(i+1)*(i+2)*(i+3)/6;\n    if(f[i]>1000000) break;\n    cnt++;\n    i++;\n  }\n  dp[0]=0;dp[1]=1;\n  odp[0]=0;odp[1]=1;\n  for(int i=2;i<1000000;i++){\n    dp[i]=odp[i]=10000000;\n  }\n  for(int i=2;i<1000000;i++){\n    for(int j=0;j<cnt;j++){\n      if((i-f[j])<0) break;\n      else dp[i]=min(dp[i-f[j]]+1,dp[i]);\n    }\n  }\n  for(int i=2;i<1000000;i++){\n    for(int j=0;j<cnt;j++){\n      if((i-f[j])<0) break;\n      else if(j%4!=0) continue;\n      else odp[i]=min(odp[i-f[j]]+1,odp[i]);\n    }\n  }\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    cout<<dp[N]<<\" \"<<odp[N]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP_N(i,n,s) for(ll i=0; i<(ll)n; i+=s)\n#define REP(i,n) REP_N(i,n,1)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nvoid solution(ll output[1000001], int interval) {\n\toutput[0] = 0;\n\tll current_i = 1-interval;\n\tREP(i, 1000001) if (i != 0) {\n\t\tif (table[current_i + interval] == i) current_i += interval;\n\t\tll minimum = 1000001;\n\t\tREP_N(j, current_i+1, interval) if(j!=0) minimum = min(output[i - table[j]] + 1, minimum);\n\t\toutput[i] = minimum;\n\n\t}\n}\n\nint main() {\n\t\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i++]) table[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tsolution(pollock, 1);\n\tsolution(dp, 4);\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define M 1000000\n\nint odd[M + 10], all[M + 10];\n\nvoid update(int *ar, int x){\n\tfor(int i = x; i <= M; ++i){\n\t\tar[i] = min(ar[i], ar[i - x] + 1);\n\t}\n}\n\nint main(){\n\tfor(int i = 1; i <= M; ++i){\n\t\todd[i] = all[i] = 10000000;\n\t}\n\n\tfor(int i = 1; ; ++i){\n\t\tint x = i * (i + 1) * (i + 2) / 6;\n\t\tif(x > M){ break; }\n\t\tupdate(all, x);\n\t\tif(x & 1){ update(odd, x); }\n\t}\n\t\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tprintf(\"%d %d\\n\", all[n], odd[n]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nusing P = pair<int, int>;\nusing Iterator = vector<int>::iterator;\nvector<int> s;\nvector<int> odd_s;\n\nvoid make_shimentai(){\n    for(int i = 1; ; ++i){\n        int sum = i * (i + 1) * (i + 2) / 6;\n\n        if(sum >= 1000000) break;\n\n        s.emplace_back(sum);\n\n        if(sum % 2 == 1) odd_s.emplace_back(sum);\n    }\n}\n\nint bfs(const int v, Iterator it, vector<int> &s, const int ans){\n    // first:????¨????, second:?¶????????????°\n    queue<P> q;\n    q.push(make_pair(*it, 1));\n\n    while(!q.empty()){\n        P p = q.front(); q.pop();\n        if(p.first == v) return p.second;\n\n        for(Iterator it_ = s.begin(); it_ <= it; ++it_){\n            int sum = p.first + *it_;\n            if(sum <= v && p.second + 1 <= ans)\n                q.push(make_pair(sum, p.second + 1));\n        }\n    }\n    return INT_MAX;\n}\n\nint solve(const int v, vector<int> &s){\n    Iterator it = lower_bound(s.begin(), s.end(), v);\n    if(*it != v) it--;\n\n    int ans = INT_MAX;\n\n    for(;it != s.begin() - 1; --it){\n        ans = min(ans, bfs(v, it, s, ans));\n        if(ans == 1) break;\n    }\n\n    return ans;\n}\n\n/*int solve(const int v, vector<int> s){\n  decltype(s)::iterator it = lower_bound(s.begin(), s.end(), v);\n  if(*it != v) it--;\n\n  int ans = INT_MAX;\n  for(;it != s.begin()-1; it--){\n  vector<int>::iterator it_ = it;\n  int v_ = v;\n  int count = 0;\n  while(true){\n  if(v_ == 0) break;\n  if(v_ - *it_ < 0){\n  it_--;\n  continue;\n  }\n\n  v_ -= *it_;\n  count++;\n  if(ans < count) break;\n  }\n  ans = min(ans, count);\n  }\n\n  return ans;\n  }*/\n\nint main(){\n    make_shimentai();\n\n    while(true){\n        int v;\n        cin >> v;\n        if(v == 0) break;\n\n        int ans = solve(v, s);\n        cout << ans << \" \";\n        ans = solve(v, odd_s);\n        cout << ans << \"\\n\";\n    }\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\nconst int INF = 0x3fffffff;\n\nint vx[] = {1,0,-1,0}, vy[] = {0,1,0,-1};\n\nint main(){\n\tint N;\n\tint sq[300];\n\trep(i, 300){\n\t\tsq[i] = (ll)i*(i+1)*(i+2)/6;\n\t}\n\tsq[0] = INF;\n\tint memo[1000006]={};\n\tint modd[1000006]={};\n\tmemo[1] = 1;\n\tmodd[1] = 1;\n\tfor(int n=1; n<1000002; n++){\n\t\tint mn = INF, mn_o = INF;\n\t\trep(i,300){\n\t\t\tif( sq[i] > n ) continue;\n\t\t\tmn = min(mn, memo[ n-sq[i] ] + 1);\n\t\t\tif( sq[i]%2 == 1 ){\n\t\t\t\tmn_o = min(mn_o, modd[ n-sq[i] ] + 1);\n\t\t\t}\n\t\t}\n\t\tmemo[n] = mn;\n\t\tmodd[n] = mn_o;\n\t}\n\t//rep(i,20) cout << modd[i] << endl;\n\twhile(cin >> N, N){\n\t\tcout << memo[N] << \" \" << modd[N] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    int ans_tmp=0;\n    int ans2_tmp=0;\n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<=x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n    \n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  ans2_tmp=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  dp2[i+coin_ki[j]]=ans2_tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n    for(int i=0;i<count;i++)\n      printf(\"coin[%d]=%d\\n\",i,coin[i]);\n    for(int i=0;i<count_ki;i++)\n      printf(\"coin_ki[%d]=%d\\n\",i,coin_ki[i]);\n\n\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nll memo[250000];\nll memo2[250000];\n\nll calc(int n) {\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint dfs(int depth, int n) {\n  int ans = 9999;\n  if (n < 250000 && memo[n] != 0) return memo[n];\n  for (int i = n; i >= 1; i--) {\n    ll t = calc(i);\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < 250000) {\n\tmemo[n] = depth;\n      }\n      return depth;\n    }\n    ans = min(ans, dfs(depth + 1, n - t));\n  }\n  if (n < 250000)\n    memo[n] = ans;\n  return ans;\n}\n\nint dfs_odd(int depth, int n) {\n  int ans = 9999;\n  if (n < 250000 && memo2[n] != 0) return memo2[n];\n  for (int i = n; i >= 1; i--) {\n    if (i % 2 == 0) continue;\n    ll t = calc(i);\n    if (t % 2 == 0) continue;\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < 250000)\n\tmemo2[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs_odd(depth + 1, n - t));\n  }\n  if (n < 250000)\n    memo2[n] = ans;\n  return ans;\n}\n  \nint main() {\n  int N;\n  while (cin >> N, N != 0) {\n    for (int i = 0; i < 250000; i++) {\n      memo[i] = 0;\n      memo2[i] = 0;\n   }\n    cout << dfs(1, N) << \" \" << dfs_odd(1, N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint p[200],q[50],dp1[1000000],dp2[1000000],n;\n\nint main(){\n\trep(i,200)p[i]=(i+1)*(i+2)*(i+3)/6;\n\trep(i,50)q[i]=(4*i+1)*(4*i+2)*(4*i+3)/6;\n\tfor(int i=1;i<1e6;i++){\n\t\tdp1[i]=dp2[i]=INF;\n\t\trep(j,200)if(p[j]<=i)dp1[i]=min(dp1[i],dp1[i-p[j]]+1);\n\t\trep(j,50)if(q[j]<=i)dp2[i]=min(dp2[i],dp2[i-q[j]]+1);\n\t}\n\twhile(cin>>n&&n){\n\t\tcout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nint tetra(int n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint solve(int n)\n{\n  for(int i = 1; tetra(i) <= n; i++){\n    if(tetra(i) & 1)\n      dp2[tetra(i)] = 1;\n    dp[tetra(i)] = 1;\n  }\n  for(int i = 1; i <= n; i++)\n    for(int j = i; j <= n; j++)\n      if(dp[j] == i || dp2[j] == i)\n        for(int k = 1; j + tetra(k) <= n; k++){\n          if((dp2[j] != MAX) && (tetra(k) & 1))\n            dp2[j + tetra(k)] = min(i + 1, dp2[j + tetra(k)]);\n          dp[j + tetra(k)] = min(i + 1, dp[j + tetra(k)]);\n        }\n}\n\nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing ll = long long;\nconst ll inf = 1e8;\nconst ll co = 1000005;\n\nll dp[2][1000005];\n\nint main() {\n    rep(i,2)rep(j,co) dp[i][j] = inf;\n    dp[0][0] = dp[1][0] = 0;\n    for (int i = 1; i*(i+1)*(i+2)/6 < co; i++) {\n        int l = i*(i+1)*(i+2)/6;\n        for (int j = 1; j <= co; j++) {\n            if (j >= l) dp[0][j] = min(dp[0][j],dp[0][j-l]+1);\n        }\n        if (l&1) {\n            for (int j = 1; j <= co; j++) {\n                if (j >= l) dp[1][j] = min(dp[1][j],dp[1][j-l]+1);\n            }\n        }\n    }\n\n    while (true) {\n        int x;\n        cin >> x;\n        if (x == 0) break;\n        cout << dp[0][x] << \" \" << dp[1][x] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int INF = 1000000007;\n    int MAX = 1000100;\n\n    vector<int> pollock;\n    vector<int> dp(MAX, INF);\n    vector<int> oddDp(MAX, INF);\n    for (int i = 1; i <= int(pow(6 * MAX, 1.0 / 3.0)); i++) {\n        pollock.push_back(i * (i + 1) * (i + 2) / 6);\n    }\n    dp[0] = 0;\n    oddDp[0] = 0;\n    for (int i = 0; i <= MAX; i++) {\n        for (int j = 0; j < pollock.size(); j++) {\n            if (i + pollock[j] > MAX) continue;\n            dp[i + pollock[j]] = min(dp[i] + 1, dp[i + pollock[j]]);\n            if (pollock[j] % 2 == 1) {\n                oddDp[i + pollock[j]] = min(oddDp[i] + 1, oddDp[i + pollock[j]]);\n            }\n        }\n    }\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) break;\n        cout << dp[n] << \" \" << oddDp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\n\ntypedef vector<int> vi;\nint const inf = 1 << 28;\nint main(){\n    vi q, r;\n    for (int i = 1;; i++){\n        int pq = i*(i + 1)*(i + 2) / 6;\n        q.push_back(pq);\n        if (pq & 1) r.push_back(pq);\n\n        if (pq > 1e6 + 100) break;\n    }\n\n    int n;\n    while (cin >> n && n){\n\n        vi dp(n + 1,inf);\n        dp[0] = 0;\n        rep(i, q.size()){\n            rep(j, n+1){\n                if (j - q[i] >= 0){\n                    dp[j] = min(dp[j], dp[j - q[i]] + 1);\n                }\n            }\n        }\n        cout << dp[n] << \" \";\n\n\n        vi dp2(n + 1, inf);\n        dp2[0] = 0;\n        rep(i, r.size()){\n            rep(j, n + 1){\n                if (j - r[i] >= 0){\n                    dp2[j] = min(dp2[j], dp2[j - r[i]] + 1);\n                }\n            }\n        }\n        cout << dp2[n] << endl;\n    }\n    \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1000001];\nint memo2[1000001];\n \nint solve(int n){\n\n  if(!n) return 0;\n  if(memo[n]) return memo[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n; i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(memo2[n]) return memo2[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++){\n    if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n  }\n   \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  for(int i=0;i<=181;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i+=100) solve(i), solve2(i);\n   \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 10e8\n#define INF 1<<30\n#define MOD 1000000007\n#define mod 998244353\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    \n    int dp[1000100],dpodd[1000100];\n    for(int i=0;i<1000100;i++){\n        dp[i]=INF;\n        dpodd[i]=INF;\n    }\n    dp[0]=0;\n    dpodd[0]=0;\n        for(int i=1;;i++){\n            ll y=i*(i+1)*(i+2)/6;\n            if(y>1e6)break;\n            for(int j=y;j<1000100;j++){\n                chmin(dp[j],dp[j-y]+1);\n                if(y%2!=0)chmin(dpodd[j],dpodd[j-y]+1);\n            }\n        }\n    int n;cin>>n;\n    while(n){\n        cout<<dp[n]<<\" \"<<dpodd[n]<<Endl;\n        cin>>n;\n    }\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    long long i;\n    int n;\n    long long j = 0;\n    int a[84];\n    int b[22];\n    long long t[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#define N 1000000\n\nusing namespace std;\n\nint main(){\n\tvector<int> sq;\n\tvector<int> sqodd;\n\tint a[N];\n\tint aodd[N];\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++)  sq.push_back((i * (i + 1) * (i + 2)) / 6);\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++){\n\t\tif(((i * (i + 1) * (i + 2)) / 6) % 2)\n\t\t \tsqodd.push_back((i * (i + 1) * (i + 2)) / 6);\n\t}\n\tfor(int i = 0; i < N; i++) a[i] = N;\n\tfor(int i = 0; i < N; i++) aodd[i] = N;\n\tfor(int i = 0; i < sq.size(); i++) a[sq[i]] = 1;\n\tfor(int i = 0; i < sqodd.size(); i++) aodd[sqodd[i]] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tif(a[i] == N) continue;\n\t\tfor(int j = 0; j < sq.size(); j++){\n\t\t\tif(sq[j] + i < N && a[sq[j] + i] > a[i] + 1) a[sq[j] + i] = a[i] + 1;\n\t\t}\n\t}\n\tfor(int i = 1; i < N; i++){\n\t\tif(aodd[i] == N) continue;\n\t\tfor(int j = 0; j < sqodd.size(); j++){\n\t\t\tif(sqodd[j] + i < N && aodd[sqodd[j] + i] > aodd[i] + 1) aodd[sqodd[j] + i] = aodd[i] + 1;\n\t\t}\n\t}\t\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << a[n] << \" \" << aodd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ1167\n//\n//  Created by aki33524 on 2014/07/09.\n//  Copyright (c) 2014年 aki33524. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 1000000;\nconst int MAX_T = 200;\n\nvector<int> tetras;\nvector<int> oddtetras;\nint dp1[MAX_T + 1][MAX_N];\nint dp2[MAX_T + 1][MAX_N];\n\nvoid init(){\n    memset(dp1, 0x3f, sizeof(dp1));\n    memset(dp2, 0x3f, sizeof(dp2));\n    \n    for(int i=0; i<MAX_T; i++){\n        int t = i*(i+1)*(i+2)/6;\n        tetras.push_back(t);\n        if(t%2)\n            oddtetras.push_back(t);\n    }\n    \n    for(int i=0; i<tetras.size(); i++)\n        dp1[0][tetras[i]] = 1;\n    for(int i=0; i<tetras.size(); i++){\n        int t = tetras[i];\n        for(int j=0; j<MAX_N; j++){\n            if(j < t){\n                dp1[i+1][j] = dp1[i][j];\n            }else{\n                dp1[i+1][j] = min(dp1[i][j], dp1[i+1][j-t]+1);\n            }\n        }\n    }\n    \n    for(int i=0; i<oddtetras.size(); i++)\n        dp2[0][oddtetras[i]] = 1;\n    for(int i=0; i<oddtetras.size(); i++){\n        int t = oddtetras[i];\n        for(int j=0; j<MAX_N; j++){\n            if(j < t){\n                dp2[i+1][j] = dp2[i][j];\n            }else{\n                dp2[i+1][j] = min(dp2[i][j], dp2[i+1][j-t]+1);\n            }\n        }\n    }\n}\n\nint main(int argc, const char * argv[])\n{\n    init();\n    \n    int N;\n    while(cin>>N, N){\n        cout << dp1[tetras.size()][N] << \" \" << dp2[oddtetras.size()][N] << endl;;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000000\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[MAXNUM], fourodd[MAXNUM];\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n\tint n;\n\tint counter = 0;\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 0, oddcounter = 0;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t}\n\t//cout << fourall[allcounter - 1] << endl;\n\t//cout << \"ok\" << endl;\n\t//cout << allcounter << endl;\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tfor (int j = 0; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\t\t//cout << i << \":\" << all[i]<<endl;\n\n\t\tfor (int j = 0; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t//cout << \"aaa\" << endl;\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////ここまでOK\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n      \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000000\nusing namespace std;\n\nint main(){\n int pol[201],ans[N],ans2[N];\n\n for(int i=0;i<N;i++)ans[i]=ans2[i]=N;\n for(int i=1;i<201;i++){\n   pol[i]=i*(i+1)*(i+2)/6;\n   if(pol[i]<N){\n     ans[pol[i]]=1;\n   if(pol[i]%2)ans2[pol[i]]=1;\n   }\n }\n for(int i=1;i<=N;i++)\n   for(int j=1;j<201;j++){\n     if(i-pol[j]>=0 && pol[j]<N) ans[i]=min(ans[i-pol[j]]+ans[pol[j]],ans[i]);\n     if(i-pol[j]>=0 && pol[j]%2 && pol[j]<N)ans2[i]=min(ans2[i-pol[j]]+ans2[pol[j]],ans2[i]);\n   }\n while(1){\n   \n  int n;\n   cin>>n;\n   if(n==0) break;\n  cout<<ans[n]<<\" \"<<ans2[n]<<endl;\n }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n \nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef long long LL;\ntypedef priority_queue<int> PQ_DESC;\ntypedef priority_queue<int, vector<int>, greater<int>> PQ_ASC;\ntypedef priority_queue<PII> PQ_DESC_PII;\ntypedef priority_queue<PII, vector<PII>, greater<PII>> PQ_ASC_PII;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVLL> VVVLL;\n\n#define SORT_ASC(c) sort((c).begin(), (c).end())\n#define SORT_DESC(c) sort((c).begin(), (c).end(), greater<typeof((c).begin())>())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define FORL(i,a,b) for(LL i=(a);i<(b);++i)\n#define REPL(i,n)  FORL(i,0,n)\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n //debug func\ntemplate<typename T>\nvoid vprint(vector<T> v) {\n    for(auto x : v) {\n        cerr << x << \" \";\n    }\n    cerr << endl;\n}\n \ntemplate<typename T>\nvoid vvprint(vector<vector<T>> vv) {\n    REP(i, SIZE(vv)) {\n        REP(j, SIZE(vv[i])) {\n            cerr << vv[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n}\n\ntemplate <typename Iterator>\ninline bool next_combination(const Iterator first, Iterator k, const Iterator last)\n{\n   /* Credits: Thomas Draper */\n   if ((first == last) || (first == k) || (last == k))\n      return false;\n   Iterator itr1 = first;\n   Iterator itr2 = last;\n   ++itr1;\n   if (last == itr1)\n      return false;\n   itr1 = last;\n   --itr1;\n   itr1 = k;\n   --itr2;\n   while (first != itr1)\n   {\n      if (*--itr1 < *itr2)\n      {\n         Iterator j = k;\n         while (!(*itr1 < *j)) ++j;\n         iter_swap(itr1,j);\n         ++itr1;\n         ++j;\n         itr2 = k;\n         rotate(itr1,j,last);\n         while (last != j)\n         {\n            ++j;\n            ++itr2;\n         }\n         rotate(k,itr2,last);\n         return true;\n      }\n   }\n   rotate(first,k,last);\n   return false;\n}\n\ninline double get_time_sec(void){\n    return static_cast<double>(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count())/1000000000;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    if(a > b) swap(a, b);\n    if(a == 0) return b;\n    else return gcd(b%a, a);\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return (a / gcd(a, b)) * b;\n}\n\ntemplate<typename T>\nmap<T, T> prime_list(T n) {\n    map<T, T> ret;\n    for(T i = 2; i*i <= n; i++) {\n        if(n % i == 0) {\n            ret[i] = 0;\n            while(n % i == 0) {\n                n /= i;\n                ret[i]++;\n            }\n        }\n    }\n    if(n != 1) ret[n]++;\n    return ret;\n}\n\n#define MOD 1000000007\n\nLL mypow(LL a, LL n) {\n    if(n == 1) return a % MOD;\n    if(n % 2 == 1) return (a * mypow(a, n-1)) % MOD;\n    LL t = mypow(a, n/2);\n    return (t * t) % MOD; \n}\n\nLL mycomb(LL n, LL k) {\n    if(n == 0 || n == k) return 1;\n    LL x = 1, y = 1;\n    REP(i, k) {\n        x = x * (n-i) % MOD;\n        y = y * (i+1) % MOD;\n    }\n    return x * mypow(y, MOD - 2) % MOD;\n}\n\n#define MAXNUM 1000001\n\nint main(void) {\n    int N = 180;\n    VI a(N, 0), b;\n    REP(i, N) a[i] = (i+2) * (i+1) / 2;\n    FOR(i, 1, N) a[i] += a[i-1];\n    REP(i, N) if(a[i] % 2 == 1) b.push_back(a[i]);\n    // vprint(b);\n    VI dp1(MAXNUM, 0), dp2(MAXNUM, 0);\n    iota(ALL(dp1), 0);\n    iota(ALL(dp2), 0);\n    FOR(i, 1, N) {\n        FOR(j, a[i], MAXNUM) dp1[j] = min(dp1[j], dp1[j - a[i]] + 1);\n    }\n    FOR(i, 1, b.size()) {\n        FOR(j, b[i], MAXNUM) dp2[j] = min(dp2[j], dp2[j - b[i]] + 1);\n    }\n    // vprint(dp1);\n    // vprint(dp2);\n\n    // VVI dp3(N/2, VI(MAXNUM, 0));\n    // iota(ALL(dp3[0]), 0);\n    // FOR(i, 1, N/2) {\n    //     REP(j, MAXNUM) {\n    //         if(j >= b[i]) {\n    //             dp3[i][j] = dp3[i-1][j];\n    //             for(int k = 1; j - k * b[i] >= 0; k++) {\n    //                 dp3[i][j] = min(dp3[i][j], dp3[i-1][j - k * b[i]] + k);\n    //             }\n    //         }\n    //         else dp3[i][j] = dp3[i-1][j];\n    //     }\n    // }\n    // vvprint(dp3);\n\n\n    while(1) {\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tvector<int> dp1(1000000,1000000);\n\tdp1[0] = 0;\n\tvector<int> dp2(1000000,1000000);\n\tdp2[0] = 0;\n\tfor(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n\t\tint x = i*(i+1)*(i+2)/6;\n\t\tfor(int j=0;j<1000000-x;j++){\n\t\t\tdp1[j+x] = min(dp1[j+x],dp1[j] + 1);\n\t\t\tif(x%2 == 1) dp2[j+x] = min(dp2[j+x],dp2[j] + 1);\n\t\t}\n\t}\n\t\n\tint a;\n\twhile(cin >> a,a > 0){\n\t\tcout << dp1[a] << \" \" << dp2[a] << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate<class T>\nvoid print_vector (std::vector<T>* v)\n{\n    std::cout << std::endl;\n    for (T& e: *v)\n    {\n        std::cout << e << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint tetrahedral_number (int n)\n{\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\nint tetrahedral_number (std::vector<int>* vec, std::vector<int>* indices)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i] * tetrahedral_number ((*indices)[i]);\n    }\n\n    return num;\n}\n\nint tetrahedral_number (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i] * tetrahedral_number (i + 1);\n    }\n    return num;\n}\n\nint vector_sum (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i];\n    }\n\n    return num;\n}\n\nstd::vector<int>* approx_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n\n    while (tmp_n != 0)\n    {\n\n        int i = 0;\n\n        while (i++, tetrahedral_number (i + 1) <= tmp_n);\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (i);\n        }\n\n        (*solution)[i-1] = (*solution)[i-1] + 1;\n\n\n        tmp_n = tmp_n - tetrahedral_number (i);\n\n    }\n\n\n    return solution;\n}\n\nstd::vector<int>* improve_pollock_solution (std::vector<int>* base, int total)\n{\n\n    int dim = base->size ();\n\n    auto iterated_v = new std::vector<int> (*base);\n\n    std::vector<int>* solution = base;\n\n    int vsum = 0;\n\n    int approx_sum = 5;\n\n    while ((vsum = vector_sum (iterated_v)) > 0)\n    {\n\n        if (tetrahedral_number (iterated_v) == total && vsum <= approx_sum)\n        {\n            if (vector_sum (solution) > vsum)\n            {\n                solution = new std::vector<int> (*iterated_v);\n                approx_sum = vsum;\n                //return solution;\n            }\n        }\n\n\n        if ((*iterated_v)[0] > 0)\n        {\n            (*iterated_v)[0] = (*iterated_v)[0] - 1;\n        }\n        else\n        {\n            for (int index = 1; index < dim; index++)\n            {\n                if ((*iterated_v)[index] != 0)\n                {\n                    (*iterated_v)[index] = (*iterated_v)[index] - 1;\n\n                    for (index = index - 1; index >= 0; index--)\n                    {\n                        (*iterated_v)[index] = approx_sum - vector_sum (iterated_v);\n                    }\n\n                    int i = 0;\n                    for (i = dim - 1; i > 0; i--)\n                    {\n                        if ((*iterated_v)[i] != 0)\n                        {\n                            break;\n                        }\n                    }\n\n                    if (tetrahedral_number (i+1) * approx_sum < total)\n                    {\n                        return solution;\n                    }\n\n                    break;\n                }\n            }\n\n        }\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* approx_odd_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    while (tmp_n != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= tmp_n; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (cnt);\n        }\n\n        (*solution)[cnt-1] = (*solution)[cnt-1] + 1;\n\n        tmp_n = tmp_n - tetrahedral_number (odd_i);\n\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* improve_odd_pollock_solution (std::vector<int>* base, int total)\n{\n\n    int dim = base->size ();\n\n    auto iterated_v = new std::vector<int> (*base);\n\n    std::vector<int>* solution = base;\n\n\n    auto tetra_indices = new std::vector<int> (dim);\n\n    int n_copy = total;\n\n    while (n_copy != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= n_copy; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n\n        (*tetra_indices)[cnt-1] = odd_i;\n\n        int tetra_num = tetrahedral_number (odd_i);\n\n        while (n_copy >= tetra_num)\n        {\n            n_copy = n_copy - tetra_num;\n        }\n\n    }\n\n    int vsum = 0;\n\n    int approx_sum = vector_sum (iterated_v);\n\n    while ((vsum = vector_sum (iterated_v)) > 0)\n    {\n\n        if (tetrahedral_number (iterated_v, tetra_indices) == total)\n        {\n\n            if (vector_sum (solution) > vsum)\n            {\n                solution = new std::vector<int> (*iterated_v);\n                approx_sum = vsum;\n            }\n        }\n\n\n        if ((*iterated_v)[0] > 0)\n        {\n            (*iterated_v)[0] = (*iterated_v)[0] - 1;\n        }\n        else\n        {\n            for (int index = 1; index < dim; index++)\n            {\n                if ((*iterated_v)[index] != 0)\n                {\n                    (*iterated_v)[index] = (*iterated_v)[index] - 1;\n\n                    for (index = index - 1; index >= 0; index--)\n                    {\n                        (*iterated_v)[index] = approx_sum - vector_sum (iterated_v);\n                    }\n\n                    int i = 0;\n                    for (i = dim - 1; i > 0; i--)\n                    {\n                        if ((*iterated_v)[i] != 0)\n                        {\n                            break;\n                        }\n                    }\n\n                    if (tetrahedral_number ((*tetra_indices)[i+1]) * approx_sum < total)\n                    {\n                        return solution;\n                    }\n\n                    break;\n                }\n            }\n\n        }\n    }\n\n\n\n    return solution;\n\n}\n\nint main ()\n{\n\n    int n = 0;\n    while (std::cin >> n, n != 0)\n    {\n\n\n        auto b = approx_least_number_by_tetrahedral (n);\n\n        int normal = vector_sum (b);\n\n        if (normal > 5)\n        {\n            auto s = improve_pollock_solution (b,n);\n        \n            normal = vector_sum (s);\n        }\n\n        auto ob = approx_odd_least_number_by_tetrahedral (n);\n\n        auto os = improve_odd_pollock_solution (ob, n);\n\n        int odd =vector_sum (os);\n\n        std::cout << normal << \" \" << odd <<  std::endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst int M=1000000;\nint dp[M],DP[M];\n\nint main(){\n\tfill(dp+1,dp+M,inf);\n\tfill(DP+1,DP+M,inf);\n\tfor(int i=1;i*(i+1)*(i+2)/6<=M;i++){\n\t\tint t=i*(i+1)*(i+2)/6;\n\t\tfor(int j=t;j<M;j++) if(dp[j-t]!=inf) dp[j]=min(dp[j],dp[j-t]+1);\n\t\tif(t%2==1) for(int j=t;j<M;j++) if(DP[j-t]!=inf) DP[j]=min(DP[j],DP[j-t]+1);\n\t}\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<dp[n]<<' '<<DP[n]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define pint pair<int,int>\n\nconst int MAX_N = 2e6;\nconst int inf = 1LL << 60;\n\nvector<int> candi;\nvector<int> odd;\n\nint DPA[MAX_N],DPB[MAX_N];\n\nvoid chmin(int &a, int b){ \n  if( a > b ){ swap(a,b);} return;\n}\n\nvoid init(){\n  \n  for(int i = 1; (i*(i+1)*(i+2))/6 < MAX_N; i++){\n    int num = i*(i+1)*(i+2);\n    num /= 6;\n    candi.push_back(num);\n    if(num%2){\n      odd.push_back(num);\n    }\n  }\n  \n  \n  int a = candi.size();\n  int b = odd.size();\n  \n  \n  for(int i = 0; i < MAX_N; i++){\n    DPA[i] = inf; DPB[i] = inf;\n  }\n  \n  for(int i = 0; i < a; i++){\n    DPA[candi[i]] = 1;\n  }\n  \n  for(int i = 0; i < b; i++){\n    DPB[odd[i]] = 1;\n  }\n   \n  DPA[0] = 0; DPB[0] = 0;\n  \n  for(int i = 1; i < MAX_N; i++){\n   \n    for(int j = 0; j < a; j++){ \n      if(i-candi[j] >= 0 ){ \n       chmin(DPA[i],DPA[i-candi[j]]+1);\n      }\n    }\n    \n  }\n  \n  for(int i = 1; i < MAX_N; i++){\n    \n    for(int j = 0; j < b; j++){\n      if(i-odd[j] >= 0 ){\n        chmin(DPB[i],DPB[i-odd[j]]+1);\n      }\n    }\n  }\n  \n  return ;\n}\n  \n    \n\nsigned main(void){\n  int N; \n  init();\n  while(cin >> N){\n    if( N == 0 ){ return 0;}\n    \n    cout << DPA[N] << \" \" << DPB[N] << endl;\n    \n  }\n  \n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(y,x,h,w) (0<=y && y<h && 0<=x && x<w)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef string str;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vd> vvd;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1,0,1,0 }; const int dy[] = { 0,1,0,-1 };\n\nint main() {\n\tvi sikaku;\n\tvi sikaku2;\n\tint cnt = 1;\n\twhile (cnt*(cnt + 1)*(cnt + 2) / 6 <= 1000000) {\n\t\tsikaku.push_back(cnt*(cnt + 1)*(cnt + 2) / 6);\n\t\tif (cnt*(cnt + 1)*(cnt + 2) / 6 % 2 == 1)\n\t\t\tsikaku2.push_back(cnt*(cnt + 1)*(cnt + 2) / 6);\n\t\tcnt++;\n\t}\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tvi memo(n + 1, 1e9);\n\t\tvi memo2(n + 1, 1e9);\n\t\tmemo[n] = 0;\n\t\tmemo2[n] = 0;\n\t\tqueue<int> Q;\n\t\tQ.push(n);\n\t\twhile (!Q.empty()) {\n\t\t\tint q = Q.front(); Q.pop();\n\t\t\tif (q == 0)\n\t\t\t\tbreak;\n\t\t\tREP(i, sikaku.size()) {\n\t\t\t\tif (q >= sikaku[i]) {\n\t\t\t\t\tif (memo[q - sikaku[i]] > memo[q] + 1) {\n\t\t\t\t\t\tmemo[q - sikaku[i]] = memo[q] + 1;\n\t\t\t\t\t\tQ.push(q - sikaku[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<int> Q2;\n\t\tQ2.push(n);\n\t\twhile (!Q2.empty()) {\n\t\t\tint q = Q2.front(); Q2.pop();\n\t\t\tif (q == 0)\n\t\t\t\tbreak;\n\t\t\tREP(i,sikaku2.size()) {\n\t\t\t\tif (q >= sikaku2[i]) {\n\t\t\t\t\tif (memo2[q - sikaku2[i]] > memo2[q] + 1) {\n\t\t\t\t\t\tmemo2[q - sikaku2[i]] = memo2[q] + 1;\n\t\t\t\t\t\tQ2.push(q - sikaku2[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << memo[0] << \" \" << memo2[0] << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define Rep(b, e, i) for(int i = b; i <= e; i++)\n#define Repr(e, b, i) for(int i = e; i >= b; i--)\n#define rep(n, i) Rep(0, n-1, i)\n#define repr(n, i) Repr(n-1, 0, i)\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define uniq(x) (x).erase(unique(all(x)),(x).end())\n\ntypedef long long ll;\ntypedef pair<ll, ll> llP;\ntypedef pair<int, int> intP;\ntypedef std::priority_queue<int> IntPrioQueue; //Z->A\ntypedef std::priority_queue<int, std::vector<int>, std::greater<int> > IntReversePrioQueue; //A->Z\n\nconst int MAX = 1000010;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = 1<<29;\nconst int MOD = 1000000007;\n\nvector <int> sq, odsq;\nint N, mn[MAX], od[MAX];\n\nvoid solve(void){\n    int n = 1;\n    fill(mn, mn+MAX, INF);\n    fill(od, od+MAX, INF);\n    mn[0] = od[0] = 0;\n    while(n*(n+1)*(n+2)/6<MAX) {\n        sq.pb(n*(n+1)*(n+2)/6);\n        mn[n*(n+1)*(n+2)/6] = 1;\n        if (n*(n+1)*(n+2)/6%2) {\n            odsq.pb(n*(n+1)*(n+2)/6);\n            od[n*(n+1)*(n+2)/6] = 1;\n        }\n        n++;\n    }\n    Rep(1, MAX-1, k) {\n        int mini = INF, miniod = INF;\n        for (int q : sq) {\n            if (q >= k) break;\n            mini = min(mini, k/q + mn[k%q]);\n        }\n        for (int q : odsq) {\n            if (q >= k) break;\n            miniod = min(miniod, k/q + od[k%q]);\n        }\n        mn[k] = min(mini, mn[k]);\n        od[k] = min(miniod, od[k]);\n    }\n    while (1) {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) break;\n        printf(\"%d %d\\n\", mn[N], od[N]);\n    }\n}\n\nint main(void){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define invrepr(i,a,b) for(int i=b-1;i>=a;i--)\n#define invrep(i,n) invrepr(i,0,n)\n#define repitr(itr,a) for(auto itr=a.begin();itr!=a.end();++itr)\nconst int MOD=1e9+7;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    vector<int> dp(1000010,1e9),odddp(1000010,1e9);\n    dp[0]=0;\n    odddp[0]=0;\n    repr(i,1,1010) {\n        int a=i*(i+1)*(i+2)/6;\n        rep(j,1000010) {\n            if (j>=a) dp[j]=min(dp[j],dp[j-a]+1);\n            if (a%2==1 && j>=a) odddp[j]=min(odddp[j],odddp[j-a]+1); \n        }\n    }\n    // rep(i,50) cout << dp[i] << endl;\n    while (1) {\n        int n;\n        cin >> n;\n        if (n==0) break;\n        cout << dp[n] << ' ' << odddp[n] << endl;\n    }\n    return 0;   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\t\n\tint min0[1000000];\n\tint min1[1000000];\n\tfill(min0,min0+1000000,100);\n\tfill(min1,min1+1000000,100);\n\n\tfor(int j=1;j<300;j++){\n\t\tint n = j*(j+1)*(j+2)/6;\n\t\tif( n>=1000000) break;\n\t\tmin0[n] = 1;\n\t\tif((n%2)==1){\n\t\t\tmin1[n] = 1;\n\t\t}\n\t}\n\n\n\tfor(int i=1;i<1000000;i++)\n\t{\n\t\tfor(int j=1;j<300;j++){\n\t\t\tint n = j*(j+1)*(j+2)/6;\n\t\t\tif( n+i>=1000000) break;\n\t\t\tmin0[n+i] = min( min0[n+i], min0[i]+1);\n\t\t\tif( (n%2)==1){\n\t\t\t\tmin1[n+i] = min( min1[n+i], min1[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tcout << min0[n] << \" \" << min1[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 1000000\nusing namespace std;\nint ans1[MAX+10],ans2[MAX+10],box[300];\nvoid tab_make(){\n\tfor(int i=1;;i++){\n\t\tbox[i]=(i*(i+1)*(i+2)/6);\n\tif(i*(i+1)*(i+2)/6>MAX)\n\t\tbreak;\n\t}\n}\nvoid ans_make(){\n\tans1[0]=ans2[0]=0;\n\tfor(int i=1;i<=MAX;i++){\n\t\tans1[i]=ans2[i]=i;\n\t\tfor(int j=1;i-box[j]>=0;j++){\n\t\t\tans1[i]=min(ans1[i],ans1[i-box[j]]+1);\n\t\t\tif(box[j]%2==1)\n\t\t\tans2[i]=min(ans2[i],ans2[i-box[j]]+1);\n\t\t}\n\t}\n}\nint main(){\n\tint x;\n\ttab_make();\n\tans_make();\n\twhile(cin>>x,x){\n\t\tcout<<ans1[x]<<' '<<ans2[x]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[1000];//正四面体数\nvector<ll>v;\nll dp[1000000],dp2[1000000];\nint main() {\n\tv.pb(1);\n\tll n,now=1;\n\trep(i, 1000) {\n\t\tss[i] = (ll)i*(i + 1)*(i + 2) / 6;\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 100000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 100000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\t\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], i / v[j] + dp2[i%v[j]]);\n\t\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <cmath>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#define FOR(i, a) for(i = 0; i < (a); i++)\n#define FORM(i, a) for(i = (a) i >= 0; i--)\n#define INF 100000\nusing namespace std;\nint c[1000], odd[1000];\nint mini[200];\n\nint main(){\nint i, j, W, minimum, l;\n \n\n   for(i = 1; i <= 200; i++){\n\t   c[i] = (i*(i+1)*(i+2))/6;\n   }\n   j = 1;\n   for(i = 1; i <= 200; i++){\n\t   if(c[i] % 2 == 1){\n\t\t   odd[j] = c[i];\n\t\t   j += 1;\n\t   }\n   }\n\n\n   cin >> W;\n\n   while(W != 0){\n\t   minimum = 10000000;\n\t   for(i = 1; i <= 200; i++){\n\t\t   l = W;\n\t\t   if(c[i] > W){\n\t\t\t   break;\n\t\t   }\n\t\t for(j = i; j > 0; j--){\n\t\t\t mini[i] += l / c[j];\n\t\t\t l %= c[j];\n\t\t\t\n\t\t }\n\n\t\t  minimum = min(minimum, mini[i]);\n\t   }\n\n\t   cout << minimum << \" \";\n\t   minimum = 100000000;\n\t   FOR(i, 200){\n\t\t   mini[i] = 0;\n\t   }\n\t      for(i = 1; i <= 200; i++){\n\t\t\t  l = W;\n\t\t   if(odd[i] > W){\n\t\t\t   break;\n\t\t   }\n\t\t for(j = i; j > 0; j--){\n\t\t\t mini[i] += l/odd[j];\n\t\t\t l %= odd[j];\n\t\t\t\n\t\t }\n\n\t\t  minimum = min(minimum, mini[i]);\n\t   }\n\t\t  \n     cout << minimum << endl;\n\t   FOR(i, 200){\n\t\t   mini[i] = 0;\n\t   }\n       \n\t   cin >> W;\n\n   }\n   \n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nint main(){\n    int n,m=0;\n    vector<int>v;\n    for(int i=1;(i*(i+1)*(i+2))/6 < 1e6;++i){\n        v.push_back((i*(i+1)*(i+2))/6);\n        m++;\n    }\n    vector<int>dp(1e6,1e9);\n    vector<int> dp1(1e6, 1e9);\n    dp[0] = 0;\n    dp1[0] = 0;\n    for (int i = 0; i <= 1e6; ++i)\n    {\n        for (int j = 0; j < m; ++j)\n        {\n            if (i + v[j] >= 1e6)\n                break;\n            dp[i + v[j]] = min(dp[i] + 1, dp[i + v[j]]);\n            if (v[j] % 2 == 0)\n                continue;\n            dp1[i + v[j]] = min(dp1[i] + 1, dp1[i + v[j]]);\n        }\n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<dp1[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF (1<<28)\n\nint t[1000*1000+1];\nint ot[1000*1000+1];\n\nvoid init() {\n    memset(t, -1, sizeof(t));\n    memset(ot, -1, sizeof(ot));\n    for (int i = 1; ; i++) {\n        int n = i * (i+1) * (i+2) / 6;\n        if (n > 1000*1000) break;\n        t[n] = 1;\n        if (n % 2) ot[n] = 1;\n    }\n}\n\nint count_t(int n) {\n    if (t[n] >= 0) return t[n];\n    int ans = INF;\n    for (int i = 1; ; i++) {\n        int p = i * (i+1) * (i+2) / 6;\n        if (n <= p) break;\n        ans = min(ans, count_t(n - p)+1);\n    }\n    return t[n] = ans;\n}\n\nint count_odd_t(int n) {\n    if (ot[n] >= 0) return ot[n];\n    int ans = INF;\n    for (int i = 1; ; i++) {\n        int p = i * (i+1) * (i+2) / 6;\n        if (n <= p) break;\n        if (p % 2) ans = min(ans, count_odd_t(n - p)+1);\n    }\n    return ot[n] = ans;\n}\n\nint main() {\n    init();\n    int n;\n    while (scanf(\"%d\", &n), n) {\n        printf(\"%d %d\\n\", count_t(n), count_odd_t(n));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n#include <math.h>\n//#include <unistd.h>\n//#include <stdio.h>\n#define rep(i,x) for(ll i = 0;i<x;i++)\n#define all(a) (a).begin(),(a).end()\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nusing dou = double;\nconst ll inf = 2147483647;\nconst ll INF = 1LL << 60;\nconst ld pi = 3.14159265358;\nconst ll mod = 1000000007;\ntypedef pair<ll,ll> P;\nusing graph = vector<vector<ll>>;\ntemplate<class T> inline bool chmax(T& a, T b){if(a < b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmin(T& a, T b){if(a > b){a = b; return true;}return false;}\nll gcd(ll a,ll b){\n    if(a < b)swap(a,b);\n    if(a % b == 0)return b;\n    else return gcd(b,a%b);\n}\n//素数判定O(sqrt(N))\nbool isp(ll n){\n    bool res = true;\n    if(n == 1)return false;\n    else{\n        for(ll i = 2;i * i <= n;i++){\n            if(n % i == 0){\n                res = false;\n                break;\n            }\n        }\n        return res;\n    }\n}\n\nll fac[510000], finv[510000], inv[510000];\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < 510000; i++){\n        fac[i] = fac[i - 1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n        finv[i] = finv[i - 1] * inv[i] % mod;\n    }\n}\n\n// 二項係数計算\nll nCk(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\n//nのm乗をMODで割ったあまりO(logN)\nll modpow(ll n,ll m,ll MOD){\n    ll res = 1;\n    while(m){\n        if(m & 1)res = (res * n) % MOD;\n        m >>= 1;\n        n *= n;\n        n %= MOD;\n    }\n    return res;\n}\n\n//printf(\"%.10f\\n\", N);\n/*  vector<ll> vec = {1,2,5,6,8,9,10};\n    cout << binary_search(all(vec),5) << endl; -> true*/\n/*\n    vector<ll> vec = {1,2,5,6,8,9,10};\n    auto n = upper_bound(all(vec),4);\n    cout << *n << endl; -> 5*/\n\n//    cout << fixed << setprecision(15);\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll N;\n    vector<ll> num(190),odd;\n    for(ll i = 1;i < 190;i++){\n        num[i] = i * (i + 1) * (i + 2) / 6;\n        if(i * (i + 1) * (i + 2) / 6 % 2 == 1)odd.push_back(i * (i + 1) * (i + 2) / 6);\n    }\n    vector<ll> memo(1000005,INF),od(1000005,INF);\n    memo[0] = 0;\n    rep(i,1000002){\n        rep(j,189){\n            if(num[j] + i <= 1000001){\n                memo[num[j] + i] = min(memo[num[j] + i],memo[i] + 1);\n            }\n            else break;\n        }\n    }\n    od[0] = 0;\n    rep(i,1000002){\n        rep(j,odd.size()){\n            if(odd[j] + i <= 1000001){\n                od[odd[j] + i] = min(od[odd[j] + i],od[i] + 1);\n            }\n            else break;\n        }\n    }\n    while(true){\n        cin >> N;\n        if(N == 0)break;\n        cout << memo[N] <<\" \"<< od[N] << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    /*for(int i=1;i<=x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)\n\tbreak;\n      count++;\n      if(tmp%2==1)\n\tcount_ki++;\n\t}*/\n\n    int coin[x];\n    int coin_ki[x];\n    fill(coin,coin + x + 1,-1);\n    fill(coin_ki,coin_ki + x + 1,-1);\n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      coin[i-1]=i*(i+1)*(i+2)/6;\n      count++;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki++;\n      }\n      if(coin[i-1]>x)break;\n    }\n\n    int dp[x+1];\n    fill(dp,dp + x + 1,100000);\n  \n\n    /*for(int i=0;i<=x;i++)\n      printf(\"dp[%d]=%d\\n\",i,dp[i]);\n    */\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint A[2111111];\nint B[2111111];\nint seica[11111];\n\n\nint main(){\n\t\n\tREP(i,1111111)A[i] = B[i] = INF;\n\tA[0] = B[0] = 0;\n\tREP(i,11111){\n\t\tseica[i] = i*(i+1)*(i+2)/6;\n\t\tif(seica[i] > 1000000)break;\n\t}\n\t\n\tREP(i,1000000){\n\t\tfor(int j = 1;j < 10000;j++){\n\t\t\tA[i+seica[j]] = min(A[i]+1,A[i+seica[j]]);\n\t\t\tif(i + seica[j] > 1000000)break;\n\t\t}\n\t}\n\t\t\t\n\tREP(i,1000000){\n\t\tfor(int j = 1;j < 10000;j++){\n\t\t\tif(seica[j]%2==1)B[i+seica[j]] = min(B[i]+1,B[i+seica[j]]);\n\t\t\tif(i + seica[j] > 1000000)break;\n\t\t}\n\t}\t\n\t\n\tDBG(SHOW1d(A,100);)\n\tDBG(SHOW1d(B,100);)\n\t\n\tint n;\n\twhile(cin >> n ,n){\n\t\tcout << A[n] << ' ' << B[n] << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1e7+1;\nconst long long MOD = 1000000007;\nconst long double PI = 3.1415926;\n#define FOR(i,r,n) for(ll i = (ll)(r); i < (ll)(n); i++)\n#define RFOR(i,r,n) for(ll i=(ll)(n-1);i>=r;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define RALL(x) x.rbegin(),x.rend()\ntypedef long long int ll;\ntypedef vector<ll> vi;\ntypedef vector < pair<ll, ll > > vp;\ntypedef vector <string> vs;\ntypedef vector <char> vc;\ntypedef list <ll> lst;\n\nll n, k, ans = 0, sum = 0, cnt = 0;\nstring s;\nchar c;\n\n/*--------------------template--------------------*/\n\n\nll dp[1000001];\nll dpOdd[1000001];\n\nint main()\n{\n\tREP(i, 100001)\n\t{\n\t\tdp[i] = dpOdd[i] = i;\n\t}\n\n\tfor (int n = 2; ; n++) {\n\t\tll bNumber = n * (n + 1) * (n + 2) / 6;\n\t\tif (bNumber > 1000001) break;\n\n\t\tfor (int i = 0; i <= 1000001; i++) {\n\t\t\tif (i - bNumber < 0) continue;\n\t\t\tdp[i] = min(dp[i], dp[i - bNumber] + 1);\n\t\t\tif (bNumber % 2 == 1) dpOdd[i] = min(dpOdd[i], dpOdd[i - bNumber] + 1);\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tll Value;\n\t\tcin >> Value;\n\t\tif (!Value) break;\n\t\tcout << dp[Value] << \" \" << dpOdd[Value] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n;\n    vector<int>v;\n    for(int i=1;(i*(i+1)*(i+2))/6 < 1e6;++i){\n        v.push_back((i*(i+1)*(i+2))/6);\n    }\n    while(cin>>n,n){\n        vector<int>dp(1e6,1e9);\n        vector<int>dp1(1e6,1e9);\n        dp[0]=0;\n        dp1[0]=0;\n        for(int i=0;i<=n;++i){\n            for(int j=0;j<v.size();++j){\n                if(i+v[j]>=1e6)break;\n                dp[i+v[j]]=min(dp[i]+1,dp[i+v[j]]);\n                if(v[j]%2==0)continue;\n                dp1[i+v[j]]=min(dp1[i]+1,dp1[i+v[j]]);\n            }\n        }\n        cout<<dp[n]<<\" \"<<dp1[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\nconst int inf = 1000000009;\n\nint main() {\n    vector<int> memo(1000000, inf);     memo[0] = 0;\n    vector<int> odd_memo(1000000, inf); odd_memo[0] = 0;\n\n    for (int i=0; i<1000000; i++) {\n        memo[i]     = i;\n        odd_memo[i] = i;\n    }\n\n    for (int l=2; l<85; l++) {\n        const int n = (l*(l+1)*(l+2))/6;\n        for (int i=0; i<1000000; i++) {\n            if (i-n >= 0) {\n                memo[i] = min(memo[i-n]+1, memo[i]);\n                if (l%2==1) {\n                    odd_memo[i] = min(odd_memo[i-n]+1, odd_memo[i]);\n                }\n            }\n        }\n    }\n\n    int n; \n    while (cin >> n, n!=0) {\n        cout << memo[n] << \" \" << odd_memo[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing std::vector;\n\nvector<int> make_table(vector<int> v) {\n    vector<int> dp(1000000, 0);\n    dp[1] = 1;\n    int j;\n    int min;\n    for (int i = 2; i < dp.size(); i++) {\n        //std::cout << \"HERE\" << std::endl;\n        //std::cout << \"I = \" << i << std::endl;\n        j = 0;\n        min = 1e09;\n        //std::cout << i << \", \" << v[j] << \", \" << dp[v[j]] << endl;\n        while (i >= v[j]) {\n            if (min > dp[i - v[j]]) {\n                min = dp[i - v[j]];\n            }\n            j++; \n        }\n        dp[i] = min + 1;\n        //std::cout << \"DP\" << i << \" = \" << dp[i] << std::endl;\n        //std::cout << \"-------------------------=\" << endl;\n    }\n    return dp; \n}\n\nint main(void) {\n    vector<int> all;\n    vector<int> odd;\n\n    int tetra = 0;\n    int times = 1;\n    while (1) {\n        tetra = times * (times + 1) * (times + 2) / 6;\n        all.push_back(tetra);\n        if (tetra % 2 == 1) {\n            odd.push_back(tetra);\n        }\n        times++;\n        if (tetra > 1000000) {\n            break;\n        }\n    }\n    vector<int> dp_all = make_table(all);\n    vector<int> dp_odd = make_table(odd);\n    int input;\n    while (1) {\n        cin >> input;\n        if (input == 0) {\n            break;\n        }\n        cout << dp_all[input] << \" \" << dp_odd[input] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; scanf(\"%lld\", &x);\n \n//int dxy[5] = {0, 1, 0, -1, 0};\n// assign\n\nvi tetra, odd_tetra;\nvi table(1000001, INF), dp(1000001, INF);\n\nvoid make_tetra();\nvoid make_odd_tetra();\n\n\nsigned main()\n{\n    make_tetra();\n    make_odd_tetra();\n\n    Int(n);\n\n    while (n) {\n        cout << dp[n] << \" \" << table[n] << endl;\n        cin >> n;\n    }\n\n    return 0;\n}\n\n\nvoid make_tetra()\n{\n    Rep(i, 181) {\n        tetra.pb(i * (i + 1) * (i + 2) /6);\n    }\n    dp[0] = 0;\n    Rep(x, 1000000) {\n        int ret = INF;\n        for (int i : tetra) {\n            if (x < i) {\n                break;\n            } else {\n                ret = min(ret, dp[x - i] + 1);\n            }\n        }\n        dp[x] = ret;\n    }\n}\n\nvoid make_odd_tetra()\n{\n    for (int i : tetra) {\n        if (i % 2) {\n            odd_tetra.pb(i);\n            table[i] = 1;\n        }\n    }\n    table[0] = 0;\n    Rep(x, 1000000) {\n        int ret = INF;\n        for (int i : odd_tetra) {\n            if (x < i) {\n                break;\n            } else {\n                ret = min(ret, table[x - i] + 1);\n            }\n        }\n        table[x] = ret;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int SIZE = 181 + 1;\nconst int MAX = 1000000;\n\nint T[SIZE];\nint cost1[MAX], cost2[MAX];\n\nint main( void )\n{\t\n\tfor(int i=0; i < SIZE; ++i) T[i] = i * (i + 1) * (i + 2) / 6;\n\n\tfill(cost1, cost1+MAX, MAX);\n\tfill(cost2, cost1+MAX, MAX);\n\tcost1[0] = cost2[0] = 0;\n\tfor(int i=0; i < MAX; ++i) {\n\t\t\tfor(int j=0; j < SIZE; ++j) {\n\t\t\t\tif(i + T[j] < MAX)\n\t\t\t\t\tcost1[i + T[j]] = min(cost1[i + T[j]], cost1[i] + 1);\n\t\t\t\tif(T[j] & 1) {\n\t\t\t\t\tif(i + T[j] < MAX)\n\t\t\t\t\t\tcost2[i + T[j]] = min(cost2[i + T[j]], cost2[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n) {\n\t\tcout << cost1[n] << ' ' << cost2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#define MAX (int)1e+6\nusing namespace std;\n\nint main(void){\n  int i,j,n;\n  int a[181],b[46];\n  int dp1[MAX],dp2[MAX];\n\n  b[0] = 0;\n  j = 1;\n  for(i=0;i<181;i++){\n    a[i] = i * (i+1) * (i+2) / 6;\n    if(a[i]&1)b[j++] = a[i];\n  }\n\n  for(i=0;i<MAX;i++)dp1[i] = dp2[i] = 1000000;\n\n  for(i=0;i<MAX;i++){\n    for(j=0;j<181;j++){\n      if(i>a[j])dp1[i] = min(dp1[i],dp1[i-a[j]]+1);\n      else if(i==a[j])dp1[i]=1;\n      else break;\n    }\n  }\n  \n  for(i=0;i<MAX;i++){\n    for(j=0;j<46;j++){\n      if(i>b[j])dp2[i] = min(dp2[i],dp2[i-b[j]]+1);\n      else if(i==b[j])dp2[i]=1;\n      else break;\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp1[n],dp2[n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 100000\n\nint main(){\n\tvector <int> v(100);\n\tfor(int i = 0; i < 100; i++)\n\t\tv[i] = i * (i + 1) * (i + 2) / 6;\n\t\n\twhile(1){\n\t\tint s;\n\t\tcin >> s;\n\t\tif(s == 0)\n\t\t\tbreak;\n\t\t\n\t\tvector <int> d(s + 1, INF);\n\t\tvector <int> d2(s + 1, INF);\n\t\t\n\t\td[0] = d2[0] = 0;\n\t\tfor(int i = 1; i <= s; i++){\n\t\t\tfor(int j = 0; v[j] <= i; j++){\n\t\t\t\td[i] = min(d[i], d[i - v[j]] + 1);\n\t\t\t\tif(v[j] % 2 != 0)\n\t\t\t\t\td2[i] = min(d2[i], d2[i - v[j]] + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << d[s] << \" \" << d2[s] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint normal[100100];\nint odd[100100];\n\nint main() {\n  MEMSET(normal, 0x0f);\n  MEMSET(odd, 0x0f);\n  normal[0] = odd[0] = 0;\n  REP(i, 100001) {\n    REP(j, 1000) {\n      int plus = j * (j + 1) * (j + 2) / 6;\n      if (i + plus > 100000) { break; }\n      normal[i + plus] = min(normal[i + plus], normal[i] + 1);\n      if (plus & 1) {\n        odd[i + plus] = min(odd[i + plus], odd[i] + 1);\n      }\n    }\n  }\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    printf(\"%d %d\\n\", normal[n], odd[n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <utility>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <cmath>\n\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define itrep(i,x) for(auto i=(x).begin(); i!=(x).end();i++)\n#define Sort(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define vec vector\n#define INF INT_MAX\n#define INFL 1e18\n#define MOD 1000000007\n#define pb push_back\n#define MP make_pair\n#define PI 3.1415926535\ntypedef long long int ll;\ntypedef std::pair<int,int> P;\nint D=1;\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\nusing namespace std;\n\nint main(){\n    vector<int> v,oddv;\n    for(ll i=1;;i++){\n        if(i*(i+1)*(i+2)/6<=2000000){\n            v.pb(i*(i+1)*(i+2)/6);\n        }\n        else break;\n    }\n    int ans1[1000010],ans2[1000010];\n    rep(i,0,1000010) ans1[i]=ans2[i]=INF;\n    ans1[0]=0; ans2[0]=0;\n    rep(i,0,1000000){\n        ans1[i]=i; ans2[i]=i;\n        for(int j=0;i>=v[j];j++){\n            ans1[i]=min(ans1[i-v[j]]+1,ans1[i]);\n            if(v[j]%2==1)ans2[i]=min(ans2[i],ans2[i-v[j]]+1);\n        }\n    }\n\n    int n;\n    while(cin>>n&&n){\n        cout<<ans1[n]<<\" \"<<ans2[n]<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    int ans_tmp=0;\n    int ans2_tmp=0;\n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<100000;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  //printf(\"dp[%d]=%d\\n\",i+coin[j],dp[i+coin[j]]);\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n    \n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  ans2_tmp=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  dp2[i+coin_ki[j]]=ans2_tmp;\n\t  //printf(\"dp2[%d]=%d\\n\",i+coin_ki[j],dp[i+coin_ki[j]]);\n\t}\n      }\n    }\n   \n    \n    int ans2=dp2[x];\n    \n\n    //for(int i=0;i<count;i++)\n      //printf(\"coin[%d]=%d\\n\",i,coin[i]);\n      //for(int i=0;i<count_ki;i++)\n      //printf(\"coin_ki[%d]=%d\\n\",i,coin_ki[i]);\n\n\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n      \n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int i,j,n,three[1000],four[1000],four_2[1000],c[1000],c_2[1000];\n\n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < 50; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < 50; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL << 30)\n#define LLINF (1LL << 60)\n#define PI 3.14159265359\n#define EPS 1e-12\n#define int ll\n\nint dp1[1000010], dp2[1000010];\nsigned main(void) {\n  VL a, b;\n  FOR(i, 1, 500) {\n    int tmp = i * (i + 1) * (i + 2) / 6;\n    if (tmp % 2)\n      b.PB(tmp);\n    a.PB(tmp);\n  }\n  //cout << a[100] << \" \" << a[150] << \" \" << a[200] << endl;\n  //cout << b.size() << endl;\n  //a 200?????§???b 100?????§\n\n  REP(i, 1000001) dp1[i] = dp2[i] = i;\n  FOR(i, 1, 200) {\n    FOR(j, a[i], 1000001) {\n      dp1[j] = min(dp1[j], dp1[j-a[i]] + 1);\n    }\n    FOR(j, b[i], 1000001) {\n      dp2[j] = min(dp2[j], dp2[j-b[i]] + 1);\n    }\n  }\n  //cout << \"a\" << endl;\n/*  FOR(i, 1, 100) {\n    FOR(j, b[i], 1000001) {\n      dp2[j] = min(dp2[j], dp2[j-b[i]] + 1);\n    }\n  }\n  *///cout << \"b\" << endl;\n\n  //REP(i, 50) cout << dp1[i] << \" \"; cout << endl;\n  //REP(i, 50) cout << dp2[i] << \" \"; cout << endl;\n\n  int n;\n  while (true) {\n    cin >> n;\n    if(!n) break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;a[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++)for(k=a[j];k<=1000000;k++){\n    b[k]=min(b[k],b[k-a[j]]+1);\n    if(a[j]%2)c[k]=min(c[k],c[k-a[j]]+1);\n  }\nwhile(cin>>n,n)cout<<b[n]<<' '<<c[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint dp[1000010][2];\nint data[1000010];\nint main(){\n\tint index=1;\n\twhile(index*(index+1)*(index+2)/6 < 10000000){\n\t\tdata[index-1] = index*(index+1)*(index+2)/6;\n\t\tindex++;\n\t}\n\tfill(dp[0],dp[0]+1000000,INF);\n\tfill(dp[1],dp[1]+1000000,INF);\n\tdp[0][0] = dp[0][1] = 0;\n\trep(i,1000000){\n\t\trep(j,index){\n\t\t\tif(i+data[j] < 1000000){\n\t\t\t\tdp[i+data[j]][0] = min(dp[i+data[j]][0],dp[i][0]+1);\n\t\t\t\tif(data[j] % 2 == 1){\n\t\t\t\t\tdp[i+data[j]][1] = min(dp[i+data[j]][1],dp[i][1]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint N;\n\n\twhile(scanf(\"%d\",&N),N){\n\t\tprintf(\"%d %d\\n\",dp[N][0],dp[N][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\nint dpodd[190][1000010] = { 0 };\n\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= 50; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint\tmain()\n{\n\tvector<int>\tq_vec;\n\tint\tq, max_q = 0;\n\twhile (cin >> q) {\n\t\tif (q == 0) break;\n\t\tif (max_q < q)\n\t\t\tmax_q = q;\n\t\tq_vec.push_back(q);\n\t}\n\tvector<int>\tcost(max_q + 1, -1);\n\tvector<int>\todd_cost(max_q + 1, -1);\n\tcost[0] = 0;\n\todd_cost[0] = 0;\n\tint\tnum;\n\tfor (int i = 1; (num = i * (i + 1) * (i + 2) / 6) <= max_q; ++i) {\n\t\tfor (int j = 0; j <= max_q; ++j) {\n\t\t\tif (cost[j] == -1) continue;\n\t\t\tint\tk = j + num;\n\t\t\tif (k > max_q) continue;\n\t\t\tint\tcost_k = cost[j] + 1;\n\t\t\tif (cost[k] == -1 || cost[k] > cost_k)\n\t\t\t\tcost[k] = cost_k;\n\t\t}\n\t\tif (num % 2 == 0) continue;\n\t\tfor (int j = 0; j <= max_q; ++j) {\n\t\t\tif (odd_cost[j] == -1) continue;\n\t\t\tint\tk = j + num;\n\t\t\tif (k > max_q) continue;\n\t\t\tint odd_cost_k = odd_cost[j] + 1;\n\t\t\tif (odd_cost[k] == -1 || odd_cost[k] > odd_cost_k)\n\t\t\t\todd_cost[k] = odd_cost_k;\n\t\t}\n\t}\n\tfor (int q : q_vec) {\n\t\tcout << cost[q] << \" \" << odd_cost[q] << endl;\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rep1(i, n) for (int i = 1; i <= (n); i++)\n#define show(a, n) rep(i,n) {cout<<a[i]<<' ';} cout<<endl;\n#define show2(a, n, m) rep(i, n) {rep(j, m) {cout<<a[i][j]<<' ';} cout<<endl;}\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<long long, long long> pll;\n\nconst int INF = 1 << 30;\n//const int INF = 10000;\nconst long long INFL = 1LL << 62;\nconst int MOD = 1000000007;\nconst int MAX = 100000;\nconst int N = 1000000;\n\nint main() {\n//\tcout << fixed << setprecision(15);\n\tvi v[2];\n\tint n = 1, m;\n\twhile(true) {\n\t\tm = n * (n + 1) * (n + 2) / 6;\n\t\tif(m > N) break;\n\t\tv[0].push_back(m);\n\t\tif(m % 2 == 1) v[1].push_back(m);\n\t\tn++;\n\t}\n\n\tvi in;\n\twhile(true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tin.push_back(n);\n\t}\n\n\tvi dp(N+1), ans[2];\n\trep(i, 2) {\n\t\tfill(dp.begin(), dp.end(), INF);\n\t\tdp[0] = 0;\n\t\tfor(int j = 0; j < v[i].size(); j++) {\n\t\t\tfor(int k = v[i][j]; k <= N; k++) {\n\t\t\t\tdp[k] = min(dp[k - v[i][j]] + 1, dp[k]);\n\t\t\t}\n\t\t}\n\t\tfor(auto j : in) ans[i].push_back(dp[j]);\n\t}\n\trep(i, in.size()) cout << ans[0][i] << ' ' << ans[1][i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvi llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\n\nint beam_width=15000;\n\nint bfs(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n        }\n        if(i<target){\n            q.pb(i);\n            mm=i;\n        }\n        if(i>target) break;\n    }\n    //auto mm=*max_element(beginend(q));\n    int cnt=0;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(llist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,llist){\n                if(k+x>target) break;\n                // if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.pb(k+x);\n            }\n\n            \n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) {q.pb(i);mm=i;}\n        if(i>target) break;\n    }\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    //out(mm);\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(oddlist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                //if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.pb(k+x);\n            }\n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    int mm=0;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n        mm=max(mm,n);\n    }\n    map<int,pii> m;\n    makeList(mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        //int ans2=0;\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SET(a,c) memset(a,c,sizeof(a))\n#define PB push_back\nusing namespace std;\n\nconst int MAX_N = 1e6;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve(int n)\n{\n\tvector<int> m;\n\tint dp[MAX_N], dp_odd[MAX_N];\n\tSET(dp, INF);\n\tSET(dp_odd, INF);\n\t\n\tREP(i, MAX_N) {\n\t\tm.PB( (i+1)*(i+2)*(i+3)/6 );\n\t\tif (m.back() > n) break;\n\t}\n\n\tdp[0] = 0;\n\tdp_odd[0] = 0;\n\tREP(i, m.size()) {\n\t\tREP(j, n + 1) {\n\t\t\tif (j < m[i]) continue;\n\t\t\tdp[j] = min(dp[j], dp[j - m[i]] + 1);\n\t\t\tif (m[i] % 2) dp_odd[j] = min(dp_odd[j], dp_odd[j - m[i]] + 1);\n\t\t}\n\t}\t\n\tprintf(\"%d %d\\n\", dp[n], dp_odd[n]);\n}\n\nint main()\n{\n\tint n;\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (!n) break;\n\t\tsolve(n);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n\nusing namespace std;\n\n#define MAX 1000000\n\nint ans[MAX];\nint ans_odd[MAX];\n\nint square(int n){\n    return n * (n + 1) * (n + 2) / 6;\n}\n\nint calc(int n){\n\n    if(ans[n] != MAX)return ans[n];\n\n\n    int num = 0;\n    while(square(num) <= n){\n        ans[square(num)] = 1;\n        num++;\n    }\n    num--;\n\n    for(int i = num; i > 0; i--){\n        int tmp = calc(n - square(i));\n        if(ans[n] > tmp + 1)ans[n] = tmp + 1;\n    }\n\n    return ans[n];\n}\n\nint calcOdd(int n){\n    if(ans_odd[n] != MAX)return ans_odd[n];\n\n\n    int num = 1;\n    while(square(num) <= n){\n        ans_odd[square(num)] = 1;\n        num+=4;\n    }\n    num-=4;\n\n    for(int i = num; i > 0; i-=4){\n        int tmp = calcOdd(n - square(i));\n        if(ans_odd[n] > tmp + 1)ans_odd[n] = tmp + 1;\n    }\n\n    return ans_odd[n];\n}\n\nint main(){\n//    ifstream fin(\"in.txt\");\n    int n = 0;\n\n    for(int i = 0; i < MAX; i++){\n        ans[i] = ans_odd[i] = MAX;\n    }\n\n\n    while((cin >> n), n){\n\n        cout << calc(n) << \" \" << calcOdd(n) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n#define EPS 0.000000001\n\n#define x first\n#define y second\n#define M 1000000\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n//int dx[8] = {0,1,1,1,0,-1,-1,-1};\n//int dy[8] = {1,1,0,-1,-1,-1,0,1};\n\nint nextInt(){\n\tint x;\n\tscanf(\"%d\",&x);\n\treturn x;\n}\n\n\nint main(){\n\tvint ss;\n\tvint so;\n\t\n\tstatic int nums[M+1];\n\tstatic int numo[M+1];\n\t\n\tfor(int i=0; i<=M; i++){\n\t\tnums[i] = INF;\n\t\tnumo[i] = INF;\n\t}\n\t\n\tfor(int i=1; i<200; i++){\n\t\tint n = i*(i+1)*(i+2)/6;\n\t\tif(n>M) break;\n\t\t\n\t\tss.push_back(n);\n\t\tnums[n]=1;\n\t\tif(n%2==1){\n\t\t\tso.push_back(n);\n\t\t\tnumo[n]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=1; i<=M; i++){\n\t\tfor(int j=0; j<ss.size(); j++){\n\t\t\tif(i+ss[j]>M) break;\n\t\t\tnums[i+ss[j]] = min(nums[i+ss[j]], nums[i]+1);\n\t\t}\n\t\tfor(int j=0; j<so.size(); j++){\n\t\t\tif(i+so[j]>M) break;\n\t\t\tnumo[i+so[j]] = min(numo[i+so[j]], numo[i]+1);\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tint a = nextInt();\n\t\tif(a==0) break;\n\t\tprintf(\"%d %d\\n\", nums[a], numo[a]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint memo1[1000001], memo2[1000001], memoodd[1000001], memo3[1000001];\n\nint pollock_1(int n)\n{\n    int min = 100, ex;\n    if (n == memo1[n])\n        return memo2[n] = 1;\n    if (memo2[n] > 0)\n        return memo2[n];\n    for (int i = 1; i < 1000001; i++)\n    {\n        if (i <= n / 2)\n        {\n            if (pollock_1(n - i) == 1)\n            {\n                ex = pollock_1(n - i) + pollock_1(i);\n            }\n            if (i == 1)\n            {\n                ex = pollock_1(n - 1) + 1;\n            }\n            if (ex < min)\n                min = ex;\n        }\n    }\n    return memo2[n] = min;\n}\n\nint pollock_2(int n)\n{\n    int min = 10000000, ex;\n    if (n == memoodd[n])\n        return memo2[n] = 1;\n    if (memo3[n] > 0)\n        return memo3[n];\n    for (int i = 1; i < 1000001; i++)\n    {\n        if (i <= n / 2)\n        {\n            if (pollock_2(n - i) == 1)\n            {\n                ex = pollock_2(n - i) + pollock_2(i);\n            }\n            if (i == 1)\n            {\n                ex = pollock_2(n - 1) + 1;\n            }\n            if (ex < min)\n                min = ex;\n        }\n    }\n    return memo3[n] = min;\n}\n\nint main()\n{\n    for (int k = 0; k < 1000001; k++)\n    {\n        memo1[k] = 0;\n        memo2[k] = 0;\n        memoodd[k] = 0;\n        memo3[k] = 0;\n    }\n    for (int k = 1; k < 200; k++)\n    {\n        n = (k * (k + 1) * (k + 2)) / 6;\n        memo1[n] = n;\n        if (n % 2 != 0)\n            memoodd[n] = n;\n    }\n\n    scanf(\"%d\", &n);\n    printf(\"%d %d\\n\", pollock_1(n), pollock_2(n));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define LL long long\n#define VI vector<int>\n#define VVI vector<vector<int>>\n#define VVVI vector<vector<vector<int>>>\n#define VL vector<LL>\n#define VVL vector<vector<LL>>\n#define VVVL vector<vector<vector<LL>>>\n#define VB vector<bool>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\ntemplate<class T> T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> void print(T x) { std::cout << x << std::endl; }\n\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, -1, 0, 1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    vector<LL> v, odd;\n\n    FOR(n, 1, 200) {\n        LL num = n * (n + 1) * (n + 2) / 6;\n        v.emplace_back(num);\n        if (num % 2 != 0) {\n            odd.emplace_back(num);\n        }\n    }\n\n    VI dp(1000001, INT_MAX), dp_odd(1000001, INT_MAX);\n    dp[0] = 0;\n    dp_odd[0] = 0;\n\n\n    FOR(i, 0, dp.size()) {\n        FOE(num, v) {\n            if (dp[i] != INT_MAX and i + num < dp.size()) {\n                dp[i + num] = min(dp[i + num], dp[i] + 1);\n            }\n        }\n    }\n    FOR(i, 0, dp_odd.size()) {\n        FOE(num, odd) {\n            if (dp_odd[i] != INT_MAX and i + num < dp_odd.size()) {\n                dp_odd[i + num] = min(dp_odd[i + num], dp_odd[i] + 1);\n            }\n        }\n    }\n\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) { break; }\n\n        cout << dp[n] << \" \" << dp_odd[n] << endl;\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define ALL(obj) obj.begin(), obj.end()\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\n\nusing namespace std;\n\ntemplate <typename T>\nint getFormer(const vector<T> &vec, T x) {\n    return upper_bound(vec.begin(), vec.end(), x) - vec.begin() - 1;\n}\n\ntemplate <typename T>\nint getLatter(const vector<T> &vec, T x) {\n    return lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n}\n\nint ball[210], dp1[1000010], dp2[1000010];\n\nint main() {\n    for(int i = 1; i <= 200; i++) {\n        ball[i] = i * (i + 1) * (i + 2) / 6;\n    }\n\n    fill_n(dp1, 1000010, iINF);\n    fill_n(dp2, 1000010, iINF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n\n    for (int i = 1; i <= 1000000; i++) {\n        for (int j = 1; j <= 200; j++) {\n            if (i - ball[j] < 0) continue;\n            dp1[i] = min(dp1[i], dp1[i - ball[j]] + 1);\n            if (ball[j] & 1) dp2[i] = min(dp2[i], dp2[i - ball[j]] + 1);\n        }\n    }\n\n    int N;\n    while(cin >> N && N) {\n        cout << dp1[N] << \" \" << dp2[N] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[1000001]={0},k=0,i,j,n;\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nconst int INF = 1001001001;\n\nstd::vector<int> A, B;\nint dp[2][1000001], dp2[2][1000001];\n\nvoid DP(int (&dp)[2][1000001], std::vector<int> &v){\n    for(int i=0;i<=1000000;i++){\n        dp[0][i] = INF;\n    }\n    dp[0][0] = 0;\n\n    int L = v.size();\n    int prev = 0, next = 1;\n    for(int i=0;i<L;i++){\n        for(int j=0;j<=1000000;j++){\n            dp[next][j] = dp[prev][j];\n            if(j-v[i] >= 0){\n                dp[next][j] = std::min(dp[next][j], dp[next][j-v[i]] + 1);\n            }\n        }\n\n        prev = !prev;\n        next = !next;\n    }\n}\n\nint main(){\n    for(int i=1;;i++){\n        long long x = 1ll * i * (i+1) * (i+2) / 6;\n        if(x <= 1000000ll){\n            A.push_back(x);\n            if(x & 1){B.push_back(x);}\n        }else{\n            break;\n        }\n    }\n    \n    DP(dp, A);\n    DP(dp2, B);\n    \n    int N;\n    while(scanf(\"%d\", &N), N){\n        printf(\"%d %d\\n\", dp[0][N], dp2[0][N]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[1000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b ???ans??????????????????????????? */\n\n  for (i = 1; i <= 180; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;\n    int temp = input;\n    int j = 1, min = 1000000000;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n    while (j > 0) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j--;\n      input = temp;\n    }\n    ans[a][0] = min;\n    j = l; \n    min = 1000000000;\n    while (j > 0) {\n      if (tetras[j] % 2 == 0) {\n\tj--;\n\tcontinue;\n      }\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tif (tetras[k] % 2 == 0) {\n\t  k--;\n\t  continue;\n\t}\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j--;\n      input = temp;\n    }\n    ans[a][1] = min;\n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1200001]={0,1,2,3},d[1300001],k=0,i,j,n,p;\n  for(i=1;a[i-1]<1000000;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0,p=i;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<p;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\nstruct multi {\n  ll first;\n  ll second;\n  ll third;\n};\nbool multicomp(const multi &a, const multi &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll func(vl &kouho, ll c) {\n  vl DP(c + 1, llINF);\n  vl prev(c + 1, llINF);\n  DP[0] = 0;\n  while (true) {\n    prev = DP;\n    AUTO(a, kouho) {\n      REP(i, c - a + 1) {\n        if (prev[i] < llINF)\n          DP[i + a] = min(prev[i] + 1, prev[i + a]);\n      }\n    }\n    if (DP[c] < llINF)\n      break;\n  }\n  return DP[c];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  vl all;\n  vl odd;\n  ll score = 0;\n  ll i = 1;\n  vector<pll> ans;\n  while (score < 1e6 + 1) {\n    score = (i * (i + 1) * (i + 2)) / 6;\n    if (score % 2 == 1)\n      odd.push_back(score);\n    all.push_back(score);\n    i++;\n  }\n  sort(ALL(odd), REV(ll));\n  sort(ALL(all), REV(ll));\n\n  while (true) {\n    ll n;\n    cin >> n;\n    if (n == 0)\n      break;\n    ans.push_back(make_pair(func(all, n), func(odd, n)));\n  }\n\n  AUTO(a, ans) { cout << a.first << \" \" << a.second << endl; }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    ll s4[101];\n    vector<ll> s4_k;\n    s4[0] = 1;\n    for(int i = 1; i < 101; i++){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    vector<ll> dp1(100001, INF), dp2(100001, INF);\n    dp1[0] = 0;\n    REP(i, 101){\n        REP(j, 100001){\n            if(s4[i] <= j){\n                dp1[j] = min(dp1[j], dp1[j - s4[i]] + 1);\n            }\n        }\n    }\n    \n    dp2[0] = 0;\n    REP(i, s4_k.size()){\n        REP(j, 100001){\n            if(s4_k[i] <= j){\n                dp2[j] = min(dp2[j], dp2[j - s4_k[i]] + 1);\n            }\n        }\n    }\n    \n    ll n;\n    cin >> n;\n    while(n != 0){\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n        \n        cin >> n;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint List[100];\n\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tList[i]=i*(i+1)*(i+2)/6;\n\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint dp[1000001], dp_odd[1000001];\n\nsigned main()\n{\n    vi tet, tet_odd;\n\n    for (int i = 1; ; ++i) {\n        tet.PB(i * (i + 1) * (i + 2) / 6);\n        if (tet.back() >= 100000) break;\n    }\n\n    for (int i = 0; i < tet.size(); ++i) {\n        if (tet[i] & 1) tet_odd.PB(tet[i]);\n    }\n\n    for (int i = 1; i <= 1000000; ++i) dp[i] = dp_odd[i] = inf;\n\n    for (int i = 1; i <= 1000000; ++i) {\n        for (int j = 0; j < tet.size(); ++j) {\n            if (i >= tet[j]) {\n                dp[i] = min(dp[i], dp[i - tet[j]] + 1);\n            }\n            if (i < tet[j]) break;\n        }\n\n        for (int j = 0; j < tet_odd.size(); ++j) {\n            if (i >= tet_odd[j]) {\n                dp_odd[i] = min(dp_odd[i], dp_odd[i - tet_odd[j]] + 1);\n            }\n            if (i < tet_odd[j]) break;\n        }\n    }\n\n    int N;\n    while (cin >> N, N) cout << dp[N] << ' ' << dp_odd[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX + 1], dp2[MAX + 1];\n\nint main()\n{\n    for (int i = 1; i <= MAX; i++)\n    {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for (int n = 1; n * (n + 1) * (n + 2) / 6 <= MAX; n++)\n    {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp1[i] = min(dp1[i], dp1[i - a] + 1);\n        }\n        if (a % 2 == 0)\n            continue;\n        for (int i = a; i <= MAX; i++)\n        {\n            dp2[i] = min(dp2[i], dp2[i - a] + 1);\n        }\n    }\n\n    while (1)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n            break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 1000000\n#define INFINITY 2000000000\nusing namespace std;\nint dp[200][N],data[N];\nvector<int> data2;\nint DP(int);\nint DP2(int);\nint main(){\n  int i,out,out2,n,c;\n  data2.push_back(0);\n  for(i=1;i<N;i++){\n    data[i]=i*(i+1)*(i+2)/6;\n    if(data[i]>N){\n      c=i;\n    }\n    if(data[i]%2==1){\n      data2.push_back(data[i]);\n    }\n  }\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    out=DP(n);\n    out2=DP2(n);\n    cout << out << ' ' << out2 << endl;\n  }\n  return 0;\n}\nint DP(int n){\n  int i,j,minret,s;\n  for(i=1;i<N;i++){\n    if(data[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}\nint DP2(int n){\n  int i,j,minret,s,len;\n  len=data2.size();\n  for(i=1;i<len;i++){\n    if(data2[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data2[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data2[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1000005,INF=1<<30;\nvector<ll> A,B;\nint cnt1[MAX],cnt2[MAX];\n\nvoid BFS(){\n    cnt1[0]=0;\n    cnt2[0]=0;\n    \n    queue<ll> Q;\n    Q.push(0);\n    \n    while(!Q.empty()){\n        ll a=Q.front();\n        Q.pop();\n        for(ll to:A){\n            if(a+to<=1000000){\n                if(cnt1[a+to]==INF){\n                    cnt1[a+to]=cnt1[a]+1;\n                    Q.push(a+to);\n                }\n            }\n        }\n    }\n    \n    Q.push(0);\n    \n    while(!Q.empty()){\n        ll a=Q.front();\n        Q.pop();\n        for(ll to:B){\n            if(a+to<=1000000){\n                if(cnt2[a+to]==INF){\n                    cnt2[a+to]=cnt2[a]+1;\n                    Q.push(a+to);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    for(ll i=1;;i++){\n        if(i*(i+1)*(i+2)/6>1000000) break;\n        if((i*(i+1)*(i+2)/6)%2==1){\n            B.push_back((i*(i+1)*(i+2))/6);\n        }\n        \n        A.push_back((i*(i+1)*(i+2))/6);\n    }\n    \n    for(int i=0;i<=1000000;i++){\n        cnt1[i]=INF;\n        cnt2[i]=INF;\n    }\n    \n    BFS();\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        \n        cout<<cnt1[N]<<\" \"<<cnt2[N]<<endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long int li;\ntypedef long double lb;\n#define rep(i,j,n) for (ll i = j; i < (n); i++)\n#define repr(i,j,n) for(ll i = j; i >= (n); i--)\n#define all(x) (x).begin(),(x).end()\n#define CLR(mat,f) memset(mat, f, sizeof(mat))\n#define IN(a, b, x) (a<=x&&x<b)\n#define out(ans) cout << ans << endl\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\ntypedef pair<ll,ll>P;\nconst ll mod=1e9+7;\nconst ll INF = 1LL<<60;\nconst ll m=1LL<<32;\n\nint main(){\n\n  ll n;\n  vector<ll>a;\n  ll ma=0;\n  while(cin>>n){\n    if(n==0)break;\n    chmax(ma,n);\n    a.push_back(n);\n  }\n  vector<ll>v;\n  rep(i,1,190)v.push_back(i*(i+1)*(i+2)/6);\n  // out(v[4]);\n  // out(v[v.size()-1]);\n  ma++;\n\n  ll dp[ma];fill(dp,dp+ma,INF);\n  dp[0]=0;\n  rep(i,1,ma){\n    dp[i]=dp[i-1]+1;\n    rep(j,1,v.size()){\n      if(i-v[j]>=0)chmin(dp[i],dp[i-v[j]]+1);\n    }\n  }\n\n  ll d[ma];fill(d,d+ma,INF);\n  d[0]=0;\n  rep(i,1,ma){\n    d[i]=d[i-1]+1;\n    rep(j,1,v.size()){\n      if(v[j]%2==0)continue;\n      if(i-v[j]>=0)chmin(d[i],d[i-v[j]]+1);\n    }\n  }\n  rep(i,0,a.size()){\n    out(dp[a[i]]<<\" \"<<d[a[i]]);\n  }\n\n\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\n#define PB push_back\n\nconst int inf = 1e9;\n\nint dp[1000000], dp_odd[1000000];\n\nint main()\n{\n\tvi tet;\n\n\tfor (int i = 1; ; ++i) {\n\t\ttet.PB(i * (i + 1) * (i + 2) / 6);\n\t\tif (tet.back() > 1000000) break;\n\t}\n\n\tfor (int i = 1; i < 1000000; ++i) dp[i] = dp_odd[i] = inf;\n\n\tfor (int i = 0; i < tet.size(); ++i) {\n\t\tfor (int j = tet[i]; j < 1000000; ++j) {\n\t\t\tdp[j] = min(dp[j], dp[j - tet[i]] + 1);\n\t\t\tif (tet[i] & 1) {\n\t\t\t\tdp_odd[j] = min(dp_odd[j], dp_odd[j - tet[i]] + 1);\n\t\t\t}\n\t\t\tif (j < tet[i]) break;\n\t\t}\n\t}\n\n\tint N;\n\twhile (scanf(\"%d\", &N), N) printf(\"%d %d\\n\", dp[N], dp_odd[N]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int M=1e6+100;\n  vector<Int> v;\n  for(Int i=1;i*(i+1)*(i+2)/6<=M;i++)\n    v.emplace_back(i*(i+1)*(i+2)/6);\n\n  const Int INF = 1e8;\n  vector<Int> dp(M,INF),dp2(M,INF);\n  dp[0]=dp2[0]=0;\n  for(Int i=0;i<(Int)v.size();i++){\n    for(Int j=0;j<M;j++){\n      if(j+v[i]<M){\n\tchmin(dp[j+v[i]],dp[j]+1);\n\tif(v[i]&1) chmin(dp2[j+v[i]],dp2[j]+1);\n      }\n    }\n  }\n  \n  Int n;\n  while(cin>>n,n) cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for(int i = (int)(n - 1); i >= 0; --i)\n#define RFOR(i, a, b) for(int i = (int)(b - 1); i >= (int)(a); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef vector<vll> vvll;\n\nconst int INF = (int)1e9;\n\nint main() {\n  vi pollock;\n  for(int i = 0, v; ( v = i * (i + 1) * (i + 2) / 6) <= 1000000; i++) {\n    pollock.push_back(v);\n  }\n\n  vi dpall(100001, INF);\n  vi dpodd(100001, INF);\n  dpall[0] = dpodd[0] = 0;\n  for (auto m : pollock) {\n    for(int i = 0; i + m < dpall.size(); i++) {\n      dpall[i + m] = min(dpall[i + m], dpall[i] + 1);\n    }\n    if (m % 2 == 1) {\n      for(int i = 0; i + m < dpodd.size(); i++) {\n        dpodd[i + m] = min(dpodd[i + m], dpodd[i] + 1);\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    printf(\"%d %d\\n\", dpall[n], dpodd[n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int SIZE = 300;\nconst int N = 1000002;\nint p[SIZE+1];\nint dp1[N], dp2[N];\n\nvoid make_pollock (void )\n{\n\tfor (int i = 0; i <= SIZE; i++ )\n\t\tp[i] = i*(i+1LL)*(i+2LL)/6LL;\n}\n\nvoid make_dp (void )\n{\n\tdp1[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp1[j] = min (dp1[j], dp1[j-m]+1 );\n\t} // end for\n\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tif (p[i] % 2 == 0 ) continue;\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp2[j] = min (dp2[j], dp2[j-m]+1 );\n\t} // end for\t\n}\n\t\nint main()\n{\n\tmemset (p, 0, sizeof (p ) );\n\tfill (dp1, dp1+N, INF );\n\tfill (dp2, dp2+N, INF );\n\n\tmake_pollock();\n\tmake_dp ();\n\n\tint n;\n\twhile (cin >> n, n )\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nvector<int>nums;\nvector<int>oddnums;\n\nvector<short>memo(1000001,-1);\nvector<short>oddmemo(1000001,-1);\n\nint getans(const int num,const int atime) {\n\tif (memo[num] != -1) {\n\t\treturn memo[num];\n\t}\n\telse {\n\t\tif (num == 0)return memo[num] = 0;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <nums.size(); ++i) {\n\t\t\tint minusnum = nums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 10) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getans(num - minusnum, atime + 1)+1);\n\t\t}\n\n\t\treturn memo[num] = ans;\n\t}\n}\nint getoddans(const int num, const int atime) {\n\tif (oddmemo[num] != -1) {\n\t\treturn oddmemo[num];\n\t}\n\telse {\n\t\tif (num == 0)return oddmemo[num] = 0;\n\t\tint ans = num;\n\t\tfor (int i = 0; i < oddnums.size(); ++i) {\n\t\t\tint minusnum = oddnums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 100) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getoddans(num - minusnum, atime + 1) + 1);\n\t\t}\n\t\treturn oddmemo[num] = ans;\n\t}\n\n}\nint main() {\n\tfor (int i = 1; i < 190; ++i) {\n\t\tnums.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (((i*(i + 1)*(i + 2)) / 6) % 2) {\n\n\t\t\n\t\t\toddnums.push_back((i*(i + 1)*(i + 2)) / 6);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tint normalans = getans(n, 0);;\n\t\tint oddans = getoddans(n, 0);\n\n\t\tcout << normalans << \" \" << oddans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repr(i,a,n) for(int i=a;i>=n;i--)\n#define INF 999999999\n#define pb(a) push_back(a)\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef vector<pii> VP;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\n\nint main() {\n    int n;\n    int a[1000];\n    int b[1000];\n    int dp1[1000000];\n    int dp2[1000000];\n    while(cin >> n) {\n        if(n == 0) break;\n        rep(i,0,1000) {\n            a[i] = 0;\n            b[i] = 0;\n        }\n\n        int cnt = 0;\n        for(int i = 1; i * (i+1) * (i+2) / 6 <= n; i++) {\n            a[i-1] = i * (i+1) * (i+2) / 6;\n\n            if(i * (i+1) * (i+2) / 6 % 2 == 1) {\n                b[cnt] = i * (i+1) * (i+2) / 6;\n                cnt++;\n            }\n        }\n\n/*\n        for(int i = 1; i * (i+1) * (i+2) / 6 <= n; i++) {\n            cout << a[i-1] << endl;\n        }\n\n        cout << endl;\n\n        for(int i = 0; b[i] != 0; i++) {\n            cout << b[i] << endl;\n        }\n*/\n\n        rep(i,0,1000000) {\n            dp1[i] = i;\n            dp2[i] = i;\n        }\n\n        int k = 0;\n        while(a[k] != 0) {\n            rep(j,0,1000000-a[k]+1) {\n                dp1[j+a[k]] = min(dp1[j+a[k]], dp1[j] + 1);\n            }\n            k++;\n        }\n\n        k = 0;\n        while(b[k] != 0) {\n            rep(j,0,1000000-b[k]+1) {\n                dp2[j+b[k]] = min(dp2[j+b[k]], dp2[j] + 1);\n            }\n            k++;\n        }\n\n        cout << dp1[n] << \" \"<< dp2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1e9+7;\nint main(void){\n    ll n,i,j;\n    while(cin >> n && n){\n        std::vector<ll> v,v2;\n        for(i=1;(i*(i+1)*(i+2)/6)<=n;i++){\n            v.push_back(i*(i+1)*(i+2)/6);\n            if(i*(i+1)*(i+2)/6%2)v2.push_back(i*(i+1)*(i+2)/6);\n        }\n        ll vs = v.size();\n        ll dp[vs+1][n+1];\n        fill(dp[0],dp[0]+(vs+1)*(n+1),1000000);\n        //cout << dp[0][0] << endl;\n        dp[0][0]=0;\n        for(i=1;i<=vs;i++){\n            for(j=0;j<=n;j++){\n                if(j-v[i-1]<0)dp[i][j]=dp[i-1][j];\n                else dp[i][j]=min(dp[i][j-v[i-1]]+1,dp[i-1][j]);\n            }\n        }\n        ll ret1 = dp[vs][n];//直にやるほう\n        vs = v2.size();\n        ll dp2[vs+1][n+1];\n        fill(dp2[0],dp2[0]+(vs+1)*(n+1),1000000);\n        dp[0][0]=0;\n        for(i=1;i<=vs;i++){\n            for(j=0;j<=n;j++){\n                if(j-v2[i-1]<0)dp[i][j]=dp[i-1][j];\n                else dp[i][j]=min(dp[i][j-v2[i-1]]+1,dp[i-1][j]);\n            }\n        }\n        ll ret2 = dp[vs][n];\n        cout << ret1 << \" \" << ret2 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,a,n) for(int i=(a); i<(n); i++)\n#define all(v) v.begin(), v.end()\n#define fi first\n#define se second\nusing namespace std;\nusing ll = long long;\nusing P = pair<int ,int>;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\nconst int MINT = 1000000;\nint dp[MINT]; // 正四面体の番号、正整数\nint dpodd[MINT]; // 正四面体の番号、正整数\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n = 200;\n    vector<int> a(n);\n    rep(i, n) a[i] = (i+1)*(i+2)*(i+3)/6;\n\n    rep(j, MINT) { dp[j]=INF; dpodd[j]=INF; }\n    dp[0] = 0; dpodd[0] = 0;\n\n    rep(i, n) {\n        ll num = a[i];\n        rep(j, MINT) {\n            if (j>=num) dp[j] = min(dp[j-num]+1, dp[j]);\n            else dp[j] = dp[j];\n            if (num%2) {\n                if (j>=num) dpodd[j] = min(dpodd[j-num]+1, dpodd[j]);\n                else dpodd[j] = dpodd[j];\n            } else {\n                dpodd[j] = dpodd[j];\n            }\n        }\n    }\n\n    while (true) {\n        int x; cin >> x;\n        if (!x) break;\n        cout << dp[x] << \" \" << dpodd[x] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<int> tri;\nvector<int> b;\nvector<int> a;\nint ansa[1000005];\nint ansb[1000005];\n\nint main()\n{\n\ttri.push_back(0);\n\ta.push_back(0);\n\tFOR(i, 1, 10000) tri.push_back(tri[i - 1] + i);\n\tFOR(i, 1, 10000)\n\t{\n\t\ta.push_back(a[i - 1] + tri[i]);\n\t\tif (a.back() & 1) b.push_back(a.back());\n\t\tif (a.back() > 1000001) break;\n\t}\n\tfill(ALL(ansa), INF);\n\tfill(ALL(ansb), INF);\n\n\tREP(i, a.size())\n\t{\n\t\tansa[a[i]] = 1;\n\t\tREP(j, 1000001)\n\t\t{\n\t\t\tint t = j + a[i];\n\t\t\tif (t > 1000001) break;\n\t\t\tansa[t] = min(ansa[t],ansa[j] + 1);\n\t\t}\n\t}\n\tREP(i, b.size())\n\t{\n\t\tansb[b[i]] = 1;\n\t\tREP(j, 1000001)\n\t\t{\n\t\t\tint t = j + b[i];\n\t\t\tif (t > 1000001) break;\n\t\t\tansb[t] = min(ansb[t],ansb[j] + 1);\n\t\t}\n\t}\n\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tcout << ansa[n] << \" \" << ansb[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define from_to(from, to, i) for(int i=from;i<=to;i++)\n\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 1000010;\nconst int INF = 1<<20;\n\nint main(int argc, char const* argv[])\n{\n    vector<int> V;\n    for (int i = 1; i*(i+1)*(i+2)/6 < MAX; i++) {\n        V.push_back(i*(i+1)*(i+2)/6);\n    }\n\n    int all[MAX], odd[MAX];\n    fill(all, all+MAX, INF);\n    fill(odd, odd+MAX, INF);\n\n    all[0] = odd[0] = 0;\n    for (int v : V) {\n        loop (v, i) {\n            for (int j = 1; i+v*j < MAX; j++) {\n                all[i+v*j] = min((ll)all[i+v*j], (ll)all[i] + j);\n\n                if (v%2) {\n                    odd[i+v*j] = min((ll)odd[i+v*j], (ll)odd[i] + j);\n                }\n            }\n        }\n    }\n\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        printf(\"%d %d\\n\", all[n], odd[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <unordered_set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <functional>\n#include <cassert>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define ALL(v) v.begin(),v.end()\ntemplate < class T > inline bool chmax(T& a, T b) {if (a < b) { a=b; return true; } return false; }\ntemplate < class T > inline bool chmin(T& a, T b) {if (a > b) { a=b; return true; } return false; }\n#define DEBUG_VLL(vec) REP(sz, vec.size()) std::cerr<<vec[sz]<<(sz==vec.size()-1?'\\n':' ');\n\nconst long long MOD = 1000000007;\nconst long long HIGHINF = (long long)1e18;\nconst int INF = (int)1e9;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    vll proc(200, 0);\n    for (ll i = 1; i < 200; i++) proc[i] = i * (i + 1) * (i + 2) / 6;\n\n    vll dp(1000005, HIGHINF), odd_dp(1000005, HIGHINF);\n    dp[0] = odd_dp[0] = 0;\n    for (ll i = 0; i < 1000005; i++) {\n        for (ll j = 0; j < 200; j++) {\n            if (i - proc[j] >= 0) {\n                chmin(dp[i], dp[i - proc[j]] + 1);\n                if (proc[j] % 2 == 1) chmin(odd_dp[i], odd_dp[i - proc[j]] + 1);\n            }\n        }\n    }\n\n    ll n;\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        cout << dp[n] << ' ' << odd_dp[n] << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint dp[1000001];\nint dp2[1000001];\nvector<int> vi;\n\nvoid solve(){\n\tfor(int i=1;i*(i+1)*(i+2)/6 <= 1000000;i++){\n\t\tvi.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tfill(dp,dp+1000001,9999999);\n\tfill(dp2,dp2+1000001,9999999);\n\t\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor(int i=0;i<1000000;i++){\n\t\tif(dp[i] != 9999999){\n\t\t\tfor(int j=0;j<vi.size();j++){\n\t\t\t\tif(i+vi[j] <= 1000000){\n\t\t\t\t\tdp[i+vi[j]] = min(dp[i+vi[j]],dp[i]+1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp2[i] != 9999999){\n\t\t\tfor(int j=0;j<vi.size();j++){\n\t\t\t\tif(i+vi[j] <= 1000000 && vi[j]%2 == 1){\n\t\t\t\t\tdp2[i+vi[j]] = min(dp2[i+vi[j]],dp2[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\tsolve();\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n==0){\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1 << 30;\nconst int SIZE = 300;\nconst int N = 1000002;\nint p[SIZE+1];\nint dp1[N], dp2[N];\n\nvoid make_pollock (void )\n{\n\tmemset (p, 0, sizeof (p ) );\n\n\tfor (int i = 0; i <= SIZE; i++ ){\n\t\tll ans = (ll)i*(i+1LL)*(i+2LL)/6LL;\n\t\tp[i] = (int)ans;\n\t} // end for\n}\n\nvoid make_dp (void )\n{\n\tfill (dp1, dp1+N, INF );\n\tfill (dp2, dp2+N, INF );\n\n\tdp1[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp1[j] = min (dp1[j], dp1[j-m]+1 );\n\t} // end for\n\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tif (p[i] % 2 == 0 ) continue;\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp2[j] = min (dp2[j], dp2[j-m]+1 );\n\t} // end for\t\n}\n\t\nint main()\n{\n\tmake_pollock();\n\tmake_dp ();\n\n\tint n;\n\twhile (cin >> n, n )\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[1000010] = { 0 };\nint dpodd[1000010] = { 0 };\n\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= 1000009; i++) {\n\t\tdp[i] = 1001000;\n\t}\n\tfor (int i = 1; i <= 1000009; i++) {\n\t\tdpodd[i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[i] = dp[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i] = min(dp[i], dp[i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (int j = 1; j <= 50; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[i] = dpodd[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[i] = min(dpodd[i], dpodd[i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/*for (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}*/\n\t\n\n\t\t\n\n\t\tCO dp[N] << \" \";\n\n\t\t\n\t\t/*for (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}*/\n\t\t\n\n\t\tCO dpodd[N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[1000010];\nint dp2[1000010];\n\ninline int tetnum(int n) {\n\treturn n * (n + 1) * (n + 2) / 6;\n}\n\nint main () {\n\tdp[0] = 0;\n\tfill(dp, dp + 1000010, 0x7ffffff);\n\tfill(dp2, dp2 + 1000010, 0x7ffffff);\n\tfor (int i = 0; tetnum(i) < 1000010; i++) dp[tetnum(i)] = 1;\n\tfor (int i = 0; tetnum(i) < 1000010; i++) {\n\t\tif (tetnum(i) & 1) dp2[tetnum(i)] = 1;\n\t}\n\tfor (int i = 1; i <= 1000010; i++) {\n\t\tfor (int j = 0; i - tetnum(j) > 0; j++) {\n\t\t\tdp[i] = min(dp[i], dp[i - tetnum(j)] + 1);\n\t\t\tif (tetnum(j) & 1) {\n\t\t\t\tdp2[i] = min(dp2[i], dp2[i - tetnum(j)] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, table[200];\nint dp[1000000], odddp[1000000];\n\nint main()\n{\n\tfor (int i = 0; i < 183; ++i)table[i] = i * (i + 1) * (i + 2) / 6;\n\tfor (int i = 0; i < 1000000; ++i){\n\t\todddp[i] = 20000000;\n\t\tdp[i] = 20000000;\n\t}\n\tdp[0] = odddp[0] = 0;\n\tdp[1] = odddp[1] = 1;\n\tfor (int i = 2; i < 1000000; ++i){\n\t\tfor (int j = 1; table[j] <= i; ++j){\n\t\t\tdp[i] = min(dp[i], dp[i - table[j]] + 1);\n\t\t\tif (table[j] % 2)odddp[i] = min(odddp[i], odddp[i - table[j]] + 1);\n\t\t}\n\t}\n\twhile (cin >> n){\n\t\tif (!n)return 0;\n\t\tcout << dp[n] << ' ' << odddp[n] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ntemplate<class T> void pp(T a, T b){ for(T i = a; i != b; ++i) cout << *i << ' '; cout << endl; }\n\n#define INF (1<<29)\n\nint N;\nint d[200];\nint dp[1000010][2];\n\nvoid init(){\n  int n;\n  rep(n,200) d[n] = n * (n+1) * (n+2) / 6;\n}\n\n\nint main(){\n  int i,j;\n\n  init();\n\n  // pp(d,d+200);\n\n  rep(i,1000010) rep(j,2) dp[i][j] = INF;\n\n  dp[0][0] = dp[0][1] = 0;\n  rep(i,1000010) for(j = 1; d[j] <= i+1; j++){\n    if(i - d[j] >= 0){\n      dp[i][0] = min(dp[i][0], dp[i-d[j]][0] + 1);\n      if(d[j] % 2 == 1){\n        dp[i][1] = min(dp[i][1], dp[i-d[j]][1] + 1);\n      }\n    }\n  }\n\n\n  while(1){\n    scanf(\"%d\",&N);\n    if(N == 0) break;\n\n    printf(\"%d %d\\n\",dp[N][0],dp[N][1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nvi all, odd;\nvi dpall, dpodd;\n\nvoid init() {\n  int n = 1000000;\n  int sz = SZ(all);\n  dpall.resize(1000001, INF);\n  dpall[0] = 0;\n  REP(i, sz) {\n    if(all[i] > n) break;\n    REP(j, n+1) {\n      if(j + all[i] <= n) {\n        chmin(dpall[j+all[i]], dpall[j] + 1);\n      }\n    }\n  }\n\n  sz = SZ(odd);\n  dpodd.resize(1000001, INF);\n  dpodd[0] = 0;\n  REP(i, sz) {\n    if(odd[i] > n) break;\n    REP(j, n+1) {\n      if(j + odd[i] <= n) {\n        chmin(dpodd[j+odd[i]], dpodd[j] + 1);\n      }\n    }\n  }\n\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  REP(i, 1000) {\n    int tmp = i * (i + 1) * (i + 2) / 6;\n    if(tmp > 1000000) break;\n    all.push_back(tmp);\n    if(tmp&1) odd.push_back(tmp);\n  }\n\n  init();\n\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    cout << dpall[n] << \" \" << dpodd[n] << endl;\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\nint dp[500];\nint dp1[11111500];\nint dp2[11111100];\nint main(){\n    dp[1]=1;\n    for(int i=2;i<210;i++){\n        dp[i]=dp[i-1]+i;\n    }\n    for(int i=2;i<210;i++){\n        dp[i]=dp[i-1]+dp[i];\n    }\n   // fill(dp,dp+400,0);\n    fill(dp1,dp1+1111100,9999999999);\n    fill(dp2,dp2+1111100,9999999999);\n    dp1[0]=0;dp2[0]=0;\n    for(int i=1;i<210;i++){\n        int now=dp[i];\n        for(int k=now;k<1100000;k++){\n            if(dp1[k]>dp1[k-now]+1){\n                dp1[k]=dp1[k-now]+1;\n            }\n        }\n    }\n    for(int i=1;i<300;i++){\n        int now=dp[i];\n        if(now%2==0)\n            continue;\n        for(int k=now;k<1100000;k++){\n            if(dp2[k]>dp2[k-now]+1)\n                dp2[k]=dp2[k-now]+1;\n        }\n    }\n    int n;\n    while(1){\n        cin>>n;\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[1000001];\nint odd[1000001];\nconst int n=1000000;\n\nvoid update(int* dp,int x){\n  for(int i=1;i<=n;i++){\n    if(i<x)continue;\n    dp[i]=min(dp[i],dp[i-x]+1);\n  }\n}\n\nint main(){\n  dp[0]=odd[0]=0;\n  for(int i=1;i<=n;i++){\n    dp[i]=99999999;\n    odd[i]=99999999;\n  }\n  for(int i=1;i<=n;i++){\n    int x=i*(i+1)*(i+2)/6;\n    if(x>n)break;\n    update(dp,x);\n    if(x&1)update(odd,x);\n  }\n  int a;\n  while(cin>>a,a){\n    cout << dp[a] << \" \" << odd[a] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=100000000;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nstring s;\nvector<int> a,b;\nint dp[1000001],dp2[1000001];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  for(int i=1;i<200;i++){\n    a.push_back(i*(i+1)*(i+2)/6);\n    int temp=i*(i+1)*(i+2)/6;\n    if(temp&1)b.push_back(temp);\n  }\n  for(int i=0;i<=1000000;i++)dp[i]=inf;\n  dp[0]=0;\n  for(int i=0;i<=1000000;i++){\n    for(int j=0;j<(int)a.size();j++){\n      if(i+a[j]<=1000000){\n        dp[i+a[j]]=min(dp[i+a[j]],dp[i]+1);\n      }\n    }\n  }\n  for(int i=0;i<=1000000;i++)dp2[i]=inf;\n  dp2[0]=0;\n  for(int i=0;i<=1000000;i++){\n    for(int j=0;j<(int)b.size();j++){\n      if(i+b[j]<=1000000){\n        dp2[i+b[j]]=min(dp2[i+b[j]],dp2[i]+1);\n      }\n    }\n  }\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<1;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\nint n = 0;\n\n\n\nvoid input() {\n\tCI n;\n}\n\n\nvoid proce_odd() {\n\tvector<int> tetra;\n\tint num = 1;\n\n\tint i = 0;\n\tint remain = 0;\n\tint maxx = 0;\n\n\twhile (true) {\n\n\t\tif (i * (i + 1) * (i + 2) / 6 > n && (i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n\t\t\ti--;\n\t\t\tauto ite = tetra.end();\n\t\t\tite--;\n\t\t\tmaxx = *ite;\n\t\t\tbreak;\n\t\t}\n\t\tif ((i * (i + 1) * (i + 2) / 6) % 2 == 1) {\n\t\t\ttetra.push_back(i * (i + 1) * (i + 2) / 6);\n\t\t}\n\t\ti++;\n\t}\n\n\tremain = n - maxx;\n\tvector<int>::iterator it_end = tetra.end();\n\tvector<int>::iterator it_last = tetra.end();\n\t--it_end;\n\n\tint num_min = 1000001;\n\twhile (1) {\n\t\twhile (remain > 0) {\n\t\t\tnum++;\n\t\t\t++it_end;\n\t\t\tit_end = upper_bound(tetra.begin(), it_end, remain);\n\t\t\t--it_end;\n\n\t\t\tremain -= *it_end;\n\t\t}\n\t\tif (num_min > num) {\n\t\t\tnum_min = num;\n\t\t}\n\t\tnum = 1;\n\t\tremain = n - *--it_last;\n\t\tif (remain == n - 1)break;\n\t\tit_end = it_last;\n\t}\n\n\tCO num_min E;\n\n}\n\nvoid proce() {\n\tvector<int> tetra;\n\tint num = 1;\n\n\tint i = 0;\n\tint remain = 0;\n\tint maxx = 0;\n\n\twhile (true) {\n\n\t\tif (i * (i + 1) * (i + 2) / 6 > n) {\n\t\t\ti--;\n\t\t\tmaxx = i * (i + 1) * (i + 2) / 6;\n\t\t\tbreak;\n\t\t}\n\t\ttetra.push_back(i * (i + 1) * (i + 2) / 6);\n\t\ti++;\n\t}\n\n\tremain = n - maxx;\n\tvector<int>::iterator it_end = tetra.end();\n\tvector<int>::iterator it_last = tetra.end();\n\t--it_end;\n\n\tint num_min = 1000001;\n\twhile (1) {\n\t\twhile (remain > 0) {\n\t\t\tnum++;\n\t\t\t++it_end;\n\t\t\tit_end = upper_bound(tetra.begin(), it_end, remain);\n\t\t\t--it_end;\n\n\t\t\tremain -= *it_end;\n\t\t}\n\t\tif (num_min > num) {\n\t\t\tnum_min = num;\n\t\t}\n\t\tnum = 1;\n\t\tremain = n - *--it_last;\n\t\tif (remain == n - 1)break;\n\t\tit_end = it_last;\n\t}\n\n\tCO num_min;\n\n\n}\n\nint main(void) {\n\twhile (true) {\n\t\tinput();\n\t\tif (n == 0)break;\n\n\t\tproce();\n\n\t\tCO ' ';\n\n\t\tproce_odd();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdafx.h\"\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\nusing pci = pair<char, int>;\nusing vpci = vector<pci>;\n#define out(S) cout<<(S)<<endl;\n#define REP(i,b) for(size_t i=0;i<(b);i++)\n#define rREP(i,b) for(int i=(b)-1;i>=0;i--)\n#define FOR(i,a,b) for(size_t i=(a);i<(b);i++)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define Foreach(item,collection) for(auto item:collection)\n#define mod(i) ((i) % (ll)(1e9 + 7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a * modpow((ll)b,(ll)(1e9 + 5))))\n#define Yes out(\"Yes\")\n#define No out(\"No\")\n#define NO out(\"NO\")\n#define YES out(\"YES\")\n#define INF 1e10;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define IfOut(condition,text) if((condition)){out(text);return 0;}\n#define IfeOut(condition,itext,etext) if(condition){out(itext);return 0;}else{out(etext);return 0;}\n#define Select(collection,condition,result) Foreach(i,collection){result+=condition;}\n#define GetAuto(_N,vect) {cin>>_N;vect.resize(_N);REP(i,_N){cin>>vect[i];}}\n#define beginend(vec) (vec).begin(),(vec).end()\n#define pb(item) push_back(item)\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) { ll prime; double sqrtmax = sqrt(max); vector<ll> primeVec, searchVec; FOR(i, 2, max + 1) searchVec.push_back(i); do { prime = searchVec[0]; primeVec.push_back(prime); auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; }); searchVec.erase(itr, searchVec.end()); } while (prime < sqrtmax); primeVec.reserve(primeVec.size() + searchVec.size()); primeVec.insert(primeVec.end(), beginend(searchVec)); return primeVec; }\nbool isPrime(ll x) { if (x == 2) return true; if (x < 2 || x % 2 == 0) return false; ll i = 3; while (i <= sqrt(x)) { if (x%i == 0) return false; i += 2; }return true; }\n\n\nmap<int, int> dp, odddp;\nint main() {\n\tint N;\n\tint p = 4;\n\tREP(i, 1000000) {\n\t\tdp[i] = i;\n\t\todddp[i] = i;\n\t}\n\tint n = 3;\n\twhile (p<=1000000)\n\t{\n\t\tfor (int i = 0; i+p <=1000000; i++)\n\t\t{\n\t\t\tdp[i + p] = min(dp[i + p], dp[i] + 1);\n\t\t}\n\t\tif (p % 2 == 1) {\n\t\t\tfor (int i = 0; i + p <= 1000000; i++)\n\t\t\t{\n\t\t\t\todddp[i + p] = min(odddp[i + p], odddp[i] + 1);\n\t\t\t}\n\t\t}\n\n\t\tp = n*(n + 1)*(n + 2) / 6;\n\t\tn++;\n\t}\n\n\t\n\n\twhile (cin>>N,N)\n\t{\n\t\tcout << dp[N - 1] << \" \" << odddp[N - 1] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nint f(int n) {\n    return n * (n + 1) * (n + 2) / 6;\n}\n\nconst int INF = 1e9;\n\nint main() {\n    vector <int> all, odd;\n    for (int i = 0; f(i) < 1e6; i++) {\n        int fi = f(i);\n        all.push_back(fi);\n        if (fi % 2) odd.push_back(fi);\n    }\n\n    vector <int> allDp(1e6, INF);\n    allDp[0] = 0;\n    for (int i = 0; i < 1e6; i++) {\n        for (auto & j : all) {\n            if (i + j >= 1e6) continue;\n            allDp[i + j] = min(allDp[i + j], allDp[i] + 1);\n        }\n    }\n\n    vector <int> oddDp(1e6, INF);\n    oddDp[0] = 0;\n    for (int i = 0; i < 1e6; i++) {\n        for (auto & j : odd) {\n            if (i + j >= 1e6) continue;\n            oddDp[i + j] = min(oddDp[i + j], oddDp[i] + 1);\n        }\n    }\n\n\n    int n;\n    while (cin >> n, n) {\n        cout << allDp[n] << \" \" << oddDp[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n int i,j,n,three[1000000],four[1000000],four_2[1000000],c[1000000],c_2[1000000];\n\nint main(){\n  \n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 1000000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 1000000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 1000000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < 100; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < 100; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\n\nint N = 0;\nint C[190];\nint Codd[50];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dp[1000010];\nint dp2[1000010];\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\trep(i, 0, 1000010) {\n\t\t\tdp[i] = 10;\n\t\t\tdp2[i] = 10000000;\n\t\t}\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\trep(i, 1, 200) {\n\t\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\t\trep(j, 0, n + 1) {\n\t\t\t\tif (j + a > n) continue;\n\t\t\t\tdp[j + a] = min(dp[j + a], dp[j] + 1);\n\t\t\t\tif (a % 2 == 0) continue;\n\t\t\t\tdp2[j + a] = min(dp2[j + a], dp2[j] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include <climits>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nint dpAll[1000010];\nint dpOdd[1000010];\nvector<int> v;\n\nint dfsAll(int rem){\n  if(rem == 0) return 0;\n  if(dpAll[rem] != INT_MAX) return dpAll[rem];\n\n  int res = INT_MAX;\n  for(int i=0;i<v.size() && v[i]<=rem;i++){\n    int tmp = dfsAll(rem-v[i]);\n    if(tmp != INT_MAX && res > tmp + 1) res = tmp + 1;\n  }\n  return dpAll[rem]=res;\n}\n\nint dfsOdd(int rem){\n  if(rem == 0) return 0;\n  if(dpOdd[rem] != INT_MAX) return dpOdd[rem];\n\n  int res = INT_MAX;\n  for(int i=0;i<v.size() && v[i]<=rem;i++){\n    if(v[i] % 2 == 1){\n      int tmp = dfsOdd(rem-v[i]);\n      if(tmp != INT_MAX && res > tmp + 1) res = tmp + 1;\n    }\n  }\n  return dpOdd[rem]=res;\n}\n\nint main(){\n  int n;\n\n  for(int i=1;i*(i+1)*(i+2)/6<=1000100;i++){\n    v.push_back(i*(i+1)*(i+2)/6);\n  }\n\n  rep(i,1000010) dpAll[i] = INT_MAX;\n  rep(i,1000010) dpOdd[i] = INT_MAX;\n  for(int i=1;i<=1000002;i+=10000) dfsAll(i);\n  for(int i=1;i<=1000002;i+=10000) dfsOdd(i);\n\n  while(cin>>n,n){\n    cout<<dpAll[n]<<\" \"<<dpOdd[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n\nint main() {\n\n    vector<int> poloq;\n    for (int i = 0; i < 190; i++) poloq.push_back((i + 1) * (i + 2) * (i + 3) / 6);\n    //for (int i = 0; i < 190; i++) cout << poloq[i] << \" \";\n\n\n    vector<int> all = poloq;\n    vector<int> odd;\n    for (int i = 0; i < all.size(); i++) if (all[i] % 2 == 1) odd.push_back(all[i]);\n//\n//    for (int i = 0; i < poloq.size(); i++)cout << poloq[i] << \" \";\n//    cout << endl;\n//    for (int i = 0; i < odd.size(); i++)cout << odd[i] << \" \";\n\n    vector<int> ans1(1300000);\n    vector<int> ans2(1300000);\n\n    ans1[0] = 0;\n    ans1[1] = 1;\n    for (int i = 2; i <= 1200000; i++) {\n        ans1[i] = ans1[i - 1] + 1;\n        for (int j = 0; j < all.size(); j++) {\n            if (all[j] <= i) ans1[i] = min(ans1[i], ans1[i - all[j]] + 1);\n            else break;\n        }\n    }\n    // for (int i = 0; i < 10000; i++) cout << ans1[i] << \" \";\n\n    ans2[0] = 0;\n    ans2[1] = 1;\n    for (int i = 2; i <= 1200000; i++) {\n        ans2[i] = ans2[i - 1] + 1;\n        for (int j = 0; j < odd.size(); j++) {\n            if (odd[j] <= i) ans2[i] = min(ans2[i], ans2[i - odd[j]] + 1);\n            else break;\n        }\n    }\n    //for (int i = 0; i < 10000; i++) cout << ans2[i] << \" \";\n\n    while (true) {\n        int N;\n        cin >> N;\n\n        if (N == 0) break;\n\n        cout << ans1[N] << \" \" << ans2[N] << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define print(x)cout<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\n\nll dp[2000000];\nll dp2[2000000];\nconst ll INF = 1e9;\nint main() {\n  vl A;\n  ll x = 0;\n  int m = 1;\n  while(x<=1000000){\n    x = m*(m+1)*(m+2)/6;\n    A.push_back(x);\n    m++;\n    //if(x<100)show(x);\n  }\n  int k = sz(A);\n  fill(dp,dp+2000000,INF);\n  fill(dp2,dp2+2000000,INF);\n  dp[0] = 0;\n  dp2[0] = 0;\n  srep(i,1,1000001){\n    rep(j,k){\n      if((i - A[j])< 0) break;\n      dp[i] = min(dp[i],dp[i - A[j]]+1);\n      if(A[j]%2)dp2[i] = min(dp2[i],dp2[i - A[j]]+1);\n    }  \n  }\n  //rep(i,100)cout<<i << \" \" << (dp2[i]) << endl;\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0){\n      return 0;\n    }\n    cout<<dp[n]<<\" \"<< dp2[n]<<endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstring>\n#include<string>\n#include <math.h>\n#include<algorithm>\n#include<functional>\n\n#define ll long long\n#define inf  1000000007\n#define mod 1000000007\n#define pa pair<int,int>\n#define pal pair<ll,ll>\n#define ppa pair<int,pa>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\nclass Point{\n  public:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y) {}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double a) {return Point(x*a,y*a);}\n  Point operator / (double a) {return Point(x/a,y/a);}\n  double absv() {return sqrt(norm());}\n  double norm() {return x*x+y*y;}\n  bool operator < (const Point &p) const{\n    return x != p.x ? x<p.x: y<p.y;\n  }\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\ntypedef Point Vector;\n\nstruct Segment{\nPoint p1,p2;\n};\n\ndouble hen(Vector a){\nif(fabs(a.x)<EPS && a.y>0) return acos(0);\nelse if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\nelse if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\nelse if(fabs(a.y)<EPS && a.x>0) return 0.0;\nelse if(a.y>0) return acos(a.x/a.absv());\nelse return 2*acos(0)+acos(-a.x/a.absv());\n\n}\n\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ru[11]={1,2,4,8,16,32,64,128,256,512,1024};\n\nll frac[100010];\nll inv[100010];\n\nll saikif(ll a,int n){\n  if(n==1) return a%mod;\n  else if(n%2==0){\n    ll q=saikif(a,n/2);\n    return (q*q)%mod;\n  }\n  else return (a*saikif(a,n-1))%mod;\n}\n\nvoid gyakugen(){\n  frac[0]=1;\n  for(int i=1;i<=100000;i++) frac[i]=(frac[i-1]*i)%mod;\n  for(int i=0;i<=100000;i++) inv[i]=saikif(frac[i],mod-2);\n}\n\n\n//----------------kokomade temple------------\nint dp[100002];\nint dp2[100002];\nvector<int> ve;\nvector<int> ve2;\nint num,num2;\n\nint dfs(int n){\nif(dp[n]<inf) return dp[n];\nelse{\n//  cout<<n<<endl;\n  int ans=inf;\nfor(int j=0;j<num;j++){\n  if(ve[j]>=n) break;\n\n  ans=min(ans,1+dfs(n-ve[j]));\n}\n  dp[n]=ans;\n  return ans;\n}\n\n}\n\nint dfs2(int n){\nif(dp2[n]<inf) return dp2[n];\nelse{\n//  cout<<n<<endl;\n  int ans=inf;\nfor(int j=0;j<num2;j++){\n  if(ve2[j]>=n) break;\n\n  ans=min(ans,1+dfs2(n-ve2[j]));\n}\n  dp2[n]=ans;\n  return ans;\n}\n\n}\n\n\n\nint main(){\n  fill(dp,dp+100002,inf);\n  fill(dp2,dp2+100002,inf);\nint z=1,w;\nwhile(1){\n  w=z*(z+1)*(z+2)/6;\n  //cout<<w<<endl;\n  if(w>100000) break;\n  else{\n    ve.push_back(w);\n    if(w%2==1){\n      ve2.push_back(w);\n      dp2[w]=1;\n    }\n    z++;\n    dp[w]=1;\n\n  }\n}\nnum=ve.size();\nnum2=ve2.size();\nfor(int i=1;i<100001;i++){\n  dfs(i);\n  dfs2(i);\n}\n\nint n;\n\nwhile(cin>>n){\n  if(n==0) break;\n  cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n}\n\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[1000], fourodd[1000];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nint main()\n{\n  static const int N = 1000000;\n\n  vector<int> vs;\n  for (int i = 1; ; i++) {\n    const int x = i*(i+1)*(i+2)/6;\n    if (x >= N) {\n      break;\n    }\n    vs.push_back(x);\n  }\n\n  vector<int> dp(N, numeric_limits<int>::max()), dp_odd(N, numeric_limits<int>::max());\n  dp[0] = dp_odd[0] = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < vs.size(); j++) {\n      if (i + vs[j] < N) {\n        dp[i+vs[j]] = min(dp[i+vs[j]], dp[i]+1);\n        if (vs[j] % 2 == 1) {\n          dp_odd[i+vs[j]] = min(dp_odd[i+vs[j]], dp_odd[i]+1);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  int n;\n  while (cin >> n && n != 0) {\n    cout << dp[n] << ' ' << dp_odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n/*sqrt<3>(NMAX)==100*/\n\nint Nkake[100+1];\nint g[1000001]={0};\nint k[1000001]={0};\n\nint main(){\n\n\tint N;\n\t\n\tfor(int i=1;i<=200;i++){\n\t\tNkake[i]=i*(i+1)*(i+2)/6;\n\t}\n\n\tfor(int i=0;i<=1000000;i++){\n\t\tfor(int j=1;j<200;j++){\n\t\t\tif(i+Nkake[j]<=1000000){\n\t\t\t\tif(g[Nkake[j]+i]==0||g[Nkake[j]+i]>g[i]+1) g[Nkake[j]+i]=g[i]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<=1000000;i++){\n\t\tfor(int j=1;j<200;j++){\n\t\t\tif(Nkake[j]%2==1&&i+Nkake[j]<=1000000){\n\t\t\t\tif(k[Nkake[j]+i]==0||k[Nkake[j]+i]>k[i]+1) k[Nkake[j]+i]=k[i]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\n\t\tcout<<g[N]<<\" \"<<k[N]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define rep1(i,n) for(int i = 1; i <= (n); i++)\n#define rrep1(i,n) for(int i = (n); i > 0; i--)\n\n#define ll long long\n#define pi pair<int, int>\n#define pll pair<ll, ll>\n\n#define MOD 1000000007\n#define INF 1000000000\n\nusing namespace std;\n\n#define MAXN 999999\n\nint tetrahedrons[MAXN];\nint triangles[MAXN];\n\nint dp[MAXN];\nint odp[MAXN];\n\nint main(){\n  rep1(i, MAXN-1){\n    triangles[i] = triangles[i-1] + i;\n    tetrahedrons[i] = triangles[i] + tetrahedrons[i-1];\n  }\n\n  rep(i, MAXN)dp[i]=INF;\n  dp[0]=0;\n  rep(i, 2000){\n    rep1(j, MAXN){\n      int c = tetrahedrons[i];\n\n      if(j-c>=0)dp[j] = min<ll>(dp[j], dp[j-c]+1);\n    }\n  }\n\n  rep(i, MAXN)odp[i]=INF;\n  odp[0]=0;\n  rep(i, 2000){\n    rep1(j, MAXN){\n      int c = tetrahedrons[i];\n      if(c%2==0)continue;\n\n      if(j-c>=0)odp[j] = min<ll>(odp[j], odp[j-c]+1);\n    }\n  }\n\n  while(true){\n    int n;cin>>n;\n    if(n==0)break;\n\n    cout<<dp[n]<<' '<<odp[n]<<endl;\n\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nconst int MAX = 1111111;\n\nint dpall[MAX];\nint dpodd[MAX];\nvi tri, all, odd;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\n\ttri.push_back(1);\n\tFOR(i, 2, MAX)\n\t{\n\t\tint t = tri.back() + i;\n\t\tif (t >= MAX) break;\n\t\ttri.push_back(t);\n\t}\n\n\tall.push_back(1);\n\todd.push_back(1);\n\tFOR(i, 2, MAX)\n\t{\n\t\tint t = all.back() + tri[i-1];\n\t\tif (t >= MAX) break;\n\t\tall.push_back(t);\n\t\tif (t % 2 == 1) odd.push_back(t);\n\t}\n\n\tREP(i, MAX)\n\t{\n\t\tdpall[i] = dpodd[i] = MAX;\n\t}\n\n\tfor (auto i : all) dpall[i] = 1;\n\tfor (auto i : odd) dpodd[i] = 1;\n\n\tFOR(i, 1, MAX)for (auto j : all)\n\t{\n\t\tint t = i + j;\n\t\tif (t >= MAX) break;\n\t\tchmin(dpall[t], dpall[i] + 1);\n\t}\n\tFOR(i, 1, MAX)for (auto j : odd)\n\t{\n\t\tint t = i + j;\n\t\tif (t >= MAX) break;\n\t\tchmin(dpodd[t], dpodd[i] + 1);\n\t}\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tcout << dpall[n] << \" \" << dpodd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n\nint f(int x) {\n  return ((x)*(x+1)*(x+2))/6;\n}\n\nconst int INF = 1 << 28;\n\nint main()\n{\n  vector<int> list;\n  for(int i = 1; f(i) < 1000000; ++i) {\n    list.push_back(f(i));\n  }\n  int adp[1000000] = {};\n  bool done[1000000] = {};\n  rep(i, 1000000) {\n    adp[i] = INF;\n  }\n  done[0] = true;\n  adp[0] = 0;\n  for(auto v : list) {\n    rep(i, 1000000 - v) {\n      if(done[i]) {\n        adp[i + v] = min(adp[i + v], adp[i] + 1);\n        done[i + v] = true;\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    cout << adp[n];\n    int cnt = 0;\n    for(int i = list.size() - 1; 0 <= i; --i) {\n      if( list[i]&1 && n >= list[i] ) {\n        int m = n / list[i];\n//        cerr << n << \" : \" << list[i] << \"*\" << m << endl;\n        cnt += m;\n        n -= list[i] * m;\n      }\n    }\n    cout << \" \" << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int int64_t\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) begin(c), end(c)\n\n\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tconst int NM = 1e6;\n\tvector<int> seisi, dp(NM, 1 << 29), dp2(NM, 1 << 29);\n\tfor (int i = 1; i * (i + 1) * (i + 2) / 6 < NM; i++) {\n\t\tint x = i * (i + 1) * (i + 2) / 6;\n\t\tseisi.push_back(x);\n\t}\n\tdp2[0] = dp[0] = 0;\n\trep(i, NM) {\n\t\tfor (auto x : seisi) {\n\t\t\tif (i - x < 0) break;\n\t\t\tdp[i] = min(dp[i], dp[i - x] + 1);\n\t\t\tif (x % 2) dp2[i] = min(dp2[i], dp2[i - x] + 1);\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n && n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n/*\n#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n#include <complex>\n#include <bitset>\n#include <functional>\n#include <stack>\n#include <regex>\n#include <tuple>\n*/\n#define int long long\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define mod 1000000007\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define showp(n) cerr<<n.fs<<\", \"<<n.sc<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n#define showsp(n) for(auto z:n){cerr<<z.fs<<\" \"<<z.sc<<\", \"}cerr<<endl\n\n#define yes printf(\"Yes\\n\")\n#define no printf(\"No\\n\")\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int,int>;\n\nconst int INF=1LL<<55;\n\nint n;\nint a[100001],b[100001];\nint v;\n\nvoid ume(){\n    REP(i,1,100001){\n        a[i]=b[i]=i;\n        for(int j=0;;j++){\n            v=j*(j+1)*(j+2)/6;\n            if(i-v<0) break;\n            a[i]=min(a[i], a[i-v]+1);\n            if(v&1) b[i]=min(b[i],b[i-v]+1);\n        }\n    }\n}\n\nvoid solve(){\n    \n    cout<<a[n]<<\" \"<<b[n]<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ume();\n    while(cin>>n,n){\n        solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\n#define reps(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, N) reps(i, 0, N-1)\n#define deps(i, E, S) for (ll i = (E); i >= (S); i--)\n#define dep(i, N) deps(i, N-1, 0)\nconst ll INF = 1LL << 60;\nconst int INF_INT = 1 << 30;\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\nstruct mll {\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0) : val(v % MOD) { if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val = (val + b.val) % MOD; return *this; }\n\tmll &operator -= (const mll &b) { val = (val + MOD - b.val) % MOD; return *this; }\n\tmll &operator *= (const mll &b) { val = (val*b.val) % MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c = b.val, d = MOD, u = 1, v = 0;\n\t\twhile (d) {\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b) {\n\t\tchmin(b, a - b);\n\t\tif (b < 0) return mll(0);\n\t\tmll c = 1;\n\t\trep(i, b) c *= a - i;\n\t\trep(i, b) c /= i + 1;\n\t\treturn c;\n\t}\n};\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\n//struct Fast {\n//\tFast() {\n//\t\tcin.tie(0);\n//\t\tios::sync_with_stdio(false);\n//\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n//\t}\n//} fast; //cin,cout高速化のおまじない＋桁数指定\n//\n//ll mll::MOD = (ll)(1e9 + 7);// 998244353ll;\n\n\nint main() {\n\tvll A;\n\tll num = 1;\n\twhile (true) {\n\t\tll temp = num * (num + 1) * (num + 2) / 6;\n\t\tif (temp < 1000000) {\n\t\t\tA.push_back(temp);\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\tnum++;\n\t}\n\n\tvll ansAll(1000000, INF);\n\tvll ansOdd(1000000, INF);\n\tansAll[0] = 0;\n\tansOdd[0] = 0;\n\treps(i, 1, 1000000 - 1) {\n\t\t//all\n\t\trep(j, A.size()) {\n\t\t\tll prev = i - A[j];\n\t\t\tif (prev < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchmin(ansAll[i], ansAll[prev] + 1);\n\n\t\t\tif (A[j] % 2 > 0) {\n\t\t\t\tchmin(ansOdd[i], ansOdd[prev] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tll N;\n\t\tcin >> N;\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << ansAll[N] << \" \" << ansOdd[N] << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\n    int res=0xFFFF;\n    if(maxcnt<cnt) return 0xFFFE;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n        if(res==0xFFFE) break;\n    }\n    return res;\n}\nint ress;\nvoid mama(int x){\n    if(x==0) return;\n    int tmp[oddlistcnt];\n    memset(tmp,0,sizeof(tmp));\n    for(int i=0;i<oddlistcnt;i++){\n        tmp[i]=x/oddlist[i];\n        if(tmp[i]==0) {\n            ress+=tmp[i-1];\n            mama(x%tmp[i-1]);\n            break;\n        }\n    }\n}\n\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        /*        if((oddres=oddrec(n, 0, 0, 1))>=0xFFFE) {\n                  for(int i=2; ; i=i*3/2) {\n                  if((oddres=oddrec(n, 0, 0, i))<0xFFFE)\n                  break;\n                  }\n                  }\n\n                  printf(\"%d %d\\n\",res,oddres);\n\n         * p    */\n        ress=0;\n        mama(n);\n        printf(\"%d %d\\n\",res,ress);\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF INT_MAX/3\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define debug(x) cout<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cout<<#x\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nvi num;\nvi num_odd;\nint N;\nint N_odd;\n\nvoid init(){\n    int t=1;\n    int i=1;\n    while(t<1000000){\n        num.EB(t);\n        i++;\n        t = i*(i+1)*(i+2)/6;\n    }\n    N = num.size();\n\n    for(i=0;i<N;i++){\n        if(num[i]%2==1) num_odd.emplace_back(num[i]);\n    }\n    N_odd = num_odd.size();\n}\n\nvoid solve(int n){\n    vi dp(n+10,INF);\n    dp[0]=0;\n    for(int i=0;i<N;i++){\n        for(int j=num[i];j<=n;j++){\n            dp[j] = min(dp[j],dp[j-num[i]]+1);\n        }\n    }\n\n    cout << dp[n] << \" \";\n\n    dp = vector<int>(n+10,INF);\n    dp[0] = 0;\n    for(int i=0;i<N_odd;i++){\n        for(int j=num_odd[i];j<=n;j++){\n            dp[j] = min(dp[j],dp[j-num_odd[i]]+1);\n        }\n    }\n    cout << dp[n] << endl;\n}\n\nint main(){\n    init();\n    int n;\n\n\n    while(cin>>n){\n        if(n==0) break;\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  vector<int> smt(1,0);\n  vector<int> ksmt(1,0);\n  int a;\n  for(int i=1;i<10000;i++){\n    a=i*(i+1)*(i+2)/6;\n    smt.push_back(a);\n    if(a%2==1)ksmt.push_back(a);\n    if(a>1000000)break;\n    //cout << a << endl;\n  }\n  while(1){\n    //cout <<smt.size()<<\" \"<<ksmt.size()<<endl;\n    int dp[2][1000001]={};\n    //cout <<\"2\"<<endl;\n    int n;\n    cin >> n;\n    int m=0,k=1;\n    if(n==0)break;\n    //\n    for(int i=1;i<=n;i++){\n      dp[0][i]=i;\n    }\n    //all\n    for(int i=1;i<smt.size();i++){\n      if(smt[i]>n){\n\tcout << dp[m][n]<<\" \";\n\tbreak;\n      }\n      for(int j=1;j<=n;j++){\n\tif(smt[i]>j) dp[k][j]=dp[m][j];\n\telse{\n\t  dp[k][j]=min(dp[m][j],dp[k][j-smt[i]]+1);\n\t}\n\t//cout <<dp[k][j]<<\" \";\n      }\n      swap(m,k);\n    }\n    //reset\n    for(int i=1;i<=n;i++){\n      dp[0][i]=i;\n    }\n    m=0,k=1;\n    //kisuu\n    for(int i=1;i<ksmt.size();i++){\n      if(ksmt[i]>n){\n\tcout << dp[m][n]<<endl;\n\tbreak;\n      }\n      for(int j=1;j<=n;j++){\n\tif(ksmt[i]>j) dp[k][j]=dp[m][j];\n\telse{\n\t  dp[k][j]=min(dp[m][j],dp[k][j-ksmt[i]]+1);\n\t}\n      }\n      swap(m,k);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nvi all, odd, v;\nint allt[1000005], oddt[1000005];\n\nint main()\n{\n\tv.push_back(0);\n\tFOR(i, 1, 1000) v.push_back(v[i - 1] + i);\n\tall.push_back(0);\n\tFOR(i,1, v.size())\n\t{\n\t\tall.push_back(all[i - 1] + v[i]);\n\t\tif (i & 1) odd.push_back(all[i - 1] + v[i]);\n\t\tif (all[i] > 1000000) break;\n\t}\n\tint n;\n\tfill(ALL(allt), INF); fill(ALL(oddt), INF);\n\tallt[0] = oddt[0] = 0;\n\tREP(i, 1000001)REP(j, all.size())\n\t{\n\t\tint t = i + all[j];\n\t\tif (t >= 1000001) break;\n\t\tallt[t] = min(allt[i] + 1, allt[t]);\n\t}\n\n\tREP(i, 1000001)REP(j, odd.size())\n\t{\n\t\tint t = i + odd[j];\n\t\tif (t >= 1000001) break;\n\t\toddt[t] = min(oddt[i] + 1, oddt[t]);\n\t}\n\twhile (cin >> n, n)\n\t{\n\t\tcout << allt[n] << \" \" << oddt[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n \nusing namespace std;\n \nconst int N=1000000;\nconst int INF=1<<30;\n \nint main(){\n  static int dp[N];\n  static int dpo[N];\n  fill(begin(dp),end(dp),INF);\n  fill(begin(dpo),end(dpo),INF);\n  dp[0]=dpo[0]=0;\n  for(int i=0;;i++){\n    int q=i*(i+1)*(i+2)/6;\n    if(q>N)break;\n    for(int j=q;j<N;j++){\n      dp[j]=min(dp[j],dp[j-q]+1);\n      if(q%2){\n    dpo[j]=min(dpo[j],dpo[j-q]+1);\n      }\n    }\n  }\n  for(int n;cin>>n,n;){\n    cout<<dp[n]<<' '<<dpo[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint main(){\n\tvector<int> dp(1000001,INF);\n\tvector<int> odp(1000001,INF);\n\tdp[0]=0;\n\todp[0]=0;\n\t\n\tint num=0;\n\tfor(int i=1;num<1000001;i++){\n\t\tnum=i*(i+1)*(i+2)/6;\n\t\tfor(int j=num;j<1000001;j++){\n\t\t\tdp[j]=min(dp[j],dp[j-num]+1);\n\t\t\tif(num%2==1)\n\t\t\todp[j]=min(odp[j],odp[j-num]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tprintf(\"%d %d\\n\",dp[n],odp[n]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include<iostream>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include <sstream>\n\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<limits.h>\nconst int INF = 0x7fffffff;\n\nusing namespace std;\n\nint dp[1000001],dpodd[1000001];\n\nint main(){\n\n  long ii,jj,kk;\n  vector<int> ret;\n\n  //ポロック予想\n  int n;\n  n = -1;\n\n\n\n  for(ii=0;ii<1000001;ii++){\n    dp[ii] = INF;\n    dpodd[ii] = INF;\n  }\n      \n  dp[0] = 0;\n  dpodd[0] = 0;\n\n  int y;\n\n  for(ii=1;;ii++){\n    y = ii*(ii+1)*(ii+2)/6;\n\n    if(y>=1e6){\n    //if(y>=21){\n      break;\n    }\n\n    for(jj=y;jj<1000001;jj++){\n      //for(jj=y;jj<=40;jj++){\n    \n      dp[jj] = min(dp[jj],dp[jj-y] + 1);\n    \n      if(y%2 == 1){\n        dpodd[jj] = min(dpodd[jj],dpodd[jj-y] + 1);\n      }\n    \n    }\n    //for(jj=1;jj<=40;jj++){\n    //  cout << dp[jj] << \"\\t\";\n    //}\n    //cout << endl;\n  }\n\n    \n  \n  while(n != 0){\n    cin >> n;\n    if(n!=0){\n      cout << dp[n] << \" \" << dpodd[n] << endl;\n    }\n\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint main() {\n\n  vector<int> v1;\n  vector<int> v2;\n  int tn = 1;\n  while(1){\n      int tmp = tn*(tn+1)*(tn+2)/6;\n      if(tmp < 1000000){\n        v1.push_back(tmp);\n        if(tmp % 2 != 0) v2.push_back(tmp);\n      }else{\n        break;\n      }\n      tn++;\n  }\n\n  int INF = 1000000000;\n  int dp1[1000005], dp2[1000005];\n\n  REP(i,0,1000005) dp1[i] = i, dp2[i] = i;\n\n  REP(i,1,180){\n    REP(j,0,1000005){\n      if(j-v1[i] >= 0) dp1[j] = min(dp1[j], dp1[j-v1[i]] + 1);\n    }\n  }\n  REP(i,1,45){\n    REP(j,0,1000005){\n      if(j-v2[i] >= 0) dp2[j] = min(dp2[j], dp2[j-v2[i]] + 1);\n    }\n  }\n\n  int N;\n  while(1){\n    cin>>N;\n    if(N==0) break;\n\n    cout<<dp1[N]<<\" \"<<dp2[N]<<endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define INF 1 << 9\nusing namespace std;\n\nint pollock[200];\nint pollock2[200] = {INF};\n\nvoid calcPollock() {\n  for (int i = 0; i < 200; i++) {\n    pollock[i] = i * (i + 1) * (i + 2) / 6;\n  }\n  pollock2[0] = 0;\n  int j = 1;\n  for (int i = 0; i < 200; i++) {\n    if (pollock[i] % 2)\n      pollock2[j++] = pollock[i];\n  }\n}\n\nint countPollock2(int n) {\n  int temp, maxp;\n  for (int i = 0; i < 200; i++)\n    if (pollock2[i] > n) {\n      maxp = i - 1;\n      break;\n    }\n  \n  int count[maxp + 1] = {0};\n  for (int i = maxp; i > 0; i--) {\n    temp = n;\n    int j = i;\n    while (temp > 0) {\n      while (temp < pollock2[j]) {\n\tj--;\n      }\n      count[i]++;\n      temp -= pollock2[j];\n    }\n  }\n  sort(count, count + maxp + 1);\n  \n  for (int i = 0; i < 200; i++)\n    if (count[i] > 0) return count[i];\n}\n\n\nint countPollock(int n) {\n  int temp, maxp;\n  for (int i = 0; i < 200; i++)\n    if (pollock[i] > n) {\n      maxp = i - 1;\n      break;\n    }\n  \n  int count[maxp + 1] = {0};\n  for (int i = maxp; pollock[i] * 5 > pollock[maxp]; i--) {\n    temp = n;\n    int j = i;\n    while (temp > 0) {\n      while (temp < pollock[j]) {\n\tj--;\n      }\n      count[i]++;\n      temp -= pollock[j];\n    }\n  }\n  sort(count, count + maxp + 1);\n  for (int i = 0; i < 200; i++)\n    if (count[i] > 0) return count[i];\n}\n\nint main() {\n  calcPollock();\n\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) return 0;\n\n    int ans = countPollock(n);\n    int ans2 = countPollock2(n);\n\n    cout << ans << ' ' << ans2 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector < vector<bool> >dp(201, vector < bool>(1000001, 0));\n\tdp[0][0] = 1;\n\tREP(i, 5) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 5)REP(j, 1000001)dp[i][j] = 0;\n\tdp[0][0] = 1;\n\tREP(i, 200) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k % 2 == 0)continue;\n\t\t\tif (k > 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tREP(i, 5) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \" \";\n\t\tREP(i, 200) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint list[181],dp[999999],dq[999999];\nint main(){\n    for(int i=0;i<999999;i++){\n        dp[i]=1000000;\n        dq[i]=1000000;\n    }\n    for(int i=0;i<181;i++){\n        list[i]=(i+1)*(i+2)*(i+3)/6;\n        dp[list[i]-1]=1;\n        if(list[i]%2==1) dq[list[i]-1]=1;\n    }\n    for(int i=0;i<999999;i++){\n        for(int j=0;list[j]<=i;j++){\n            dp[i]=min(dp[i],dp[i-list[j]]+1);\n            if(list[j]%2==1) dq[i]=min(dq[i],dq[i-list[j]]+1);\n        }\n    }\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n==0) return 0;\n        printf(\"%d %d\\n\",dp[n-1],dq[n-1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P,P> P2;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nint c[1000000];\nint co[1000000];\nint po[300];\n\nint main(){\n\tint n;\n\tfill(c, c + 1000000, INF);\n\tfill(co, co + 1000000, INF);\n\tc[0] = co[0] = 0;\n\tfor(int i = 0; i < 300; i++){\n\t\tpo[i] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tfor(int i = 0; i < 1000000; i++){\n\t\tfor(int j = 1; j < 300; j++){\n\t\t\tif(i + po[j] >= 1000000) break;\n\t\t\tif(c[i + po[j]] > c[i] + 1){\n\t\t\t\tc[i+po[j]] = c[i] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < 1000000; i++){\n\t\tfor(int j = 1; j < 300; j++){\n\t\t\tif(!(po[j] & 1)) continue;\n\t\t\tif(i + po[j] >= 1000000) break;\n\t\t\tif(co[i+po[j]] > co[i] + 1){\n\t\t\t\tco[i+po[j]] = co[i] + 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> n && n){\n\t\tcout << c[n] << \" \" << co[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint polloc[200];\n\nint main()\n{\n\tfor(int i=0;i<200;i++){\n\t\tpolloc[i]=i*(i+1)*(i+2)/6;\n\t}\n\tint n;\n\tvector<int> ans1(1000001,-1);\n\tvector<int> ans2(1000001,-1);\n\t\n\tfor(int i=0;i<200;i++){\n\t\tif(polloc[i]>1000000) break;\n\t\tans1[polloc[i]]=1;\n\t\tif(polloc[i]%2==1)\n\t\t\tans2[polloc[i]]=1;\n\t}\n\n\tfor(int i=1;i<=1000000;i++){\n\t\tif(ans1[i]<0){\n\t\t\tans1[i]=100000000;\n\t\t\tfor(int k=0;k<200;k++){\n\t\t\t\tif(i-polloc[k]<0) break;\n\t\t\t\tans1[i]=min(ans1[i],ans1[i-polloc[k]]+1);\n\t\t\t}\n\t\t}\n\n\t\tif(ans2[i]<0){\n\t\t\tans2[i]=1000000000;\n\t\t\tfor(int k=0;k<200;k++){\n\t\t\t\tif(polloc[k]%2==0) continue;\n\t\t\t\tif(i-polloc[k]<0) break;\n\t\t\t\tans2[i]=min(ans2[i],ans2[i-polloc[k]]+1);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\twhile(cin>>n){\n\t\tif(n==0) return 0;\n\t\tcout<<ans1[n]<<\" \"<<ans2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long int mod = 1000000007;\n\n//i*2^X>=K\n//2^X>=\nint main() {\n\tvector<int>Prk(181),dp(1000001,mod), dpi(1000001, mod);\n\tfor (size_t i = 1; i <= 180; i++)\n\t{\n\t\tPrk.at(i) = i * (i + 1) * (i + 2) / 6;\n\t}\n\tdp.at(0) = 0;\n\tdpi.at(0) = 0;\n\tfor (size_t i = 1; i <= 180; i++)\n\t{\n\t\tfor (size_t j = Prk.at(i); j <= 1000000; j++)\n\t\t{\n\t\t\tdp.at(j) = min(dp.at(j - Prk.at(i)) + 1, dp.at(j));\n\t\t\tif (Prk.at(i) % 2)dpi.at(j) = min(dpi.at(j - Prk.at(i))+1, dpi.at(j));\n\t\t}\n\t}\n\tint task;\n\twhile (true)\n\t{\n\t\tcin >> task;\n\t\tif (task == 0)return 0;\n\t\tcout << dp.at(task) << \" \" << dpi.at(task) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 1000000\nmain(){\n    int T1[MAX], T2[MAX];\n    for ( int i = 0; i < MAX; i++ ) T1[i] = T2[i] = i;\n    int  n = 1;\n    while(1){\n\tint i = n*(n+1)*(n+2)/6;\n\tif ( i >= MAX ) break;\n\n\tfor ( int j = i; j < MAX; j++ ) T1[j] = min(T1[j], T1[j-i]+1);\n\tif ( i % 2 ){\n\t    for ( int j = i; j < MAX; j++ ) T2[j] = min(T2[j], T2[j-i]+1);\n\t}\n\tn++;\n    }\n\n    while(1){\n\tcin >> n;\n\tif ( n == 0 ) break;\n\tcout << T1[n] << \" \" << T2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i < (n);i++)\n#define ALL(obj) (obj).begin(),(obj).end()\nusing namespace std;\n\nconst long long INF = 1LL << 60;\nconst int MOD = (int)1e9 + 7;\ntypedef long long ll;\n//約数列挙\nvector<long long> divisor(long long n) {\n    vector<long long> ret;\n    for (long long i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            ret.push_back(i);\n            if (i * i != n) ret.push_back(n / i);\n        }\n    }\n    //sort(ret.begin(), ret.end()); // 昇順に並べる\n    return ret;\n}\nvector<int> dx={1,0,-1,0};vector<int> dy={0,-1,0,1};\n\nsigned main () {\n    vector<int> list;\n    int tmp=1;int cnt=1;\n    while(tmp<=1000000){\n        list.push_back(tmp);\n        cnt++;\n        tmp=cnt*(cnt+1)*(cnt+2)/6;\n    }\n    int len = list.size();\n    vector<int> dp(1000001,0);vector<int> oddsdp(1000001,0);\n    REP(i,1000001){\n        dp[i]=i;oddsdp[i]=i;\n    }\n    REP(i,len){\n        REP(j,1000001){\n            if(j - list[i]>=0)dp[j] = min(dp[j-list[i]]+1,dp[j]);\n        }\n        //printf(\"%d\\n\",list[i]);\n    }\n    REP(i,len){\n        if(list[i]%2 == 0)continue;\n        REP(j,1000001){\n            if(j-list[i]>=0)oddsdp[j]=min(oddsdp[j-list[i]]+1,oddsdp[j]);\n        }\n        //printf(\"%d\\n\",oddsdp[40]);\n    }\n    int n;scanf(\"%d\",&n);\n    while(n){\n        int ans1,ans2;\n        ans1 =dp[n];ans2=oddsdp[n];\n        printf(\"%d %d\\n\",ans1,ans2);\n        scanf(\"%d\",&n);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tvector<int> tri(200);\n\n\tfor (int i = 0; i < 200; i++) {\n\t\ttri[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tvector<int> ans1(1000000);\n\tvector<int> ans2(1000000);\n\n\tans1[0] = 0;\n\tans2[0] = 0;\n\n\tfor (int i = 1; i < 1000000; i++) {\n\t\tans1[i] = i;\n\t\tans2[i] = i;\n\n\t\tfor (int j = 0; i - tri[j] >= 0; j++) {\n\t\t\tans1[i] = min(ans1[i], ans1[i - tri[j]] + 1);\n\n\t\t\tif (tri[j] % 2 == 1) {\n\t\t\t\tans2[i] = min(ans2[i], ans2[i - tri[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\n\t\tcout << ans1[n] << \" \" << ans2[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\n#define INF (int)1e09\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::setprecision;\nusing std::fixed;\nusing std::pair;\nusing std::make_pair;\nusing std::min;\nusing std::max;\nusing std::string;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::set; // insert erase find count\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n\ntypedef vector<int> VI;\ntypedef vector<vector<int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, pair<int, int> > PIII;\n\nint main(void) {\n    int bas = 0;\n    int tri = 0;\n    int fou = 0;\n\n    VI total;\n    VI odd;\n\n    VI ans_total(1e06, INF);\n    VI ans_odd(1e06, INF);\n\n    while (1) {\n        bas++;\n        tri += bas;\n        fou += tri;\n        if (fou >= 1e06) {\n            break;\n        }\n        total.push_back(fou);\n        ans_total[fou] = 1;\n        if (fou % 2 == 1) {\n            odd.push_back(fou);\n            ans_odd[fou] = 1;\n        }\n\n    }\n    int size_total = (int)total.size();\n    int size_odd = (int)odd.size();\n    int posi;\n\n    for (int i = 0; i < size_total; i++) {\n        posi = total[i];\n        for (int j = posi + 1; j < 1e06; j++) {\n            ans_total[j] = min(ans_total[j], ans_total[posi] + ans_total[j - posi]);\n        }\n    }\n    for (int i = 0; i < size_odd; i++) {\n        posi = odd[i];\n        for (int j = posi + 1; j < 1e06; j++) {\n            ans_odd[j] = min(ans_odd[j], ans_odd[posi] + ans_odd[j - posi]);\n        }\n    }\n\n    int input;\n    while (1) {\n        cin >> input;\n        if (input == 0) {\n            break;\n        }\n        cout << ans_total[input] << \" \" << ans_odd[input] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1167      \n#include <bits/stdc++.h>\n#define endl \"\\n\"\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define SZ(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ipair;\ntypedef pair<ll,ll> lpair;\ntemplate <class T>ostream &operator<<(ostream &o,const vector<T>&v) //vectorの中身を見る\n{o<<\"{\";for(int i=0;i<(int)v.size();i++)o<<(i>0?\", \":\"\")<<v[i];o<<\"}\";return o;}\n\nvector<int> simen;\nvector<int> simen_odd;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(12);\n\n    int max_n=pow(10,6);\n    int i=1;\n    int cur=i*(i+1)*(i+2)/6;\n    while(cur<=max_n){\n        simen.emplace_back(cur);\n        if(cur%2==1) simen_odd.emplace_back(cur);\n        i++;\n        cur=i*(i+1)*(i+2)/6;\n    }\n    int n;\n    int l=simen.size();\n    int l_odd=simen_odd.size();\n    int max_=pow(10,7);\n    vector<int> dp1(max_n+10,max_);\n    dp1[0]=0;\n    for(int i=0;i<l;i++){ //もらうDP\n        for(int j=1;j<=max_n;j++){\n            if(0<=j-simen[i]) dp1[j]=min(dp1[j-simen[i]]+1,dp1[j]);\n        }\n    }\n    vector<int> dp2(max_n+10,max_);\n    dp2[0]=0;\n    for(int i=0;i<l_odd;i++){\n        for(int j=1;j<=max_n;j++){\n            if(0<=j-simen_odd[i]) dp2[j]=min(dp2[j-simen_odd[i]]+1,dp2[j]);\n        }\n    }\n    while(cin>>n){\n        if(n==0) break;\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\n#define MAX 1000000\n\nvoid makelist(int *list, int x) {\n  for (int i = x; i < MAX; i++) {\n    list[i] = min(list[i], list[i-x]+1);\n  }\n}\n\nint main() {\n  int list1[MAX], list2[MAX], x, n;\n  for (int i = 1; i < MAX; i++) {\n    list1[i] = list2[i] = INF;\n  }\n  for (int i = 1; ; i++) {\n    x = i*(i+1)*(i+2)/6;\n    if (x >= MAX) break;\n    makelist(list1, x);\n    if (x & 1) makelist(list2, x);\n  }\n  while (cin >> n, n) {\n    cout << list1[n] << \" \" << list2[n] << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  vt<int> vec;\n  for(int i = 1, num = 1; num <= 1e6; ++i, num = i * (i + 1) * (i + 2) / 6) {\n    vec.push_back(num);\n  }\n\n  vt<int> dp1(1e6 + 1, INF), dp2(1e6 + 1, INF);\n  dp1[0] = dp2[0] = 0;\n  rep(i, 1, 1e6 + 1) {\n    rep(j, 0, vec.size()) {\n      if(i >= vec[j]) {\n        dp1[i] = min(dp1[i], dp1[i - vec[j]] + 1);\n        if(vec[j] % 2 == 1) dp2[i] = min(dp2[i], dp2[i - vec[j]] + 1);\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n != 0) cout << dp1[n] << \" \" << dp2[n] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define NUM 1000000\n\nint n,tetra_sum[NUM],odd_sum[NUM];\n\nvoid tetrahedral(int sum[],int tetra)\n{\n  for(int i=tetra;i<NUM;i++)\n    sum[i]=min(sum[i],sum[i-tetra]+1);\n}\n\nint main()\n{\n  tetra_sum[0]=0; odd_sum[0]=0;\n  for(int i=1;i<NUM;i++){\n    tetra_sum[i]=NUM; odd_sum[i]=NUM;\n  }\n  for(int i=1;i<=180;i++){\n    int tetra=i*(i+1)*(i+2)/6;\n    tetrahedral(tetra_sum,tetra);\n    if(tetra%2) tetrahedral(odd_sum,tetra);\n  }\n  for(;;){\n    cin>>n;\n    if(!n) break;\n    cout<<tetra_sum[n]<<\" \"<<odd_sum[n]<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint memo1[1000001], memo2[1000001], memoodd[1000001], memo3[1000001];\n\nint pollock_1(int n)\n{\n    int min = 100, ex;\n    if (n == memo1[n])\n        return memo2[n] = 1;\n    if (memo2[n] > 0)\n        return memo2[n];\n    for (int i = 1; i < 1000001; i++)\n    {\n        if (i <= n / 2)\n        {\n            if (pollock_1(n - i) == 1)\n            {\n                ex = pollock_1(n - i) + pollock_1(i);\n            }\n            if (i == 1)\n            {\n                ex = pollock_1(n - 1) + 1;\n            }\n            if (ex < min)\n                min = ex;\n        }\n    }\n    return memo2[n] = min;\n}\n\nint pollock_2(int n)\n{\n    int min = 10000000, ex;\n    if (n == memoodd[n])\n        return memo2[n] = 1;\n    if (memo3[n] > 0)\n        return memo3[n];\n    for (int i = 1; i < 1000001; i++)\n    {\n        if (i <= n / 2)\n        {\n            if (pollock_2(n - i) == 1)\n            {\n                ex = pollock_2(n - i) + pollock_2(i);\n            }\n            if (i == 1)\n            {\n                ex = pollock_2(n - 1) + 1;\n            }\n            if (ex < min)\n                min = ex;\n        }\n    }\n    return memo3[n] = min;\n}\n\nint main()\n{\n    for (int k = 0; k < 1000001; k++)\n    {\n        memo1[k] = 0;\n        memo2[k] = 0;\n        memoodd[k] = 0;\n        memo3[k] = 0;\n    }\n    for (int k = 1; k < 200; k++)\n    {\n        n = (k * (k + 1) * (k + 2)) / 6;\n        memo1[n] = n;\n        if (n % 2 != 0)\n            memoodd[n] = n;\n    }\n    while (1)\n    {\n        scanf(\"%d\", &n);\n        if (n == 0)\n            break;\n        printf(\"%d %d\\n\", pollock_1(n), pollock_2(n));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##_len=(int)(n);i<i##_len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nint tetr[131];\nint dp1[1234567];\nint dp2[1234567];\nsigned main() {\n    REP(i,130) tetr[i]=(i+1)*(i+2)*(i+3)/6;\n    fill(ALL(dp1),INF);\n    fill(ALL(dp2),INF);\n\n    dp1[0]=0;\n    dp2[0]=0;\n    REP(i,130) {\n        REP(j,1000010) {\n            if(dp1[j]!=INF) {\n                if(j+tetr[i]<=1000010) chmin(dp1[j+tetr[i]],dp1[j]+1);\n            }\n            if(tetr[i]%2==0) {\n                continue;\n            }\n            if(dp2[j]!=INF) {\n                if(j+tetr[i]<=1000010) chmin(dp2[j+tetr[i]],dp2[j]+1);\n            }\n        }\n    }\n    while(1) {\n        int n;\n        cin>>n;\n        if(n==0) break;\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint D[182] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<182 ; i++ ){\n\t\tD[i] = i * (i+1) * (i+2) / 6 ;\n\t}\n}\n\nint cal_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\t//if( dp_map[0][x] != 0 ) return dp_map[0][x] ;\n\t\t//else \n\t\treturn x/D[c] + cal_2( x%D[c] , c-1 ) ;\n\t}\n}\n\nint cal( int m , int q ){\n\tint ans = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans = min( ans , cal_2( m , j ) ) ;\n\t}\n\treturn ans ;\n}\n\nint cal_odd_2( int x , int c ){\n\tif( x==0 ) return 0 ;\n\telse{\n\t\tif( D[c]%2 == 0 ) return cal_odd_2( x , c-1 ) ;\n\t\telse{\n\t\t\t//if( dp_map[1][x] != 0 ) return dp_map[1][x] ;\n\t\t\t//else \n\t\t\treturn x/D[c] + cal_odd_2( x%D[c] , c-1 ) ;\n\t\t}\n\t}\n}\n\nint cal_odd( int m , int q ){\n\tint ans_2 = m ;\n\tfor( int j=q ; j>1 ; j-- ){\n\t\tans_2 = min( ans_2 , cal_odd_2( m , j ) ) ;\n\t}\n\treturn ans_2 ;\n}\n\nvoid dp(){\n\tint p = 1 ;\n\tfor( int i=1 ; i<=1000000 ; i++ ){\n\t\tif( i < 182 && i >= D[p] ) p++ ;\n\t\tdp_map[0][i] = cal(i,p) ;\n\t\tdp_map[1][i] = cal_odd(i,p) ;\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint dp[1000005];\nint dp2[1000005];\nint pl[180];\n\nint main() {\n\t//init\n\tfor (int i = 1; i<=180; i++)pl[i-1] = (i*(i + 1)*(i + 2)) / 6;\n\tmemset(dp, 0x7f, sizeof(dp));\n\tmemset(dp2, 0x7f, sizeof(dp2));\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tfor (int j = 0; j < 180; j++) {\n\t\t\tif(i+pl[j] <= 1000000)dp[i + pl[j]] = min(dp[i] + 1, dp[i + pl[j]]);\n\t\t\tif (i + pl[j] <= 1000000 && pl[j]&1)dp2[i + pl[j]] = min(dp2[i] + 1, dp2[i + pl[j]]);\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tprintf(\"%d %d\\n\", dp[n], dp2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int i,j,k,t=0,a[200]={},b[200]={},c[1000005]={1000000},d[1000005]={1000000};\n  for(i=1;i<201;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(m[i-1]%2==1)b[t++]=m[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<200;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<b[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint main() {\n    const int n = 1000000;\n    vector<int> pyramid_nums;\n    int k = 1;\n    while(true) {\n        int num = k*(k+1)*(k+2) / 6;\n        if(num >= n) break;\n        pyramid_nums.push_back(num);\n        k++;\n    }\n    vector<int> dp;\n    dp.push_back(0);\n    for(int k = 1; k < n; ++k) {\n        int elem = k;\n        for(int p_num : pyramid_nums) {\n            if(p_num > k) break;\n            if(elem > dp[k - p_num] + 1) elem = dp[k - p_num] + 1;\n        }\n        dp.push_back(elem);\n    }\n    vector<int> dp_odd;\n    dp_odd.push_back(0);\n    for(int k = 1; k < n; ++k) {\n        int elem = k;\n        for(int p_num : pyramid_nums) {\n            if(p_num % 2 == 0) continue;\n            if(p_num > k) break;\n            if(elem > dp_odd[k - p_num] + 1) elem = dp_odd[k - p_num] + 1;\n        }\n        dp_odd.push_back(elem);\n    }\n    while(true) {\n        int q; cin >> q;\n        if(q == 0) break;\n        cout << dp[q] << ' ' << dp_odd[q] << endl;\n    }\n    return 0;\n}\n\n// [Problem] Pollock's conjecture\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nconst int m = 1000001;\n\nint dp[2][1000001];\n\nint main() {\n\n    rep(i, 2)rep(j, m)dp[i][j] = j;\n\n    for(int i=1,a;a=i*(i+1)*(i+2)/6,a<m;i++)\n        rep(k, m-a) {\n            if(dp[0][k]< dp[0][k+a])dp[0][k+a] = dp[0][k] + 1;\n            if(a%2 && dp[1][k] < dp[1][k+a])dp[1][k+a] = dp[1][k] + 1;\n        }\n\n    for(int n;cin>>n,n;)cout<<dp[0][n]<<' '<<dp[1][n]<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;i<181;i++) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;i<181;i++) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <map>\n#include <climits>\nusing namespace std;\n#define mod (1000000007)\n#define ll long long int\n\nint main(void){\n  ll koho[200];\n  for (size_t i = 1; i < 201; i++) {\n    koho[i-1] = i*(i+1)*(i+2)/6;\n  }\n  vector<ll> koho_odd;\n  for(auto k: koho){\n    if(k%2 == 1){\n      koho_odd.push_back(k);\n    }\n  }\n\n  vector<ll> dp;\n  dp.assign(1000005,INT_MAX);\n  dp[0] = 0;\n  for (size_t i = 1; i < 1000005; i++) {\n    for(auto k: koho){\n      if(i<k){\n        break;\n      }else{\n        dp[i] = min(dp[i],dp[i-k]+1);\n      }\n    }\n  }\n\n  vector<ll> dpo;\n  dpo.assign(1000005,INT_MAX);\n  dpo[0] = 0;\n  for (size_t i = 1; i < 1000005; i++) {\n    for(auto k: koho_odd){\n      if(i<k){\n        break;\n      }else{\n        dpo[i] = min(dpo[i],dpo[i-k]+1);\n      }\n    }\n  }\n\n  int N;\n  while(true){\n    cin >> N;\n    if(N==0){\n      break;\n    }else{\n      cout << dp[N] << ' ' <<  dpo[N] << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nlong dp[1000000];\n\nint main(){\n    int N;\n    dp[0] = 0;\n    for(int i = 1;i < 1000000;i++){\n            dp[i] = 1000000;\n        }\n    for(int i= 0;i < 1000;i++){\n        long a = (i * (i + 1) * (i + 2)) / 6;\n        for(int j = a;j < 1000000;j++){\n            dp[j] = min(dp[j],dp[j - a] + 1);\n        }\n    }\n    for(int i = 0;;i++){\n        scanf(\"%d\",&N);\n        if(N == 0){\n            break;\n        }\n        printf(\"%ld\\n\",dp[N]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\n#define itn long long\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define rrep(i,n) for(int i=(int)(n);i>=0;--i)\n#define debug(x) cout << #x << \"=\" << (x) << endl;\nconst ll MOD=1e9+7;\n\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T> void fail(T v){cout << v << endl;exit(0);}\n//template end\n\nvoid solve(){\n  const int N=(int)1e6+1;\n  vector<int> sum;\n  sum.push_back(1);int s=1;\n  while(sum.back()<=N){\n    s+=sum.size()+1;\n    sum.push_back(s+sum.back());\n  }\n  vector<int> dp(N,1<<29);dp[0]=0;\n  rep(i,sum.size()){\n    for(int j=0;j+sum[i]<N;j++)\n      chmin(dp[j+sum[i]],dp[j]+1);\n  }\n  vector<int> odd(N,1<<29);odd[0]=0;\n  rep(i,sum.size()){\n    if(sum[i]%2==0)continue;\n    for(int j=0;j+sum[i]<N;j++)\n      chmin(odd[j+sum[i]],odd[j]+1);\n  }\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)return;\n    cout<<dp[n]<<\" \"<<odd[n]<<endl;\n  }\n}\n \nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n}\n     return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\nusing namespace std;\ntypedef long long ll;\n\nvector<int> v,v2;\nint d[1000005];\nint d2[1000005];\n\nint main()\n{\n    rep(i,200) {\n        int t = i * (i+1) * (i+2);\n        t /= 6;\n\n        if(t%2 == 0) {\n            v.push_back(t);\n        }\n        else {\n            v.push_back(t);\n            v2.push_back(t);\n        }\n    }\n\n    fill(d,d+1000005,INF);\n    fill(d2,d2+1000005,INF);\n\n    d[0] = 0;\n    d2[0] = 0;\n\n    rep(i,1000005) {\n        rep(j,v.size()) {\n            int next = i + v[j];\n            if(next < 1000005) {\n                d[next] = min(d[next],d[i]+1);\n            }\n        }\n\n        rep(j,v2.size()) {\n            int next = i + v2[j];\n            if(next < 1000005) {\n                d2[next] = min(d2[next],d2[i]+1);\n            }\n\n        }\n    }\n\n    int n;\n    while(cin >> n && n) {\n        cout << d[n] << \" \" << d2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n;\nint sum[222];\n\n//int dp[1111111][222];\nint dp[2][1111111];\n\n/*\nint solve(int s,int i,int f){\n  //if(!s) return 0;\n  if(i >= m) return s;\n  if(dp[s][i])return dp[s][i];\n\n  int ret = 1 << 28;\n  if(!((sum[i] + 1) % f)){\n    for(int j = 0;s - sum[i] * j >= 0 ; j++){\n      ret = min(ret,solve(s - sum[i] * j,i + 1,f) + j);\n    }\n  }\n  ret = min(ret,solve(s,i + 1,f));\n\n  return dp[s][i] = ret;\n}\n*/\nint solve(int s,int f){\n  if(!s) return 0;\n  if(dp[f-1][s]) return dp[f-1][s];\n\n  int ret = 1 << 28;\n  for(int i = 0; s >= sum[i]; i++){\n    if(!((sum[i] + 1) % f)){\n      ret = min(ret,solve(s - sum[i],f) + 1);\n    }\n  }\n  return dp[f-1][s] = ret;\n}\n\nint main(void){\n  sum[0] = 1;\n  for(int i = 1; sum[i-1] <= 1000000; i++){\n    sum[i] = sum[i-1] * (i + 3) / i;\n  }\n  for(int i = 1; i < 1000000; i++){\n    solve(i,1);\n    solve(i,2);\n  }\n  puts(\"ok\");\n  while(1){\n    scanf(\"%d\",&n); if(!n) break;\n    printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvvi dp(6,vi(100001,0));\n\tdp[0][0] = 1;\n\tREP(i, 5) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif ( k> 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp[i][l])dp[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvvi dp2(1001, vi(100001, 0));\n\tREP(i, 1000) {\n\t\tREP(j, INF) {\n\t\t\tint k = j*(j + 1)*(j + 2) / 6;\n\t\t\tif (k % 2 == 0)continue;\n\t\t\tif (k> 100001)break;\n\t\t\tREP(l, 100001 - k) {\n\t\t\t\tif (dp2[i][l])dp2[i + 1][l + k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tREP(i, 5) {\n\t\t\tif (dp[i + 1][n]) {\n\t\t\t\tcout << i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \" \";\n\t\tREP(i, 5) {\n\t\t\tif (dp2[i + 1][n]) {\n\t\t\t\tcout << i+1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[x];\n    int coin_ki[x];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[x+1];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\nvector<int> P;\nint memo[1001001];\nint mome[1001001];\n\nvoid hoge(){\n\n    for(int i=1; ; i++){\n        int p=i*(i+1)*(i+2)/6;\n        if(p>=1001001) break;\n        P.push_back(p);\n    }\n    for(int i=0; i<1001001; i++){\n        memo[i]=mome[i]=i;\n    }\n    for(int i=0; i<P.size(); i++){\n        memo[P[i]]=1;\n        if(P[i]%2) mome[P[i]]=1;\n    }\n    for(int i=0; i<1001001; i++){\n        for(int j=0; j<P.size(); j++){\n            if(i+P[j]<1001001){\n                memo[i+P[j]]=min(memo[i+P[j]], memo[i]+1);\n            }\n            if((P[j]%2)&&i+P[j]<1001001){\n                mome[i+P[j]]=min(mome[i+P[j]], mome[i]+1);\n            }\n        }\n    }\n}\n\nint main(){\n\n    hoge();\n    while(1){\n        int N;\n        cin>> N;\n        if(!N) break;\n\n        cout<< memo[N]<< \" \"<< mome[N]<< endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint dp[1000001]={};\nint dp2[1000001]={};\nint main(){\n\tfor(int i = 0 ; i < 1000001 ; i++) dp[i] = 1e9;\n\tfor(int i = 0 ; i < 1000001 ; i++) dp2[i] = 1e9;\n\tdp[0] = dp2[0] = 0;\n\t\n\tfor(int i = 1 ; i*(i+1)*(i+2) / 6 <= 1000000 ; i++){\n\t\tint s = i*(i+1)*(i+2)/6;\n\t\tfor(int j = 0 ; j+s <= 1000000 ; j++){\n\t\t\tdp2[j+s] = min(dp2[j+s],dp2[j]+1);\n\t\t}\n\t}\n\tfor(int i = 1 ; i*(i+1)*(i+2) / 6 <= 1000000 ; i++){\n\t\tint s = i*(i+1)*(i+2)/6;\n\t\tif( s%2 == 0 ) continue;\n\t\tfor(int j = 0 ; j+s <= 1000000 ; j++){\n\t\t\tdp[j+s] = min(dp[j+s],dp[j]+1);\n\t\t}\n\t}\n\tint a,b;\n\twhile(cin >> a && a){\n\t\tcout << dp2[a] << \" \" << dp[a] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<map>\n#include<set>\n#include<queue>\n#include<functional>\n#include<math.h>\nusing namespace std;\n#define N (1000000000+7)\n#define INF 1e16\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n \nll dp[1000010];\nll dp_odd[1000010];\n\n\nint main(void){\n    for(ll i=0;i<1000010;i++){\n        dp[i]=(ll)INF;\n        dp_odd[i]=(ll)INF;\n    }\n    vector<ll>a,b,c;\n    for(ll i=1;;i++){\n        ll tmp = i*(i+1)/2;\n        if(i>1000000)break;\n        a.push_back(tmp);\n    }\n    ll sum = 0;\n    for(ll i=0;;i++){\n        sum+=a[i];\n        if(sum>1000000)break;\n        b.push_back(sum);\n        if(sum%2==1)c.push_back(sum);\n    }\n    ll asize = a.size();\n    ll bsize = b.size();\n    ll csize = c.size();\n    dp[0]=0;\n    dp_odd[0]=0;\n    for(ll i=1;i<1000000;i++){\n        for(ll j=0;j<bsize;j++){\n            if(i>=b[j])dp[i]=min(dp[i],dp[i-b[j]]+1);\n            else break;\n        }\n    }\n    for(ll i=1;i<1000000;i++){\n        for(ll j=0;j<csize;j++){\n            if(i>=c[j])dp_odd[i]=min(dp_odd[i],dp_odd[i-c[j]]+1);\n            else break;\n        }\n    }\n    while(true){\n        int n;\n        cin>>n;\n        if(n==0)break;\n        cout<<dp[n]<<\" \"<<dp_odd[n]<<endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\n#define INF 1020304050\n#define n_max 1000000\n\nint main()\n{\n  int n;cin>>n;\n  int i,j;\n  vector<int> dp(n_max+1,INF);\n  vector<int> dp2(n_max+1,INF);\n  vector<int> ss(300,0);\n  dp[0]=0;\n  dp2[0]=0;\n  rep(i,300)\n  {\n    ss[i]=(i+1)*(i+2)*(i+3)/6;\n  }\n  for(i=1;i<=n_max;i++)\n  {\n    rep(j,300)\n    {\n      if(i-ss[j]<0)break;\n      dp[i]=min(dp[i],dp[i-ss[j]]+1);\n      if(ss[j]%2==1)\n      {\n        dp2[i]=min(dp2[i],dp2[i-ss[j]]+1);\n      }\n    }\n  }\n  while(n!=0)\n  {\n    cout<<dp[n]<<' '<<dp2[n]<<endl;\n    cin>>n;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n\nusing namespace std;\nusing ll = long long;\n\n#define INF 1e9\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int n;\n  while(cin >> n && n){\n    vector<int> dp_a(n+1, INF), dp_b(n+1, INF);\n    dp_a[0] = 0, dp_b[0] = 0;\n    for(int i = 0; i <= 200; i++){\n      int tetra = i * (i+1) * (i+2) / 6;\n      for(int j = tetra; j <= n; j++){\n        dp_a[j] = min(dp_a[j], dp_a[j-tetra] + 1);\n        if(tetra%2 != 0) dp_b[j] = min(dp_b[j], dp_b[j-tetra] + 1);\n      }\n    }\n    cout << dp_a[n] << ' ' << dp_b[n] << endl;\n  }\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <iterator>\n#include <algorithm>\n#include <limits.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nvector<int> GetIntVector()\n{\n\tstring str;\n\tgetline(cin,str);\n\tistringstream line( str );\n\n\tistream_iterator<int> iit(line);\n\tistream_iterator<int> iit_eof;\n\n\tvector<int> ret;\n\n\tfor(;iit != iit_eof; iit++){\n\t\tret.push_back(*iit);\n\t}\n\n\treturn ret;\n}\n\nint tetrahedralNumber(int count)\n{\n\treturn count * (count + 1) * (count + 2) / 6;\n}\n\nbool isEven(int num){ return num % 2 == 0; }\n\nint GetMinCombination(vector<int>& numbers,int input,int maxConbination)\n{\n\n\tint minConbi = INT_MAX;\n\n\tvector<int>::reverse_iterator rit = numbers.rbegin();   \n\tfor(; rit != numbers.rend(); rit++)  \n\t{\n\t\tif( (*rit) > input) continue; //ツ妥・ツつォツつ「ツ甘板づ債暗クツつッツづ按つ「ツづ個づ姪淞つキ\n\t\tif( (*rit) < input / maxConbination) break; //ツ表ツつオツつォツづェツづ按つ「\n\t\tif(input - (*rit) == 0) return 1; //ツ暗ェツづつづ個青板づ表ツつケツつス\n\n\t\tint conbi = GetMinCombination(numbers,input - (*rit),(minConbi == INT_MAX) ? maxConbination - 1 : minConbi - 1);\n\t\tif(conbi != INT_MAX)\n\t\t\tminConbi = conbi + 1; //conbiツ青板更ツ新\n\t}\n\n\treturn minConbi;\n}\n\nvoid solve(int inputs)\n{\n\tvector<int> tNumbers;\n\ttNumbers.push_back(0);\n\tfor(int i = 1; inputs > tNumbers[tNumbers.size() - 1]; i++){\n\t\ttNumbers.push_back(tetrahedralNumber(i));\n\t}\n\ttNumbers.erase(tNumbers.begin());\n\n\tint conbi = GetMinCombination(tNumbers,inputs,5);\n\n\tvector<int>::iterator rem = remove_if(tNumbers.begin(),tNumbers.end(),isEven);\n\ttNumbers.erase( rem, tNumbers.end());\n\n\tint oddConbi = GetMinCombination(tNumbers,inputs,inputs);\n\n\tcout << conbi << ' ' << oddConbi << endl;\n}\n\nvoid C()\n{\n\tint input = GetIntVector()[0];\n\twhile(input){\n\t\tsolve(input);\n\t\tinput = GetIntVector()[0];\n\t}\n}\nint main()\n{\n\tC();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\nconst int inf = 1000000009;\n\nint main() {\n    vector<int> memo(1000000, inf);     memo[0] = 0;\n    vector<int> odd_memo(1000000, inf); odd_memo[0] = 0;\n\n    for (int i=0; i<1000000; i++) {\n        memo[i]     = i;\n        odd_memo[i] = i;\n    }\n\n    for (int l=2; l<200; l++) {\n        const int n = (l*(l+1)*(l+2))/6;\n        for (int i=0; i<1000000; i++) {\n            if (i-n >= 0) {\n                memo[i] = min(memo[i-n]+1, memo[i]);\n                if (n%2==1) {\n                    odd_memo[i] = min(odd_memo[i-n]+1, odd_memo[i]);\n                }\n            }\n        }\n    }\n\n    int n; \n    while (cin >> n, n!=0) {\n        cout << memo[n] << \" \" << odd_memo[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\n\tint n,table[183];\n\tint* dp = new int[1000000];\n\tint* odd_dp = new int[1000000];\n\n\tfor(int i=0; i < 183; i++)table[i] = i*(i+1)*(i+2)/6;\n\n\tfor(int i=0; i < 1000000; i++){\n\t\todd_dp[i] = 20000000;\n\t\tdp[i] = 20000000;\n\t}\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\n\todd_dp[0] = 0;\n\todd_dp[1] = 1;\n\n\tfor(int i = 2; i < 1000000; i++){\n\t\tfor(int k = 1; table[k] <= i; k++){\n\t\t\tdp[i] = (dp[i] <= dp[i-table[k]]+1)?dp[i]:dp[i-table[k]]+1;\n\t\t\tif(table[k]%2 == 1){\n\t\t\t\todd_dp[i] = (odd_dp[i] <= odd_dp[i-table[k]]+1)?odd_dp[i]:odd_dp[i-table[k]]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tprintf(\"%d %d\\n\",dp[n],odd_dp[n]);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=1;\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp2[i+coin_ki[j]]=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  tmp=min(dp2[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=1;\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint INF = (1LL << 30) - 1;\nint MOD = 1e9+7;\nvector<int> V,W;\nint MAX_NUM = 1000000;\nvector<int> table(MAX_NUM);\nP dp(int N){\n    P ans;\n    table.assign(N+1,INF);\n    table[0] = 0;\n    rep(i,0,V.size()){\n        rep(j,0,N+1){\n            if(j + V[i] > N)break;\n            table[j + V[i]] = min(table[j + V[i]], table[j] + 1);\n        }\n    }\n    ans.first = table[N]; \n    table.assign(N+1,INF);\n    table[0] = 0;\n    rep(i,0,W.size()){\n        rep(j,0,N+1){\n            if(j + W[i] > N)break;\n            table[j + W[i]] = min(table[j + W[i]], table[j] + 1);\n        }\n    }\n    ans.second = table[N];\n    return ans;\n}\nmain(){\n    for(int i = 1;i * (i + 1) * (i + 2) / 6 <= MAX_NUM;i++){\n        int num = i * (i + 1) * (i + 2) / 6; \n        V.push_back(num);\n        if(i % 4 == 1)W.push_back(num);\n    }\n\n    int N;\n    cin >> N;\n    while(N){\n        auto ans = dp(N);\n        cout << ans.first << \" \" << ans.second << endl;\n        cin >> N;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvi llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\n\nint beam_width=10000;\n\nint bfs(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n        }\n        if(i<target){\n            q.pb(i);\n            mm=i;\n        }\n        if(i>target) break;\n    }\n    //auto mm=*max_element(beginend(q));\n    int cnt=0;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(llist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,llist){\n                if(k+x>target) break;\n                // if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.pb(k+x);\n            }\n\n            \n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) {q.pb(i);mm=i;}\n        if(i>target) break;\n    }\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    //out(mm);\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(oddlist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                //if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.pb(k+x);\n            }\n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    int mm=0;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n        mm=max(mm,n);\n    }\n    map<int,pii> m;\n    makeList(mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        //int ans2=0;\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include<numeric>\n#include<cmath>\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define INF 2e9\n#define ALL(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst int maxn = 1100000;\n\n\nint main(){\n    //cin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\t//cout << fixed << setprecision(15);\n    vector<int> tetra, tetra_odd;\n    int i = 0;\n    while(i *(i+1)*(i+2) / 6 < 1100000){\n        i++;\n        int a = i *(i+1)*(i+2) / 6;\n        tetra.push_back(a);\n        if(i % 4 == 1) tetra_odd.push_back(a);\n    }\n    /*REP(i,7){\n        cout << tetra_odd[i] << endl;\n    }*/\n    vector<int> dp(maxn+1);\n    vector<int> dp_odd(maxn+1);\n    dp[0] = 0;\n    dp[1] = 1;\n    FOR(i,2,maxn+1){\n        dp[i] = dp[i-1] + 1;\n        int j = 0;\n        while(tetra[j] <= i && j < tetra.size()){\n            dp[i] = min(dp[i], dp[i - tetra[j]] + 1);\n            j++;\n        }\n    }\n\n    dp_odd[0] = 0;\n    dp_odd[1] = 1;\n    /*REP(i,maxn+1){\n        dp_odd[i] = i;\n    }*/\n    FOR(i,2,maxn){\n        dp_odd[i] = dp_odd[i-1] + 1;\n        int j = 0;\n        while(j < tetra_odd.size()){\n            if(tetra_odd[j] <= i) dp_odd[i] = min(dp_odd[i], dp_odd[i - tetra_odd[j]] + 1);\n            //else break;\n            j++;\n        }\n    }\n    /*REP(i,40){\n        cout << dp_odd[i] << endl;\n    }*/\n\n    vector<int> ans1,ans2;\n    while(true){\n        int N; cin >> N;\n        if(N == 0){\n            REP(i,ans1.size()){\n                cout << ans1[i] << \" \" <<  ans2[i] << endl;\n            }\n            return 0;\n        }\n        else{\n            ans1.push_back(dp[N]);\n            ans2.push_back(dp_odd[N]);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n;\nint res =inf;\nint solve(int a,int b,int c,vector<int> v){\n  if(b == 0) res = inf;\n//   rep(i,b) cout <<\"\\t\";\n//   cout << a<< \" \" << b << \" \" << v[c]<<endl;\n  if(a == n){\n    res = min(res,b);\n    return b;\n  }\n  if(a > n || res <= b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < 1000000){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    lb1 += n % suqnum[lb1] == 0;\n    lb2 += n % odd[lb2] == 0;\n    queue<pii> q;\n    q.push(make_pair(0,0));\n    while(!q.empty()){\n      pii p = q.front();q.pop();\n      REP(i,lb1,suqnum.size()){\n        if(p.se+suqnum[i] == n){\n          cout << p.fi+1<< \" \";\n          q = queue<pii>();\n          break;\n        }\n        else if(p.se+suqnum[i] <= n){\n          q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n        }\n      }\n    }\n    q.push(make_pair(0,0));\n    while(!q.empty()){\n      pii p = q.front();q.pop();\n      REP(i,lb2,odd.size()){\n        if(p.se+odd[i] == n){\n          cout << p.fi+1<< endl;\n          q = queue<pii>();\n          break;\n        }\n        else if(p.se+odd[i] < n){\n          q.push(make_pair(p.fi+1,p.se+odd[i]));\n        }\n      }\n    }\n//     cout << solve(0,0,lb1,suqnum)<<endl;\n//     cout << solve(0,0,lb2,odd) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define MAXN 1000000\n#define ll long long\n\nll dp[MAXN + 1];\nll Odp[MAXN + 1];\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < MAXN + 1;i++) {\n\t\tdp[i] = i;\n\t\tOdp[i] = i;\n\t}\n\t// n := n???????????£?????¢???\n\t// p := ??£?????¢?????°\n\t// n = 1 p = 1 ?????´???????????????\n\t// n = 2, p = 2*3*4/6 = 4??????\n\tll p = 4;\n\tfor (int n = 2; p <= MAXN;n++) {\n\t\t p = n*(n + 1)*(n + 2) / 6;\n\t\t //cout << n << \" \" << p << endl;\n\t\tfor (int i = 0; i + p <= MAXN;i++) {\n\t\t\tdp[i + p] = min(dp[i + p], dp[i] + 1);\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tOdp[i + p] = min(Odp[i + p], Odp[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint N;\n\twhile (cin >> N,N) {\n\t\tcout << dp[N] << \" \" << Odp[N] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[200][1000010] = { 0 };\n\nint N = 0;\nint C[190];\nint Codd[50];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define SZ(a) (int)((a).size())\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\ntypedef pair<int,int> PI;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\n\nint dp[1200000];\nint odp[1200000];\nint n;\nvoid solve(){\n  \n}\n\nint main(){\n  rep(i,1200000) dp[i]=1<<28;\n  rep(i,1200000) odp[i]=1<<28;\n\n  dp[0]=0;\n  odp[0]=0;\n  \n  for(int i=1;;++i){\n    int p = i*(i+1)*(i+2)/6;\n    if(p>1100000) break;\n    //cout <<  i << endl;\n    for(int j=0;j+p<1200000;++j)\n      dp[j+p]=min(dp[j+p],dp[j]+1);\n    if(p&1)\n      for(int j=0;j+p<1200000;++j)\n        odp[j+p]=min(odp[j+p],odp[j]+1);\n      // for(int j=110000-p;j>=0;--j)\n      //   odp[j+p]=min(odp[j+p],odp[j]+1);\n  }\n  \n  //return 0;\n  \n  while(cin >> n,n) cout << dp[n] << \" \" << odp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline int setbit(int n) { return (1 << n) - 1; }\ninline bool contains(int x, int min, int max) { return x >= min && x < max; } // max含まない\n\nvoid solve()\n{\n\tint testcases = INF;\n\tint M = 1e6 + 1;\n\tvector<int> t1, t2;\n\tfor (int i = 0; i * (i + 1) * (i + 2) / 6 < M; i++)\n\t{\n\t\tint x = i * (i + 1) * (i + 2) / 6;\n\t\tt1.push_back(x);\n\t\tif (x & 1) t2.push_back(x);\n\t}\n\n\tvector<int> a1(10e6 + 1, INF); a1[0] = 0;\n\tvector<int> a2(10e6 + 1, INF); a2[0] = 0;\n\n\tfor (auto x : t1)\n\tfor (int j = x; j < M; j++)\n\t\ta1[j] = min(a1[j], a1[j - x] + 1);\n\n\n\tfor (auto x : t2)\n\tfor (int j = x; j < M; j++)\n\t\ta2[j] = min(a2[j], a2[j - x] + 1);\n\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!(N)) { break; }\n\t\tWRITE(a1[N], a2[N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nll dp[1000001],dpo[1000001];\n\nconst ll MAX=LONG_MAX/10;\n\nll pol(ll n){\n\treturn n*(n+1)*(n+2)/6;\n}\n\nll dfs(ll n,bool odd,int size){\n\tll (&dpp)[1000001]=(odd?dpo:dp);\n\tif(dpp[n]!=MAX){\n\t\treturn dpp[n];\n\t}\n\tif(n==0){\n\t\treturn 0;\n\t}\n\tif(size>100){\n\t\treturn MAX;\n\t}\n\tll ret=MAX;\n\tfor(ll j=1,i=pol(j);i<=n;j++,i=pol(j)){\n\t\tif(odd&&(!(i&1)))continue;\n\t\tret=min(ret,dfs(n-i,odd,size+1)+1);\n\t}\n\treturn dpp[n]=ret;\n}\n\nint main(){\n\tll n;\n\tREP(i,1000001){\n\t\tdp[i]=MAX;\n\t}\n\tREP(i,1000001){\n\t\tdpo[i]=MAX;\n\t}\n\tREP(i,1000000){\n\t\tdp[i]=dfs(i,false,0);\n\t\tdpo[i]=dfs(i,true,0);\n\t}\n\twhile(cin>>n,n){\n\t\tcout<<dfs(n,false,0);\n\t\tcout<<\" \"<<dfs(n,true,0)<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,i,j,k,t=0,a[200]={},b[200]={},c[1000005]={1000000},d[1000005]={1000000};\n  for(i=1;i<201;i++) {\n    a[i-1]=i*(i+1)*(i+2)/6;\n    if(a[i-1]%2==1)b[t++]=m[i-1];\n  }\n  for(i=c[0]=d[0]=0;i<200;i++) {\n    for(j=a[i];j<1000005;j++){\n      c[j]=min(c[j],c[j-a[i]]+1);\n    }\n  }\n  for(i=0;i<t;i++) {\n    for(j=b[i];j<1000005;j++){\n      d[j]=min(d[j],d[j-b[i]]+1);\n    }\n  }\n  while(cin>>n,n)cout<<c[n]<<\" \"<<b[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[MAXNUM], fourodd[MAXNUM];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tlong long int now = 0;\n\tlong long int allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\n\t\tint four = now * (now + 1) * (now + 2) / 6;\n\t\t//cout << four << endl;\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t\t\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t}\n\n\t//cout << allcounter << \", \" << oddcounter << endl;\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < allcounter; i++){\n\t\tconst int num_all = fourall[i];\n\n\t\tfor (int j = 1; j < (MAXNUM - num_all); j++){\n\t\t\tall[j + num_all] = min(all[j + num_all], 1 + all[j]);\n\t\t}\n\t}\n\n\tfor (int i = 1; i < oddcounter; i++){\n\t\tconst int num_odd = fourodd[i];\n\n\t\tfor (int j = 1; j < (MAXNUM - num_odd); j++){\n\t\t\todd[j + num_odd] = min(odd[j + num_odd], 1 + odd[j]);\n\t\t}\n\t}\n\n\n\t/*\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; fourall[j] < i; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t\tcout << all[i];\n\t\t}\n\t\tfor (int j = 1; fourodd[j] < i; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t*/\n\n\t//cout << \"a\";\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nvector<int> pol;\nvector<int> pol_odd;\nset<int> s;\nint dp1[1000100],dp2[1000100];\nint dfs1(int k)\n{\n\tif(dp1[k]!=-1)return dp1[k];\n\tint res=INF;\n\tfor(int i=0;i<pol.size();i++)\n\t{\n\t\tif(pol[i]>k)break;\n\t\tres=min(res,dfs1(k-pol[i])+1);\n\t}\n\treturn dp1[k]=res;\n}\nint dfs2(int k)\n{\n\tif(dp2[k]!=-1)return dp2[k];\n\tint res=INF;\n\tfor(int i=0;i<pol_odd.size();i++)\n\t{\n\t\tif(pol_odd[i]>k)break;\n\t\tres=min(res,dfs2(k-pol_odd[i])+1);\n\t}\n\treturn dp2[k]=res;\n}\nint main()\n{\n\tmemset(dp1,-1,sizeof(dp1));\n\tmemset(dp2,-1,sizeof(dp2));\n\tdp1[0]=dp2[0]=0;\n\ts.insert(0);\n\tfor(int i=1;;i++)\n\t{\n\t\tint k=i*(i+1)*(i+2)/6;\n\t\tif(k>1000000)break;\n\t\tpol.pb(k);\n\t\tif(k%2)pol_odd.pb(k);\n\t}\n\twhile(1)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",dfs1(n),dfs2(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dp1[1000001], dp2[1000001];\n\nint main()\n{\n    fill(dp1, dp1 + 1000001, 1000000000);\n    fill(dp2, dp2 + 1000001, 1000000000);\n    \n    dp1[0] = dp2[0] = 0;\n    \n    for (int i = 1; i * (i + 1) * (i + 2) <= 6000000; i++){\n        int s = i * (i + 1) * (i + 2) / 6;\n        \n        if (s & 1){\n            for (int j = 0; j + s <= 1000000; j++){\n                dp2[j + s] = min(dp2[j + s], dp2[j] + 1);\n            }\n        }\n        for (int j = 0; j + s <= 1000000; j++){\n            dp1[j + s] = min(dp1[j + s], dp1[j] + 1);\n        }\n    }\n    \n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        printf(\"%d %d\\n\", dp1[n], dp2[n]);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\nusing namespace std;\n\nint memo[150];\nint dp[1000002];\nint dp2[1000002];\nvoid inset(){\n\tdp[0]=0;\n\tfill(dp,dp+100001,1000000);\n\tfill(dp2,dp2+100001,1000000);\n\tdp[0]=0;\n\tdp2[0]=0;\n\trep(i,1,150){\n\t\tmemo[i]=i*(i+1)*(i+2),memo[i]/=6;\n\t\trep(j,1,100001)if(j-memo[i]>=0){\n\t\tif(dp[j]>dp[j-memo[i]]+1)dp[j]=dp[j-memo[i]]+1;\n\t\tif(memo[i]&1)if(dp2[j]>dp2[j-memo[i]]+1)dp2[j]=dp2[j-memo[i]]+1;\n\t\t}\n\t}\n\t//rep(i,1,150){\n\t//\tprintf(\"[%d]%d\\n\",i,dp2[i]);\n\t//}\n}\n\n\nint main(void){\n\tinset();\n\tint x;\n\twhile(true){\n\t\tcin>>x;if(x==0)return(0);\n\t\tcout<<dp[x]<<\" \"<<dp2[x]<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1];\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      if(dp[0][nxt]>dp[0][j]+1)dp[0][nxt] = dp[0][j] + 1;\n      if( (val&1) && (dp[1][nxt]>dp[1][j]+1))dp[1][nxt] = dp[1][j] + 1;\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  int n;\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[x];\n    int coin_ki[x];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n \nint main(void){\n    int i, j, n, min1,small;\n    int dp[1000000];\n    scanf(\"%d\",&n);\n    while(n != 0){\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(small > dp[i]){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n                if(small > dp[n])\n                    small = dp[n];\n        }\n \n        min1 = dp[n];\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(dp[i] < small){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n            if(small > dp[n])\n                small = dp[n];\n        }\n        printf(\"%d %d\\n\",min1,dp[n]);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main() {\n    int table[1000000];\n    int max;\n    for (int i = 1; i < 1000000; i++) {\n        table[i] = i * (i + 1) * (i + 2) / 6;\n        if (table[i] >= 1000000) {\n            max = i - 1;\n            break;\n        }\n    }\n\n    int m;\n    while (cin >> m, m) {\n        priority_queue<pii, vector<pii>, greater<pii>> q;\n        q.push({0, 0});\n        while (!q.empty()) {\n            pii p = q.top(); q.pop();\n            int count = p.first;\n            int total = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << \" \";\n                break;\n            }\n\n            for (int i = 1; i < max; i++) {\n                if (table[i] + total <= m)\n                    q.push({count+1, table[i] + total});\n            }\n        }\n        while(!q.empty())\n            q.pop();\n        q.push({0, 0});\n        while (!q.empty()) {\n            pii p = q.top(); q.pop();\n            int count = p.first;\n            int total = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << endl;\n                break;\n            }\n\n            for (int i = 1; i < max; i++) {\n                if (table[i] % 2 && table[i] + total <= m)\n                    q.push({count+1, table[i] + total});\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1];\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      if(dp[0][nxt]>dp[0][j]+1)dp[0][nxt] = dp[0][j] + 1;\n      if( (val&1) && (dp[1][nxt]>dp[1][j]+1))dp[1][nxt] = dp[1][j] + 1;\n    }\n    val *= (i+3), val /= i;\n  }\n\n  int n;\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nconst int tetra_size = 185;\nint tetra[tetra_size];\nint tri[tetra_size];\nvoid settetra(){\n\ttetra[0] = 0;\n\ttri[0] = 0;\n\tfor(int i = 1; i < tetra_size; i++){\n\t\ttri[i] = tri[i-1] + i;\n\t\ttetra[i] = tetra[i-1] + tri[i];\n\t}\n}\n\nint dp[1000001];\nint dpodd[1000001];\nvoid setdp(){\n\tfill(dp, dp+1000001, INF);\n\tdp[0] = 0;\n\tfill(dpodd, dpodd+1000001, INF);\n\tdpodd[0] = 0;\n\tfor(int i = tetra_size ; i >= 1; i--){\n\t\tfor(int j = 0; j + tetra[i] < 1000001; j++ ){\n\t\t\tif(dp[j] == INF) continue;\n\t\t\tdp[j+tetra[i]] = min(dp[j]+1, dp[j+tetra[i]]);\n\t\t\tif(tetra[i]%2 == 1) dpodd[j+tetra[i]] = min(dpodd[j]+1, dpodd[j+tetra[i]]);\n\t\t}\n\t}\n}\n\nint main(){\n\tsettetra();\n\tsetdp();\n\tint n;\n\twhile(cin >> n){\n\t\t//cout << tetra[n]  << endl;\n\t\tcout << dp[n] << ' ' <<  dpodd[n]  << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//using Graph = vector<vector<edge>>;\nusing dou =long double;\nstring yes=\"yes\";\nstring Yes=\"Yes\";\nstring YES=\"YES\";\nstring no=\"no\";\nstring No=\"No\";\nstring NO=\"NO\";\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n#define rep(i, n)         for(int i = 0; i < (int)(n); i++)\n#define brep(n)           for(int bit=0;bit<(1<<n);bit++)\n#define erep(i,container) for (auto i : container)\n#define irep(i, n)        for(int i = n-1; i >= (int)0; i--)\n#define rrep(i,m,n) for(ll i = m; i < (ll)(n); i++)\n#define reprep(i,j,h,w) rep(i,h)rep(j,w)\n#define all(x) (x).begin(),(x).end()\n#define VEC(type,name,n) std::vector<type> name(n);rep(i,n)std::cin >> name[i];\n#define pb push_back\n#define pf push_front\n#define query int qq;std::cin >> qq;rep(qqq,qq)\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define itn int\n#define mp make_pair\n#define sum(a) accumulate(all(a),0ll)\n#define keta fixed<<setprecision\n#define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a))\n#define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<t>(n,a)));\n#define vvvvector(name,t,k,l,m,n,a) vector<vector<vector<vector<t> > > > name(k,vector<vector<vector<t> > >(l, vector<vector<t> >(m, vector<t>(n,a)) ));\n#define case std::cout <<\"Case #\" <<qqq+1<<\": \"\n#define res resize\n#define as assign\n#define ffor for(;;)\n#define ppri(a,b) std::cout << a<<\" \"<<b << std::endl\n#define pppri(a,b,c) std::cout << a<<\" \"<<b <<\" \"<< c<<std::endl\n#define aall(x,n) (x).begin(),(x).begin()+(n)\n \ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n//typedef long long T;\nconst int INF = 2000000000;\nconst ll INF64 = 922337203685477580ll;\nconst ll MOD = 1000000007ll;\nconst dou pi=3.141592653589793;\n\nint main(){\n    std::vector<int> dum(200);\n    dum[0]=1;\n    rrep(i,1,200){\n        dum[i]=(i+1)+dum[i-1];\n    }\n    std::vector<int> p(200);p[0]=1;\n    std::vector<int> pp;\n    rrep(i,1,200){\n        p[i]=p[i-1]+dum[i];\n    }\n    //erep(i,p)std::cout << i << std::endl;\n    erep(i,p){\n        if(i%2==1)pp.pb(i);\n    }\n    int m=p.size(),mm=pp.size();\n    std::vector<int> dp(1000001,INF),ddp(1000001,INF);\n    dp[0]=0;\n    ddp[0]=0;\n    rep(i,1000001){\n        erep(j,p){\n          //  if(i==0)std::cout << j << std::endl;\n            if(i+j<=1000000)chmin(dp[i+j],dp[i]+1);\n            else break;\n        }\n        erep(j,pp){\n            if(i+j<=1000000)chmin(ddp[i+j],ddp[i]+1);\n            else break;\n        }\n    }\n    for(;;){\n        int nn;\n        std::cin >> nn;\n        if(nn==0)exit(0);\n        else ppri(dp[nn],ddp[nn]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=1;\n\t  //tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=dp[x];\n\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  tmp=1; \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=dp[x];\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint normal[1001000];\nint odd[1001000];\n\nint main() {\n  MEMSET(normal, 0x0f);\n  MEMSET(odd, 0x0f);\n  normal[0] = odd[0] = 0;\n  REP(i, 1000001) {\n    REP(j, 10000) {\n      int plus = j * (j + 1) * (j + 2) / 6;\n      if (i + plus > 1000000) { break; }\n      normal[i + plus] = min(normal[i + plus], normal[i] + 1);\n      if (plus & 1) {\n        odd[i + plus] = min(odd[i + plus], odd[i] + 1);\n      }\n    }\n  }\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    printf(\"%d %d\\n\", normal[n], odd[n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nvoid solve(int n)\n{\n  vector<int> v;\n  for(int i = 0; ; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    if(t <= MAX)\n      v.push_back(t);\n    else\n      break;\n  }\n  for(int i = 0; i <= n; i++){\n    for(int j = 0; i + v[j] <= n; j++){\n      if(v[j] & 1)\n        dp2[i + v[j]] = min(dp2[i + v[j]], dp2[i] + 1);\n      dp[i + v[j]] = min(dp[i + v[j]], dp[i] + 1);\n    }\n  }\n}\n\n\n    \nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include<vector>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define req(i,n) for(int i = 1;i <=  n; i++)\ntypedef long long int ll;\nconst ll INF = (1 << 29);\nll h, m, n; string s;\nconst int Max = 1000100;\nint main() {\n    vector<int> dp(Max, INF), odp(Max, INF);\n    dp[0] = odp[0] = 0;\n    req(i, 175) {\n        ll num = i * (i + 1) * (i + 2) / 6;\n        if (num >= Max) break;\n        for (int j = num; j < Max; j++) {\n            dp[j] = min(dp[j], dp[j - num] + 1);\n            if (num & 1) odp[j] = min(odp[j], odp[j - num] + 1);\n        }\n    }while (cin >> n, n) {\n        cout << dp[n] << \" \" << odp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n, dp[1000000], dp2[1000000];\n\nvoid solve() {\n  cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  memset(dp, -1, sizeof dp);\n  memset(dp2, -1, sizeof dp2);\n  \n  dp[0] = dp2[0] = 0;\n  for (int i = 1; i < 1000000; i += 1) {\n    dp[i] = dp2[i] = i;\n    for (int j = 1;; j += 1) {\n      int s = j * (j + 1) * (j + 2) / 6;\n      if (s > i) break;\n      dp[i] = min(dp[i], dp[i - s] + 1);\n      if (s % 2) {\n        dp2[i] = min(dp2[i], dp2[i - s] + 1);\n      }\n    }\n  }\n  \n  while (cin>>n, n) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define TEST 0\n#if TEST\nFILE* in = freopen(\"./Q.txt\", \"r\", stdin);\nFILE* out = freopen(\"./A.txt\", \"w\",stdout);\n#endif\n\n#define MAXN 300\n#define MAXINPUT 1000001\n\nvector<int> seq;\nint normalAns[MAXINPUT];\nint oddAns[MAXINPUT];\n\nint main(int argc, const char * argv[]) {\n    for(int i = 0; i < MAXN; i++){\n        seq.push_back(i*(i + 1)*(i + 2)/6);\n    }\n    \n    for(int i = 0; i < MAXINPUT; i++){\n        normalAns[i] = oddAns[i] = i;\n        for(int j = 0; i - seq[j] >= 0; j++){\n            normalAns[i] = min(normalAns[i], normalAns[i-seq[j]] + 1);\n            if(seq[j]&1) oddAns[i] = min(oddAns[i], oddAns[i-seq[j]] + 1);\n        }\n    }\n    \n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        \n        cout << normalAns[n] << \" \" << oddAns[n] << endl;\n    }\n    \n#if TEST\n    fclose(in);\n    fclose(out);\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1000000000\n\n\n#define MAX_N 1000000\n\nint N;\n\nvector<pair<int, int> > ans_list;\n\nint memo[MAX_N];\n\n//nを作るのに必要な正四面体数の最小数を返す関数\nint solve(int n){\n  if(memo[n] > 0)\n    return memo[n];\n\n  if(n == 1)\n    return memo[1] = 1;\n\n  bool tmp_flag = false;\n  int tmp = INF;\n  for(int i = 1; i*(i+1)*(i+2)/6 <= n; i++){\n    if(i*(i+1)*(i+2)/6 == n){\n      tmp_flag = true;\n      break;\n    }\n    tmp =  min(tmp, solve(i*(i+1)*(i+2)/6) + solve(n - i*(i+1)*(i+2)/6));\n  }\n\n  if(tmp_flag)\n    tmp = 1;\n\n  return memo[n] = tmp;\n\n}\n\nint odd_memo[MAX_N];\n\n//nを作るのに必要な正四面体数の最小値を返す関数(奇数版)\nint odd_solve(int n){\n  \n  if(odd_memo[n] > 0)\n    return odd_memo[n];\n\n  if(n == 1)\n    return odd_memo[n] = 1;\n\n  bool tmp_flag = false;\n  int tmp = INF;\n  for(int i = 1; i*(i+1)*(i+2)/6 <= n; i++){\n    int a = i*(i+1)*(i+2)/6;\n    int b = n-a;\n    if(a == n && a%2 == 1){\n      tmp_flag = true;\n      break;\n    }\n    if(a % 2 == 1 || b%2 == 1)\n      tmp =  min(tmp, odd_solve(a) + odd_solve(b));\n  }\n\n  if(tmp_flag)\n    tmp = 1;\n\n  return odd_memo[n] = tmp;\n\n}\n\n\nint main(){\n\n  while(true){\n    cin >> N;\n    if(N == 0)\n      break;\n\n    ans_list.push_back(make_pair(solve(N), odd_solve(N)));\n\n  }\n\n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i].first << \" \" << ans_list[i].second << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst ll MOD=10000;\nconst ll INF=1000000010;\nconst int MAX=100001;\nint dx[8]={0,1,0,-1,1,-1,1,-1};\nint dy[8]={1,0,-1,0,1,-1,-1,1};\nint main(){\n\tint s[110];\n\tfor(int i=0;i<110;i++){\n\t\ts[i]=(i+1)*(i+2)*(i+3)/6;\n\t}\n\tint n;\n\twhile(cin>>n,n){\n\t\tint nn=n;\n\t\tint c=0;\n\t\twhile(n){\n\t\t\tc++;\n\t\t\tint ss;\n\t\t\tfor(int i=0;i<110;i++){\n\t\t\t\tif(s[i]>n){\n\t\t\t\t\tss=s[i-1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn-=ss;\n\t\t}\n\t\tcout<<c<<\" \";\n\t\tn=nn;\n\t\tc=0;\n\t\twhile(n){\n\t\t\tc++;\n\t\t\tint ss;\n\t\t\tfor(int i=0;i<110;i++){\n\t\t\t\tif(s[i]>n){\n\t\t\t\t\tss=i-1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=ss;i>=0;i--){\n\t\t\t\tif(s[i]%2){\n\t\t\t\t\tss=s[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn-=ss;\n\t\t}\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#define INF 1e8\nusing namespace std;\nint n;\nint dp[5000001];\nint dp2[5000001];\n\nint func(int v){\n\tif(dp[v]!=INF)return dp[v];\n\tif(v==0)return 0;\n\tint cnt=INF;\n\tint j=1;\n\twhile(j*(j+1)*(j+2)/6<=v)j++;\n\tj--;\n\tfor(int i=j;i>=1;i--){\n\t\tcnt=min(cnt,func(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp[v]=cnt+1);\n}\n\nint func2(int v){\n\tif(dp2[v]!=INF)return dp2[v];\n\tif(v==0)return 0;\n\tint cnt=INF;\n\tint j=1,i;\n\twhile(j*(j+1)*(j+2)/6<=v)j++;\n\tj--;\n\tfor(i=j;i>=1;i--){\n\t\tif((i*(i+1)*(i+2)/6)%2!=1)continue;\n\t\tcnt=min(cnt,func2(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp2[v]=cnt+1);\n}\n\nint main(void){\n\tfor(int i=1;i<=2000000;i++)dp[i]=dp2[i]=INF;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",func(n),func2(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1e9+7;\n\nll dp[100][1000010];\nll dp2[100][1000010];\nint main(void){\n    ll n,i,j;\n    while(cin >> n && n){\n        std::vector<ll> v,v2;\n        for(i=1;(i*(i+1)*(i+2)/6)<=n;i++){\n            v.push_back(i*(i+1)*(i+2)/6);\n            if((i*(i+1)*(i+2)/6)%2)v2.push_back(i*(i+1)*(i+2)/6);\n        }\n        ll vs = v.size();\n        \n        fill(dp[0],dp[0]+(vs+1)*(n+1),1000000);\n        //cout << dp[0][0] << endl;\n        dp[0][0]=0;\n        \n        for(i=1;i<=vs;i++){\n            for(j=0;j<=n;j++){\n                if(j-v[i-1]<0)dp[i][j]=dp[i-1][j];\n                else dp[i][j]=min(dp[i][j-v[i-1]]+1,dp[i-1][j]);\n            }\n        }\n        \n        ll ret1 = dp[vs][n];//直にやるほう\n        vs = v2.size();\n        fill(dp2[0],dp2[0]+(vs+1)*(n+1),1000000);\n        dp2[0][0]=0;\n        for(i=1;i<=vs;i++){\n            for(j=0;j<=n;j++){\n                if(j-v2[i-1]<0)dp2[i][j]=dp2[i-1][j];\n                else dp2[i][j]=min(dp2[i][j-v2[i-1]]+1,dp2[i-1][j]);\n            }\n        }\n        ll ret2 = dp2[vs][n];\n        cout << ret1 << \" \" << ret2 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\n\nint main() {\n    int table1[100000];\n    int max1;\n    for (int i = 1; i < 100000; i++) {\n        table1[i] = i * (i + 1) * (i + 2) / 6;\n        if (table1[i] >= 1000000) {\n            max1 = i - 1;\n            break;\n        }\n    }\n    int table2[100000];\n    int max2;\n    for (int i = 1; i < 100000; i++) {\n        int n = i;\n        do {\n            table2[i] = n * (n + 1) * (n + 2) / 6;\n            n++;\n        } while (table2[i] % 2 == 0);\n        if (table2[i] >= 1000000) {\n            max2 = i - 1;\n            break;\n        }\n    }\n\n    int m;\n    while (cin >> m, m) {\n        bool used[1000000];\n        fill_n((bool *)used, 1000000, false);\n        priority_queue<ppiii, vector<ppiii>, greater<ppiii>> q;\n        q.push({{0, 0}, 1});\n        while (!q.empty()) {\n            ppiii p = q.top(); q.pop();\n            int count = p.first.first;\n            int total = p.first.second;\n            int now = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << \" \";\n                break;\n            }\n\n            for (int i = now; i < max1; i++) {\n                int sum = table1[i] + total;\n                if (sum <= m && !used[sum]) {\n                    q.push({{count+1, sum}, i});\n                    used[sum] = true;\n                }\n            }\n        }\n        while(!q.empty())\n            q.pop();\n        fill_n((bool *)used, 1000000, false);\n        q.push({{0, 0}, 1});\n        while (!q.empty()) {\n            ppiii p = q.top(); q.pop();\n            int count = p.first.first;\n            int total = p.first.second;\n            int now = p.second;\n\n            // goal\n            if (total == m) {\n                cout << count << endl;\n                break;\n            }\n\n            for (int i = now; i < max2; i++) {\n                int sum = table2[i] + total;\n                if (table2[i] % 2 && sum <= m && !used[sum]) {\n                    q.push({{count+1, sum}, i});\n                    used[sum] = true;\n                }\n            }\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++) if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<185;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint list[100];\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n\t\tlist[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;list[j]<=i-1;j+=2)if(!dp2[i] || dp2[list[j]]+dp2[i-list[j]] < dp2[i]) dp2[i]=dp2[list[j]]+dp2[i-list[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;list[j]<=i-1;j++) if(!dp1[i] || dp1[list[j]]+dp1[i-list[j]] < dp1[i]) dp1[i]=dp1[list[j]]+dp1[i-list[j]];\n\t}\n}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nint main()\n{\n\tint n;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j <= 1000000; j++)\n\t\t{\n\t\t\tif (j == 0)dp[i][j] = 0;\n\t\t\telse dp[i][j] = 999999;\n\t\t}\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tvector<int> v;\n\t\tfor (int i = 1;; i++)\n\t\t{\n\t\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\t\tif (k > n)break;\n\t\t\tv.push_back(k);\n\t\t}\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < v.size(); j++)\n\t\t\t{\n\t\t\t\tif (i + v[j] > 1000000)break;\n\t\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]],dp[0][i] + 1);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < v.size();j++)\n\t\t\t{\n\t\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\t\tif (i + v[j] > 1000000)break;\n\t\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define req(i,r,k) for(int i=k;i<r;i++)\n#define rep(i,r) req(i,r,0)\nconst int INF = 10000;\n\nint dp[180][1000000];\n//int odddp[91][1000000] = {INF};\n\nconst long  int h = 180,oddh = 90,w=1000000;\n\nint main() {\n\n    int n,a,a2;\n\n    vector<int> t;\n\n    req(i,200,1){\n        t.push_back(i * (i+1) * (i+2) / 6);\n        if(t[i-1] > 1000000) {\n            t.erase(t.end() - 1);\n            break;\n        }\n    }\n\n    rep(i,h){\n        rep(j,w){\n            dp[i][j] = INF;\n        }\n    }\n\n    rep(j,w){\n        dp[0][j] = 0;\n        //odddp[0][j] = 0;\n    }\n\n    /*rep(i,20){\n        rep(j,41){\n            cout << dp[i][j] << \" \";\n        }\n        cout << endl;\n    }*/\n\n    rep(i,h){\n        dp[i][0] = 0;\n    }\n\n/*\n    rep(i,oddh){\n        odddp[i][0] = 0;\n    }\n*/\n\n\n    while(1){\n\n        cin >> n;\n        if(n==0) break;\n\n        if(dp[h-1][n] == INF){\n            rep(i,h){\n                rep(j,w){\n                    if(j >= t[i]){\n                        dp[i+1][j] = min(dp[i][j],dp[i][j-t[i]] + 1);\n                    }\n                    else{\n                        dp[i+1][j] = dp[i][j];\n                    }\n                }\n            }\n        }\n\n        cout << dp[h-1][n] << ' ';\n/*\n        if(odddp[oddh-1][n] == INF){\n            rep(i,oddh){\n                rep(j,w){\n                    if(j >= t[i]){\n                        dp[i+1][j] = min(dp[i][j],dp[i][j-t[i]] + 1);\n                    }\n                    else{\n                        dp[i+1][j] = dp[i][j];\n                    }\n                }\n            }\n        }\n\n        cout << odddp[h-1][n] << endl;\n*/\n    }\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define REP(i,l,n) for(int i=l;i<n;++i)\nint ans = 0;\nint oddans = 0;\nint pol[200];\nint oddpol[100];\nint oddpolcount = 0;\nint memo[1000000];\nint oddmemo[1000000];\nint memorep(int n);\nint oddmemorep(int n);\nusing namespace std;\nint main() {\n  pol[0] = 1;\n  oddpol[oddpolcount++] = 1;\n  int def = 3;\n  int defdef = 3;\n  REP(i,1,180){\n    pol[i] = pol[i-1] + def;\n    if(pol[i]%2==1) oddpol[oddpolcount++] = pol[i];\n    def += defdef++;\n  }\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    ans = memorep(n);\n    oddans = oddmemorep(n);\n    int i = 0;\n    cout << ans << \" \" << oddans << endl;\n  }\n  return 0;\n}\n\nint memorep(int n){\n  assert(n < 1000000);\n  if(memo[n]!=0) return memo[n];\n  int result;\n  int min = 1000000;\n  for(int i = 179;i>=0;i--){\n    result = n-pol[i];\n    if(result == 0){\n      return memo[n] = 1;\n    }\n    if(result > 0){\n      result = memorep(result) + 1;\n      if(min > result) min = result;\n    }\n  }\n  return memo[n] = min;\n}\n\nint oddmemorep(int n){\n  if(oddmemo[n]!=0) return oddmemo[n];\n  int result;\n  int min = 1000000;\n  for(int i = oddpolcount-1;i>=0;i--){\n    result = n-oddpol[i];\n    if(result == 0){\n      return oddmemo[n] = 1;\n    }\n    if(result > 0){\n      result = oddmemorep(result) + 1;\n      if(min > result){\n        min = result;\n      }\n    }\n  }\n  return oddmemo[n] = min;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nvi all, odd, v;\nint allt[1000005], oddt[1000005];\n\nint main()\n{\n\tv.push_back(0);\n\tFOR(i, 1, 1000) v.push_back(v[i - 1] + i);\n\tall.push_back(0);\n\tFOR(i,1, v.size())\n\t{\n\t\tall.push_back(all[i - 1] + v[i]);\n\t\tif (i & 1) odd.push_back(all[i - 1] + v[i]);\n\t\tif (all[i] > 1000000) break;\n\t}\n\tint n;\n\tfill(ALL(allt), INF); fill(ALL(oddt), INF);\n\tREP(i, 1000001)REP(j, all.size())\n\t{\n\t\tint t = i + all[j];\n\t\tif (t >= 1000001) break;\n\t\tallt[t] = min(allt[i] + 1, allt[t]);\n\t}\n\tREP(i, 1000001)REP(j, odd.size())\n\t{\n\t\tint t = i + odd[j];\n\t\tif (t >= 1000001) break;\n\t\toddt[t] = min(oddt[i] + 1, oddt[t]);\n\t}\n\twhile (cin >> n, n) cout << allt[n] << \" \" << oddt[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[200][1000010] = { 0 };\n\nint N = 0;\nint C[200];\nint Codd[50];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 200;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\t}\n\t\n\t\n\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct P{\n  int sum;\n  char k,n;\n  P(){}\n  P(int S,int K,int N){ sum=S;k=K;n=N; }\n};\n\nint a[200];\n\nint main(){\n  int n, ans1,ans2;\n  queue<P> q;\n  P p;\n\n  a[0]=0;\n  for( int i=1;i<200 ; i++ )\n    if( (a[i]=i*(i+1)*(i+2)/6)>1000000 )\n      break;\n\n  int size,n2;\n  while( cin>>n && n ){\n\n    ans1=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<200;i++ ){\n      if( a[i]==n ){\n\tans1=1; size=i+1;\n\tbreak;\n      }\n      if( a[i]<n ) q.push( P(a[i],i,1) );\n      else{\n\tsize=i; break;\n      }\n    }\n    while( !ans1 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      int mm=n-p.sum;\n      int *ip = lower_bound( a,a+size,mm );\n      if( *ip==mm ){\n\tans1=n2; break;\n      }\n      while( *ip ){\n\tint i = (ip-a);\n\tint j=p.sum+(*ip);\n\tq.push( P(j,i,n2) );\n\tip--;\n      }\n    }\n\n    ans2=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<size;i++ ){\n      if( a[i]%2==1 ){\n\tif( a[i]==n ){ ans2=1; break; }\n\tq.push( P(a[i],i,1) );\n      }\n    }\n    while( !ans2 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      int mm=n-p.sum;\n      int *ip=lower_bound( a,a+size,mm );\n      if( *ip==mm && (*ip)%2==1 ){\n\tans2=n2; break;\n      }\n      while( *ip ){\n\tint i=(ip-a);\n\tif( (*ip)%2==1 ){\n\t  int j=p.sum+(*ip);\n\t  q.push( P(j,i,n2) );\n\t}\n\tip--;\n      }\n\n      /*\n      if( mm%2==1 && binary_search( a,a+size,mm ) ){\n\tans2=n2; break;\n      }\n      for( int i=p.k,j;i<size;i++ ){\n\tif( a[i]%2==1 ){\n\t  j=p.sum+a[i];\n\t  if( j>n ) break;\n\t  q.push( P(j,i,n2) );\n\t}\n      }\n      */\n    }\n    \n    cout << ans1 << \" \" << ans2 << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 999999\n\n/*void pollock(int po[], int od[]) {\n\tint i = 1, j = 1;\n\twhile (po[i - 1] < 1000000) {\n\t\tpo[i] = (i * (i + 1) * (i + 2)) / 6;\n\t\tif (po[i] % 2 == 1) {\n\t\t\tod[j] = po[i];\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}*/\n\nint main() {\n\tvector<int> tmp(1000000, MAX);\n\tvector<int> odtmp(1000000, MAX);\n\ttmp[0] = 0, odtmp[0] = 0;\n\tint t = 1, i = 1;\n\twhile (t <= MAX) {\n\t\t\tfor (int j = 0; j + t <= MAX; ++j) {\n\t\t\t\ttmp[j + t] = min(tmp[j + t], tmp[j] + 1);\n\t\t\t\tif (t % 2 == 1) odtmp[j + t] = min(odtmp[j + t], odtmp[j] + 1);\n\t\t\t}\n\t\t\ti++;\n\t\t\tt = (i * (i + 1) * (i + 2)) / 6;\n\t\t}\n\tint n;\n\twhile (cin >> n && n) {\n\t\tcout << tmp[n] << \" \" << odtmp[n] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\n#include <iterator>\n#include <climits>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define X first\n#define Y second\n\nconst LL MOD = 1000000007;\n\ntemplate<typename T>\nvoid dump(T a, int n) { for (int i = 0; i < n; i++) cout << a[i] << (i == n - 1 ? '\\n' : ' '); }\n\ntemplate<typename T>\nvoid dump(T a) { dump<T>(a, a.size()); }\n\nconst int LIM = 1000000;\nconst int INF = INT_MAX;\n\nint main(void) {\n\tVI nums;\n\tVI evens;\n\tfor (int i= 1; i <= LIM; i++) {\n\t\tint num = i * (i + 1) * (i + 2) / 6;\n\t\tif (num > LIM) {\n\t\t\tbreak;\n\t\t}\n\n\t\tnums.push_back(num);\n\n\t\tif (num % 2) {\n\t\t\tevens.push_back(num);\n\t\t}\n\t}\n\n\tVI dpa(LIM + 1, INF);\n\tVI dpb(LIM + 1, INF);\n\tdpa[0] = 0;\n\tdpb[0] = 0;\n\t\n\tfor (int i = 0; i < LIM; i++) {\n\t\tif (dpa[i] != INF) {\n\t\t\tfor (auto a : nums) {\n\t\t\t\tint n = i + a;\n\t\t\t\tif (n <= LIM) {\n\t\t\t\t\tdpa[n] = min(dpa[n], dpa[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dpb[i] != INF) {\n\t\t\tfor (auto b : evens) {\n\t\t\t\tint n = i + b;\n\t\t\t\tif (n <= LIM) {\n\t\t\t\t\tdpb[n] = min(dpb[n], dpb[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int N; cin >> N, N;) {\n\t\tcout << dpa[N] << \" \" << dpb[N] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  dp[i+coin[j]]=1;\n\t}\n      }\n    }\n\n\n    int ans1=1;\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp2[i+coin_ki[j]]=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  tmp=min(dp2[i+coin_ki[j]],dp[i]+1);\n\t  dp[i+coin_ki[j]]=2;\n\t}\n      }\n    }\n   \n    \n    int ans2=1;\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nstatic const int INF = 999999999;\nvector<int> tetrahedral;\nint min_depth;\nint min_odd_depth;\nint n;\n\nvoid DFS(int pos, int depth, int sum)\n{\n\tif(depth >= min_depth)\n\t{\n\t\treturn;\n\t}\n\tif(sum == n)\n\t{\n\t\tif(depth < min_depth)\n\t\t{\n\t\t\tmin_depth = depth;\n\t\t}\n\t\treturn;\n\t}\n\telse if(sum > n)\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tDFS(i, depth + 1, sum + tetrahedral[i]);\n\t\t}\n\t}\n}\n\nvoid DFS2(int pos, int depth, int sum)\n{\n\tif(depth >= min_odd_depth)\n\t{\n\t\treturn;\n\t}\n\tif(sum == n)\n\t{\n\t\tif(depth < min_odd_depth)\n\t\t{\n\t\t\tmin_odd_depth = depth;\n\t\t}\n\t\treturn;\n\t}\n\telse if(sum > n)\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tif(tetrahedral[i] % 2)\n\t\t\t{\n\t\t\t\tDFS2(i, depth + 1, sum + tetrahedral[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; ++i)\n\t{\n\t\ttetrahedral.push_back(i * (i + 1) * (i + 2) / 6);\n\t}\n\twhile(cin >> n, n)\n\t{\n\t\tmin_depth = INF;\n\t\tmin_odd_depth = INF;\n\t\tint pos = 0;\n\t\twhile(tetrahedral[pos] < n)\n\t\t{\n\t\t\t++pos;\n\t\t}\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tDFS(i, 1, tetrahedral[i]);\n\t\t}\n\t\twhile(tetrahedral[pos] % 2 == 0)\n\t\t{\n\t\t\t--pos;\n\t\t}\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tif(tetrahedral[i] % 2)\n\t\t\t{\n\t\t\t\tDFS2(i, 1, tetrahedral[i]);\n\t\t\t}\n\t\t}\n\t\tcout << min_depth << \" \" << min_odd_depth << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\n#define MAX 1000000\n\nVI triangular, tetrahedral;\nmap<PII, int> memo;\n\n// recurse with memo: O(N * lgN)\nint solve(int n, bool odd)\n{\n\tif (n == 0) {\n\t\treturn 0;\n\t}\n\tif (EXIST(memo, MP(n, odd))) {\n\t\treturn memo[MP(n, odd)];\n\t}\n\tVI::iterator it = upper_bound(ALL(tetrahedral), n) - 1; // lower than or equal to n\n\tint ans = INF;\n\twhile (it >= tetrahedral.begin()) {\n\t\tif (!odd || *it % 2) {\n\t\t\tans = min(ans, 1 + solve(n - *it, odd));\n\t\t}\n\t\t--it;\n\t}\n\treturn memo[MP(n, odd)] = ans;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\n\tint tmp = 0;\n\tFOR (i, 1, MAX) {\n\t\tIFB(tmp > MAX);\n\t\ttriangular.PB(tmp += i);\n\t}\n\ttmp = 0;\n\tEACH (triangular, it) {\n\t\tIFB(tmp > MAX)\n\t\ttetrahedral.PB(tmp += *it);\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << solve(n, false) << ' ' << solve(n, true) << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e10\n#define EPS 1e-10\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nconst int N = 1000000;\n\nint a[N], b[N];\n\nvoid gen() {\n  memset(a, 37, sizeof(a));\n  memset(b, 37, sizeof(b));\n  a[0] = b[0] = 0;\n\n  for (int i = 1, d = 1; d < N; ++i, d += i * (i + 1) / 2) {\n    for (int j = d; j < N; ++j) {\n      a[j] = min(a[j], a[j - d] + 1);\n      if (d & 1)\n\tb[j] = min(b[j], b[j - d] + 1);\n    }\n  }\n}\n\nint main() {\n  gen();\n\n  int n;\n  while (cin >> n && n)\n    cout << a[n] << ' ' << b[n] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n/*sqrt<3>(NMAX)==100*/\n\nint Nkake[100+1];\nint c,maxc,max2c;\n\nvoid searchA(int c,int N){\n\tif(maxc<=c) return;\n\tif(N==0){\n\t\tif(maxc>c) maxc=c;\n\t\treturn;\n\t}\n\tfor(int i=100;;i--){\n\t\tif(N>=Nkake[i]){\n\t\t\tsearchA(c+1,N-Nkake[i]);\n\t\t}\n\t\tif(i<=1) return;\n\t\tif(maxc<=c) return;\n\t}\n}\n\nvoid searchB(int c,int N){\n\tif(max2c<=c) return;\n\tif(N==0){\n\t\tif(max2c>c) max2c=c;\n\t\treturn;\n\t}\n\tfor(int i=100;;i--){\n\t\tif(Nkake[i]%2==1&&N>=Nkake[i]){\n\t\t\tsearchB(c+1,N-Nkake[i]);\n\t\t}\n\t\tif(i<=1) return;\n\t\tif(max2c<=c) return;\n\t}\n}\n\nint main(){\n\n\tint N;\n\t\n\tfor(int i=1;i<=100;i++){\n\t\tNkake[i]=i*(i+1)*(i+2)/6;\n\t}\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tint g=N;\n\t\tint c=0;\n\t\tmaxc=10000000;\n\t\tmax2c=10000000;\n\t\tsearchA(0,N);\n\t\tsearchB(0,N);\n\t\tcout<<maxc<<\" \"<<max2c<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n    vector<int> dp(1000001, 1e9);\n    vector<int> dpo(1000001, 1e9);\n\n    dp[0] = dpo[0] = 0;\n    for (int i = 1; i <= 200; i++)\n    {\n        int l = i * (i + 1) * (i + 2) / 6;\n        for (int j = 0; j+l <= 1000000; j++)\n        {\n            dp[j+l] = min(dp[j+l], dp[j] + 1);\n        }\n        if(l % 2 == 1){\n            for (int j = 0; j+l <= 1000000; j++)\n            {\n                dpo[j+l] = min(dpo[j+l], dpo[j] + 1);\n            }\n        }\n    }\n\n    int n;\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        cout << dp[n] << \" \" << dpo[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nconst int tetra_size = 200;\nint tetra[tetra_size];\nint tri[tetra_size];\nvoid settetra(){\n\ttetra[0] = 0;\n\ttri[0] = 0;\n\tfor(int i = 1; i < tetra_size; i++){\n\t\ttri[i] = tri[i-1] + i;\n\t\ttetra[i] = tetra[i-1] + tri[i];\n\t}\n}\n\nint dp[100001];\nint dpodd[100001];\nvoid setdp(){\n\tfill(dp, dp+100001, INF);\n\tdp[0] = 0;\n\tfill(dpodd, dpodd+100001, INF);\n\tdpodd[0] = 0;\n\tfor(int i = 1; i < tetra_size; i++){\n\t\tfor(int j = 0; j + tetra[i] < 100001; j++ ){\n\t\t\tif(dp[j] == INF) continue;\n\t\t\tdp[j+tetra[i]] = min(dp[j]+1, dp[j+tetra[i]]);\n\t\t\tif(tetra[i]%2 == 1) dpodd[j+tetra[i]] = min(dpodd[j]+1, dpodd[j+tetra[i]]);\n\t\t}\n\t}\n}\n\nint main(){\n\tsettetra();\n\tsetdp();\n\tint n;\n\twhile(cin >> n){\n\t\tcout << dp[n] << ' ' <<  dpodd[n]  << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<cmath>\n#include<bitset>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<utility>\nusing namespace std;\nint main(){\n  int INF=(1<<29),n,i,j,dp[1000010],dp1[1000010];\n  vector<int> a,b;\n  i=0;\n  while(1){\n    a.push_back((i+1)*(i+2)*(i+3)/6);\n    if(a[i]%2==1){\n      b.push_back(a[i]);\n    }\n    if(a[i]>1000000){\n      break;\n    }\n    i++;\n  }\n  for(i=0;i<=1000000;i++){\n    dp[i]=INF;\n    dp1[i]=INF;\n  }\n  dp[0]=0,dp1[0]=0;\n  for(i=0;i<a.size();i++){\n    for(j=0;j<=1000000;j++){\n      if(j-a[i]>=0){\n        dp[j]=min(dp[j],dp[j-a[i]]+1);\n      }\n    }\n  }\n  for(i=0;i<b.size();i++){\n    for(j=0;j<=1000000;j++){\n      if(j-b[i]>=0){\n        dp1[j]=min(dp1[j],dp1[j-b[i]]+1);\n      }\n    }\n  }\n  while(1){\n    scanf(\"%d\\n\",&n);\n    if(n==0){\n      break;\n    }\n    printf(\"%d %d\\n\",dp[n],dp1[n]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int SIZE = 300;\nconst int N = 1000002;\nint p[SIZE+1];\nint dp1[N], dp2[N];\n\nvoid make_pollock (void )\n{\n\tmemset (p, 0, sizeof (p ) );\n\n\tfor (int i = 0; i <= SIZE; i++ )\n\t\tp[i] = i*(i+1LL)*(i+2LL)/6LL;\n}\n\nvoid make_dp (void )\n{\n\tfill (dp1, dp1+N, INF );\n\tfill (dp2, dp2+N, INF );\n\n\tdp1[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp1[j] = min (dp1[j], dp1[j-m]+1 );\n\t} // end for\n\n\tdp2[0] = 0;\n\tfor (int i = 1; i <= SIZE; i++ ){\n\t\tif (p[i] % 2 == 0 ) continue;\n\t\tint m = p[i];\n\t\tfor (int j = m; j <= N; j++ )\n\t\t\tdp2[j] = min (dp2[j], dp2[j-m]+1 );\n\t} // end for\t\n}\n\t\nint main()\n{\n\tmake_pollock();\n\tmake_dp ();\n\n\tint n;\n\twhile (cin >> n, n )\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int M = 179,R = 1000001;\nint dp1[R],dp2[R],T[M];\n\nvoid solve(void) {\n    for (int i = 1; i < R; i++) dp1[i] = dp2[i] = R;\n    for (int i = 1; i <= M+1; i++) T[i-1] = i*(i+1)*(i+2)/6;\n    for (int i = 0; i < M; i++) {\n        int t = T[i];\n        for (int j = t; j < R; j++) {\n            if (dp1[j-t] < R) dp1[j] = min(dp1[j], dp1[j-t]+1);\n            if (t%2 == 0) continue;\n            if (dp2[j-t] < R) dp2[j] = min(dp2[j], dp2[j-t]+1);\n        }\n    }\n}\n\nint main(void){\n    solve();\n    while (1) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        printf(\"%d %d\\n\",dp1[N],dp2[N]);\n    }\n    return 0;    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define N_MAX 1000000\n\nint main(){\n  vl tetra;\n  ll i = 1;\n  while(i*(i+1)*(i+2)/6 < N_MAX){\n    tetra.push_back( i*(i+1)*(i+2)/6 );\n    ++i;\n  }\n  vl alldp(N_MAX,1e18);\n  alldp[0] = 0;\n  REP(x,tetra.size()){\n    ll tt = tetra[x];\n    ll t = 1;\n    ll b = tt*t;\n    while(b<N_MAX){\n      REP(_a,N_MAX){\n        ll a = N_MAX-1-_a;\n        if(a+b>=N_MAX)continue;\n        alldp[a+b] = min(alldp[a+b],alldp[a]+t);\n      }\n      t<<=1;\n      b = tt*t;\n    }\n  }\n  vl odddp(N_MAX,1e18);\n  odddp[0] = 0;\n  REP(x,tetra.size()){\n    ll tt = tetra[x];\n    if(tt%2==0)continue;\n    ll t = 1;\n    ll b = tt*t;\n    while(b<N_MAX){\n      REP(_a,N_MAX){\n        ll a = N_MAX-1-_a;\n        if(a+b>N_MAX)continue;\n        odddp[a+b] = min(odddp[a+b],odddp[a]+t);\n      }\n      t<<=1;\n      b = tt*t;\n    }\n  }\n  while(true){\n    ll n;\n    cin>>n;\n    if(n==0)break;\n    cout << alldp[n] << \" \" << odddp[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<long long> poloc;\n    vector<long long> odd_poloc;\n    for (long long i = 1; i * (i + 1) * (i + 2) / 6LL <= 1000000LL; ++i) {\n        long long pl = i * (i + 1) * (i + 2) / 6LL;\n        poloc.push_back(pl);\n        if (pl % 2) odd_poloc.push_back(pl);\n    }\n\n    vector<int> dp(1000000LL + 100, INT_MAX);\n    vector<int> odd_dp(1000000LL + 100, INT_MAX);\n    dp[0] = odd_dp[0] = 0;\n    for (int i = 0; i <= 1000000LL; ++i) {\n        if (dp[i] != INT_MAX) {\n            for (long long pl : poloc) {\n                if (i + pl > 1000000LL) break;\n                dp[i + pl] = min(dp[i + pl], dp[i] + 1);\n            }\n        }\n        if (odd_dp[i] != INT_MAX) {\n            for (long long pl : odd_poloc) {\n                if (i + pl > 1000000LL) break;\n                odd_dp[i + pl] = min(odd_dp[i + pl], odd_dp[i] + 1);\n            }\n        }\n    }\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        cout << dp[n] << \" \" << odd_dp[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nint dp[1000001];\nint dp2[1000001];\n\nint func(int v){\n\tif(dp[v]!=11451419)return dp[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n\t\tif(v-i*(i+1)*(i+2)/6>=0)cnt=min(cnt,func(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp[v]=cnt+1);\n}\n\nint func2(int v){\n\tif(dp2[v]!=11451419)return dp2[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n\t\tif(i*(i+1)*(i+2)/6%2!=1)continue;\n\t\tif(v-i*(i+1)*(i+2)/6>=0)cnt=min(cnt,func2(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn dp2[v]=cnt+1;\n}\n\nint main(void){\n\tint n;\n\tfor(int i=1;i<=1000000;i++)dp[i]=dp2[i]=11451419;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",func(n),func2(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1000100;\nconst int INF = 1 << 29;\n\nint main()\n{\n    vector<int> dp(MAX, INF), odddp(MAX, INF);\n    dp[0] = odddp[0] = 0;\n    for (int i = 1;; ++i)\n    {\n        int num = i * (i + 1) * (i + 2) / 6;\n        if (num >= MAX)\n            break;\n        for (int j = num; j < MAX; ++j)\n        {\n            dp[j] = min(dp[j], dp[j - num] + 1);\n            if (num & 1)\n                odddp[j] = min(odddp[j], odddp[j - num] + 1);\n        }\n    }\n    int n;\n    while (cin >> n)\n    {\n        if (n == 0)\n            break;\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SET(a,c) memset(a,c,sizeof(a))\n#define PB push_back\nusing namespace std;\n\nconst int MAX_N = 1e6;\nconst int INF = 0x3f3f3f3f;\n\nvoid solve(int n)\n{\n\tvector<int> m;\n\tint dp[MAX_N], dp_odd[MAX_N];\n\tSET(dp, INF);\n\tSET(dp_odd, INF);\n\t\n\tREP(i, MAX_N) {\n\t\tm.PB( (i+1)*(i+2)*(i+3)/6 );\n\t\tif (m.back() > n) break;\n\t}\n\n\tdp[0] = 0;\n\tdp_odd[0] = 0;\n\tREP(i, m.size()) {\n\t\tREP(j, n + 1) {\n\t\t\tif (j < m[i]) continue;\n\t\t\tdp[j] = min(dp[j], dp[j - m[i]] + 1);\n\t\t\tif (m[i] % 2) dp_odd[j] = min(dp_odd[j], dp_odd[j - m[i]] + 1);\n\t\t}\n\t}\t\n\tprintf(\"%d %d\\n\", dp[n], dp_odd[n]);\n}\n\nint main()\n{\n\tint n;\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (!n) break;\n\t\tsolve(n);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0;i<(ll)n; ++i)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nint main() {\n\t//freopen(\"Text.txt\", \"r\", stdin);\n\t\n\tll size = 0;\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i]) {\n\t\t\ti++;\n\t\t\ttable[i] = i*(i + 1)*(i + 2) / 6;\n\t\t}\n\t\tsize = i;\n\t}\n\n\t{\n\t\tpollock[0] = 0;\n\t\tll current_i = 0;\n\t\tREP(i, 1000001) {\n\t\t\tif (i == 0) continue;\n\t\t\tif (table[current_i + 1] == i) {\n\t\t\t\tpollock[i] = 1; current_i++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tll minimum = 1000001;\n\t\t\tfor (ll j = 1; j <= current_i; j += 1) {\n\t\t\t\tminimum = min(pollock[i - table[j]] + 1, minimum);\n\t\t\t}\n\t\t\tpollock[i] = minimum;\n\t\t}\n\t}\n\n\t{\n\t\tdp[0] = 0;\n\t\tll current_i = -3;\n\t\tREP(i, 1000001) {\n\t\t\tif (i == 0) continue;\n\t\t\tif (table[current_i + 4] == i) {\n\t\t\t\tcurrent_i += 4; dp[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tll minimum = 1000001;\n\t\t\tfor(ll j=1; j<=current_i; j+=4) {\n\t\t\t\tminimum = min(dp[i - table[j]]+1, minimum);\n\t\t\t}\n\t\t\tdp[i] = minimum;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout <<\"DEBUG\"<<\" \"<< #x << \":\" << x << '\\n'\n\n// n回繰り返し\n#define rep(i,n) for(int i = 0; i < ((int)(n)); i++)   // 0-indexed昇順\n#define rep1(i,n) for(int i = 1; i <= ((int)(n)); i++) // 1-indexed昇順\n#define rrep(i,n) for(int i = ((int)(n)-1); i >= 0; i--)  // 0-indexed降順\n#define rrep1(i,n) for(int i = ((int)(n)); i >= 1; i--)   // 1-indexed降順\n#define all(x) (x).begin(),(x).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;  // 2次元配列\ntypedef vector<ll> vll;\ntypedef vector<double> vd;\ntypedef pair<int, int> PII;\n\ntemplate<typename T>\nusing vec = vector<T>;\ntemplate<class T>\nusing maxheap = std::priority_queue<T>;\ntemplate<class T>\nusing minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<class T,class U> inline bool chmax(T &a, const U &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T,class U> inline bool chmin(T &a, const U &b){if(a>b){a=b;return 1;}return 0;}\n\nconst ld Pi = std::acos(-1.0L);\nconst ll infll = (1LL<<62)-1;\nconst int inf = (1<<30)-1;\nconst int mod = 1000000007;\n// const int mod = 998244353;\n\nvi tetra;\nvi tetra_odd;\n/*FUNCs=================================================*/\n\n\n/*MAIN==================================================*/\nsigned main(){\n    int _StartTime_ = clock();\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);   //cin cout 高速化\n//    cout << fixed << setprecision(15);\n\n//    construct\n    int p;\n    for(int i = 1; ; ++i) {\n        p = i*(i+1)*(i+2)/6;\n        if(p > 1e6) break;\n        tetra.push_back(p);\n        if(p%2==1) tetra_odd.push_back(p);\n    }\n//    cout << tetra.size() << '\\n';\n\n    vi dp(1e6 + 1, inf);  // dp[i] : iを表現するために必要な正四面体数の最小個数\n    vi dp_odd(1e6 + 1, inf);\n    dp[0] = 0;\n    dp_odd[0] = 0;\n\n    for(int i = 0; i <= 1e6; ++i) {\n        for(int j = 0; j < tetra.size(); ++j) {\n            if(i+tetra[j]<=1e6) chmin(dp[i+tetra[j]], dp[i] + 1);\n        }\n    }\n    for(int i = 0; i <= 1e6; ++i) {\n        for(int j = 0; j < tetra_odd.size(); ++j) {\n            if(i+tetra_odd[j]<=1e6) chmin(dp_odd[i+tetra_odd[j]], dp_odd[i] + 1);\n        }\n    }\n\n//    solve\n    int n;\n    while(cin >> n) {\n        if(n==0) break;\n        cout << dp[n] << ' ' << dp_odd[n] << '\\n';\n    }\n//    printf(\"ExcutionTime: %d /ms\\n\",1000*(int)((clock()-_StartTime_)/CLOCKS_PER_SEC));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst int MX=1000000;\n\nint tri[1000],ntri;\nint dp[MX],dpOdd[MX];\n\nint main(){\n\t\n\tntri=0;\n\tfor(;;ntri++)\n\t{\n\t\ttri[ntri]=ntri*(ntri+1)*(ntri+2)/6;\n\t\tif(tri[ntri]>=MX)break;\n\t}\n\t\n\trep(i,MX)dp[i]=dpOdd[i]=inf;\n\tdp[0]=dpOdd[0]=0;\n\tint mx=0;\n\trep(i,5)rep(j,mx+1)\n\t{\n\t\trep(k,ntri)\n\t\t{\n\t\t\tif(j+tri[k]>=MX)break;\n\t\t\tif(tri[k]%2==1)dpOdd[j+tri[k]]=min(dpOdd[j+tri[k]],dpOdd[j]+1);\n\t\t\tdp[j+tri[k]]=min(dp[j+tri[k]],dp[j]+1);\n\t\t\tmx=max(mx,j+tri[k]);\n\t\t\tmx=min(mx,MX-1);\n\t\t}\n\t}\n\t\n\tint n;\n\twhile(cin>>n,n)cout<<dp[n]<<\" \"<<dpOdd[n]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define rep(i, a, n) for(int i = (int)(a);(i) < (int)(n);++(i))\n#define repe(i, a, n) for(int i = (int)(a);(i) <= (int)(n);++(i))\n#define repif(i, a, x) for(int i = (int)(a);(x);++(i))\n#define repr(i, a, n) for(int i = ((int)(a)-1);(i) >= (int)(n);--(i))\n#define reper(i, a, n) for(int i = (int)(a);(i) >= (int)(n);--(i))\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define CEIL(x) ((int)ceil(((double)x)))\n#define POW(x, y) ((int)pow(x, y))\n#define UNIQUE(x) (x).erase(unique(ALL((x))), end(x))\n#define gcd(x, y) __gcd(x, y)\n#define lcm(x, y) ((x)/gcd(x,y)*(y))\n#define isin(x, l, r) ((l) <= (x) and (x) < (r))\n#define fcout(n) cout << fixed << setprecision(n)\n#define rcout(n) cout << right << setw(n)\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define PI (acosl(-1))\n#define EPS (1e-10)\n#define INF LLONG_MAX\n#define INF32 INT32_MAX\n#define MOD 1000000007LL\nusing namespace std;\nusing VI = vector<int>;\nusing PII = pair<int, int>;\nusing TIII = tuple<int, int, int>;\nusing VPII = vector<PII>;\nusing VTIII = vector<TIII>;\nusing Complex = complex<double>;\ntemplate<typename T, template<typename> typename C = less> using PQ = priority_queue<T, vector<T>, C<T>>;\ntemplate<typename T> inline bool chmax(T& a, const T& b, bool t = false){ if(a<b or (t and a == b)){ a=b; return true; } return false; }\ntemplate<typename T> inline bool chmin(T& a, const T& b, bool t = false){ if(a>b or (t and a == b)){ a=b; return true; } return false; }\n\n\nint tetra[200];\nint dp[1000010];\nint dp2[1000010];\n\n\nsigned main(){\n    rep(i, 0, 200) tetra[i] = (i+1)*(i+2)*(i+3)/6;\n    fill(dp, dp+1000010, INF);\n    fill(dp2, dp2+1000010, INF);\n    dp[0] = dp2[0] = 0;\n    rep(i, 0, 1000010) rep(j, 0, 200){\n        if(i+tetra[j] > 1000010) break;\n        chmin(dp[i+tetra[j]], dp[i]+1);\n        if(tetra[j]%2 == 1) chmin(dp2[i+tetra[j]], dp2[i]+1);\n    }\n    int n;\n    while(cin >> n, n) cout << dp[n] << ' ' << dp2[n] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\nint main(){\n  int n,cpn,data[N],i,cnt,minv,cal,l;\n  for(i=1;i<=N;i++) data[i]=(i*(i+1)*(i+2))/6;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    cnt=n;\n    cpn=n;\n    minv=INFINITY;\n    l=0;\n    while(cnt){\n      n=cpn;\n      cal=0;\n      for(i=n-l;i>=1;i--){\n\tcal+=n/data[i];\n\tn%=data[i];\n      }\n      minv=min(minv,cal);\n      cnt--;\n      l++;\n    }\n    cout << minv;\n    n=cpn;\n    cnt=n;\n    minv=INFINITY;\n    l=0;\n    while(cnt){\n      n=cpn;\n      cal=0;\n      for(i=n-l;i>=1;i--){\n\tif(data[i]%2==1){\n\t  cal+=n/data[i];\n\t  n%=data[i];\n\t}\n      }\n      minv=min(minv,cal);\n      cnt--;\n      l++;\n    }\n    cout << ' ' << minv << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp1[1000001];\nint dp2[1000001];\n\nint main() {\n\tint N = 1000000;\n\n\tvector<int> v1,v2;\n\tint n = 1;\n\twhile(n*(n+1)*(n+2)/6<=N) {\n\t\tint p = n*(n+1)*(n+2) / 6;\n\t\tv1.push_back(p);\n\t\tif(p%2==1)\n\t\t\tv2.push_back(p);\n\t\tn++;\n\t}\n\n\tfor(int i = 0;i < N+1;i++) {\n\t\tdp1[i] = i;\n\t\tdp2[i] = i;\n\t}\n\t//cout << v1.size() << \" \" << v2.size() << endl;\n\tfor(auto v : v1) {\n\t\tfor(int j = v;j < N + 1;j++) {\n\t\t\tdp1[j] = min(dp1[j],dp1[j - v] + 1);\n\t\t}\n\t}\n\tfor(auto v : v2) {\n\t\tfor(int j = v;j < N + 1;j++) {\n\t\t\tdp2[j] = min(dp2[j],dp2[j - v] + 1);\n\t\t}\n\t}\n\n\twhile(true) {\n\t\tint m;\n\t\tcin >> m;\n\t\tif(m == 0)\n\t\t\tbreak;\n\t\tcout << dp1[m] << \" \" << dp2[m] << endl;\n\t}\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long L;\n#define mx 1000001\nL n,dp1[mx],dp2[mx],data[205];\nvoid init(){\n    for(L i=0;i<=200;i++){\n        data[i]=(i*(i+1)*(i+2))/6;\n    }\n    dp1[0]=dp2[0]=0;\n    for(L i=1;i<mx;i++){\n        dp1[i]=dp2[i]=i;\n        for(L j=0;i-data[j]>=0;j++){\n            dp1[i]=min(dp1[i],dp1[i-data[j]]+1);\n            if(data[j]%2==1){\n                dp2[i]=min(dp2[i],dp2[i-data[j]]+1);\n            }\n        }\n    }\n}\nint main()\n{\n    init();\n    while(scanf(\"%lld\",&n)&&n){\n        printf(\"%lld %lld\\n\",dp1[n],dp2[n]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 1000000;\nconst int INF = 1000000000;\n\nint dp_nat[MAX_N]; // dp_nat[i]: 数字iを作るための最小の正四面体の個数\nint dp_odd[MAX_N]; // dp_odd[i]: 数字iを作るための最小の奇数の正四面体の個数\n\nint tetras[10000]; // tetras[i]: i番目の正四面体数(添え字は1から始まる)\nint num_tetras = 0;\n\nint main() {\n  // 正四面体数を事前に計算しておく\n  for(int i = 1; 1; i++) {\n    int m = i*(i+1)*(i+2)/6;\n    if (m > MAX_N) break;\n    num_tetras++; // 配列は1始まりなので先にインクリメント\n    tetras[num_tetras] = m;\n  }\n\n  // 入力のnによらずdp_natとdp_oddの中身は同じになるので、入力を読む前に計算しておく\n\n  // 全ての正四面体数を使ったパターン\n  dp_nat[0] = 0;\n  for (int i = 1; i < MAX_N; i++) {\n    dp_nat[i] = INF;\n    for (int j = 1; j <= num_tetras; j++) {\n//    cout << \"dbg\" << i << \",\" << dp_nat[i] << endl;\n      if (i - tetras[j] < 0) break;\n      dp_nat[i] = min(dp_nat[i], dp_nat[i - tetras[j]] + 1);\n    }\n  }\n\n  // 奇数のみのパターン\n  dp_odd[0] = 0;\n  for (int i = 1; i < MAX_N; i++) {\n    dp_odd[i] = INF;\n    for (int j = 1; j <= num_tetras; j++) {\n      if (i - tetras[j] < 0) break;\n      if (tetras[j] % 2 != 0)\n        dp_odd[i] = min(dp_odd[i], dp_odd[i - tetras[j]] + 1);\n    }\n  }\n\n  int n;\n  while(cin >> n, n != 0) {\n    cout << dp_nat[n] << \" \" << dp_odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<unsigned int> triq,subtriq;\n\nvoid addtriq(unsigned int max){\n\twhile(triq.back()<max){\n\t\ttriq.push_back((triq.size()+1)*(triq.size()+2)*(triq.size()+3)/6);\n\t\tif(triq.back()%2==1)subtriq.push_back(triq.back());\n\t}\n\treturn;\n}\n\nvoid calc(unsigned int cur,vector<unsigned int> list,unsigned int& cmin,unsigned int cstp){\n\tif(cstp>=cmin)return;\n\tfor(vector<unsigned int>::reverse_iterator ri=list.rbegin();ri!=list.rend();++ri){\n\t\tint d=cur-(*ri);\n\t\tif(d==0){\n\t\t\tcmin=cstp;\n\t\t\tbreak;\n\t\t}\n\t\tif(d>0){\n\t\t\tcalc(d,list,cmin,cstp+1);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\ttriq.push_back(1);\n\tsubtriq.push_back(1);\n\twhile(true){\n\t\tunsigned int n,cmin;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\taddtriq(n);\n\t\tcmin=-1;\n\t\tcalc(n,triq,cmin,1);\n\t\tcout<<cmin<<' ';\n\t\tcmin=-1;\n\t\tcalc(n,subtriq,cmin,1);\n\t\tcout<<cmin<<endl;\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_NUM = 1000000;\nconst int INF = 100000000;\n\nint table[2][MAX_NUM];\nint tet[2][1000];\n\nint solve(int num,int m)\n{\n    if(table[m][num]==INF) {\n        for(int i=1; tet[m][i]<num; i++) {\n            table[m][num]=min(table[m][num],solve(num-tet[m][i],m)+1);\n        }\n    }\n    return table[m][num];\n}\n\nint main()\n{\n    for(int i=0; i<MAX_NUM; i++) {\n        table[0][i] = INF;\n        table[1][i] = INF;\n    }\n\n    for(int i=1; i*(i+1)*(i+2)/6<MAX_NUM; i++) {\n        int t=i*(i+1)*(i+2)/6;\n        table[0][t] = 1;\n        tet[0][i] = t;\n\n        if(t%2 == 1) {\n            table[1][t] = 1;\n            tet[1][i] = t;\n        }\n    }\n\n    int in;\n    while(cin>>in && in) {\n        cout<<solve(in,0)<<\" \"<<solve(in,1)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint pollock[201];\nint dp1[1000001] = { 0 };\nint dp2[1000001] = { 0 };\n\nvoid dp() {\n\tfor (int i = 1; i <= 200; i++) {\n\t\tpollock[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tdp1[i] = i;\n\t\tdp2[i] = i;\n\t}\n\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\tif (pollock[j] > i) break;\n\t\t\tif (dp1[i - pollock[j]] + 1 < dp1[i]) dp1[i] = dp1[i - pollock[j]] + 1;\n\t\t\tif (pollock[j] % 2 == 1) {\n\t\t\t\tif (dp2[i - pollock[j]] + 1 < dp2[i]) dp2[i] = dp2[i - pollock[j]] + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tdp();\n\tifstream fin(\"test.txt\");\n\tofstream fout(\"ans.txt\");\n\tint n;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 1000001\n\nint main(void){\n\tint i, j, n ,c, small1, small2;\n\tint dp1[1000000],dp2[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp1[i] = dp2[i] = INF;\n\t\tdp1[0] = dp2[0] = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tsmall1 = dp1[n];\n\t\t\tfor(j = i;j < n && dp1[j] >= small1;j++);\n\t\t\tif(j == n)\n\t\t\t\tbreak;\n\t\t\tif(j != i)\n\t\t\t\ti = j - 1;\n\t\t\tif(dp1[i] != INF){\n\t\t\t\tfor(j = 1,c = j * (j + 1) * (j + 2);c / 6 + i <= n;j++,c = j * (j + 1) * (j + 2)){\n\t\t\t\t\tif(dp1[c / 6 + i] > dp1[i] + 1 && dp1[i] != INF)\n\t\t\t\t\t\tdp1[c / 6 + i] = dp1[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tsmall2 = dp2[n];\n\t\t\tfor(j = i;j < n && dp2[j] >= small2;j++);\n\t\t\tif(j == n)\n\t\t\t\tbreak;\n\t\t\tif(j != i)\n\t\t\t\ti = j - 1;\n\t\t\tif(dp2[i] != INF){\n\t\t\t\tfor(j = 1,c = j * (j + 1) * (j + 2);c / 6 + i <= n;j++,c = j * (j + 1) * (j + 2)){\n\t\t\t\t\tif(dp2[c / 6 + i] > dp2[i] + 1 && (c / 6) % 2 == 1 && dp2[i] != INF)\n\t\t\t\t\t\tdp2[c / 6 + i] = dp2[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#define N 1000000\n\nusing namespace std;\n\nint main(){\n\tvector<int> sq;\n\tvector<int> sqodd;\n\tint a[N];\n\tint aodd[N];\n\tfor(int i = 1; i * (i + 1) * (i + 2) < N; i++)  sq.push_back((i * (i + 1) * (i + 2)) / 6);\n\tfor(int i = 1; i * (i + 1) * (i + 2) < N; i++){\n\t\tif(((i * (i + 1) * (i + 2)) / 6) % 2) sqodd.push_back((i * (i + 1) * (i + 2)) / 6);\n\t}\n\tfor(int i = 0; i < N; i++) a[i] = N;\n\tfor(int i = 0; i < N; i++) aodd[i] = N;\n\tfor(int i = 0; i < sq.size(); i++) a[sq[i]] = 1;\n\tfor(int i = 0; i < sqodd.size(); i++) aodd[sqodd[i]] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tif(a[i] == N) continue;\n\t\tfor(int j = 0; j < sq.size(); j++){\n\t\t\tif(sq[j] + i < N && a[sq[j] + i] > a[i] + 1) a[sq[j] + i] = a[i] + 1;\n\t\t}\n\t}\n\tfor(int i = 1; i < N; i++){\n\t\tif(aodd[i] == N) continue;\n\t\tfor(int j = 0; j < sqodd.size(); j++){\n\t\t\tif(sqodd[j] + i < N && aodd[sqodd[j] + i] > aodd[i] + 1) aodd[sqodd[j] + i] = aodd[i] + 1;\n\t\t}\n\t}\t\n\tint n;\n\twhile(cin >> n, n) cout << a[n] << \" \" << aodd[n] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    for(int i=1;i<=x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)\n\tbreak;\n      count++;\n      if(tmp%2==1)\n\tcount_ki++;\n    }\n\n    int coin[count];\n    int coin_ki[count_ki];\n    int tmp2=0;\n  \n    for(int i=1;i<count+1;i++){\n      coin[i-1]=i*(i+1)*(i+2)/6;\n      if(coin[i-1]%2==1)\n\tcoin_ki[tmp2++]=coin[i-1];\n    }\n  \n    //printf(\"%d\\n\",count_ki);\n\n    /*for(int i=0;i<count_ki;i++){\n      printf(\"coin[%d]=%d\\n\",i,coin_ki[i]);\n      }*/\n\n    int dp[x+1];\n    fill(dp,dp + x + 1,100000);\n  \n\n    /*for(int i=0;i<=x;i++)\n      printf(\"dp[%d]=%d\\n\",i,dp[i]);\n    */\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1],nxt,val,i,j,n;\n\nint main(){\n  for(i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  val = 1;\n  for(i=1;val<=N;i++){\n    for(j=0;j+val<=N;j++){\n      nxt = j+val;\n      dp[0][nxt] = min(dp[0][nxt],dp[0][j] + 1);\n      if(val&1)dp[1][nxt] = min(dp[1][nxt],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nvector<long long int> list,oddlist;\nint listcnt, oddlistcnt;\n\nint oddrec(int target, int sum, int cnt, int maxcnt) {\n    return 0;\n    int res=0xFFFF;\n    if(maxcnt<cnt) return 0xFFFE;\n    if(sum == target) return cnt;\n    for(int i=oddlistcnt-1; 0<=i; i--) {\n        if(sum+oddlist[i] > target) continue;\n        res = min(res, oddrec(target, sum+oddlist[i], cnt+1, maxcnt));\n        if(res==0xFFFE) break;\n    }\n    return res;\n}\n\nint mama(int x,int ress){\n    if(x==0) return ress;\n    int tmp[oddlistcnt];\n    memset(tmp,0,sizeof(tmp));\n    for(int i=0;i<oddlistcnt;i++){\n        tmp[i]=x/oddlist[i];\n        if(tmp[i]==0) {\n            ress+=tmp[i-1];\n//            cout << \"tmp[i-1]:\" << tmp[i-1] <<endl;\n//            cout << \"x%tmp[i-1]:\" << x%oddlist[i-1] <<endl;\n            return mama(x%oddlist[i-1],ress);\n            break;\n        }\n    }\n}\n\n\nint main(void) {\n    for(long long int i=1; i*(i+1)*(i+2)/6<1e6; i++) {\n        list.push_back(i*(i+1)*(i+2)/6);\n        if(i*(i+1)*(i+2)/6 % 2)\n            oddlist.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    listcnt = list.size();\n    oddlistcnt = oddlist.size();\n    while(true) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n\n        int res=5, oddres=1000;\n        for(int i=listcnt-1; 0<=i; i--) {\n            if(list[i]>n) continue;\n            if(list[i]==n){ res=1; break; }\n            if(res<=2) continue;\n            for(int j=listcnt-1; 0<=j; j--) {\n                if(list[i] + list[j]>n) continue;\n                if(list[i] + list[j]==n) res=2;\n                if(res<=3) continue;\n                for(int k=listcnt-1; 0<=k; k--) {\n                    if(list[i] + list[j] + list[k]>n) continue;\n                    if(list[i] + list[j] + list[k]==n) res=3;\n                    if(res<=4) continue;\n                    for(int l=listcnt-1; 0<=l; l--) {\n                        if(list[i] + list[j] + list[k] + list[l]>n) continue;\n                        if(list[i] + list[j] + list[k] + list[l]==n) res=4;\n                        if(res<=4) break;\n                    }\n                }\n            }\n        }\n\n        if((oddres=oddrec(n, 0, 0, 1))>=0xFFFE) {\n            for(int i=2; ; i=i*3/2) {\n                if((oddres=oddrec(n, 0, 0, i))<0xFFFE)\n                    break;\n            }\n        }\n\n\n        printf(\"%d %d\\n\",res,mama(n,0));\n    }\n\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[6] = {1, 0, -1, 0,1,1};\nconst int dy[6] = {0, 1, 0, -1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    ll cnt = 2;\n    ll sum = 1;\n    vector<ll> suzu;\n    suzu.push_back(1);\n    while(suzu.back() <= 1000000){\n        sum += cnt;\n        int now = suzu.back() + sum;\n        suzu.push_back(now);\n        cnt++;\n    }\n    reverse(suzu.begin(),suzu.end());\n    int N;\n    int M = suzu.size();\n    vector<ll> dp(1000100,inf);\n    vector<ll> dp_odd(1000100,inf);\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    for(int i=0; i<M; i++){\n        for(int j=0; j<=1000000; j++){\n            if(j+suzu[i]<=1000000){\n                chmin(dp[j+suzu[i]],dp[j]+1);\n                if(suzu[i]%2){\n                    chmin(dp_odd[j+suzu[i]],dp_odd[j]+1);\n                }\n            }\n        }\n    }\n    while(cin >> N){\n        if(N == 0) break;\n        cout << dp[N] << \" \" << dp_odd[N] << enld;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint dp[1000001],dp2[1000001];\n\nint main(void){\n\n  vector<int>p;\n\n  for(int i=1;i*(i+1)*(i+2)/6<1000001;i++){\n    p.push_back(i*(i+1)*(i+2)/6);\n  }\n\n  fill(dp,dp+1000001,10000000);\n  fill(dp2,dp2+1000001,10000000);\n  dp[0]=dp2[0]=0;\n\n  for(int i=0;i<1000001;i++){\n    for(int j=0;j<p.size();j++){\n      if(i-p[j]<0)break;\n      dp[i]=min(dp[i],dp[i-p[j]]+1);\n      if(p[j]%2==1)dp2[i]=min(dp2[i],dp2[i-p[j]]+1);\n    }\n  }\n\n  int n;\n  while(cin >> n,n){\n    cout << dp[n] <<\" \"<<dp2[n]<< endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#define INF 1e9\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int dp[1000010]={};\n  int dp2[1000010]={};\n  for(int i=1;i<=1000000;i++){dp[i]=INF;dp2[i]=INF;}\n  vector<ll> gu;\n  vector<ll> ki;\n  ll cnt=1;\n  while(1){\n    if((cnt*(cnt+1)*(cnt+2)/6)>1000000)break;\n    if(((cnt*(cnt+1)*(cnt+2))/6)%2){ki.pb(cnt*(cnt+1)*(cnt+2)/6);dp[ki[ki.size()-1]]=1;dp2[gu[su.size()-1]]=1;}\n    else {gu.pb(cnt*(cnt+1)*(cnt+2)/6);dp[gu[gu.size()-1]]=1;}\n    cnt++;\n  }\n  dp[1]=1;\n  dp2[1]=1;\n  for(int i=1;i<1000000;i++){\n    for(int j=0;j<gu.size();j++){\n      if(i+gu[j]>1000000)break;\n      dp[i+gu[j]]=min(dp[i+gu[j]],(dp[i]+1));\n    }\n    for(int j=0;j<ki.size();j++){\n      if(i+ki[j]>1000000)break;\n      dp[i+ki[j]]=min(dp[i+ki[j]],(dp[i]+1));\n      dp2[i+ki[j]]=min(dp2[i+ki[j]],(dp2[i]+1));\n    }\n  }\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct P{\n  int sum,k,n;\n  P(){}\n  P(int S,int K,int N){ sum=S;k=K;n=N; }\n};\n\nint a[200];\n\nint main(){\n  int n, ans1,ans2;\n  queue<P> q;\n  P p;\n\n\n  for( int i=1;i<200 ; i++ )\n    if( (a[i]=i*(i+1)*(i+2)/6)>1000000 )\n      break;\n\n  int size,n2;\n  while( cin>>n && n ){\n\n    ans1=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<200;i++ ){\n      if( a[i]==n ){\n\tans1=1; size=i+1;\n\tbreak;\n      }\n      if( a[i]<n ) q.push( P(a[i],i,1) );\n      else{\n\tsize=i; break;\n      }\n    }\n    while( !ans1 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      for( int i=p.k,j;i<size;i++ ){\n\tj=p.sum+a[i];\n\tif( j==n ){\n\t  ans1=n2; break;\n\t}\n\tq.push( P(j,i,n2) );\n      }\n    }\n\n    ans2=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<size;i++ ){\n      if( a[i]%2==1 ){\n\tif( a[i]==n ){ ans2=1; break; }\n\tq.push( P(a[i],i,1) );\n      }\n    }\n    while( !ans2 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      for( int i=p.k,j;i<size;i++ ){\n\tif( a[i]%2==1 ){\n\t  j=p.sum+a[i];\n\t  if( j==n ){\n\t    ans2=n2; break;\n\t  }\n\t  q.push( P(j,i,n2) );\n\t}\n      }\n    }\n    \n    cout << ans1 << \" \" << ans2 << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define _USE_MATH_DEFINES\n#include <math.h>\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define NIL = -1;\n\nll gcd(long long a,long long b) {\n    if (a < b) swap(a,b);\n    if (b == 0) return a;\n    \n    return gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n    a / gcd(a,b) * b;\n}\nconst ll mod = 1e9 + 7;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nconst ll INF = 1e9;\n/////////////////////////////////////////////////////////////////////////////////////////\nint dp[1000010];\nint odd_dp[1000010];\n\nint main(){\n    int n,table[183];\n\n    for (int i = 0;i < 183;i++) table[i] = i*(i+1)*(i+2)/6;\n\n    vector<int> num(1000010);\n    int cnt = 0,a;\n    while(true){\n        cin >> a;\n        num[cnt] = a;\n        cnt++;\n        if (a == 0) break;\n    }\n\n    for (int i = 0;i < 1000010;i++){\n        dp[i] = 20000000;\n        odd_dp[i] = 20000000;\n    }\n\n    dp[0] = 0;\n    dp[1] = 1;\n\n    odd_dp[0] = 0;\n    odd_dp[1] = 1;\n\n    for (int i = 2;i < 1000000;i++){\n        for (int k = 1;table[k] <= i;k++){\n            dp[i] = min(dp[i],dp[i-table[k]] + 1);\n            if (table[k] % 2 != 0){\n                odd_dp[i] = min(odd_dp[i],odd_dp[i-table[k]] + 1);\n            }\n        }\n    }\n\n    for (int i = 0;i < cnt - 1;i++){\n        cout << dp[num[i]] << \" \" << odd_dp[num[i]] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint List[100];\n\nvoid setpolloc(){\n\tint i,j,li;\n\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tList[i]=i*(i+1)*(i+2)/6;\n/*\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n*/}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint tr[300];\nint sq[300];\nint dp1[1000000];\nint dp2[1000000];\n\nint main() {\n\n  for(int i=1; i < 300; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  for(int i=1; i < 1000000; i++) {\n      dp1[i] = 1000111000;\n      dp2[i] = 1000111000;\n  }\n\n  for(int i=0; i<1000000; i++) {\n    for(int j=1; j < 300; j++) {\n      if(i+sq[j] < 1000000) {\n        dp1[i+sq[j]] = min(dp1[i] + 1, dp1[i+sq[j]]);\n        if(sq[j]%2 == 1) {\n          dp2[i+sq[j]] = min(dp2[i] + 1, dp2[i+sq[j]]);\n        }\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string.h>\n\nusing namespace std;\n\nint f[1000001];\n\nint main()\n{\n\tint t_num[182];\n\tint t_num_odd[182];\n\t\n\tint k=0;\n\tfor (int i=1;i<182;++i)\n\t{\n\t\tt_num[i-1] = i*(i+1)*(i+2)/6;\n\t\tif (t_num[i-1] % 2 == 1)\n\t\t{\n\t\t\tt_num_odd[k] = t_num[i-1];\n\t\t\t++k;\n\t\t}\t\t\n\t}\n\t\n\tint n;\n\tcin >> n;\n\t\n\twhile (n)\n\t{\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int j=0;j<181;++j)\n\t\t{\n\t\t\tfor (int i=t_num[j];i<=n;++i)\n\t\t\t{\n\t\t\t\tif (i>=t_num[j]) f[i] = min(f[i],f[i-t_num[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << \" \";\n\t\t\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int j=0;j<k;++j)\n\t\t{\n\t\t\tfor (int i=t_num_odd[j];i<=n;++i)\n\t\t\t{\n\t\t\t\tif (i>=t_num_odd[j]) f[i] = min(f[i],f[i-t_num_odd[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << endl;\n\t\t\n\t\tcin >> n;\n\t\t\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\nint tri[1900];\nint tetra[190];\n\nclass Node{\npublic:\n\tint deep;\n\tint sum;\n\tint num;\n\tNode(int d,int s,int n){\n\t\tdeep=d;\n\t\tsum=s;\n\t\tnum=n;\n\t}\n\tvoid print(){\n\t\tcout<<\"(\"<<deep<<\",\"<<sum<<\",\"<<num<<\")\"<<endl;\n\t}\n\tbool operator < (const Node &o) const{\n\t\treturn deep >o.deep;\n\t}\n};\ntypedef priority_queue <Node> PQ;\nint getTriNum(int n){\n//\tcout<<\"tri:\"<<n<<endl;\n\tif(n==1)return (tri[1]=1);\n\tif(tri[n]!=0)return tri[n];\n\treturn (tri[n]=getTriNum(n-1)+n);\n}\n\nint getTetraNum(int n){\n//\tcout<<\"tetra:\"<<n<<endl;\n\tif(n==1)return (tetra[1]=1);\n\tif(tetra[n]!=0)return tetra[n];\n\treturn (tetra[n]=getTetraNum(n-1)+getTriNum(n));\n}\nvoid print(){\n\tcout<<\"=============\"<<endl;\n\tfor(int i=1;i<10;i++){\n\t\tcout<<tri[i]<<endl;\n\t}\n\tcout<<\"-------------\"<<endl;\n\tfor(int i=1;i<10;i++){\n\t\tcout<<tetra[i]<<endl;\n\t}\n\tcout<<\"=============\"<<endl;\n}\nint dijkstra(int limit){\n\tPQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.top();\n\t\tpq.pop();\n\t//\tcur.print();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=190;i++){\n\t\t\tif(cur.sum+getTetraNum(i)>limit)break;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+getTetraNum(i),i));\n\t\t}\n\t}\n\treturn -1;\n}\nint dijkstra2(int limit){\n\tPQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.top();\n\t\tpq.pop();\n//\t\tcur.print();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=190;i++){\n\t\t\tif(cur.sum+getTetraNum(i)>limit)break;\n\t\t\tif(!(getTetraNum(i)%2))continue;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+getTetraNum(i),i));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint\nmain(){\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tint count;\n\t\tif((count=dijkstra(n))>0){\n\t\t\tcout<<count;\n\t\t}\n\t\tif((count=dijkstra2(n))>0){\n\t\t\tcout<<\" \"<<count<<endl;\n\t\t}\n\t}\n\n\t//\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167\n#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\nusing ll = long long;\nusing namespace std;\n\n#define MAX 1000000\nint const MOD = 1e9 + 7;\nvector<ll> full_set, odd_set;\nint dp1[MAX], dp2[MAX]; //最小数, 最小数(奇数のみ)\nint main(void)\n{\n    for (ll i = 1; i * (i + 1) * (i + 2) / 6 < MAX; ++i)\n    {\n        ll t = i * (i + 1) * (i + 2) / 6;\n        if (t % 2 == 1)\n        {\n            odd_set.push_back(t);\n        }\n        full_set.push_back(t);\n    }\n\n    for (int i = 0; i < MAX; ++i)\n    {\n        dp1[i] = 1e9;\n        dp2[i] = 1e9;\n    }\n    dp1[0] = 0;\n    dp2[0] = 0;\n    for (int i = 0; i < full_set.size(); ++i)\n    {\n        for (int j = 0; j < MAX; ++j)\n        {\n            if (j - full_set[i] >= 0)\n                dp1[j] = min(dp1[j], dp1[j - full_set[i]] + 1);\n        }\n    }\n\n    for (int i = 0; i < odd_set.size(); ++i)\n    {\n        for (int j = 0; j < MAX; ++j)\n        {\n            if (j - odd_set[i] >= 0)\n            {\n                dp2[j] = min(dp2[j], dp2[j - odd_set[i]] + 1);\n            }\n        }\n    }\n    ll n;\n    while (cin >> n, n)\n    {\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nll memo[250000];\nll memo2[250000];\n\nll calc(int n) {\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint dfs(int depth, int n) {\n  int ans = 9999;\n  if (n < 250000 && memo[n] != 0) return memo[n];\n  for (int i = n; i >= 1; i--) {\n    ll t = calc(i);\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < 250000) {\n\tmemo[n] = depth;\n      }\n      return depth;\n    }\n    ans = min(ans, dfs(depth + 1, n - t));\n  }\n  if (n < 250000)\n    memo[n] = ans;\n  return ans;\n}\n\nint dfs_odd(int depth, int n) {\n  int ans = 9999;\n  if (n < 250000 && memo2[n] != 0) return memo2[n];\n  for (int i = n; i >= 1; i--) {\n    if (i % 2 == 0) continue;\n    ll t = calc(i);\n    if (t % 2 == 0) continue;\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < 250000)\n\tmemo2[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs_odd(depth + 1, n - t));\n  }\n  if (n < 250000)\n    memo2[n] = ans;\n  return ans;\n}\n  \nint main() {\n  int N;\n  while (cin >> N, N != 0) {\n    for (int i = 0; i < 250000; i++) {\n      memo[i] = 0;\n      memo2[i] = 0;\n   }\n    cout << dfs(1, N) << \" \" << dfs_odd(1, N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1],nxt,val,n;\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      nxt = j+val;\n      dp[0][nxt] = min(dp[0][nxt],dp[0][j] + 1);\n      if(val&1)dp[1][nxt] = min(dp[1][nxt],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nvoid solve(int n)\n{\n  vector<int> v;\n  for(int i = 0; ; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    if(t <= MAX)\n      v.push_back(t);\n    else\n      break;\n  }\n  for(int i = 0; i <= n; i++){\n    for(int j = 0; j < v.size(); j++){\n      if(i + v[j] <= n){\n        if(v[j] & 1)\n          dp2[i + v[j]] = min(dp2[i + v[j]], dp2[i] + 1);\n        dp[i + v[j]] = min(dp[i + v[j]], dp[i] + 1);\n      }\n    }\n  }\n}\n    \nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <list>\n#include <stack>\n#include <queue>\n#define INF 1000000\nusing namespace std;\n\ntypedef list<int> L;\ntypedef pair <int,int> P;\ntypedef vector<int> V;\ntypedef queue<int> Q;\ntypedef stack<int> S;\ntypedef map<string,int> M;\n\nint N;\nint dp[1000001];\nint dp2[1000001];\nint tetra[1000];\n\nint main()\n{\n    for (int i = 0; i <= INF; i++) {dp[i] = INF;dp2[i] = INF;}\n    int n = 1;\n    int tmp;\n    while ((tmp = (n * (n + 1) * (n + 2) / 6)) <= 1000000) {\n        tetra[n++] = tmp;\n        dp[tmp] = 1;\n        if (tmp % 2) dp2[tmp] = 1;\n    }\n    int max = 1;\n    while (cin >> N, N) {\n        if (max > N) {\n            cout <<  dp[N] << \" \";\n        } else {\n            for (int i = max; i <= N; i++) {\n                for (int j = 1; tetra[j] <= i; j++) {\n                    dp[i] = min(dp[i], dp[i - tetra[j]] + 1);\n                }\n            }\n            cout << dp[N] << \" \";\n        }\n\n        if (max > N) {\n            cout << dp2[N] << endl;\n        } else {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; tetra[j] <= i; j++) {\n                    if (tetra[j] % 2)\n                        dp2[i] = min(dp2[i], dp2[i - tetra[j]] + 1);\n                }\n            }\n            cout << dp[N] << endl;\n            max = N;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\nusing ll = long long;\nusing ld = long double;\nusing intpair = pair<int, int>;\nconst int MOD = 1e9 + 7;\ninline int mod (ll a, int m = MOD) { return (a % m + m) % m; }\n//struct Fast {Fast(){cin.tie(0);ios::sync_with_stdio(0);}} fast;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define reps(i, n, m) for (int i = (int)(n); i <= (int)(m); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define rALL(obj) (obj).rbegin(), (obj).rend()\n#define ceiv(a, b) ((ll)((a) + (b) - 1)/(ll)(b))\n\nconst int INF = 2e9;\n\nbool chmin(int &a, int b){\n    if(a > b){a = b; return true;}\n    return false;\n}\n\ninline int tetrahedra(int n){\n    return n*(n+1)/2*(n+2)/3;\n}\n\nsigned main(){\n    vector<int> tetra_table, tetra_odd;\n    \n    for(int i = 1; tetrahedra(i) <= 1000000; i++){\n        int t = tetrahedra(i);\n        tetra_table.emplace_back(t);\n        if(t % 2){\n            tetra_odd.emplace_back(t);\n        }\n    }\n    \n    int dp[1000001], dp_odd[1000001];\n    \n    for(int &i : dp)     i = INF;\n    for(int &i : dp_odd) i = INF;\n    dp[0] = dp_odd[0] = 0;\n    \n    for(int i : tetra_table){\n        reps(j,i,1000000){\n            chmin(dp[j], dp[j-i] + 1);\n        }\n    }\n    \n    for(int i : tetra_odd){\n        reps(j,i,1000000){\n            chmin(dp_odd[j], dp_odd[j-i] + 1);\n        }\n    }\n    \n    while(true){\n        int n; cin >> n;\n        if(n == 0) break;\n        printf(\"%d %d\\n\", dp[n], dp_odd[n]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <math.h>\n#include <stdlib.h>\nusing namespace std;\nint main(){\n\tint *a=new int[1000000];\n\tint *b=new int[1000000];\n\tfor(int i=0;i<1000000;i++){\n\t\ta[i]=100000;\n\t\tb[i]=100000;\n\t}\n\tfor(int i=1;i<pow(6000000,0.333334)+5;i++){\n\t\tif((i*(i+1)*(i+2))/6<1000000){\n\t\t\tint aa=(i*(i+1)*(i+2))/6;\n\t\t\ta[aa]=1;\n\t\t}\n\t}\n\ta[0]=0;\n\ta[2]=2;\n\ta[3]=3;\n\tfor(int i=4;i<1000000;i++){\n\t\tif(a[i]==1){\n\t\t\tfor(int j=1;j<=5;j++){\n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\tif(j*i+k<1000000){\n\t\t\t\t\t\ta[j*i+k]=min(a[j*i+k],j+a[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<pow(6000000,0.333334)/4+5;i++){\n\t\tif(((4*i+1)*(4*i+2)*(4*i+3))/6<1000000){\n\t\t\tint bb=((4*i+1)*(4*i+2)*(4*i+3))/6;\n\t\t\tb[bb]=1;\n\t\t}\n\t}\n\tb[0]=0;\n\tfor(int i=2;i<35;i++){\n\t\tb[i]=i;\n\t}\n\tfor(int i=4;i<1000000;i++){\n\t\tif(b[i]==1){\n\t\t\tfor(int j=1;j<=20;j++){\n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\tif(j*i+k<1000000){\n\t\t\t\t\t\tb[j*i+k]=min(b[j*i+k],j+b[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0) break;\n\t\tcout<<a[n]<<\" \"<<b[n]<<endl;\n\t}\n    return 0;\n    delete[] a;\n    delete[] b;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int SIZE = 181 + 1;\nconst int MAX = 1000000;\n\nint T[SIZE];\nint cost1[MAX], cost2[MAX];\n\nint main( void )\n{\t\n\tfor(int i=0; i < SIZE; ++i) T[i] = i * (i + 1) * (i + 2) / 6;\n\n\tfor(int i=0; i < MAX; ++i) cost1[i] = cost2[i] = MAX << 1;\n\tcost1[0] = cost2[0] = 0;\n\tfor(int i=0; i < MAX; ++i) {\n\t\t\tfor(int j=0; j < SIZE; ++j) {\n\t\t\t\tif(i + T[j] < MAX && cost1[i] < 5)\n\t\t\t\t\tcost1[i + T[j]] = min(cost1[i + T[j]], cost1[i] + 1);\n\t\t\t\tif(T[j] & 1) {\n\t\t\t\t\tif(i + T[j] < MAX)\n\t\t\t\t\t\tcost2[i + T[j]] = min(cost2[i + T[j]], cost2[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n) {\n\t\tcout << cost1[n] << ' ' << cost2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvoid init(vector<int>* all, vector<int>* odd){\n  int x;\n  for(int i=1; ; ++i){\n    x = i*(i+1)*(i+2)/6;\n    if(x > 1000000) break;\n    all->push_back(x);\n    if(x%2 == 1) odd->push_back(x);\n  }\n  reverse(all->begin(), all->end());\n  reverse(odd->begin(), odd->end());\n}\n\nint search(int x, int& n, const vector<int>& data){\n  for(int i=x; i<data.size(); ++i){\n    if(data[i] <= n) return i;\n  }\n}\n\nint solve(int& n, const vector<int>& data){\n  int x = search(0, n, data);\n  int ans=n, ans_, y, m;\n  for(int i=x; i<data.size(); ++i){\n    y = i; ans_=0; m=n;\n    while(1){\n      y = search(y, m, data);\n      m -= data[y];\n      ++ans_;\n      if(m == 0 || ans < ans_) break;\n    }\n    ans = min(ans, ans_);\n  }\n  return ans;\n}\n\nint main(){\n  vector<int> all, odd;\n  init(&all, &odd);\n  int n;\n  while(1){\n    cin >> n;\n    if(!n) break;\n    cout << solve(n, all) << \" \" << solve(n, odd) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000005LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\nstatic const int N = 1000005;\n\nint n;\nll K;\nint dp[N],dpo[N];\nll pollock[N];\nll pmax;\nint cmax;\nint a;\n\nint pol()\n{\n\tscanf(\"%d\",&n);\n\tif(n==0)return -1;\n\tif(cmax>=n){\n\t\ta = dpo[n];\n\t\treturn dp[n];\n\t}\n\twhile(pollock[pmax]<=n){\n\t\tpmax++;\n\t\tpollock[pmax] = pmax*(pmax+1)*(pmax+2)/6;\n\t}\n\tint j=1,s=1,f=1;\n\tfor(int i=cmax+1;i<=n;i++){\n\t\twhile(pollock[j]<=i)j++;\n\t\tif(j<=2)dp[i]=dp[i-pollock[j-1]]+1;\n\t\telse dp[i] = min(dp[i-pollock[j-1]],dp[i-pollock[j-2]])+1;\n\n\n\t\tf = j-1;\n\t\twhile(pollock[f]%2==0)f--;\n\t\ts = f;\n\t\tif(f>2)s--;\n\t\twhile(pollock[s]%2==0)s--;\n\t\tdpo[i] = min(dpo[i-pollock[f]],dpo[i-pollock[s]])+1;\n\t}\n\tcmax=n;\n\ta = dpo[n];\n\treturn dp[n];\n}\nint main(){\n\tpmax=0;\n\tcmax=0;\n\tdp[0]=0;\n\tdpo[0]=0;\n\tpollock[0]=0;\n\twhile(1){\n\t\tint p = pol();\n\t\tif(p==-1)return 0;\n\t\tprintf(\"%d %d\\n\",p,a);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <list>\n#include <utility>\n#include <cmath>\nusing namespace std;\nvector<int> v;\nshort memo[1000000][100];\nint a;\nint dp(int now,int j)\n{\n\tif(now>a||j>5)return 9999999;\n\tif(now==a)return j;\n\tif(memo[now][j]!=-1)return memo[now][j];\n\tint ans =9999999;\n\tfor(int i=1;i<v.size();i++)\n\t{\n\t\tans=min(ans,dp(now+v[i],j+1));\n\t}\n\treturn memo[now][j]=ans;\n}\nint dp2(int now,int j)\n{\n\tif(now>a)return 9999999;\n\tif(now==a)return j;\n\tif(memo[now][j]!=-1)return memo[now][j];\n\tint ans =9999999;\n\tfor(int i=1;i<v.size();i+=2)\n\t{\n\t\tans=min(ans,dp2(now+v[i],j+1));\n\t}\n\treturn memo[now][j]=ans;\n}\nint main ()\n{\n\tv.push_back(0);\n\tfor(int i=1;i<1000;i++)\n\t{\n\t\tv.push_back(i*(i+1)*(i+2)/6);\n\t}\n\n\twhile(cin>>a&&a)\n\t{\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcout<<dp(0,0)<<\" \";\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tcout<<dp2(0,0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst int W = 1e6;\nsigned main() {\n\tvector<int>c(1, 0), odd(1, 0);\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 < W; i++) {\n\t\tc.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (c[i] & 1)odd.push_back(c[i]);\n\t}\n\tvector<int>v1(W, INF), v2(W, INF); v1[0] = v2[0] = 0;\n\trep(i, 1, c.size()) {\n\t\trep(j, c[i], W) {\n\t\t\tv1[j] = min(v1[j], v1[j - c[i]] + 1);\n\t\t}\n\t}\n\trep(i, 1, odd.size()) {\n\t\trep(j, odd[i], W) {\n\t\t\tv2[j] = min(v2[j], v2[j - odd[i]] + 1);\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << v1[n] << \" \" << v2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint a[1000001], b[1000001];\n\nint main(){\n\t\n\tfor(int i = 0; i <= 1000000; i++){\n\t\ta[i] = 1000000;\n\t\tb[i] = 1000000;\n\t}\n\t\n\ta[0] = 0;\n\tb[0] = 0;\n\t\n\tfor(int num = 1; num < 200; num++){\n\t\tint p = num * (num + 1) * (num + 2) / 6;\n\t\tif(p % 2 == 1){\n\t\t\tfor(int i = 0; i <= 1000000 - p; i++){\n\t\t\t\ta[i + p] = min(a[i + p], a[i] + 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i <= 1000000 - p; i++){\n\t\t\tb[i + p] = min(b[i + p], b[i] + 1);\n\t\t}\n\t}\n\t\n\tint N;\n\t\n\twhile(true){\n\t\tcin >> N;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\tcout << b[N] << \" \" << a[N] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<vector>\n#include<algorithm>\nint memo[1001][1001];\nlong long int mem1[100001];\n\tint n;\n\tint u;\t\n\tint w[1000], v[1000];\n\tint pol[200];\nint mm(int i, int u) {\n\tint max = 0;\n\tif (memo[i][u]!=-1) {\n\t\treturn memo[i][u];\n\t}\n\t\tif (u - w[i] > 0) {\n\t\t\tmax += std::max(mm(1+i, u - w[i]) + v[i] , mm(1+i, u) ); \n\t\t\n\t\t\t\n\t\t}\n\t\telse if(u-w[i]<0) max = mm(i + 1, u);\n\t\n\treturn\tmemo[i][u] = max;\n}\nint pollock(int i, int u) {\n\tint count = 0;\n\t\n\tif (u == 0) {\n\t\treturn 0;\n\t}\n\tif (u>=pol[i]) {\n\t\tif (u - pol[i] == pol[i]) {\n\t\t\treturn 2;\n\t\t}\n\t\telse count =1+ std::min(pollock(i + 1, u - pol[i]), pollock(i + 1, u));\n\t}\n\telse return 0;\n\treturn mem1[u - pol[i]] = count;\n}\nint main() {\n\tfor (int i = 0; i < 200; ++i) {\n\t\tint num = i + 1;\n\t\tpol[i] = num * (num + 1)*(num + 2) / 6;\n\t}\n\t\n\t/*for (int i = 0; i < 1001; ++i) {\n\t\tfor (int j = 0; j < 1001; ++j) {\n\t\t\tmemo[i][j] = -1;\n\t\t}\n\t}\n\tstd::cin >> n>>u;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstd::cin >> v[i] >> w[i];\n\t}\n\tstd::cout << mm(0, u) << std::endl;*/\n\t\n\twhile (std::cin >> n) {\n\tstd::cout << pollock(0, n) << std::endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1e9+7;\n\nll dp[100][1000010];\nll dp2[100][1000010];\nint main(void){\n    ll n,i,j;\n    while(cin >> n && n){\n        std::vector<ll> v,v2;\n        for(i=1;(i*(i+1)*(i+2)/6)<=n;i++){\n            v.push_back(i*(i+1)*(i+2)/6);\n            if((i*(i+1)*(i+2)/6)%2)v2.push_back(i*(i+1)*(i+2)/6);\n        }\n        ll vs = v.size();\n        \n        fill(dp[0],dp[0]+(vs+1)*(n+1),1000000);\n        //cout << dp[0][0] << endl;\n        dp[0][0]=0;\n        \n        for(i=1;i<=vs;i++){\n            for(j=0;j<=n;j++){\n                if(j-v[i-1]<0)dp[i][j]=dp[i-1][j];\n                else dp[i][j]=min(dp[i][j-v[i-1]]+1,dp[i-1][j]);\n            }\n        }\n        \n        ll ret1 = dp[vs][n];//直にやるほう\n        vs = v2.size();\n        fill(dp2[0],dp2[0]+(vs+1)*(n+1),1000000);\n        dp2[0][0]=0;\n        for(i=1;i<=vs;i++){\n            for(j=0;j<=n;j++){\n                if(j-v2[i-1]<0)dp2[i][j]=dp2[i-1][j];\n                else dp2[i][j]=min(dp2[i][j-v2[i-1]]+1,dp2[i-1][j]);\n            }\n        }\n        ll ret2 = dp2[vs][n];\n        cout << ret1 << \" \" << ret2 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1000000;\nconst int INF = (1 << 30);\n\nint main()\n{\n  vector<int> dp(MAX, INF), odddp(MAX, INF);\n  dp.at(0) = 0;\n  odddp.at(0) = 0;\n  for (int i = 1;; i++)\n  {\n    int num = (i * (i + 1) * (i + 2)) / 6;\n    if (num >= MAX)\n    {\n      break;\n    }\n    for (int j = num; j < MAX; j++)\n    {\n      dp.at(j) = min(dp.at(j), dp.at(j - num) + 1);\n      if (num & 1)\n      {\n        odddp.at(j) = min(odddp.at(j), odddp.at(j - num) + 1);\n      }\n    }\n  }\n  while (1)\n  {\n    int n;\n    cin >> n;\n    if (!n)\n    {\n      break;\n    }\n    cout << dp.at(n) << \" \" << odddp.at(n) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tvi dp(1000010,inf);\n\tvi dp2(1000010,inf);\n\tdp[0]=dp2[0]=0;\n\tloop(i,1,2000){\n\t\tint a=i*(i+1)*(i+2)/6;\n\t\tif(a>=1000010)break;\n\t\trep(j,1000010)if(j+a<1000010)dp[j+a]=min(dp[j+a],dp[j]+1);else break;\n\t\tif(a%2)rep(j,1000010)if(j+a<1000010)dp2[j+a]=min(dp2[j+a],dp2[j]+1);else break;\n\t}\n\tint n;\n\twhile(cin>>n,n)cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\nstd::vector<int>t,o;\nconst int N=100000,V=1<<15;\nint a[N],b[N];\nint main()\n{\n\tint i,j,n;\n\tfor(i=1;i<N;++i)a[i]=b[i]=V;\n\tfor(i=1;n=(i*(i+1)*(i+2))/6,n<N;++i)if(t.push_back(n),n&1)o.push_back(n);\n\tfor(i=0;i<t.size();++i)\n\t{\n\t\ta[t[i]]=1;\n\t\tfor(j=0;j+t[i]<N;++j)if(a[j]-V&&a[j]>5)break;else if(a[j]+1<a[j+t[i]])a[j+t[i]]=a[j]+1;\n\t}\n\tfor(i=0;i<o.size();++i)\n\t{\n\t\tb[o[i]]=1;\n\t\tfor(j=0;j+o[i]<N;++j)if(b[j]-V&&b[j]>37)break;else if(b[j]+1<b[j+o[i]])b[j+o[i]]=b[j]+1;\n\t}\n\twhile(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",a[n],b[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint z1[1000000] = { 0 };\nint z2[1000000] = { 0 };\n\nvoid pollock(int n) {\n\tfor (int i = 1; i*(i + 1)*(i + 2) / 6 <= n; i++) {\n\t\tz1[i*(i + 1)*(i + 2) / 6] = 1;\n\t\tif ((i*(i + 1)*(i + 2) / 6) % 2 == 1) z2[i*(i + 1)*(i + 2) / 6] = 1;\n\t}\n\n\tfor (int i = 2; i <= n; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif (z1[i] == 0 || (z1[i] != 0 && z1[j] + z1[i - j] < z1[i])) z1[i] = z1[j] + z1[i - j];\n\t\t\tif (z2[i] == 0 || (z2[i] != 0 && z2[j] + z2[i - j] < z2[i])) z2[i] = z2[j] + z2[i - j];\n\t\t}\n\t}\n\n\tcout << z1[n] << \" \" << z2[n] << endl;\n}\n\nint main() {\n\tpollock(103);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\n\ntypedef long long ll;\n\nconst int inf = 1e9;\nconst int maxN = 1000000;\nint dp[maxN+1];\n\nll f(ll n) {\n\treturn n * (n+1) * (n+2) / 6;\n}\n\nvector<int> makeS(int mod, int d) {\n\tvector<int> res;\n\tfor (int n = 1; f(n) <= maxN; ++n) {\n\t\tif ( f(n) % mod == d ) {\n\t\t\tres.push_back( f(n) );\n\t\t}\n\t}\n\treturn res;\n}\nint solve(const vector<int>& s) {\n\tfill(dp, dp+N+1, inf); dp[0] = 0;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tif (s[i] > N) break;\n\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\tint nj = j + s[i];\n\t\t\tif (nj <= N) {\n\t\t\t\tdp[nj] = min(dp[nj], dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[N];\n}\n\nint main() {\n\tvector<int> s0 = makeS(1, 0);\n\tvector<int> s1 = makeS(2, 1);\n\twhile (cin >> N, N) {\n\t\tcout << solve(s0) << \" \" << solve(s1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tmemset(dp, 0, sizeof(dp));\n\n\tint ans = 1;\n\n\tfor (int i=0; i<N && V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<6 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; k<N && j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; i<M && D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=MAX && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tdp[i%2][j] = 0;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; k<M && j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n    int N;\n    int tri[200];\n    static int ansA[1000000], ansB[1000000];\n    /* ??£?????¢?????°?¨???? */\n    for(int i=0;i<200;i++) tri[i] = i*(i+1)*(i+2)/6;\n    \n    /* ??????1,000,000?????§?????????????¨???????????????? */\n    ansA[0] = ansB[0] = 0;\n    for(int i=1;i<1000000;i++){\n        ansA[i] = ansB[i] = i;  /* ????????????i???????????? */\n        for(int j=1;i-tri[j]>=0;j++){\n            /* ???????¨?????????§???????????£?????¢????????°????????????????¢???????????????? */\n            ansA[i] = min(ansA[i], ansA[i-tri[j]]+1);\n            /* ?\\???°???????????´??? */\n            if(tri[j]%2==1)\n                ansB[i] = min(ansB[i], ansB[i-tri[j]]+1);\n        }\n    }\n    \n    /* input?????????????????????????????? */\n    while(cin >> N, N)\n        cout << ansA[N] << \" \" << ansB[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tvector<int> A, B;\n\tfor (int i = 1; ; i++) {\n\t\tint j = (i * (i + 1) * (i + 2)) / 6;\n\t\tif (j >= 1000000) break;\n\t\tA.push_back(j);\n\t\tif (j % 2 == 1) B.push_back(j);\n\t}\n\tvector<int> DPA(1000000, 1000000), DPB(1000000, 1000000);\n\tDPA[0] = 0, DPB[0] = 0;\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tint X = A[i], Y = 1;\n\t\twhile (1) {\n\t\t\tfor (int j = 0; j < 1000000; j++) {\n\t\t\t\tif (j + X < 1000000) {\n\t\t\t\t\tDPA[j + X] = min(DPA[j + X], DPA[j] + Y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX <<= 1, Y <<= 1;\n\t\t\tif (X >= 1000000) break;\n\t\t}\n\t}\n\tfor (int i = 0; i < B.size(); i++) {\n\t\tint X = B[i], Y = 1;\n\t\twhile (1) {\n\t\t\tfor (int j = 0; j < 1000000; j++) {\n\t\t\t\tif (j + X < 1000000) {\n\t\t\t\t\tDPB[j + X] = min(DPB[j + X], DPB[j] + Y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tX <<= 1, Y <<= 1;\n\t\t\tif (X >= 1000000) break;\n\t\t}\n\t}\n\tint N;\n\twhile (cin >> N) {\n\t\tif (N == 0) return 0;\n\t\tcout << DPA[N] << \" \" << DPB[N] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\nint tri[1500];\nint tetra[190];\n\nclass Node{\npublic:\n\tint deep;\n\tint sum;\n\tint num;\n\tNode(int d,int s,int n){\n\t\tdeep=d;\n\t\tsum=s;\n\t\tnum=n;\n\t}\n\tbool operator < (const Node &o) const{\n\t\treturn deep >o.deep;\n\t}\n};\ntypedef priority_queue <Node> PQ;\nint getTriNum(int n){\n\tif(tri[n]!=0)return tri[n];\n\treturn (tri[n]=getTriNum(n-1)+n);\n}\n\nint getTetraNum(int n){\n\tif(tetra[n]!=0)return tetra[n];\n\treturn (tetra[n]=getTetraNum(n-1)+getTriNum(n));\n}\nint dijkstra(int limit){\n\tPQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.top();\n\t\tpq.pop();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=182;i++){\n\t\t\tif(cur.sum+tetra[i]>limit)break;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+tetra[i],i));\n\t\t}\n\t}\n\treturn -1;\n}\nint dijkstra2(int limit){\n\tPQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.top();\n\t\tpq.pop();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=182;i++){\n\t\t\tif(cur.sum+tetra[i]>limit)break;\n\t\t\tif(!(tetra[i]%2))continue;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+tetra[i],i));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint\nmain(){\n\ttetra[1]=tri[1]=1;\n\tgetTetraNum(182);\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tint count;\n\t\tif((count=dijkstra(n))>0){\n\t\t\tcout<<count;\n\t\t}\n\t\tif((count=dijkstra2(n))>0){\n\t\t\tcout<<\" \"<<count<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX 1000000\nusing namespace std;\nvector<int> box,ans1(MAX+10),ans2(MAX+10);\nvoid tab_make(){\n\tfor(int i=1;i*(i+1)*(i+2)/6<=MAX;i++)\n\t\tbox.push_back(i*(i+1)*(i+2)/6);\n}\nvoid ans_make(){\n\tans1[0]=ans2[0]=0;\n\tfor(int i=1;i<=MAX;i++){\n\t\tans1[i]=ans2[i]=i;\n\t\tfor(int j=0;i-box[j]>=0;j++){\n\t\t\tans1[i]=min(ans1[i],ans1[i-box[j]]+1);\n\t\t\tif(box[j]%2==1)\n\t\t\tans2[i]=min(ans2[i],ans2[i-box[j]]+1);\n\t\t}\n\t}\n}\nint main(){\n\tint x;\n\ttab_make();\n\tans_make();\n\twhile(cin>>x,x){\n\t\tcout<<ans1[x]<<' '<<ans2[x]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1167\n#include<cstdio>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n\nconst int INF = 1<<30;\n\nstd::vector<int> tet;\nstd::vector<int> dp( 1000001, INF ), dpOdd( 1000001, INF );\n\nint main()\n{\n\tfor( int i = 1; i*(i+1)*(i+2)/6 <= 200000; ++i )\n\t\ttet.push_back( i*(i+1)*(i+2)/6 );\n\n\tdp[0] = dpOdd[0] = 0;\n\trep( i, 1000001 )\n\t{\n\t\trep( j, tet.size() )\n\t\t{\n\t\t\tif( i-tet[j] >= 0 )\n\t\t\t{\n\t\t\t\tdp[i] = std::min( dp[i], dp[i-tet[j]]+1 );\n\t\t\t\n\t\t\t\tif( tet[j]&1 )\n\t\t\t\t\tdpOdd[i] = std::min( dpOdd[i], dpOdd[i-tet[j]]+1 );\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\twhile( scanf( \"%d\", &n ), n )\n\t\tprintf( \"%d %d\\n\", dp[n], dpOdd[n] );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[1000001];\n\nint nums[200] = {0};\n\nint main(){\n\n    for(int i = 0;i < 200;i++) nums[i] = i * (i + 1) * (i + 2) / 6;\n\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        for(int j = 1;nums[j] <= n;j++) {\n            for(int i = nums[j];i <= n;i++) {\n                if(dp[i] > dp[i - nums[j]] + 1) dp[i] = dp[i - nums[j]] + 1;\n            }\n        }\n\n        cout << dp[n] << ' ';\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        for(int j = 1;nums[j] <= n;j++) {\n            if(nums[j] % 2 != 1) continue;\n            //cout << num << endl;\n            for(int i = nums[j];i <= n;i++) {\n                if(dp[i] > dp[i - nums[j]] + 1) dp[i] = dp[i - nums[j]] + 1;\n                //cout << dp[i] << ' ';\n            }\n            //cout << endl;\n        }\n\n        cout << dp[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\ntemplate<class T>\nclass Node\n{\n    private:\n        T n;\n        Node<T>* next_node;\n    public:\n        Node (T);\n        T get ();\n        Node<T>* next ();\n        void add (Node<T>*);\n        void remove ();\n};\n\ntemplate<class T>\nNode<T>::Node (T n)\n{\n    this.n = n;\n    this->next_node = NULL;\n}\n\ntemplate<class T>\nT Node<T>::get ()\n{\n    return this->n;\n}\n\ntemplate<class T>\nNode<T>* Node<T>::next ()\n{\n    return this->next_node;\n}\n\ntemplate<class T>\nvoid Node<T>::add (Node<T>* new_node)\n{\n    if (this->next_node != NULL)\n    {\n        new_node->add (this->next_node);\n        this->next_node = new_node;\n    }\n    else\n    {\n        this->next_node = new_node;\n    }\n}\n\ntemplate<class T>\nvoid Node<T>::remove ()\n{\n    if (this->next_node == NULL)\n    {\n        this->next_node->remove ();\n    }\n    delete this;\n}\n\nint tetrahedral_number (int n)\n{\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\nint vector_sum (std::vector<int>* vec)\n{\n    int num = 0;\n    for (int i = 0; i < vec->size (); i++)\n    {\n        num = num + (*vec)[i];\n    }\n\n    return num;\n}\n\nstd::vector<int>* approx_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    while (tmp_n != 0)\n    {\n\n        int i = 0;\n\n        while (i++, tetrahedral_number (i + 1) <= tmp_n);\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (i);\n        }\n\n        (*solution)[i-1] = (*solution)[i-1] + 1;\n\n        tmp_n = tmp_n - tetrahedral_number (i);\n\n    }\n\n    return solution;\n}\n\nstd::vector<int>* approx_odd_least_number_by_tetrahedral (int n)\n{\n    int tmp_n = n;\n    std::vector<int>* solution = NULL;\n\n    while (tmp_n != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= tmp_n; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n        if (solution == NULL)\n        {\n            solution = new std::vector<int> (cnt);\n        }\n\n        (*solution)[cnt-1] = (*solution)[cnt-1] + 1;\n\n        tmp_n = tmp_n - tetrahedral_number (odd_i);\n\n    }\n\n    return solution;\n\n}\n\nstd::vector<int>* odd_branch_and_bound (std::vector<int>* base, int n)\n{\n\n    int upper_b = vector_sum (base);\n\n    int v_dim = base->size ();\n\n    auto tetra_indices = new std::vector<int> (v_dim);\n\n    int n_copy = n;\n\n    while (n_copy != 0)\n    {\n\n        int i = 1;\n\n        int cnt = 0;\n\n        int odd_i = 0;\n\n        for (int tetra_num = 1; tetra_num <= n_copy; tetra_num = tetrahedral_number (i))\n        {\n\n            if (tetrahedral_number (i) % 2 != 0)\n            {\n                cnt++;\n                odd_i = i;\n\n            }\n\n            i++;\n        }\n\n\n        (*tetra_indices)[cnt-1] = odd_i;\n\n        int tetra_num = tetrahedral_number (odd_i);\n\n        while (n_copy >= tetra_num)\n        {\n            n_copy = n_copy - tetra_num;\n        }\n\n    }\n\n    auto f = [&](int upper_bound, int upper_index) -> std::vector<int>*\n    {\n        int cnt = 1;\n\n\n        std::vector<int>* target = new std::vector<int> (upper_index);\n\n        (*target)[upper_index-1] = 1;\n\n        int tmp_n = n - tetrahedral_number ((*tetra_indices)[upper_index-1]);\n\n        while (tmp_n != 0)\n        {\n\n            int i = 0;\n\n            while (i++, tetrahedral_number ((*tetra_indices)[i]) <= tmp_n && i < upper_index);\n\n            \n            (*target)[i-1] = (*target)[i-1] + 1;\n\n            cnt++;\n\n            if (cnt >= upper_bound)\n            {\n                return NULL;\n            }\n\n            tmp_n = tmp_n - tetrahedral_number ((*tetra_indices)[i-1]);\n\n        }\n\n\n        return target;\n    };\n\n    std::vector<int>* solution = base;\n\n    for (int i = solution->size () - 1; i > 0; i--)\n    {\n\n\n        auto vec = f (vector_sum (solution), i);\n\n\n        if (vec !=NULL)\n        {\n            solution = vec;\n        }\n\n    }\n\n\n\n    return solution;\n}\n\n\nstd::vector<int>* branch_and_bound (std::vector<int>* base, int n)\n{\n\n\n\n    int upper_b = vector_sum (base);\n\n    auto f = [](std::vector<int>* base, int n, int index) -> std::vector<int>*\n    {\n        int cnt = 1;\n\n        int upper_cnt = vector_sum (base);\n\n        std::vector<int>* solution = new std::vector<int> (index);\n\n        (*solution)[index-1] = 1;\n\n        int tmp_n = n - tetrahedral_number (index);\n\n        while (tmp_n != 0)\n        {\n\n            int i = 0;\n\n            while (i++, tetrahedral_number (i + 1) <= tmp_n && i <= index);\n\n            \n            (*solution)[i-1] = (*solution)[i-1] + 1;\n\n            cnt++;\n\n            if (cnt >= upper_cnt)\n            {\n                return NULL;\n            }\n\n            tmp_n = tmp_n - tetrahedral_number (i);\n\n        }\n\n\n        return solution;\n    };\n\n    std::vector<int>* solution = base;\n\n    for (int i = solution->size () - 1; i > 0; i--)\n    {\n\n\n        auto vec = f (solution, n, i);\n\n\n        if (vec !=NULL)\n        {\n            solution = vec;\n        }\n\n    }\n\n\n\n\n    return solution;\n}\n\nint main ()\n{\n\n    int n = 0;\n    while (std::cin >> n, n != 0)\n    {\n\n        auto b = approx_least_number_by_tetrahedral (n);\n\n        auto s = branch_and_bound(b,n);\n        \n        int normal = vector_sum (s);\n\n        auto ob = approx_odd_least_number_by_tetrahedral (n);\n\n        auto os = odd_branch_and_bound (ob, n);\n\n        int odd =vector_sum (os);\n\n        std::cout << normal << \" \" << odd <<  std::endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0; i<n; i++)\ntypedef long long ll;\ntypedef long long unsigned int llu;\nll MOD = 1000000007;\nll INF = 1000000009;\n\nint f[190];\nint dp1[1000100];\nint dp2[1000100];\n\n\nvoid solve(){\n\n    int n=182;\n    vector<int> v;\n\n    while(true){\n        int x;\n        cin >> x;\n        if(x==0) break;\n        v.emplace_back(x);\n    }\n\n\n    rep(i,190){\n        f[i]=i*(i+1)*(i+2)/6;\n    }\n\n    rep(i,1000100){\n        dp1[i]=i;\n        dp2[i]=i;\n    }\n\n\n    for(int k=1; k<=1000100; k++){\n        rep(i,n){\n            if(k>=f[i]) dp1[k]=min(dp1[k-f[i]]+1, dp1[k]);\n            if(f[i]%2==1){\n                if(k>=f[i]) dp2[k]=min(dp2[k-f[i]]+1, dp2[k]);\n            }\n        }\n        /*\n        rep(i,100){\n            if(k>=fodd[i]) dp2[k]=min(dp2[k-fodd[i]]+1, dp2[k]);\n        }\n        */\n    }\n\n\n    rep(i,v.size()){\n        cout << dp1[v[i]] << \" \" << dp2[v[i]] << endl;\n    }\n\n\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tlong int ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1500001]={0,1,2,3},d[1500001],k=0,i,j,n,p;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0,p=i;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<198;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<cctype>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define SZ(a) ((int)((a).size()))\n#define REPSZ(i,v) REP(i,SZ(v))\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long Int;\n\ntemplate<class T> void pv(T a, T b){for(T i=a;i!=b;++i)cout<<*i<<' ';cout<<endl;}\n\nint dp[1000 * 1000 + 10];\nint dp_odd[1000 * 1000 + 10];\n\nint main() {\n  int v[200];\n  for(int i = 0; i < 200; i++) {\n    v[i] = i * (i + 1) * (i + 2) / 6;\n  }\n\n  memset( dp, -1, sizeof(dp) );\n  memset( dp_odd, -1, sizeof(dp_odd) );\n\n  dp[0] = dp_odd[0] = 0;\n\n  for(int i = 0; i < 200; i++)\n    for(int j = 0; j + v[i] <= 1000 * 1000; j++) {\n      if( dp[j] != -1 ) {\n        if( dp[j + v[i]] == -1 || dp[j + v[i]] > dp[j] + 1 )\n          dp[j + v[i]] = dp[j] + 1;\n      }\n\n      if( (v[i] & 1) && dp_odd[j] != -1 ) {\n        if( dp_odd[j + v[i]] == -1 || dp_odd[j + v[i]] > dp_odd[j] + 1 )\n          dp_odd[j + v[i]] = dp_odd[j] + 1;\n      }\n\n    }\n\n  for(int N; cin >> N, N; ) {\n    cout << dp[N] << \" \" << dp_odd[N] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N = 1e6;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\nvector<int> init() {\n\tvector<int> num;\n\tint sum = 0;\n\tfor(int i = 1;; ++i) {\n\t\tsum += i;\n\t\tif(sum > MAX_N) break;\n\t\tnum.emplace_back(sum);\n\t}\n\n\tpartial_sum(num.begin(), num.end(), num.begin());\n\treturn num;\n}\n\nint main() {\n\tconst auto num = init();\n\n\tvector<int> dp(MAX_N + 1, INT_MAX);\n\tvector<int> odd_dp(MAX_N + 1, INT_MAX);\n\tdp[0] = odd_dp[0] = 0;\n\n\tfor(unsigned i = 0; i < num.size(); ++i) {\n\t\tconst int &value = num[i];\n\n\t\tfor(int j = 0; j + value <= MAX_N; ++j) {\n\t\t\tchmin(dp[j + value], dp[j] + 1);\n\t\t}\n\n\t\tif(value & 1) {\n\t\t\tfor(int j = 0; j + value <= MAX_N; ++j) {\n\t\t\t\tchmin(odd_dp[j + value], odd_dp[j] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int n; cin >> n && n;) {\n\t\tcout << dp[n] << \" \" << odd_dp[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint N,inf = 1e9;\nint dp[1000010] = {},dp_odd[1000010] = {};\n\nint main(){\n\twhile(cin >> N && N>0){\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tdp[i] = inf;\n\t\t\tdp_odd[i] = inf;\n\t\t}\n\t\tdp[0] = 0;\n\t\tfor(int i=1;i*(i+1)*(i+2)<=6*N;i++){\n\t\t\tint n = i*(i+1)*(i+2)/6;\n\t\t\tfor(int j=n;j<=N;j++){\n\t\t\t\tdp[j] = min(dp[j],dp[j-n]+1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[N] << \" \";\n\t\tdp_odd[0] = 0;\n\t\tfor(int i=1;i*(i+1)*(i+2)<=6*N;i++){\n\t\t\tint n = i*(i+1)*(i+2)/6;\n\t\t\tif(n%2==0) continue;\n\t\t\tfor(int j=n;j<=N;j++){\n\t\t\t\tdp_odd[j] = min(dp_odd[j],dp_odd[j-n]+1);\n\t\t\t}\n\t\t}\n\t\tcout << dp_odd[N] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string.h>\n\nusing namespace std;\n\nint f1[1000001];\nint f2[1000001];\n\nint main()\n{\n\tint t_num[182];\n\tint t_num_odd[182];\n\t\n\tint k=0;\n\tfor (int i=1;i<182;++i)\n\t{\n\t\tt_num[i-1] = i*(i+1)*(i+2)/6;\n\t\tif (t_num[i-1] % 2 == 1)\n\t\t{\n\t\t\tt_num_odd[k] = t_num[i-1];\n\t\t\t++k;\n\t\t}\t\t\n\t}\n\t\n\tmemset(f1,1000001,sizeof(f1));\n\tf1[0] = 0;\n\tfor (int j=0;j<181;++j)\n\t{\n\t\tfor (int i=t_num[j];i<=1000000;++i)\n\t\t{\n\t\t\tif (i>=t_num[j]) f1[i] = min(f1[i],f1[i-t_num[j]]+1);\n\t\t}\n\t}\n\t\n\tmemset(f2,1000001,sizeof(f2));\n\tf2[0] = 0;\n\tfor (int j=0;j<k;++j)\n\t{\n\t\tfor (int i=t_num_odd[j];i<=1000000;++i)\n\t\t{\n\t\t\tif (i>=t_num_odd[j]) f2[i] = min(f2[i],f2[i-t_num_odd[j]]+1);\n\t\t}\n\t}\n\t\n\tint n;\n\tcin >> n;\n\t\n\twhile (n)\n\t{\n\t\t\n\t\tcout << f1[n] << \" \";\n\t\tcout << f2[n] << endl;\n\t\tcin >> n;\n\t\t\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// #define USE_CPP11\n// #define USE_PRINTF\n\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <utility>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <numeric>\n#include <complex>\n#include <memory>\n#include <sstream>\n\n#ifdef USE_CPP11\n#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#endif\n\n#define PRINT(obj) cout << obj << endl\n#define REP(i, n) for(int (i) = 0; (i) < (n); i++)\n#define SPACE \" \"\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nnamespace Scanner {\n#ifdef USE_PRINTF\n  int    nextInt()    { int    d; scanf(\"%d\" , &d); return d; }\n  float  nextFloat()  { float  f; scanf(\"%f\" , &f); return f; }\n  double nextDouble() { double f; scanf(\"%lf\", &f); return f; }  \n  string nextString() { string s; scanf(\"%s\" , &s); return s; }\n  ll     nextll()     { ll     l; scanf(\"%ll\", &l); return l; }\n#else\n  int    nextInt()    { int    d; cin >> d; return d; }\n  float  nextFloat()  { float  f; cin >> f; return f; }\n  double nextDouble() { double f; cin >> f; return f; }  \n  string nextString() { string s; cin >> s; return s; }\n  ll     nextll()     { ll     l; cin >> l; return l; }\n#endif\n\n  string getLine() { \n    string input;\n    getline(cin, input);\n    return input;\n  }\n};\n\nnamespace myLibrary {\n  vector<string> split(const string& str, char delim) {\n    vector<string> ret;\n    size_t current = 0, found;\n    while ((found = str.find_first_of(delim, current)) != string::npos) {\n      ret.push_back(string(str, current, found - current));\n      current = found + 1;\n    }\n    ret.push_back(string(str, current, str.size() - current));\n    return ret;\n  }\n  \n#ifdef USE_CPP11\n  ///\n  /// higher-order functional\n  /// This is something like map in haskell, python, etc.\n  /// Sample usage:\n  ///   vector<int> a = {1, 2, 3, 4, 5};\n  ///   vector<int> b = myLibrary::_Map<int, int>(a, [](int n){\n  ///     return n * n;\n  ///   });\n  /// Result:\n  ///   b = 1, 4, 9, 16, 25\n  ///\n  template<typename T_IN, typename T_OUT, class Functor>\n  vector<T_OUT> _Map(vector<T_IN> src, Functor func) {\n    vector<T_OUT> ret;\n    for (int i = 0; i < src.size(); i++) {\n      ret.push_back(func(src[i]));\n    }\n    return ret;\n  }\n#endif\n\n};\n\n/// BEGIN //////////////////////////////////////////////////////////\n\nint memo[(int)1e6 + 1];\nint memo_odd[(int)1e6 + 1];\n\nint solve(int n) {\n  int ret = 0;\n  int s_min = INF;\n  if (n < 1) return memo[n] = 0;\n  if (memo[n] > 0) return memo[n];\n  for (int i = sqrt(n); i >= 1; i--) {\n    int t = i * (i + 1) * (i + 2) / 6;\n    if (t > n) continue;\n    if (t == n) return memo[n] = 1;\n    int s = solve(n - t);\n    if (s == 0) continue;\n    if (s < s_min) {\n      s_min = s;\n    } \n  }\n  \n  return memo[n] = (s_min + 1);\n}\n\nint solve_odd(int n) {\n  int ret = 0;\n  int s_min = INF;\n  if (n < 1) return memo_odd[n] = 0;\n  if (memo_odd[n] > 0) return memo_odd[n];\n  for (int i = sqrt(n); i >= 1; i--) {\n    int t = i * (i + 1) * (i + 2) / 6;\n    if (t % 2 == 0) continue;\n    if (t > n) continue;\n    if (t == n) return memo_odd[n] = 1;\n    int s = solve_odd(n - t);\n    if (s == 0) continue;\n    if (s < s_min) {\n      s_min = s;\n    } \n  }\n  \n  return memo_odd[n] = (s_min + 1);\n}\n\nvoid calc(int n) {\n  cout << solve(n) << SPACE << solve_odd(n) << endl;\n}\n\nint main() {\n  while (true) {\n    int n = Scanner::nextInt();\n    if (n == 0) break;\n    calc(n);\n  }\n  return 0;\n}\n\n/// END   //////////////////////////////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define REPD(i,n) for(ll i=n-1;i>=0;i--)\n#define FOR(i,a,b) for(ll i=a;i<=(ll)(b);i++)\n#define FORD(i,a,b) for(ll i=a;i>=(ll)(b);i--)\n\n#define input(...) __VA_ARGS__; in(__VA_ARGS__)\n\ntemplate<class T>\nvoid print(vector<T> a) {\n  cout << \"[ \";\n  REP(i, a.size()) cout << a[i] << \" \";\n  cout << \"]\" << endl;\n}\n\nvoid print() {\n  std::cout << std::endl;\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  std::cout << head << \" \";\n  print(std::forward<Tail>(tail)...);\n}\n\nvoid in() { }\n\ntemplate <class Head, class... Tail>\nvoid in(Head&& head, Tail&&... tail) {\n  cin >> head;\n  in(std::forward<Tail>(tail)...);\n}\n\nll n;\n\nvector<ll> fvalues;\nvector<ll> fvalues2;\nll f(ll x) {\n  return x * (x + 1) * (x + 2) / 6;\n}\n\nvector<ll> table;\nll dfs(ll x) {\n  if (table[x] != -1) return table[x];\n  if (x == 0) return 0;\n\n  ll minv = numeric_limits<ll>::max() / 2;\n\n  for (ll i = fvalues.size() - 1; i >= 0; i -= 1) {\n    ll value = fvalues[i];\n    if (x - value >= 0) {\n      minv = min(minv, dfs(x - value) + 1);\n    }\n  }\n  return table[x] = minv;\n}\n\nvector<ll> table2;\nll dfs2(ll x) {\n  if (table2[x] != -1) return table2[x];\n  if (x == 0) return 0;\n\n  ll minv = numeric_limits<ll>::max() / 2;\n\n  for (ll i = fvalues2.size() - 1; i >= 0; i -= 1) {\n    ll value = fvalues2[i];\n    if (x - value >= 0) {\n      minv = min(minv, dfs2(x - value) + 1);\n    }\n  }\n  return table2[x] = minv;\n}\n\nbool solve() {\n  cin >> n;\n  if (n == 0) return false;\n\n  cout << dfs(n) << \" \" << dfs2(n) << endl;\n\n  return true;\n}\n\nint main() {\n  ll M = 1000000;\n  for (ll i = 1;; i++) {\n    ll value = f(i);\n    fvalues.push_back(value);\n    if (value % 2 == 1) fvalues2.push_back(value);\n    if (value > M) break;\n  }\n\n  table = vector<ll>(M + 1, -1);\n  table2 = vector<ll>(M + 1, -1);\n  while (solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int MAX_V=1000010;\nunsigned int dp[MAX_V];\nunsigned int dpodd[MAX_V];\nset<int> tetras{-1};\nset<int> oddtetras{-1};\nint main(){ _;\n  int n;\n  REP(i,MAX_V)dp[i]=dpodd[i]=-1;\n  dp[0]=dpodd[0]=0;\n  for(int i=1;;i++){\n    int k=i*(i+1)*(i+2)/6;\n    tetras.insert(k);\n    if((k>>1)<<1!=k)//odd\n      oddtetras.insert(k);\n    if(k>MAX_V)break;\n  }\n  for(int i=1;i<MAX_V;i++){\n    auto tetra=tetras.upper_bound(i);\n    auto oddtetra=oddtetras.upper_bound(i);\n    for(int j=0;j<200;j++){\n      int k=*(--tetra);\n      if(k<0)break;\n      dp[i]=min(dp[i],dp[i-k]+1);\n    }\n    for(int j=0;j<200;j++){\n      int k=*(--oddtetra);\n      if(k<0)break;\n      dpodd[i]=min(dpodd[i],dpodd[i-k]+1);\n    }\n  }\n  while(cin>>n,n!=0){\n    cout<<dp[n]<<\" \"<<dpodd[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint dp1[MAX+1],dp2[MAX+1];\n\nint main(){\n    //INFで初期化\n    for(int i = 0;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n * 2) /6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;  //ポロック数の生成\n        for(int i = a;i <= MAX;i++)     //正四面体数の個数dp(a以下は必要ない)\n            dp1[i] = min(dp1[i],dp1[i-a] + 1);  //更新しないor左側から更新する\n        if(a % 2 == 0)continue;     //偶数の時は次のroopへ\n        for(int i = a;i <= MAX;i++)     //奇数の正四面体数の個数dp(a以下は必要ない)\n            dp2[i] = min(dp2[i],dp2[i-a] + 1);  //更新しないor左側から更新する\n    }\n\n    //入出力\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\nusing LL = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using Grid = vector<vector<T>>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr LL inf_ll = (LL)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ntemplate<class T>inline bool inRange(const T& v, const T& min, const T& max)noexcept { return min <= v && v <= max; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_WIN32) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (LL)(c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T input() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { return input<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tconst int MAX_N = 1000009;\n\n\tVI num;\n\tFOR(i, 1, MAX_N) {\n\t\tnum.push_back(i * (i + 1) * (i + 2) / 6);\n\t\tif (num.back() > MAX_N) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tVI dp(MAX_N, inf);\n\tdp[0] = 0;\n\tfor (auto n : num) {\n\t\tFOR(i, n, MAX_N) {\n\t\t\tchmin(dp[i], dp[i - n] + 1);\n\t\t}\n\t}\n\n\tVI dp2(MAX_N, inf);\n\tdp2[0] = 0;\n\tfor (auto n : num)if (n % 2) {\n\t\tFOR(i, n, MAX_N) {\n\t\t\tchmin(dp2[i], dp2[i - n] + 1);\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n = in;\n\t\tif (!n)break;\n\t\tout(dp[n], dp2[n]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// repetition\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\n// container util\n#define all(x) (x).begin(), (x).end()\n\n// debug\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x)                                         \\\n  cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" \\\n       << \" \" << __FILE__ << endl;\n\n// typedef\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef complex<long double> Complex;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n// constant\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\n// conversion\ninline int toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\n\n//\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n//\n\nconst int MAX = 1000100;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  vector<int> dp(MAX, INF), odddp(MAX, INF);\n  dp[0] = odddp[0] = 0;\n  for (int i = 1;; i++) {\n    int num = i * (i + 1) * (i + 2) / 6;\n    if (num >= MAX) break;\n    for (int j = num; j < MAX; j++) {\n      dp[j] = min(dp[j], dp[j - num] + 1);\n      if (num & 1) odddp[j] = min(odddp[j], odddp[j - num] + 1);\n    }\n  }\n\n  int n;\n  while (cin >> n) {\n    if (n == 0) break;\n    cout << dp[n] << \" \" << odddp[n] << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nconst int INF = (1<<30)-1;\nconst long long LINF = (1LL<<62)-1;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int MAX = 1e6+10;\n\nint func(ll x) {\n  return x*(x+1)/2*(x+2)/3;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> dp1(MAX, INF), dp2(MAX, INF);\n  dp1[0] = dp2[0] = 0;\n  for (int i = 1; i < MAX; i++) {\n    for (int j = 1; ; j++) {\n      ll num = func(j);\n      if (i-num < 0)\n        break;\n      chmin(dp1[i], dp1[i-num]+1);\n      if (num%2)\n        chmin(dp2[i], dp2[i-num]+1);\n    }\n  }\n  int tmp;\n  while (cin >> tmp && tmp)\n    cout << dp1[tmp] << ' ' << dp2[tmp] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\ntypedef pair<int,int> P;\nconst int MAX = 1000001;\nconst int INF = (1<<20);\n\nvector<int> p;\nP ans[MAX];\n\nvoid init(){\n\n  for(int i = 1; i < MAX; i++)\n    ans[i].first = ans[i].second = INF;\n\n}\n\nvoid make(){\n  int n = 0;\n  while(1){\n    int now = (n*(n+1)*(n+2))/6;\n    if(now >= MAX) break;\n    p.push_back(now);\n    n++;\n  }\n\n\n  for(int i = 1; i < MAX; i++)\n    for(int j = 1; j < p.size(); j++){\n      if(i-p[j] >= 0){\n\tif(p[j]%2) ans[i].second = min(ans[i].second,ans[i-p[j]].second+1);\n\tans[i].first = min(ans[i].first,ans[i-p[j]].first+1);\n      }\n    }\n}\n\nint main(){\n  init();\n  make();\n  int in;\n  while(cin >> in && in) cout << ans[in].first << \" \" << ans[in].second << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <utility>\n#include <cmath>\n#include <random>\n#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i<n; ++i)\n#define REP(i,n) for(int i = 1; i<=n; ++i)\n#define all(x) begin(x),end(x)\ntypedef long long ll;\ntypedef pair<int,int> ip;\ntypedef pair<ll,ll> lp;\nconst int inf = 1001001000;\nconst ll INF = 1LL<<60;\nconst int MOD = (int)1e9 + 7;\n\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) { a = b; return true; } return false;}\n\n\n\n\nint main(){\n\tvector<int> dp1(1000100,inf);\n\tvector<int> dp2(1000100,inf);\n\t\tvector<int> opt1;\n\t\tvector<int> opt2;\n\t\tfor(int i = 1; i*(i+1)*(i+2) <= 6*1000000; ++i){\n\t\t\tint t = i*(i+1)*(i+2)/6;\n\t\t\topt1.push_back(t);\n\t\t\tif(t%2)opt2.push_back(t);\n\t\t}\n\t\tdp1[0] = 0;\n\t\tdp2[0] = 0;\n\t\tREP(i,1000100){\n\t\t\trep(j,opt1.size()){\n\t\t\t\tif(opt1[j]>i)continue;\n\t\t\t\tchmin(dp1[i], dp1[i-opt1[j]]+1);\n\t\t\t}\n\t\t}\n\t\tREP(i,1000100){\n\t\t\trep(j,opt2.size()){\n\t\t\t\tif(opt2[j]>i)continue;\n\t\t\t\tchmin(dp2[i], dp2[i-opt2[j]]+1);\n\t\t\t}\n\t\t}\n\t\t// REP(i,opt1.size()-1){\n\t\t// \tREP(j,N){\n\t\t// \t\tif(opt1[i]>j){\n\t\t// \t\t\tchmin(dp1[i][j], dp1[i-1][j]);\n\t\t// \t\t}else{\n\t\t// \t\t\tchmin(dp1[i][j], dp1[i-1][j]);\n\t\t// \t\t\tchmin(dp1[i][j], dp1[i-1][j-opt1[i]]+1);\n\t\t// \t\t\tchmin(dp1[i][j], dp1[i][j-opt1[i]]+1);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t\t// REP(i,opt2.size()-1){\n\t\t// \tREP(j,N){\n\t\t// \t\tif(opt2[i]>j){\n\t\t// \t\t\tchmin(dp2[i][j], dp2[i-1][j]);\n\t\t// \t\t}else{\n\t\t// \t\t\tchmin(dp2[i][j], dp2[i-1][j]);\n\t\t// \t\t\tchmin(dp2[i][j], dp2[i-1][j-opt2[i]]+1);\n\t\t// \t\t\tchmin(dp2[i][j], dp2[i][j-opt2[i]]+1);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t\t// ans1 = dp1[opt1.size()-1][N];\n\t\t// ans2 = dp2[opt2.size()-1][N];\n\t\tint N;\n\t\tint ans1, ans2;\n\t\twhile(true){\n\t\t\tscanf(\"%d\",&N);\n\t\t\tif(!N)break;\n\t\t\tans1 = dp1[N]; ans2 = dp2[N];\n\t\t\tprintf(\"%d %d\\n\",ans1,ans2);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define MAX_ 1000010\n\nusing namespace std;\n\nint nml[MAX_];\nint kisu[MAX_];\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tvector<int> vn;\n\tvector<int> vk;\n\n\tfor(int i1=0;i1<MAX_;i1++){\n\t\tnml[i1]=0;\n\t\tkisu[i1]=0;\n\t}\n\n\tfor(int i=1;;i++){\n\t\tint p=(i*(i+1)*(i+2))/6;\n\t\tif(p>MAX_) break;\n\n\t\tvn.push_back(p);\n\t\tif(p%2==1) {\n\t\t\tvk.push_back(p);\n\t\t}\n\t}\n\n\tnml[0]=0;\n\tkisu[0]=0;\n\tfor(int i1=1;i1<MAX_;i1++){\n\t\tint i2=0;\n\t\tint min = 10;\n\t\twhile(i1-vn[i2]>=0 && i2<vn.size()){\n\t\t\tif(min>nml[i1-vn[i2]]){\n\t\t\t\tmin=nml[i1-vn[i2]];\n\t\t\t}\n\t\t\ti2++;\n\t\t}\n\t\tnml[i1]=min+1;\n\n\t\ti2=0;\n\t\tmin=2000000;\n\t\twhile(i1-vk[i2]>=0 && i2<vk.size()){\n\t\t\tif(min>kisu[i1-vk[i2]]){\n\t\t\t\tmin=kisu[i1-vk[i2]];\n\t\t\t}\n\t\t\ti2++;\n\t\t}\n\t\tkisu[i1]=min+1;\n\t}\n\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\n\t\tcout<<nml[n]<<\" \"<<kisu[n]<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main(){\n    for(int i = 1;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n + 2) / 6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;\n        for(int i = a;i <= MAX;i++){\n            dp1[i] = min(dp1[i],dp1[i - a] + 1);\n        }\n        if(a % 2 == 0)continue;\n        for(int i = a;i <= MAX;i++){\n            dp2[i] = min(dp2[i],dp2[i - a] + 1);\n        }\n    }\n\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \n\n#define int long long\n#define double long double\n\n#define REP(i, b) for(int i = 0; i < (b); i++)\n#define REPS(i, b) for(int i = 1; i <= (b); i++)\n#define ALL(v) (v).begin(), (v).end()\n\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\nusing pi = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vpi = vector<pi>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\n\nconst int INF = 1e16;\nconst int MOD = 1e9+7;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    const int MAX = 1e6;\n    int n = 1;\n    vi pollock;\n    while(true)\n    {\n        if(n*(n+1)*(n+2)/6 > MAX) break;\n        pollock.pb(n*(n+1)*(n+2)/6);\n        n++;\n    }\n\n    vi ans(MAX+1, INF);\n    REP(i, pollock.size()) ans[pollock[i]] = 1;\n    ans[0] = 0;\n    REPS(i, MAX)\n    {\n        REP(j, pollock.size())\n        {\n            if(i >= pollock[j]) chmin(ans[i], ans[i-pollock[j]]+1);\n        }\n    }\n    vi ans2(MAX+1, INF);\n    REP(i, pollock.size()) if(pollock[i] % 2 == 1) ans2[pollock[i]] = 1;\n    ans2[0] = 0;\n    REPS(i, MAX)\n    {\n        REP(j, pollock.size())\n        {\n            if(pollock[j] % 2 == 1 && i >= pollock[j]) chmin(ans2[i], ans2[i-pollock[j]]+1);\n        }\n    }\n    while(true)\n    {\n        int x; cin >> x;\n        if(x == 0) break;\n        cout << ans[x] << \" \" << ans2[x] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\nconst int INF=1000000000;\nint dp1[2][1000001];\nint dp2[2][1000001];\nvoid solve(){\n\tvector<int> nums;\n\tfor(int i=1;;i++){\n\t\tint a=i*(i+1)*(i+2)/6;\n\t\tnums.push_back(a);\n\t\tif(a>1000000)break;\n\t}\n\tint n=nums.size()-1;\n\tfor(int i=n;i>=0;i--){\n\t\tint cur=i%2;\n\t\tint nxt=(i+1)%2;\n\t\tfor(int j=0;j<=1000000;j++){\n\t\t\tint res=INF;\n\t\t\tif(i==n){\n\t\t\t\tif(j==0)res=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(j-nums[i]>=0)\n\t\t\t\t\tres=min(res,dp1[cur][j-nums[i]]+1);\n\t\t\t\tres=min(res,dp1[nxt][j]);\n\t\t\t}\n\t\t\tdp1[cur][j]=res;\n\t\t}\n\t}\n\tnums.clear();\n\tfor(int i=1;;i++){\n\t\tint a=i*(i+1)*(i+2)/6;\n\t\tif(a%2==1)\n\t\t\tnums.push_back(a);\n\t\tif(a>1000000)break;\n\t}\n\tn=nums.size()-1;\n\tfor(int i=n;i>=0;i--){\n\t\tint cur=i%2;\n\t\tint nxt=(i+1)%2;\n\t\tfor(int j=0;j<=1000000;j++){\n\t\t\tint res=INF;\n\t\t\tif(i==n){\n\t\t\t\tif(j==0)res=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(j-nums[i]>=0)\n\t\t\t\t\tres=min(res,dp2[cur][j-nums[i]]+1);\n\t\t\t\tres=min(res,dp2[nxt][j]);\n\t\t\t}\n\t\t\tdp2[cur][j]=res;\n\t\t}\n\t}\n\tint in;\n\twhile(cin>>in&&in){\n\t\tcout<<dp1[0][in]<<\" \"<<dp2[0][in]<<endl;\n\t}\n}\n\n\nint main(){\n\tsolve();\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint dp1[1000500];\nint dp2[1000500];\n\nint main(void)\n{\n\tvector <int> data;\n\tint n = 1;\n\twhile (1){\n\t\tint tmp = n * (n + 1) * (n + 2) / 6;\n\t\tif (1000000 < tmp) break;\n\t\tdata.push_back(tmp);\n\t\tn++;\n\t}\n\tfill(dp1, dp1 + 1000500, 99999);\n\tfill(dp2, dp2 + 1000500, 99999);\n\tdp1[0] = dp2[0] = 0;\n\tfor (int i = 0; i < 1000500; i++){\n\t\tfor (int j = 0; j < data.size(); j++){\n\t\t\tif (1000500 < i + data[j]) break;\n\t\t\tdp1[i + data[j]] = min(dp1[i + data[j]], dp1[i] + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < 1000500; i++){\n\t\tfor (int j = 0; j < data.size(); j++){\n\t\t\tif (1000000 < i + data[j]) break;\n\t\t\tif (data[j] % 2 == 1) dp2[i + data[j]] = min(dp2[i + data[j]], dp2[i] + 1);\n\t\t}\n\t}\n\n\twhile (cin >> n, n){\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\n#define INF 1 << 28\n\nvector<int> t;\nvector<int> odd_t;\nint ns[1000001];\nint odd_ns[1000001];\n\nint count_t(int n) {\n\tif (ns[n] != 0) return ns[n];\n\tif (binary_search(t.begin(), t.end(), n)) {\n\t\tns[n] = 1;\n\t\treturn 1;\n\t}\n\tns[n] = INF;\n\tfor (int i = 0; n-t[i] >= 0; i++) {\n\t\tns[n] = min(ns[n], count_t(n-t[i])+1);\n\t}\n\treturn ns[n];\n}\n\nint count_odd_t(int n) {\n\tif (odd_ns[n] != 0) return odd_ns[n];\n\tif (binary_search(odd_t.begin(), odd_t.end(), n)) {\n\t\todd_ns[n] = 1;\n\t\treturn 1;\n\t}\n\todd_ns[n] = INF;\n\tfor (int i = 0; n-odd_t[i] >= 0; i++) {\n\t\todd_ns[n] = min(odd_ns[n], count_odd_t(n-odd_t[i])+1);\n\t}\n\treturn odd_ns[n];\n}\n\nint main() {\n\tmemset(ns, 0, sizeof(ns));\n\tmemset(odd_ns, 0, sizeof(odd_ns));\n\n\tfor (int i = 0; i < 500; i++) {\n\t   \tt.push_back((i+1)*(i+2)*(i+3) / 6);\n\t\tif (*(t.end()-1) % 2 == 1) odd_t.push_back(*(t.end()-1));\n\t}\n\t//for (int i = 0; i < odd_t.size(); i++) cout << odd_t[i] << ' ';\n\t//cout << endl;\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << count_t(n) << ' ' << count_odd_t(n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\nint c[300];\nvector<int> d;\nint a[10000000],b[10000000];\n\nvoid f(int n){\n\n  int j=1;\n  FOR(i,1,n+1){\n    if(c[j+1]==i){\n      a[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,1,j+1){\n        res = min(res,(i/c[k])+a[i%c[k]]);\n      }\n      a[i] = res;\n    }\n  }\n\n  cout<<a[n]<<' ';\n\n  j = 0;\n  FOR(i,1,n+1){\n    if(d[j+1]==i){\n      b[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,1,j+1){\n        res = min(res,(i/d[k])+b[i%d[k]]);\n      }\n      b[i] =res;\n    }\n  \n  }\n\n  cout<<b[n]<<endl;\n\n\n\n}\n\nvoid g(int n){\n  cout<<a[n]<<' '<<b[n]<<endl;\n}\n\n\nint main(){\n\n  for(int i=1;i<200;i++){\n    c[i] = (i*(i+1)*(i+2))/6;\n   if(c[i]%2){\n     d.push_back(c[i]);\n   }\n  }\n\n  f(1000000);\n\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    g(n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nvector<int>nums;\nvector<int>oddnums;\n\nvector<vector<short>>memo(100001, vector<short>(190,-1));\nvector<vector<short>>oddmemo(100001, vector<short>(50,-1));\n\nint getans(const int num, const int used,const int atime) {\n\tif (memo[num][used] != -1) {\n\t\treturn memo[num][used];\n\t}\n\telse {\n\t\tif (num == 0)return memo[num][used] = 0;\n\t\tif (atime > 10)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <= used; ++i) {\n\t\t\tint minusnum = nums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 10) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getans(num - minusnum, i, atime + 1)+1);\n\t\t}\n\n\t\treturn memo[num][used] = ans;\n\t}\n}\nint getoddans(const int num, const int used, const int atime) {\n\tif (oddmemo[num][used] != -1) {\n\t\treturn  oddmemo[num][used];\n\t}\n\telse {\n\t\tif (num == 0)return oddmemo[num][used] = 0;\n\t\tif (atime > 100)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <= min(int(oddnums.size()),used); ++i) {\n\t\t\tint minusnum = oddnums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 100) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getoddans(num - minusnum, i, atime + 1) + 1);\n\t\t}\n\n\t\treturn  oddmemo[num][used] = ans;\n\t}\n}\nint main() {\n\tfor (int i = 1; i < 190; ++i) {\n\t\tnums.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (((i*(i + 1)*(i + 2)) / 6) % 2) {\n\n\t\t\n\t\t\toddnums.push_back((i*(i + 1)*(i + 2)) / 6);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tint normalans = getans(n, 189, 0);;\n\t\tint oddans = getoddans(n, 47, 0);\n\n\t\tcout << normalans << \" \" << oddans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[111111];\nint memo2[111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n\n  for(int i=0;i<111111;i++){ solve(i), solve2(i); }\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000001];\nint v[1000];\nint main()\n{\n\tint n;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j <= 1000000; j++)\n\t\t{\n\t\t\tif (j == 0)dp[i][j] = 0;\n\t\t\telse dp[i][j] = 999999;\n\t\t}\n\t}\n\tfor (int i = 1;;i++)\n\t{\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif (k > 1000000)break;\n\t\tv[i - 1] = k;\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t{\n\t\t\tfor (int j = 0;;j++)\n\t\t\t{\n\t\t\t\tif (i + v[j] > n)break;\n\t\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]],dp[0][i] + 1);\n\t\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S acm(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nvi od,all;\n\nvoid solve(int n){\n\tvi aldp(n+1,INF),oddp(n+1,INF);\n\taldp[0]=0;oddp[0]=0;\n\trrep(i,all.size()){\n\t\trep(j,n){\n\t\t\tif(aldp[j]==INF)continue;\n\t\t\tif(j+all[i]>n)j=n;\n\t\t\telse chmin(aldp[j+all[i]],aldp[j]+1);\n\t\t}\n\t}\n\trrep(i,od.size()){\n\t\trep(j,n){\n\t\t\tif(oddp[j]==INF)continue;\n\t\t\tif(j+od[i]>n)j=n;\n\t\t\telse chmin(oddp[j+od[i]],oddp[j]+1);\n\t\t}\n\t}\n\tputa(aldp[n],oddp[n]);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tfor(int i=1;(i)*(i+1)*(i+2)/6<=1E6;i++){\n\t\tall.push_back((i)*(i+1)*(i+2)/6);\n\t\tif((i)*(i+1)*(i+2)/6%2==1)od.push_back((i)*(i+1)*(i+2)/6);\n\t}\n\twhile(cin>>n,n)solve(n);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconst int INF = 1e8;\nconst int MAX_N = 1e6;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    vector<int> sum(201, 0);\n    for (int i = 1; i <= 200; ++i) {\n        sum.at(i) = i * (i + 1) * (i + 2) / 6;\n    }\n\n    vector<vector<int> > dp(2, vector<int>(MAX_N, INF));\n    dp.at(0).at(0) = 0;\n    dp.at(1).at(0) = 0;\n    dp.at(0).at(1) = 1;\n    dp.at(1).at(1) = 1;\n    for (int i = 0; i < MAX_N; ++i) {\n        for (auto &x : sum) {\n            if (i + x >= MAX_N) break;\n            dp.at(0).at(i + x) = min(dp.at(0).at(i + x), dp.at(0).at(i) + 1);\n            if (x % 2 == 0) continue;\n            dp.at(1).at(i + x) = min(dp.at(1).at(i + x), dp.at(1).at(i) + 1);\n        }\n    }\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) break;\n        cout << dp.at(0).at(N) << ' ' << dp.at(1).at(N) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    vector<int> queries;\n    int q_max = 0;\n    while(1){\n        int q;\n        cin >> q;\n        if(q == 0) break;\n        queries.push_back(q);\n        q_max = max(q_max, q);\n    }\n\n    int num = 0;\n    vector<int> tetra;\n    int x = 1;\n    while(num <= q_max){\n        num = x * (x+1) * (x+2) / 6;\n        tetra.push_back(num);\n        ++x;\n    }\n\n    int m = tetra.size();\n\n    const int INF = 1001001001;\n    vector<vector<int>> dp(2, vector<int>(q_max+1, INF)); // 0: all, 1: odd only\n    dp[0][0] = 0;\n    dp[1][0] = 0;\n    rep1(i, q_max+1){\n        rep(j, m){\n            if(tetra[j] > i) break;\n            dp[0][i] = min(dp[0][i], dp[0][i-tetra[j]] + 1);\n            if(tetra[j]%2 == 1) dp[1][i] = min(dp[1][i], dp[1][i-tetra[j]] + 1);\n        }\n    }\n\n    rep(i, queries.size()) cout << dp[0][queries[i]] << \" \" << dp[1][queries[i]] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pll> vp;\ntypedef vector<ll> vll;\n\nconst int inf = 1e6;\nconst int MAX = 1e6;\n\nint dp1[MAX];\nint dp2[MAX];\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    vi a1;\n    vi a2;\n\n    a1.emplace_back(1);\n    a2.emplace_back(1);\n    rep2(i, 1, 300) {\n        int x = i * (i + 1) * (i + 2) / 6;\n        if (x >= MAX) break;\n        a1.emplace_back(x);\n        if (x & 1) a2.emplace_back(x);\n    }\n\n    fill(dp1, dp1 + MAX, inf);\n    dp1[0] = 0;\n    for (int x : a1) {\n        rep2(i, x, MAX) {\n            dp1[i] = min(dp1[i], dp1[i - x] + 1);\n        }\n    }\n\n    fill(dp2, dp2 + MAX, inf);\n    dp2[0] = 0;\n    for (int x : a2) {\n        rep2(i, x, MAX) {\n            dp2[i] = min(dp2[i], dp2[i - x] + 1);\n        }\n    }\n\n\n    int n;\n    while (cin >> n && n) {\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nint dp[1000001],Odp[1000001];\nint Tn[200],OTn[200]; \n\nint main(){\n    int count = 0;  //pollocks numberの生成\n    for(int i = 1;i < 200;i++){\n        Tn[i-1] = i * (i + 1) * (i + 2) / 6;\n        if(Tn[i-1] % 2 == 1){\n            OTn[count] = Tn[i-1];\n            count++;\n        }\n    }\n    int n = 1000000;\n\n    //正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        dp[j] = j;\n    int k;\n    for(int i = 0;i < 200;i++)\n        for(int j = Tn[i];j <= 1000000;j++){\n            if(j >= Tn[i])\n                dp[j] = min(dp[j],dp[j-Tn[i]] + 1);\n            k = i;\n        }\n\n    //奇数正四面体数の個数の最小値\n    for(int j = 0;j <= n;j++)\n        Odp[j] = j;\n    int k1;\n    for(int i = 0;i <= 200;i++)\n        for(int j = OTn[i];j <= n;j++){\n            if(j >= OTn[i])\n                Odp[j] = min(Odp[j],Odp[j-OTn[i]] + 1);\n            k1 = i;\n        }\n    while(cin >> n,n)\n        cout << dp[k][n] << ' ' <<  Odp[k1][n] << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX_N = 1e+6;\nconst int INF = 1e+8;\n\nint f(int n){\n\treturn n * (n+1) * (n+2) / 6;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tint dp[MAX_N+1];\n\t\tfor(int i=0 ; i <= n ; i++ ){\n\t\t\tdp[i] = INF;\n\t\t}\n\t\tfor(int i=1 ; f(i) <= n ; i++ ){\n\t\t\tdp[f(i)] = 1;\n\t\t}\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tif( dp[i] != INF ){\n\t\t\t\tfor(int j=1 ; dp[i] + f(j) <= n ; j++ ){\n\t\t\t\t\tdp[i+f(j)] = min( dp[i+f(j)] , dp[i]+1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << \" \";\n\t\tfor(int i=0 ; i <= n ; i++ ){\n\t\t\tdp[i] = INF;\n\t\t}\n\t\tfor(int i=1 ; f(i) <= n ; i++ ){\n\t\t\tif( f(i) % 2 ) dp[f(i)] = 1;\n\t\t}\n\t\tfor(int i=1 ; i <= n ; i++ ){\n\t\t\tif( dp[i] != INF ){\n\t\t\t\tfor(int j=1 ; dp[i] + f(j) <= n ; j++ ){\n\t\t\t\t\tif( f(j) % 2 ) \n\t\t\t\t\t\tdp[i+f(j)] = min( dp[i+f(j)] , dp[i]+1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <list>\n#include <set>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <deque>\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<ll>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\nusing vvi=vector<vi>;\nusing vpii=vector<pii>;\nusing si=set<int>;\n\n\n#define REP(i,a) for(int i=0;i<a;i++)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rREP(i,a) for(int i=(a)-1;i>=0;i--)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define out(S) cout<<(S)<<endl;\n#define beginend(v) (v).begin(),(v).end()\n#define IfOut(condition,text) if(condition){out(text);return 0;}\n#define IfOutElse(condition,if_text,else_text) if(condition){out(if_text);return 0;}else{out(else_text);return 0;}\n#define mod(s) ((s)%(ll)(1e9+7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a*modpow((ll)b,(ll)(1e9+5))))\n#define pb(i) push_back(i)\n#define fst first\n#define snd second\n#define Foreach(item,collection) for(auto item:collection)\n#define INF (int)1e10\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nll sum(vi v) {ll sum=0;Foreach(i,v){sum+=i;}return sum;}\n#define ShowAll(v) Foreach(i,v) out(i);\nbool isInnerIndex(int kx,int ky,int mx,int my){ return (kx>=0&&kx<mx&&ky>=0&&ky<my); }\n#define yes cout<<\"yes\"<<endl;\n#define no cout<<\"no\"<<endl;\n\nvi llist,oddlist;\n\nvoid makeList(int max){\n    int n=1;\n    bool f=true;\n    while(f){\n        ll next=n*(n+1)*(n+2)/6;\n        if(next>max){break;}\n        llist.pb(next);\n        if(next%2==1) oddlist.pb(next);\n        n++;\n    }\n}\n\n\nint beam_width=20000;\n\nint bfs(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,llist) {\n        if(i==target){\n            return 1;\n        }\n        if(i<target){\n            q.pb(i);\n            mm=i;\n        }\n        if(i>target) break;\n    }\n    //auto mm=*max_element(beginend(q));\n    int cnt=0;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(llist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,llist){\n                if(k+x>target) break;\n                // if(k+x==target) {next.clear();q.clear();return cnt;}\n                if(k+x<target) next.pb(k+x);\n            }\n\n            \n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\nint bfs2(int target){\n    deque<int> q;\n    int mm=0;\n    Foreach(i,oddlist){\n        if(i==target) return 1;\n        if(i<target) {q.pb(i);mm=i;}\n        if(i>target) break;\n    }\n    int cnt=(target-mm)/mm;\n    target=target%mm+mm;\n    if(binary_search(beginend(q),target)) return cnt+1;\n    cnt+=2;\n    //out(mm);\n    while(1){\n        deque<int> next;\n        Foreach(x,q){\n            if(binary_search(beginend(oddlist),target-x)){\n                next.clear();\n                q.clear();\n                return cnt;\n            }\n            Foreach(k,oddlist){\n                if(k+x>target)break;\n                //if(k+x==target){next.clear();q.clear();return cnt;}\n                if(k+x<target)next.pb(k+x);\n            }\n        }\n                    sort(beginend(next));\n            int ns=next.size();\n            REP(i,ns-beam_width){\n                next.pop_front();\n            }\n        q=next;\n        next.clear();\n        cnt++;\n    }\n}\n\n\n\nint main(){\n    int n;\n    vl query;\n    int mm=0;\n    while (cin>>n,n)\n    {\n        query.pb(n);\n        mm=max(mm,n);\n    }\n    map<int,pii> m;\n    makeList(mm);\n    Foreach(i,query){\n        if(m.count(i)!=0){\n            cout<<m[i].first<<\" \"<<m[i].second<<endl;\n            continue;\n        }\n        int ans1=bfs(i);\n        int ans2=bfs2(i);\n        //int ans2=0;\n        m[i]=pii(ans1,ans2);\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#define N 1000000\n\nusing namespace std;\n\nint main(){\n\tvector<int> sq;\n\tvector<int> sqodd;\n\tint a[N];\n\tint aodd[N];\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++)  sq.push_back((i * (i + 1) * (i + 2)) / 6);\n\tfor(int i = 1; i * (i + 1) * (i + 2) <= N; i++){\n\t\tif(((i * (i + 1) * (i + 2)) / 6) % 2)\n\t\t \tsqodd.push_back((i * (i + 1) * (i + 2)) / 6);\n\t}\n\tfor(int i = 0; i < N; i++) a[i] = N;\n\tfor(int i = 0; i < N; i++) aodd[i] = N;\n\tfor(int i = 0; i < sq.size(); i++) a[sq[i]] = 1;\n\tfor(int i = 0; i < sqodd.size(); i++) aodd[sqodd[i]] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tif(a[i] == N) continue;\n\t\tfor(int j = 0; j < sq.size(); j++){\n\t\t\tif(sq[j] + i < N && a[sq[j] + i] > a[i] + 1) a[sq[j] + i] = a[i] + 1;\n\t\t}\n\t}\n\tfor(int i = 1; i < N; i++){\n\t\tif(aodd[i] == N) continue;\n\t\tfor(int j = 0; j < sqodd.size(); j++){\n\t\t\tif(sqodd[j] + i < N && aodd[sqodd[j] + i] > aodd[i] + 1) aodd[sqodd[j] + i] = aodd[i] + 1;\n\t\t}\n\t}\t\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << a[n] << \" \" << aodd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n\nusing namespace std;\n\ntypedef vector<int> vi;\nint const inf = 1 << 28;\nint main(){\n    vi q, r;\n    for (int i = 1;; i++){\n        int pq = i*(i + 1)*(i + 2) / 6;\n        q.push_back(pq);\n        if (pq & 1) r.push_back(pq);\n\n        if (pq > 1e6 + 100) break;\n    }\n\n    int n = 1000000;\n\n    vi dp(n + 1, inf);\n    dp[0] = 0;\n    rep(i, q.size()){\n        rep(j, n + 1){\n            if (j - q[i] >= 0){\n                dp[j] = min(dp[j], dp[j - q[i]] + 1);\n            }\n        }\n    }\n\n    vi dp2(n + 1, inf);\n    dp2[0] = 0;\n    rep(i, r.size()){\n        rep(j, n + 1){\n            if (j - r[i] >= 0){\n                dp2[j] = min(dp2[j], dp2[j - r[i]] + 1);\n            }\n        }\n    }\n\n    int t;\n    while (cin >> t && t){\n        cout << dp[t] << \" \" << dp2[t] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define pb push_back\n#define pf push_front\n#define fi first\n#define se second\n#define BIT(x,n) bitset<n>(x)\n#define PI 3.14159265358979323846\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\n\n//-----------------------------------------------------------------------------\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint num[185];\n\tfor(int i=1;i<185;i++) {\n\t\tnum[i-1]=i*(i+1)*(i+2)/6;\n\t}\n\tint dp[1000100],dp_odd[1000100];\n\tREP(i,1000100) dp[i]=dp_odd[i]=INF;\n\tdp[0]=dp_odd[0]=0;\n\tREP(i,1000000) {\n\t\tif(dp[i]!=INF) {\n\t\t\tREP(j,185) {\n\t\t\t\tif(num[j]+i>1000000) break;\n\t\t\t\tdp[i+num[j]]=min(dp[i+num[j]],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tif(dp_odd[i]!=INF) {\n\t\t\tREP(j,185) {\n\t\t\t\tif(num[j]+i>1000000) break;\n\t\t\t\tif(num[j]%2==0) continue;\n\t\t\t\tdp_odd[i+num[j]]=min(dp_odd[i+num[j]],dp_odd[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true) {\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<dp[n]<<' '<<dp_odd[n]<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[60]={0},c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(long long int i=0;i<n;++i)\ntypedef long long int ll;\n\nint cal(int n){\n    int ret=(ll)n*(n+1)*(n+2)/6;\n    return ret;\n}\n\nint main(){\n\n    vector<int> dp(1e+6,1e+6),odp(1e+6,1e+6);\n    dp[0]=0;\n    odp[0]=0;\n    dp[1]=1;\n    odp[1]=1;\n    vector<int> c,oc;\n    for(int i=0;cal(i)<2e+6;i++){\n        c.push_back(cal(i));\n        if(cal(i)%2==1){\n            oc.push_back(cal(i));\n        }\n    }\n    for(int i=2;i<1e+6;i++){\n        for(int j=0;c[j]<=i;j++){\n            dp[i]=min(dp[i],dp[i-c[j]]+1);\n        }\n    }\n    for(int i=2;i<1e+6;i++){\n        for(int j=0;oc[j]<=i;j++){\n            odp[i]=min(odp[i],odp[i-oc[j]]+1);\n        }\n    }\n\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0){\n            break;\n        }\n        cout << dp[n] << \" \" << odp[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dpt1[1000001];\nint dpt2[1000001];\nbool dpb1[1000001];\nbool dpb2[1000001];\nint tr[301];\nint sq[301];\n\nint dp1(int s) {\n  if(dpb1[s])\n    return dpt1[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; s-sq[i] >= 0; i++) {\n    r = dp1(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt1[s] = m + 1;\n  dpb1[s] = true;\n  return m + 1;\n}\n\nint dp2(int s) {\n  if(dpb2[s])\n    return dpt2[s];\n\n  int m = 1000111000;\n  int r;\n  for(int i=1; s-sq[i] >= 0; i++) {\n    if(sq[i]%2 == 0)\n      continue;\n    r = dp2(s-sq[i]);\n    if(r < m) m = r;\n  }\n\n  dpt2[s] = m + 1;\n  dpb2[s] = true;\n  return m + 1;\n}\n\nint main() {\n\n  for(int i=1; i <= 300; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  dpt1[0] = 0;\n  dpb1[0] = true;\n  dpt2[0] = 0;\n  dpb2[0] = true;\n  int n;\n  while(cin >> n, n) {\n    cout << dp1(n) << \" \" << dp2(n) << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> A(M,INF), A_odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  A_odd[0] = 0;\n  while(t < 1000000){\n    for(int k = 0; k+t < M; ++k){\n      A[k+t] = min(A[k]+1,A[k+t]);\n      if(t%2) A_odd[k+t] = min(A_odd[k]+1,A_odd[k+t]);\n    }\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << A_odd[n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[1000], fourodd[1000];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 100010;\n\nvector<int> tetras;\nvector<int> oddTetras;\n\nint dp[MAX];\nint oddDp[MAX];\n\nint main() {\n\tfor (int i = 1; i < 100; i++) {\n\t\tint n = i * (i + 1) * (i + 2) / 6;\n\t\ttetras.push_back(n);\n\t\tif (n % 2 == 1)\n\t\t\toddTetras.push_back(n);\n\t}\n\n\tfor (int i = 0; i < MAX; i++) {\n\t\tdp[i] = oddDp[i] = i;\n\t}\n\tfor (int i = 1; i < MAX; i++) {\n\t\tfor (int j = 0; tetras[j] <= i; j++) {\n\t\t\tdp[i] = min(dp[i], dp[i - tetras[j]] + 1);\n\t\t}\n\t\tfor (int j = 0; oddTetras[j] <= i; j++) {\n\t\t\toddDp[i] = min(oddDp[i], oddDp[i - oddTetras[j]] + 1);\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n , n != 0) {\n\t\tcout << dp[n] << \" \" << oddDp[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ans1[1048576];\nint ans2[1048576];\nstd::vector<int> num34;\nstd::vector<int> numodd4;\n\nint main(int argc, char *argv[]) {\n\n  // step 1\n  for(int i = 1; ; ++i) {\n    int t = i * (i + 1) / 2;\n    if( t >= 1048576 ) break;\n    num34.push_back(t);\n  }\n  for(int i = 1; ; ++i) {\n    int t = i * (i + 1) * (i + 2) / 6;\n    if( t >= 1048576 ) break;\n    num34.push_back(t);\n    if( t % 2 == 1 ) numodd4.push_back(t);\n  }\n  std::sort(std::begin(num34), std::end(num34));\n  std::sort(std::begin(numodd4), std::end(numodd4));\n  num34.erase(std::unique(std::begin(num34), std::end(num34)), std::end(num34));\n  numodd4.erase(std::unique(std::begin(numodd4), std::end(numodd4)), std::end(numodd4));\n\n  // step 2\n  for(int i = 1; i < 1048576; ++i) {\n    int min = 1048576;\n    for(int dx : num34) {\n      int previ = i - dx;\n      if( previ < 0 ) break;\n      min = std::min(min, ans1[previ] + 1);\n    }\n    ans1[i] = min;\n  }\n\n  // step 3\n  ans2[0] = 0;\n  for(int i = 1; i < 1048576; ++i) {\n    int min = 1048576;\n    for(int dx : numodd4) {\n      int previ = i - dx;\n      if( previ < 0 ) break;\n      min = std::min(min, ans2[previ] + 1);\n    }\n    ans2[i] = min;\n  }\n\n  // step 4\n  for(;;) {\n    int N;\n    scanf(\"%d\", &N);\n    if( N == 0 ) break;\n    printf(\"%d %d\\n\", ans1[N], ans2[N]);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct State{\n    int lower,size,rest;\n    State(int lower,int size,int rest) : lower(lower),size(size),rest(rest) {};\n};\n\nint main(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        vector<int> v;\n        vector<int> odd;\n        for(int i=1;;i++){\n            int c = i*(i+1)*(i+2)/6;\n            if(c > 1000000) break;\n            v.push_back(c);\n            if(c % 2 == 1) odd.push_back(c);\n        }\n        queue<State> que;\n        que.push(State(0,0,n));\n        int ret;\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                ret = s.size;\n                break;\n            }\n            for(int i=s.lower;v[i] <= s.rest;i++){\n                que.push(State(i,s.size+1,s.rest-v[i]));\n            }\n        }\n        int oret;\n        que = queue<State>();\n        que.push(State(0,0,n));\n        while(!que.empty()){\n            State s = que.front();\n            que.pop();\n            if(s.rest == 0){\n                oret = s.size;\n                break;\n            }\n            for(int i=s.lower;odd[i] <= s.rest;i++){\n                que.push(State(i,s.size+1,s.rest-odd[i]));\n            }\n        }\n        cout << ret << \" \" << oret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// -*- coding: utf-8 -*-\n// Last-Updated : <2014/06/19 00:29:01 by samui>\n\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <climits>\n#define MP(a, b) make_pair(a, b)\n#define X first\n#define Y second\n#define rep(i,n) for(int (i) = 0; (i) < (int)(n); ++(i))\n#define rer(i,l,n) for(int (i) = l; (i) <= (int)(n); ++(i))\n#define reu(i,l,n) for(int (i) = l; (i) < (int)(n); ++(i))\ntemplate<typename T,typename U> inline void amin(T &x,U y){ if(y<x) x = y;}\ntemplate<typename T,typename U> inline void amax(T &x,U y){ if(x<y) x = y;}\ntemplate<typename TYPE,std::size_t SIZE>\nstd::size_t len(const TYPE (&array)[SIZE]){return SIZE;}\n\n\nconst int M = 1000000;\n\nvoid refresh(std::vector<int>& arr,int x){\n  rer(i,x,M){\n    amin(arr[i],arr[i-x]+1);\n\n  }\n}\nint main(int argc, char *argv[])\n{\n  std::vector<int> s(M+10);\n  std::vector<int> all(M+10,10000000);\n  std::vector<int> odd(M+10,10000000);\n  all[0] = 0;\n  odd[0] = 0;\n  //odd[0] = 0;\n  reu(i,1,M+100){\n    int x = i*(i+1)*(i+2)/6;\n    if(x > M) break;\n    rer(j,x,M){\n      amin(all[j],all[j-x]+1);\n    }\n    //refresh(all,x);\n    if(x&1) refresh(odd,x);\n  }\n  int i;\n  while(std::cin>>i){\n    if(i == 0)\n      break;\n    std::cout<<all[i]<<\" \"<<odd[i]<<std::endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n;\nvector<int> vec, vec2;\nint dp[1000005], dp2[1000005];\n\nint main(void)\n{\n  for(long long i = 1; i*(i+1)*(i+2)/6 <= 1000000; i++){\n    long long x = i*(i+1)*(i+2)/6;\n    if(x % 2) vec2.push_back(x);\n    vec.push_back(x);\n  }\n  //for(int i = 0 ;i < vec.size(); i++) cout << vec[i] << \" \"; cout << endl;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    for(int i = 0; i <= n; i++) dp[i] = dp2[i] = 1e9;\n    dp[0] = dp2[0] = 0;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < vec.size(); j++){\n        if(i+vec[j] <= n) dp[i+vec[j]] = min(dp[i+vec[j]], dp[i]+1);\n      }\n      for(int j = 0; j < vec2.size(); j++){\n        if(i+vec2[j] <= n) dp2[i+vec2[j]] = min(dp2[i+vec2[j]], dp2[i]+1);\n      }\n    }\n    //for(int i = 0; i <= n; i++) cout<< dp[i] << \" \"; cout << endl;\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define INF 1000000\n\nint main(void){\n\tint i, j, n ,c;\n\tint dp1[1000000],dp2[1000000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp1[i] = dp2[i] = INF;\n\t\tdp1[0] = dp2[0] = 0;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dp1[i] != INF || dp2[i] != INF){\n\t\t\t\tfor(j = 1,c = j * (j + 1) * (j + 2);c / 6 + i <= n;j++,c = j * (j + 1) * (j + 2)){\n\t\t\t\t\tif(dp1[c / 6 + i] > dp1[i] + 1 && dp1[i] != INF)\n\t\t\t\t\t\tdp1[c / 6 + i] = dp1[i] + 1;\n\t\t\t\t\tif(dp2[c / 6 + i] > dp2[i] + 1 && (c / 6) % 2 == 1 && dp2[i] != INF)\n\t\t\t\t\t\tdp2[c / 6 + i] = dp2[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp1[n] != INF && dp2[n] != INF)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nvoid solve(int n)\n{\n  vector<int> v;\n  for(int i = 0; ; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    if(t <= MAX)\n      v.push_back(t);\n    else\n      break;\n  }\n  for(int i = 1; v[i] <= n; i++){\n    if(v[i] & 1)\n      dp2[v[i]] = 1;\n    dp[v[i]] = 1;\n  }\n  for(int i = 1; i <= n; i++){\n    for(int j = 1; i + v[j] <= n; j++){\n      if(v[j] & 1)\n        dp2[i + v[j]] = min(dp2[i + v[j]], dp2[i] + 1);\n      dp[i + v[j]] = min(dp[i + v[j]], dp[i] + 1);\n    }\n  }\n}\n\n\n    \nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define N 1000000\n#define M 200\n\nusing namespace std;\n\nint dp[M], dp1[N], dp2[N];\n\nvoid init(){\n  dp[0]=0; dp1[0]=0; dp2[0]=0;\n  for(int i=1; i<M; ++i) dp[i]=i*(i+1)*(i+2)/6;\n  for(int i=1; i<N; ++i){\n    dp1[i]=N; dp2[i]=N;\n    for(int j=1; j<N; ++j){\n      if(i-dp[j] < 0) break;\n      dp1[i] = min(dp1[i], dp1[i-dp[j]]+1);\n      if(dp[j]%2) dp2[i] = min(dp2[i], dp2[i-dp[j]]+1);\n    }\n  }\n}\n\nint main(){\n  init();\n  int n;\n  while(1){\n    cin >> n;\n    if(!n) break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep2(i,n) for(int i=1;i<=(n);i++)\n#define rep3(i,i0,n) for(int i=i0;i<(n);i++)\n#define pb push_back\n#define mod 1000000007\nconst ll INF = 1LL << 60;\nconst int INF_i = 1 << 30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll a, ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) {return a/gcd(a,b)*b;}\n#define all(x) x.begin(), x.end()\n#define mp make_pair\nbool compare(pair<int, int> a, pair<int, int> b) {\n    if(a.first != b.first){\n        return a.first < b.first;\n        \n    }else{\n        return a.second < b.second;\n    }\n}\n\n\nbool In_map(ll y,ll x,ll h,ll w){\n    if(y<0 || x<0 || y>=h || x>=w){\n        return 0;\n    }else{\n        return 1;\n    }\n}\nconst vector<ll> dx{1,0,-1,0};\nconst vector<ll> dy{0,1,0,-1};\nint main() {\n    while(1){\n        ll N;\n        cin >> N;\n        if(N == 0) break;\n        vector<ll> tetra;\n        ll n = 1;\n        while(n*(n+1)*(n+2)/6 <= N){\n            tetra.pb(n*(n+1)*(n+2)/6);\n \n            n++;\n\n        }\n        \n        vector<ll> dp(N+2,INF);\n        dp[0] = 0;\n        vector<ll> odp(N+2,INF);\n        odp[0] = 0;\n        rep(i,tetra.size()){\n            rep(j,N+1){\n                if(j-tetra[i]>=0){\n                    dp[j] = min({dp[j], dp[j-tetra[i]]+1}); \n                    if(tetra[i]%2 == 1){\n                        odp[j] = min({odp[j], odp[j-tetra[i]]+1});\n                    }\n                }\n                \n            }\n        }\n\n        \n        /*rep(i,otetra.size()){\n            rep(j,N+1){\n                if(j-otetra[i]>=0){\n                    odp[j] = min({odp[j], odp[j-otetra[i]]+1}); ;\n                }\n            }\n        }*/\n        \n        cout << dp[N]<<\" \"<< odp[N]<< endl;\n    }\n\n\n\n    return 0;\n    \n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<numeric>\n\n#define INF (1<<28)\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=(j);i<=(k);i++)\n#define fs first\n#define sc second\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint dp1[3][1000000];\nint dp2[3][1000000];\nint main(){\n\tvi v1,v2;\n\tfor(int i=1;;i++){\n\t\tint t = i * (i+1) * (i+2) / 6;\n\t\tif (t > 1000000) break;\n\t\tv1.pb(t);\n\t\tif(t&1)v2.pb(t);\n\t}\n\trep(i,1000000) dp1[0][i] = dp2[0][i] = i;\n\trep(i,v1.size()-1){\n\t\tint n = (i+1)&1,c = i&1;\n\t\trep(j,1000000){\n\t\t\tdp1[2][j] = dp1[n][j] = dp1[c][j];\n\t\t\tif(j>=v1[i+1])\n\t\t\t\tdp1[2][j] = dp1[n][j] = min(dp1[n][j], dp1[n][j-v1[i+1]] + 1);\n\t\t}\n\t}\n\trep(i,v2.size()-1){\n\t\tint n = (i+1)&1, c = 1&i;\n\t\trep(j,1000000){\n\t\t\tdp2[2][j] = dp2[n][j] = dp2[c][j];\n\t\t\tif(j>=v2[i+1])\n\t\t\t\tdp2[2][j] = dp2[n][j] = min(dp2[n][j], dp2[n][j-v2[i+1]]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n,n){\n\t\tcout << dp1[2][n] << \" \" << dp2[2][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define NEXT(i,n) ((i+1)%(n))\nconst int N = 1000001;\nint dp1[N],dp2[N];  \nmain(){\n  vector<int> simen;\n  REP(i,1,N+1){\n    simen.push_back(i*(i+1)*(i+2)/6);\n    if (simen[i-1] > N+1)break;\n  }\n  \n  dp1[0]=0;\n  dp2[0]=0;\n  REP(i,1,N){\n    dp1[i]=10000000;\n    dp2[i]=10000000;\n    rep(j,simen.size()){\n      if (i-simen[j] < 0)break;\n      dp1[i]=min(dp1[i],dp1[i-simen[j]]+1);\n      if (simen[j]%2 == 1){\n\tdp2[i]=min(dp2[i],dp2[i-simen[j]]+1);\n      }\n    }\n  }\n  \n  int n;\n  while(cin>>n && n){\n    cout << dp1[n] <<\" \" << dp2[n] << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int  N = 1000100;\n\nint t1[200];\nint t2[200];\nint dp1[N] = {0};\nint dp2[N] = {0};\n\nint main(){\n\tint i,j,k=2,s;\n\t\n\tt1[1] = t2[1] = dp1[1] = dp2[1] = 1;\n\tfor(i = 2; i < 200; i++){\n\t\tt1[i] = t1[i-1] * (i+2) / (i-1);\n\t\tif(t1[i] > 1e+6) break;\n\t\tdp1[t1[i]] = 1;\n\t\tif(t1[i]%2){ dp2[t1[i]] = 1; t2[k++] = t1[i];}\n\t}\n\n\tfor(i = 2; i < N; i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j = 1; t2[j] < i && j < 200; j++){\n\t\t\tif(!dp2[i] || (1 + dp2[i-t2[j]]) < (dp2[i])){\n\t\t\t\tdp2[i] = 1 + dp2[i-t2[j]];\n\t\t\t}\n\t\t}\n\t\tif(dp1[i]) continue;\n\t\tfor(j = 1; t1[j] < i; j++){\n\t\t\tif(!dp1[i] || (1 + dp1[i-t1[j]]) < (dp1[i])){\n\t\t\t\tdp1[i] = 1 + dp1[i-t1[j]];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(cin >> s, s)\n\t\tcout << dp1[s] << ' ' << dp2[s] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main() {\n    for(int i = 1;i <= MAX;i++) {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n + 2) / 6 <= MAX;n++) {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for(int i = a;i <= MAX;i++) {\n            dp1[i] = min(dp1[i],dp1[i - a] + 1);\n        }\n        if(a % 2 == 0)continue;\n        for(int i = a;i <= MAX;i++) {\n            dp2[i] = min(dp2[i],dp2[i - a] + 1);\n        }\n    }\n\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n\nconst int N = 1000000 + 1;\nll dp[N], dp2[N];\n\nint main() {\n\n    dp[0] = dp2[0] = 0;\n    for (int i=1; i<=N; ++i) {\n        dp[i] = dp2[i] = i;\n        for (int n=1;; ++n) {\n            int p = n*(n+1)*(n+2)/6;\n            if (p > i) break;\n            dp[i] = min(dp[i], dp[i-p]+1);\n            if (p%2) {\n                dp2[i] = min(dp2[i], dp2[i-p]+1);\n            }\n        }\n    }\n\n    int n;\n    while (cin >> n and n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[5000];//正四面体数\nvector<ll>v;\nll dp[1000000], dp2[1000000];\nint main() {\n\tv.pb(0);\n\tll n, now = 1, now2 = 1;\n\trep(i, 5000) {\n\t\tss[i] = (ll)(i*(i + 1)*(i + 2) / 6);\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 1000000) {\n\t\tif (i < 2) { dp[i] = i; dp2[i] = i;continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], (ll)i / ss[j] + dp[i%ss[j]]);\n\t\tif (i >= v[now2 + 1])++now2;\n\t\tdp2[i] = i / v[now2] + dp2[i%v[now2]];\n\t\tfor (int j = now2 - 1; j >= 1; --j)dp2[i] = min(dp2[i], (ll)i / v[j] + dp2[i%v[j]]);\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\nint dp1[1000001];\nint dp2[1000001];\n\nset<int> por;\nvector<int> porv;\nset<int> pork;\nvector<int> porkv;\n\nint rec1(int n) {\n\tcout<<n<<endl;\n\tif(n < 0) return INF;\n\tif(dp1[n] != INF) return dp1[n];\n\tif(por.count(n) != 0) return 1;\n\tint res = INF;\n\tREP(i, porv.size()) {\n\t\tres = min(res, rec1(n - porv[i] ) + 1);\n\t}\n\treturn dp1[n] = res;\n}\n\nint rec2(int n) {\n\tcout<<n<<endl;\n\tif(n < 0) return INF;\n\tif(dp2[n] != INF) return dp2[n];\n\tif(pork.count(n) != 0) return 1;\n\tint res = INF;\n\tREP(i, porkv.size()) {\n\t\tres = min(res, rec2(n - porkv[i]) + 1);\n\t}\n\treturn dp2[n] = res;\n}\n\nint main() {\n\tREP(i, 1000001) dp1[i] = dp2[i] = INF;\n\tdp1[0] = 0;\n\tdp2[0] = 0;\n\tint buf = 1;\n\twhile(buf * (buf + 1) * (buf + 2) / 6 <= pow(10, 6)) {\n\t\tpor.insert(buf * (buf + 1) * (buf + 2) / 6);\n\t\tporv.pb(buf * (buf + 1) * (buf + 2) / 6);\n\t\tif((buf * (buf + 1) * (buf + 2) / 6) % 2 == 1) {\n\t\t\tpork.insert(buf * (buf + 1) * (buf + 2) / 6);\n\t\t\tporkv.pb(buf * (buf + 1) * (buf + 2) / 6);\n\t\t}\n\t\t++buf;\n\t}\n\tsort(ALL(porv));\n\tsort(ALL(porkv));\n\tREP(i, 1000001) {\n\t\tif(i == 0) dp1[i] = 0;\n\t\telse if(por.count(i) != 0) dp1[i] = 1;\n\t\telse {\n\t\t\tint roc = 0;\n\t\t\tint res = INF;\n\t\t\twhile(roc < porv.size() && i - porv[roc] >= 0) {\n\t\t\t\tres = min(res, dp1[i - porv[roc]] + 1);\n\t\t\t\t++roc;\n\t\t\t}\n\t\t\tdp1[i] = res;\n\t\t}\n\t}\n\tREP(i, 1000001) {\n\t\tif(i == 0) dp2[i] = 0;\n\t\telse if(pork.count(i) != 0) dp2[i] = 1;\n\t\telse {\n\t\t\tint roc = 0;\n\t\t\tint res = INF;\n\t\t\twhile(roc < porkv.size() && i - porkv[roc] >= 0) {\n\t\t\t\tres = min(res, dp2[i - porkv[roc]] + 1);\n\t\t\t\t++roc;\n\t\t\t}\n\t\t\tdp2[i] = res;\n\t\t}\n\t}\n\twhile(1) {\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tcout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint all[1000001];\nint odd[1000001];\n\nint const INF = 1<<29;\n\nint main() {\n  \n  fill(all, all+1000001, INF);\n  fill(odd, odd+1000001, INF);\n  \n  all[0] = odd[0] = 0;\n  \n  for(int i=1; ; i++) {\n    int n = i*(i+1)*(i+2);\n    for(int j=n; j<=1000000; j++) {\n      all[j] = min(all[j-n]+1, all[j]);\n      if(n % 2) {\n\todd[j] = min(odd[j-n]+1, odd[j]);\n      }\n    }\n  }\n  \n  int N;\n  while(cin >> N && N) {\n    cout << all[N] << ' ' << odd[N] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tmemset(dp, 0, sizeof(dp));\n\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=1000000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tdp[i][j] = 0;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<int ,P> P3;\ntypedef pair<P ,P> PP;\nconst ll MOD = ll(1e9+7);\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e6 + 5);\nconst double EPS = 1e-6;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nint main() {\n    vector<int> a, b;\n    for(int i=1;i<200;i++){\n        int x = i*(i+1)*(i+2)/6;\n        a.push_back(x);\n        if(x%2)b.push_back(x);\n    }\n    reverse(ALL(a));\n    reverse(ALL(b));\n\n    int dp1[MAX_N], dp2[MAX_N];\n    fill(dp1,dp1+MAX_N,IINF);\n    fill(dp2,dp2+MAX_N,IINF);\n    dp1[0] = dp2[0] = 0;\n    for(int i=1;i<MAX_N;i++){\n        for(auto j : a){\n            if(i >= j){\n                dp1[i] = min(dp1[i], dp1[i-j]+1);\n            }\n        }\n    }\n    for(int i=1;i<MAX_N;i++){\n        for(auto j : b){\n            if(i >= j){\n                dp2[i] = min(dp2[i], dp2[i-j]+1);\n            }\n        }\n    }\n\n    int n;\n    while(cin >> n, n){\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n#define MAX 1000001\n\nint main(){\n    int n;\n    int ans_odd[MAX], ans[MAX];\n    int tmp, i = 1, j;\n    vector<int> odd, normal;\n\n    for(j = 0; j < MAX; j++){\n        ans_odd[j] = j;\n        ans[j] = j;\n    }\n\n    while(tmp < MAX){\n        tmp = i * (i + 1) * (i + 2) / 6;\n        normal.push_back(tmp);\n        if (tmp % 2 == 1) odd.push_back(tmp);\n        i++;\n    }\n\n    ans_odd[0] = 0;\n    ans[0] = 0;\n    for(i = 1; i < MAX; i++){\n        for(j = 0; j < normal.size(); j++){\n            if(normal[j] > i) break;\n            ans[i] = min(ans[i], ans[i - normal[j]] + 1);\n        }\n    }\n\n    for(i = 1; i < MAX; i++){\n        ans_odd[i] = i;\n        for(j = 0; j < odd.size(); j++){\n            if(odd[j] > i) break;\n            ans_odd[i] = min(ans_odd[i], ans_odd[i - odd[j]] + 1);\n        }\n    }\n\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n        printf(\"%d %d\\n\", ans[n], ans_odd[n]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint dp[100001];\nint dp2[100001];\nint dfs(int n){\n\tif(~dp[n]) return dp[n];\n\tif(n == 0) return 0;\n\tint ans = 9999;\n\tfor(int i = 1 ; i*(i+1)*(i+2)/6 <= n ; i++){\n\t\tans = min(dfs(n-i*(i+1)*(i+2)/6)+1,ans);\n\t}\n\treturn dp[n] = ans;\n}\nint dfs2(int n){\n\tif(~dp2[n]) return dp2[n];\n\tif(n == 0) return 0;\n\tint ans = 9999;\n\tfor(int i = 1 ; i*(i+1)*(i+2)/6 <= n ; i++){\n\t\tif( (i*(i+1)*(i+2)/6) % 2)ans = min(dfs2(n-i*(i+1)*(i+2)/6)+1,ans);\n\t}\n\treturn dp2[n] = ans;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\trep(i,100001) dp[i] = -1 , dp2[i] = -1;\n\t\tcout << dfs(n) << \" \" << dfs2(n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GRIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ?????¬???????????¬??????\n#pragma region MACRO\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define PED cout << \"\\n\"\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n#define REP(i,x,n) for(int i=x; i<(int)n; ++i)\n#define repi(i,n) for(int i=0; i<=(int)n; ++i)\n#define REPI(i,x,n) for(int i=x; i<=(int)n; ++i)\n#define ILP while(true)\n#define FOR(i,c) for(__typeof((c).begin())!=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#pragma endregion\n\n// ???\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pss;\ntypedef pair<string, int> psi;\ntypedef pair<int, string> pis;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long double> vld;\ntypedef vector<long> vl;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\n#pragma endregion\n\n// Effective std\n#pragma region ESTD\ntemplate<typename C, typename T> int count(C& c, T t) { return count(ALL(c), t); }\ntemplate<typename C, typename F> int count_if(C& c, F f) { return count_if(ALL(c), f); }\ntemplate<typename C, typename T> void erase(C& c, T t) { remove(ALL(c), t), c.end(); }\ntemplate<typename C> void remove(vector<C>& c, unsigned int index) { c.erase(c.begin()+index); }\ntemplate<typename C, typename T, typename U> void replace(C& c, T t, U u) { replace(ALL(c), t, u); }\ntemplate<typename C, typename F, typename U> void replace_if(C& c, F f, U u) { (ALL(c), f, u); }\ntemplate<typename C> void reverse(C& c) { reverse(ALL(c)); }\ntemplate<typename C> void sort(C& c) { sort(ALL(c)); }\ntemplate<typename C, typename Pred> void sort(C& c, Pred p) { sort(ALL(c), p); }\n#pragma endregion\n\n// ?????°\n#pragma region CONST_VAL\nconstexpr int PI = (2*acos(0.0));\nconstexpr int EPS = (1e-9);\nconstexpr int MOD = (int)(1e9+7);\nconstexpr int INF = 100000000;\n#pragma endregion\n\n#define int long long\n\nint dp[1000001];\nint odp[1000001];\n\nsigned main()\n{\n    for(int i=0; i<1000001; ++i) {\n        dp[i] = i;\n        odp[i] = i;\n    }\n    for(int i=1;; ++i) {\n        int a = i*(i+1)*(i+2)/6;\n        if(a>=1000000) break;\n        for(int j=a; j<1000000; ++j) {\n            dp[j] = min(dp[j], dp[j-a] + 1);\n            if(a&1) odp[j] = min(odp[j], odp[j-a] + 1);\n        }\n    }\n    int n;\n    while(cin>>n, n) {\n        cout << dp[n] << \" \" << odp[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tvector<int> data;\n\tvector<int> data2;\n\tvector<int> dp(1000001, 10);\n\tvector<int> dp2(1000001, 1000000);\n\tlong long int n = 0;\n\tfor (long long int i = 1; ; i++) {\n\t\tn = i*(i+1)*(i+2)/6;\n\t\tif (n > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tdata.push_back(n);\n\t\tdp[n] = 1;\n\t\tif (n % 2 == 1) {\n\t\t\tdata2.push_back(n);\n\t\t\tdp2[n] = 1;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < data.size(); i++) {\n\t\tfor (int j = data[i]+1; j <= 1000000; j++) {\n\t\t\tdp[j] = min(dp[j], dp[j-data[i]]+1);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < data2.size(); i++) {\n\t\tfor (int j = data2[i]+1; j <= 1000000; j++) {\n\t\t\tdp2[j] = min(dp2[j], dp2[j-data2[i]]+1);\n\t\t}\n\t}\n\n\tint a;\n\twhile (cin >> a) {\n\n\t\tif (a == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcout << dp[a] << ' ' << dp2[a] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nvector<int> a;\nvector<int> memo1(1000005, -1);\nvector<int> memo2(1000005, -1);\n\nint dfs1(int s)\n{\n\tif(s == 0) return 0;\n\n\tif(memo1[s] != -1) {\n\t\treturn memo1[s];\n\t}\n\n\tint res = INF;\n\n\tfor(int i = a.size() - 1; i >= 0; --i) {\n\t\tif(s - a[i] >= 0) {\n\t\t\tres = min(res, dfs1(s - a[i]) + 1);\n\t\t}\n\t}\n\n\treturn memo1[s] = res;\n}\n\nint dfs2(int s)\n{\n\tif(s == 0) return 0;\n\n\tif(memo2[s] != -1) {\n\t\treturn memo2[s];\n\t}\n\n\tint res = INF;\n\n\tfor(int i = a.size() - 1; i >= 0; --i) {\n\t\tif(s - a[i] >= 0 && (a[i] & 1)) {\n\t\t\tres = min(res, dfs2(s - a[i]) + 1);\n\t\t}\n\t}\n\n\treturn memo2[s] = res;\n}\n\nint main()\n{\n\tint n;\n\n\tfor(int i = 1; i * (i + 1) * (i + 2) / 6 < 1000004; ++i) {\n\t\ta.push_back(i * (i + 1) * (i + 2) / 6);\n\t}\n\n\t//cout << a.size() << endl;\n\n\twhile(cin >> n, n) {\n\t\tcout << dfs1(n) << ' ' << dfs2(n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\nusing namespace std;\n#define ull unsigned long long\nint memo[150];\nint  dp[1000002];\nint  dp2[1000002];\nvoid inset(){\n\tdp[0]=0;\n\tfill(dp,dp+1000001,10000);\n\tfill(dp2,dp2+1000001,10000);\n\tdp[0]=0;\n\tdp2[0]=0;\n\trep(i,1,150){\n\t\tmemo[i]=i*(i+1)*(i+2),memo[i]/=6;\n\t\trep(j,1,1000001)\n\t\t\tif(j-memo[i]>=0){\n\t\tif(dp[j]>dp[j-memo[i]]+1)dp[j]=dp[j-memo[i]]+1;\n\t\tif(memo[i]&1)if(dp2[j]>dp2[j-memo[i]]+1)dp2[j]=dp2[j-memo[i]]+1;\n\t\t}\n\t}\n\t//rep(i,1,1000001){\n\t//\tif(dp2[i]==0){\n\t//\tprintf(\"[%d]%d\\n\",i,dp2[i]);\n\t//\tbreak;\n\t//\t}\n\t}\n}\n\n\nint main(void){\n\tinset();\n\tint x;\n\twhile(true){\n\t\tcin>>x;if(x==0)return(0);\n\t\tcout<<dp[x]<<\" \"<<dp2[x]<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][100010] = {0};\n\nvoid solve(int n) {\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t\tif (dp[i][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=100000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t\tif (dp[i%2][n]) break;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nint p[1000001];\nint memo[1000001];\nint memo2[1000001];\n\nint solve(int n, int count){\n  \n  if(!n) return 0;\n  if(n <= 0 || !count) return INF;\n  if(memo[n]) return memo[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n; i++) ans = min(ans, solve(n-p[i], count-1)+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n;i++){\n    if(!(p[i]%2)) continue;\n    ans = min(ans, solve2(n-p[i])+1);\n  }\n  \n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  for(int i=0;i<=1000000;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i++) solve2(i);\n  \n  while(cin >> n, n) cout << solve(n, 5) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1000100\n\nint dp[SIZE], dp_o[SIZE];\n\nint main(){\n  for(int i=0;i<SIZE;i++) dp[i] = dp_o[i] = i;\n\n  for(int i=2;(ll)i*(i+1)*(i+2)<SIZE*6;i++){\n    int num = (ll)i*(i+1)*(i+2)/6;\n\n    for(int j=0;j<SIZE-num;j++){\n      dp[j+num] = min(dp[j+num], dp[j] + 1);\n      if(num%2)\n        dp_o[j+num] = min(dp_o[j+num], dp_o[j] + 1);\n    }\n  }\n\n  int n;\n\n  while(1){\n    scanf(\"%d\", &n);\n    if(!n) break;\n\n    printf(\"%d %d\\n\", dp[n], dp_o[n]);\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\n\n#define arrsize 500000\n\nll memo[arrsize];\nll memo2[arrsize];\n\nll calc(int n) {\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nint dfs(int depth, int n) {\n  int ans = 9999;\n  if (n < arrsize && memo[n] != 0) return memo[n];\n  for (int i = sqrt(n); i >= 1; i--) {\n    \n    ll t = calc(i);\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < arrsize) {\n\tmemo[n] = depth;\n      }\n      return depth;\n    }\n    ans = min(ans, dfs(depth + 1, n - t));\n  }\n  if (n < arrsize)\n    memo[n] = ans;\n  return ans;\n}\n\nint dfs_odd(int depth, int n) {\n  int ans = 9999;\n  if (n < arrsize && memo2[n] != 0) return memo2[n];\n  for (int i = sqrt(n); i >= 1; i--) {\n    if (i % 2 == 0) continue;\n    ll t = calc(i);\n    if (t % 2 == 0) continue;\n    if (n - t < 0) continue;\n    if (n - t == 0) {\n      if (n < arrsize)\n\tmemo2[n] = depth;\n      return depth;\n    }\n    ans = min(ans, dfs_odd(depth + 1, n - t));\n  }\n  if (n < arrsize)\n    memo2[n] = ans;\n  return ans;\n}\n  \nint main() {\n  int N;\n  while (cin >> N, N != 0) {\n    for (int i = 0; i < arrsize; i++) {\n      memo[i] = 0;\n      memo2[i] = 0;\n   }\n    cout << dfs(1, N) << \" \" << dfs_odd(1, N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n// f[k] := k テ」ツつ津ヲツュツ」テ・ツ崢崚ゥツ敖「テ、ツスツ禿ヲツ閉ーテ」ツ?ョテ・ツ陳古」ツ?ィテ」ツ?療」ツ?ヲティツ。ツィテ」ツ?凖」ツ?淌」ツつ?」ツ?ォテ・ツソツ?ィツヲツ?」ツ?ェテヲツュツ」テ・ツ崢崚ゥツ敖「テ、ツスツ禿ヲツ閉ーテ」ツ?ョテ・ツ?凝ヲツ閉ーテ」ツ?ョテヲツ慊?・ツーツ湘・ツ?、\nint f[1000001];\n// g[k] := k テ」ツつ津・ツ・ツ?ヲツ閉ーテ」ツ?ョテヲツュツ」テ・ツ崢崚ゥツ敖「テ、ツスツ禿ヲツ閉ーテ」ツ?ョテ・ツ陳古」ツ?ィテ」ツ?療」ツ?ヲティツ。ツィテ」ツ?凖」ツ?淌」ツつ?」ツ?ォテ・ツソツ?ィツヲツ?」ツ?ェテ・ツ・ツ?ヲツ閉ーテ」ツ?ョテヲツュツ」テ・ツ崢崚ゥツ敖「テ、ツスツ禿ヲツ閉ーテ」ツ?ョテ・ツ?凝ヲツ閉ーテ」ツ?ョテヲツ慊?・ツーツ湘・ツ?、\nint g[1000001];\n\nint main(){\n\tfill(f, f + 1000001, INF);\n\tfill(g, g + 1000001, INF);\n\tvector<int> a, b;\n\tfor(int i = 0 ; true ; i++ ){\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif( 1e+6 < k ) break;\n\t\t\n\t\tif( k % 2 == 1 ){\n\t\t\tb.push_back(k);\n\t\t\tg[k] = 1;\n\t\t}\n\t\ta.push_back(k);\n\t\tf[k] = 1;\n\t}\n\tfor(int i = 0 ; i < 1000001 ; i++ ){\n\t\tif( f[i] ){\n\t\t\tfor(int j = 0 ; j < a.size() ; j++ ){\n\t\t\t\tint k = i + a[j];\n\t\t\t\tif( 1e+6 < k ) break;\n\t\t\t\tf[k] = min(f[k], f[i] + 1);\n\t\t\t}\n\t\t}\n\t\tif( g[i] ){\n\t\t\tfor(int j = 0 ; j < b.size() ; j++ ){\n\t\t\t\tint k = i + b[j];\n\t\t\t\tif( 1e+6 < k ) break;\n\t\t\t\tg[k] = min(g[k], g[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint N;\n\twhile( cin >> N , N ){\n\t\tcout << f[N] << \" \" << g[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    vector<int> v(201);\n    for(int i=1; i<=200; i++){\n        v[i] = i * (i + 1) * (i + 2) / 6;\n    }\n\n    vector<int> dp1(1000010, 1e9);\n    dp1[0] = 0;\n    auto dp2 = dp1;\n\n    for(int i=1; i<=200; i++){\n        for(int j=0; j<=1000005; j++){\n            if(j - v[i] >= 0) dp1[j] = min(dp1[j], dp1[j-v[i]] + 1);\n\n            if(v[i] % 2){\n                if(j - v[i] >= 0) dp2[j] = min(dp2[j], dp2[j-v[i]] + 1);\n            }\n        }\n    }\n\n    while(1){\n        int n; cin>>n;\n        if(n == 0) return 0;\n\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << \"\\n\"\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[3000][3000];\nchar field[200][200];\n\nll max_p[200010],min_p[200010];\n\nvoid func(){\n  max_p[0] = min_p[0] = 0;\n  rep(i,1,200010){\n    min_p[i] = max_p[i] = i;\n    rep(j,1,200010){\n      ll test = j * (j + 1) * (j + 2) / 6;\n      if(i - test < 0)break;\n      min_p[i] = min(min_p[i] ,min_p[i - test] + 1);\n      if(test % 2)max_p[i] = min(max_p[i],max_p[i - test] + 1);\n    }\n  }\n}\n\nint main(){\n  func();\n  while(cin >> n,n){\n    cout << min_p[n] << \" \" << max_p[n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nchar dp1[1000001],dp2[1000001];\n\nint main(){\n    int t[181];\n    \n    for(int i = 1;i <= 180;++i)\n        t[i] = i * (i + 1) * (i + 2) / 6;\n    \n    dp1[0] = dp2[0] = 0;\n    \n    for(int i = 1;i <= 1000000;++i)\n        dp1[i] = dp2[i] = 40;\n    \n    for(int i = 1;i <= 180;++i){\n        int x = t[i];\n        \n        for(int j = x;j <= 1000000;++j)\n            if(1 + dp1[j - x] < dp1[j]) dp1[j] = 1 + dp1[j - x];\n    }\n    \n    for(int i = 1;i <= 180;++i){\n        int x = t[i];\n        \n        if(x & 1)\n            for(int j = x;j <= 1000000;++j)\n                if(1 + dp2[j - x] < dp2[j]) dp2[j] = 1 + dp2[j - x];\n    }\n    \n    int n;\n    \n    while(true){\n        scanf(\"%d\",&n);\n        \n        if(n == 0) break;\n        \n        printf(\"%d %d\\n\",dp1[n],dp2[n]);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main()\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    /*for(int i=1;i<=x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)\n\tbreak;\n      count++;\n      if(tmp%2==1)\n\tcount_ki++;\n\t}*/\n\n    int coin[x];\n    int coin_ki[x];\n    //fill(coin,coin + x + 1,-1);\n    //fill(coin_ki,coin_ki + x + 1,-1);\n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      coin[i-1]=i*(i+1)*(i+2)/6;\n      count++;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki++;\n      }\n      if(coin[i-1]>x)break;\n    }\n\n    int dp[x+1];\n    fill(dp,dp + x + 1,100000);\n  \n\n    /*for(int i=0;i<=x;i++)\n      printf(\"dp[%d]=%d\\n\",i,dp[i]);\n    */\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nvoid solve(int n)\n{\n  vector<int> v;\n  for(int i = 0; ; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    if(t <= n)\n      v.push_back(t);\n    else\n      break;\n  }\n  for(int i = 0; i <= n; i++){\n    for(int j = 0; j < v.size(); j++){\n      if(i + v[j] <= n){\n        if(v[j] & 1)\n          dp2[i + v[j]] = min(dp2[i + v[j]], dp2[i] + 1);\n        dp[i + v[j]] = min(dp[i + v[j]], dp[i] + 1);\n      }\n    }\n  }\n}\n    \nint main()\n{\n  int n;\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }else{\n      fill(dp, dp + n + 1, MAX);\n      fill(dp2, dp2 + n + 1, MAX);\n      solve(n);\n      cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#define V_MAX 1000\nusing namespace std;\n\nint main(){\n  int n;\n  vector<int> v(V_MAX);\n  int i=0,mx=0;\n  int p[200],size;\n\n  while( cin>>n && n ){\n    if( i<V_MAX ) v[i]=n;\n    else          v.push_back(n);\n    i++;\n    mx=max(mx,n);\n  }\n  int vSize=i;\n\n  p[0]=0;\n  for( size=1; ; size++ ){\n    p[size]= size*(size+1)*(size+2)/6;\n    if( p[size]>mx ) break;\n  }\n\n  int dMAX = p[size-1] + 1;\n  int dp1[dMAX],dp2[dMAX];\n  int m,j ;\n  fill( dp1,dp1+dMAX,INT_MAX );\n  fill( dp2,dp2+dMAX,INT_MAX );\n\n  dp1[0]=0;\n  for( i=1;i<size;i++){\n    m=p[i];\n    for( j=m;j<dMAX;j++ )\n      dp1[j] = min( dp1[j],dp1[j-m]+1 );\n  }\n\n  dp2[0]=0;\n  for( i=1;i<size;i++){\n    if( p[i]%2==0 ) continue;\n    m=p[i];\n    for( j=m;j<dMAX;j++ )\n      dp2[j] = min( dp2[j],dp2[j-m]+1 );\n  }\n\n\n  \n  for( i=0;i<vSize;i++ )\n    cout << dp1[ v[i] ] << \" \" << dp2[ v[i] ] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct P{\n  int sum;\n  char k,n;\n  P(){}\n  P(int S,int K,int N){ sum=S;k=K;n=N; }\n};\n\nint a[200];\n\nint main(){\n  int n, ans1,ans2;\n  queue<P> q;\n  P p;\n\n  for( int i=1;i<200 ; i++ )\n    if( (a[i]=i*(i+1)*(i+2)/6)>1000000 )\n      break;\n\n  int size,n2;\n  while( cin>>n && n ){\n\n    ans1=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<200;i++ ){\n      if( a[i]==n ){\n\tans1=1; size=i+1;\n\tbreak;\n      }\n      if( a[i]<n ) q.push( P(a[i],i,1) );\n      else{\n\tsize=i; break;\n      }\n    }\n    while( !ans1 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      for( int i=p.k,j;i<size;i++ ){\n\tj=p.sum+a[i];\n\tif( j==n ){\n\t  ans1=n2; break;\n\t}\n\tq.push( P(j,i,n2) );\n      }\n    }\n\n    ans2=0;\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<size;i++ ){\n      if( a[i]%2==1 ){\n\tif( a[i]==n ){ ans2=1; break; }\n\tq.push( P(a[i],i,1) );\n      }\n    }\n    while( !ans2 ){\n      p=q.front(); q.pop();\n      n2=p.n+1;\n      for( int i=p.k,j;i<size;i++ ){\n\tif( a[i]%2==1 ){\n\t  j=p.sum+a[i];\n\t  if( j==n ){\n\t    ans2=n2; break;\n\t  }\n\t  q.push( P(j,i,n2) );\n\t}\n      }\n    }\n    \n    cout << ans1 << \" \" << ans2 << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dp[1000010];\nint dp2[1000010];\n\nsigned main() {\n\tint n;\n\trep(i, 0, 1000010) {\n\t\tdp[i] = 10;\n\t\tdp2[i] = 1000000;\n\t}\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\trep(i, 1, 150) {\n\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\tif (a > 1000000) break;\n\t\trep(j, 0, 1000001) {\n\t\t\tif (j + a > 1000000) break;\n\t\t\tdp[j + a] = min(dp[j + a], dp[j] + 1);\n\t\t\tif (a % 2 == 0) continue;\n\t\t\tdp2[j + a] = min(dp2[j + a], dp2[j] + 1);\n\t\t}\n\t}\n\twhile (cin >> n && n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dp[1000010];\nint dp2[1000010];\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\trep(i, 0, n+1) {\n\t\t\tdp[i] = 10;\n\t\t\tdp2[i] = 10000000;\n\t\t}\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\trep(i, 1, 150) {\n\t\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\t\tif (a > n) break;\n\t\t\trep(j, 0, n + 1) {\n\t\t\t\tif (j + a > n) break;\n\t\t\t\tdp[j + a] = min(dp[j + a], dp[j] + 1);\n\t\t\t\tif (a % 2 == 0) continue;\n\t\t\t\tdp2[j + a] = min(dp2[j + a], dp2[j] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define vec vector\n\nusing namespace std;\n\nconst int inf = 1e8;\n\nint s(int n){\n    return n*(n+1)*(n+2)/6;\n}\nint main(){\n  vec<int> d1(2e6+1, inf), d2(2e6+1, inf);\n  d1[0] = d2[0] = 0;\n  rep(i, 1000){\n      int n = s(i+1);\n      rep(j, 2e6+1){\n          if(j + n < 2e6+1) {\n          d1[j+n] = min(d1[j]+1, d1[j+n]);\n          if(n%2==1) d2[j+n] = min(d2[j]+1, d2[j+n]);\n          }\n      }\n  }\n  int x;\n  while(cin >> x, x != 0){\n      cout << d1[x] <<\" \"<< d2[x] <<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n;\n\tint i1,i2;\n\tint nn;\n\tint p;\n\tint min;\n\tint num;\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\n\t\tvector<int> pollock(n+1,0);\n\t\tvector<int> pollock2(n+1,0);\n\t\tvector<int> p;\n\t\tvector<int> p2;\n\t\tnn=1;\n\t\tnum=(nn*(nn+1)*(nn+2))/6;\n\n\t\tfor(i1=1;i1<=n;i1++){\t\t\t\n\n\t\t\tif(i1==num) {\n\t\t\t\tif(i1%2==1){\n\t\t\t\t\tp.push_back(i1);\n\t\t\t\t\tp2.push_back(i1);\n\t\t\t\t\tnn++;\n\t\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6;\n\t\t\t\t\tpollock[i1]=1;\n\t\t\t\t\tpollock2[i1]=1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnn++;\n\t\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6;\n\t\t\t\t\tp.push_back(i1);\n\t\t\t\t\tpollock[i1]=1;\n\t\t\t\t\tmin=100000;\n\t\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpollock2[i1]=min+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p.size();i2++){\n\t\t\t\t\tif((pollock[i1-p[i2]])<min){\n\t\t\t\t\t\tmin=pollock[i1-p[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock[i1]=min+1;\n\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock2[i1]=min+1;\n\t\t\t}\n\t\t\t//cout<<pollock[i1]<<\" \";\n\n\t\t}\n\n\t\tcout << pollock[n] << \" \" << pollock2[n] << endl;\n\t\t\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int N,S[1000],SS[1000],SSS[1000],P[1000001],OP[1000001],a=0;\n  S[0]=0;P[0]=0;OP[0]=0;\n  for(int i=1;i<1000001;i++){\n    OP[i]=P[i]=10000001;\n  }\n  for(int i=1;i<300;i++){\n    S[i]=S[i-1]+i;\n  }\n  SS[0]=0;\n  for(int i=1;i<300;i++){\n    SS[i]=SS[i-1]+S[i];\n    if(SS[i]%2==1)SSS[a++]=SS[i];\n  }\n  for(int i=0;i<a;i++){\n    for(int j=SSS[i];j<1000001;j++){\n      OP[j]=min(OP[j],OP[j-SSS[i]]+1);\n    }\n  }\n  for(int i=1;i<300;i++){\n    for(int j=SS[i];j<1000001;j++){\n      P[j]=min(P[j],P[j-SS[i]]+1);\n    }\n  }\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    cout<<P[N]<<\" \"<<OP[N]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nint memo[1000001][6];\nint memo2[1000001];\n\nint solve(int n, int count){\n\n  if(!n) return 0;\n  if(n <= 0 || !count) return INF;\n  if(memo[n][count]) return memo[n][count];\n\n  int ans = INF;\n  for(int i=0,k=0; k=i*(i+1)*(i+2)/6, k<=n; i++){\n    ans = min(ans, solve(n-k, count-1)+1);\n  }\n\n  return memo[n][count] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n\n  int ans = INF;\n  for(int i=0,k=0;k=i*(i+1)*(i+2)/6, k<=n; i++){\n    if(!(k%2)) continue;\n    ans = min(ans, solve2(n-k)+1);\n  }\n\n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  for(int i=1;i<=1000000;i++) solve2(i);\n\n  while(cin >> n, n)\n    cout << solve(n, 5) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<map>\nusing namespace std;\nint a[1001],ta[1001],tta[1001];\nint dp[1000021],dp2[1000010];\nconst int INF=99999999;\nint main(){\n\ta[1]=1,ta[1]=1,tta[1]=1;\n\tint cnt=1;\n\tfor(int i=2;i<=1000;i++)a[i]=i+a[i-1];\n\tfor(int i=2;i<=1000;i++){\n\tta[i]=a[i]+ta[i-1];\n\tif(ta[i]%2==1)tta[++cnt]=ta[i];\n\t}\n\n\tfill(dp,dp+1000001,INF);\n\tfill(dp2,dp2+1000001,INF);\n\tdp[0]=0,dp2[0]=0;\n\tfor(int i=1;i<=200;i++){\n\t\tfor(int j=1;j<=1000000;j++){\n\t\tif(j>=ta[i])dp[j]=min(dp[j],dp[j-ta[i]]+1);\n\t\t}//\n\t}//endfor\n\tfor(int i=1;i<=100;i++){\n\t\tfor(int j=1;j<=1000000;j++){\n\t\tif(j>=tta[i])dp2[j]=min(dp2[j],dp2[j-tta[i]]+1);\n\t\t}\n\t}//endfor\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}//endwhile\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint list[181],dp[999999],dq[999999];\nint main(){\n    for(int i=0;i<999999;i++){\n        dp[i]=1000000;\n        dq[i]=1000000;\n    }\n    for(int i=0;i<181;i++){\n        list[i]=(i+1)*(i+2)*(i+3)/6;\n        dp[list[i]-1]=1;\n        if(i%4==0) dq[list[i]-1]=1;\n    }\n    for(int i=0;i<999999;i++){\n        for(int j=0;list[j]<=i;j++){\n            if(dp[i]>dp[i-list[j]]+1) dp[i]=dp[i-list[j]]+1;\n            if(j%4==0&&dq[i]>dq[i-list[j]]+1) dq[i]=dq[i-list[j]]+1;\n        }\n    }\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n==0) return 0;\n        printf(\"%d %d\\n\",dp[n-1],dq[n-1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint m;\nint f(int n) { return n*(n+1)*(n+2)/6; }\nvector<int> l1, l2;\n\nvoid r(int n, int step, vector<int> &l, int p) {\n  if(step+1 >= m) return;\n \n  for(int i=p; i>=0; i--) {\n    int n2 = n-l[i];\n    if(n2<0) continue;\n    if(n2==0) {\n      m = step+1;\n      return;\n    }\n    if(n2>0) {\n      r(n2, step+1, l, i);\n    }\n  }\n  \n}\n\nint main() {\n  while(1) {\n    vector<int> l1, l2;\n    int n;\n\n     cin >> n;\n     if(n==0) break;\n    \n    // not over\n    for(int i=1; true; i++) {\n      int mm = f(i);\n      if(mm>n) break;\n      l1.push_back(mm);\n      if(mm&1) l2.push_back(mm);\n    }\n\n    m = n;\n    r(n, 0, l1, l1.size()-1);\n    cout << m;\n\n    cout << ' ';\n    \n    m = n;\n    r(n, 0, l2, l2.size()-1);\n    cout << m;\n\n    cout << \"\\n\";\n\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<map>\nusing namespace std;\nint a[1001],ta[1001],tta[1001];\nint dp[1000021];\nconst int INF=99999999;\nint main(){\n\ta[1]=1,ta[1]=1,tta[1]=1;\n\tint cnt=1;\n\tfor(int i=2;i<=1000;i++)a[i]=i+a[i-1];\n\tfor(int i=2;i<=1000;i++){\n\tta[i]=a[i]+ta[i-1];\n\tif(ta[i]%2==1)tta[++cnt]=ta[i];\n\t}\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tta[1]=1;\n\n\tfill(dp+1,dp+1000021,INF);\n\tfor(int i=0;i<=181;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\tif(j>=ta[i])dp[j]=min(dp[j],dp[j-ta[i]]+1);\n\t\t}\n\t}//endfor\n\tcout<<dp[n]<<\" \";\n\tfill(dp+1,dp+1000021,INF);\n\tfor(int i=0;i<=92;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\tif(j>=tta[i])dp[j]=min(dp[j],dp[j-tta[i]]+1);\n\t\t}\n\t}//endfor\n\tcout<<dp[n]<<endl;\n\t}//endwhile\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvoid pollock(int po[], int od[]) {\n\tint i = 1, j = 1;\n\twhile (po[i - 1] < 1000000) {\n\t\tpo[i] = (i * (i + 1) * (i + 2)) / 6;\n\t\tif (po[i] % 2 == 1) {\n\t\t\tod[j] = po[i];\n\t\t\tj++;\n\t\t}\n\t\ti++;\n\t}\n}\n\nint main() {\n\tint po[200] = {}, od[200] = {};\n\tpollock(po, od);\n\tint n;\n\twhile (cin >> n && n) {\n\t\tvector<int> tmp(1000000, 100);\n\t\ttmp[0] = 0;\n\t\tint t = 1;\n\t\twhile (po[t] <= n) t++;\n\t\tfor (int i = 1; i <= t; ++i) {\n\t\t\tfor (int j = 0; j + po[i] <= n; ++j) {\n\t\t\t\ttmp[j + po[i]] = min(tmp[j + po[i]], tmp[j] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << tmp[n] << \" \";\n\n\t\tfor (int i = 1; i < 1000000; ++i) tmp[i] = 1000000;\n\t\ttmp[0] = 0;\n\t\tt = 1;\n\t\twhile (od[t] <= n) t++;\n\t\tfor (int i = 1; i <= t; ++i) {\n\t\t\tfor (int j = 0; j + od[i] <= n; ++j) {\n\t\t\t\ttmp[j + od[i]] = min(tmp[j + od[i]], tmp[j] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << tmp[n] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define ll long long\nusing namespace std;\n\nint main() {\n  int n;\n  vector<int> X(200, 0);\n  rep(i, 200) X[i]=i*(i+1)*(i+2)/6;\n  int INF=1e9;\n  int MAX_N=1000001;\n  vector<int> dp(MAX_N, INF);\n  vector<int> dp2(MAX_N, INF);\n  dp[0]=0;\n  rep(i, 200) {\n    for (int j=X[i]; j<MAX_N; j++) {\n      dp[j]=min(dp[j], dp[j-X[i]]+1);\n    }\n  }\n  dp2[0]=0;\n  rep(i, 200) {\n    for (int j=X[i]; j<MAX_N; j++) {\n      if (X[i]%2==0) continue;\n      dp2[j]=min(dp2[j], dp2[j-X[i]]+1);\n    }\n  }\n\n  while (1) {\n    cin>>n;\n    if (n==0) break;\n    cout<<dp[n]<<\" \"<<dp2[n]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tvi v;\n\tFOR(i, 1, 1000001) {\n\t\tv.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (v[i - 1] >= 1000001)break;\n\t}\n\tint m = v.size();\n\tvi dp(1000001, INF);\n\tdp[0] = 0;\n\tREP(i, m) {\n\t\tREP(j, 1000000+ 1) {\n\t\t\tif (j >= v[i]) dp[j] = min(dp[j], dp[j - v[i]] + 1);\n\t\t}\n\t}\n\tvi dp2(1000001, INF);\n\n\tdp2[0] = 0;\n\tREP(i, m) {\n\t\tif (v[i] % 2 == 0) continue;\n\n\t\tREP(j, 1000000 + 1) {\n\t\t\tif (j >= v[i])dp2[j] = min(dp2[j], dp2[j - v[i]] + 1);\n\t\t}\n\n\t}\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << dp[n]<<\" \"<<dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tstatic int dpA[1000001], dpB[1000001];\n\tvector<int> v;\n\tfor(int i=0;i<=1000000;i++) dpA[i] = dpB[i] = 10000;\n\tdpA[0] = dpB[0] = 0;\n\tfor(int i=1;;i++){\n\t\tint s = i*(i+1)*(i+2)/6;\n\t\tif(s > 1000000) break;\n\t\tv.push_back(s);\n\t}\n\tfor(int i=0;i<=1000000;i++){\n\t\tfor(int j=0;j<v.size()&&i+v[j]<=1000000;j++){\n\t\t\tdpA[i+v[j]] = min(dpA[i+v[j]], dpA[i]+1);\n\t\t\tif(v[j]%2==1){\n\t\t\t\tdpB[i+v[j]] = min(dpB[i+v[j]], dpB[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\tint t;\n\twhile(cin >> t && t){\n\t\tcout << dpA[t] << \" \" << dpB[t] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nvoid solve()\n{\n  fill(dp, dp + MAX + 1, MAX);\n  fill(dp2, dp2 + MAX + 1, MAX);\n  \n  vector<int> v;\n  for(int i = 0; ; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    if(t <= MAX)\n      v.push_back(t);\n    else\n      break;\n  }\n  for(int i = 0; i <= MAX; i++){\n    for(int j = 0; j < v.size(); j++){\n      if(i + v[j] <= MAX){\n        if(v[j] & 1)\n          dp2[i + v[j]] = min(dp2[i + v[j]], dp2[i] + 1);\n        dp[i + v[j]] = min(dp[i + v[j]], dp[i] + 1);\n      }\n    }\n  }\n}\n    \nint main()\n{\n  solve();\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0)\n      break;\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std ;\n\nint D[181] = {} ; // 10^6 越え → 181\nint dp_map[2][1000002] = {} ;\n\nvoid t(){\n\tfor( int i=1 ; i<181 ; i++ ){\n\t\tD[i] = i * (i+1) * (i+2) / 6 ;\n\t}\n}\n\nvoid dp(){\n\t\n\tfor( int i=0 ; i<=1000000 ; i++ ){\n\t\tdp_map[0][i] = i ;\n\t\tdp_map[1][i] = i ;\n\t}\n\t\n\tfor( int i=0 ; i<=1000000 ; i++ ){\n\t\tfor( int j=1 ; j<181 ; j++ ){\n\t\t\tif( i+D[j] <= 1000000 )\n\t\t\t\tdp_map[0][i+D[j]] = min( dp_map[0][i+D[j]] , dp_map[0][i]+1 ) ;\n\t\t\tif( D[j]%2 == 1 && i+D[j] <= 1000000 )\n\t\t\t\tdp_map[1][i+D[j]] = min( dp_map[1][i+D[j]] , dp_map[1][i]+1 ) ;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tt() ;\n\tdp() ;\n\t\n\tint n ;\n\t\n\twhile( cin >> n , n ){\n\t\tcout << dp_map[0][n] << ' ' ;\n\t\tcout << dp_map[1][n] << endl ;\n\t}\n\t\nreturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e6;\nconst int INF = 1e8;\nint dp[MAX_N+1],dp2[MAX_N+1];\n\nint main(){\n  fill(dp,dp+MAX_N,INF);\n  fill(dp2,dp2+MAX_N,INF);\n  dp[0] = dp2[0] = 0;\n\n  int n = 1, pil = 1;\n  do{\n    for(int i=0;i<=MAX_N-pil;i++){\n      dp[i+pil] = min(dp[i+pil], dp[i] + 1);\n    }\n    if(pil % 2){\n      for(int i=0;i<=MAX_N-pil;i++){\n\tdp2[i+pil] = min(dp2[i+pil], dp2[i] + 1);\n      }\n    }\n\n    n++;\n    pil = n*(n+1)*(n+2)/6;\n  }while(pil<=MAX_N);\n\n  while(cin >> n, n){\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint p(int i){\n  return i * (i + 1) * (i + 2) / 6;\n}\n\n\nint main(void){\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0){return 0;}\n\n    /* ???????¨??????? */\n    int ans1[n+1];\n    int ans2[n+1];\n    for(int i = 1 ; i < n + 1 ; i++){\n      ans1[i+1] = -1;\n      ans2[i+1] = -1;\n    }\n\n    for(int i = 1 ; p(i) < n + 1 ; i++){\n      ans1[p(i)] = 1;\n      if(p(i) % 2 == 1){ ans2[p(i)] = 1; }\n    }\n\n    for(int i = 2 ; i <= n ; i++){\n      if(ans1[i] == 1){\n      }else{\n        int min = 100000;\n        for(int j = 1 ; j < i ; j++){\n          if(ans1[j] + ans1[i - j] < min){\n            min = ans1[j] + ans1[i - j];\n          }\n        }\n        ans1[i] = min;\n      }\n    }\n\n    for(int i = 2 ; i <= n ; i++){\n      if(ans2[i] == 1){\n      }else{\n        int min = 100000;\n        for(int j = 1 ; j < i ; j++){\n          if(ans2[j] + ans2[i - j] < min){\n            min = ans2[j] + ans2[i - j];\n          }\n        }\n        ans2[i] = min;\n      }\n    }\n\n\n    cout << ans1[n] << \" \" << ans2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dp1[1000001], dp2[1000001];\n\nvoid num(){\n\tfor(int i = 1; i < 1000001; i++){\n\t\tdp1[i] = 1000000;\n\t\tdp2[i] = 1000000;\n\t}\n\tvector<int> v1, v2;\n\tfor(int i = 1; i < 200; i++){\n\t\tint t = (i*i*i+3*i*i+2*i)/6;\n\t\tif(t > 1000000) break;\n\t\tv1.push_back(t);\n\t\tif(t%2) v2.push_back(t);\n\t}\n\tfor(int i = 1; i < 1000001; i++){\n\t\tfor(int j = 0; j < v1.size(); j++){\n\t\t\tif(i < v1[j]) break;\n\t\t\tdp1[i] = min(dp1[i],dp1[i-v1[j]]+1);\n\t\t}\n\t\tfor(int j = 0; j < v2.size(); j++){\n\t\t\tif(i < v2[j]) break;\n\t\t\tdp2[i] = min(dp2[i],dp2[i-v2[j]]+1);\n\t\t}\n\t}\n}\n\nint main(){\n\tnum();\n\tint n;\n\twhile(scanf(\"%d\", &n), n) printf(\"%d %d\\n\", dp1[n], dp2[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <cmath>\n#include <time.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#define FOR(i, a) for(i = 0; i < (a); i++)\n#define FORM(i, a) for(i = (a) i >= 0; i--)\n#define INF 100000\nusing namespace std;\nint c[1000], odd[1000];\nint mini[200];\n\nint main(){\nint i, j, W, minimumc, minimumodd, l;\n \n\n   for(i = 1; i <= 200; i++){\n\t   c[i] = (i*(i+1)*(i+2))/6;\n   }\n   j = 1;\n   for(i = 1; i <= 200; i++){\n\t   if(c[i] % 2 == 1){\n\t\t   odd[j] = c[i];\n\t\t   j += 1;\n\t   }\n   }\n\n\n   cin >> W;\n\n   while(W != 0){\n\t   minimumc = 10000000;\n\t   minimumodd = 10000000;\n\t   for(i = 1; i <= 200; i++){\n\t\t   l = W;\n\t\t   if(c[i] > W){\n\t\t\t   break;\n\t\t   }\n\t\t for(j = i; j > 0; j--){\n\t\t\t mini[i] += l / c[j];\n\t\t\t l %= c[j];\n\t\t\t\n\t\t }\n\n\t\t  minimumc = min(minimumc, mini[i]);\n\t   }\n\n\t   \n\t\n\t   FOR(i, 200){\n\t\t   mini[i] = 0;\n\t   }\n\t      for(i = 1; i <= 200; i++){\n\t\t\t  l = W;\n\t\t   if(odd[i] > W){\n\t\t\t   break;\n\t\t   }\n\t\t for(j = i; j > 0; j--){\n\t\t\t mini[i] += l/odd[j];\n\t\t\t l %= odd[j];\n\t\t\t\n\t\t }\n\n\t\t  minimumodd = min(minimumodd, mini[i]);\n\t   }\n\t\t  \n     cout << minimumc << \" \" << minimumodd << endl;\n\t   FOR(i, 200){\n\t\t   mini[i] = 0;\n\t   }\n       \n\t   cin >> W;\n\n   }\n   \n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\nusing P = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\n\n#define REP(i, n) for(LL i = 0; i < n; ++i)\n#define FOR(i, a, n) for(LL i = a; i < n; ++i)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n\nconst int INF = (int)1e9;\nconst LL INFL = (LL)1e15;\nconst int MOD = 1e9 + 7;\n\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n//#define int long long\n\n/*************** using variables ***************/\nint n;\nint dp1[1000005], dp2[1000005];\nvector<int> sei5, sei5_odd;\n/**********************************************/\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    for(int i = 1; ; i++){\n        int x = i * (i+1) * (i+2) / 6;\n        if(x > 1000000) break;\n        sei5.pb(x);\n        if(x % 2 == 1) sei5_odd.pb(x);\n    }\n\n    REP(i, 1000001){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    dp1[0] = 0;\n    dp2[0] = 0;\n    FOR(i, 1, 1000001){\n        REP(j, sei5.size()){\n            if(i-sei5[j] < 0) break;\n            dp1[i] = min(dp1[i], dp1[i-sei5[j]] + 1);\n        }\n    }\n    FOR(i, 1, 1000001){\n        REP(j, sei5_odd.size()){\n            if(i-sei5_odd[j] < 0) break;\n            dp2[i] = min(dp2[i], dp2[i-sei5_odd[j]] + 1);\n        }\n    }\n    while(cin >> n, n){\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst ll MOD=10000;\nconst ll INF=1000000010;\nconst int MAX=100001;\nint dx[8]={0,1,0,-1,1,-1,1,-1};\nint dy[8]={1,0,-1,0,1,-1,-1,1};\nint a[1000010],b[1000010];\nint main(){\n\ta[0]=0;b[0]=0;\n\tfor(int i=1;i<=1000010;i++){\n\t\ta[i]=i;b[i]=i;\n\t\tint j=1;\n\t\twhile(j++){\n\t\t\tint p=j*(j+1)*(j+2)/6;\n\t\t\tif(i<p)break;\n\t\t\ta[i]=min(a[i],a[i-p]+1);\n\t\t\tif(p%2)b[i]=min(b[i],b[i-p]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin>>n,n){\n\t\tcout<<a[n]<<\" \"<<b[n]<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define INF 1000000\n\nint t(int x) { return x*(x+1)*(x+2)/6; }\n\nint dp[1000010];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  Vi one, two, odd;\n  for (int i = 1; t(i) <= 1000000; i++) {\n    one.push_back(t(i));\n    if (t(i)%2) odd.push_back(t(i));\n  }\n\n  for (int a : one) {\n    for (int b : one) {\n      two.push_back(a+b);\n    }\n  }\n  sort(ALL(two));\n\n  REP(i, 1000001) dp[i] = INF;\n  dp[0] = 0;\n  REP(i, 1000000) {\n    for (int a : odd) {\n      if (i+1-a < 0) break;\n      dp[i+1] = min(dp[i+1-a]+1, dp[i+1]);\n    }\n  }  \n\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    if (n == *lower_bound(ALL(one), n)) {\n      cout << 1;\n    } else if (n == *lower_bound(ALL(two), n)) {\n      cout << 2;\n    } else {\n      bool flag = false;\n      for (int a : one) {\n\tif (n - a == *lower_bound(ALL(two), n - a)) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if (flag) {\n\tcout << 3;\n      } else {\n\tfor (int a : two) {\n\t  if (n - a == *lower_bound(ALL(two), n - a)) {\n\t    flag = true;\n\t    break;\n\t  }\n\t}\n\tcout << (flag ? 4 : 5);\n      }\n    }\n\n    cout << ' ' << dp[n] << endl;\n\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(n); ++i)\n#define repr(i, a, b) for (int i=a; i<(b); ++i)\n#define reprev(i, n) for (int i=n-1; i>=0; --i)\n#define reprrev(i, a, b) for (int i=b-1; i>=(a); --i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint main() {\n    cout << fixed << setprecision(10);\n    int max_n = 1e6+1, INF = max_n+1;\n\n    // max_nを超えるまで、正四面体数を用意する\n    vector<int> st, ost;\n    int tn = 0, ti = 1;\n    while (tn <= max_n) {\n        tn = ti * (ti+1) * (ti+2) / 6;\n        st.emplace_back(tn);\n        if (tn % 2 == 1) {\n            ost.emplace_back(tn);\n        }\n        ti += 1;\n    }\n\n    // 全ての数を使用する\n    vector<int> dp(max_n+1, INF);\n    dp[0] = 0;\n    rep(i, max_n) {\n        rep(j, st.size()) {\n            if (i+1 - st[j] >= 0) {\n                dp[i+1] = min(dp[i+1], dp[i+1 - st[j]] + 1);\n            }\n        }\n    }\n\n    // 奇数だけ使用\n    vector<int> odp(max_n+1, INF);\n    odp[0] = 0;\n    rep(i, max_n) {\n        rep(j, ost.size()) {\n            if (i+1 - ost[j] >= 0) {\n                odp[i+1] = min(odp[i+1], odp[i+1 - ost[j]] + 1);\n            }\n        }\n    }\n\n    int N;\n    while(cin >> N) {\n        if (N == 0){\n            break;\n        }\n        cout << dp[N] << \" \" << odp[N] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;n<=p[n] && i<181;i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;n<=p[n] && i<181;i++) if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\n/*\nusing ll = long long;\nusing P = pair<int, int>;\n*/\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\n\nint a[205];\nint dp[1000005];\nint dp2[1000005];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    vector<int> odd;\n    rep(i,200){\n        a[i] = i*(i+1)*(i+2)/6;\n        if(a[i]%2 == 1) odd.push_back(a[i]);\n    }\n    rep(i,1000001){\n        dp[i] = INF;\n        dp2[i] = INF;\n    }\n    dp[0] = 0;\n    dp2[0] = 0;\n    rep(i,200)rep(j,1000001){\n        if(j+a[i] > 1000000) break;\n        chmin(dp[j+a[i]], dp[j]+1);\n    }\n    rep(i,odd.size())rep(j,1000001){\n        if(j+odd[i] > 1000000) break;\n        chmin(dp2[j+odd[i]], dp2[j]+1);\n    }\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX_N = 1000000;\nstatic const int INF = 1 << 30;\n\nint n;\nvector<int> va, vb;\nint memo[2][MAX_N + 1], memo2[2][MAX_N + 1];\n\nint main(){\n\tfor(int i = 1; ; i++){\n\t\tint num = i * (i + 1) * (i + 2) / 6;\n\t\tif(num > MAX_N) break;\n\t\tva.push_back(num);\n\t\tif(num % 2) vb.push_back(num);\n\t}\n\tfill(memo[0], memo[2], INF);\n\tmemo[0][0] = 0;\n\tfor(int i = 0; i < va.size(); i++){\n\t\tfor(int j = 0; j <= MAX_N; j++){\n\t\t\tif(j - va[i] < 0) memo[1][j] = memo[0][j];\n\t\t\telse memo[1][j] = min(memo[0][j], min(memo[0][j - va[i]] + 1, memo[1][j - va[i]] + 1));\n\t\t}\n\t\tfor(int j = 0; j <= MAX_N; j++) memo[0][j] = memo[1][j];\n\t}\n\tfill(memo2[0], memo2[2], INF);\n\tmemo2[0][0] = 0;\n\tfor(int i = 0; i < vb.size(); i++){\n\t\tfor(int j = 0; j <= MAX_N; j++){\n\t\t\tif(j - vb[i] < 0) memo2[1][j] = memo2[0][j];\n\t\t\telse memo2[1][j] = min(memo2[0][j], min(memo2[0][j - vb[i]] + 1, memo2[1][j - vb[i]] + 1));\n\t\t}\n\t\tfor(int j = 0; j <= MAX_N; j++) memo2[0][j] = memo2[1][j];\n\t}\n\tfor(;;){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tprintf(\"%d %d\\n\", memo[0][n], memo2[0][n]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    long long i;\n    int n;\n    long long j = 0;\n    int a[84];\n    int b[22];\n    long long t[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-8;\n\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nint memo[3000001];\n\nint solve(int n, bool skip_even) {\n  if (memo[n] != 0) return memo[n];\n  if (n == 0) return 0;\n  int mini = 1 << 30;\n  for (int i = 1; i*(i+1)*(i+2)/6 <= n; i++) {\n    if (skip_even && i*(i+1)*(i+2)/6 % 2 == 0) continue;\n    mini = min(mini, solve(n-i*(i+1)*(i+2)/6, skip_even) + 1);\n  }\n  return memo[n] = mini;\n}\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int n;\n  while (cin >> n, n) {\n    fill(memo, memo + 3000001, 0);\n    cout << solve(n, false) << \" \";\n    fill(memo, memo + 3000001, 0);\n    cout << solve(n, true) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SET(a,c) memset(a,c,sizeof(a))\n#define PB push_back\nusing namespace std;\n\nconst int MAX_N = 1e6;\nconst int INF = 0x3f3f3f3f;\nint dp[MAX_N], dp_odd[MAX_N];\n\nvoid solve(int n)\n{\n\tvector<int> m;\n\n\tREP(i, MAX_N) {\n\t\tm.PB((i + 1) * (i + 2) * (i + 3) / 6);\n\t\tif (m.back() > n) break;\n\t}\n\t\n\tREP(i, n + 1) dp[i] = dp_odd[i] = i;\n\tREP(i, m.size()) {\n\t\tif (i == 1) continue;\n\t\tREP(j, n + 1) {\n\t\t\tif (j < m[i]) continue;\n\t\t\tdp[j] = min(dp[j], dp[j - m[i]] + 1);\n\t\t\tif (m[i] % 2) dp_odd[j] = min(dp_odd[j], dp_odd[j - m[i]] + 1);\n\t\t}\n\t}\t\n\tprintf(\"%d %d\\n\", dp[n], dp_odd[n]);\n}\n\nint main()\n{\n\tint n;\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (!n) break;\n\t\tsolve(n);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main(){\n    //INFで初期化\n    for(int i = 1;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n * 2) /6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;  //ポロック数の生成\n        for(int i = a;i <= MAX;i++)     //正四面体数の個数dp(a以下は必要ない)\n            dp1[i] = min(dp1[i],dp1[i-a] + 1);  //更新しないor左側から更新する\n        if(a % 2 == 0)continue;     //偶数の時は次のroopへ\n        for(int i = a;i <= MAX;i++)     //奇数の正四面体数の個数dp(a以下は必要ない)\n            dp2[i] = min(dp2[i],dp2[i-a] + 1);  //更新しないor左側から更新する\n    }\n\n    //入出力\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main(){\n    //INFで初期化\n    for(int i = 0;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n * 2) /6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;  //ポロック数の生成\n        for(int i = a;i <= MAX;i++)     //正四面体数の個数dp(a以下は必要ない)\n            dp1[i] = min(dp1[i],dp1[i-a] + 1);  //更新しないor左側から更新する\n        if(a % 2 == 0)continue;     //偶数の時は次のroopへ\n        for(int i = a;i <= MAX;i++)     //奇数の正四面体数の個数dp(a以下は必要ない)\n            dp2[i] = min(dp2[i],dp2[i-a] + 1);  //更新しないor左側から更新する\n    }\n\n    //入出力\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint m;\nint f(int n) { return n*(n+1)*(n+2)/6; }\nvector<int> l1, l2;\n\nvoid r(int n, int step, vector<int> &l, int p) {\n  if(step+1 >= m) return;\n \n  for(int i=p; i>=0; i--) {\n    int n2 = n-l[i];\n    if(n2<0) continue;\n    if(n2==0) {\n      m = step+1;\n      return;\n    }\n    if(n2>0) {\n      r(n2, step+1, l, i);\n    }\n  }\n  \n}\n\nint main() {\n  while(1) {\n    vector<int> l1, l2;\n    int n;\n\n     cin >> n;\n     if(n==0) break;\n    \n    // not over\n    for(int i=1; true; i++) {\n      int mm = f(i);\n      if(mm>n) break;\n      l1.push_back(mm);\n      if(mm&1) l2.push_back(mm);\n    }\n\n    m = n;\n    r(n, 0, l1, l1.size()-1);\n    cout << m;\n\n    cout << ' ';\n    \n    m = n;\n    r(n, 0, l2, l2.size()-1);\n    cout << m;\n\n    cout << \"\\n\";\n\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const MAX = 1000000;\nint const INF = 1<<29;\nint dpa[MAX+1];\nint dpo[MAX+1];\n\nint main() {\n  \n  \n  fill(dpa, dpa+MAX, INF);\n  fill(dpo, dpo+MAX, INF);\n  \n  dpa[0] = dpo[0] = 0;\n  \n  for(int i=1; ; i++) {\n    int n = i*(i+1)*(i+2)/6;\n    for(int j=n; j<=MAX; j++) {\n      dpa[j] = min(dpa[j], dpa[j-n]+1);\n      if(n%2) {\n\tdpo[j] = min(dpo[j], dpo[j-n]+1);\n      }\n    }\n  }\n  \n  for(int N; cin >> N && N;) {\n    cout << dpa[N] << ' ' << dpo[N] << endl;\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint tetrahedron(int);\n\nint index_direct_match(int);\nint index_direct_match_odd(int);\nint index_number(int);\nint index_number_odd(int);\n\nint main(int argc, char const *argv[]) {\n\n  int n;\n  int cnt_min;\n  int cnt_only_odd;\n\n  for(cin >> n;n != 0;cin >> n){\n:\n    cout << index_number(n) << \" \" <<  index_number_odd(n) << endl;\n\n  }\n\n  //\n\n  return 0;\n}\n\nint tetrahedron(int k){\n\n  return k*(k+1)*(k+2)/6;\n\n}\n\nint index_number(int index){\n  static int memo[1000]={};\n  if(index>=1 && index<=3) return index;\n  else if(index_direct_match(index)) return 1;\n  else if(memo[index] != 0) return memo[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i++){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number( index - tetrahedron(i) ));\n    }\n    memo[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n\n}\n\nint index_direct_match(int index){\n\n  for(int i=1;i<200;i++){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_direct_match_odd(int index){\n\n  for(int i=1;i<200;i+=4){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_number_odd(int index){\n  static int memo2[1000]={};\n  if(index>=1 && index<=34) return index;\n  else if(index_direct_match_odd(index)) return 1;\n  else if(memo2[index] != 0) return memo2[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i+=4){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number_odd( index - tetrahedron(i) ));\n    }\n    memo2[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/06/29 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint DP[1000000];\n\tint DP2[1000000];\n\tDP[0] = 0;\n\tDP2[0] = 0;\n\tfor(int i=1; i<1000000; i++){\n\t\tDP[i] = 1000000;\n\t\tDP2[i] = 1000000;\n\t}\n\n\tfor(int i=1; ; i++){\n\t\tint p = i*(i+1)*(i+2)/6;\n\n\t\tif(p>=1000000)\n\t\t\tbreak;\n\n\t\tDP[p] = 1;\n\n\t\tif(p%2==1){\n\t\t\tDP2[p] = 1;\n\t\t}\n\t}\n/*\n\tfor(int i=0; i<P.size(); i++){\n\t\tcout << P[i] << endl;\n\t}\n*/\n\tfor(int i=0; i<1000000; i++){\n\t\tif(DP[i]!=1)\n\t\t\tcontinue;\n\n\t\tfor(int j=0; j+i<1000000; j++){\n\t\t\tif(DP[j]+1<DP[j+i]){\n\t\t\t\tDP[j+i] = DP[j]+1;\n\t\t\t}\n\n\t\t\tif(DP2[i]==1 && DP2[j]+1<DP2[j+i]){\n\t\t\t\tDP2[j+i] = DP2[j]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tcout << DP[n] << ' ' << DP2[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define INF 1000\nusing namespace std;\n\nint all[MAXNUM + 2], odd[MAXNUM + 2], fourall[1000], fourodd[1000];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 0; i < MAXNUM; i++){\n\t\tall[i] = INF;\n\t\todd[i] = INF;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM * 2)\n\t\t\tbreak;\n\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\t\t\t//cout << i << endl;\n\t}\n\t//cout << \"a\";\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define REP(i, n) for(int (i) = 0; (i) < (n); (i)++)\n\nconst int MAX = 1000000;\n\nint dp[MAX + 1];\nint dp2[MAX + 1];\n\nvoid solve()\n{\n  fill(dp, dp + MAX + 1, MAX);\n  fill(dp2, dp2 + MAX + 1, MAX);\n  dp[0] = dp[2] = 0;\n  vector<int> v;\n  for(int i = 0; ; i++){\n    int t = i * (i + 1) * (i + 2) / 6;\n    if(t <= MAX)\n      v.push_back(t);\n    else\n      break;\n  }\n  for(int i = 0; i <= MAX; i++){\n    for(int j = 0; j < v.size(); j++){\n      if(i + v[j] <= MAX){\n        if(v[j] & 1)\n          dp2[i + v[j]] = min(dp2[i + v[j]], dp2[i] + 1);\n        dp[i + v[j]] = min(dp[i + v[j]], dp[i] + 1);\n      }\n    }\n  }\n}\n    \nint main()\n{\n  solve();\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0)\n      break;\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n//#include<vector>\n#include<algorithm>\n#define N (int)1e6\nusing namespace std;\n\nint main(){\n  int n,tmp,dp[N],dp_odd[N];\n  int plc[1000],num;\n\n  for(int i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint v[200], dp[1000001], dp2[1000001];\nvector<int> v2;\n\nint main()\n{\n  v[0] = 1;\n  v2.push_back(1);\n  for(int i = 1; i < 200; i++)\n  {\n    v[i] = v[i - 1];\n    for(int j = 0; j <= i; j++)\n      v[i] += j + 1;\n    if(v[i] % 2)\n      v2.push_back(v[i]);\n  }\n  fill(dp, dp + 1000001, 1000000000);\n  fill(dp2, dp2 + 1000001, 1000000000);\n  dp[0] = dp2[0] = 0;\n  for(int i = 0; i <= 1000000; i++)\n  {\n    for(int j = 0; j < 200; j++)\n    {\n      if(v[j] <= i)\n        dp[i] = min(dp[i], dp[i - v[j]] + 1);\n      if(j < v2.size() && v2[j] <= i)\n        dp2[i] = min(dp2[i], dp2[i - v2[j]] + 1);\n    }\n  }\n  while(true)\n  {\n    int n;\n    cin >> n;\n    if(!n)\n      break;\n    cout << dp[n] << \" \" << dp2[n] << endl; \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\n//int dps[190][1000010] = { 0 };\nvector<vector<int>> dp;\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp.resize(C_N + 2);\n\t\tfor (int i = 0; i < C_N + 2; i++) {\n\t\t\tdp[i].resize(N + 2);\n\t\t}\n\n\t\tfor(int i = 1; i <= N + 1; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\n\t\tdp.clear();\n\t\tdp.shrink_to_fit();\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nconst int MAX_N = 1e6; \nvector<int>dp1, dp2;\nvector<int>tetra;\n\nint main(void)\n{\n\tint n = 1;\n\tdo\n\t{\n\t\ttetra.push_back(n * (n + 1) * (n + 2) / 6);\n\t\t++n;\n\t} while (tetra.back() <= MAX_N);\n\tdp1.push_back(0);\n\tdp2.push_back(0);\n\tfor (int i = 1; i <= MAX_N; ++i)\n\t{\n\t\tint a1 = INT_MAX, a2 = INT_MAX;\n\t\tfor (int t : tetra)\n\t\t{\n\t\t\tif (t > i)break;\n\t\t\ta1 = min(a1, dp1[i - t] + 1);\n\t\t\tif (t % 2)\n\t\t\t{\n\t\t\t\ta2 = min(a2, dp2[i - t] + 1);\n\t\t\t}\n\t\t}\n\t\tdp1.push_back(a1);\n\t\tdp2.push_back(a2);\n\t}\n\tint x;\n\twhile (cin >> x, x)\n\t{\n\t\tcout << dp1[x] << \" \" << dp2[x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nconst int INF=1e9;\nconst int N=1000001;\nint mem[N],memo[N];\n\n\nint tetra(int x)\n{\n    return x*(x+1)*(x+2)/6;\n}\nint main()\n{\n    REP(i,N)\n    {\n        mem[i]=INF;\n        memo[i]=INF;\n    }\n    mem[0]=0;\n    memo[0]=0;\n    for(int j=200;j>=1;j--)\n    {\n        int c = tetra(j);\n        REP(i,N)\n        {\n            if(i+c>=N) continue;\n            if(c%2==1)\n            {\n                memo[i+c]=min(memo[i+c], memo[i]+1);\n            }\n\n            mem[i+c]=min(mem[i+c], mem[i]+1);\n        }\n    }\n\n    /*\n    REP(i,30)\n        cout<<mem[i]<<\" \\n\"[i==29];\n    REP(i,30)\n        cout<<memo[i]<<\" \\n\"[i==29];\n        */\n\n    int n;\n    while(cin>>n,n)\n    {\n        cout<<mem[n]<<\" \"<<memo[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define dtm(i,n) rep(i,0,n)\n\nint f(int n) {\n\tint ret;\n\tret = n * (n+1) * (n+2) / 6;\n\treturn ret;\n}\n\nint max_n;\nint table[3000];\nvoid make_table() {\n\tint i;\n\tfor (i=0; i<1000000; i++) {\n\t\tint x = f(i);\n\t\tif (x > 1000000) break;\n\t\ttable[i] = x;\n\t}\n\tmax_n = i;\n}\n\nint memo[1000000];\nint r(int n) {\n\tint i;\n\tif (n == 0) return 0;\n\tif (memo[n]) return memo[n];\n\tfor (i=max_n-1; table[i]>n; i--) ;\n\tif (table[i] == n) {\n\t\tmemo[n] = 1;\n\t\treturn 1;\n\t}\n\tint m = INT_MAX;\n\tfor (; i>=1; i--) {\n\t\tint x = 1 + r(n - table[i]);\n\t\tif (x < m) m = x;\n\t}\n\tmemo[n] = m;\n\treturn m;\n}\nint memo2[1000000];\nint r2(int n) {\n\tint i;\n\tif (n == 0) return 0;\n\tif (memo2[n]) return memo2[n];\n\tfor (i=max_n-1; table[i]>n; i--) ;\n\tif (n%2==1 && table[i] == n) {\n\t\tmemo2[n] = 1;\n\t\treturn 1;\n\t}\n\tint m = INT_MAX;\n\tfor (; i>=1; i--) {\n\t\tif (table[i]%2==0) continue;\n\t\tint x = 1 + r2(n - table[i]);\n\t\tif (x < m) m = x;\n\t}\n\tmemo2[n] = m;\n\treturn m;\n}\n\nvoid solve(int n) {\n\tprintf(\"%d %d\\n\", r(n), r2(n));\n}\n\nint main() {\n\tint n;\n\tmake_table();\n\tfor (;;) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n==0) break;\n\t\tsolve(n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  tmp =min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t // dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nvoid solution(int n)\n{\n    vector<int> num(n+1, -1);\n    num[0] = 0;\n    for(int i=1; ; ++i){\n        int tmp = i*(i+1)*(i+2)/6;\n        if(tmp > n)\n            break;\n        for(int j=0; j+tmp<=n; ++j){\n            if(num[j] >= 0 && (num[j+tmp] == -1 || num[j]+1 < num[j+tmp])){\n                num[j+tmp] = num[j]+1;\n            }\n        }\n    }\n    cout << num[n] << ' ';\n\n    num.assign(n+1, -1);\n    num[0] = 0;\n    for(int i=1; ; ++i){\n        int tmp = i*(i+1)*(i+2)/6;\n        if(tmp > n)\n            break;\n        if(tmp % 2 == 0)\n            continue;\n        for(int j=0; j+tmp<=n; ++j){\n            if(num[j] >= 0){\n                num[j+tmp] = num[j]+1;\n            }\n        }\n    }\n    cout << num[n] << endl;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            break;\n        solution(n);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 1000000\n#define MAX 1000000\n\nint main(){\n\tvector <int> v(200);\n\tfor(int i = 0; i < 200; i++)\n\t\tv[i] = i * (i + 1) * (i + 2) / 6;\n\t\n\tvector <int> d(MAX + 1, INF);\n\tvector <int> d2(MAX + 1, INF);\n\t\n\td[0] = d2[0] = 0;\n\tfor(int i = 1; i <= MAX; i++){\n\t\tfor(int j = 0; v[j] <= i; j++){\n\t\t\td[i] = min(d[i], d[i - v[j]] + 1);\n\t\t\tif(v[j] % 2 != 0)\n\t\t\t\td2[i] = min(d2[i], d2[i - v[j]] + 1);\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tint s;\n\t\tcin >> s;\n\t\t\n\t\tif(s == 0)\n\t\t\tbreak;\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tcout << d[s] << \" \" << d2[s] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 105000\n#define INFINITY 2000000000\nusing namespace std;\nint dp[N][N],data[N];\nvector<int> data2;\nint DP(int);\nint DP2(int);\nint main(){\n  int i,out,out2,n;\n  data2.push_back(0);\n  for(i=1;i<N;i++){\n    data[i]=i*(i+1)*(i+2)/6;\n    if(data[i]%2==1){\n      data2.push_back(data[i]);\n    }\n  }\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    out=DP(n);\n    out2=DP2(n);\n    cout << out << ' ' << out2 << endl;\n  }\n  return 0;\n}\nint DP(int n){\n  int i,j,minret,s;\n  for(i=1;i<N;i++){\n    if(data[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}\nint DP2(int n){\n  int i,j,minret,s,len;\n  len=data2.size();\n  for(i=1;i<len;i++){\n    if(data2[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  for(i=0;i<=n;i++) dp[0][i]=INFINITY;\n  for(i=0;i<=s;i++) dp[i][0]=0;\n  for(i=1;i<=s;i++){\n    for(j=1;j<=n;j++){\n      if(j>=data2[i]) dp[i][j]=min(dp[i-1][j],dp[i][j-data2[i]]+1);\n      else dp[i][j]=dp[i-1][j];\n    }\n  }\n  minret=INFINITY;\n  for(i=1;i<=s;i++) minret=min(minret,dp[i][n]);\n  return minret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    /*dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;*/\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\nint dp1[1000001 * 2], dp2[1000001 * 2];\nint main() {\n\n    fill_n(dp1, 1000001 * 2, INF);\n    fill_n(dp2, 1000001 * 2, INF);\n    vector< int > p;\n    for(int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; i++) {\n        int v = i * (i + 1) * (i + 2) / 6;\n        p.push_back(v); dp1[v] = 1;\n        if(v % 2) dp2[v] = 1;\n    }\n    for(int i = 1; i < 1000001; i++) {\n        if(dp1[i] != INF) {\n            for(int j = 0; j < p.size(); j++) {\n                dp1[i + p[j]] = min(dp1[i + p[j]], dp1[i] + 1);\n                if(p[j] % 2) dp2[i + p[j]] = min(dp2[i + p[j]], dp2[i] + 1);\n            }\n        }\n    }\n\n    int N;\n    while(cin >> N, N) {\n        cout << dp1[N] << \" \" << dp2[N] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\n#define MAX 1000000\n\nvoid makelist(int *list, int x) {\n  for (int i = x; i < MAX; i++) {\n    list[i] = min(list[i], list[i-x]+1);\n  }\n}\n\nint main() {\n  int list1[MAX], list2[MAX], a, n;\n  for (int i = 1; i < MAX; i++) {\n    list1[i] = list2[i] = INF;\n  }\n  for (int i = 1; ; i++) {\n    a = i*(i+1)*(i+2)/6;\n    if (a >= MAX) break;\n    makelist(list1, a);\n    if (a & 1) makelist(list2, a);\n  }\n  while (cin >> n, n) {\n    cout << list1[n] << \" \" << list2[n] << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[202];\n    int b[202];\n    vector<int> t1(1000010, 0),t2(1000010, 0);\n    for(i = 0; i < 200; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    /*cout << a[82] << b[20] << endl;\n    for(i = 0; i < 200; i++){\n        cout << \"a[\" << i << \"] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 200; i++){\n        cout << \"b[\" << i << \"] = \" << b[i] << endl;\n    }*/\n\n        for(i = 0; i <= 1000005; i++){\n            t1[i] = i;\n        }\n\n        for(i = 0; i <= 179; i++){\n            for(j = a[i]; j <= 1000005; j++){\n                if(t1[j] > t1[j - a[i]] + 1){\n                    t1[j] = t1[j -a[i]] + 1;\n                }\n            }    \n        }        \n\n        for(i = 0; i <= 1000005; i++){\n            t2[i] = i;\n        }\n        \n        for(i = 0; i <= 44; i++){\n            for(j = b[i]; j <= 1000005; j++){\n                if(t2[j] > t2[j - b[i]] + 1){\n                    t2[j] = t2[j - b[i]] + 1;\n                }\n            }\n        }\n            \n\n\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << t1[n] << \" \" << t2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    vector<int> v(201);\n    for(int i=1; i<=200; i++){\n        v[i] = i * (i + 1) * (i + 2) / 6;\n    }\n\n    while(1){\n        int n; cin>>n;\n        if(n == 0) return 0;\n\n        vector<int> dp1(n+10, 1e9);\n        dp1[0] = 0;\n        auto dp2 = dp1;\n\n        for(int i=1; i<=200; i++){\n            for(int j=0; j<=n; j++){\n                if(j - v[i] >= 0) dp1[j] = min(dp1[j], dp1[j-v[i]] + 1);\n\n                if(v[i] % 2){\n                    if(j - v[i] >= 0) dp2[j] = min(dp2[j], dp2[j-v[i]] + 1);\n                }\n            }\n        }\n\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nvector<int> tetra;\nvector<int> oddTetra;\nint dp[1000000];\nint oddDp[1000000];\nint N;\n\nconst int MAX = 1000000;\n\nvoid initialize() {\n  for (int i = 1;;i++) {\n    int n = i * (i + 1) * (i + 2) / 6;\n    if (n > MAX) {\n      break;\n    }\n    tetra.push_back(n);\n    if (n % 2 == 1) {\n      oddTetra.push_back(n);\n    }\n  }\n  fill(dp, dp + 1000000, MAX);\n  fill(oddDp, oddDp + 1000000, MAX);\n  /*\n  for (int i = 0; i < tetra.size(); i++) {\n    printf(\"%d\\n\", tetra[i]);\n  }\n  */\n}\n\nvoid solve() {\n  dp[0] = oddDp[0] = 0;\n  for (int i = 1; i < MAX; i++) {\n    for (int j = 0; j < tetra.size(); j++) {\n      if (tetra[j] > i) {\n        break;\n      }\n      dp[i] = min(dp[i], 1 + dp[i - tetra[j]]);\n    }\n    for (int j = 0; j < oddTetra.size(); j++) {\n      if (oddTetra[j] > i) {\n        break;\n      }\n      oddDp[i] = min(oddDp[i], 1 + oddDp[i - oddTetra[j]]);\n    }\n  }\n}\n\nint main() {\n  initialize();\n  solve();\n  while (true) {\n    scanf(\"%d \", &N);\n    if (N == 0) {\n      break;\n    }\n    printf(\"%d %d\\n\", dp[N], oddDp[N]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\n#define MAX 1000010\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\n\tVI ans(MAX, INF), ans_odd(MAX, INF);\n\tans[0] = ans_odd[0] = 0;\n\tULL tetra;\n\tfor (int i = 1; (tetra = i * (i+1) * (i+2) / 6) < MAX; ++i) {\n\t\tfor (int j = tetra; j < MAX; ++j) {\n\t\t\tans[j] = min(ans[j], ans[j - tetra] + 1);\n\t\t\tif (tetra % 2) {\n\t\t\t\tans_odd[j] = min(ans_odd[j], ans_odd[j - tetra] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << ans[n] << ' ' << ans_odd[n] << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp1[1000001];\nint dp2[1000001];\n\nint main() {\n\tint N = 1000000;\n\n\tvector<int> v1,v2;\n\tint n = 1;\n\twhile(n*(n+1)*(n+2)/6<=N) {\n\t\tint p = n*(n+1)*(n+2) / 6;\n\t\tv1.push_back(p);\n\t\tif(p%2==1)\n\t\t\tv2.push_back(p);\n\t\tn++;\n\t}\n\n\tfor(int i = 0;i < N+1;i++) {\n\t\tdp1[i] = i;\n\t\tdp2[i] = i;\n\t}\n\t//cout << v1.size() << \" \" << v2.size() << endl;\n\tfor(auto v : v1) {\n\t\tfor(int j = v;j < N + 1;j++) {\n\t\t\tdp1[j] = min(dp1[j],dp1[j - v] + 1);\n\t\t}\n\t}\n\tfor(auto v : v2) {\n\t\tfor(int j = v;j < N + 1;j++) {\n\t\t\tdp2[j] = min(dp2[j],dp2[j - v] + 1);\n\t\t}\n\t}\n\n\twhile(true) {\n\t\tint m;\n\t\tcin >> m;\n\t\tif(m == 0)\n\t\t\tbreak;\n\t\tcout << dp1[m] << \" \" << dp2[m] << endl;\n\t}\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 1000000;\nint dp[2][N+1];\n\nint main(){\n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n\n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      dp[0][nxt] = min(dp[0][nxt],dp[0][j] + 1);\n      if(val&1)dp[1][nxt] = min(dp[1][nxt],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  int n;\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "/* C ????§????: ?????? */\n#include<bits/stdc++.h>\n#define dump(a) cout << (#a) << (a) << endl\nusing namespace std;\n\n#define MAX_SIZE 2000002\n\n//pollok\nint memo_cnt[MAX_SIZE]; //MAX_SIZE??????\nvector<int> all_pks;\nvector<int> kisu_pks;\n\n//P=pk??????, index=pks????????¨?????´???\nint dfs(const int P, const int &now_index, int level, vector<int> &pks)\n{\n\t//dump(level);\n\tif (P == 0) { return level; }\n\tif (memo_cnt[P] != -1) { return memo_cnt[P]; } //?????¢????????\\\n\t\n\tint min_depth = INT_MAX;\n\tfor(int i=now_index; i<pks.size(); i++) { //??§?????????\n\t\tint next_P = P-pks[i];\n\t\tif (next_P >= 0) {\n\t\t\tint depth = dfs(next_P, i, level+1, pks); //????????°???????????????cnt???\n\t\t\tmin_depth = min(min_depth,depth); //????°????????????°\n\t\t}\n\t\t//?????????????????´???????¬?\n\t}\n\t//???????????¢???\n\tmemo_cnt[P] = min_depth;\n\t\n\treturn min_depth;\n}\n\nint main() {\n\tint n=1;\n\twhile(true) {\n\t\tint pk = n * (n+1) * (n+2) / 6;\n\t\tif (pk >= MAX_SIZE){ break; }\n\n\t\tall_pks.push_back(pk);\n\t\tif (pk % 2 != 0) { kisu_pks.push_back(pk); }\n\t\tn++;\n\t}\n\treverse(begin(all_pks),end(all_pks));\n\treverse(begin(kisu_pks),end(kisu_pks));\n\n\tint P;\n\twhile(cin >> P) {\n\t\tif (P == 0) { break; }\n\n\t\tint index=0; //\n\t\tint left=0,right=0;\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tleft = dfs(P, 0/*pks???????????????*/, 0/* ??±??? */, all_pks);\n\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tright = dfs(P, 0/*pks???????????????*/, 0/* ??±??? */, kisu_pks);\n\t\tcout << left << \" \" << right << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}\n\n\n\n\n\t/*\n\tcout << all_pks.size() << endl;\n\tfor(int i=0; i<all_pks.size(); i++) {\n\t\tcout << all_pks[i] << \" \";\n\t}\n\tcout << endl;\n\n\tcout << kisu_pks.size() << endl;\n\tfor(int i=0; i<kisu_pks.size(); i++) {\n\t\tcout << kisu_pks[i] << \" \";\n\t}\n\tcout << endl;\n\t*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define INF (1<<25)\nint N;\nint pr[102];\nint dp[1000002];\nvoid init(){\n  for(int i=0;i<=N;i++) dp[i]=INF;\n}\nint solve(int g){\n  dp[0]=0;\n  for(int i=0;i<=N;i++){\n    if(dp[i]==INF) continue;\n    for(int j=0;j<102;j++){\n      if(g==2 && pr[j]%g==0) continue;\n      if(i+pr[j]>N) continue;\n      dp[i+pr[j]] = min(dp[i+pr[j]],dp[i]+1);\n    }\n  }\n\n  //  for(int i=0;i<=N;i++) printf(\"id=%d => %d\\n\",i,dp[i]);\n  return dp[N];\n}\n\nint main(){\n  for(int i=0;i<102;i++) pr[i] = (i+1)*(i+2)*(i+3)/6;\n  //  for(int i=0;i<102;i++) printf(\"%d\\n\",pr[i]);\n  //  for(int i=0;i<102;i++) if(!(i%2)) printf(\"%d\\n\",pr[i]);\n  while(1){\n    scanf(\"%d\",&N);\n    if(!N) break;\n    init();\n    int res1 = solve(1);\n    init();\n    int res2 = solve(2);\n    printf(\"%d %d\\n\",res1,res2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint dp[46][1000001];\n\nint main(){\n\n    printf(\"%d\\n\",sizeof(dp));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**Function Template**/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pint;\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define Rep(i, n) for(ll i = 1; i < (n); i++)\n#define ALL(a)  (a).begin(),(a).end()\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define PI 3.14159265358979323846\n#define ifYN(x) cout<<(x?\"Yes\":\"No\")<<\"\\n\" \nll fac[MAX], finv[MAX], inv[MAX];\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool palindrome(string s){\n  bool flag=true;\n  rep(i,s.size()) if(s[i]!=s[s.size()-1-i]) flag=false;\n  return flag;\n}\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n\n}\nll Len(ll n) {\n  ll s=0;\n  while(n!=0) s++, n/=10;\n  return s;\n}\n\n\nll Sint(ll n) {\n  ll m=0,s=0,a=n;\n  while(a!=0) s++, a/=10;\n  for(ll i=s-1;i>=0;i--) m+=n/((ll)pow(10,i))-(n/((ll)pow(10,i+1)))*10;\n  return m;\n}\n\n\nll Svec(vector<ll> v){\n  ll n=0;\n  for(ll i=0;i<v.size();i++) n+=v[i];\n  return n;\n}\n\n\nll GCD(ll a,ll b) {\n  return b ? GCD(b,a%b) : a;\n}\n\n\nll LCM(ll a,ll b){\n  return a/GCD(a,b)*b;\n}\n\n\nll Factorial(ll n){\n  ll m=1;\n  while(n>=1) m*=n,n--;\n  return m;\n}\n\nvoid runlength(string s,vector<pair<char,ll>> &p){\n  ll x=1;\n  if(s.size()==1){\n    p.push_back(pair<char,ll>(s[0],1));\n  }\n  for(ll i=0;i<s.size()-1;i++){\n    if(s[i]==s[i+1]){\n      x++;\n      if(i==s.size()-2){\n        p.push_back(pair<char,ll>(s[i],x));\n      }\n    }else{\n      p.push_back(pair<char,ll>(s[i],x));\n      x=1;\n      if(i==s.size()-2){\n        p.push_back(pair<char,ll>(s[s.size()-1],x));\n      }\n    }\n  }\n}\n\nll COM(ll n,ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstring Toupper(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('a'<=s[i] && s[i]<='z') ans+=(char)s[i]-32;\n    else ans+=s[i];\n  }\n  return ans;\n}\nstring Tolower(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('A'<=s[i] && s[i]<='Z') ans+=(char)s[i]+32;\n    else ans+=s[i];\n  }\n  return ans;\n}\n\n\nconst int MAX_N=100010;\nvector<bool> sieve_of_eratosthenes(){\n  vector<bool> isPrime(MAX_N+1,true);\n  /* isPrime[1]=false; */\n  for(int i=2;i<=MAX_N;i++){\n    if(isPrime[i]){\n      for(int j=2*i;j<=MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n  return isPrime;\n}\n\nvector<pint> prime_factorize(ll n){\n  vector<pint> ans;\n  for(ll p=2;p<=sqrt(n);p++){\n    if(n%p!=0) continue;\n    ll cnt=0;\n    while(n%p==0){\n      n/=p;\n      cnt++;\n    }\n    ans.push_back(make_pair(p,cnt));\n  }\n  if(n!=1) ans.push_back(make_pair(n,1));\n  return ans;\n}\n\n/*bool cmp(pint a, pint b) { return a.second < b.second; }*/\n\n/*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/\nll f(ll x){\n  return x*(x+1)*(x+2)/6;\n}\nint main(){\n  IOS;\n  vector<ll> v,w;\n  ll x=1;\n  while(f(x)<=1000000){\n    if(f(x)%2==0){\n      v.push_back(f(x));\n    }else{\n      v.push_back(f(x));\n      w.push_back(f(x));\n    }\n    x++;\n  }\n  vector<ll> dp1(1000001,1e16);\n  dp1[0]=0;\n  rep(i,v.size()) rep(j,1000001){\n    if(j-v[i]>=0) chmin(dp1[j],dp1[j-v[i]]+1);\n  }\n  vector<ll> dp2(1000001,1e16);\n  dp2[0]=0;\n  rep(i,w.size()) rep(j,1000001){\n    if(j-w[i]>=0) chmin(dp2[j],dp2[j-w[i]]+1);\n  }\n  while(1){\n    ll n;\n    cin>>n;\n    if(n==0) return 0;\n    cout<<dp1[n]<<' '<<dp2[n]<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000000\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[MAXNUM], fourodd[MAXNUM];\n\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 0, oddcounter = 0;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t}\n\t//cout << fourall[allcounter - 1] << endl;\n\t//cout << \"ok\" << endl;\n\t//cout << allcounter << endl;\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tfor (int j = 0; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\t\t//cout << i << \":\" << all[i]<<endl;\n\n\t\tfor (int j = 0; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t//cout << \"aaa\" << endl;\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000000;\n\nint dp[MAX], dp_odd[MAX];\n\nint main()\n{\n  vector<int> tetra;\n\n  for (int i = 1; ; ++i) {\n    int d = i * (i + 1) * (i + 2) / 6;\n    if (d >= MAX)\n      break;\n    tetra.push_back(d);\n  }\n\n  dp[0] = dp_odd[0] = 0;\n  for (int i = 1; i < MAX; ++i) {\n    dp[i] = dp_odd[i] = i;\n    for (int j = 0; j < tetra.size(); ++j) {\n      if (tetra[j] > i)\n\tbreak;\n      dp[i] = min(dp[i], dp[i-tetra[j]]+1);\n      if (tetra[j] % 2 == 1)\n\tdp_odd[i] = min(dp_odd[i], dp_odd[i-tetra[j]]+1);\n    }\n  }\n\n  int in;\n  for ( ; ; ) {\n    cin >> in;\n    if (in == 0)\n      break;\n    cout << dp[in] << \" \" << dp_odd[in] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N  int(pow(10.0,6.0))\n\nusing namespace std;\nint calc(int x){\n    return int(x*(x+1)*(x+2)/6);\n}\n\n\nint main(){\n    int n;\n\n    int dp[MAX_N];\n    int dp_odd[MAX_N];\n    int L[200]; //200くらいで正四面体数は10**6を超える\n    for(int i=0;i<MAX_N;i++){\n        dp[i]=MAX_N;\n        dp_odd[i]=MAX_N;\n    }\n    dp[0]=0;//dp[n]はnを作るのに必要な正四面体数の、最小の個数\n    dp_odd[0]=0;//奇数version\n\n    for(int i=0;i<200;i++){\n        L[i]=calc(i);\n    }\n\n    int new_val;\n    for(int x=0;x<MAX_N;x++){\n        for(int y=0;y<200;y++){\n            new_val= x-L[y];\n            if (new_val>=0){\n                dp[x] = min(dp[x],dp[new_val]+1);\n                if (L[y]%2==1){\n                    dp_odd[x] = min(dp_odd[x],dp_odd[new_val]+1); \n                }\n            }\n        }\n    }\n\n    while(true){\n        cin >> n;\n        if(n==0){\n            break;\n        }\n        printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n    }\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> vec, vec2;\nint dp[1000005], dp2[1000005];\n\nint main(void)\n{\n    for(long long x, i = 1; (x = i*(i+1)*(i+2)/6, x) <= 1000000; i++){\n        if(x % 2) vec2.push_back(x);\n        vec.push_back(x);\n    }\n    \n    for(int i = 0; i <= 1000000; i++) dp[i] = dp2[i] = 1e9;\n    dp[0] = dp2[0] = 0;\n    for(int i = 0; i < 1000000; i++){\n        for(int j = 0; j < vec.size(); j++){\n            if(i+vec[j] <= 1000000) dp[i+vec[j]] = min(dp[i+vec[j]], dp[i]+1);\n        }\n        for(int j = 0; j < vec2.size(); j++){\n            if(i+vec2[j] <= 1000000) dp2[i+vec2[j]] = min(dp2[i+vec2[j]], dp2[i]+1);\n        }\n    }\n    \n    while(cin >> n, n){\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 100000\n#define INF (1<<24)\nint n[1000],M;\n\nint dp[100005];\nint od[100005];\n\nint main()\n{\n\tfor(M=1; ; M++)\n\t{\n\t\tint v=M*(M+1)*(M+2)/6;\n\t\tif(v>MAX) break;\n\t\tn[M]=v;\n\t}\n\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<=N; i++)\n\t\t{\n\t\t\tdp[i]=INF;\n\t\t\tod[i]=INF;\n\t\t}\n\n\t\tdp[0]=od[0]=0;\n\n\t\tfor(int i=1; i<M; i++)\n\t\tfor(int j=0; j<=N; j++) \n\t\t{\n\t\t\tif(j+n[i] > N) break;\n\t\t\tif(dp[j]!=INF)\n\t\t\t{\n\t\t\t\tdp[j+n[i]]=min(dp[j+n[i]], dp[j]+1);\n\t\t\t}\n\t\t\tif(od[j]!=INF&&n[i]%2==1)\n\t\t\t{\n\t\t\t\tod[j+n[i]]=min(od[j+n[i]], od[j]+1);\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[N] << \" \" << od[N] << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<ll> p;\nvector<ll> o;\nvector<ll> memo(1000001, INF);\n\nll cal(ll n) {\n\tif(memo[n] != INF) return memo[n];\n\telse {\n\t\tll ans = INF;\n\t\tll i = 0;\n\t\twhile(i < o.size() && o[i] < n) {\n\t\t\tans = min(ans, 1 + cal(n - o[i]));\n\t\t\t++i;\n\t\t}\n\t\treturn memo[n] = ans;\n\t}\n}\n\nint main(void) {\n\n\tfor(ll i = 0; i * (i + 1) * (i + 2) / 6 <= 1000000; ++i) {\n\t\tp.pb(i * (i + 1) * (i + 2) / 6);\n\t\tif((i * (i + 1) * (i + 2) / 6) % 2 == 1) o.pb(i * (i + 1) * (i + 2) / 6);\n\t}\n\tvector<P> nf;\n\tmap<ll, ll> nb;\n\tREP(i, p.size()) {\n\t\tREP(j, p.size()) {\n\t\t\tif(p[i] + p[j] > 1000000) continue;\n\t\t\tnf.pb(P(p[i] + p[j], (ll)(p[i] != 0) + (ll)(p[j] != 0)));\n\t\t\tREP(k, p.size()) {\n\t\t\t\tif(nb.count(p[i] + p[j] + p[k]) != 0)\n\t\t\t\tnb[p[i] + p[j] + p[k]] = min(nb[p[i] + p[j] + p[k]], (ll)(p[i] != 0) + (ll)(p[j] != 0) + (ll)(p[k] != 0));\n\t\t\t\telse\n\t\t\t\tnb[p[i] + p[j] + p[k]] = (ll)(p[i] != 0) + (ll)(p[j] != 0) + (ll)(p[k] != 0);\n\t\t\t}\n\t\t}\n\t}\n\tmemo[0] = 0;\n\tREP(i, o.size()) {\n\t\tmemo[o[i]] = 1;\n\t}\n\twhile(true) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tll ans1 = INF, ans2 = INF;\n\t\tREP(i, nf.size()) {\n\t\t\tif(nb.count(n - nf[i].first) != 0) {\n\t\t\t\tans1 = min(ans1, nf[i].second + nb[n - nf[i].first]);\n\t\t\t}\n\t\t}\n\t\tans2 = cal(n);\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint tr[300];\nint sq[300];\nint dp1[1000000];\nint dp2[1000000];\n\nint main() {\n\n  for(int i=1; i < 300; i++) {\n    tr[i] = tr[i-1] + i;\n    sq[i] = sq[i-1] + tr[i];\n  }\n  for(int i=1; i < 1000000; i++) {\n      dp1[i] = 1000111000;\n      dp2[i] = 1000111000;\n  }\n\n  cout << sq[30] << endl;\n  for(int i=0; i<1000000; i++) {\n    for(int j=1; j < 300; j++) {\n      if(i+sq[j] < 1000000) {\n        dp1[i+sq[j]] = min(dp1[i] + 1, dp1[i+sq[j]]);\n        if(sq[j]%2 == 1) {\n          dp2[i+sq[j]] = min(dp2[i] + 1, dp2[i+sq[j]]);\n        }\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n, n) {\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXN 1000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint dp[MAXN+1];\nint dp2[MAXN+1];\n\nint main(void) {\n    for (int j = 0; j <= MAXN; j++) {\n        dp[j] = INF;\n        dp2[j] = INF;\n    }\n    dp[0] = 0; dp[1] = 1;\n    dp2[0] = 0; dp2[1] = 1;\n    // DP\n    for (int i = 1; i < 200; i++) {\n        int plus = i * (i+1) * (i+2) / 6;\n        for (int j = 1; j <= MAXN; j++) {\n            if (j - plus >= 0) dp[j] = min(dp[j], dp[j-plus] + 1);\n            else dp[j] = dp[j];\n        }\n        if (plus % 2 == 1) {\n            for (int j = 1; j <= MAXN; j++) {\n                if (j - plus >= 0) dp2[j] = min(dp2[j], dp2[j-plus] + 1);\n                else dp2[j] = dp2[j];\n            }\n        } else {\n            for (int j = 1; j <= MAXN; j++) {\n                dp2[j] = dp2[j];\n            }\n        }\n    }\n//    for (int i = 1; i < 5; i++) {\n//        for (int j = 1; j <= 10; j++) {\n//            cout << dp2[i][j] << \" \";\n//        }\n//        cout << endl;\n//    }\n    int n;\n    while (1) {\n        cin >> n;\n        if (n == 0) break;\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <list>\n#include <stack>\n#include <queue>\n#define INF 1000000\nusing namespace std;\n\ntypedef list<int> L;\ntypedef pair <int,int> P;\ntypedef vector<int> V;\ntypedef queue<int> Q;\ntypedef stack<int> S;\ntypedef map<string,int> M;\n\nint N;\nint dp[1000001];\nint dp2[1000001];\nint tetra[1000];\n\nint main()\n{\n    for (int i = 0; i <= INF; i++) {dp[i] = INF;dp2[i] = INF;}\n    int n = 1;\n    int tmp;\n    while ((tmp = (n * (n + 1) * (n + 2) / 6)) <= 1000000) {\n        tetra[n++] = tmp;\n        dp[tmp] = 1;\n        if (tmp % 2) dp2[tmp] = 1;\n    }\n    int max = 1;\n    while (cin >> N, N) {\n        if (max > N) {\n            cout <<  dp[N] << \" \";\n        } else {\n            for (int i = max; i <= N; i++) {\n                for (int j = 1; tetra[j] <= i; j++) {\n                    dp[i] = min(dp[i], dp[i - tetra[j]] + 1);\n                }\n            }\n            cout << dp[N] << \" \";\n        }\n\n        if (max > N) {\n            cout << dp2[N] << endl;\n        } else {\n            for (int i = max; i <= N; i++) {\n                for (int j = 1; tetra[j] <= i; j++) {\n                    if (tetra[j] % 2)\n                        dp2[i] = min(dp2[i], dp2[i - tetra[j]] + 1);\n                }\n            }\n            cout << dp2[N] << endl;\n            max = N;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lpin(a,i,n) for(int i=0;i<n;i++){cin>>a[i];}\nusing namespace std;\nint ans[100000],check[100000];\nint main(){\n  list<int> l;\n  list<int>::iterator it;\n  it = l.end();\n  int n;\n  cin>>n;\n  lp(i,n){\n    int a,b;\n    cin>>a;\n    if(a==0){\n      cin>>b;\n      l.insert(it, b);\n      it++;\n    }\n    if(a==1){\n      cin>>b;\n      it = l.begin()+b;\n    }\n    if(a==2){\n      l.erase(it);\n      if(it--) 1;\n      else it= l.end();\n    }\n  }\n  it=l.begin();\n  while(it!=l.end()){\n    cout<<*it<<endl;\n    it++;\n  }\n      \n    \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing ll = long long;\n\n#define N 1000007\nll s[N], t[N];\n\nint main() {\n\n    for(ll i=0; i<N; ++i) s[i] = t[i] = 10000000;\n    s[0] = t[0] = 0;\n    for(ll i=0; i<N; ++i) {\n        ll j = 1;\n        while(i + j*(j+1)*(j+2)/6 < N) {\n            ll p = j*(j+1)*(j+2)/6;\n            s[i+p] = min(s[i]+1, s[i+p]);\n            if(p % 2 == 1) {\n                t[i+p] = min(t[i]+1, t[i+p]);\n            }\n            ++j;\n        }\n    }\n\n    int n;\n    while(cin >> n && n) {\n        cout << s[n] << \" \" << t[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep2(i, s, n) for (int i = s; i < (int)(n); i++)\n#define rep3(i, s, n) for (int i = s; i > (int)(n); i--)\n#define all(obj) obj.begin(), obj.end()\n#define from1(obj) obj.begin() + 1, obj.end()\n#define db(x) cerr << #x << \":\" << x << \" \"\n#define dbl(x) cerr << #x << \":\" << x << \"\\n\"\n#define dbp(p) cerr << #p << \":(\" << p.first << \", \" << p.second << \") \"\n#define dbpl(p) cerr << #p << \":(\" << p.first << \", \" << p.second << \")\\n\"\n#define dbt3(t3) cerr << #t3 << \":(\" << get<0>(t3) << \", \" << get<1>(t3) << \", \" << get<2>(t3) << \") \"\n#define dbt3l(t3) cerr << #t3 << \":(\" << get<0>(t3) << \", \" << get<1>(t3) << \", \" << get<2>(t3) << \")\\n\"\n#define dbt4(t4) cerr << #t4 << \":(\" << get<0>(t4) << \", \" << get<1>(t4) << \", \" << get<2>(t4) << \", \" << get<3>(t4) << \") \"\n#define dbt4l(t4) cerr << #t4 << \":(\" << get<0>(t4) << \", \" << get<1>(t4) << \", \" << get<2>(t4) << \", \" << get<3>(t4) << \")\\n\"\n#define dbv(vec) cerr << #vec << \":{ \"; for (auto e : vec) cerr << e << \", \"; cerr << \"}\\n\"\n#define dbvv(vv) cerr << #vv << \":{\\n\"; for (auto vec : vv) { cerr << \"{ \"; for (auto e : vec) cerr << e << \", \"; cerr << \"}\\n\"; } cerr << \"}\\n\"\n#define dbm(map) cerr << #map << \":{ \"; for (auto p : map) cerr << \"(\" << p.first << \", \" << p.second << \"), \"; cerr << \"}\\n\"\n#define YN(f) cout << (f ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(f) cout << (f ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(f) cout << (f ? \"yes\" : \"no\") << \"\\n\"\nusing ll = long long;\nusing vi = vector<int>; using vl = vector<ll>; using vs = vector<string>; using vb = vector<bool>;\nusing vvi = vector<vi>; using vvl = vector<vl>; using vvb = vector<vb>;\nusing pii = pair<int, int>; using pil = pair<int, ll> ; using pll = pair<ll, ll>; using pli = pair<ll, int>;\nusing vpii = vector<pii>; using vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>; using tl3 = tuple<ll, ll, ll>;\nusing ti4 = tuple<int, int, int, int>; using tl4 = tuple<ll, ll, ll, ll>;\nusing mii = map<int, int>; using mil = map<int, ll>; using mll = map<ll, ll>; using mli = map<ll, int>;\n\nint main() {\n\tconst int x = 1e6;\n\tvi T, U;\t\n\tfor (int n = 1; ; n++) {\n\t\tint Tn = n * (n + 1) * (n + 2) / 6;\n\t\t// db(n); dbl(Tn);\n\t\tif (Tn > x) break;\n\t\tT.push_back(Tn);\n\t\tif (Tn % 2) U.push_back(Tn);\n\t}\n\t// dbv(T); dbv(U);\n\t// db(T.size()); dbl(U.size());\n\t\t\t\n\tvi dp(x + 1); // dp[j]:jを作るのに必要な正四面体数の個数(i番目の正四面体数T[i]までで作る場合)\n\tvi ep(x + 1); // dp[j]:jを作るのに必要な奇数の正四面体数の個数(i番目の奇数の正四面体数U[i]までで作る場合)\n\trep(j, x + 1) { dp[j] = j; ep[j] = j; }\n\t// dbv(dp);\n\tfor (int i = 0; i < T.size() and T[i] <= x; i++) {\t\t\t\n\t\trep(j, x + 1 - T[i]) {\t\t\t\t\n\t\t\tdp[j + T[i]] = min(dp[j + T[i]], dp[j] + 1);\t\t\t\t\n\t\t}\n\t\t// db(i); dbl(T[i]); dbv(dp);\n\t}\n\t// dbv(ep);\n\tfor (int i = 0; i < U.size() and U[i] <= x; i++) {\n\t\trep(j, x + 1 - U[i]) {\n\t\t\tep[j + U[i]] = min(ep[j + U[i]], ep[j] + 1);\n\t\t}\n\t\t// db(i); dbl(U[i]); dbv(ep);\n\t}\n\twhile (true) {\n\t\tint y; cin >> y;\n\t\tif (!y) break;\n\t\tcout << dp[y] << \" \" << ep[y] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint N = (int)1e6;\n\nint main(void){\n    vi sa, saodd;\n    for(int a = 1, next; (next = a * (a + 1) * (a + 2) / 6) < N; a++){\n        sa.pb(next);\n        if(next % 2) saodd.pb(next);\n    }\n\n    vi dp(N, inf), dpodd(N, inf);\n    dp[0] = 0; dpodd[0] = 0;\n    rep(i, N){\n        rep(j, sa.size()){\n            if(N <= i + sa[j]) break;\n            dp[i + sa[j]] = min(dp[i + sa[j]], dp[i] + 1);\n        }\n        rep(j, saodd.size()){\n            if(N <= i + saodd[j]) break;\n            dpodd[i + saodd[j]] = min(dpodd[i + saodd[j]], dpodd[i] + 1);\n        }\n    }\n\n    for(int n; cin >> n, n; cout << dp[n] << \" \" << dpodd[n] << endl);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1000001];\nint memo2[1000001];\n \nint solve(int n){\n\n  if(!n) return 0;\n  if(memo[n]) return memo[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n; i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(memo2[n]) return memo2[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++){\n    if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n  }\n   \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i+=5000) solve(i), solve2(i);\n   \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nint dp1[100010]={0};\nint dp2[100010]={0};\nint List[100];\n\nvoid setpolloc(){\n\tint i,j,li;\n/*\tfor(i=1;i*(i+1)*(i+2)/6<=100000;i++){\n\t\tList[i]=i*(i+1)*(i+2)/6;\n\t\tdp1[i*(i+1)*(i+2)/6]=1;\n\t\tif((i*(i+1)*(i+2)/6)%2) dp2[i*(i+1)*(i+2)/6]=1;\n\t}\n\tList[i]=i*(i+1)*(i+2)/6;\n\tfor(i=1;i<=100000;i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j+=2)if(!dp2[i] || dp2[List[j]]+dp2[i-List[j]] < dp2[i]) dp2[i]=dp2[List[j]]+dp2[i-List[j]];\n\t\tif(dp1[i]) continue;\n\t\tfor(j=1;List[j]<=i-1;j++) if(!dp1[i] || dp1[List[j]]+dp1[i-List[j]] < dp1[i]) dp1[i]=dp1[List[j]]+dp1[i-List[j]];\n\t}\n*/}\n\n\nint main(){\n\tint n;\n\tsetpolloc();\n\twhile(cin>>n,n){\n\t\tcout << dp1[n] << ' ' << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nint n, a[1000000];\n\nvoid set() {\n\tfor (int i = 0; i < 1000000; i++) {\n\t\ta[i] = 1;\n\t\tfor (int j = 1; j <= 3; j++) {\n\t\t\ta[i] *= (i + j);\n\t\t}\n\t\ta[i] /= 6;\n\t\tif (a[i] > 1000000)break;\n\t}\n}\n\nint main() {\n\tset();\n\n\twhile (true) {\n\t\tcin >> n;\n\n\t\tif (n == 0)break;\n\n\t\tint b;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint c = 1;\n\t\t\tfor (int j = 1; j <= 3; j++) {\n\t\t\t\tc *= (i + j);\n\t\t\t}\n\t\t\tc /= 6;\n\t\t\t//cout << \"c:\" << c << endl;\n\t\t\tif (c <= n) {\n\t\t\t\tb = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint sum1 = n, ans1 = 0, sum2 = n, ans2 = 0, sum3 = n, ans3 = 0;\n\t\tfor (int i = b; i >= 0; i--) {\n\t\t\t//cout << \"a[i]:\" << a[i] << \"i:\" << i << endl;\n\t\t\twhile (sum1 >= a[i]) {\n\t\t\t\t//cout << \"sum1:\" << sum1 << endl;\n\t\t\t\tsum1 -= a[i];\n\t\t\t\tans1++;\n\t\t\t}\n\n\t\t\tif (i != b) {\n\t\t\t\twhile (sum2 >= a[i]) {\n\t\t\t\t\t//cout << \"sum2:\" << sum2 << \"a[i]:\" << a[i] << \"i:\" << i << endl;\n\t\t\t\t\tsum2 -= a[i];\n\t\t\t\t\tans2++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a[i] % 2 == 1) {\n\t\t\t\twhile (sum3 >= a[i]) {\n\t\t\t\t\tsum3 -= a[i];\n\t\t\t\t\tans3++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << min(ans1, ans2) << \" \" << ans3 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define itrep(it, a) for(it = (a).begin(); it != (a).end(); it++)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 30)\nusing namespace std;\n\nint dp1[2000050];\nint dp2[2000050];\n\nvoid solve(){\n    vector<int> va;\n    vector<int> vb;\n    for(int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; i++){\n        int a = i * (i + 1) * (i + 2) / 6;\n        va.push_back(a);\n        if(a % 2 == 1) vb.push_back(a);\n    }\n    rep(i,1000005){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    dp1[0] = dp2[0] = 0;\n\n    rep(i,va.size()){\n        rep(j, 1000000){\n            if(dp1[j] != INF){\n                dp1[j + va[i]] = min(dp1[j + va[i]], dp1[j] + 1);\n            }\n        }\n    }\n    rep(i,vb.size()){\n        rep(j, 1000000){\n            if(dp2[j] != INF){\n                dp2[j + vb[i]] = min(dp2[j + vb[i]], dp2[j] + 1);\n            }\n        }\n    }\n}\n\nint main(){\n    int n;\n    solve();\n    while(cin >> n, n){\n        cout << dp1[n] << ' ' << dp2[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000\nusing namespace std;\n\nconst int M = 1000000;\nint N, dp1[M + 1], dp2[M + 1];\n\nint main(void) {\n  REP(i, 1, M) dp1[i] = dp2[i] = i;\n\n  for(int i = 1, n; n = i * (i + 1) * (i + 2) / 6, n <= M; i++) {\n    for(int j = 1; j + n <= M; j++) {\n      dp1[j + n] = min(dp1[j + n], dp1[j] + 1);\n      if(n % 2 == 1) {\n        dp2[j + n] = min(dp2[j + n], dp2[j] + 1);\n      }\n    }\n  }\n\n  while(cin >> N, N) {\n    cout << dp1[N] << \" \" << dp2[N] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[1111111];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=199;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=0;p[i]<=n;i++) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<200;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename TYPE>\nvoid print_vec(const vector<TYPE>& v){\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << v[i] << \" \";\n\t}\n\tcout << endl;\n}\n\ntemplate <typename TYPE>\nvoid print_vec2(const vector<vector<TYPE>>& v){\n  cout << endl; cout << \"       \";\n  for(int i=0; i<v[0].size(); i++) cout << i << \"   \"; \n  cout << endl;\n\tfor(int i=0; i<v.size(); i++){\n\t\tcout << \"i=\" << i << \":   \";\n\t\tfor(int j=0; j<v[i].size(); j++){\n\t\t\tif(v[i][j] == 0) cout << \"\\x1B[0m\" << v[i][j] << \"   \";\n      else cout << \"\\x1B[31m\" << v[i][j] << \"   \";//https://stackoverrun.com/ja/q/12618775\n\t\t}\n\t\tcout << \"\\x1B[0m\" << endl;\n\t}\n}\n\n////////////////////////////////////////////////////////////////\n\nint chmin(int &a, int b){return a = min(a, b);}\n\nint main(void) {\n\tint MAX = 0;\n\tvector<int> input;\n\twhile(true){\n\t\tint x;\n\t\tcin >> x;\n\t\tif(x == 0) break;\n\t\tinput.push_back(x);\n\t\tMAX = max(MAX, x);\n\t}\n\n\tconst int TETRA_MAX = 1000;\n\t// dp1[i]: 正整数iを作るときに必要な四面体数の最小個数\n\tvector<int> dp1(MAX+1, MAX+1);\n\tdp1[0] = 0;\n\tfor(int i=0; i<TETRA_MAX; i++){\n\t\tint tetra = (i+1)*(i+2)*(i+3)/6;\n\t\tfor(int j=0; j<=MAX; j++){\n\t\t\t//chmin(dp1[j], dp1[j]);\n\t\t\tif(j+tetra <= MAX) chmin(dp1[j+tetra], dp1[j]+1);//これだと 同じ四面体数を複数回使うことを考慮できてないと思われる\n\t\t\t//if(j+tetra <= MAX) chmin(dp1[j+tetra], dp1[j]+1);\n\t\n\t\t\t//if(j-tetra >= 0) chmin(dp1[j], dp1[j-tetra] + 1);//もらうdp\n\t\t}\t\n\t}\t\n\n\t// vector<ll> odd_tetras;\n\t// for(int i=0; i<TETRA_MAX; i++){\n\t// \tll tetra = (i+1)*(i+2)*(i+3)/6;\n\t// \tif(tetra % 2 == 0) continue;\n\t// \todd_tetras.push_back(tetra);\n\t// }\n\t// dp2[i]: 正整数iを作るときに必要な奇数の四面体数の最小個数\n\tvector<int> dp2(MAX+1, MAX+1);\n\tdp2[0] = 0;\n\tfor(int i=0; i<TETRA_MAX; i++){\n\t\tint tetra = (i+1)*(i+2)*(i+3)/6;\n\t\tif(tetra % 2 == 0) continue;\n\t\tfor(int j=0; j<=MAX; j++){\n\t\t\t//chmin(dp2[j], dp2[j]);\n\t\t\tif(j+tetra <= MAX) chmin(dp2[j+tetra], dp2[j]+1);//これだと 同じ四面体数を複数回使うことを考慮できてないと思われる\n\t\t\t//if(j+tetra <= MAX) chmin(dp2[j+tetra], dp2[j]+1);\n\n\t\t\t//if(j-tetra >= 0) chmin(dp2[j], dp2[j-tetra] + 1);//もらうdp\n\t\t}\t\n\t}\t\n\n\tfor(int i=0; i<(int)input.size(); i++){\n\t\tcout << dp1[input[i]] << \" \" << dp2[input[i]] << endl;\n\t}\n\n\n\t//以下2次元のdp　だけど メモリエラーになったので1次元でやりましょう\n\t// const int TETRA_MAX = 100;\n\t// // dp1[i][j]: (i-1)番目までの四面体数を使って，正整数jを作るときに必要な四面体数の最小個数\n\t// vector<vector<ll>> dp1(TETRA_MAX+1, vector<ll>(MAX+1, MAX+1));\n\t// dp1[0][0] = 0;\n\t// for(ll i=0; i<TETRA_MAX; i++){\n\t// \tll tetra = (i+1)*(i+2)*(i+3)/6;\n\t// \tfor(int j=0; j<=MAX; j++){\n\t// \t\tchmin(dp1[i+1][j], dp1[i][j]);\n\t// \t\tif(j+tetra<=MAX) chmin(dp1[i+1][j+tetra], dp1[i][j]+1);\n\t// \t\tif(j+tetra<=MAX) chmin(dp1[i+1][j+tetra], dp1[i+1][j]+1);\n\t// \t}\n\t// }\n\n\t// vector<ll> odd_tetras;\n\t// for(int i=0; i<TETRA_MAX; i++){\n\t// \tll tetra = (i+1)*(i+2)*(i+3)/6;\n\t// \tif(tetra % 2 == 0) continue;\n\t// \todd_tetras.push_back(tetra);\n\t// }\n\t\n\t// //dp2[i][j]: (i-1)番目までの四面体数の中の奇数のモノのみを使って，\n\t// //正整数jを作るときに必要な四面体数の最小個数\n\t// vector<vector<ll>> dp2(odd_tetras.size()+1, vector<ll>(MAX+1, MAX+1));\n\t// dp2[0][0] = 0;\n\t// for(int i=0; i<dp2.size()-1; i++){\n\t// \tll tetra = odd_tetras[i];\n\t// \tfor(int j=0; j<=MAX; j++){\n\t// \t\tchmin(dp2[i+1][j], dp2[i][j]);\n\t// \t\tif(j+tetra<=MAX) chmin(dp2[i+1][j+tetra], dp2[i][j]+1);\n\t// \t\tif(j+tetra<=MAX) chmin(dp2[i+1][j+tetra], dp2[i+1][j]+1);\n\t// \t}\n\t// }\n\t\n\t\n\n\t// for(int i=0; i<input.size(); i++){\n\t// \tcout << dp1[dp1.size()-1][input[i]] << \" \" << dp2[dp2.size()-1][input[i]] <<  endl;\n\t// }\n\t\n\n}\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    int M = 1000000;\n    vector<int> v, u;\n    for (int i = 1; i*(i+1)*(i+2)/6 <= M; ++i) {\n        v.emplace_back(i*(i+1)*(i+2)/6);\n        if(v[i-1]&1) u.emplace_back(v[i-1]);\n    }\n    v.emplace_back(MOD);\n    u.emplace_back(MOD);\n    vector<int> dp(M, INF<int>);\n    dp[0] = 0;\n    for (int i = 0; i < M; ++i) {\n        for (int j = 0; v[j] <= i; ++j) {\n            chmin(dp[i], dp[i-v[j]]+1);\n        }\n    }\n    vector<int> dq(M, INF<int>);\n    dq[0] = 0;\n    for (int i = 0; i < M; ++i) {\n        for (int j = 0; u[j] <= i; ++j) {\n            chmin(dq[i], dq[i-u[j]]+1);\n        }\n    }\n    int p;\n    while(cin >> p, p){\n        cout << dp[p] << \" \" << dq[p] << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define INF 100000000\nusing namespace std;\n\nconst int M = 1000000;\nint N, dp1[M + 1], dp2[M + 1];\n\nint main(void) {\n  REP(i, 1, M) dp1[i] = dp2[i] = i;\n\n  for(int i = 1, n; n = i * (i + 1) * (i + 2) / 6, n <= M; i++) {\n    dp1[n] = 1;\n    if(n % 2 == 1) dp2[n] = 1;\n    for(int j = 1; j + n <= M; j++) {\n      dp1[j + n] = min(dp1[j + n], dp1[j] + 1);\n      if(n % 2 == 1) {\n        dp2[j + n] = min(dp2[j + n], dp2[j] + 1);\n      }\n    }\n  }\n\n  while(cin >> N, N) {\n    cout << dp1[N] << \" \" << dp2[N] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nll dp[1000010];\nll dp2[1000010];\nll n3[1000010],s3;\nll n4[1000010],s4;\nll n5[1000010],s5;\nint rec(int x){\n  if(dp[x]!=-1)return dp[x];\n  int ans=1e9;\n  for(int i=1;i<s4;i++){\n    if(n4[i]>x)break;\n    ans=min(ans,rec(x-n4[i])+1);\n  }\n  return dp[x]=ans;\n}\n\nint rec2(int x){\n  if(dp2[x]!=-1)return dp2[x];\n  int ans=1e9;\n  for(int i=0;i<s5;i++){\n    if(n5[i]>x)break;\n    ans=min(ans,rec2(x-n5[i])+1);\n  }\n  return dp2[x]=ans;\n}\n\n\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  memset(dp2,-1,sizeof(dp2));\n  dp[0]=dp2[0]=0;\n  for(int i=1;;i++){\n    n3[i]=n3[i-1]+i;\n    s3=i+1;\n    if(n3[i]>1e6)break;\n  }\n  for(int i=1;;i++){\n    n4[i]=n4[i-1]+n3[i];\n    s4=i+1;\n    if(n4[i]%2){\n      n5[s5++]=n4[i];\n    }\n    if(n4[i]>1e6)break;\n    dp[n4[i]]=1;\n    dp2[n5[s5-1]]=1;\n  }\n  int n;\n  while(cin>>n,n){\n    cout<<rec(n)<<\" \"<<rec2(n)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int MAX_N = 1000011;\nint dp1[MAX_N+2];\nint dp2[MAX_N+2];\nvi w1;\nvi w2;\nint N;\n\ninline int get(int i){ return i * (i + 1) / 2 * (i + 2) / 3; }\n\nint main()\n{\n  rrep(i, 1, MAX_N){\n    if(get(i) >= MAX_N) break;\n    w1.pb(get(i));\n    if(get(i) & 1) w2.pb(get(i));\n  }\n  int n1 = w1.size();\n  int n2 = w2.size();\n\n  rep(i, MAX_N) dp1[i] = dp2[i] = INF;\n  rep(i, n1) dp1[w1[i]] = 1;\n  rep(i, n2) dp2[w2[i]] = 1;\n  rrep(i, 1, MAX_N) rep(j, n1) if(i + w1[j] < MAX_N) minup(dp1[i + w1[j]], dp1[i] + 1);\n  rrep(i, 1, MAX_N) rep(j, n2) if(i + w2[j] < MAX_N) minup(dp2[i + w2[j]], dp2[i] + 1);\n\n  while(cin >> N, N) cout << dp1[N] << ' ' << dp2[N] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    const int M = 1e6 + 10;\n    vector<int> dp1(M,INF),dp2(M,INF);\n    dp1[0] = dp2[0] = 0;\n    for (int n = 1; ; ++n) {\n        int x = n*(n+1)*(n+2)/6;\n        if (x > M) break;\n\n        rep (j,M) if (j+x < M) {\n            chmin(dp1[j+x], dp1[j] + 1);\n            if (x%2 == 1) {\n                chmin(dp2[j+x], dp2[j] + 1);\n            }\n        }\n    }\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        cout << dp1[n] << \" \" << dp2[n] << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>//sort,二分探索,など\n#include<bitset>//固定長bit集合\n#include<cmath>//pow,logなど\n#include<complex>//複素数\n#include<deque>//両端アクセスのキュー\n#include<functional>//sortのgreater\n#include<iomanip>//setprecision(浮動小数点の出力の誤差)\n#include<iostream>//入出力\n#include<map>//map(辞書)\n#include<numeric>//iota(整数列の生成),gcdとlcm(c++17)\n#include<queue>//キュー\n#include<set>//集合\n#include<stack>//スタック\n#include<string>//文字列\n#include<utility>//pair\n#include<list>\n#include<vector>//可変長配列\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define pb push_back\n#define ll __int64\n#define __int64 long long\n#define P pair<int,int>\n#define PP pair<P,int>\n#define F first\n#define S second\n\n\nint n;\nvector<int>simen;\nvector<int>ki_simen;\nconst int MAX_N = 1e6;\nint dp[MAX_N + 1];\nint dp2[MAX_N + 1];\n\nvoid init() {\n\n    for (int i = 1; i * (i + 1) * (i + 2) / 6 <= MAX_N; i++) {\n        int now = i * (i + 1) * (i + 2) / 6;\n        simen.pb(now);\n        if (now % 2)\n            ki_simen.pb(now);\n    }\n}\n\n\nvoid solve() {\n    rep(i, MAX_N+ 1)dp[i] = MAX_N;\n    dp[0] = 0;\n\n    rep(i, simen.size()) {\n        rep(j, MAX_N+1) {\n            if (j + simen[i] <= MAX_N)\n                dp[j + simen[i]] = min(dp[j + simen[i]], dp[j] + 1);\n            else break;\n        }\n    }\n\n\n    rep(i, MAX_N+ 1)dp2[i] = MAX_N;\n    dp2[0] = 0;\n    rep(i, ki_simen.size()) {\n        rep(j, MAX_N+1) {\n            if (j + ki_simen[i] <= MAX_N)\n                dp2[j + ki_simen[i]] = min(dp2[j + ki_simen[i]], dp2[j] + 1);\n            else break;\n        }\n    }\n}\n\nint main() {\n\n    init();       \n    solve();\n\n    while (cin >> n, n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstring>\n\n#define REP(i,a,b)for(long long i=(long long)a;i<(long long)b;i++)\n#define min(a,b)(a<b?a:b)\n\nusing namespace std;\n\nint mem[200]={0};\nint ary[1000010]={0};\nint ary_kisu[1000010]={0};\n\nint cul(int n){\n\treturn \t((n*(n+1)*(n+2))/6);\n}\n\nint main(void){\n\n\tREP(i,0,200) mem[i]=cul(i);\n\t\n\tREP(i,1,1000010) ary[i]=999999;\n\tREP(i,1,1000010) ary_kisu[i]=999999;\n\n\tREP(j,1,200){\n\t\tREP(i,mem[j],1000001){\n\t\t\tif(i-mem[j]>=0)\n\t\t\t\tary[i]=min(ary[i],ary[i-mem[j]]+1);\n\t\t}\n\t}\n\n\tREP(j,1,200){\n\t\tif(1&mem[j]){\n\t\t\tREP(i,mem[j],1000001){\n\t\t\t\tif(i-mem[j]>=0)\n\t\t\t\t\tary_kisu[i]=min(ary_kisu[i],ary_kisu[i-mem[j]]+1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(1){\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif(!n)break;\n\n\t\tcout << ary[n]<<\" \"<<ary_kisu[n]<<endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint d[1<<21],e[1<<21],x[1<<21],y[1<<21];\nmain(){\n  for(int i=0;i<1<<20;++i)d[i]=e[i]=i;\n  \n  for(int i=1,j=1;i<300;++i){\n    x[i]=i*(i+1)*(i+2)/6,d[x[i]]=1;\n    if(x[i]%2)y[j]=x[i],e[y[j++]]=1;\n  }\n  \n  for(int i=1;i<1000001;++i)\n    for(int j=1;i+x[j]<300;++j){\n      d[i+x[j]]=min(d[i+x[j]],d[i]+1);\n    }\n  for(int i=1;i<1000001;++i)\n    for(int j=1;i+y[j]<300;++j){\n      e[i+y[j]]=min(e[i+y[j]],e[i]+1);\n    }\n  int n;\n  while(cin>>n,n){\n    cout<<d[n]<<' '<<e[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\n//vector<vector<int>> dp;\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//dp.resize(C_N + 2);\n\t\t/*for (int i = 0; i < C_N + 2; i++) {\n\t\t\tdp[i].resize(N + 2);\n\t\t}*/\n\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}\n\t\t\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < C[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t/*for (int i = 1; i <= N; i++) {\n\t\t\tdp[0][i] = 1001000;\n\t\t}*/\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= C_N; j++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tCO dp[C_N][N] E\n\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n#include<list>\n#include<stack>\n\nusing namespace std;\n\nusing ll = long long int;\nconst ll MOD = 1000000007;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    vector<ll> allNum;\n    vector<ll> oddNum;\n\n    ll n = 1;\n\n    while(true){\n        ll tmp = (n*(n+1)*(n+2))/6;\n        if(tmp > 1000000){\n            break;\n        }\n        allNum.push_back(tmp);\n        if(tmp&1){\n            oddNum.push_back(tmp);\n        }\n        ++n;\n    }\n\n    vector<ll> allDP(1000001,-1);\n    vector<ll> oddDP(1000001,-1);\n\n    allDP[0] = 0;\n    oddDP[0] = 0;\n\n    for(int i = 0; i < allNum.size(); i++){\n        for(int j = 0; j < 1000001; j++) {\n            if (j - allNum[i] >= 0 && allDP[j - allNum[i]] >= 0) {\n                if (allDP[j] >= 0) {\n                    allDP[j] = min(allDP[j], allDP[j - allNum[i]] + 1);\n                } else {\n                    allDP[j] = allDP[j - allNum[i]] + 1;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < oddNum.size(); i++){\n        for(int j = 0; j < 1000001; j++) {\n            if (j - oddNum[i] >= 0 && oddDP[j - oddNum[i]] >= 0) {\n                if (oddDP[j] >= 0) {\n                    oddDP[j] = min(oddDP[j], oddDP[j - oddNum[i]] + 1);\n                } else {\n                    oddDP[j] = oddDP[j - oddNum[i]] + 1;\n                }\n            }\n        }\n    }\n\n    while(true){\n        ll a;\n        cin >> a;\n        if(a == 0){\n            break;\n        }\n        cout << allDP[a] << \" \";\n        cout << oddDP[a] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n\n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n\n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint n;\n\n#define MAX 1000000\nvector<int> tri;\n\nint dp[MAX];\nint odd_dp[MAX];\n\nvoid gentri()\n{\n\tfor (int i = 1;; i++) {\n\t\tint t = i*(i+1)*(i+2)/6;\n\t\tif (t >= MAX) break;\n\t\ttri.push_back(t);\n\t}\n}\n\nint main(void)\n{\n\tgentri();\n\n\tdp[0] = 0;\n\todd_dp[0] = 0;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tdp[i] = i;\n\t\todd_dp[i] = i;\n\t\t\n\t\trep(j, tri.size()) {\n\t\t\tint t = i-tri[j];\n\t\t\tif (t < 0) break;\n\t\t\tdp[i] = min(dp[i], dp[t]+1);\n\n\t\t\tif (tri[j]%2!=0)\n\t\t\t\todd_dp[i] = min(odd_dp[i], odd_dp[t]+1);\n\t\t}\n\t}\n\t\n\twhile(cin >> n, n) {\n\t\tcout << dp[n] << \" \" << odd_dp[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nll cost[2010100] = {0};\nll cost2[2010100] = {0};\nvector<ll> edge, edge2;\nstruct N {\n  ll v, d;\n};\nll M = 1000000;\nll INF = 1001010100101010;\nbool operator<(const N &l, const N &r) { return l.d > r.d; }\nint main() {\n  for (int i = 1; i < 10000; i++) {\n    ll ne = i * (i + 1) * (i + 2) / 6;\n    if (ne > M)\n      break;\n    edge.push_back(ne);\n    if (ne % 2 == 1)\n      edge2.push_back(ne);\n  }\n\n  priority_queue<N> q, q2;\n  for (auto &j : edge)\n    q.push(N{j, 1});\n  for (auto &j : edge2)\n    q2.push(N{j, 1});\n  for (int i = 0; i < M; i++)\n    cost[i] = cost2[i] = INF;\n\n  while (q.size()) {\n    N now = q.top();\n    q.pop();\n    if (cost[now.v] < now.d)\n      continue;\n    cost[now.v] = now.d;\n    for (auto &j : edge) {\n      ll next = now.v + j;\n      if (cost[next] < INF || next > M)\n        continue;\n      cost[next] = now.d + 1;\n      q.push(N{next, now.d + 1});\n    }\n  }\n\n  while (q2.size()) {\n    N now = q2.top();\n    q2.pop();\n    if (cost2[now.v] < now.d)\n      continue;\n    cost2[now.v] = now.d;\n    for (auto &j : edge2) {\n      ll next = now.v + j;\n      if (cost2[next] < INF || next > M)\n        continue;\n      cost2[next] = now.d + 1;\n      q2.push(N{next, now.d + 1});\n    }\n  }\n\n  while (true) {\n    ll n;\n    cin >> n;\n    if (n == 0)\n      break;\n    cout << cost[n] << \" \" << cost2[n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(void)\n{\n\tint n;\n\tint i1,i2;\n\tint nn;\n\tint min;\n\tint num;\n\tint max;\n\tvector<int> v;\n\t\n\t\n\n\tmax=0;\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(max<n) max=n;\n\t\tv.push_back(n);\n\t\tif(n==0) break;\n\t}\n\n\tvector<int> pollock(max+1,0);\n\tvector<int> pollock2(max+1,0);\n\tvector<int> p;\n\tvector<int> p2;\n\tnn=1;\n\tnum=(nn*(nn+1)*(nn+2))/6;\n\n\tfor(i1=1;i1<=max;i1++){\t\t\t\n\n\t\tif(i1==num) {\n\t\t\tif(i1%2==1){\n\t\t\t\tp.push_back(i1);\n\t\t\t\tp2.push_back(i1);\n\t\t\t\tnn++;\n\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6;\n\t\t\t\tpollock[i1]=1;\n\t\t\t\tpollock2[i1]=1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnn++;\n\t\t\t\tnum=(nn*(nn+1)*(nn+2))/6;\n\t\t\t\tp.push_back(i1);\n\t\t\t\tpollock[i1]=1;\n\t\t\t\tmin=100000;\n\t\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpollock2[i1]=min+1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmin=100000;\n\t\t\tfor(i2=0;i2<p.size();i2++){\n\t\t\t\tif((pollock[i1-p[i2]])<min){\n\t\t\t\t\tmin=pollock[i1-p[i2]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpollock[i1]=min+1;\n\n\t\t\tmin=100000;\n\t\t\tfor(i2=0;i2<p2.size();i2++){\n\t\t\t\tif((pollock2[i1-p2[i2]])<min){\n\t\t\t\t\tmin=pollock2[i1-p2[i2]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpollock2[i1]=min+1;\n\t\t}\n\t\t\t//cout<<pollock[i1]<<\" \";\n\t}\n\n\tfor(i1=0;i1<v.size();i1++){\n\n\t\tcout << pollock[v[i1]] << \" \" << pollock2[v[i1]] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\ntemplate <class T>\nbool chmax(T &a, const T &b) {\n    return (a < b) ? (a = b, 1) : 0;\n}\ntemplate <class T>\nbool chmin(T &a, const T &b) {\n    return (b < a) ? (a = b, 1) : 0;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int k = 180;\n    vector<int> a(k);\n    iota(a.begin(), a.end(), 1);\n    for (int i = 1; i < k; ++i) {\n        a[i] += a[i - 1];\n    }\n    for (int i = 1; i < k; ++i) {\n        a[i] += a[i - 1];\n    }\n    vector<int> o;\n    for (int i = 0; i < k; ++i) {\n        if (a[i] % 2 == 1)\n            o.push_back(a[i]);\n    }\n    int l = o.size();\n    vector<int> dp(1000001, 1000000);\n    dp[0] = 0;\n    for (int i = 0; i < k; ++i) {\n        for (int j = 0; j < 1000000; ++j) {\n            if (j + a[i] <= 1000000)\n                chmin(dp[j + a[i]], dp[j] + 1);\n            else\n                break;\n        }\n    }\n    vector<int> dpo(1000001, 1000000);\n    dpo[0] = 0;\n    for (int i = 0; i < l; ++i) {\n        for (int j = 0; j < 1000000; ++j) {\n            if (j + o[i] <= 1000000)\n                chmin(dpo[j + o[i]], dpo[j] + 1);\n            else\n                break;\n        }\n    }\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0)\n            return 0;\n        cout << dp[n] << \" \" << dpo[n] << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1000000\nusing namespace std;\nint t[INF+100],tt[INF+100];\n\nvoid DP(int *a, int x){\n\tfor(int i = x;i <= INF;i++){\n\t\ta[i] = min(a[i],a[i-x]+1);\n\t}\n}\n\nint main(){\n\tint n;\n\tfor(int i = 1;i <= INF;i++){\n\t\tt[i] = tt[i] = INF;\n\t}\n\tt[0] = tt[0] = 0;\n\tfor(int i = 1;;i++){\n\t\tint a = (i*(i+1)*(i+2))/6;\n\t\tif(a > INF)break;\n\t\tDP(t,a);\n\t\tif(a%2 == 1){\n\t\t\tDP(tt,a);\n\t\t}\n\t}\n\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tcout << t[n] << \" \" << tt[n] <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n#include <set>\n#include <stack>\n#include <queue>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing pii = pair<int, int>;\nusing vpii = vector<pii>;\nusing pci = pair<char, int>;\nusing vpci = vector<pci>;\n#define out(S) cout<<(S)<<endl;\n#define REP(i,b) for(size_t i=0;i<(b);i++)\n#define rREP(i,b) for(int i=(b)-1;i>=0;i--)\n#define FOR(i,a,b) for(size_t i=(a);i<(b);i++)\n#define rFOR(i,a,b) for(int i=(a)-1;i>=(b);i--)\n#define Foreach(item,collection) for(auto item:collection)\n#define mod(i) ((i) % (ll)(1e9 + 7))\nll modpow(ll i, ll j) { ll tmp = 1; while (j) { if (j % 2)tmp = mod(tmp*i); i = mod(i*i); j /= 2; }return tmp; }\n#define divmod(a,b) (mod(a * modpow((ll)b,(ll)(1e9 + 5))))\n#define Yes out(\"Yes\")\n#define No out(\"No\")\n#define NO out(\"NO\")\n#define YES out(\"YES\")\n#define INF 1e10;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define IfOut(condition,text) if((condition)){out(text);return 0;}\n#define IfeOut(condition,itext,etext) if(condition){out(itext);return 0;}else{out(etext);return 0;}\n#define beginend(vec) (vec).begin(),(vec).end()\n#define pb(item) push_back(item)\n#define removeAll(vec,deleg) auto itr=remove_if(beginend(vec),deleg);vec.erase(itr,vec.end());\nvoid removeAt(string& s, int index) { s.erase(index, 1); }\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\nll manhattanDistance(ll x1, ll y1, ll x2, ll y2) { return (abs(x2 - x1) + abs(y2 - y1)); }\nvector<ll> sieveOfEratosthenes(int max) {ll prime;double sqrtmax = sqrt(max);vector<ll> primeVec, searchVec;FOR(i, 2, max + 1) searchVec.push_back(i);do{prime = searchVec[0];primeVec.push_back(prime);auto itr = remove_if(beginend(searchVec), [=](ll x)->bool {return x%prime == 0; });searchVec.erase(itr, searchVec.end());} while (prime < sqrtmax);primeVec.reserve(primeVec.size() + searchVec.size());primeVec.insert(primeVec.end(), beginend(searchVec));return primeVec;}\nbool isPrime(ll x) {if (x == 2) return true;if (x < 2 || x % 2 == 0) return false;ll i = 3;while (i <= sqrt(x)) {if (x%i == 0) return false;i += 2;}return true;}\n\nvl dd(int max) {\n\tvl rt;\n\tint n = 1;\n\twhile (true)\n\t{\n\t\tll next = n*(n + 1)*(n + 2) / 6;\n\t\tif (max  <= next) { rt.pb(next); break; }\n\t\trt.pb(next);\n\t\tn++;\n\t}\n\treturn rt;\n}\n\nvl llist;\n\nint bfs(int target) {\n\tqueue<ll> q;\n\tForeach(i, llist) {\n\t\tif (i == target) { return 1; }\n\t\telse if (i < target) q.push(i);\n\t}\n\tint cnt = 2;\n\twhile (1){\n\t\tqueue<ll> next;\n\t\tint ss = q.size();\n\t\tFOR(i, 0, ss) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tForeach(k, llist) {\n\t\t\t\tif (k + x > target) break;\n\t\t\t\tif (k + x == target) return cnt;\n\t\t\t\tif (k + x < target) next.push(k + x);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tq = next;\n\t}\n}\n\nint bfs2(int target) {\n\tqueue<ll> q;\n\tvl oddlist = llist;\n\tremoveAll(oddlist, [](ll x) {return x % 2 == 0; });\n\tForeach(i, oddlist) {\n\t\tif (i == target) { return 1; }\n\t\telse if (i < target) q.push(i);\n\t}\n\tint cnt = 2;\n\twhile (1) {\n\t\tqueue<ll> next;\n\t\tint ss = q.size();\n\t\tFOR(i, 0, ss) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tForeach(k, oddlist) {\n\t\t\t\tif (k + x > target) break;\n\t\t\t\tif (k + x == target) return cnt;\n\t\t\t\tif (k + x < target) next.push(k + x);\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tq = next;\n\t}\n}\n\nint main() {\n\tvi query;\n\tint k;\n\twhile (cin >> k, k)query.pb(k);\n\tauto mm = max_element(beginend(query));\n\tllist = dd(*mm);\n\t//ShowAll(llist);\n\tForeach(q, query) {\n\t\tcout << bfs(q) << \" \" << bfs2(q) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000000;\n\nint d[110], dNumber = 1;\nint f(int c) { return c * (c + 1) * (c + 2) / 6; }\nint dp1[1000000], dp2[1000000];\n\nint main() {\n  while (1) {\n    d[dNumber] = f(dNumber);\n    if (d[dNumber] > 1000000) break;\n    dNumber++;\n  }\n  for (int i = 0; i < 1000000; i++) dp1[i] = dp2[i] = INF;\n  dp1[0] = dp2[0] = 0;\n  for (int i = 1; i < 1000000; i++) {\n    for (int j = 1; j < dNumber; j++) {\n      if (d[j] > i) break;\n      dp1[i] = min(dp1[i], dp1[i - d[j]] + 1);\n      if (d[j] % 2 == 1) dp2[i] = min(dp2[i], dp2[i - d[j]] + 1);\n    }\n  }\n  int N;\n  while (1) {\n    scanf(\"%d\", &N);\n    if (N == 0) break;\n    printf(\"%d %d\\n\", dp1[N], dp2[N]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[1000001];\n\nint main(){\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        int num = 0;\n        for(int j = 1;(num = j * (j + 1) * (j + 2) / 6) <= n;j++) {\n            for(int i = 0;i <= n;i++) {\n                if(i - num >= 0) {\n                    dp[i] = min(dp[i], dp[i - num] + 1);\n                }\n            }\n        }\n\n        cout << dp[n] << ' ';\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        num = 0;\n        int j = 0;\n        while(num <= n) {\n            do{\n                j++;\n                num = j * (j + 1) * (j + 2) / 6;\n            } while(num % 2 != 1);\n            //cout << num << endl;\n            for(int i = 0;i <= n;i++) {\n                if(i - num >= 0) {\n                    dp[i] = min(dp[i], dp[i - num] + 1);\n                }\n                //cout << dp[i] << ' ';\n            }\n            //cout << endl;\n        }\n\n        cout << dp[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#define INF 810114514\n#define MAX 1000000\n\nint dp[MAX];\nint dp_odd[MAX];\nint main(){\n    dp[0] = 0;\n    dp_odd[0] = 0;\n    for(int i=1; i<MAX; i++){\n        dp[i] = MAX+1;\n        dp_odd[i] = MAX+1;\n    }\n    for(int n=1; n*(n+1)*(n+2)/6 < MAX; n++){\n        int p = n*(n+1)*(n+2)/6;\n        for(int i=0; i+p < MAX; i++){\n            dp[i+p] = std::min(dp[i+p], dp[i] + 1);\n            if(p&1) dp_odd[i+p] = std::min(dp_odd[i+p], dp_odd[i] + 1);\n        }\n    }\n    int x;\n    scanf(\"%d\",&x);\n    while(x != 0){\n        printf(\"%d %d\\n\", dp[x], dp_odd[x]);\n        scanf(\"%d\",&x);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nmax 1000000\n#define INF 1000000000\nint dp[nmax],dp2[nmax];\n\n\nint main()\n{\n    for (int i=0;i<nmax;i++)\n    {\n        dp[i]=INF;\n        dp2[i]=INF;\n    }\n    int i=1;\n    dp[0]=0;dp2[0]=0;\n    vector<int> nums;\n    while (i*(i+1)*(i+2)/6<nmax)\n    {\n        nums.push_back(i*(i+1)*(i+2)/6);\n        dp[i*(i+1)*(i+2)/6]=1;\n        if (i*(i+1)*(i+2)/6%2==1) dp2[i*(i+1)*(i+2)/6]=1;\n        i++;\n    }\n    for (int i=0;i<nums.size();i++)\n    {\n        for (int j=0;j<nmax;j++)\n        {\n            if (j+nums[i]<nmax) dp[j+nums[i]]=min(dp[j+nums[i]],dp[j]+1);\n            if (j+nums[i]<nmax && nums[i]%2==1) dp2[j+nums[i]]=min(dp2[j+nums[i]],dp2[j]+1);\n        }\n    }\n    while (true)\n    {\n        int n;cin >> n;\n        if (n==0) break;\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nvector<int> x,y;\nconst int inf=1e6;\nint a[inf],b[inf];\nint main(){\n\tfor(int i=1;;i++){\n\t\tint p=i*(i+1)*(i+2)/6;\n\t\tif(p>=inf) break;\n\t\tx.pb(p);\n\t\tif(p%2) y.pb(p);\n\t}\n\trep(i,inf) a[i]=b[i]=inf;\n\ta[0]=0,b[0]=0;\n\tfor(int p:x){\n\t\trep(i,inf-p){\n\t\t\ta[i+p]=min(a[i+p],a[i]+1);\n\t\t}\n\t}\n\tfor(int p:y){\n\t\trep(i,inf-p){\n\t\t\tb[i+p]=min(b[i+p],b[i]+1);\n\t\t}\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<a[n]<<\" \"<<b[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1e7\n\nusing namespace std;\n\nint main(){\n\tvector<int> t(1,0),t1(1,0);\n\tint c=1;\n\twhile(t[c-1]<=(int)1e6){\n\t\tint temp;\n\t\ttemp=c*(c+1)*(c+2)/6;\n\t\tt.push_back(temp);\n\t\tif(temp%2==1 ){\n\t\t\tt1.push_back(temp);\n\t\t}\n\t\tc++;\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\t\n\t\tint num,num1;\n\t\tnum=distance(t.begin(),upper_bound(t.begin(),t.end(),n)-1);\n\t\tnum1=distance(t1.begin(),upper_bound(t1.begin(),t1.end(),n)-1);\n\n\t\tvector<vector<int> > s(num+1,vector<int>(n+1,INF));\n\t\tvector<vector<int> > s1(num1+1,vector<int>(n+1,INF));\n\t\t\n\t\tfor(int i=0;i<=n;i++){\n\t\t\ts[0][i]=0;\n\t\t\ts[0][i]=0;\n\t\t\ts[1][i]=i;\n\t\t\ts1[1][i]=i;\n\t\t}\n\t\tfor(int i=0;i<=num;i++) s[i][0]=0;\n\t\tfor(int i=0;i<=num1;i++) s1[i][0]=0;\n\n\t\tfor(int i=2;i<=num;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j-t[i]>=0){\n\t\t\t\t\ts[i][j]=min(s[i-1][j],s[i][j-t[i]]+1);\n\t\t\t\t}\n\t\t\t\telse s[i][j]=s[i-1][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=2;i<=num1;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(j-t1[i]>=0){\n\t\t\t\t\ts1[i][j]=min(s1[i-1][j],s1[i][j-t1[i]]+1);\n\t\t\t\t}\n\t\t\t\telse s1[i][j]=s1[i-1][j];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tfor(int j=0;j<s[i].size();j++){\n\t\t\t\tif(s[i][j]==INF) cout << \"0\";\n\t\t\t\telse cout << s[i][j];\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << s[num][n] << \" \" << s1[num1][n] << endl;\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n  int i,j,k;\n  int x,y;\n  int inf = 1 << 10;\n  int m[200]={};\n  int memo[1000005]={};\n  int memo2[1000005]={};\n  vector <int>  odd;\n  fill(memo,memo+1000005,inf);\n  fill(memo2,memo2+1000005,inf);\n  for(i=1;i<201;i++) {\n    m[i-1]=i*(i+1)*(i+2)/6;\n    if(m[i-1]%2==1) odd.push_back(m[i-1]);\n  }\n  memo[0]=0;\n  for(i=0;i<200;i++) {\n    for(j=m[i];j<1000005;j++){\n      memo[j]=min(memo[j],memo[j-m[i]]+1);\n    }\n  }\n  memo2[0]=0;\n  for(i=0;i<odd.size();i++) {\n    for(j=odd[i];j<1000005;j++){\n      memo2[j]=min(memo2[j],memo2[j-odd[i]]+1);\n    }\n  }\n  int n;\n  cin >> n;\n  while(n!=0){\n    cout << memo[n] << \" \" <<  memo2[n] << endl;\n    cin >> n;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[MAXNUM], fourodd[MAXNUM];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tlong long int now = 0;\n\tlong long int allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\n\t\tint four = now * (now + 1) * (now + 2) / 6;\n\t\t//cout << four << endl;\n\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t}\n\n\t//cout << allcounter << \", \" << oddcounter << endl;\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < allcounter; i++){\n\t\tconst int num_all = fourall[i];\n\n\t\tfor (int j = 1; j < (MAXNUM - num_all); j++){\n\t\t\tall[j + num_all] = min(all[j + num_all], 1 + all[j]);\n\t\t}\n\t}\n\n\tfor (int i = 1; i < oddcounter; i++){\n\t\tconst int num_odd = fourodd[i];\n\n\t\tfor (int j = 1; j < (MAXNUM - num_odd); j++){\n\t\t\todd[j + num_odd] = min(odd[j + num_odd], 1 + odd[j]);\n\t\t}\n\t}\n\n\n\t/*\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; fourall[j] < i; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t\tcout << all[i];\n\t\t}\n\t\tfor (int j = 1; fourodd[j] < i; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t*/\n\n\t//cout << \"a\";\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nconst int N=1000000;\nint dp[N], oddDp[N];\nconst int M=200;\nint p[M];\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n\n  p[0]=INF;\n  for(int i=1; i<M; i++){\n    int num = i*(i+1)*(i+2)/6;\n    p[i]=num;\n  }\n\n  fill( dp, dp+N, INF );\n  fill( oddDp, oddDp+N, INF );\n  dp[0] = 0;\n  oddDp[0] = 0;\n\n  REP(i,N){\n\n    REP(j,M){\n      if( i-p[j] >= 0 ){\n\tif( p[j] %2 == 1 )\n\t  oddDp[i] = min( oddDp[i], oddDp[i-p[j]]+1 );\n\tdp[i] = min( dp[i], dp[i-p[j]]+1 );\n      }\n    }\n\n  }\n\n  int n;\n  while(cin>>n,n){\n    cout << dp[n] << \" \" << oddDp[n] << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[1000001];\n\nint nums[200] = {0};\n\nint main(){\n\n    for(int i = 0;i < 200;i++) nums[i] = i * (i + 1) * (i + 2) / 6;\n\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        for(int j = 1;nums[j] <= n;j++) {\n            for(int i = 0;i <= n;i++) {\n                if(i - nums[j] >= 0) {\n                    dp[i] = min(dp[i], dp[i - nums[j]] + 1);\n                }\n            }\n        }\n\n        cout << dp[n] << ' ';\n\n        for(int i = 0;i <= n;i++) dp[i] = 100002;\n        dp[0] = 0;\n\n        int num = 0;\n        int j = 0;\n        for(int j = 1;nums[j] <= n;j++) {\n            if(nums[j] % 2 != 1) continue;\n            //cout << num << endl;\n            for(int i = 0;i <= n;i++) {\n                if(i - nums[j] >= 0) {\n                    dp[i] = min(dp[i], dp[i - nums[j]] + 1);\n                }\n                //cout << dp[i] << ' ';\n            }\n            //cout << endl;\n        }\n\n        cout << dp[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, e) for (int i = (int)(s); i <= (int)(e); i++)\n#define printYesNo(is_ok) puts(is_ok ? \"Yes\" : \"No\");\n#define SORT(v) sort(v.begin(), v.end());\n#define RSORT(v) sort(v.rbegin(), v.rend());\n#define REVERSE(v) reverse(v.begin(), v.end());\n\nint main()\n{\n  vector<int> dp(1e6 + 1, INT32_MAX), odd_dp(1e6 + 1, INT32_MAX);\n\n  dp[0] = 0;\n  odd_dp[0] = 0;\n  rep(i, 1e6 + 1) for(int j = 200; j > 0; j--)\n  {\n    int regular_tetrahedron_number = j * (j + 1) * (j + 2) / 6;\n    int ni = i + regular_tetrahedron_number;\n    if(ni > 1e6)\n      continue;\n\n    if(dp[i] != INT32_MAX)\n      dp[ni] = min(dp[ni], dp[i] + 1);\n\n    if(regular_tetrahedron_number % 2 == 1 && odd_dp[i] != INT32_MAX)\n      odd_dp[ni] = min(odd_dp[ni], odd_dp[i] + 1);\n  }\n\n  while(true)\n  {\n    int N;\n    cin >> N;\n    if(N != 0)\n      cout << dp[N] << \" \" << odd_dp[N] << endl;\n    else\n      break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int MAX=1e6+10;\nusing namespace std;\nint main(){\n    vector<int>precal;\n    vector<int>dp(MAX,MAX);\n    vector<bool>flag(MAX,false);\n    int n;\n    precal.push_back(0);\n    dp[0]=0;\n    for(int i=1;;i++){\n        int cnt=((i)*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        precal.push_back(cnt);\n        flag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(flag[i]){dp[i]=1; continue;}\n        int index=upper_bound(precal.begin(),precal.end(),i)-precal.begin();\n        for(int j=0; j<=index;j++)\n            dp[i]=min(dp[i],dp[precal[j]]+dp[i-precal[j]]);\n    }\n    vector<int>oddcal;\n    vector<int>odp(MAX,MAX);\n    vector<bool>oddflag(MAX,false);\n    oddcal.push_back(0);\n    odp[0]=0;\n    for(int i=1;;i++){\n        int cnt=(i*(i+1)*(i+2))/6;\n        if(cnt>MAX)break;\n        if(!(cnt%2))continue;\n        oddcal.push_back(cnt);\n        oddflag[cnt]=true;\n    }\n    for(int i=1; i<=MAX-9;i++){\n        if(oddflag[i]){odp[i]=1;continue;}\n        int index=upper_bound(oddcal.begin(), oddcal.end(), i)-oddcal.begin();\n        for(int j=0;j<=index;j++)\n            odp[i]=min(odp[i],odp[oddcal[j]]+odp[i-oddcal[j]]);\n        \n    }\n    while(cin>>n,n){\n        cout<<dp[n]<<\" \"<<odp[n]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n#define REP(i,n) for(int i=0; i < (n); ++i)\n#define REPR(i,n) for(int i=(n); i >= 0; --i)\n#define FOR(i, m, n) for(int i = (m); i < (n); ++i)\n#define INF 1e9\n// const ll INF = 1LL << 60;\n\nint cal(int n){\n  return n*(n+1)*(n+2)/6;\n}\nconstexpr int maxd = 1e6+10;\nint dp[maxd], dp2[maxd];\nint main(){\n  vector<int> P;\n  int p;\n  for(int i = 1; (p=cal(i)) <= 1e6; i++){\n    P.push_back(p);\n  }\n  REP(i, maxd){\n    dp[i] = dp2[i] = INF;\n  }\n  dp[0] = 0;\n  dp2[0] = 0;\n  REP(i, P.size()){\n    int a = P[i];\n    REP(j, 1e6){\n      if(j+a > 1e6) continue;\n      dp[j+a] = min(dp[j+a], dp[j]+1);\n      if(a % 2){\n        dp2[j+a] = min(dp2[j+a], dp2[j]+1); \n      }\n    }\n  }\n  while(true){\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\nint main(void){\n    \n    vector<int> p4;\n    int c = 1, t = 0;\n    while (1) {\n        t = c*(c+1)*(c+2)/6;\n        if (t >= 1e6) break;\n        p4.push_back(t);\n        c++;\n    }\n    \n    int a[1010101] = {};\n    int b[1010101] = {};\n    for (int i = 1; i < 1010101; i++) {\n        a[i] = 1e6;\n        b[i] = 1e6;\n    }\n    \n    for (int i = 0; i < 1010101; i++) {\n        for (int j = 0; j < p4.size(); j++) {\n            int t = i + p4[j];\n            if (t > 1010101) break;\n            a[t] = min(a[t], a[i]+1);\n            if (p4[j]&1) b[t] = min(b[t], b[i]+1);\n        }\n    }\n    int n;\n    while (cin>>n && n) {\n        cout << a[n] << \" \" << b[n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long long toLL(string s) {long long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst double EPS = 1e-12;\nconst long INF = 1000001;\nconst LL MOD=100007;\n\nlong dp1[1000003],dp2[1000003];\nint main(){\n\tLL t=1;\n\tvector<LL>poll,odd;\n\tLL n=1;\n\twhile(t<=1000000){\n\t\tt=n*(n+1)*(n+2)/6LL;\n\t\tpoll.PB(t);\n\t\tif(t%2)odd.PB(t);\n\t\tn++;\n\t}\n\tREP(i,1000002){\n\t\tdp1[i]=dp2[i]=INF;\n\t}\n\tdp1[0]=dp2[0]=0;\n\tdp1[1]=dp2[1]=1;\n\tFOR(i,2,1000001){\n\t\tauto itr1=upper_bound(ALL(poll),i);\n\t\tauto itr2=upper_bound(ALL(odd),i);\n\t\t//itr1--;itr2--;\n\t\tfor(auto itr=poll.begin();itr!=itr1;itr++)dp1[i]=min(dp1[i],dp1[i-*itr]+1);\n\t\tfor(auto itr=odd.begin();itr!=itr2;itr++)dp2[i]=min(dp2[i],dp2[i-*itr]+1);\n\t}\n\tlong tt;\n\twhile(cin>>tt&&tt!=0){\n\t\tcout<<dp1[tt]<<\" \"<<dp2[tt]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int c1[100000],c2[100000],i,m,p=0,dp1[100001],dp2[100001],k;\n  for(i=0;i*(i+1)*(i+2)/6<=100000;i++){\n    c1[i]=i*(i+1)*(i+2)/6;\n    if(c1[i]%2==1){\n      c2[p]=c1[i]; \n      p++; \n    }\n  }\n  while(1){\n  cin >>m;\n  if(m==0)break;\n  for(int j=0;j<=m;j++){\n    dp1[j]=j;\n    dp2[j]=j;\n    for(int k=0;k<i;k++){\n      if(j-c1[k]>=0)dp1[j]=min(dp1[j],dp1[j-c1[k]]+1);\n      if(k<p)\n\tif(j-c2[k]>=0){\n\tdp2[j]=min(dp2[j],dp2[j-c2[k]]+1);\n       }\n    }\n  }\n  cout << dp1[m]<<\" \"<<dp2[m]<<endl;\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct P{\n  int sum,k,n;\n  P(){}\n  P(int S,int K,int N){ sum=S;k=K;n=N; }\n};\n\nint a[200];\n\nint main(){\n  int n, ans1,ans2;\n  queue<P> q;\n  P p;\n\n\n  for( int i=1;i<200 ; i++ )\n    if( (a[i]=i*(i+1)*(i+2)/6)>1000000 )\n      break;\n\n  while( cin>>n && n ){\n\n    \n    while( !q.empty() ) q.pop();\n    for( int i=1;i<200;i++ ){\n      if( a[i]<=n ) q.push( P(a[i],i,1) );\n      else          break;\n    }\n    while( !q.empty() ){\n      p=q.front(); q.pop();\n\n      if( p.sum==n ){\n\tans1=p.n; break;\n      }\n\n      for( int i=p.k,j;i<200;i++ ){\n\tj=p.sum+a[i];\n\tif( j<=n ) q.push( P(j,i,p.n+1) );\n\telse       break;\n      }\n    }\n\n\n    while( !q.empty() ) q.pop();\n    for( int i=1;i<200;i++ ){\n      if( a[i]<=n ){\n\tif( a[i]%2==1 ) q.push( P(a[i],i,1) );\n      }else          break;\n    }\n    while( !q.empty() ){\n      p=q.front(); q.pop();\n\n      if( p.sum==n ){\n\tans2=p.n; break;\n      }\n\n      for( int i=p.k,j;i<200;i++ ){\n\tif( a[i]%2==1 ){\n\t  j=p.sum+a[i];\n\t  if( j<=n ) q.push( P(j,i,p.n+1) );\n\t  else       break;\n\t}\n      }\n    }\n\n    cout << ans1 << \" \" << ans2 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\n\tint n,table[200];\n\tint* dp = new int[1000000];\n\tint* odd_dp = new int[1000000];\n\n\tfor(int i=0; i < 200; i++)table[i] = i*(i+1)*(i+2)/6;\n\n\tfor(int i=0; i < 1000000; i++){\n\t\todd_dp[i] = 20000000;\n\t\tdp[i] = 20000000;\n\t}\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\n\tfor(int i = 2; i < 1000000; i++){\n\t\tfor(int k = 1; table[k] <= i; k++){\n\t\t\tdp[i] = (dp[i] <= dp[i-table[k]]+1)?dp[i]:dp[i-table[k]]+1;\n\t\t}\n\t}\n\n\todd_dp[0] = 0;\n\todd_dp[1] = 1;\n\n\tfor(int i = 2; i < 1000000; i++){\n\t\tfor(int k = 1; table[k] <= i; k += 2){\n\t\t\tif(table[k]%2 == 1){\n\t\t\t\todd_dp[i] = (odd_dp[i] <= odd_dp[i-table[k]]+1)?odd_dp[i]:odd_dp[i-table[k]]+1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tprintf(\"%d %d\\n\",dp[n],odd_dp[n]);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n    vector<int> num;\n    for(long long int i=1;;i++){\n        if(i*(i+1)*(i+2)/6>1e6)\n            break;\n        num.push_back(i*(i+1)*(i+2)/6);\n    }\n    vector<int> dp1(1e6+1,1e7);\n    vector<int> dp2(1e6+1,1e7);\n    dp1[0]=0,dp2[0]=0;\n    for(int i=1;i<dp1.size();i++){\n        for(int r=0;r<num.size() ;r++){\n            if(num[r]>i) break;\n            dp1[i]=min(dp1[i],dp1[i-num[r]]+1);\n            if(num[r]%2==1){\n                dp2[i]=min(dp2[i],dp2[i-num[r]]+1);\n            }\n        }\n    }\n    int n;\n    while(cin>>n,n){\n        cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\n\n#define MAX 1000000\n\nint main()\n{\n  int triangle,tetra[MAX];\n  int i,j,T;\n  int dp[MAX],dpOdd[MAX];\n  int n;\n  T=0;\n  tetra[0]=1;\n  tetra[1]=4;\n  triangle=1;\n  for(i=2;triangle<MAX;i++){\n    triangle+=i;\n    tetra[i-1]=tetra[i-2]+triangle;\n    T++;\n  }\n\n  for(i=0;i<MAX;i++)dp[i]=dpOdd[i]=INT_MAX;\n  dp[0]=dpOdd[0]=0;\n  for(i=0;i<T;i++){\n    for(j=tetra[i]; j<MAX; j++){\n      if(dp[j-tetra[i]]+1 < dp[j])\n\tdp[j]=dp[j-tetra[i]]+1;\n      if(tetra[i]&1 && dpOdd[j-tetra[i]]+1 < dpOdd[j])\n\tdpOdd[j]=dpOdd[j-tetra[i]]+1;\n    }\n  }\n\n  while(cin>>n,n){\n    cout<<dp[n]<<\" \"<<dpOdd[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX = 1e6+5;\nint dp1[MAX];\nint dp2[MAX];\n\nvoid init(int n){\n    int INF = 1e9;\n    for(int j=0;j<=n;j++){\n        dp1[j] = INF;\n        dp2[j] = INF;\n    }\n    dp1[0] = 0;\n    dp2[0] = 0;\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    vector<int> a;\n    vector<int> b;\n    for(int i=1;i<100000;i++){\n        int ret = i*(i+1)*(i+2)/6;\n        if(ret > 1e6) break;\n        a.push_back(ret);\n        if(ret %2 == 1) b.push_back(ret);\n\n    }\n    init(1e6);\n    for(int i=0;i<180;i++){\n        if(a[i] > 1e6) break;\n        for(int j=0;j<=1e6;j++){\n            int p = j+a[i];\n            if(p > 1e6) break;\n            dp1[p] = min(dp1[p], dp1[j]+1);\n        }\n    }\n    for(int i=0;i<b.size();i++){\n        if(b[i] > 1e6) break;\n        for(int j=0;j<=1e6;j++){\n            int p = j+b[i];\n            if(p > 1e6) break;\n            dp2[p] = min(dp2[p], dp2[j]+1);\n        }\n    }\n\n\n\n\n\n    int n;\n    while(cin>>n){\n        if(n==0) break;\n        cout << dp1[n] << \" \";\n        cout << dp2[n] << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define SZ(a) (int)((a).size())\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\ntypedef pair<int,int> PI;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\n\nint dp[120000];\nint odp[120000];\nint n;\nvoid solve(){\n  \n}\n\nint main(){\n  rep(i,120000) dp[i]=1<<28;\n  rep(i,120000) odp[i]=1<<28;\n\n  dp[0]=0;\n  odp[0]=0;\n  \n  for(int i=1;;++i){\n    int p = i*(i+1)*(i+2)/6;\n    if(p>110000) break;\n    //cout <<  i << endl;\n    for(int j=0;j+p<120000;++j)\n      dp[j+p]=min(dp[j+p],dp[j]+1);\n    if(p&1)\n      for(int j=0;j+p<120000;++j)\n        odp[j+p]=min(odp[j+p],odp[j]+1);\n      // for(int j=110000-p;j>=0;--j)\n      //   odp[j+p]=min(odp[j+p],odp[j]+1);\n  }\n  \n  //return 0;\n  \n  while(cin >> n,n) cout << dp[n] << \" \" << odp[n] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define M 1000000\n#define INF 10000000\n\n#define min(a,b) (a<b?a:b)\n\nint main() {\n\tint n, p;\n\tvector<int> fn, fno;\n\tstatic int dp[M+1], odp[M+1];\n\tfor(int i=1;; ++i) {\n\t\tp = i*(i+1)*(i+2)/6;\n\t\tif(p>M) break;\n\t\tfn.push_back(p);\n\t\tif(p%2) fno.push_back(p);\n\t}\n\tfor(int i=0; i<=M; ++i) dp[i] = odp[i] = INF;\n\tdp[0] = 0; dp[1] = 1; odp[0] = 0; odp[1] = 1;\n\tfor(int i=2; i<=M; ++i) {\n\t\tfor(int j=0; j<(signed)fn.size(); ++j) {\n\t\t\tif(i-fn[j]>=0) dp[i] = min(dp[i], dp[i-fn[j]]+1);\n\t\t\telse break;\n\t\t}\n\t\tfor(int j=0; j<(signed)fno.size(); ++j) {\n\t\t\tif(i-fno[j]>=0) odp[i] = min(odp[i], odp[i-fno[j]]+1);\n\t\t\telse break;\n\t\t}\n\t}\n\t\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tcout << dp[n] << \" \" << odp[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n,res =inf;\nconst int MAX = 1000000;\nint solve(int a,int b,int c,vector<int> v, int** dp){\n  if(dp[b][a] == 1) return b;\n  else if(dp[b][a] == -1) return inf;\n  dp[b][a] = -1;\n  if(b == 0) res = inf;\n  if(a == n){\n    res = min(res,b);\n    dp[b][a] = 1;\n    return b;\n  }\n  if(a > n || res < b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v,dp),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < MAX){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    {\n      const size_t s = suqnum.size();\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb1,suqnum,arg) << \" \";\n      rep(i,s) delete[] dp[i];\n    }\n    {\n      const size_t s = odd.size();\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb2,odd,arg)<<endl;\n      rep(i,s) delete[] dp[i];\n    }\n//     queue<pii> q;\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb1,suqnum.size()){\n//         if(p.se+suqnum[i] == n){\n//           cout << p.fi+1<< \" \";\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+suqnum[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n//         }\n//       }\n//     }\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb2,odd.size()){\n//         if(p.se+odd[i] == n){\n//           cout << p.fi+1<< endl;\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+odd[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+odd[i]));\n//         }\n//       }\n//     }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N, K;\nint inf = 1000000000;\n\nint d[MAX_N+1]; // ?????????j??¨?????????????????????????°??????°\n\nint calc_sn(int n){\n\treturn n*(n+1)*(n+2)/6;\n}\n\nvoid solve(){\n\tfor (int i = 1; i < inf; ++i)\n\t{\n\t\tif(calc_sn(i) > N){\n\t\t\tK = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\td[0] = 0;\n    for(int i = 1; i <= N; i++){\n    \td[i] = inf;\n       \tfor (int j = 1; j < K; j++)\n        {\n        \tif(i < calc_sn(j)) break;\n            d[i] = min(d[i], d[i-calc_sn(j)]+1);\n        }\n    }\n    cout << d[N] << \" \";\n    d[0] = 0;\n    for(int i = 1; i <= N; i++){\n    \td[i] = inf;\n       \tfor (int j = 1; j < K; j++)\n        {\n        \tif(i < calc_sn(j)) break;\n        \tif(calc_sn(j) % 2 == 0) continue;\n            d[i] = min(d[i], d[i-calc_sn(j)]+1);\n        }\n    }\n    cout << d[N] << endl;\n}\n\nint main() {\n    while(1){\n    \tcin >> N;\n    \tif(N == 0) break;\n    \tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//??§????????£?????¢?????°??????????¬??????¨??£????????? -> ?????£????????????\n//[????????°]?????????????????????????????\\??????????????????????????? -> [????????°]?????????????????????????????§??????????????°????°?????????????????????????\n//????????£?????¢?????°???????????§?????????????????§???[???????????£?????¢?????°]?????¶??????????????????????????????\n#include <iostream>\nusing namespace std;\n\nint dp[1000001];\nint dpOdd[1000001];\n\nint main() {\n\tint i, j;\n\t\n\tfor (i = 0; i < 1000001; i++) dp[i] = 1145141919;\n\tfor (i = 0; i < 1000001; i++) dpOdd[i] = 1145141919;\n\tdp[0] = 0;\n\tdpOdd[0] = 0;\n\t\n\tfor (i = 0; i < 1000001; i++) {\n\t\tfor (j = 1; i + j * (j + 1) * (j + 2) / 6 < 1000001; j++) {\n\t\t\tint num = j * (j + 1) * (j + 2) / 6;\n\t\t\tdp[i + num] = min(dp[i + num], dp[i] + 1);\n\t\t\tif (num % 2 == 1) {\n\t\t\t\tdpOdd[i + num] = min(dpOdd[i + num], dpOdd[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tcout << dp[n] << \" \" << dpOdd[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main(){\n  int lim = 1e6;\n  vector<int> cube;\n  for(int i=1;;i++){\n    int c = i*(i+1)*(i+2)/6;\n    if(c>lim)break;\n    cube.push_back(c);\n  }\n\n  vector<int> dp1(lim+1,INF), dp2(lim+1,INF);\n  dp1[0] = dp2[0] = 0;\n\n  for(int i=0;i<=lim;i++){\n    for(int c : cube){\n      if(i+c<=lim){\n\tdp1[i+c] = min(dp1[i+c], dp1[i]+1);\n\tif(c%2==1){\n\t  dp2[i+c] = min(dp2[i+c], dp2[i]+1);\n\t}\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n){\n    if(n==0)break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[150]={0},c[1500001]={0,1,2,3},d[1500001],k=0,i,j,n;\n  for(i=1;i<190;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<188;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int N = 1000001;\n  vector<int> full(N);\n  vector<int> odd(N);\n  for(int i = 0; i < N; i++) full[i] = i;\n  for(int i = 0; i < N; i++) odd[i] = i;\n  for(int n = 2; ; n++) {\n    const int t = (n * (n+1) * (n+2))/6;\n    if(t >= N) break;\n    for(int i = 0; i + t < N; i++) {\n      const int k = i + t;\n      if(full[i] + 1 < full[k]) full[k] = full[i] + 1;\n      if(t & 1) {\n        if(odd[i] + 1 < odd[k]) odd[k] = odd[i] + 1;\n      }\n    }\n  }\n  \n  for(int t = 1;; t++) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    cout << full[n] << \" \" << odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nint main(void) {\n    const int M = 1000000;\n    VI xs, xs2;\n    REP(i, 1, 200) {\n        int x = (i * (i + 1) * (i + 2)) / 6;\n        if (x < M) xs.PB(x);\n        if (x < M && x % 2) xs2.PB(x);\n    }\n\n    VI dp(M + 1, INF);\n    VI dp2(M + 1, INF);\n    for (auto x : xs) dp[x] = 1;\n    for (auto x : xs2) dp2[x] = 1;\n\n    rep(i, M) {\n        if (dp[i] == INF) continue;\n\n        for (auto x : xs) {\n            int y = x + i;\n            if (y > M) break;\n            MINUD(dp[y], dp[i] + 1);\n        }\n    }\n\n    rep(i, M) {\n        if (dp2[i] == INF) continue;\n\n        for (auto x : xs2) {\n            int y = x + i;\n            if (y > M) break;\n            MINUD(dp2[y], dp2[i] + 1);\n        }\n    }\n\n    int n;\n    while (cin >> n, n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n  \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n  \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n \nint dp[1000005][2];\n \nint main(){\n    for(int i = 1;i <= 1000000;i++){\n        dp[i][0] = 10000000;\n        dp[i][1] = 10000000;\n    }\n \n    for(int i = 1; i*(i+1)*(i+2)/6 < 1000000;i++){\n        int simen = i*(i+1)*(i+2)/6;\n        for(int j = 0; j + simen < 1000000;j++){\n            for(int k = 0;k < 2;k++){\n                if(k == 1 && simen % 2 == 0) continue;\n                dp[j+simen][k] = min(dp[j+simen][k],dp[j][k]+1);\n            }\n        }\n    }\n    int n;\n    while(true){\n        cin >> n;\n        if(n == 0) break;\n        cout << dp[n][0] << \" \" << dp[n][1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\nconst int NMAX = 1e6 + 8;\nconst int INF = 1e6 + 8;\n\nint dp1[NMAX], dp2[NMAX];\n\nvoid solve(int n) {\n  REP(i, n) {\n    dp1[i] = dp2[i] = i;\n  }\n\n  for (int base = 100; base > 2; base--) {\n    int q = base * (base - 1) * (base - 2) / 6;\n    for (int i = q; i < n; i++) {\n      dp1[i] = min(dp1[i], dp1[i - q] + 1);\n    }\n  }\n\n  for (int base = 100; base > 2; base--) {\n    int q = base * (base - 1) * (base - 2) / 6;\n    if (q % 2 == 0) continue;\n    for (int i = q; i < n; i++) {\n      dp2[i] = min(dp2[i], dp2[i - q] + 1);\n    }\n  }\n}\n\nint main() {\n  solve(1e6 + 1);\n\n  int n;\n  while (cin >> n and n) {\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\nint c[300];\nvector<int> d;\nint a[10000000],b[10000000];\n\nvoid f(int n){\n\n  int j=1;\n  FOR(i,1,n+1){\n    if(c[j+1]==i){\n      a[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,1,300){\n        if(i/c[k]==0) break;\n        res = min(res,(i/c[k])+a[i%c[k]]);\n      }\n      a[i] = res;\n    }\n  }\n\n\n  j = 1;\n  FOR(i,1,n+1){\n    if(d[j+1]==i){\n      b[i]=1;\n      j++;\n    }\n    else{\n      int res = i;\n      FOR(k,1,d.size()){\n        if(i/d[k]==0) break;\n        res = min(res,(i/d[k])+b[i%d[k]]);\n      }\n      b[i] =res;\n    }\n  \n  }\n\n\n\n\n}\n\nvoid g(int n){\n  cout<<a[n]<<' '<<b[n]<<endl;\n}\n\n\nint main(){\n  d.push_back(0);\n  for(int i=1;i<200;i++){\n    c[i] = (i*(i+1)*(i+2))/6;\n   if(c[i]%2){\n     d.push_back(c[i]);\n   }\n  }\n\n  f(1000000);\n\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    g(n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n \nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<(n); i++)\n#define repc(i,s,e) for(int i=(s); i<(e); i++)\n#define pb(n) push_back((n))\n#define mp(n,m) make_pair((n),(m))\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef pair<int, pii> pip;\n \n \n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\n \nint dp[1000010];\nint dp2[1000010];\n\nint main(){\n\tint a = 1, b;\n\tvi v;\n\tvi u;\n\twhile((b = a*(a+1)*(a+2)/6)<1e6){\n\t\tv.pb(b);\n\t\tif(b%2 == 1){\n\t\t\tu.pb(b);\n\t\t}\n\t\ta++;\n\t}\n\t//cout<<v.size()<<endl;\n\tfor(int i = 0; i < 1000010; i++){\n\t\tdp[i] = INF;\n\t\tdp2[i] = INF;\n\t}\n\tdp[0] = 0;\n\tdp2[0] = 0;\n\tfor(int i = 0; i < v.size(); i++){\n\t\tfor(int j = v[i]; j < 1000010; j++){\n\t\t\tdp[j] = min(dp[j], dp[j-v[i]]+1);\n\t\t\tif(i < u.size()){\n\t\t\t\tdp2[j] = min(dp2[j], dp2[j-u[i]]+1);\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<\"OK\"<<endl;\n\tint n;\n\twhile(cin>>n && n > 0){\n\t\tcout<<dp[n]<<\" \"<<dp2[n]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;++i)\n#define Rep(i,n) for(int i=1;i<=n;++i)\n#define rrep(i,n) for(int i=n-1;0<=i;--i)\n#define rRep(i,n) for(int i=n;0<i;--i)\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef double Real;\ntypedef int Int;\ntypedef vector<Int> vi;\ntypedef vector<vector<Int> > vvi;\ntypedef pair<Int,Int> pii;\n\ninline Real sr(Real a) {return sqrt(max(a, (Real)0));}\nconst vi dy = {-1, 0, 1, 0}, dx = {0, -1, 0, 1};\n\ntemplate <typename K, typename V> ostream& operator<< (ostream& out, const pair<K, V>& p) {\n  out << '(' << p.first << \", \" << p.second << ')';\n  return out;\n}\n\ntemplate <typename T> ostream& operator<< (ostream& out, const vector<T>& v) {\n  out << '[';\n  rep(i, v.size()) out << v[i] << \",\";\n  out << \"\\b], \" << v.size();\n  return out;\n}\n\nvi tetrahedralNums, tetrahedralNumsDoubled;\n\ninline int calcTetrahedralNum(int N){\n  return N * (N + 1) * (N + 2) / 6;\n}\n\nint M = 183;\n\nvoid solve(){\n  int N, ansA, ansB;\n  tetrahedralNums.resize(M);\n  tetrahedralNumsDoubled.reserve(M * M);\n\n  rep(i, M) tetrahedralNums[i] = calcTetrahedralNum(i+1);\n  rep(i, M) rep(j, M) tetrahedralNumsDoubled.push_back(tetrahedralNums[i] + tetrahedralNums[j]);\n\n  sort(all(tetrahedralNums));\n  sort(all(tetrahedralNumsDoubled));\n  tetrahedralNums.erase(unique(all(tetrahedralNums)), tetrahedralNums.end());\n  tetrahedralNumsDoubled.erase(unique(all(tetrahedralNumsDoubled)), tetrahedralNumsDoubled.end());\n\n  vi dp(1e6+1, INF);\n  dp[0] = 0;\n  rep(i, M){\n    if(tetrahedralNums[i] % 2 == 0) continue;\n    int m = tetrahedralNums[i];\n    for(int j = m; j <= 1e6; j++)\n      if(dp[j] > dp[j - m] + 1)\n          dp[j] = dp[j - m] + 1;\n  }\n\n  while(cin >> N && N){\n    \n    ansA = 0, ansB = 0;\n\n    if(find(all(tetrahedralNums), N) != tetrahedralNums.end()){\n      ansA = 1;\n    }else if(find(all(tetrahedralNumsDoubled), N) != tetrahedralNumsDoubled.end()){\n      ansA = 2;\n    }else{\n      bool done = false;\n      for(int tet : tetrahedralNums){\n        if(find(all(tetrahedralNumsDoubled), N - tet) != tetrahedralNumsDoubled.end()){\n          ansA = 3;\n          done = true;\n          break;\n        }\n      }\n      if(!done){\n        for(int tet: tetrahedralNumsDoubled){\n          auto lb = lower_bound(all(tetrahedralNumsDoubled), N - tet);\n          if(lb != tetrahedralNumsDoubled.end() && *lb == N - tet){\n            ansA = 4;\n            break;\n          }\n\n          if(find(all(tetrahedralNums), N - tet - *(lb-1)) != tetrahedralNums.end()){\n            ansA = 5;\n            break;\n          }\n        }\n        // noreach\n      }\n    }\n\n    cout << ansA << ' ' << dp[N] << endl;\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(9);\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = int(1e6);\n\nint dp[MAX];\nint odp[MAX];\n\nint main(void)\n{\n    int n;\n\n    fill(dp, dp + MAX, MAX);\n    fill(odp, odp + MAX, MAX);\n    dp[0] = odp[0] = 0;\n    for (int i = 0; i < 200; i++){\n        int tetra = i * (i + 1) * (i + 2) / 6;\n        for (int j = 0; j < MAX - tetra; j++){\n            dp[j + tetra] = min(dp[j + tetra], dp[j] + 1);\n        }\n        if (tetra % 2 == 1){\n            for (int j = 0; j < MAX - tetra; j++){\n                odp[j + tetra] = min(odp[j + tetra], odp[j] + 1);\n            }\n        }\n    }\n    while (cin >> n, n){\n        printf(\"%d %d\\n\", dp[n], odp[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200]={0},b[200]={0},c[1000001],d[1000001],k=0,i,j,n;\n\n  for(i=0;i<200;i++)a[i]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=0;i<1000001;i++)c[i]=d[i]=i;\n\n  for(i=1;i<195;i++)for(j=a[i];j<1000001;j++){\n    c[j]=min(c[j],c[j-a[i]]+1);\n  }\n  for(i=1;i<k-2;i++)for(j=b[i];j<10000001;j++){\n    d[j]=min(d[j],d[j-b[i]]+1);\n  }\n while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint INF = (1LL << 30) - 1;\nint MOD = 1e9+7;\nint MAX_NUM = 1000000;\nmain(){\n    vector<int> V,W;\n    for(int i = 1;i * (i + 1) * (i + 2) / 6 <= MAX_NUM;i++){\n        int num = i * (i + 1) * (i + 2) / 6; \n        V.push_back(num);\n        if(i % 4 == 1)W.push_back(num);\n    }\n    vector<int> t1(MAX_NUM,INF),t2(MAX_NUM,INF);\n    t1[0] = t2[0] = 0;\n    rep(i,0,V.size()){\n        rep(j,0,MAX_NUM){\n            if(j + V[i] > MAX_NUM)break;\n            t1[j + V[i]] = min(t1[j + V[i]], t1[j] + 1);\n        }\n    }\n    rep(i,0,W.size()){\n        rep(j,0,MAX_NUM){\n            if(j + W[i] > MAX_NUM)break;\n            t2[j + W[i]] = min(t2[j + V[i]], t2[j] + 1);\n        }\n    }\n    int N;\n    cin >> N;\n    while(N){\n        cout << t1[N] << \" \" << t2[N] << endl;\n        cin >> N;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define MAX 100000\n#define INF (1<<24)\nint n[100000],M;\n\nint dp[1000005];\nint od[1000005];\n\nint main()\n{\n\tfor(M=1; ; M++)\n\t{\n\t\tint v=M*(M+1)*(M+2)/6;\n\t\tif(v>MAX) break;\n\t\tn[M]=v;\n\t}\n\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tfor(int i=0; i<=N; i++)\n\t\t{\n\t\t\tdp[i]=INF;\n\t\t\tod[i]=INF;\n\t\t}\n\n\t\tdp[0]=od[0]=0;\n\n\t\tfor(int i=1; i<M; i++)\n\t\tfor(int j=0; j<=N; j++) \n\t\t{\n\t\t\tif(j+n[i] > N) break;\n\t\t\tif(dp[j]!=INF)\n\t\t\t{\n\t\t\t\tdp[j+n[i]]=min(dp[j+n[i]], dp[j]+1);\n\t\t\t}\n\t\t\tif(od[j]!=INF&&n[i]%2==1)\n\t\t\t{\n\t\t\t\tod[j+n[i]]=min(od[j+n[i]], od[j]+1);\n\t\t\t}\n\t\t}\n\n\t\tcout << dp[N] << \" \" << od[N] << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nint dp[190][1000010] = { 0 };\nint dpodd[190][1000010] = { 0 };\n//vector<vector<int>> dp;\n\nint N = 0;\nint C[191];\nint Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tint C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tint ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j = 1; j <= 189; j++) {\n\t\tfor (int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dp[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define MAX 100\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM], fourall[MAXNUM], fourodd[MAXNUM];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tall[i] = MAX;\n\t\todd[i] = MAX;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM * 2)\n\t\t\tbreak;\n\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nusing P = pair<int, int>;\nusing Iterator = vector<int>::iterator;\nvector<int> s;\nvector<int> odd_s;\n\nvoid make_shimentai(){\n    for(int i = 1; ; ++i){\n        int sum = i * (i + 1) * (i + 2) / 6;\n\n        if(sum >= 1000000) break;\n\n        s.emplace_back(sum);\n\n        if(sum % 2 == 1) odd_s.emplace_back(sum);\n    }\n}\n\nint bfs(const int v, Iterator it, vector<int> &s){\n    // first:????¨????, second:?¶????????????°\n    queue<P> q;\n    q.push(make_pair(*it, 1));\n\n    while(!q.empty()){\n        P p = q.front(); q.pop();\n        if(p.first == v) return p.second;\n\n        for(Iterator it_ = s.begin(); it_ <= it; ++it_){\n            int sum = p.first + *it_;\n            if(sum <= v)\n                q.push(make_pair(sum, p.second + 1));\n        }\n    }\n    return -1;\n}\n\nint solve(const int v, vector<int> &s){\n    Iterator it = lower_bound(s.begin(), s.end(), v);\n    if(*it != v) it--;\n\n    int ans = INT_MAX;\n\n    for(;it != s.begin() - 1; --it){\n        ans = min(ans, bfs(v, it, s));\n        if(ans == 1) break;\n    }\n\n    return ans;\n}\n\n/*int solve(const int v, vector<int> s){\n  decltype(s)::iterator it = lower_bound(s.begin(), s.end(), v);\n  if(*it != v) it--;\n\n  int ans = INT_MAX;\n  for(;it != s.begin()-1; it--){\n  vector<int>::iterator it_ = it;\n  int v_ = v;\n  int count = 0;\n  while(true){\n  if(v_ == 0) break;\n  if(v_ - *it_ < 0){\n  it_--;\n  continue;\n  }\n\n  v_ -= *it_;\n  count++;\n  if(ans < count) break;\n  }\n  ans = min(ans, count);\n  }\n\n  return ans;\n  }*/\n\nint main(){\n    make_shimentai();\n\n    while(true){\n        int v;\n        cin >> v;\n        if(v == 0) break;\n\n        int ans = solve(v, s);\n        cout << ans << \" \";\n        ans = solve(v, odd_s);\n        cout << ans << \"\\n\";\n    }\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,b,n) for(int i=b;i<n;i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tint n;\n\tint A[1000000];\n\tint B[1000000];\n\tA[0]=B[0]=0;\n\tfor(int i = 1; i<1000000;i++){\n\t\tA[i] = i;\n\t\tB[i] =i;\n\t\tfor(int j=1;;j++){\n\t\t\tint t =j*(j+1)*(j+2)/6;\n\t\t\tif(t > i)\n\t\t\t\tbreak;\n\t\t\tA[i]=min(A[i],A[i-t]+1);\n\t\t\tif(t%2==1)\n\t\t\t\tB[i]=min(B[i],B[i-t]+1);\n\t\t}\n\t}\n\twhile(cin>>n,n){\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tcout <<A[n]<<\" \"<<B[n]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nvector<int>nums;\nvector<int>oddnums;\n\nvector<short>memo(1000001,-1);\nvector<short>oddmemo(1000001,-1);\n\nint getans(const int num,const int atime) {\n\tif (memo[num] != -1) {\n\t\treturn memo[num];\n\t}\n\telse {\n\t\tif (num == 0)return memo[num] = 0;\n\t\tif (atime > 10)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <nums.size(); ++i) {\n\t\t\tint minusnum = nums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 10) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getans(num - minusnum, atime + 1)+1);\n\t\t}\n\n\t\treturn memo[num] = ans;\n\t}\n}\nint getoddans(const int num, const int atime) {\n\tif (oddmemo[num] != -1) {\n\t\treturn oddmemo[num];\n\t}\n\telse {\n\t\tif (num == 0)return oddmemo[num] = 0;\n\t\tif (atime > 50)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i < oddnums.size(); ++i) {\n\t\t\tint minusnum = oddnums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 50) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getoddans(num - minusnum, atime + 1) + 1);\n\t\t}\n\t\treturn oddmemo[num] = ans;\n\t}\n\n}\nint main() {\n\tfor (int i = 1; i < 190; ++i) {\n\t\tnums.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (((i*(i + 1)*(i + 2)) / 6) % 2) {\n\n\t\t\n\t\t\toddnums.push_back((i*(i + 1)*(i + 2)) / 6);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tint normalans = getans(n, 0);;\n\t\tint oddans = getoddans(n, 0);\n\n\t\tcout << normalans << \" \" << oddans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define print(a) cout<<a<<endl;\nint aaa[200] = {}, bbb[200] = {}, counta=1,countb=1,xxx[1100000] = {}, yyy[1100000] = {};\n\nint foo(int n, int x){\n\tint mi = 1000000;\n\tif(xxx[n]) return xxx[n]+x;\n\tif(x > 5) return mi;\n\tfor(int i = counta-1; i >= 1; i--){\n\t\tif(aaa[i] < n){\n\t\t\tmi = min(foo(n-aaa[i],x+1), mi);\n\t\t\tif(mi - n == 1)break;\n\t\t}\n\t}\n\t\n\txxx[n] = mi;\n\treturn mi;\n}\nint boo(int n, int x){\n\tint mi = 1000000;\n\tif(yyy[n]) return yyy[n]+x;\n\tfor(int i = countb-1; i >= 1; i--){\n\t\tif(bbb[i] < n){\n\t\t\tmi = min(boo(n-bbb[i],x+1), mi);\n\t\t\tif(mi - n == 1)break;\n\t\t}\n\t}\n\tyyy[n] = mi;\n\treturn mi;\n}\n\nint main(){\n\tint i, n, abc;\n\tfor(i = 1; abc <= 1000000; i++){\n\t\tabc = (i*(i+1)*(i+2))/6;\n\t\txxx[abc] = 1;\n\t\tif(abc%2){\n\t\t\tyyy[abc] = 1;\n\t\t\tbbb[countb++] = abc;\n\t\t}\n\t\taaa[counta++] = abc;\n\t}\n\tfor(i = 1; i <= 1000000; i++){\n\t\txxx[i] = foo(i, 0);\n\t\tyyy[i] = boo(i, 0);\n\t}\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n == 0) break;\n\t\tcout<<xxx[n]<<\" \"<<yyy[n]<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(n>=p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(p[i]&1 && n>=p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <list>\n#include <set>\n#define foreach(t,p) for(t::iterator it=p.begin();it!=p.end();++it)\n#define rforeach(t,p) for(t::reverse_iterator it=p.rbegin();it!=p.rend();++it)\nusing namespace std;\n#define REP(n) for(int i=0;i<n;i++)\n#define N 1000001\n#define POL 180\nint pol[POL];\nint pol2[POL];\nint dp1[N];\nint dp2[N];\nint num;\n\nvoid solve1() {\n    REP(N) dp1[i] = N;\n    dp1[0] = 0;\n        for(int k=0;k<N;k++) {\n                for(int j=0;j<POL;j++) \n                    if(k+pol[j] <=N)\n                        dp1[k+pol[j] ] = min(dp1[k+pol[j]],dp1[k]+1);\n        }\n}\n\nvoid solve2() {\n    REP(N) dp2[i] = N;\n    dp2[0] = 0;\n    for(int i=0;i<N;i++) {\n          //                cout << i << \" \"  << \" \" << dp2[i] << endl;\n            for(int j=0;j<num;j++) {\n                if(i+pol2[j] <= N) {\n                    dp2[i+pol2[j] ] = min(dp2[i+pol2[j]],dp2[i]+1);\n                }\n            }\n    }\n}\n\nint main() {\n    num = 0;\n    REP(POL){\n        pol[i] = (i+1)*(i+2)*(i+3)/6;\n        if(pol[i]%2 == 1) pol2[num++] = pol[i];\n    }\n    solve1();\n    solve2();\n//    REP(30) cout << dp1[i];\n    int q;\n    while(cin >> q && q) {\n        cout << dp1[q] << \" \" << dp2[q] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<utility>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\ntypedef pair<int,int> pi;\n\nconst int inf=1<<28;\nconst int MX=1000000;\n\nint tri[1000],ntri;\nint dp[MX],dpOdd[MX];\n\nint main(){\n\t\n\tntri=0;\n\tfor(;;ntri++)\n\t{\n\t\ttri[ntri]=ntri*(ntri+1)*(ntri+2)/6;\n\t\tif(tri[ntri]>=MX)break;\n\t}\n\t\n\tdbg(ntri);\n\t\n\trep(i,MX)dp[i]=dpOdd[i]=inf;\n\tdp[0]=dpOdd[0]=0;\n\tint mx=0;\n\trep(i,5)rep(j,mx+1)\n\t{\n\t\trep(k,ntri)\n\t\t{\n\t\t\tif(j+tri[k]>=MX)break;\n\t\t\tif(tri[k]%2==1)dpOdd[j+tri[k]]=min(dpOdd[j+tri[k]],dpOdd[j]+1);\n\t\t\tdp[j+tri[k]]=min(dp[j+tri[k]],dp[j]+1);\n\t\t\tmx=max(mx,j+tri[k]);\n\t\t\tmx=min(mx,MX-1);\n\t\t}\n\t}\n\t\n\tint n;\n\twhile(cin>>n,n)cout<<dp[n]<<\" \"<<dpOdd[n]<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  const int N = 1000000;\n  int dp[2][N+1], n;\n  \n  for(int i=0;i<=N;i++)dp[0][i] = dp[1][i] = N;\n  dp[0][0] = dp[1][0] = 0;\n  \n  int val = 1;\n  for(int i=1;val<=N;i++){\n    for(int j=0;j+val<=N;j++){\n      int nxt = j+val;\n      dp[0][nxt] = min(dp[0][nxt],dp[0][j] + 1);\n      if(val&1)dp[1][nxt] = min(dp[1][nxt],dp[1][j] + 1);\n    }\n    val = i*(i+1)*(i+2)/6;\n  }\n\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint table[200];\nint dp1[1000001];\nint dp2[1000001];\n\nint main(){\n\tfor(int i=0;i < 200;i++){\n\t\ttable[i]=i*(i+1)*(i+2)/6;\n\t}\n\tfor(int i=0;i < 1000001;i++) dp1[i]=dp2[i]=99999999;\n\tdp1[0]=dp2[0]=0;\n\tfor(int i=0;i < 1000001;i++){\n\t\tfor(int j=1;j < 200;j++){\n\t\t\tif(i+table[j] <= 1000000) dp1[i+table[j]] = min(dp1[i+table[j]],dp1[i]+1);\n\t\t\tif(table[j]%2 && i+table[j] <= 1000000) dp2[i+table[j]] = min(dp2[i+table[j]],dp2[i]+1);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n,n){\n\t\tcout << dp1[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n2017_04_13_AC\n?????????DP??????????????£????????????????????¨??£??????????¨???????:2*10^8????????§???????????????\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\n/*dp[i]: ??´??°i????§??????§??????????°??????£?????¢?????°????????°*/\nint dp1[1000005], dp2[1000005];\nvoid makeDP(){\n  vector<int> v1;\n  vector<int> v2;\n  int tn = 1;\n  while(1){\n      int tmp = tn*(tn+1)*(tn+2)/6;\n      if(tmp < 1000000){\n        v1.push_back(tmp);\n        if(tmp % 2 != 0) v2.push_back(tmp);\n      }else{\n        break;\n      }\n      tn++;\n  }\n  /*1?????£?????¢?????°????????§??????????????????????????°??????????????°??§?§??????????*/\n  REP(i,0,1000005) dp1[i] = i, dp2[i] = i;\n  REP(i,1,v1.size()){\n    REP(j,0,1000005){\n      if(j-v1[i] >= 0) dp1[j] = min(dp1[j], dp1[j-v1[i]] + 1);\n    }\n  }\n  REP(i,1,v2.size()){\n    REP(j,0,1000005){\n      if(j-v2[i] >= 0) dp2[j] = min(dp2[j], dp2[j-v2[i]] + 1);\n    }\n  }\n}\n\nint main() {\n\n  makeDP();\n\n  int N;\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    cout<<dp1[N]<<\" \"<<dp2[N]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repr(i,a,n) for(int i=a;i>=n;i--)\n#define INF 999999999\n#define pb(a) push_back(a)\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef vector<pii> VP;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\n\nint main() {\n    int n;\n    const int N = 1000000;\n    int dp1[1000000];\n    int dp2[1000000];\n\n    rep(i,0,N) dp1[i] = dp2[i] = i;\n\n    int val = 1;\n    for(int i = 1; val <= N; i++) {\n        for(int j=0; j+val <= N; j++) {\n            dp1[j+val] = min(dp1[j+val], dp1[j] + 1);\n            if(val%2 == 1) dp2[j+val] = min(dp2[j+val], dp2[j] + 1);\n        }\n        val = i * (i+1) * (i+2) / 6;\n    }\n\n    while(cin >> n) {\n        if(n == 0) break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<stdint.h>\n#include<vector>\n#include<deque>\n#include<stack>\n#include<string>\n#include<cstring>\n#include<time.h>\n#include<iomanip>\n#include<list>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<random>\n#include<bitset>\n#include <queue>\n#include <map>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing ldouble = long double;\n\n\n#define repi(i,a,b) for(ll i = (a); i < (b); i++)\n#define rep(i, n) for(ll i = 0; i < (n); ++i)\n\n\nll MOD = 1000000007;\nint main() {\n\tvector<int> s;\n\tvector<int> k;\n\tfor (int j = 1; true; ++j) {\n\t\tint x = j * (j + 1) * (j + 2) / 6;\n\t\ts.push_back(x);\n\t\tif (x % 2 == 1) k.push_back(x);\n\t\tif (x > 1000000) break;\n\t}\n\tvector<pair<int, int>> res;\n\tvector<pair<int, int>> ans;\n\tunordered_map<int, int> idx;\n\tlist<int> q1;\n\tlist<int> q2;\t\n\tfor(int i = 1; true; ++i) {\n\t\tint c; \n\t\tcin >> c;\n\t\tif (c == 0) break;\n\t\tq1.push_back(c);\n\t\tq2.push_back(c);\n\t\tidx.insert(pair<int, int>(c, i));\n\t}\n\tres.resize(idx.size());\n\tbitset<1000001> b;\n\tb[0] = true;\n\tfor (int i = 1; !q1.empty(); ++i) {\n\t\tbitset<1000001> buf = b;\n\t\tfor (int j : s) buf |= (b << j);\n\t\tfor (auto it = q1.begin(); it != q1.end();) {\n\t\t\tif (buf[*it]) {\n\t\t\t\tres[idx[*it]-1].first = i;\n\t\t\t\tit = q1.erase(it);\n\t\t\t}\n\t\t\telse it++;\n\t\t}\n\t\tb = buf;\n\t}\n\tb.reset();\n\tb[0] = true;\n\tfor (int i = 1; !q2.empty(); ++i) {\n\t\tbitset<1000001> buf = b;\n\t\tfor (int j : k) buf |= (b << j);\n\t\tfor (auto it = q2.begin(); it != q2.end();) {\n\t\t\tif (buf[*it]) {\n\t\t\t\tres[idx[*it]-1].second = i;\n\t\t\t\tit = q2.erase(it);\n\t\t\t}\n\t\t\telse it++;\n\t\t}\n\t\tb = buf;\n\t}\n\trep(i, res.size()) cout << res[i].first << \" \" << res[i].second << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;i<180;i++) if(n>=p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;i<180;i++) if(p[i]&1 && n>=p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=0;i<111111;i++){ solve(i), solve2(i); }\n \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    long long n;\n    int j = 0;\n    long long a[84];\n    long long b[22];\n    int t[100010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        t[0] = 0;\n\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n            \n        }\n        cout << t[n] << \" \";        \n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        t[0] = 0;\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int i,j,n,three[10000],four[10000],four_2[10000],c[10000],c_2[10000];\n\n  three[0] = 1;\n  four[0] = 1;\n  for( i = 1; i < 10000; i++ )three[i] = i+1 + three[i-1];\n  for( i = 1; i < 10000; i++ )four[i] = three[i] + four[i-1];\n  \n  int k = 0;\n  for( i = 0; i < 10000; i++ ){\n    if(four[i] %2 == 1 ){\n      four_2[k] = four[i];\n      k++;\n    }\n  }\n  \n  while(1){\n    int n; cin >> n;\n    if(n==0)break;\n    for( i = 0; i <= n; i++ ){\n      c[i] = 2000000;\n      c_2[i] = 2000000;\n    }\n\n    c[0] = 0;\n    for( i = 0; i < n; i++ ){\n      for( j = four[i]; j <= n; j++ ){\n\tc[j] = min( c[j],c[j-four[i]] + 1 );\n      }\n    }\n\n    c_2[0] = 0;\n    for( i = 0; i < n; i++ ){\n      for ( j = four_2[i]; j <= n; j++ ){\n\tc_2[j] = min( c_2[j],c_2[j-four_2[i]] + 1 );\n      }\n    }\n    cout << c[n] << \" \" << c_2[n] << endl;\n  }\n    return 0;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ1167\n//\n//  Created by aki33524 on 2014/07/09.\n//  Copyright (c) 2014年 aki33524. All rights reserved.\n//\n\n#include <iostream>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\nconst int MAX_N = 1000000;\nconst int MAX_T = 200;\n\nvector<int> tetras;\nvector<int> oddtetras;\nint dp1[MAX_T + 1][MAX_N];\nint dp2[MAX_T + 1][MAX_N];\n\nvoid init(){\n    memset(dp1, 0x3f, sizeof(dp1));\n    memset(dp2, 0x3f, sizeof(dp2));\n    \n    for(int i=0; i<MAX_T; i++){\n        int t = i*(i+1)*(i+2)/6;\n        tetras.push_back(t);\n        if(t%2)\n            oddtetras.push_back(t);\n    }\n    \n    for(int i=0; i<tetras.size(); i++)\n        dp1[0][tetras[i]] = 1;\n    for(int i=0; i<tetras.size(); i++){\n        int t = tetras[i];\n        for(int j=0; j<MAX_N; j++){\n            if(j < t){\n                dp1[i+1][j] = dp1[i][j];\n            }else{\n                dp1[i+1][j] = min(dp1[i][j], dp1[i+1][j-t]+1);\n            }\n        }\n    }\n    \n    for(int i=0; i<oddtetras.size(); i++)\n        dp2[0][oddtetras[i]] = 1;\n    for(int i=0; i<oddtetras.size(); i++){\n        int t = oddtetras[i];\n        for(int j=0; j<MAX_N; j++){\n            if(j < t){\n                dp2[i+1][j] = dp2[i][j];\n            }else{\n                dp2[i+1][j] = min(dp2[i][j], dp2[i+1][j-t]+1);\n            }\n        }\n    }\n}\n\nint main(int argc, const char * argv[])\n{\n    init();\n    \n    int N;\n    while(cin>>N, N){\n        cout << dp1[tetras.size()][N] << \" \" << dp2[oddtetras.size()][N] << endl;;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\nconst int inf = 1000000009;\n\nint main() {\n    vector<vector<int>> memo(85, vector<int>(1000000, inf));\n    vector<vector<int>> odd_memo(85, vector<int>(1000000, inf));\n    for (int i=0; i<1000000; i++) {\n        memo[0][i] = 0;\n        odd_memo[0][i] = 0;\n    }\n\n    for (int i=0; i<1000000; i++) {\n        memo[1][i] = i;\n        odd_memo[1][i] = i;\n    }\n\n    for (int l=2; l<(int)memo.size(); l++) {\n        const int n = (l*(l+1)*(l+2))/6;\n        for (int i=0; i<(int)memo[l].size(); i++) {\n            if(i-n == 0) {\n                memo[l][i] = 1;\n            } else if(i-n > 0) {\n                memo[l][i] = min(memo[l][i-n]+1, memo[l-1][i]);\n            } else {\n                memo[l][i] = memo[l-1][i];\n            }\n\n            if (l%2==1) {\n                if(i-n == 0) {\n                    odd_memo[l][i] = 1;\n                } else if(i-n > 0) {\n                    odd_memo[l][i] = min(odd_memo[l][i-n]+1, odd_memo[l-1][i]);\n                } else {\n                    odd_memo[l][i] = odd_memo[l-1][i];\n                }\n            } else {\n                odd_memo[l][i] = odd_memo[l-1][i];\n            }\n        }\n    }\n\n    int n; \n    while (cin >> n, n!=0) {\n        cout << memo[memo.size()-1][n] << \" \" << odd_memo[odd_memo.size()-1][n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint dp[1000001], dp_odd[1000001];\n\nsigned main()\n{\n    omajinai;\n\n    vi tet, tet_odd;\n\n    for (int i = 1; ; ++i) {\n        tet.PB(i * (i + 1) * (i + 2) / 6);\n        if (tet.back() >= 1000000) break;\n    }\n\n    for (int i = 0; i < tet.size(); ++i) {\n        if (tet[i] & 1) tet_odd.PB(tet[i]);\n    }\n\n    for (int i = 1; i <= 1000000; ++i) dp[i] = dp_odd[i] = inf;\n\n    for (int i = 1; i <= 1000000; ++i) {\n        for (int j = 0; j < tet.size(); ++j) {\n            if (i >= tet[j]) {\n                dp[i] = min(dp[i], dp[i - tet[j]] + 1);\n            }\n            if (i < tet[j]) break;\n        }\n\n        for (int j = 0; j < tet_odd.size(); ++j) {\n            if (i >= tet_odd[j]) {\n                dp_odd[i] = min(dp_odd[i], dp_odd[i - tet_odd[j]] + 1);\n            }\n            if (i < tet_odd[j]) break;\n        }\n    }\n\n    int N;\n    while (cin >> N, N) cout << dp[N] << ' ' << dp_odd[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(n >= p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=180;i>0;i--) if(p[i]&1 && n >= p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n\n  //for(int i=0;i<1111111;i+=10){ solve(i), solve2(i); }\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i < n; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define INF 1e9\ntypedef long long ll;\n\n\n\nint main() {\n    int MAX = 10e6;\n\n    vector<int> dp(MAX+1, INF);\n    vector<int> odd_dp(MAX+1, INF);\n\n    dp[0] = 0;\n    odd_dp[0] = 0;\n\n\n    // FOR(i,0,10e6+1){\n    //     cout << i << endl;\n    //     FOR(j,1,1000){\n    //         int num = j*(j+1)*(j+2)/6;\n    //         if (i+num >= 10e6) break;\n    //         dp[i+num] = min(dp[i+num], dp[i]+1);\n    //         if(j%2 == 0){\n    //             odd_dp[i+num] = min(odd_dp[i+num], odd_dp[i]+1);\n    //         }\n    //     }\n    // }\n\n    FOR(j,1,1000){\n        int num = j*(j+1)*(j+2)/6;\n        if (num > MAX) break;\n        FOR(i,0,MAX+1){\n            if (i+num > MAX) break;\n            dp[i+num] = min(dp[i+num], dp[i]+1);\n            if(num%2 == 1){\n                odd_dp[i+num] = min(odd_dp[i+num], odd_dp[i]+1);\n            }\n        }\n    }\n\n    while(1){\n        int N;\n        cin >> N;\n        if (N == 0) break;\n\n        cout << dp[N] << \" \" << odd_dp[N] << endl;\n\n    }\n    return 0;\n}\n\n// #include <iostream>\n// #include <vector>\n// using namespace std;\n\n// const int MAX = 1000100;\n// const int INF = 1<<29;\n\n// int main() {\n//     vector<int> dp(MAX, INF), odddp(MAX, INF);\n//     dp[0] = odddp[0] = 0;\n//     for (int i = 1;; ++i) {\n//         int num = i * (i+1) * (i+2) / 6;\n//         if (num >= MAX) break;\n//         for (int j = num; j < MAX; ++j) {\n//             dp[j] = min(dp[j], dp[j-num]+1);\n//             if (num & 1) odddp[j] = min(odddp[j], odddp[j-num]+1);\n//         }\n//     }\n//     int n;\n//     while (cin >> n) {\n//         if (n == 0) break;\n//         cout << dp[n] << \" \" << odddp[n] << endl;\n//     }\n// }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX = 1000000;\n\nint dp[MAX], dp_odd[MAX];\n\nint main()\n{\n  vector<int> tetra, tetra_odd;\n\n  for (int i = 1; ; ++i) {\n    int d = i * (i + 1) * (i + 2) / 6;\n    if (d >= MAX)\n      break;\n    tetra.push_back(d);\n    if (d % 2 == 1)\n      tetra_odd.push_back(d);\n  }\n\n  for (int i = 0; i < MAX; ++i)\n    dp[i] = dp_odd[i] = i;\n\n  for (int i = 1; i < MAX; ++i) {\n    for (int j = tetra.size() - 1; j >= 0; --j) {\n      if (i >= tetra[j]) {\n\tint q = i / tetra[j];\n\tint s = i % tetra[j];\n\tdp[i] = min(dp[i], q + dp[s]);\n      }\n    }\n    for (int j = tetra_odd.size() - 1; j >= 0; --j) {\n      if (i >= tetra_odd[j]) {\n\tint q = i / tetra_odd[j];\n\tint s = i % tetra_odd[j];\n\tdp_odd[i] = min(dp_odd[i], q + dp_odd[s]);\n      }\n    }\n  }\n\n  int in;\n  for ( ; ; ) {\n    cin >> in;\n    if (in == 0)\n      break;\n    cout << dp[in] << \" \" << dp_odd[in] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n\nint main(){\n  int x;\n\n  VI array;\n  VI oddArray;\n\n  FOR(i,1,200){\n    if(i*(i+1)*(i+2)/6 <= 1e6){\n      array.push_back(i*(i+1)*(i+2)/6);\n      if((i*(i+1)*(i+2)/6) % 2 == 1) oddArray.push_back(i*(i+1)*(i+2)/6);\n    }\n\n\n    else break;\n  }\n  VI dp(1000010,0);\n  VI dpOdd(1000010,0);\n  rep(i,array.size()){\n    dp[array[i]] ++;\n  }\n  rep(i,oddArray.size()){\n    dpOdd[oddArray[i]] ++;\n  }\n  rep(j,array.size()){\n    rep(k,1e6+1){\n      if(dp[k] == 0) continue;\n      if(array[j]+k >= 1e6) continue;\n      if(dp[array[j]+k] >= 1) dp[array[j]+k] = min(dp[k] + 1,dp[array[j]+k]);\n      else dp[array[j]+k] = dp[k] + 1;\n    }\n  }\n  rep(j,oddArray.size()){\n    rep(k,1e6+1){\n      if(dpOdd[k] == 0) continue;\n      if(oddArray[j]+k >= 1e6) continue;\n      if(dpOdd[oddArray[j]+k] >= 1) dpOdd[oddArray[j]+k] = min(dpOdd[k] + 1,dpOdd[oddArray[j]+k]);\n      else dpOdd[oddArray[j]+k] = dpOdd[k] + 1;\n    }\n  }\n\n  // rep(i,10){\n  //   rep(j,array.size()){\n  //     int cnt = 0;\n  //     if(array[j] % 2 == 0) continue;\n  //     FOR(k,1,1e6+1){\n  //       if(dp[k].second == 0) continue;\n  //       cnt++;\n  //       if(array[j]+k >= 1e6) continue;\n  //       if(dp[array[j]].first == 0) continue;\n  //       if(dp[array[j]+k].first >= 1) continue;\n  //       dp[array[j]+k].first += dp[array[j]].first + 1;\n  //     }\n  //   }\n  //}\n  while(true){\n    cin >> x;\n    if(x == 0) return 0;\n    cout << dp[x] << ' ' << dpOdd[x] << endl;\n    //printf(\"%d %d\\n\",dp[x].first,dp[x].second);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-6;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nconst int64 mod = 1e9+7;\n\nvector<int64> po, podd;\nvector<int64> dp(1e6+1, INF), dpdd(1e6+1, INF);\n\nvoid init(){\n\tfor(int64 i = 1;i*(i+1)*(i+2)/6 <= 1000000;i++){\n\t\tint64 x = i*(i+1)*(i+2)/6;\n\t\tpo.push_back(x);\n\t\tif(x%2) podd.push_back(x);\n\t}\n\n\tdp[0] = 0; dpdd[0] = 0;\n\tREP(i, po.size()){\n\t\tfor(int32 j = 0;j+po[i] < dp.size();j++){\n\t\t\tdp[j+po[i]] = min(dp[j+po[i]], dp[j]+1);\n\t\t}\n\t}\n\tREP(i, podd.size()){\n\t\tfor(int32 j = 0;j+podd[i] < dpdd.size();j++){\n\t\t\tdpdd[j+podd[i]] = min(dpdd[j+podd[i]], dpdd[j]+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tinit();\n\tint32 N;\n\twhile(cin >> N && N){\n\t\tcout << dp[N] << \" \" << dpdd[N] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\n\nint N=100000;\nint dp[100000], oddDp[100000];\nvector<int> sqNum;\nvector<int> oddSqNum;\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n\n  for(int i=1; i<202; i++){\n    int num = i*(i+1)*(i+2)/6;\n    sqNum.PB( num );\n    if(num%2==1)\n      oddSqNum.PB( num );\n  }\n\n  fill( dp, dp+N, INF );\n  fill( oddDp, oddDp+N, INF );\n  dp[0] = 0;\n  oddDp[0] = 0;\n\n  REP(i,N){\n    REP(j,sqNum.size()){\n      if( i-sqNum[j] >= 0 ){\n\tdp[i] = min( dp[i], dp[i-sqNum[j]]+1 );\n      }\n    }\n\n    REP(j,oddSqNum.size()){\n      if( i-oddSqNum[j] >= 0 ){\n\toddDp[i] = min( oddDp[i], oddDp[i-oddSqNum[j]]+1 );\n      }\t\n    }\n  }\n\n  int n;\n  while(cin>>n,n){\n    cout << dp[n] << \" \" << oddDp[n] << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1e7\n\nusing namespace std;\n\nint dp(int n,vector<int> tetra){\n\tint num;\n\tnum=distance(tetra.begin(),upper_bound(tetra.begin(),tetra.end(),n)-1);\n\n\tvector<int> pre(n+1,INF),now(n+1,INF);\n\n\tfor(int i=0;i<=n;i++){\n\t\tpre[i]=i;\n\t}\n\tnow[0]=0;\n\tfor(int i=2;i<=num;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j-tetra[i]>=0){\n\t\t\t\tnow[j]=min(pre[j],now[j-tetra[i]]+1);\n\t\t\t}\n\t\t\telse now[j]=pre[j];\n\t\t}\n\t\tnow.swap(pre);\n\t}\n\treturn pre[n];\n}\n\nint main(){\n\tvector<int> t(1,0),t1(1,0);\n\tint c=1;\n\twhile(t[c-1]<=(int)1e6){\n\t\tint temp;\n\t\ttemp=c*(c+1)*(c+2)/6;\n\t\tt.push_back(temp);\n\t\tif(temp%2==1 ){\n\t\t\tt1.push_back(temp);\n\t\t}\n\t\tc++;\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\t\n\t\t/*\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tfor(int j=0;j<s[i].size();j++){\n\t\t\t\tif(s[i][j]==INF) cout << \"0\";\n\t\t\t\telse cout << s[i][j];\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << dp(n,t) << \" \" << dp(n,t1) << endl;\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 10000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\nint dp1[2][1000000 + 1];\nint dp2[2][1000000 + 1];\nvector<int> cnt1;\nvector<int> cnt2;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    rep2(i, 1, 200) {\n        cnt1.push_back(i * (i + 1) * (i + 2) / 6);\n        if ((i * (i + 1) * (i + 2) / 6)% 2 == 1) {\n            cnt2.push_back(i * (i + 1) * (i + 2) / 6);\n        }\n    }\n    int cur1 = 1, pre1 = 0;\n    int cur2 = 1, pre2 = 0;\n    rep(j, 1000000 + 1) {\n        dp1[pre1][j] = INF;\n        dp2[pre2][j] = INF;\n    }\n    dp1[0][0] = 0;\n    dp2[0][0] = 0;\n    rep(i, 200) {\n        rep(j, 1000000 + 1) dp1[cur1][j] = INF;\n        rep(j, 1000000 + 1) {\n            dp1[cur1][j] = dp1[pre1][j];\n            if (j - cnt1[i] >= 0) {\n                dp1[cur1][j] = min(dp1[cur1][j], dp1[cur1][j - cnt1[i]] + 1);\n            }\n        }\n        swap(cur1, pre1);\n    }\n    rep(i, cnt2.size()) {\n        rep(j, 1000000 + 1) dp2[cur2][j] = INF;\n        rep(j, 1000000 + 1) {\n            dp2[cur2][j] = dp2[pre2][j];\n            if (j - cnt2[i] >= 0) {\n                dp2[cur2][j] = min(dp2[cur2][j], dp2[cur2][j - cnt2[i]] + 1);\n            }\n        }\n        swap(cur2, pre2);\n    }\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        cout << dp1[pre2][n] << \" \" << dp2[pre2][n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n\nusing  namespace std;\n\n#define N 1000000\n#define M 300\n\nint tet_num[M];\nint tet_num_odd[M];\nint ans_integer[N];\nint ans_odd[N];\n\nint main(){\n\n\tint n;\n\tint j = 1;\n\n\tfor (int i = 0; i < M; i++){\n\t\ttet_num[i] = i*(i + 1)*(i + 2) / 6;\n\t\tif (tet_num[i] % 2 == 1){\n\t\t\ttet_num_odd[j] = tet_num[i];\n\t\t\tj++;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++){\n\t\tans_integer[i] = N;\n\t\tans_odd[i] = N;\n\t}\n\n\twhile (1){\n\n\t\tcin >> n;\n\n\t\tif (n == 0)break;\n\n\t\tfor (int m = 1; m <= n; m++){\n\t\t\tif (ans_integer[m] == N){\n\t\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\t\tif (m == tet_num[i]){\n\t\t\t\t\t\tans_integer[m] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (m - tet_num[i] > 0){\n\t\t\t\t\t\tif (ans_integer[m] > ans_integer[m - tet_num[i]] + 1)\n\t\t\t\t\t\t\tans_integer[m] = ans_integer[m - tet_num[i]] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\t\tif (m == tet_num_odd[i]){\n\t\t\t\t\t\tans_odd[m] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (m - tet_num_odd[i] > 0){\n\t\t\t\t\t\tif (ans_odd[m] > ans_odd[m - tet_num_odd[i]] + 1)\n\t\t\t\t\t\t\tans_odd[m] = ans_odd[m - tet_num_odd[i]] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans_integer[n] << \" \" << ans_odd[n] << endl;\n\n\t}\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n\n    int dp[100000];\n    fill(dp,dp + x + 1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  constexpr int N = 1e6;\n  V<> a, b;\n  for (int i = 1; ; ++i) {\n    a.push_back(i * (i + 1) * (i + 2) / 6);\n    if (a.back() >= N) {\n      a.pop_back();\n      break;\n    }\n    if (a.back() & 1) b.push_back(a.back());\n  }\n  V<> p(N, -1), q(N, -1);\n  p[0] = q[0] = 0;\n  queue<int> que;\n  que.push(0);\n  while (!que.empty()) {\n    int i = que.front(); que.pop();\n    for (int e : a) if (i + e < N and p[i + e] == -1) {\n      p[i + e] = p[i] + 1;\n      que.push(i + e);\n    }\n  }\n  que.push(0);\n  while (!que.empty()) {\n    int i = que.front(); que.pop();\n    for (int e : b) if (i + e < N and q[i + e] == -1) {\n      q[i + e] = q[i] + 1;\n      que.push(i + e);\n    }\n  }\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    cout << p[n] << ' ' << q[n] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nvi all, odd, v;\nint allt[1000005], oddt[1000005];\n\nint main()\n{\n\tv.push_back(0);\n\tFOR(i, 1, 1000) v.push_back(v[i - 1] + i);\n\tall.push_back(0);\n\tFOR(i,1, v.size())\n\t{\n\t\tall.push_back(all[i - 1] + v[i]);\n\t\tif (i & 1) odd.push_back(all[i - 1] + v[i]);\n\t\tif (all[i] > 1000000) break;\n\t}\n\tint n;\n\tfill(ALL(allt), INF); fill(ALL(oddt), INF);\n\tallt[0] = oddt[0] = 0;\n\tREP(i, 1000001)REP(j, all.size())\n\t{\n\t\tint t = i + all[j];\n\t\tif (t >= 1000001) break;\n\t\tallt[t] = min(allt[i] + 1, allt[t]);\n\t}\n\n\tREP(i, 1000001)REP(j, odd.size())\n\t{\n\t\tint t = i + odd[j];\n\t\tif (t >= 1000001) break;\n\t\toddt[t] = min(oddt[i] + 1, oddt[t]);\n\t}\n\twhile (cin >> n, n) cout << allt[n] << \" \" << oddt[n] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint num[1000010];\n\tint num2[1000010];\n\tvector<int> v;\n\tfor(int i=0; i< 100000; i++){\n\t\tint m = i*(i+1)*(i+2)/6;\n\t\tif(1000000 <= m) break;\n\t\tv.push_back(m);\n\t}\n\tfor(int i=0; i< 1000010; i++) num[i] = 10e8;\n\tfor(int i=0; i< 1000010; i++) num2[i] = 10e8;\n\tnum[0] = 0;\n\tnum2[0] = 0;\n\tfor(int j=0; j< 1000010; j++){\n\t\tfor(int i=0; i < v.size(); i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(1000010 <= m+j) continue;\n\t\t\tnum[j+m] = min(num[j]+1, num[j+m]);\n\n\t\t\tif(m == 0) continue;\n\t\t\tif(m%2 == 0) continue;\n\t\t\tnum2[j+m] = min(num2[j]+1, num2[j+m]);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << num[n] << \" \" << num2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tvector<int>e(1000000, MOD);\n\te[0] = 0;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tfor (int j = 1; j < 1000; j++) {\n\t\t\tint box = i + j * (j + 1)*(j + 2) / 6;\n\t\t\tif (box >= 1000000)break;\n\t\t\te[box] = min(e[box], e[i] + 1);\n\t\t}\n\t}\n\tvector<int>o(1000000, MOD);\n\to[0] = 0;\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tfor (int j = 1; j < 1000; j += 2) {\n\t\t\tint box = i + j * (j + 1)*(j + 2) / 6;\n\t\t\tif (box >= 1000000)break;\n\t\t\to[box] = min(o[box], o[i] + 1);\n\t\t}\n\t}\n\tcin >> N;\n\twhile (N) {\n\t\tcout << e[N] << \" \" << o[N] << endl;\n\t\tcin >> N;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nvector<int> tri;\nvector<int> b;\nvector<int> a;\nint ansa[1000005];\nint ansb[1000005];\n\nint main()\n{\n\ttri.push_back(0);\n\ta.push_back(0);\n\tFOR(i, 1, 10000) tri.push_back(tri[i - 1] + i);\n\tFOR(i, 1, 10000)\n\t{\n\t\ta.push_back(a[i - 1] + tri[i]);\n\t\tif (a.back() & 1) b.push_back(a.back());\n\t\tif (a.back() > 1000001) break;\n\t}\n\tfill(ALL(ansa), INF);\n\tfill(ALL(ansb), INF);\n\tansa[0] = ansb[0] = 0;\n\tREP(j, 1000001)\n\t{\n\t\tREP(i, a.size())\n\t\t{\n\t\t\tint t = j + a[i];\n\t\t\tif (t > 1000001) break;\n\t\t\tansa[t] = min(ansa[t],ansa[j] + 1);\n\t\t}\n\t}\n\tREP(j, 1000001)\n\t{\n\t\tREP(i, b.size())\n\t\t{\n\t\t\tint t = j + b[i];\n\t\t\tif (t > 1000001) break;\n\t\t\tansb[t] = min(ansb[t],ansb[j] + 1);\n\t\t}\n\t}\n\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tcout << ansa[n] << \" \" << ansb[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MOD = 1e9+7;\ntemplate<class T>bool chmin(T &a, const T &b)\n{ return (a>b ? (a=b)||1 : 0); }\n\nint main(){\n\t\n\tvector<int> d,e;\n\tfor(int i=1; i<=200; i++){\n\t\tint m = i*(i+1)*(i+2)/6;\n\t\td.push_back(m);\n\t\tif(m%2) e.push_back(m);\n\t}\n\tvector<int> dp1(1000001,1e8);\n\tvector<int> dp2(1000001,1e8);\n\tdp1.at(0) = 0;\n\tdp2.at(0) = 0;\n\tfor(int i=0; i<=1000000; i++){\n\t\tfor(auto j:d){\n\t\t\tif(i+j<=1e6){\n\t\t\t\tchmin(dp1.at(i+j),dp1.at(i)+1);\n\t\t\t}\n\t\t}\n\t\tfor(auto j:e){\n\t\t\tif(i+j<=1e6){\n\t\t\t\tchmin(dp2.at(i+j),dp2.at(i)+1);\n\t\t\t}\n\t\t}\n\t}\n\twhile(1){\n\t\tint n; cin>>n;\n\t\tif(!n) break;\n\t\tcout << dp1.at(n)<<' '<<dp2.at(n)<<endl;\n\t}\n\t\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef _DEBUG\n#include \"debug.hpp\"\n#else\n#define debug(...)\n#endif\n#define REP(i, m, n) for(int (i) = (m); (i) < (n); ++i)\n#define rep(i, n) REP(i, 0, n)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1e9 + 7;\nconst ll LINF = 1LL << 60;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if(a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if(a > b) { a = b; return true; } return false; }\n\nconst int MAX = 1000100;\nint dp1[MAX], dp2[MAX];\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  rep(i,MAX) dp1[i] = INF, dp2[i] = INF;\n  dp1[0] = dp2[0] = 0;\n  vector<int> s1, s2;\n  ll t = 1;\n  while(t*(t+1)*(t+2)/6 < 1000000) {\n    ll s = t*(t+1)*(t+2)/6;\n    s1.push_back(s);\n    if(s%2) s2.push_back(s);\n    t++;\n  }\n  // チノガキbot \"because t^3 is included, the size won't be over 10^3!!!\"\n  rep(i,MAX-50) {\n    rep(j,s1.size()) {\n      if(i+s1[j] >= MAX-50) break;\n      chmin(dp1[i+s1[j]], dp1[i]+1);\n    }\n    rep(j,s2.size()) {\n      if(i+s2[j] >= MAX-50) break;\n      chmin(dp2[i+s2[j]], dp2[i]+1);\n    }\n  }\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    cout << dp1[n] << \" \" << dp2[n] << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1167\n#include<iostream>\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\n\ntypedef long long int number;\n\nconst number NMAX = 10e6 + 8;\n\nint dp[NMAX], odp[NMAX];\n\nint main() {\n  REP(i, NMAX) {\n    dp[i] = odp[i] = i;\n  }\n  for (number i = 2; i * (i + 1) * (i + 2) / 6 < NMAX; i++) {\n    int tetr = i * (i + 1) * (i + 2) / 6;\n    int limit = min(NMAX, (i + 1) * (i + 2) * (i + 3) / 6 + 8);\n    for (number j = tetr; j < limit; j++) {\n      dp[j] = min(dp[j], dp[j - tetr] + 1);\n    }\n\n    if (tetr % 2 != 0) {\n      int limit = min(NMAX, (i + 4) * (i + 5) * (i + 6) / 6 + 8);\n      for (number j = tetr; j < limit; j++) {\n        odp[j] = min(odp[j], odp[j -tetr] + 1);\n      }\n    }\n  }\n\n  int n;\n  while (cin >> n and n) {\n    cout << dp[n] << \" \" << odp[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX+1],dp2[MAX+1];\n\nint main() {\n    for(int i = 1;i <= MAX;i++) {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n + 2) / 6 <= MAX;n++) {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for(int i = a;i <= MAX;i++) {\n            dp1[i] = min(dp1[i],dp1[i - a] + 1);\n        }\n        if(a % 2 == 0)continue;\n        for(int i = a;i <= MAX;i++) {\n            dp2[i] = min(dp2[i],dp2[i - a] + 1);\n        }\n    }\n\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp1[1000001],dp2[1000001];\nint main(){\n  int c1[100000],c2[100000],i,m,p=0,k;\n  for(i=0;i*(i+1)*(i+2)/6<=1000000;i++){\n    c1[i]=i*(i+1)*(i+2)/6;\n    if(c1[i]%2==1){\n      c2[p]=c1[i]; \n      p++; \n    }\n  }\n  for(int j=0;j<=1000000;j++){\n    dp1[j]=j;\n    dp2[j]=j;\n    for(int k=0;k<i;k++){\n      if(j-c1[k]>=0)dp1[j]=min(dp1[j],dp1[j-c1[k]]+1);\n      if(k<p){\n\tif(j-c2[k]>=0){\n\tdp2[j]=min(dp2[j],dp2[j-c2[k]]+1);\n       }\n      }\n    }\n  }\n\n  while(1){\n  cin >>m;\n  if(m==0)break;\n\n  cout << dp1[m]<<\" \"<<dp2[m]<<endl;\n  }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tmemset(dp, 0, sizeof(dp));\n\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; k<(int)V.size() && j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=MAX && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tdp[i%2][j] = 0;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; k<(int)D.size() && j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint tetrahedron(int);\n\nint index_direct_match(int);\nint index_direct_match_odd(int);\nint index_number(int);\nint index_number_odd(int);\n\nint main(int argc, char const *argv[]) {\n\n  int n;\n  int cnt_min;\n  int cnt_only_odd;\n\n  for(cin >> n;n != 0;cin >> n){\n\n    cout << index_number(n) << \" \" <<  index_number_odd(n) << endl;\n\n  }\n\n  //\n\n  return 0;\n}\n\nint tetrahedron(int k){\n\n  return k*(k+1)*(k+2)/6;\n\n}\n\nint index_number(int index){\n  static int memo[1000]={};\n  if(index>=1 && index<=3) return index;\n  else if(index_direct_match(index)) return 1;\n  else if(memo[index] != 0) return memo[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i++){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number( index - tetrahedron(i) ));\n    }\n    memo[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n\n}\n\nint index_direct_match(int index){\n\n  for(int i=1;i<200;i++){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_direct_match_odd(int index){\n\n  for(int i=1;i<200;i+=4){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_number_odd(int index){\n  static int memo2[1000]={};\n  if(index>=1 && index<=34) return index;\n  else if(index_direct_match_odd(index)) return 1;\n  else if(memo2[index] != 0) return memo2[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i+=4){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number_odd( index - tetrahedron(i) ));\n    }\n    memo2[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 1145141919\n#define MOD 1000000007\n#define ALL(a) begin((a)),end((a))\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<edge> edges;\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nvi all, odd, v;\nint allt[1000005], oddt[1000005];\n\nint main()\n{\n\tv.push_back(0);\n\tFOR(i, 1, 1000) v.push_back(v[i - 1] + i);\n\tall.push_back(0);\n\tFOR(i,1, v.size())\n\t{\n\t\tall.push_back(all[i - 1] + v[i]);\n\t\tif (all[i] & 1) odd.push_back(all[i]);\n\t\tif (all[i] > 1000000) break;\n\t}\n\tint n;\n\tfill(ALL(allt), INF); fill(ALL(oddt), INF);\n\tallt[0] = oddt[0] = 0;\n\tREP(i, 1000001)REP(j, all.size())\n\t{\n\t\tint t = i + all[j];\n\t\tif (t >= 1000001) break;\n\t\tallt[t] = min(allt[i] + 1, allt[t]);\n\t}\n\n\tREP(i, 1000001)REP(j, odd.size())\n\t{\n\t\tint t = i + odd[j];\n\t\tif (t >= 1000001) break;\n\t\toddt[t] = min(oddt[i] + 1, oddt[t]);\n\t}\n\twhile (cin >> n, n)\n\t{\n\t\tcout << allt[n] << \" \" << oddt[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nvector<int> pol;\nvector<int> pol_odd;\nint dp1[1000100],dp2[1000100];\nint main()\n{\n\tfor(int i=0;i<=1000000;i++)dp1[i]=dp2[i]=INF;\n\tdp1[0]=dp2[0]=0;\n\tfor(int i=1;;i++)\n\t{\n\t\tint k=i*(i+1)*(i+2)/6;\n\t\tif(k>1000000)break;\n\t\tpol.pb(k);\n\t\tif(k%2)pol_odd.pb(k);\n\t}\n\tfor(int i=0;i<=1000000;i++)\n\t{\n\t\tfor(int j=0;j<pol.size();j++)\n\t\t{\n\t\t\tif(i<pol[j])break;\n\t\t\tdp1[i]=min(dp1[i],dp1[i-pol[j]]+1);\n\t\t}\n\t}\n\tfor(int i=0;i<=1000000;i++)\n\t{\n\t\tfor(int j=0;j<pol_odd.size();j++)\n\t\t{\n\t\t\tif(i<pol_odd[j])break;\n\t\t\tdp2[i]=min(dp2[i],dp2[i-pol_odd[j]]+1);\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define MAXNUM 1000000\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM];\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//1からMAXまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t\tif (minnum == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  vector<int> smt(1,0);\n  vector<int> ksmt(1,0);\n  int a;\n  for(int i=1;i<10000;i++){\n    a=i*(i+1)*(i+2)/6;\n    smt.push_back(a);\n    if(a%2==1)ksmt.push_back(a);\n    if(a>1000000)break;\n    //cout << a << endl;\n  }\n    //cout <<smt.size()<<\" \"<<ksmt.size()<<endl;\n  int dp[2][1000001]={};\n  //cout <<\"2\"<<endl;\n  //\n  for(int i=1;i<=1000000;i++){\n    dp[0][i]=i;\n    dp[1][i]=i;\n  }\n  //all\n  for(int i=1;i<smt.size();i++){\n    for(int j=1;j<=1000000;j++){\n      if(smt[i]>j) dp[0][j]=dp[0][j];\n      else{\n\tdp[0][j]=min(dp[0][j],dp[0][j-smt[i]]+1);\n      }\n      //cout <<dp[k][j]<<\" \";\n    }\n  }\n  //kisuu\n  for(int i=1;i<ksmt.size();i++){\n    for(int j=1;j<=1000000;j++){\n      if(ksmt[i]>j) dp[1][j]=dp[1][j];\n      else{\n\tdp[1][j]=min(dp[1][j],dp[1][j-ksmt[i]]+1);\n      }\n    }\n  }\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0)break;\n    cout << dp[0][n]<<\" \"<<dp[1][n]<<endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main() {\n  vector<int> s,sodd;\n  for(int i=1; i*(i+1)*(i+2)/6 < 1000000; ++i) {\n    s.push_back(i*(i+1)*(i+2)/6);\n    if((i*(i+1)*(i+2)/6)%2 == 1)\n      sodd.push_back(i*(i+1)*(i+2)/6);\n  }\n\n  vector<int> table(1000001, 0);\n  vector<int> otable(1000001, 0);\n\n  for(int i=0; i<s.size(); ++i)\n    table[s[i]] = 1;\n\n  for(int i=0; i<sodd.size(); ++i)\n    otable[sodd[i]] = 1;\n\n  for(int j=1; j < 1000001; ++j) {\n    for(int i=0; i < s.size(); ++i)\n      if(table[j] != 0 && j+s[i] < 1000001) {\n\ttable[j + s[i]] = (table[j+s[i]]==0) ? table[j]+1 : min( table[j+s[i]], table[j]+1 );\n      }\n  }\n\n  for(int j=1; j < 1000001; ++j) {\n    for(int i=0; i < sodd.size(); ++i)\n      if(otable[j] != 0 && j+sodd[i] < 1000001) {\n\totable[j + sodd[i]] = (otable[j+sodd[i]]==0) ? otable[j]+1 : min( otable[j+sodd[i]], otable[j]+1 );\n      }\n  }\n\n  int d;\n  for(;;) {\n    cin>>d;\n    if(!d) break;\n    cout<<table[d]<<\" \"<<otable[d]<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n\nint main(void){\n\tint i, j, n, min1,small;\n\tint dp[200000];\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tsmall = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(small > dp[i]){\n\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tif(small > dp[n])\n\t\t\t\t\tsmall = dp[n];\n\t\t}\n\n\t\tmin1 = dp[n];\n\t\tfor(i = 0;i <= n;i++)\n\t\t\tdp[i] = INF;\n\t\tdp[0] = 0;\n\t\tsmall = INF;\n\t\tfor(i = 0;i < n;i++){\n\t\t\tif(dp[i] < small){\n\t\t\t\tfor(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n\t\t\t\t\tif(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n\t\t\t\t\t\tdp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(small > dp[n])\n\t\t\t\tsmall = dp[n];\n\t\t}\n\t\tprintf(\"%d %d\\n\",min1,dp[n]);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N=1000000;\nconst int INF=1<<30;\n\nint main(){\n  static int dp[N];\n  static int dpo[N];\n  fill(begin(dp),end(dp),INF);\n  fill(begin(dpo),end(dpo),INF);\n  dp[0]=dpo[0]=0;\n  for(int i=0;;i++){\n    int q=i*(i+1)*(i+2)/6;\n    if(q>N)break;\n    for(int j=q;j<N;j++){\n      dp[j]=min(dp[j],dp[j-q]+1);\n      if(q%2){\n\tdpo[j]=min(dpo[j],dpo[j-q]+1);\n      }\n    }\n  }\n  for(int n;cin>>n,n;){\n    cout<<dp[n]<<' '<<dpo[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    long long i;\n    int n;\n    long long j = 0;\n    int a[84];\n    int b[22];\n    long long t[10000];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[10000];\n    /*fill(dp,dp + x+1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    */\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int MAX_N = 1000011;\nint dp1[MAX_N+2];\nint dp2[MAX_N+2];\nvi w1;\nvi w2;\nint N;\n\ninline int get(int i){ return i * (i + 1) / 2 * (i + 2) / 3; }\n\nint main()\n{\n  rrep(i, 1, MAX_N){\n    if(get(i) >= MAX_N) break;\n    w1.pb(get(i));\n    if(get(i) & 1) w2.pb(get(i));\n  }\n  int n1 = w1.size();\n  int n2 = w2.size();\n\n  rep(i, MAX_N) dp1[i] = dp2[i] = INF;\n  rep(i, n1) dp1[w1[i]] = 1;\n  rep(i, n2) dp2[w2[i]] = 1;\n  rrep(i, 1, 111) rep(j, n1) if(i + w1[j] < MAX_N) minup(dp1[i + w1[j]], dp1[i] + 1);\n  rrep(i, 1, 111) rep(j, n2) if(i + w2[j] < MAX_N) minup(dp2[i + w2[j]], dp2[i] + 1);\n\n  while(cin >> N, N) cout << dp1[N] << ' ' << dp2[N] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <utility>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define MAX 1000000\nint all[MAX];\nint odd[MAX];\nint main()\n{\n\tint cnt = 1;\n\tivec A;\n\twhile (true)\n\t{\n\t\tint d = cnt * (cnt + 1) * (cnt + 2) / 6;\n\t\tif (d < MAX)\n\t\t{\n\t\t\tA.push_back(d);\n\t\t}\n\t\telse break;\n\t\tcnt++;\n\t}\n\tfor (int j = 0; j < MAX; j++)\n\t{\n\t\tall[j] = j;\n\t\todd[j] = j;\n\t}\n\n\tfor (int i = 1; i < A.size(); i++)\n\t{\n\t\tfor (int j = A[i]; j < MAX; j++)\n\t\t{\n\t\t\tall[j] = min(all[j], all[j - A[i]] + 1);\n\t\t\tif (A[i] % 2 == 0)continue;\n\t\t\todd[j] = min(odd[j], odd[j - A[i]] + 1);\n\t\t}\n\t}\n\t\n\n\n\twhile (true)\n\t{\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tif (s == 0)break;\n\t\tprintf(\"%d %d\\n\", all[s], odd[s]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[1000][2] = {{0}, {0}};\n  int a = 0, b = 0; /* a, b???ans??????????????????????????? */\n\n  /* ??£?????¢?????°?¨???? */\n  for (i = 1; i < 200; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  while (cin >> input) {\n    if (input == 0) break;  /* input???0??§break */\n    int temp = input; /* input??????????????? */\n    int j = 1, min = 1000;\n    /* tetras????????§input??\\?????§????????§??????????????¢??? */\n    while (tetras[j] <= input) j++;\n    j--;\n    int l = j; /* j ??????????????? */\n      \n    /* ?????????????????¢?????° */\n    while (j > 0) {\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* tetras[k] > input???????£???°??? */\n            if (tetras[k] > input) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][0] = min;\n      \n    /* ?\\???°?????£?????¢?????°?????? */\n    j = l;  /* j??????????????? */\n    min = 1000; /* min??????????????? */\n    while (j > 0) {\n        /* ??¶??°?????£?????¢?????°????£???°??? */\n        if (tetras[j] % 2 == 0) {\n            j--;\n            continue;\n        }\n        int n = 0;\n        int k = j;\n        while (input > 0) {\n            /* ??¶??°?????£?????¢?????°????£???°??? */\n            if (tetras[k] % 2 == 0 || tetras[k] > input) {\n                k--;\n                continue;\n            }\n            input -= tetras[k];\n            if (input >= 0) {\n                n++;\n            } else {\n                input += tetras[k];\n                k--;\n                continue;\n            }\n        }\n        if (min > n) min = n;\n        j--;\n        input = temp;\n    }\n    ans[a][1] = min;\n      \n    a++;\n  }\n\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ans1[1048576];\nint ans2[1048576];\nstd::vector<int> num4;\nstd::vector<int> numodd4;\n\nint main(int argc, char *argv[]) {\n\n  // step 1\n  for(int i = 1; ; ++i) {\n    int t = i * (i + 1) * (i + 2) / 6;\n    if( t >= 1048576 ) break;\n    num4.push_back(t);\n    if( t % 2 == 1 ) numodd4.push_back(t);\n  }\n  std::sort(std::begin(num4), std::end(num4));\n  std::sort(std::begin(numodd4), std::end(numodd4));\n  num4.erase(std::unique(std::begin(num4), std::end(num4)), std::end(num4));\n  numodd4.erase(std::unique(std::begin(numodd4), std::end(numodd4)), std::end(numodd4));\n\n  // step 2\n  for(int i = 1; i < 1048576; ++i) {\n    int min = 1048576;\n    for(int dx : num4) {\n      int previ = i - dx;\n      if( previ < 0 ) break;\n      min = std::min(min, ans1[previ] + 1);\n    }\n    ans1[i] = min;\n  }\n\n  // step 3\n  ans2[0] = 0;\n  for(int i = 1; i < 1048576; ++i) {\n    int min = 1048576;\n    for(int dx : numodd4) {\n      int previ = i - dx;\n      if( previ < 0 ) break;\n      min = std::min(min, ans2[previ] + 1);\n    }\n    ans2[i] = min;\n  }\n  \n  // step 4\n  for(;;) {\n    int N;\n    scanf(\"%d\", &N);\n    if( N == 0 ) break;\n    printf(\"%d %d\\n\", ans1[N], ans2[N]);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint N;\nint dp[1000001], dpodd[1000001];\n\nint main() {\n\n\t//前計算でdpテーブルを計算。8sもあるのでオーダーは怪しいけど大丈夫のはず\n\n\tfor (int i = 0; i <= 1000000; i++)dp[i] = 1145141919, dpodd[i] = 1145141919;\n\n\tdp[0] = 0, dpodd[0] = 0;\n\tfor (int i = 1; i <= 180; i++) {\n\t\tint cur = i * (i + 1) * (i + 2) / 6;\n\t\tfor (int j = cur; j <= 1000000; j++) {\n\t\t\tif (i % 2 == 1) {\n\t\t\t\tdpodd[j] = min(dpodd[j], dpodd[j - cur] + 1);\n\t\t\t}\n\n\t\t\tdp[j] = min(dp[j], dp[j - cur] + 1);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tcout << dp[N] << \" \" << dpodd[N] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,x,n) for(int i=(x);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define int long long\nusing namespace std;\nconst int MOD=1e9+7;\nconst int INF=1e10;\ntemplate<typename T> void cmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\nvector<int> dp(1e6+1,INF),DP(1e6+1,INF);\nsigned main(){\n  vector<int> a,odd;\n  loop(i,1,1e6+1){\n    int tmp=i*(i+1)*(i+2)/6;\n    if(1e6<tmp)break;\n    a.push_back(tmp);\n    if(tmp%2)odd.push_back(tmp);\n  }\n  dp[0]=DP[0]=0;\n  rep(i,1e6+1){\n    rep(j,a.size())if(i+a[j]<=1e6)cmin(dp[i+a[j]],dp[i]+1);\n    rep(j,odd.size())if(i+odd[j]<=1e6)cmin(DP[i+odd[j]],DP[i]+1);\n  }\n\n  int n;\n  while(cin>>n,n){\n    cout<<dp[n]<<' '<<DP[n]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint N;\n\tint v[200];\n\tstatic int ansA[1000000], ansB[1000000];\n\tfor (int i = 0; i<=200; i++) v[i] = i * (i + 1)*(i + 2) / 6;\n\tansA[0] = ansB[0] = 0;\n\tfor (int i = 1; i<1000000; i++) {\n\t\tansA[i] = ansB[i] = i;\n\t\tfor (int j = 0; i - v[j] >= 0; j++) {\n\t\t\tansA[i] = min(ansA[i], A[i - v[j]] + 1);\n\t\t\tif (v[j] % 2 == 1)\n\t\t\t\tansB[i] = min(ansB[i], ansB[i - v[j]] + 1);\n\t\t}\n\t}\n\twhile (cin >> N, N)\n\t\tcout << ansA[N] << \" \" << ansB[N] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<queue>\n#include <algorithm>\n#include<functional>\n#include<cstdlib>\n#include<cmath>\n\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define CI cin >>\n#define CO cout <<\n#define E << endl;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long, long> LP;\ntypedef pair<int, P> PP;\ntypedef pair<long, LP> LPP;\n\n\n\nint dy[] = { 0, 0, 1, -1, 0 };\nint dx[] = { 1, -1, 0, 0, 0 };\n\n\nlong int dp[190][1000010] = { 0 };\nlong int dpodd[190][1000010] = { 0 };\n\n\nlong int N = 0;\nlong int C[191];\nlong int Codd[51];\n\nvoid input(void) {\n\tCI N;\n\n\treturn;\n}\n\n\nint main(void) {\n\tlong int C_N;\n\tfor (int i = 1; i <= 190;i++) {\n\t\tC[i - 1] = i * (i + 1) * (i + 2) / 6;\n\t}\n\tlong int ii = 1, jj = 0;\n\twhile (true) {\n\t\tif (ii * (ii + 1) * (ii + 2) / 6 > 1000000) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((ii * (ii + 1) * (ii + 2) / 6) % 2 == 1) {\n\t\t\tCodd[jj] = ii * (ii + 1) * (ii + 2) / 6;\n\t\t\tjj++;\n\t\t}\n\t\tii++;\n\t}\n\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdp[0][i] = 1001000;\n\t}\n\tfor (long int i = 1; i <= N; i++) {\n\t\tdpodd[0][i] = 1001000;\n\t}\n\n\tfor (long int j = 1; j <= 189; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < C[j - 1]) {\n\t\t\t\tdp[j][i] = dp[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[j][i] = min(dp[j - 1][i], dp[j][i - C[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (long int j = 1; j <= 50; j++) {\n\t\tfor ( long int i = 1; i <= 1000002; i++) {\n\t\t\tif (i < Codd[j - 1]) {\n\t\t\t\tdpodd[j][i] = dpodd[j - 1][i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpodd[j][i] = min(dpodd[j - 1][i], dpodd[j][i - Codd[j - 1]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tinput();\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 190; i++) {\n\t\t\tif (C[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\n\t\t\n\n\t\tCO dp[C_N][N] << \" \";\n\n\t\t\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tif (Codd[i] > N) {\n\t\t\t\tC_N = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tCO dpodd[C_N][N] E\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 1<<28\nusing namespace std;\n\nint p[1111111];\nint memo[1111111];\nint memo2[1111111];\n\nint solve(int n){\n  \n  if(!n) return 0;\n  if(memo[n]) return memo[n];\n\n  int ans = INF;\n  for(int i=199;i>0;i--) if(n-p[i] >= 0) ans = min(ans, solve(n-p[i])+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(memo2[n]) return memo2[n];\n\n  int ans = INF;\n  for(int i=199;i>0;i--) if(n-p[i] >= 0 && p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n\n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  for(int i=0;i<200;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint func(int m, int p, vector<int> &q){\n\tif(p == -1) return 0;\n\tint d = m / q[p];\n\treturn d + func(m - d * q[p], p-1, q);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tvector<int> a, b;\n\tfor(int i=1; i*(i+1)*(i+2)/6<1e6; ++i){\n\t\tint t = i*(i+1)*(i+2)/6;\n\t\ta.push_back(t);\n\t\tif(t % 2 == 1) b.push_back(t);\n\t}\n//\tfor(int i=0; i<a.size(); ++i)\n//\t\tcout << a[i] << \"\\n\";\n//\tcout << a.size() << \"\\n\";\n//\tcout << b.size() << \"\\n\";\n//\tfor(int i=0; i<b.size(); ++i)\n//\t\tcout << b[i] << \"\\n\";\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) return 0;\n\t\tint x = n, y = n;\n\t\tfor(int i=0; a[i]<=n; ++i)\n\t\t\tx = min(x, func(n, i, a));\n\t\tfor(int i=0; b[i]<=n; ++i)\n\t\t\ty = min(y, func(n, i, b));\n\t\tcout << x << \" \" << y << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nint tetrahedral_number (int n)\n{\n    return (n * (n + 1) * (n + 2)) / 6;\n}\n\n\nconst int MAX_NUM = 1000000;\n\nint* solve_regular_problem ()\n{\n    int* solutions = new int[MAX_NUM + 1];\n\n    std::fill (solutions, solutions + MAX_NUM + 1, MAX_NUM);\n\n    solutions[0] = 0;\n\n    int cnt = 0;\n\n    int i = 1;\n\n    for (int tetra_num = 1; tetra_num < MAX_NUM; tetra_num = tetrahedral_number (++i))\n    {\n\n        for (int j = tetra_num; j < MAX_NUM; j++)\n        {\n            solutions[j] = std::min (solutions[j], solutions[j - tetra_num] + 1);\n        }\n\n    }\n\n    return solutions;\n}\n\nint* solve_odd_problem ()\n{\n    int* solutions = new int[MAX_NUM + 1];\n\n    std::fill (solutions, solutions + MAX_NUM + 1, MAX_NUM);\n\n    solutions[0] = 0;\n\n    \n    int i = 1;\n\n    for (int tetra_num = 1; tetra_num < MAX_NUM; tetra_num = tetrahedral_number(++i))\n    {\n        if (tetra_num % 2 != 0)\n        {\n            for (int j = tetra_num; j < MAX_NUM; j++)\n            {\n                solutions[j] = std::min (solutions[j], solutions[j - tetra_num] + 1);\n            }\n\n        }\n\n    }\n\n    return solutions;\n}\n\nint main ()\n{\n\n    auto solutions = solve_regular_problem ();\n\n    auto odd_solutions = solve_odd_problem ();\n\n    int n = 0;\n    while (std::cin >> n, n != 0)\n    {\n\n        std::cout << solutions[n] << \" \" << odd_solutions[n] << std::endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define chmin(a,b)  a=min(a,b);\n\nusing namespace std;\nint main(void)\n{\n  vector<int> oddp;\n  oddp.assign(2048576,33554432);\n  oddp[0]=0;\n  vector<int> natp;\n  natp.assign(2048576,33554432);\n  natp[0]=0;\n  for(int d=0;d<200;++d){\n    for(int i=0;i<1048576;++i){\n      if(i+d*(d+1)*(d+2)/6>1048576) break;\n      chmin(natp[i+d*(d+1)*(d+2)/6],natp[i]+1);\n      if(d*(d+1)*(d+2)/6%2) chmin(oddp[i+d*(d+1)*(d+2)/6],oddp[i]+1);\n    }\n  }\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    cout << natp[n] << ' ' << oddp[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n#define INF (1<<28)\n\nint dp[2][1000001];\n\nint main() {\n    vector<int> a[2];\n    for(int i=1;; i++) {\n        const int k = i*(i+1)*(i+2)/6;\n        if(k>1000000) break;\n        a[0].push_back(k);\n        if(k%2) a[1].push_back(k);\n    }\n    rep(x, 2) {\n        rep(i, 1000001) dp[x][i] = INF;\n        dp[x][0] = 0;\n        rep(k, a[x].size()) rep(i, 1000001-a[x][k]) {\n            dp[x][i+a[x][k]] = min(dp[x][i+a[x][k]], dp[x][i]+1);\n        }\n    }\n    for(;;) {\n        int n;\n        scanf(\"%d\", &n);\n        if(n==0) return 0;\n        printf(\"%d %d\\n\", dp[0][n], dp[1][n]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1000001];\nint memo2[1000001];\n \nint solve(int n){\n\n  if(!n) return 0;\n  if(memo[n]) return memo[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n; i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(memo2[n]) return memo2[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++){\n    if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n  }\n   \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i+=10000) solve(i), solve2(i);\n   \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing Graph = vector<vector<ll>>;\n#define rep(i, n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++)\n#define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000000L;\n#ifdef __DEBUG\n\n/**\n * For DEBUG\n * https://github.com/ta7uw/cpp-pyprint\n */\n#include \"cpp-pyprint/pyprint.h\"\n\n#endif\n\nvoid solve() {\n    vector<ll> all_target, odd_target;\n    rep2(i, 1, 500) {\n        ll r = (i * (i + 1) * (i + 2)) / 6;\n        if (r % 2) {\n            odd_target.push_back(r);\n        }\n        all_target.push_back(r);\n    }\n    vector<ll> dp1(1e6, INF);\n    vector<ll> dp2(1e6, INF);\n    dp1[0] = 0;\n    dp2[0] = 0;\n    rep(i, 1e6) {\n        for (ll a : all_target) {\n            if (i + a < 1e6) {\n                dp1[i + a] = min(dp1[i + a], dp1[i] + 1);\n            }\n        }\n    }\n    rep(i, 1e6) {\n        for (ll o : odd_target) {\n            if (i + o < 1e6) {\n                dp2[i + o] = min(dp2[i + o], dp2[i] + 1);\n            }\n        }\n    }\n    while (true) {\n        ll n;\n        cin >> n;\n        if (!n) return;\n        cout << dp1[n] << ' ';\n        cout << dp2[n] << '\\n';\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 1000000\n\nint N, pol[MAX], odd[MAX];\n\nint main() {\n\tfor (int i = 0; i < MAX; i++) {\n\t\tpol[i] = MAX;\n\t\todd[i] = MAX;\n\t}\n\n\tpol[0] = odd[0] = 0;\n\n\tfor (int i = 0; i < MAX; i++)\n\t\tfor (int j = 1; j < MAX; j++) {\n\t\t\tint k = j * (j + 1) * (j + 2) / 6;\n\t\t\tif (i + k >= MAX)\n\t\t\t\tbreak;\n\t\t\tpol[i + k] = min(pol[i + k], pol[i] + 1);\n\t\t\tif ((k & 1) == 1)\n\t\t\t\todd[i + k] = min(odd[i + k], odd[i] + 1);\n\t\t}\n\n\twhile (1) {\n\t\tscanf(\"%d\", &N);\n\t\tif (N == 0)\n\t\t\treturn 0;\n\t\tprintf(\"%d %d\\n\", pol[N], odd[N]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n\n//FILE *in = freopen(\"C\", \"r\", stdin);\n\nint data[] = {1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286, 364, 455, 560, 680, 816, 969, 1140, 1330, 1540, 1771, 2024, 2300, 2600, 2925, 3276, 3654, 4060, 4495, 4960, 5456, 5984, 6545, 7140, 7770, 8436, 9139, 9880, 10660, 11480, 12341, 13244, 14190, 15180, 16215, 17296, 18424, 19600, 20825, 22100, 23426, 24804, 26235, 27720, 29260, 30856, 32509, 34220, 35990, 37820, 39711, 41664, 43680, 45760, 47905, 50116, 52394, 54740, 57155, 59640, 62196, 64824, 67525, 70300, 73150, 76076, 79079, 82160, 85320, 88560, 91881, 95284, 98770, 102340, 105995, 109736, 113564, 117480, 121485, 125580, 129766, 134044, 138415, 142880, 147440, 152096, 156849, 161700, 166650, 171700, 176851, 182104, 187460, 192920, 198485, 204156, 209934, 215820, 221815, 227920, 234136, 240464, 246905, 253460, 260130, 266916, 273819, 280840, 287980, 295240, 302621, 310124, 317750, 325500, 333375, 341376, 349504, 357760, 366145, 374660, 383306, 392084, 400995, 410040, 419220, 428536, 437989, 447580, 457310, 467180, 477191, 487344, 497640, 508080, 518665, 529396, 540274, 551300, 562475, 573800, 585276, 596904, 608685, 620620, 632710, 644956, 657359, 669920, 682640, 695520, 708561, 721764, 735130, 748660, 762355, 776216, 790244, 804440, 818805, 833340, 848046, 862924, 877975, 893200, 908600, 924176, 939929, 955860, 971970, 988260, 1004731};\nint data2[] = {1, 35, 165, 455, 969, 1771, 2925, 4495, 6545, 9139, 12341, 16215, 20825, 26235, 32509, 39711, 47905, 57155, 67525, 79079, 91881, 105995, 121485, 138415, 156849, 176851, 198485, 221815, 246905, 273819, 302621, 333375, 366145, 400995, 437989, 477191, 518665, 562475, 608685, 657359, 708561, 762355, 818805, 877975, 939929, 1004731};\n\nint n;\nint d1[1000010];\nint d2[1000010];\n\nvoid process() {\n\tfill(d1, d1 + n + 1 , -1);\n\tfill(d2, d2 + n + 1 , -1);\n\td1[0] = 0;\n\td2[0] = 0;\n\tfor(int i = 0; i < 181; i++) {\n\t\tfor(int j = data[i]; j <= n; j++) {\n\t\t\tif(d1[j - data[i]] != -1) {\n\t\t\t\tif(d1[j] == -1 || d1[j] > d1[j-data[i]] + 1) {\n\t\t\t\t\td1[j] = d1[j-data[i]] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < 46; i++) {\n\t\tfor(int j = data2[i]; j <= n; j++) {\n\t\t\tif(d2[j - data2[i]] != -1) {\n\t\t\t\tif(d2[j] == -1 || d2[j] > d2[j-data2[i]] + 1) {\n\t\t\t\t\td2[j] = d2[j-data2[i]] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\", d1[n], d2[n]);\n}\n\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tprocess();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<string>\n#include<cassert>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i);\n\nusing namespace std;\n\nint cnt1[1000100], cnt2[1000100];\n\nint main() {\n\tvector<int> nums;\n\n\tint a = 2, c = 1, num = 1;\n\n\twhile (num < 1000100) {\n\t\tnums.push_back(num);\n\t\tc += a;\n\t\t++a;\n\t\tnum += c;\n\t}\n\n\trep(j,nums.size()) {\n\t\tcnt1[nums[j]] = 1;\n\t\tif (nums[j] % 2) cnt2[nums[j]] = 1;\n\t}\n\n\tREP(i,1,1000100) {\n\t\trep(j,nums.size()) {\n\t\t\tif (i - nums[j] <= 0) break;\n\n\t\t\tif (cnt1[i] == 0) cnt1[i] = cnt1[i - nums[j]] + 1;\n\t\t\telse cnt1[i] = min(cnt1[i], cnt1[i - nums[j]] + 1);\n\n\t\t\tif (nums[j] % 2) {\n\t\t\t\tif (cnt2[i] == 0) cnt2[i] = cnt2[i - nums[j]] + 1;\n\t\t\t\telse cnt2[i] = min(cnt2[i], cnt2[i - nums[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << cnt1[n] << \" \" << cnt2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nconst int N = 1000;\nconst int M = 1000010;\n\nint a[N], dp[M] = {}, dp1[M] = {};\n\nvoid prepare()\n{\n    rep(i, N) a[i] = 1;\n    rep(i, N - 1) a[i + 1] += a[i];\n    rep(i, N - 1) a[i + 1] += a[i];\n    rep(i, N - 1) a[i + 1] += a[i];\n\n    repi(i, 1, M) dp[i] = dp1[i] = M;\n\n    rep(i, N) {\n        if (a[i] >= M) break;\n        for (int j = a[i]; j < M; ++j) {\n            dp[j] = min(dp[j], dp[j - a[i]] + 1);\n            if (a[i] & 1) dp1[j] = min(dp1[j], dp1[j - a[i]] + 1);\n        }\n    }\n}\n\nint main()\n{\n    prepare();\n\n    int n;\n    while (cin >> n and n) {\n        cout << dp[n] << ' ' << dp1[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[200],b[200],c[1000001]={0,1,2,3},d[1000001],k=0,i,j,n;\n  for(i=1;i<200;i++)a[k++]=i*(i+1)*(i+2)/6;\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n  for(i=1;i<195;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-2;i++)for(j=b[i];j<b[i+1];j++)d[j]=d[j-b[i]]+1;\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,x,n) for(int i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD (1000000007)\n#define INF (1e9)\n#define INFL (1e18)\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>using arr=vector<vector<T>>;\ntemplate<class T>int popcount(T &a){int c=0; rep(i, 8*(int)sizeof(a)){if((a>>i)&1) c++;} return c;}\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} pr(a[a.size()-1]);}\ntemplate<class T>void prarr(arr<T>& a){rep(i, a.size()) if(a[i].empty()) pr(\"\"); else prvec(a[i]);}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define N 1000000\n// #define N 200\nint main()\n{\n    int n;\n    vector<int> p, q;\n    int k=1;\n    while(1){\n        int a = k*(k+1)*(k+2)/6;\n        if(a>N) break;\n        p.push_back(a);\n        if(a&1) q.push_back(a);\n        k++;\n    }\n    \n    vector<int> dp(N+1), dq(N+1);\n    rep(i, N+1){\n        dp[i] = i;\n        dq[i] = i;\n    }\n    FOR(i, 1, p.size()){\n        // prvec(dp);\n        FOR(j, p[i], N+1){\n            chmin(dp[j],dp[j-p[i]] + 1);\n        }\n        // pr(dp[40]);\n    }\n    \n    FOR(i, 1, q.size()){\n        FOR(j, q[i], N+1){\n            chmin(dq[j], dq[j-q[i]] + 1);\n        }\n    }\n    // prvec(p);\n    while(cin >> n){\n        if(n==0) break;\n        printf(\"%d %d\\n\", dp[n], dq[n]);\n    }\n    return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\n#define MAX 1000000\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tVI triangular, tetrahedral;\n\n\tint tmp = 0;\n\tFOR (i, 1, MAX) {\n\t\tIFB(tmp > MAX);\n\t\ttriangular.PB(tmp += i);\n\t}\n\ttmp = 0;\n\tEACH (triangular, it) {\n\t\tIFB(tmp > MAX)\n\t\ttetrahedral.PB(tmp += *it);\n\t}\n\n\tVI ans(MAX + 1), ans_odd(MAX + 1);\n\tFOR (i, 1, MAX + 1) {\n\t\tans[i] = ans_odd[i] = i;\n\t\tfor (int j = 0; i - tetrahedral[j] >= 0; ++j) {\n\t\t\tans[i] = min(ans[i], ans[i - tetrahedral[j]] + 1);\n\t\t\tif (tetrahedral[j] % 2) {\n\t\t\t\tans_odd[i] = min(ans_odd[i], ans_odd[i - tetrahedral[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tint n;\n\twhile (cin >> n, n) {\n\t\tcout << ans[n] << ' ' << ans_odd[n] << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[1000000];\nint dpodd[1000000];\nint num[200];\nint INF = 10000000;\nint main(){\n\tfor(int i = 0; i < 200; i++){\n\t\tnum[i] = (i + 1) * (i + 2) * (i + 3)/ 6;\n\t}\n\tdp[0] = 0;\n\tdpodd[0] = 0;\n\tfor(int i = 1; i < 1000000; i++){\n\t\tdp[i] = INF;\n\t\tdpodd[i] = INF;\n\t\tfor(int j = 0; num[j] <= i; j++){\n\t\t\tdp[i] = min(dp[i], dp[i - num[j]] + 1);\n\t\t\tif(num[j] % 2 == 1){\n\t\t\t\tdpodd[i] = min(dpodd[i], dpodd[i - num[j]] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tint N;\n\twhile(cin >> N, N){\n\t\tcout << dp[N] << \" \" << dpodd[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\n#define MIN(X,Y) ((X)<(Y) ? (X) : (Y))\n\nshort tbl[2000000], otbl[2000000];\n\nint main(void) {\n    memset(tbl,0x7F, sizeof(tbl));\n    memset(otbl,0x7F, sizeof(otbl));\n\n    for(int i=1; i*i*i<1050000; i++)\n        tbl[i*(i+1)*(i+2)/6] = 1;\n    for(int i=1; i<1005000; i++)\n        for(int j=1; i-j*(j+1)*(j+2)/6>0; j++)\n            tbl[i] = MIN(tbl[i], 1+tbl[i-j*(j+1)*(j+2)/6]);\n\n    for(int i=1; i*i*i<1050000; i+=4)\n        otbl[i*(i+1)*(i+2)/6] = 1;\n    for(int i=1; i<1005000; i++)\n        for(int j=1; i-j*(j+1)*(j+2)/6>0; j+=4)\n            otbl[i] = MIN(otbl[i], 1+otbl[i-j*(j+1)*(j+2)/6]);\n\n    while(1) {\n        int n;\n        scanf(\"%d\",&n);\n        if(!n) break;\n        printf(\"%d %d\\n\",tbl[n],otbl[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint a;\nint tetra[202];\nint normal[1000002];\nint odd[1000002];\nvector<int>vec;\nint main(){\n\tfor (int i=1;i<=1000000;i++){\n\t\tnormal[i] = 2123123;\n\t\todd[i] = 2123123;\n\t}\n\tfor (int i=1;i<=200;i++){\n\t\ttetra[i] = i * (i+1) * (i+2) / 6;\n\t\tif (tetra[i]%2)vec.push_back(tetra[i]);\n\t}\n\tfor (int j=1;j<=200;j++){\n\t\tfor (int i=tetra[j];i<=1000000;i++){\n\t\t\tnormal[i] = min(normal[i-tetra[j]]+1, normal[i]);\n\t\t}\n\t}\n\tfor (int j=0;j<vec.size();j++){\n\t\tfor (int i=vec[j];i<=1000000;i++){\n\t\t\todd[i] = min(odd[i-vec[j]]+1, odd[i]);\n\t\t}\n\t}\n\twhile(scanf(\"%d\", &a)!=EOF){\n\t\tif (a == 0) return 0;\n\t\tprintf(\"%d %d\\n\", normal[a], odd[a]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  int a[190]={0},b[50]={0},c[1000001]={0,1,2,3},d[10001],k=0,i,j,n;\n\n  for(i=1;i<191;i++)a[k++]=i*(i+1)*(i+2)/6;\n\n  for(j=k=0;j<i;j++)if(a[j]%2)b[k++]=a[j];\n\n  for(i=1;i<189;i++)for(j=a[i];j<a[i+1];j++)c[j]=c[j-a[i]]+1;\n\n  for(i=0;i<36;i++)d[i]=i;\n  for(i=1;i<k-1;i++)for(j=b[i];j<b[i+1];j++)d[j]=c[j-b[i]]+1;\n\n  while(cin>>n,n)cout<<c[n]<<' '<<d[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main() {\n    for(int i = 1;i <= MAX;i++) {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n + 2) / 6 <= MAX;n++) {\n        int a = n * (n + 1) * (n + 2) / 6;\n        for(int i = a;i <= MAX;i++) {\n            dp1[i] = min(dp1[i],dp1[i - a] + 1);\n        }\n        if(a % 2 == 0)continue;\n        for(int i = a;i <= MAX;i++) {\n            dp2[i] = min(dp2[i],dp2[i - a] + 1);\n        }\n    }\n\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n  cerr << endl;\n  rep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n    if (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n      cerr << \"INF\";\n    } else\n      cerr << v[i][j];\n    cerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n  }\n  cerr << endl;\n}\n/*\n   typedef __int128_t Int;\n   std::ostream &operator<<(std::ostream &dest, __int128_t value) {\n   std::ostream::sentry s(dest);\n   if (s) {\n   __uint128_t tmp = value < 0 ? -value : value;\n   char buffer[128];\n   char *d = std::end(buffer);\n   do {\n   --d;\n *d = \"0123456789\"[tmp % 10];\n tmp /= 10;\n } while (tmp != 0);\n if (value < 0) {\n --d;\n *d = '-';\n }\n int len = std::end(buffer) - d;\n if (dest.rdbuf()->sputn(d, len) != len) {\n dest.setstate(std::ios_base::badbit);\n }\n }\n return dest;\n }\n\n __int128 parse(string &s) {\n __int128 ret = 0;\n for (int i = 0; i < s.length(); i++)\n if ('0' <= s[i] && s[i] <= '9')\n ret = 10 * ret + s[i] - '0';\n return ret;\n }\n */\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nsigned main(signed argc, char *argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int M = 1e6 + 10;\n  vector<int> dp(M, INF);\n  vector<int> dp2(M, INF);\n  dp2[0] = dp[0] = 0;\n  rep(i, 1, M) {\n    for (int n = 1, x = 1; x <= i;) {\n      chmin(dp[i], dp[i - x] + 1);\n      if (x & 1) {\n        chmin(dp2[i], dp2[i - x] + 1);\n      }\n      n++;\n      x = n * (n + 1) * (n + 2) / 6;\n    }\n  }\n\n  int x;\n  while (cin >> x, x) {\n    cout << dp[x] << \" \" << dp2[x] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main(){\n  int lim = 1e6;\n  vector<int> cube;\n  for(int i=1;;i++){\n    int c = i*(i+1)*(i+2)/6;\n    if(c>lim)break;\n    cube.push_back(c);\n  }\n\n  vector<int> dp1(lim+1,INF), dp2(lim+1,INF);\n  dp1[0] = dp2[0] = 0;\n\n  for(int i=0;i<=lim;i++){\n    for(int c : cube){\n      if(i+c<=lim){\n\tdp1[i+c] = min(dp1[i+c], dp1[i]+1);\n\tif(c%2==1){\n\t  dp2[i+c] = min(dp2[i+c], dp2[i]+1);\n\t}\n      }\n    }\n  }\n\n  int n;\n  while(cin >> n){\n    if(n==0)break;\n    cout << dp1[n] << \" \" << dp2[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int  N = 1000100;\n\nint t1[200];\nint t2[200];\nint dp1[N] = {0};\nint dp2[N] = {0};\n\nint main(){\n\tint i,j,k=2,s;\n\t\n\tt1[1] = t2[1] = 1;\n\tdp1[1] = dp2[1] = 1;\n\tfor(i = 2; i < N; i++){\n\t\tt1[i] = t1[i-1] * (i+2) / (i-1);\n\t\tif(t1[i] > N) break;\n\t\tdp1[t1[i]] = 1;\n\t\tif(t1[i]%2){ dp2[t1[i]] = 1; t2[k++] = t1[i];}\n\t}\n\n\tfor(i = 2; i < N; i++){\n\t\tif(dp2[i]) continue;\n\t\tfor(j = 1; t2[j] < i; j++){\n\t\t\tif(!dp2[i] || (1 + dp2[i-t2[j]]) < (dp2[i])){\n\t\t\t\tdp2[i] = 1 + dp2[i-t2[j]];\n\t\t\t}\n\t\t}\n\t\tif(dp1[i]) continue;\n\t\tfor(j = 1; t1[j] < i; j++){\n\t\t\tif(!dp1[i] || (1 + dp1[i-t1[j]]) < (dp1[i])){\n\t\t\t\tdp1[i] = 1 + dp1[i-t1[j]];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(cin >> s, s)\n\t\tcout << dp1[s] << ' ' << dp2[s] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\n  int a[200]={},dp1[1000010],dp2[1000010];\n  for(int i=1;i<200;i++) a[i]=i*(i+1)*(i+2)/6;\n  for(int i=0;i<1000000;i++) dp1[i]=dp2[i]=i;\n  for(int i=2;i<200;i++) for(int j=0;j<1000000;j++) if(j+a[i]<1000000) dp1[j+a[i]]=min(dp1[j+a[i]],dp1[j]+1);\n  for(int i=2;i<200;i++) if(a[i]%2) for(int j=0;j<1000000;j++) if(j+a[i]<1000000) dp2[j+a[i]]=min(dp2[j+a[i]],dp2[j]+1);\n  for(int n;cin>>n,n;) cout<<dp1[n]<<\" \"<<dp2[n]<<endl;\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define MAXNUM 10000\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM];\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//1からMAXまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four>MAXNUM)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define SIZE 1000000\nusing namespace std;\nint l[SIZE+1]={0};\nint m[SIZE+1]={0};\n\nint main(){\n    int i,n,a=1,b=1,c=1;\n    for(i=1;i<SIZE+1;i++){\n        l[i]=i;\n        m[i]=i;\n    }\n    while(b<SIZE){\n        for(i=0;i+b<SIZE+1;i++){\n            l[i+b]=min(l[i+b],l[i]+1);\n            if(b%2){m[i+b]=min(m[i+b],m[i]+1);}\n        }\n        a+=(c+1);\n        b+=a;\n        c++;\n    }\n    while(1){\n        cin>>n;\n        if(!n){break;}\n        cout<<l[n]<<\" \"<<m[n]<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\nlong long tetra[190];\n\nclass Node{\npublic:\n\tint deep;\n\tint sum;\n\tint num;\n\tNode(int d,int s,int n){\n\t\tdeep=d;\n\t\tsum=s;\n\t\tnum=n;\n\t}\n\tbool operator < (const Node &o) const{\n\t\treturn deep >o.deep;\n\t}\n};\ntypedef queue <Node> Q;\n\nint bfs(int limit){\n\tQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.front();\n\t\tpq.pop();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=182;i++){\n\t\t\tif(cur.sum+tetra[i]>limit)break;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+tetra[i],i));\n\t\t}\n\t}\n\treturn -1;\n}\nint bfs2(int limit){\n\tQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.front();\n\t\tpq.pop();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=182;i++){\n\t\t\tif(cur.sum+tetra[i]>limit)break;\n\t\t\tif(!(tetra[i]%2))continue;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+tetra[i],i));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint\nmain(){\n\ttetra[1]=1;\n\tfor(int i=0;i<=192;i++){\n\t\ttetra[i]=(i*(i+1)*(i+2))/6;\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tint count;\n\t\tif((count=bfs(n))>0){\n\t\t\tcout<<count;\n\t\t}\n\t\tif((count=bfs2(n))>0){\n\t\t\tcout<<\" \"<<count<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\nconst int MAX_N = 1000000;\nconst int INF = (int)1e9;\n\nint main() {\n    vector<int> tetra;\n    for(int i = 1, k; k = i * (i + 1) * (i + 2) / 6, k <= MAX_N; i++) {\n        tetra.push_back(k);\n    }\n\n    vector<int> dp(MAX_N + 1, INF);\n    vector<int> dp2(MAX_N + 1, INF);\n    queue<int> Q;\n    queue<int> Q2;\n    for(int i = 0; i < (int)tetra.size(); i++) {\n        dp[tetra[i]] = 1;\n        Q.push(tetra[i]);\n        if(tetra[i] % 2 == 1) {\n            dp2[tetra[i]] = 1;\n            Q2.push(tetra[i]);\n        }\n    }\n\n    while(Q.empty() == false) {\n        int k = Q.front(); Q.pop();\n        for(int i = 0; i < (int)tetra.size() && k + tetra[i] <= MAX_N; i++) {\n            if(dp[k + tetra[i]] > dp[k] + 1) {\n                dp[k + tetra[i]] = dp[k] + 1;\n                Q.push(k + tetra[i]);\n            }\n        }\n    }\n\n    while(Q2.empty() == false) {\n        int k = Q2.front(); Q2.pop();\n        for(int i = 0; i < (int)tetra.size() && k + tetra[i] <= MAX_N; i++) {\n            if(tetra[i] % 2 == 0) continue;\n            if(dp2[k + tetra[i]] > dp2[k] + 1) {\n                dp2[k + tetra[i]] = dp2[k] + 1;\n                Q2.push(k + tetra[i]);\n            }\n        }\n    }\n\n    for(int N; cin >> N, N > 0; ) {\n        cout << dp[N] << ' ' << dp2[N] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <numeric>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 10007;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\n\nint dp[1001000],dp2[1001000];\nvector<int> pollock, pollock2;\nint main() {\n\tfor (int i = 1;; i++) {\n\t\tLL num = i;\n\t\tnum *= (num + 1)*(num + 2);\n\n\t\tif (num > 1000000)break;\n\n\t\tif (i % 2 == 0)pollock2.emplace_back(num);\n\t\tpollock.emplace_back(num);\n\t}\n\tfor (int i = 0; i < 1000000; i++) {\n\t\tdp[i] = dp2[i] = i;\n\t}\n\tfor (int i = 1; i < pollock.size(); i++) {\n\t\tfor (int j = pollock[i]; j <= 1000000; j++) {\n\t\t\tdp[j] = min(dp[j], dp[j - pollock[i]] + 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < pollock2.size(); i++) {\n\t\tfor (int j = pollock2[i]; j <= 1000000; j++) {\n\t\t\tdp2[j] = min(dp2[j], dp2[j - pollock2[i]] + 1);\n\t\t}\n\t}\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pl;\ntypedef vector<pl> vp;\n#define fore(i,a,b) for(ll i=(a);i<=(b);++i)\n#define rep(i,n) fore(i,0,(n)-1)\n#define rfore(i,a,b) for(ll i=(b);i>=(a);--i)\n#define rrep(i,n) rfore(i,0,(n)-1)\n#define all(x) (x).begin(),(x).end()\nconst ll INF=1001001001;\nconst ll LINF=1001001001001001001;\nconst ll D4[]={0,1,0,-1,0};\nconst ll D8[]={0,1,1,0,-1,-1,1,-1,0};\ntemplate<class T>\nbool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>\nbool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n\n#define MAX 1000000\nvoid solve(){\n    vl a,b;\n    ll v1=0,v2=0,v3=0;\n    while(1){\n        v1++;\n        v2+=v1;\n        v3+=v2;\n        if(v3>MAX)break;\n        a.push_back(v3);\n        if(v3%2)b.push_back(v3);\n    }\n    reverse(all(a));\n    reverse(all(b));\n\n    vl dpA(MAX+1,LINF);\n    dpA[0]=0;\n    rep(i,a.size()){\n        fore(j,a[i],MAX)chmin(dpA[j],dpA[j-a[i]]+1);\n    }\n    vl dpB(MAX+1,LINF);\n    dpB[0]=0;\n    rep(i,b.size()){\n        fore(j,b[i],MAX)chmin(dpB[j],dpB[j-b[i]]+1);\n    }\n    \n    while(1){\n        ll n;cin>>n;\n        if(n==0)return;\n        cout<<dpA[n]<<\" \"<<dpB[n]<<endl;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\n\tint n,table[183];\n\tint* dp = new int[1000000];\n\tint* odd_dp = new int[1000000];\n\n\tfor(int i=0; i < 183; i++)table[i] = i*(i+1)*(i+2)/6;\n\n\tfor(int i=0; i < 1000000; i++){\n\t\todd_dp[i] = 20000000;\n\t\tdp[i] = 20000000;\n\t}\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\n\todd_dp[0] = 0;\n\todd_dp[1] = 1;\n\n\tfor(int i = 2; i < 1000000; i++){\n\t\tfor(int k = 1; table[k] <= i; k++){\n\t\t\tdp[i] = min(dp[i], dp[i-table[k]]+1);\n\t\t\tif(table[k]%2 == 1){\n\t\t\t\todd_dp[i] = min(odd_dp[i],odd_dp[i-table[k]]+1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tprintf(\"%d %d\\n\",dp[n],odd_dp[n]);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define N 1000000\n#define INFINITY 2000000000\nusing namespace std;\nint main(){\n  int n,cpn,data[N],i,cnt,minv,cal,l,s;\n  for(i=1;i<=N;i++) data[i]=(i*(i+1)*(i+2))/6;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    for(i=1;i<=n;i++){\n      if(n<=data[i]){\n\ts=i+1;\n\tbreak;\n      }\n    }\n    cnt=s;\n    cpn=n;\n    minv=INFINITY;\n    l=0;\n    while(cnt){\n      n=cpn;\n      cal=0;\n      for(i=s-l;i>=1;i--){\n\tcal+=n/data[i];\n\tn%=data[i];\n      }\n      minv=min(minv,cal);\n      cnt--;\n      l++;\n    }\n    cout << minv;\n    n=cpn;\n    cnt=s;\n    minv=INFINITY;\n    l=0;\n    while(cnt){\n      n=cpn;\n      cal=0;\n      for(i=s-l;i>=1;i--){\n\tif(data[i]%2==1){\n\t  cal+=n/data[i];\n\t  n%=data[i];\n\t}\n      }\n      minv=min(minv,cal);\n      cnt--;\n      l++;\n    }\n    cout << ' ' << minv << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX + 1], dp2[MAX + 1];\n\nint main()\n{\n    for (int i = 1; i < MAX; i++)\n    {\n        dp1[i] = INF;\n        dp1[i] = INF;\n    }\n    for (int n = 1; n * (n + 1) * (n + 2) <= MAX; n++)\n    {\n        int a = n * (n + 1) * (n + 2);\n        for (int i = a; i < MAX; i++)\n        {\n            dp1[i] = min(dp1[i], dp1[i - a] + 1);\n        }\n        if (a % 2 == 0)\n            continue;\n        for (int i = a; i < MAX; i++)\n        {\n            dp2[i] = min(dp2[i], dp2[i - a] + 1);\n        }\n    }\n\n    while (1)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n            break;\n        cout << dp1[n] << \"\" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n\n#include<iostream>\n#include<fstream>\n\n#define Max_Len 1000000\n\nusing namespace std;\n\nint triCalc(int num){\n\tstatic short int count[Max_Len];\n\tstatic short int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (num / 5 < triNum){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > triCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = triCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint oddCalc(int num){\n\tstatic short int count[Max_Len];\n\tstatic short int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\twhile ((i * (i + 1) * (i + 2) / 6 )% 2 == 0)i--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (i > 0){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > oddCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = oddCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\twhile ((i * (i + 1) * (i + 2) / 6) % 2 == 0)i--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint main(){\n/*\n\tifstream fin;\n\tofstream fout;\n\n\tfin.open(\"input.txt\");\n\tfout.open(\"output.txt\");\n*/\n\tint n;\n\n\n\twhile (true){\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tcout << triCalc(n) << \" \" << oddCalc(n) << endl;\n\t}\n\t\n\n\t//cout << oddCalc(40);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nint main(){\n\tvector<int> tetrahedral, odd_tetrahedral;\n\tfor(int i = 0; ; ++i){\n\t\tint y = i * (i + 1) * (i + 2) / 6;\n\t\tif(y > MAX_N){ break; }\n\t\ttetrahedral.push_back(y);\n\t\tif(y % 2 == 1){ odd_tetrahedral.push_back(y); }\n\t}\n\tvector<int> dp(MAX_N, -1), odd_dp(MAX_N, -1);\n\tdp[0] = odd_dp[0] = 0;\n\tfor(int i = 0; i < MAX_N; ++i){\n\t\tfor(int j = 0; j < tetrahedral.size(); ++j){\n\t\t\tint next = i + tetrahedral[j];\n\t\t\tif(next >= MAX_N){ break; }\n\t\t\tif(dp[next] < 0){\n\t\t\t\tdp[next] = dp[i] + 1;\n\t\t\t}else if(dp[next] > dp[i] + 1){\n\t\t\t\tdp[next] = dp[i] + 1;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < odd_tetrahedral.size(); ++j){\n\t\t\tint next = i + odd_tetrahedral[j];\n\t\t\tif(next >= MAX_N){ break; }\n\t\t\tif(odd_dp[next] < 0){\n\t\t\t\todd_dp[next] = odd_dp[i] + 1;\n\t\t\t}else if(odd_dp[next] > odd_dp[i] + 1){\n\t\t\t\todd_dp[next] = odd_dp[i] + 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tcout << dp[n] << \" \" << odd_dp[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define INF 0x7FFFFFFF\n \nint main(void){\n    int i, j, n, min1,small;\n    int dp[1000000];\n    scanf(\"%d\",&n);\n    while(n != 0){\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(dp[i] < small){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n            if(small > dp[n])\n                small = dp[n];\n        }\n \n        min1 = dp[n];\n        for(i = 0;i <= n;i++)\n            dp[i] = INF;\n        dp[0] = 0;\n        small = INF;\n        for(i = 0;i < n;i++){\n            if(dp[i] < small){\n                for(j = 1;(j * (j + 1) * (j + 2)) / 6 + i <= n;j++){\n                    if(dp[(j * (j + 1) * (j + 2)) / 6 + i] > dp[i] + 1 && j * (j + 1) * (j + 2) / 6 % 2 == 1)\n                        dp[(j * (j + 1) * (j + 2)) / 6 + i] = dp[i] + 1;\n                }\n            }\n            if(small > dp[n])\n                small = dp[n];\n        }\n        printf(\"%d %d\\n\",min1,dp[n]);\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[10000];\n    /*/fill(dp,dp + x+1,100000);\n  \n\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count;j++){\n\tif(i+coin[j]<=x){\n\t  dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x+1;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   */\n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int MAX_N = 182;\nint num[MAX_N];\nVI odd;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  num[0] = 0;\n  for(int i=1;i<MAX_N;++i){\n\tnum[i] = i*(i+1)*(i+2)/6;\n\tif(num[i] % 2 == 1) odd.PB(num[i]); // i % 4 == 1\n  }\n\n  VI pr;\n  REP(i,MAX_N) REP(j,MAX_N)\n\tpr.PB(num[i]+num[j]);\n  SORT(pr);\n  \n  VI dp(1000000+1,123456789);\n  dp[0] = 0;\n  for(int i=1;i<1000000+1;++i){\n\tfor(int j=0;j<SZ(odd);++j){\n\t  if(i < odd[j]) break;\n\t  dp[i] = min(dp[i], dp[i - odd[j]] + 1);\n\t}\n  }\n\n  int N;\n  while(cin>>N,N){\n\tint cnt = 0;\n\tif(*lower_bound(num, num+MAX_N, N) == N) cnt=1;\n\telse if(*lower_bound(ALL(pr), N) == N) cnt=2;\n\telse{\n\t  REP(i,SZ(pr)){\n\t\tint x = N - pr[i];\n\t\tif(x < 0) break;\n\t\tif(*lower_bound(num, num+MAX_N, x) == x){\n\t\t  cnt=3; break;\n\t\t}\n\t\tif(*lower_bound(ALL(pr), x) == x){\n\t\t  cnt=4;\n\t\t}\n\t  }\n\t  if(!cnt) cnt = 5;\n\t}\n\tcout << cnt << \" \" << dp[N] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define MAX 1000000\nint main(){\n  int a[MAX + 1],b[MAX + 1];\n  a[0] = b[0] = 0;\n  for(int i = 1; i < MAX + 1; i++){\n    a[i] = b[i] = i;\n    for(int j = 1;  ; j++ ){\n      int java = j * (j + 1) * (j + 2) / 6;\n      if(i - java < 0) break;\n      a[i] = min( a[i], a[i - java] + 1);\n      if(java & 1) b[i] = min( b[i], b[i - java] + 1);\n    }\n  }\n  int n;\n  while(cin >> n, n){\n    cout << a[n] << \" \" << b[n] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nll MOD = 1e9+7;\n\nll dp[1000010];\nll dp2[1000010];\nint main(void){\n    ll n,i,j,k,h;\n    std::vector<ll> v(200),v2(200);\n    h=0;k=0;\n    for(i=1;(i*(i+1)*(i+2)/6)<=1000000;i++){\n        v[k++]=(i*(i+1)*(i+2)/6);\n        if((i*(i+1)*(i+2)/6)%2)v2[h++]=(i*(i+1)*(i+2)/6);\n    }\n    ll vs = k;\n\n    fill(dp,dp+(1000000+1),1000000);\n        //cout << dp[0][0] << endl;\n    dp[0]=0;\n\n    for(i=1;i<=vs;i++){\n        for(j=v[i-1];j<=1000000;j++){\n            dp[j]=min(dp[j-v[i-1]]+1,dp[j]);\n        }\n    }\n\n    vs = h;\n    fill(dp2,dp2+(1000000+1),1000000);\n    dp2[0]=0;\n    for(i=1;i<=vs;i++){\n        for(j=v2[i-1];j<=1000000;j++){\n            dp2[j]=min(dp2[j-v2[i-1]]+1,dp2[j]);\n        }\n    }\n    while(cin >> n && n){\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include<map>\n#include <list>\n#include <typeinfo>\nusing namespace std;\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long search_use[10000000] = {};\nint dp_left[11000000] = {};\nint dp_right[11000000] = {};\nbool hoge_canuse[10000] = {};\nvoid prepare_for_search() {\n\tfor (int i = 0;i < 200;++i) {\n\t\tsearch_use[i] = (i + 1)*(i + 2)*(i + 3) / 6;\n\t\tif (search_use[i] % 2 == 1) hoge_canuse[i] = true;\n\t}\n}\n\nint main() {\n\tprepare_for_search();\n\tdp_left[0] = 0;\n\tfor (int i = 1;i < 1100000;++i) {\n\t\tint hoge = 9999999,hogehoge = 99999999;\n\t\tfor (int q = 0;i-search_use[q] >= 0;++q) {\n\t\t\thoge = min(hoge, dp_left[i - search_use[q]] + 1);\n\t\t\tif (hoge_canuse[q] == true) hogehoge = min(hogehoge, dp_right[i - search_use[q]] + 1);\n\t\t}\n\t\tdp_left[i] = hoge;\n\t\tdp_right[i] = hogehoge;\n\t}\n\tint ans = 0;\n\twhile(cin >> ans){\n\t\tif (ans == 0) break;\n\t\tcout << dp_left[ans] <<\" \"<<dp_right[ans]<< endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nconst int MAX =1000001;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1,n;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < MAX){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n//   reverse(all(suqnum));\n//   reverse(all(odd));\n  int *dp = new int[tmp+1];\n  int *dp2 = new int[tmp+1];\n  rep(i,suqnum.size()){\n    dp[suqnum[i]] = 1;\n  }\n  rep(i,odd.size()){\n    dp[odd[i]] = 1;\n  }\n  rep(j,suqnum.size()){\n    rep(i,1000000){\n      if(i - suqnum[j] >= 0){\n        if(dp[i] != 0){\n          dp[i] = min(dp[i],dp[i-suqnum[j]]+1);\n        }\n        else{\n          dp[i] = dp[i-suqnum[j]]+1;\n        }\n      }\n    }\n  }\n  rep(j,odd.size()){\n    rep(i,1000000){\n      if(i - odd[j] >= 0){\n        if(dp2[i] != 0){\n          dp2[i] = min(dp2[i],dp2[i-odd[j]]+1);\n        }\n        else{\n          dp2[i] = dp2[i-odd[j]]+1;\n        }\n      }\n    }\n  }\n  while(cin >> n){\n    if(n == 0)break;\n    cout << dp[n] << \" \" << dp2[n]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint num[1000010], num2[1000010];\n\tfor(int i=0; i< 1000010; i++) num[i] = num2[i] = 10e8;\n\tnum[0] = num2[0] = 0;\n\tfor(int j=0; j< 1000010; j++){\n\t\tfor(int i=0; i < 1500; i++){\n\t\t\tint m = i*(i+1)*(i+2)/6;\n\t\t\tif(1000010 <= m+j) continue;\n\t\t\tnum[j+m] = min(num[j]+1, num[j+m]);\n\n\t\t\tif(m == 0) continue;\n\t\t\tif(m%2 == 0) continue;\n\t\t\tnum2[j+m] = min(num2[j]+1, num2[j+m]);\n\t\t}\n\t}\n\tint n;\n\twhile(cin >> n, n){\n\t\tcout << num[n] << \" \" << num2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll tetra(ll num){\n    return ((num) * (num + 1) * (num + 2) / 6);\n}\n//100\nint main() {\n    ll N = 1e6;\n\n    vector<ll> dp(1000001, 1e9);\n    vector<ll> dp_o(1000001, 1e9);\n\n    dp[0] = 0;\n    dp_o[0]= 0;\n\n    for(int i = 1; tetra(i) < 1e6 + 2; i++){\n        for(int j = 0; j <= N; j++){\n            if(j + tetra(i) >= 1e6) break;\n            dp[j + tetra(i)] = min(dp[j + tetra(i)], dp[j] + 1);\n        }\n    }\n\n\n\n    for(int i = 1; tetra(i) < 1e6 + 2; i++){\n        for(int j = 0; j <= N; j++){\n            if(j + tetra(i) >= 1e6) break;\n            if(tetra(i) % 2 ==1) dp_o[j + tetra(i)] = min(dp_o[j +tetra(i)], dp_o[j] + 1);\n        }\n    }\n\n\n    vector<ll> v_ans;\n    vector<ll> v_ans_o;\n\n    while(1){\n        ll num;\n        cin >> num;\n        if(num == 0) break;\n        v_ans.push_back(dp[num]);\n        v_ans_o.push_back(dp_o[num]);\n    }\n\n    for(int i = 0; i < v_ans.size(); i++){\n        cout << v_ans[i] <<\" \"<< v_ans_o[i] << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <cmath>\n#include <numeric>\n#include <iomanip>\n\nusing namespace std;\nint dp[1000000];\nint dp_odd[1000000];\nint main(void){\n  vector <int> nums;\n  for(int i = 1; i * (i + 1) * (i + 2) / 6 < 1000000; i++){\n    nums.push_back(i * (i + 1) * (i + 2) / 6);\n  }\n  for(int i = 0; i < 1000000; i++){\n    dp[i] = INT_MAX;\n    dp_odd[i] = INT_MAX;\n  }\n  dp[0] = 0;\n  dp_odd[0] = 0;\n  for(int i = 1; i < 1000000; i++){\n    for(int j = 0; j < nums.size(); j++){\n      if(i - nums[j] >= 0){\n        dp[i] = min(dp[i], 1 + dp[i - nums[j]]);\n        if(nums[j] % 2 == 1){\n          dp_odd[i] = min(dp_odd[i], 1 + dp_odd[i - nums[j]]);\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  int n;\n  while(true){\n    cin >> n;\n    if(n == 0){\n      break;\n    }\n    cout << dp[n] << \" \" << dp_odd[n] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint INF = (1LL << 30) - 1;\nint MOD = 1e9+7;\nvector<int> V,W;\nint MAX_NUM = 1000000;\nP dp(int N){\n    P ans;\n    vector<int> table(N+1,INF);\n    table[0] = 0;\n    rep(i,0,V.size()){\n        rep(j,0,N+1){\n            if(j - V[i] >= 0)table[j] = min(table[j], table[j - V[i]] + 1);\n        }\n    }\n    ans.first = table[N]; \n    table.assign(N+1,INF);\n    table[0] = 0;\n    rep(i,0,W.size()){\n        rep(j,0,N+1){\n            if(j - W[i] >= 0)table[j] = min(table[j], table[j - W[i]] + 1);\n        }\n    }\n    ans.second = table[N];\n    return ans;\n}\nmain(){\n    for(int i = 1;i * (i + 1) * (i + 2) / 6 <= MAX_NUM;i++){\n        int num = i * (i + 1) * (i + 2) / 6; \n        V.push_back(num);\n        if(i % 4 == 1)W.push_back(num);\n    }\n\n    int N;\n    cin >> N;\n    while(N){\n        auto ans = dp(N);\n        cout << ans.first << \" \" << ans.second << endl;\n        cin >> N;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int MAX = 1000001;\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  vector<int> nums;\n  for (int i = 1; i * (i + 1) * (i + 2) / 6 < MAX; i++) {\n    nums.push_back(i * (i + 1) * (i + 2) / 6);\n  }\n  vector<int> dp_all(MAX, 1 << 30), dp_odd(MAX, 1 << 30);\n  dp_all[0] = 0;\n  dp_odd[0] = 0;\n  for (int x : nums) {\n    for (int i = 1; i < MAX; i++) {\n      if (i - x >= 0) {\n        dp_all[i] = min(dp_all[i], dp_all[i - x] + 1);\n        if (x % 2) dp_odd[i] = min(dp_odd[i], dp_odd[i - x] + 1);\n      }\n    }\n  }\n  int n;\n  while (cin >> n) {\n    if (n == 0) return 0;\n    cout << dp_all[n] << \" \" << dp_odd[n] << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\n\nconst int N = 1000000 + 1;\nll dp[N], dp2[N];\n\nint main() {\n\n    dp[0] = dp2[0] = 0;\n    for (int i=1; i<N; ++i) {\n        dp[i] = dp2[i] = i;\n        for (int n=1;; ++n) {\n            int p = n*(n+1)*(n+2)/6;\n            if (p > i) break;\n            dp[i] = min(dp[i], dp[i-p]+1);\n            if (p%2) {\n                dp2[i] = min(dp2[i], dp2[i-p]+1);\n            }\n        }\n    }\n\n    int n;\n    while (cin >> n and n) {\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(void){\n    int i;\n    int n;\n    int j = 0;\n    int a[84];\n    int b[22];\n    long long t[1000010];\n    for(i = 0; i < 83; i++){\n        a[i] = (i+1)*(i+2)*(i+3)/6;\n        if(a[i] % 2 == 1){\n            b[j] = a[i];\n            j++;\n        }\n    }\n    //cout << a[82] << b[20] << endl;\n    /*for(i = 0; i < 83; i++){\n        cout << \"a[i] = \" << a[i] << endl;\n    }\n    for(i = 0; i < 21; i++){\n        cout << \"b[i] = \" << b[i] << endl;\n    }*/\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 82; i++){\n            for(j = a[i]; j <= n; j++){\n                if(t[j] > t[j - a[i]] + 1){\n                    t[j] = t[j -a[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << \" \";\n\n        for(i = 0; i <= n; i++){\n            t[i] = i;\n        }\n        for(i = 0; i <= 20; i++){\n            for(j = b[i]; j <= n; j++){\n                if(t[j] > t[j - b[i]] + 1){\n                    t[j] = t[j - b[i]] + 1;\n                }\n            }\n        }\n        cout << t[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define rALL(a) (a).rbegin(), (a).rend()\n#define SZ(x) ((int)(x).size())\nusing ll = long long;\nusing P = pair<int, int>;\nusing llP = pair<ll, ll>;\nusing DoP = pair<double, double>;\nconst int di[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int dj[] = {1, 0, -1, 0, 1, -1, 1, -1};\nconst int INF = 1 << 29;\nconst ll INF64 = 1ll << 45;\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\ntemplate <class T>inline bool chmin(T &a, const T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>inline bool chmax(T &a, const T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T>inline void line_out(const vector<T> vec) {\n  int n = SZ(vec);\n  rep(i, n) {\n    cout << vec[i];\n    if(i < n-1) cout << \" \";\n  }\n  cout << endl;\n  return;\n}\n\nstruct mint\n{\n  ll x; // typedef long long ll;\n  mint(ll x = 0) : x((x % mod + mod) % mod) {}\n  mint operator-() const { return mint(-x); }\n  mint &operator+=(const mint a)\n  {\n    if ((x += a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator-=(const mint a)\n  {\n    if ((x += mod - a.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator*=(const mint a)\n  {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const\n  {\n    mint res(*this);\n    return res += a;\n  }\n  mint operator-(const mint a) const\n  {\n    mint res(*this);\n    return res -= a;\n  }\n  mint &operator++()\n  {\n    if ((x += 1) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint &operator--()\n  {\n    if ((x += mod - 1) >= mod)\n      x -= mod;\n    return *this;\n  }\n  mint operator*(const mint a) const\n  {\n    mint res(*this);\n    return res *= a;\n  }\n  mint pow(ll t) const\n  {\n    if (!t)\n      return 1;\n    mint a = pow(t >> 1);\n    a *= a;\n    if (t & 1)\n      a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const\n  {\n    return pow(mod - 2);\n  }\n  mint &operator/=(const mint a)\n  {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const\n  {\n    mint res(*this);\n    return res /= a;\n  }\n};\n\nint main()\n{\n  vector<P> ans;\n  vector<int> dp(1000005, INF), odd_dp(1000005, INF);\n  dp[0] = odd_dp[0] = 0;\n  vector<int> f;\n  vector<int> input;\n  while(true) {\n    int n; cin >> n;\n    if(n == 0) break;\n    input.push_back(n);\n  }\n\n  f.push_back(0);\n  for(int i = 1;;++i) {\n    if((i*(i+1)*(i+2))/6 > 2000000) break;\n    f.push_back((i*(i+1)*(i+2))/6);\n  }\n\n  for(int i = 1; i <= 1000000; ++i) {\n    for(int j = 1;; ++j) {\n      if(i-f[j] < 0) break;\n      chmin(dp[i], dp[i-f[j]]+1);\n      if(f[j]%2==1) chmin(odd_dp[i], odd_dp[i-f[j]]+1);\n    }\n  }\n  for(auto in : input) ans.emplace_back(dp[in], odd_dp[in]);\n  for(auto x : ans) cout << x.first << \" \" << x.second << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = (0); i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define show2(x,y) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) << endl\n#define show3(x,y,z) cout << #x << \" = \" << (x) << \", \" << #y << \" = \" << (y) <<  \", \" << #z << \" = \" << (z) << endl\n#define showv(v) rep(i,v.size()) printf(\"%d%c\", v[i], i==v.size()-1?'\\n':' ')\n#define showv2(v) rep(j,v.size()) showv(v[j])\n#define showt(t,n) rep(i,n) printf(\"%d%c\", t[i], i==n-1?'\\n':' ')\n#define showt2(t,r,c) rep(j,r) showt(t[j],c)\n#define showvp(p) rep(i,p.size()) printf(\"%d %d\\n\", p[i].first, p[i].second)\n#define printv(v) rep(i,v.size()) printf(\"%d\\n\", v[i])\n#define printt(t,n) rep(i,n) printf(\"%d\\n\", t[i])\n#define incl(v,x) (find(all(v),x)!=v.end())\n#define incls(s,c) (s.find(c)!=string::npos)\n#define lb(a,x) distance((a).begin(),lower_bound(all(a),(x)))\n#define ub(a,x) distance((a).begin(),upper_bound(all(a),(x)))\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define bit(n,k) ((n>>k)&1) // nのk bit目\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define SP << \" \" <<\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing vs = vector<string>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing vp = vector<P>;\nusing vt = vector<T>;\nconst int mod = 1000000007;\nconst double EPS = 1e-9;\n//const long double EPS = 1e-14;\nconst int INF = (1<<30)-1;\nconst ll LINF = (1LL<<62)-1;\n#define dame { puts(\"No\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\ninline int in() { int x; cin >> x; return x;}\ninline ll lin() { ll x; cin >> x; return x;}\ninline char chin() { char x; cin >> x; return x;}\ninline string stin() { string x; cin >> x; return x;}\ninline double din() { double x; cin >> x; return x;}\n//template<class T = int> inline T in() { T x; cin >> x; return (x);}\ntemplate<typename T>inline ll suma(const vector<T>& a) { ll res(0); for (auto&& x : a) res += x; return res;}\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nchar itoa(int n) { return n + '0';}\nll gcd(ll a, ll b) { return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b) { return a/gcd(a,b)*b;}\nconst int dx[4] = {1, 0,-1, 0};\nconst int dy[4] = {0, 1, 0,-1};\n\n// dp[i+1][j] = min(dp[i][j-k*t[i]]+k*1|k>=0)\n//            = min(dp[i][j], dp[i][j-k*t[i]]+k*1)|k>=1)\n//            = min(dp[i][j], dp[i][j-(k+1)*t[i]]+(k+1)*1)|k>=0)\n//            = min(dp[i][j], dp[i][j-t[i]-k*t[i]]+k*1+1|k>=0)\n//            = min(dp[i][j], dp[i+1][j-t[i]]+1)\n\nvi t, t2;\nint nt, nt2;\nint dp[1000005];\nint dp2[1000005];\n\nvoid solve(int a) {\n  rep(j,a+5) dp[j] = INF;\n  rep(j,a+5) dp2[j] = INF;\n  dp[0] = 0;\n  dp2[0] = 0;\n  rep(i,nt)rep(j,a+1) {\n    if (j-t[i] >= 0) {\n      dp[j] = min(dp[j], dp[j-t[i]]+1);\n    }\n  }\n  rep(i,nt2)rep(j,a+1) {\n    if (j-t2[i] >= 0) {\n      dp2[j] = min(dp2[j], dp2[j-t2[i]]+1);\n    }\n  }\n}\n\nint main () {\n  rrep(i,200) {\n    int x = i*(i+1)*(i+2)/6;\n    if (x >= (int)1e6) break;\n    t.pb(x);\n    if (x%2 == 1) t2.pb(x);\n  }\n  nt = sz(t);\n  nt2 = sz(t2);\n  solve(1000000);\n  while (true) {\n    int a = in();\n    if (a == 0) break;\n    printf(\"%d %d\\n\", dp[a], dp2[a]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nconst int MAX_N = 1000000;\nconst int INF = 10000000;\n\nint main() {\n  vector<int> simen, odd_simen;\n\n  int n = 1, nv = 1;\n  while (nv <= MAX_N) {\n    simen.push_back(nv);\n    if (nv % 2 == 1) odd_simen.push_back(nv);\n    n++;\n    nv = n*(n+1)*(n+2) / 6;\n  }\n  vector<int> dp(MAX_N + 1, INF);\n  vector<int> odd_dp(MAX_N + 1, INF);\n  dp[0] = odd_dp[0] = 0;\n\n  for (int i = 1; i <= MAX_N; i++) {\n    for(int j = 0; j < simen.size(); j++) {\n      if (i < simen[j]) break;\n      dp[i] = min(dp[i], dp[i - simen[j]] + 1);\n    }\n    for(int j = 0; j < odd_simen.size(); j++) {\n      if (i < odd_simen[j]) break;\n      odd_dp[i] = min(odd_dp[i], odd_dp[i - odd_simen[j]] + 1);\n    }\n  }\n\n  while (true) {\n    int m;\n    cin >> m;\n    if (m == 0) break;\n\n    cout << dp[m] << \" \" << odd_dp[m] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<queue>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int,P> Pii;\ntypedef long long int ll;\ntypedef pair<ll,ll> LLP;\nint dx[6] = {1,0,0,-1,1,-1};\nint dy[6] = {0,1,-1,0,1,-1};\n#define INF 100000007\n#define MOD 1000000007\n#define ARRAY_MAX 1000005\n//const ll INF = 1e17;\n\nint dp[ARRAY_MAX];//dp[i]:数字iを作るのに必要な数字の個数\nint dp2[ARRAY_MAX];\nint num[300];\n\nint main(){\n\n\n    REP(i,ARRAY_MAX){\n        dp[i] = dp2[i] = INF;\n    }\n    vector<int> odd;\n    REP(i,200){\n        num[i] = (i+1)*(i+2)*(i+3)/6;\n        if(num[i] % 2 == 1){\n            //奇数\n            odd.push_back(num[i]);\n        }\n    }\n\n    dp[0] = 0;\n    for(int i = 0;i < 200;i++){\n        for(int j = num[i];j < ARRAY_MAX;j++){\n            dp[j] = min(dp[j],dp[j-num[i]]+1);\n        }\n    }\n\n    dp2[0] = 0;//奇数のみ\n    for(int i = 0;i < 200;i++){\n        for(int j = num[i];j < ARRAY_MAX;j++){\n            dp[j] = min(dp[j],dp[j-num[i]]+1);\n        }\n    }\n\n    for(int i = 0;i < odd.size();i++){\n        for(int j = odd[i];j < ARRAY_MAX;j++){\n            dp2[j] = min(dp2[j],dp2[j-odd[i]]+1);\n        }\n    }\n\n    int n;\n    while(cin >> n,n){\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nunsigned int dp[1000010];\nmap<int,int> memo;\nint main(){ _;\n  int n;\n  while(cin>>n,n!=0){\n    REP(i,n+1)dp[i]=-1;\n    dp[0]=0;\n    REP(i,n){\n      for(int j=1;;j++){\n\tint& k=memo[j];\n\tif(k==0) k=j*(j+1)*(j+2)/6;\n\tif(i+k>n) break;\n\telse dp[i+k]=min(dp[i+k],dp[i]+1);\n      }\n    }\n    cout<<dp[n]<<\" \";\n    REP(i,n+1)dp[i]=-1;\n    dp[0]=0;\n    REP(i,n){\n      for(int j=1;;j++){\n\tint& k=memo[j];\n\tif(k==0) k=j*(j+1)*(j+2)/6;\n\tif(((k>>1)<<1)==k) continue;\n\tif(i+k>n) break;\n\telse dp[i+k]=min(dp[i+k],dp[i]+1);\n      }\n    }\n    cout<<dp[n]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <stack>\n#include <map>\n#include <cmath>\n#include <queue>\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\ntypedef unsigned long ll;\n#define MAX_N 1000001\n#define INF 1000000000\n\nint tetrahedron(int num){\n\treturn num*(num+1)*(num+2)/6;\n}\n\n\nint main()\n{\n\tvector<int> dp(MAX_N,INF),oddDp(MAX_N,INF);\n\tdp[0] = oddDp[0] = 0;\n\tint num = 0;\n\tfor(int i = 1; num < MAX_N; i++){\n\t\tnum = tetrahedron(i);\n\t\tfor(int j = num; j < MAX_N; j++){\n\t\t\tdp[j] = min(dp[j],dp[j-num]+1);\n\t\t\tif(num % 2 == 1){\n\t\t\t\toddDp[j] = min(oddDp[j],oddDp[j-num]+1);\n\t\t\t}\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\twhile( n != 0){\n\t\tcout<<dp[n]<<\" \"<<oddDp[n]<<endl;\n\t\tcin>>n;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define repb(i,a,b) for(int i=a;i>=b;i--)\n#define all(a) a.begin(),a.end()\n#define o(a) cout<<a<<endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dp[1000010];\nint dp2[1000010];\n\nsigned main() {\n\tint n;\n\twhile (cin >> n && n) {\n\t\trep(i, 0, 1000010) {\n\t\t\tdp[i] = 10;\n\t\t\tdp2[i] = 10000000;\n\t\t}\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\trep(i, 1, 150) {\n\t\t\tint a = i*(i + 1)*(i + 2) / 6;\n\t\t\tif (a > n) break;\n\t\t\trep(j, 0, n + 1) {\n\t\t\t\tif (j + a > n) break;\n\t\t\t\tdp[j + a] = min(dp[j + a], dp[j] + 1);\n\t\t\t\tif (a % 2 == 0) continue;\n\t\t\t\tdp2[j + a] = min(dp2[j + a], dp2[j] + 1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0;i<(ll)n; ++i)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\nint main() {\n\t//freopen(\"Text.txt\", \"r\", stdin);\n\t\n\tll size = 0;\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i]) {\n\t\t\ti++;\n\t\t\ttable[i] = i*(i + 1)*(i + 2) / 6;\n\t\t}\n\t\tsize = i;\n\t}\n\n\t{\n\t\tpollock[0] = 0;\n\t\tll current_i = 0;\n\t\tREP(i, 1000001) {\n\t\t\tif (i == 0) continue;\n\t\t\tif (table[current_i + 1] == i) {\n\t\t\t\tpollock[i] = 1; current_i++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tll minimum = 1000001;\n\t\t\tfor (ll j = 1; j <= current_i; j += 1) {\n\t\t\t\tminimum = min(pollock[i - table[j]] + 1, minimum);\n\t\t\t}\n\t\t\tpollock[i] = minimum;\n\t\t}\n\t}\n\n\t{\n\t\tdp[0] = 0;\n\t\tll current_i = -3;\n\t\tREP(i, 1000001) {\n\t\t\tif (i == 0) continue;\n\t\t\tif (table[current_i + 4] == i) {\n\t\t\t\tcurrent_i += 4; dp[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tll minimum = 1000001;\n\t\t\tfor(ll j=1; j<=current_i; j+=4) {\n\t\t\t\tminimum = min(dp[i - table[j]]+1, minimum);\n\t\t\t}\n\t\t\tdp[i] = minimum;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long shimen[200];\nlong long dp[1000010];\nlong long dp2[1000010];\nint main () {\n\tlong long N;\n\tfor (long long n = 1; n * n * n < 6000000; n++) {\n\t\tshimen[n] = n * (n + 1) * (n + 2) / 6;\n\t\tN = n;\n\t}\n\t\n\tfor (int i = 1; i < 1000001; i++) {\n\t\tdp[i] = 100000;\n\t\tdp2[i] = 100000;\n\t}\n\tdp[0] = 0;\n\tfor (long long i = 0; i < 1000001; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (shimen[j] + i > 1000001) continue;\n\t\t\tdp[i + shimen[j]] = min(dp[i + shimen[j]], dp[i] + 1);\n\t\t\tif (shimen[j] % 2) {\n\t\t\t\tdp2[i + shimen[j]] = min(dp2[i + shimen[j]], dp2[i] + 1);\n\t\t\t}\n\t\t}\n\t}\n\tcin >> N;\n\twhile (N) {\n\t\tcout << dp[N] << \" \" << dp2[N] << endl;\n\t\tcin >> N;\n\t}\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "/* C ????§????: ?????? */\n#include<bits/stdc++.h>\n#define dump(a) cout << (#a) << (a) << endl\nusing namespace std;\n\n#define MAX_SIZE 2000002\n\n//pollok\nint memo_cnt[MAX_SIZE]; //MAX_SIZE??????\nvector<int> all_pks;\nvector<int> kisu_pks;\n\n//P=pk??????, index=pks????????¨?????´???\nint dfs(const int P, const int &now_index, vector<int> &pks)\n{\n\t//dump(level);\n\tif (P == 0) { return 0; }\n\tif (memo_cnt[P] != -1) { return memo_cnt[P]; } //?????¢????????\\\n\t\n\tint min_depth = INT_MAX;\n\tfor(int i=now_index; i<pks.size(); i++) { //??§?????????\n\t\tint next_P = P-pks[i];\n\t\tif (next_P >= 0) {\n\t\t\tint depth = dfs(next_P, i, pks) + 1; //????????°???????????????cnt???\n\t\t\tmin_depth = min(min_depth,depth); //????°????????????°\n\t\t}\n\t\t//?????????????????´???????¬?\n\t}\n\t//???????????¢???\n\tmemo_cnt[P] = min_depth;\n\t\n\treturn min_depth;\n}\n\nint main() {\n\tint n=1;\n\twhile(true) {\n\t\tint pk = n * (n+1) * (n+2) / 6;\n\t\tif (pk >= MAX_SIZE){ break; }\n\n\t\tall_pks.push_back(pk);\n\t\tif (pk % 2 != 0) { kisu_pks.push_back(pk); }\n\t\tn++;\n\t}\n\treverse(begin(all_pks),end(all_pks));\n\treverse(begin(kisu_pks),end(kisu_pks));\n\n\tint P;\n\twhile(cin >> P) {\n\t\tif (P == 0) { break; }\n\n\t\tint index=0; //\n\t\tint left=0,right=0;\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tleft = dfs(P, 0/*pks???????????????*/, all_pks);\n\n\t\tfor(int i=0; i<MAX_SIZE; i++) { memo_cnt[i] = -1; }\n\t\tright = dfs(P, 0/*pks???????????????*/, kisu_pks);\n\t\tcout << left << \" \" << right << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint INF = (1LL << 30) - 1;\nint MOD = 1e9+7;\nvector<int> V,W;\nint MAX_NUM = 1000000;\nvector<int> table(MAX_NUM);\nP dp(int N){\n    P ans;\n    table.assign(N+1,INF);\n    table[0] = 0;\n    rep(i,0,V.size()){\n        rep(j,0,N+1){\n            if(j - V[i] >= 0)table[j] = min(table[j], table[j - V[i]] + 1);\n        }\n    }\n    ans.first = table[N]; \n    table.assign(N+1,INF);\n    table[0] = 0;\n    rep(i,0,W.size()){\n        rep(j,0,N+1){\n            if(j - W[i] >= 0)table[j] = min(table[j], table[j - W[i]] + 1);\n        }\n    }\n    ans.second = table[N];\n    return ans;\n}\nmain(){\n    for(int i = 1;i * (i + 1) * (i + 2) / 6 <= MAX_NUM;i++){\n        int num = i * (i + 1) * (i + 2) / 6; \n        V.push_back(num);\n        if(i % 4 == 1)W.push_back(num);\n    }\n\n    int N;\n    cin >> N;\n    while(N){\n        auto ans = dp(N);\n        cout << ans.first << \" \" << ans.second << endl;\n        cin >> N;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint dp[2][1000001];\n\nint f(int n)\n{\n    return n * (n + 1) * (n + 2) / 6;\n}\n\nint main()\n{\n    int n;\n    while(cin >> n && n) {\n        for(int k = 0; k < 2; k++)\n            fill(dp[k], dp[k] + 1000001, 1000000);\n        \n        dp[0][0] = dp[1][0] = 0;\n        for(int i = 1; i <= n; i++) {\n            for(int k = 1; ; k++) {\n                int num = f(k);\n                if(i - num >= 0) {\n                    dp[0][i] = min(dp[0][i], dp[0][i - num] + 1);\n                    if((num % 2) == 1) {\n                        dp[1][i] = min(dp[1][i], dp[1][i - num] + 1);\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        cout << dp[0][n] << \" \" << dp[1][n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAXNUM 1000001\n#define INF 1000\nusing namespace std;\n\nint all[MAXNUM + 2], odd[MAXNUM + 2], fourall[1000], fourodd[1000];\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//配列の初期化\n\tfor (int i = 0; i < MAXNUM; i++){\n\t\tall[i] = INF;\n\t\todd[i] = INF;\n\n\t}\n\n\t//1からMAXNUMまでの中に存在する正四面体数を洗い出す．\n\tint now = 0, four, allcounter = 1, oddcounter = 1;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tall[four] = 1;\n\t\tfourall[allcounter++] = four;\n\t\tif (four % 2 == 1){\n\t\t\todd[four] = 1;\n\t\t\tfourodd[oddcounter++] = four;\n\t\t}\n\t\tif (four > MAXNUM * 2)\n\t\t\tbreak;\n\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i < MAXNUM; i++){\n\t\tfor (int j = 1; i > fourall[j]; j++){\n\t\t\tall[i] = min(all[i], 1 + all[i - fourall[j]]);\n\t\t}\n\t\tfor (int j = 1; i > fourodd[j]; j++){\n\t\t\todd[i] = min(odd[i], 1 + odd[i - fourodd[j]]);\n\t\t}\n\t\t\t//cout << i << endl;\n\t}\n\t//cout << \"a\";\n\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n  \nusing namespace std;\n\n#define pi 3.141592653589793\n\nint main()\n{\n\tint result[1000010] = {};\n\tint odd_result[1000010] = {};\n\tfill(result, result + 1000000, 1000000);\n\tfill(odd_result, odd_result + 1000000, 1000000);\n\tint trangular_sum = 0, tetrahedral_sum = 0;\n\tresult[0] = 0;\n\todd_result[0] = 0;\n\tfor(int i = 1; i < 1000001; i++){\n\t\ttrangular_sum += i;\n\t\ttetrahedral_sum += trangular_sum;\n\t\tif(tetrahedral_sum > 1000000) break;\n\t\t// result[trangular_sum] = 1;\n\t\tresult[tetrahedral_sum] = 1;\n\t\tif(tetrahedral_sum % 2 == 1) odd_result[tetrahedral_sum] = 1;\n\t\tfor(int j = tetrahedral_sum + 1; j < 1000001; j++){\n\t\t\tresult[j] = min(result[j], result[j - tetrahedral_sum] + 1);\n\t\t\tif(tetrahedral_sum % 2 == 1) odd_result[j] = min(odd_result[j], odd_result[j - tetrahedral_sum] + 1);\n\t\t}\n\t}\n\tint n;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << result[n] << \" \" << odd_result[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  const int N = 100001;\n  vector<int> full(N);\n  vector<int> odd(N);\n  for(int i = 0; i < N; i++) full[i] = i;\n  for(int i = 0; i < N; i++) odd[i] = i;\n  for(int n = 2; ; n++) {\n    const int t = (n * (n+1) * (n+2))/6;\n    if(t >= N) break;\n    for(int i = 0; i + t < N; i++) {\n      const int k = i + t;\n      if(full[i] + 1 < full[k]) full[k] = full[i] + 1;\n      if(t & 1) {\n        if(odd[i] + 1 < odd[k]) odd[k] = odd[i] + 1;\n      }\n    }\n  }\n  \n  for(int t = 1;; t++) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n    cout << full[n] << \" \" << odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MAX = 1e6;\n\nint main(){\n    vector<int> th(200);\n    for(int i=1; i<=200; i++){\n        th[i] = i*(i+1)*(i+2)/6;\n    }\n    vector<int> dp(MAX, MAX), dp2(MAX, MAX);\n    dp[0]=0; dp2[0]=0;\n    for(int i=0; th[i]<MAX; i++){\n        for(int j=0; j+th[i]<MAX; j++){\n            if(dp[j]+1 < dp[j+th[i]]){\n                dp[j+th[i]] = dp[j]+1;\n            }\n        }\n        if(th[i]%2==0) continue;\n        for(int j=0; j+th[i]<MAX; j++){\n            if(dp2[j]+1 < dp2[j+th[i]]){\n                dp2[j+th[i]] = dp2[j]+1;\n            }\n        }\n    }\n    \n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        cout << dp[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define INF (1<<29)\n\nint N;\nint a[1010],dp[1000010];\n\nvoid make(){\n  int n;\n  for(n = 1; n <= 1000; n++) a[n] = n * (n+1) * (n+2) / 6;\n}\n\nint dfs1(int depth, int v, int cnt){ //cout << depth << ' ' << v << endl;\n  int i, ret = INF;\n\n  if(dp[v] != -1) return dp[v];\n  if(v == 0) return dp[v] = cnt;\n  if(v < 0 || v < a[depth]) return INF;\n\n  int K = (v / a[depth]) + 1;\n  rep(i,K) ret = min(ret, dfs1(depth + 1, v - i*a[depth], cnt + i));\n\n  return dp[v] = ret;\n}\n\nint dfs2(int depth, int v, int cnt){ //cout << depth << ' ' << v << endl;\n  int i, ret = INF;\n\n  if(dp[v] != -1) return dp[v];\n  if(v == 0) return dp[v] = cnt;\n  if(v < 0 || v < a[depth]) return INF;\n  if(a[depth] % 2 == 0) return dfs2(depth + 1, v, cnt);\n\n  int K = (v / a[depth]) + 1;\n  rep(i,K) ret = min(ret, dfs2(depth + 1, v - i*a[depth], cnt + i));\n\n  return dp[v] = ret;\n}\n\nint main(){\n  int i;\n\n  make();\n\n  for(;;){\n    scanf(\"%d\",&N); if(N == 0) break;\n    rep(i,1000010) dp[i] = -1;\n    cout << dfs1(1,N,0) << ' ';\n    rep(i,1000010) dp[i] = -1;\n    cout << dfs2(1,N,0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[1000];//正四面体数\nvector<ll>v;\nll dp[1000000],dp2[1000000];\nint main() {\n\tv.pb(1);\n\tll n,now=1;\n\trep(i, 1000) {\n\t\tss[i] = (ll)i*(i + 1)*(i + 2) / 6;\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 100000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 100000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\t\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], i / v[j] + dp2[i%v[j]]);\n\t\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nint p[1000001];\nint memo[1000001];\nint memo2[1000001];\n\nint solve(int n, int count){\n  \n  if(!n) return 0;\n  if(n <= 0 || !count) return INF;\n  if(memo[n]) return memo[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n; i++) ans = min(ans, solve(n-p[i], count-1)+1);\n  \n  return memo[n] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n;i++){\n    if(!(p[i]%2)) continue;\n    ans = min(ans, solve2(n-p[i])+1);\n  }\n  \n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  for(int i=0;i<=1000000;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i++) solve(i, 5), solve2(i);\n  \n  while(cin >> n, n) cout << solve(n, 5) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> T, T_odd, A(M,INF), odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  odd[0] = 0;\n  T.push_back(1);\n  T_odd.push_back(1);\n  while(t < 1000000){\n    T.push_back(t);\n    if (t%2) T_odd.push_back(t);\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  odd.push_back(M);\n  for(int i = 0; i < T.size(); ++i){\n    for(int j = 1; j <= 5; ++j){\n      for(int k = 0; k < T[i] && k+T[i]*j < M; ++k){\n\tA[k+T[i]*j] = min(A[k+T[i]*j],A[k]+j);\n      }\n    }\n  }\n  for(int i = 0; i < T_odd.size()-1; ++i){\n    for(int j = 1; j < 100; ++j){\n      for(int k = 0; k < T_odd[i] && k+T_odd[i]*j < M; ++k){\n\todd[k+T_odd[i]*j] = min(odd[k+T_odd[i]*j],odd[k]+j);\n      }\n    }\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX = 1000100;\nconst int INF = 1<<29;\n\nint main() {\n    vector<int> dp(MAX, INF), odddp(MAX, INF);\n    dp[0] = odddp[0] = 0;\n    for (int i = 1;; ++i) {\n        int num = i * (i+1) * (i+2) / 6;\n        if (num >= MAX) break;\n        for (int j = num; j < MAX; ++j) {\n            dp[j] = min(dp[j], dp[j-num]+1);\n            if (num & 1) odddp[j] = min(odddp[j], odddp[j-num]+1);\n        }\n    }\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1167&lang=jp\n\n#include<iostream>\n#include<fstream>\n\n#define Max_Len 1000000\n\nusing namespace std;\n\nint triCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (num / 5 < triNum){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > triCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = triCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint oddCalc(int num){\n\tstatic int count[Max_Len];\n\tstatic int triangle[Max_Len];\n\tstatic bool f = true;\n\tif (f){//初期化\n\t\tfor (int i = 0; i < Max_Len; i++)\n\t\t\tcount[i] = triangle[i] = Max_Len;\n\t\tf = false;\n\t}\n\n\tint triNum;\n\n\tint i = 1;\n\twhile (i * (i + 1) * (i + 2) / 6 <= num)i++;\n\ti--;\n\twhile ((i * (i + 1) * (i + 2) / 6 )% 2 == 0)i--;\n\ttriNum = i * (i + 1) * (i + 2) / 6;\n\n\tif (triNum == num)return 1;\n\twhile (i > 0){\n\t\tif (triangle[num - triNum] == Max_Len){\n\t\t\tif (count[num] > oddCalc(num - triNum) + 1)\n\t\t\t\tcount[num] = oddCalc(num - triNum) + 1;\n\t\t}\n\t\telse if (count[num] > triangle[num - triNum] + 1)\n\t\t\tcount[num] = triangle[num - triNum] + 1;\n\n\t\ti--;\n\t\twhile ((i * (i + 1) * (i + 2) / 6) % 2 == 0)i--;\n\t\ttriNum = i * (i + 1) * (i + 2) / 6;\n\t}\n\treturn triangle[num] = count[num];\n}\n\nint main(){\n\tint n;\n\n\twhile (true){\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tcout << triCalc(n) << \" \" << oddCalc(n) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tmemset(dp, 0, sizeof(dp));\n\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=1000000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nll dp[1000001];\n\nconst ll MAX=LONG_MAX;\n\nll pol(ll n){\n\treturn n*(n+1)*(n+2)/6;\n}\n\nll dfs(ll n,bool odd){\n\tif(dp[n]!=MAX){\n\t\treturn dp[n];\n\t}\n\tif(n==0){\n\t\treturn 0;\n\t}\n\tll ret=MAX;\n\tfor(ll j=1,i=pol(j);i<=n;j++,i=pol(j)){\n\t\tif(odd&&(!(i&1)))continue;\n\t\tret=min(ret,dfs(n-i,odd)+1);\n\t}\n\treturn dp[n]=ret;\n}\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tREP(i,1000001){\n\t\t\tdp[i]=MAX;\n\t\t}\n\t\tcout<<dfs(n,false);\n\t\tREP(i,1000001){\n\t\t\tdp[i]=MAX;\n\t\t}\n\t\tcout<<\" \"<<dfs(n,true)<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint main(){\n\t//??£?????¢?????°??¨????????????????\\???°??????????????????????????¨??£??????????????¨???\n\tint sq[200]={0};\n\tint oddsq[200]={0};\n\t//???????????????index?????????\n\tint index=0;\n\tint indexODD=0;\n\t //dp???????????¨??????\n\tint INF=2000000;\n\t\n\tfor(int i=0; (i+1)*(i+2)*(i+3)/6<=1000000; ++i){\n\t\tsq[i]=(i+1)*(i+2)*(i+3)/6;\n\t\tif(sq[i]%2==1) oddsq[indexODD++]=sq[i];\t\n\t\t//printf(\"%3d :%7d\\n\",i, sq[i]);\n\t\tindex=i+1;\n\t}\n\t//printf(\"index= %d, inODD = %d\\n\", index, indexODD);\n\t\n\t//solve\n\n\t//dpA[i]:=??°i?????£?????¢?????°????????¨????????¨?????¨?????????????????£?????¢?????°?????°???????°????\t\t\n\tint dpA[1000001];\n\tfill(dpA,dpA+1000001,INF);\n\tdpA[0]=0;\n\t\t\n\tfor(int i=0; i<1000001; ++i){\n\t\tfor(int j=0; j<index; ++j){\n\t\t\tif(i+sq[j]<1000001) dpA[i+sq[j]]=min(dpA[i+sq[j]],dpA[i]+1);\n\t\t\t\telse break;\t\n\t\t}\t\n\t}\n\t\t\n\t//dpB[i]:=??°i?????£?????¢?????°????????¨????????¨?????¨???????????????????\\???°????????£?????¢?????°?????°???????°????\t\t\n\tint dpB[1000001];\n\tfill(dpB,dpB+1000001,INF);\n\tdpB[0]=0;\n\t\t\n\tfor(int i=0; i<1000001; ++i){\n\t\tfor(int j=0; j<indexODD; ++j){\n\t\t\tif(i+oddsq[j]<1000001) dpB[i+oddsq[j]]=min(dpB[i+oddsq[j]],dpB[i]+1);\n\t\t\t\telse break;\t\n\t\t}\t\n\t}\n\t\t\n\twhile(1){\n\t\tint n;\n\t\tscanf(\" %d\", &n);\n\t\tif(n==0) break;\n\t\tprintf(\"%d %d\\n\", dpA[n], dpB[n]);\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nconst int MAX = 1000000;\nint cal(int n) { return n*(n+1)*(n+2)/6; }\nvoid dpru(int* res, const vector<int>& tet)\n{\n\tstatic bool dp[MAX + 1];\n\tclear(dp, 0);\n\tdp[0] = true;\n\tfor (int i = 1, num = 0; num < MAX; ++i)\n\t{\n\t\tfor (int j = MAX; j >= 0; --j)\n\t\t{\n\t\t\tif (!dp[j])\n\t\t\t{\n\t\t\t\tfor (int k = 0; !dp[j] && k < tet.size() && j - tet[k] >= 0; ++k)\n\t\t\t\t\tdp[j] = dp[j - tet[k]];\n\t\t\t\tif (dp[j])\n\t\t\t\t{\n\t\t\t\t\tres[j] = i;\n\t\t\t\t\t++num;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tvector<int> tetra, odd_tetra;\n\tfor (int i = 1; cal(i) <= MAX; ++i)\n\t{\n\t\ttetra.push_back(cal(i));\n\t\tif (cal(i) & 1)\n\t\t\todd_tetra.push_back(cal(i));\n\t}\n\n\tstatic int min_tet[MAX + 1], min_odd_tet[MAX + 1];\n\tdpru(min_tet, tetra);\n\tdpru(min_odd_tet, odd_tetra);\n\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t\tprintf(\"%d %d\\n\", min_tet[n], min_odd_tet[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int lim = 10000;\n    int all[lim];\n    int even[lim];\n    for (int i = 0; i < lim; i++){\n        all[i] = i;\n        even[i] = i;\n    }\n    for (int i = 0; i < 181; i++){\n        int tmp = i * (i + 1) * (i + 2) / 6;\n        if (tmp > lim) break;\n        all[tmp] = 1;\n        if (tmp % 2 == 1)\n            even[tmp] = 1;\n    }\n    for (int i = 2; i < lim; i++){\n        for (int j = 1; j <= i / 2; j++){\n            all[i] = min(all[i], all[j] + all[i-j]);\n            even[i] = min(even[i], even[j] + even[i-j]);\n        }\n    }\n\n    int n;\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n        cout << all[n] << \" \" << even[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <array>\n#include <numeric>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_in(int c){int n=0;bool m=false;if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0');return m?-n:n;} //&&c<='9'\n_in() {return in(gcu());}\n_sc(int &n){int c=gcu();return c==EOF?false:(n=in(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n//_sc(string &s){int c;s=\"\";\n//\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\ntemplate <typename H,typename... T> _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\ntemplate <typename T>\n_vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n//_vo(string &s){for (char c: s) pcu(c);}\ntemplate <typename H,typename... T> _vo(H&& h, T&&... t){out(h);out(move(t)...);}\n//template <typename T> _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);out('\\n');}\n_vl(){out('\\n');}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nenum {N = 1000000};\n\nint main() {\n\tarray<int, N> s1, s2;\n\tiota(s1.begin(), s1.end(), 0);\n\tiota(s2.begin(), s2.end(), 0);\n\tfor (int i = 1, n; (n = i * (i + 1) * (i + 2) / 6) < N; i++) {\n\t\tfor (auto j = s1.begin() + n; j != s1.end(); j++)\n\t\t\t*j = min(*j, *(j - n) + 1);\n\t\tif (n % 2)\n\t\t\tfor (auto j = s2.begin() + n; j != s2.end(); j++)\n\t\t\t\t*j = min(*j, *(j - n) + 1);\n\t}\n\tfor (int n; (n = in());)\n\t\toutl(s1[n], ' ', s2[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define POL_MAX 200\n#define N_MAX 1000000\nusing namespace std;\n\nint N;\nint dp[N_MAX+1];\nconst int INF = INT_MAX / 3;\n\nint solve(vector<int> &my_pol) {\n\trep(j, N+1) { dp[j] = j; }\n\n\tint m = my_pol.size(); \n\tint ans=INF;\t\n\tREP(j, 1, N+1) {\n\t\tREP(i, 1, m) {\n\t\t\tif(j<my_pol[i]) break;\n\t\t\tdp[j] = min(dp[j], dp[j-my_pol[i]] + 1);\n\t\t}\n\t}\n\t\n\treturn dp[N];\n}\n\nint main(){\n\n\tint n=1;\n\tint value=0;\n\tvector<int> pol, kisu_pol;\n\twhile(true) {\n\t\tvalue = n*(n+1)*(n+2) / 6;\n\t\tif (value >= N_MAX) { break; }\n\t\tpol.push_back(value);\n\t\tif (value % 2 != 0) { kisu_pol.push_back(value); }\n\t\tn++;\n\t}\n\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tcout << solve(pol) << \" \" << solve(kisu_pol) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n#define MAX 1000000\n#define INF 1000000000\n\nint dp1[MAX+1],dp2[MAX+2];\n\nint main(){\n    for(int i = 1;i <= MAX;i++){\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n\n    for(int n = 1;n * (n + 1) * (n + 2) / 6 <= MAX;n++){\n        int a = n * (n + 1) * (n + 2) / 6;\n        for(int i = a;i <= MAX;i++){\n            dp1[i] = min(dp1[i],dp2[i - a] + 1);\n        }\n        if(a % 2 == 0)continue;\n        for(int i = a;i <= MAX;i++){\n            dp2[i] = min(dp2[i],dp2[i - a] + 1);\n        }\n    }\n\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0)break;\n        cout << dp1[n] << \" \" << dp2[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1000001];\nint memo2[1000001];\n \nint solve(int n){\n\n  if(!n) return 0;\n  if(memo[n]) return memo[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n; i++) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(memo2[n]) return memo2[n];\n   \n  int ans = INF;\n  for(int i=1;p[i]<=n;i++){\n    if(p[i]&1) ans = min(ans, solve2(n-p[i])+1);\n  }\n   \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  for(int i=0;i<=181;i++) p[i] = i*(i+1)*(i+2)/6;\n  //for(int i=1;i<=1000000;i++) solve(i), solve2(i);\n   \n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;++i)\n#define Rep(i,n) for(int i=1;i<=n;++i)\n#define rrep(i,n) for(int i=n-1;0<=i;--i)\n#define rRep(i,n) for(int i=n;0<i;--i)\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#define EPS 1e-8\n#define INF 1e8\n\ntypedef double Real;\ntypedef int Int;\ntypedef vector<Int> vi;\ntypedef vector<vector<Int> > vvi;\ntypedef pair<Int,Int> pii;\n\ninline Real sr(Real a) {return sqrt(max(a, (Real)0));}\nconst vi dy = {-1, 0, 1, 0}, dx = {0, -1, 0, 1};\n\ntemplate <typename K, typename V> ostream& operator<< (ostream& out, const pair<K, V>& p) {\n  out << '(' << p.first << \", \" << p.second << ')';\n  return out;\n}\n\ntemplate <typename T> ostream& operator<< (ostream& out, const vector<T>& v) {\n  out << '[';\n  rep(i, v.size()) out << v[i] << \",\";\n  out << \"\\b], \" << v.size();\n  return out;\n}\n\nvi tetrahedralNums;\n\ninline int calcTetrahedralNum(int N){\n  return N * (N + 1) * (N + 2) / 6;\n}\n\nint M = 183;\n\nvoid solve(){\n  int N, ansA, ansB;\n  tetrahedralNums.resize(M);\n  rep(i, M) tetrahedralNums[i] = calcTetrahedralNum(i+1);\n\n  vi dp1(1e6+1, INF), dp2(1e6+1, INF);\n  dp1[0] = 0;\n  rep(i, M){\n    int m = tetrahedralNums[i];\n    for(int j = m; j <= 1e6; j++)\n      if(dp1[j] > dp1[j - m] + 1)\n          dp1[j] = dp1[j - m] + 1;\n  }\n\n  dp2[0] = 0;\n  rep(i, M){\n    if(tetrahedralNums[i] % 2 == 0) continue;\n    int m = tetrahedralNums[i];\n    for(int j = m; j <= 1e6; j++)\n      if(dp2[j] > dp2[j - m] + 1)\n          dp2[j] = dp2[j - m] + 1;\n  }\n\n  while(cin >> N && N){\n    cout << dp1[N] << ' ' << dp2[N] << endl;\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(9);\n\n  solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n\nint dp[100001] , dp2[100001];\n\nvector<int> item;\n\nint main(){\n\tint n;\n\tfor(int i = 1 ; i * (i+1) * (i+2) / 6 <= 100000 ; i++) item.push_back(i * (i+1) * (i+2) / 6);\n\trep(i,100001) dp[i] = 9999;\n\trep(i,100001) dp2[i]= 9999;\n\tdp[0] = dp2[0] = 0;\n\n\tfor(int i = 0 ; i <= 100000 ; i++){\n\t\tfor(int j = 0 ; j < item.size() && item[j]+i <= 100000 ; j++){\n\t\t\tdp[i + item[j]] = min(dp[i + item[j]] , dp[i] + 1);\n\t\t}\n\t}\n\tfor(int i = 0 ; i <= 100000 ; i++){\n\t\tfor(int j = 0 ; j < item.size() && item[j]+i <= 100000 ; j++){\n\t\t\tif(item[j] % 2) dp2[i + item[j]] = min(dp2[i + item[j]] , dp2[i] + 1);\n\t\t}\n\t}\n\t\n\twhile(cin >> n && n){\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint a[201];\nint dp1[1000001],dp2[1000001];\nint main(){\n    FOR(i,1,201){\n        a[i-1]=i*(i+1)*(i+2)/6;\n    }\n    int n;\n    while(cin>>n,n){\n        rep(i,n+1) dp1[i]=dp2[i]=1000100010;\n        dp1[n]=0,dp2[n]=0;\n        rep(i,200)for(int j=n;j>=a[199-i];--j){\n            dp1[j-a[199-i]]=min(dp1[j-a[199-i]],dp1[j]+1);\n            if(a[199-i]%2==1) dp2[j-a[199-i]]=min(dp2[j-a[199-i]],dp2[j]+1);\n        }\n        cout<<dp1[0]<<\" \"<<dp2[0]<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\t\n\tint min0[1000000];\n\tint min1[1000000];\n\tfill(min0,min0+1000000,100);\n\tfill(min1,min1+1000000,100);\n\n\tfor(int j=1;j<300;j++){\n\t\tint n = j*(j+1)*(j+2)/6;\n\t\tif( n>=1000000) break;\n\t\tmin0[n] = 1;\n\t\tif((j%2)==1){\n\t\t\tmin1[n] = 1;\n\t\t}\n\t}\n\n\n\tfor(int i=1;i<1000000;i++)\n\t{\n\t\tfor(int j=1;j<300;j++){\n\t\t\tint n = i + j*(j+1)*(j+2)/6;\n\t\t\tif( n>=1000000) break;\n\t\t\tmin0[n] = min( min0[n], min0[i]+1);\n\t\t\tif( (j%2)==1){\n\t\t\t\tmin1[n] = min( min1[n], min1[i]+1);\n\t\t\t}\n\t\t}\n\t}\n\n\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tcout << min0[n] << \" \" << min1[n] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define from_to(from, to, i) for(int i=from;i<=to;i++)\n\nusing namespace std;\ntypedef long long ll;\nconst int MAX = 1000010;\nconst int INF = 1<<29;\n\nint main(int argc, char const* argv[])\n{\n    vector<int> V;\n    for (int i = 1; i*(i+1)*(i+2)/6 < MAX; i++) {\n        V.push_back(i*(i+1)*(i+2)/6);\n    }\n\n    int all[MAX], odd[MAX];\n    fill(all, all+MAX, INF);\n    fill(odd, odd+MAX, INF);\n\n    all[0] = odd[0] = 0;\n    for (int v : V) {\n        loop (v, i) {\n            for (int j = 1; i+v*j < MAX; j++) {\n                all[i+v*j] = min(all[i+v*j], all[i+v*(j-1)] + 1);\n\n                if (v%2) {\n                    odd[i+v*j] = min(odd[i+v*j], odd[i+v*(j-1)] + 1);\n                }\n            }\n        }\n    }\n\n    while (1) {\n        int n; cin >> n;\n        if (!n) break;\n        printf(\"%d %d\\n\", all[n], odd[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX 1000000\nusing namespace std;\nvector<int> box;\nint ans1[MAX+10],ans2[MAX+10];\nvoid tab_make(){\n\tfor(int i=1;i*(i+1)*(i+2)/6<=MAX;i++)\n\t\tbox.push_back(i*(i+1)*(i+2)/6);\n}\nvoid ans_make(){\n\tans1[0]=ans2[0]=0;\n\tfor(int i=1;i<=MAX;i++){\n\t\tans1[i]=ans2[i]=i;\n\t\tfor(int j=0;i-box[j]>=0;j++){\n\t\t\tans1[i]=min(ans1[i],ans1[i-box[j]]+1);\n\t\t\tif(box[j]%2==1)\n\t\t\tans2[i]=min(ans2[i],ans2[i-box[j]]+1);\n\t\t}\n\t}\n}\nint main(){\n\tint x;\n\ttab_make();\n\tans_make();\n\twhile(cin>>x,x){\n\t\tcout<<ans1[x]<<' '<<ans2[x]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n \nusing namespace std;\n \nconst int N=1e6;\n\nint main()\n{\n\n\tvector<int> t;\n\tt.push_back(1);\n\tfor(int i=2;t.back()<=N;i++) t.push_back(i*(i+1)*(i+2)/6);\n\n\tvector<int> ans(N+1,N),ans2(N+1,N);\n\n\tans[0]=ans2[0]=0;\n\n\tfor(int i=0;i<N;i++){\n//\t\tcout<<i<<endl;\n\t\tfor(int j=0;j<t.size() && i+t[j]<=N;j++){\n\t\t\tans[i+t[j]]=min(ans[i+t[j]],ans[i]+1);\n\t\t\tif(t[j]%2) ans2[i+t[j]]=min(ans2[i+t[j]],ans2[i]+1);\n\t\t}\n\t}\n\n//\tcout<<\"ok\"<<endl;\n\n\tlong long n;\n\twhile(cin>>n,n){\n\n\t\tcout<<ans[n]<<\" \"<<ans2[n]<<endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nstatic const int INF = 999999999;\nvector<int> tetrahedral;\nint min_depth;\nint min_odd_depth;\nint n;\n\nvoid DFS(int pos, int depth, int sum)\n{\n\tif(sum == n)\n\t{\n\t\tif(depth < min_depth)\n\t\t{\n\t\t\tmin_depth = depth;\n\t\t}\n\t\treturn;\n\t}\n\telse if(sum > n)\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tDFS(i, depth + 1, sum + tetrahedral[i]);\n\t\t}\n\t}\n}\n\nvoid DFS2(int pos, int depth, int sum)\n{\n\tif(sum == n)\n\t{\n\t\tif(depth < min_odd_depth)\n\t\t{\n\t\t\tmin_odd_depth = depth;\n\t\t}\n\t\treturn;\n\t}\n\telse if(sum > n)\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tif(tetrahedral[i] % 2)\n\t\t\t{\n\t\t\t\tDFS2(i, depth + 1, sum + tetrahedral[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tfor(int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; ++i)\n\t{\n\t\ttetrahedral.push_back(i * (i + 1) * (i + 2) / 6);\n\t}\n\twhile(cin >> n, n)\n\t{\n\t\tmin_depth = INF;\n\t\tmin_odd_depth = INF;\n\t\tint pos = 0;\n\t\twhile(tetrahedral[pos] < n)\n\t\t{\n\t\t\t++pos;\n\t\t}\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tDFS(i, 1, tetrahedral[i]);\n\t\t}\n\t\twhile(tetrahedral[pos] % 2 == 0)\n\t\t{\n\t\t\t--pos;\n\t\t}\n\t\tfor(int i = pos; i >= 0; --i)\n\t\t{\n\t\t\tif(tetrahedral[i] % 2)\n\t\t\t{\n\t\t\t\tDFS2(i, 1, tetrahedral[i]);\n\t\t\t}\n\t\t}\n\t\tcout << min_depth << \" \" << min_odd_depth << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint sum[200] = {0};\nint memo[200][2] = {0};\nint ans[1000005][2] = {0};\nint n, size[2];\n\nvoid setans();\n\nint main() {\n  setans();\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    cout << ans[n][0] << \" \" << ans[n][1] << endl;\n  }\n  return 0;\n}\n\nvoid setans() {\n  size[0] = size[1] = 1;\n  sum[0] = memo[0][0] = memo[0][1] = 1;\n  while(memo[size[0] - 1][0] < 1000000) {\n    sum[size[0]] = sum[size[0] - 1] + size[0] + 1;\n    memo[size[0]][0] = memo[size[0] - 1][0] + sum[size[0]];\n    if(memo[size[0]][0] % 2 == 1)\n      memo[size[1]++][1] = memo[size[0]][0];\n    ++size[0];\n  }\n  --size[1];\n  --size[0];\n  for(int t = 0; t < 2; ++t)\n    for(int i = 1; i < 1000001; ++i) ans[i][t] = 100000000;\n  for(int t = 0; t < 2; ++t)\n    for(int i = 0; i < size[t]; ++i)\n      for(int j = 1; j < 1000001; ++j) {\n        int now = memo[i][t];\n        if(j >= now)\n          ans[j][t] = min(ans[j][t], ans[j - now][t] + 1);\n      }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint a[1010101];\nint b[1010101];\n\nint main(){\n\tfill(a ,a + 1010101,1e9);\n\tfill(b,b + 1010101,1e9);\n\ta[0] = 0;\n\tb[0] = 0;\n\n\tint MAX = 1e6;\n\n\tfor(int i = 1;i <= MAX;i++){\n\t\tint temp;\n\t\tfor(int j = 1;(temp = (j) * (j + 1) * (j + 2) / 6) <= i;j++){\n\t\t\ta[i] = min(a[i] , a[i - temp] + 1);\n\t\t\tif(temp % 2 == 1)\n\t\t\t\tb[i] = min(b[i] , b[i - temp] + 1);\n\t\t}\n\t}\n\n\tint n;\n\twhile(cin >> n , n){\n\t\tcout << a[n] << \" \" << b[n] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n,res =inf;\nconst int MAX = 1000100;\nvector<int> memo(MAX,inf);\nint solve(int a,int b,int c,vector<int> v, int** dp){\n  if(dp[b][a] == 1) return min(memo[a],b);\n  else if(dp[b][a] == -1) return inf;\n  dp[b][a] = -1;\n  if(b == 0) res = inf;\n  if(a == n){\n    res = min(res,b);\n    dp[b][a] = 1;\n    memo[a] = min(memo[a],b);\n    return b;\n  }\n  if(a > n || res < b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v,dp),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < MAX){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    {\n      const size_t s = suqnum.size()*2;\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb1,suqnum,arg) << \" \";\n      rep(i,s) delete[] dp[i];\n    }\n    {\n      const size_t s = odd.size()*2;\n      int **dp = new int*[s];\n      int *arg[s];\n      rep(i,s) dp[i] = new int[MAX];\n      rep(i,s) arg[i] = dp[i];\n      cout << solve(0,0,lb2,odd,arg)<<endl;\n      rep(i,s) delete[] dp[i];\n    }\n//     queue<pii> q;\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb1,suqnum.size()){\n//         if(p.se+suqnum[i] == n){\n//           cout << p.fi+1<< \" \";\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+suqnum[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n//         }\n//       }\n//     }\n//     q.push(make_pair(0,0));\n//     while(!q.empty()){\n//       pii p = q.front();q.pop();\n//       REP(i,lb2,odd.size()){\n//         if(p.se+odd[i] == n){\n//           cout << p.fi+1<< endl;\n//           q = queue<pii>();\n//           break;\n//         }\n//         else if(p.se+odd[i] < n){\n//           q.push(make_pair(p.fi+1,p.se+odd[i]));\n//         }\n//       }\n//     }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nconst int MAX_N = 1e6; \nvector<int>dp1, dp2;\nvector<int>tetra;\n\nint main(void)\n{\n\tint n = 1;\n\tdo\n\t{\n\t\ttetra.push_back(n * (n + 1) * (n + 2) / 6);\n\t\t++n;\n\t} while (tetra.back() <= MAX_N);\n\tdp1.push_back(0);\n\tdp2.push_back(0);\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tint a1 = INT_MAX, a2 = INT_MAX;\n\t\tfor (int t : tetra)\n\t\t{\n\t\t\tif (t > i)break;\n\t\t\ta1 = min(a1, dp1[i - t] + 1);\n\t\t\tif (t % 2)\n\t\t\t{\n\t\t\t\ta2 = min(a2, dp2[i - t] + 1);\n\t\t\t}\n\t\t}\n\t\tdp1.push_back(a1);\n\t\tdp2.push_back(a2);\n\t}\n\tint x;\n\twhile (cin >> x, x)\n\t{\n\t\tcout << dp1[x] << \" \" << dp2[x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint INF = 100000000;\nint main(){\n  int n, M = 1000000;\n  vector<int> T, T_odd, A(M,INF), odd(M,INF);\n  int t = 1, k = 3;\n  A[0] = 0;\n  odd[0] = 0;\n  T.push_back(1);\n  T_odd.push_back(1);\n  while(t < 1000000){\n    T.push_back(t);\n    if (t%2) T_odd.push_back(t);\n    ++k;\n    t *= k;\n    t /= (k-3);\n  }\n  for(int i = 0; i < T.size(); ++i){\n    for(int j = 1; j <= 5; ++j){\n      for(int k = 0; k < T[i] && k+T[i]*j < M; ++k){\n\tA[k+T[i]*j] = min(A[k+T[i]*j],A[k]+j);\n      }\n    }\n  }\n  for(int i = 0; i < T_odd.size(); ++i){\n    for(int j = 1; j < 35; ++j){\n      for(int k = 0; k < T_odd[i] && k+T_odd[i]*j < M; ++k){\n\todd[k+T_odd[i]*j] = min(odd[k+T_odd[i]*j],odd[k]+j);\n      }\n    }\n  }\n  while(cin >> n, n){\n    cout << A[n] << \" \" << odd[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-8;\n\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nint memo[1000001];\n\nint solve(int n, bool skip_even) {\n  if (memo[n] != 0) return memo[n];\n  if (n == 0) return 0;\n  int mini = 1 << 30;\n  for (int i = 1; i*(i+1)*(i+2)/6 <= n; i++) {\n    if (skip_even && i*(i+1)*(i+2)/6 % 2 == 0) continue;\n    mini = min(mini, solve(n-i*(i+1)*(i+2)/6, skip_even) + 1);\n  }\n  return memo[n] = mini;\n}\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int n;\n  while (cin >> n, n) {\n    fill(memo, memo + 1000001, 0);\n    cout << solve(n, false) << \" \";\n    fill(memo, memo + 1000001, 0);\n    cout << solve(n, true) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define rep(i,x) for(int i=0;i<(x);++i)\n#define rep1(i,x) for(int i=1;i<=(x);++i)\n#define rrep(i,x) for(int i=(x)-1;i>=0;--i)\n#define rrep1(i,x) for(int i=(x);i>=1;--i)\n#define FOR(i,a,x) for(int i=(a);i<(x);++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>istream&operator>>(istream&is,vector<T>&vec){rep(i,vec.size())is>>vec[i];return is;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint dp[1000001], dp_odd[1000001];\n\nsigned main()\n{\n    vi tet, tet_odd;\n\n    for (int i = 1; ; ++i) {\n        tet.PB(i * (i + 1) * (i + 2) / 6);\n        if (tet.back() >= 1000000) break;\n    }\n\n    for (int i = 0; i < tet.size(); ++i) {\n        if (tet[i] & 1) tet_odd.PB(tet[i]);\n    }\n\n    for (int i = 1; i <= 1000000; ++i) dp[i] = dp_odd[i] = inf;\n\n    for (int i = 1; i <= 1000000; ++i) {\n        for (int j = 0; j < tet.size(); ++j) {\n            if (i >= tet[j]) {\n                dp[i] = min(dp[i], dp[i - tet[j]] + 1);\n            }\n            if (i < tet[j]) break;\n        }\n\n        for (int j = 0; j < tet_odd.size(); ++j) {\n            if (i >= tet_odd[j]) {\n                dp_odd[i] = min(dp_odd[i], dp_odd[i - tet_odd[j]] + 1);\n            }\n            if (i < tet_odd[j]) break;\n        }\n    }\n\n    int N;\n    while (cin >> N, N) cout << dp[N] << ' ' << dp_odd[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define MP make_pair\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define fst first\n#define snd second\n\n#define INF 1000000;\n\nVi odd;\n\nint t(int x) { return x*(x+1)*(x+2)/6; }\n\nint dfs(int i, int rest) {\n  if (rest == 0) return 0;\n  if (rest < 0) return INF;\n  if (i == 0) return rest;\n\n  return min(dfs(i-1, rest), dfs(i, rest-odd[i]) + 1);\n}  \n\nint main() {\n  ios_base::sync_with_stdio(false);\n\n  Vi one, two;\n  for (int i = 1; t(i) <= 1000000; i++) {\n    one.push_back(t(i));\n    if (t(i)%2) odd.push_back(t(i));\n  }\n\n  for (int a : one) {\n    for (int b : one) {\n      two.push_back(a+b);\n    }\n  }\n  sort(ALL(two));\n\n  while (1) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    if (n == *lower_bound(ALL(one), n)) {\n      cout << 1;\n    } else if (n == *lower_bound(ALL(two), n)) {\n      cout << 2;\n    } else {\n      bool flag = false;\n      for (int a : one) {\n\tif (n - a == *lower_bound(ALL(two), n - a)) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if (flag) {\n\tcout << 3;\n      } else {\n\tfor (int a : two) {\n\t  if (n - a == *lower_bound(ALL(two), n - a)) {\n\t    flag = true;\n\t    break;\n\t  }\n\t}\n\tcout << (flag ? 4 : 5);\n      }\n    }\n\n    cout << ' ' << dfs(lower_bound(ALL(odd), n) - odd.begin(), n) << endl;\n  }    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nint p[1000001];\nint memo[1000001][6];\nint memo2[1000001];\n\nint solve(int n, int count){\n  \n  if(!n) return 0;\n  if(n <= 0 || !count) return INF;\n  if(memo[n][count]) return memo[n][count];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n; i++) ans = min(ans, solve(n-p[i], count-1)+1);\n  \n  return memo[n][count] = ans;\n}\n\nint solve2(int n){\n  \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(memo2[n]) return memo2[n];\n  \n  int ans = INF;\n  for(int i=0;p[i]<=n; i++){\n    if(!(p[i]%2)) continue;\n    ans = min(ans, solve2(n-p[i])+1);\n  }\n  \n  return memo2[n] = ans;\n}\n\nint main(){\n  \n  int n;\n  \n  for(int i=0;i<=1000000;i++) p[i] = i*(i+1)*(i+2)/6;\n  for(int i=1;i<=1000000;i++)  solve2(i);\n  \n  while(cin >> n, n) cout << solve(n, 5) << \" \" << solve2(n) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  vector<int> smt(1,0);\n  vector<int> ksmt(1,0);\n  int a;\n  for(int i=1;i<10000;i++){\n    a=i*(i+1)*(i+2)/6;\n    smt.push_back(a);\n    if(a%2==1)ksmt.push_back(a);\n    if(a>1000000)break;\n    //cout << a << endl;\n  }\n  while(1){\n    //cout <<smt.size()<<\" \"<<ksmt.size()<<endl;\n    int dp[2][1000000]={};\n    \n    //cout <<\"2\"<<endl;\n    int n;\n    cin >> n;\n    int m=0,k=1;\n    if(n==0)break;\n    //\n    for(int i=1;i<=n;i++){\n      dp[0][i]=i;\n    }\n    //all\n    for(int i=1;i<smt.size();i++){\n      if(smt[i]>n){\n\tcout << dp[m][n]<<\" \";\n\tbreak;\n      }\n      for(int j=1;j<=n;j++){\n\tif(smt[i]>j) dp[k][j]=dp[m][j];\n\telse{\n\t  dp[k][j]=min(dp[m][j],dp[k][j-smt[i]]+1);\n\t}\n\t//cout <<dp[k][j]<<\" \";\n      }\n      swap(m,k);\n    }\n    //reset\n    for(int i=1;i<=n;i++){\n      dp[0][i]=i;\n    }\n    m=0,k=1;\n    //kisuu\n    for(int i=1;i<ksmt.size();i++){\n      if(ksmt[i]>n){\n\tcout << dp[m][n]<<endl;\n\tbreak;\n      }\n      for(int j=1;j<=n;j++){\n\tif(ksmt[i]>j) dp[k][j]=dp[m][j];\n\telse{\n\t  dp[k][j]=min(dp[m][j],dp[k][j-ksmt[i]]+1);\n\t}\n      }\n      swap(m,k);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define LET(name, value) __typeof(value) name = value\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for (LET(i, (c).begin()); i != (c).end(); ++i)\n\nconst int M = 181;\nint tetra[M];\nint memo1[1000010];\nint memo2[1000010];\n\nint dfs1(int n) {\n  if (memo1[n] != -1) { return memo1[n]; }\n  if (n == 0) { return memo1[n] = 0; }\n  int ret = 1000000;\n  for (int i = M-1; i >= 0; --i) {\n    if (tetra[i] <= n) {\n      ret = min(ret, dfs1(n-tetra[i])+1);\n    }\n  }\n  return memo1[n] = ret;\n}\n\nint dfs2(int n) {\n  if (memo2[n] != -1) { return memo2[n]; }\n  if (n == 0) { return memo2[n] = 0; }\n  int ret = 1000000;\n  for (int i = M-1; i >= 0; --i) {\n    if (tetra[i] <= n && tetra[i] % 2 == 1) {\n      ret = min(ret, dfs2(n-tetra[i])+1);\n    }\n  }\n  return memo2[n] = ret;\n}\n\nint main() {\n  memset(memo1, -1, sizeof(memo1));\n  memset(memo2, -1, sizeof(memo2));\n\n  int sum = 1;\n  tetra[0] = 1;\n  FOR(i, 1, M) {\n    sum += i+1;\n    tetra[i] = tetra[i-1]+sum;\n  }\n\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    printf(\"%d %d\\n\", dfs1(n), dfs2(n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#define MAXNUM 10000\nusing namespace std;\n\nint all[MAXNUM], odd[MAXNUM];\nset<int> allfour, oddfour;\nint max(int a, int b);\nint min(int a, int b);\nint getall(int n);\nint getodd(int n);\n\nint main()\n{\n\tint n;\n\tint counter = 0;\n\n\t//1からMAXまでの中に存在する正四面体数をsetに入れる．\n\tint now = 0, four;\n\twhile (1){\n\t\tnow++;\n\t\tfour = now  *(now + 1)*(now + 2) / 6;\n\t\tif (four > MAXNUM)\n\t\t\tbreak;\n\t\tallfour.insert(four);\n\t\tif (four % 2 == 1)\n\t\t\toddfour.insert(four);\n\t}\n\n\t//1からMAXNUMまで，配列を埋める.\n\tfor (int i = 1; i <= MAXNUM; i++){\n\t\tall[i] = getall(i);\n\t\todd[i] = getodd(i);\n\t}\n\n\t//入力\n\twhile (cin >> n, n)\n\t\tcout << all[n] << \" \" << odd[n] << endl;\n\n\treturn 0;\n\n}\n\n\n\n\nint max(int a, int b){\n\tif (a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint min(int a, int b){\n\tif (a > b)\n\t\treturn b;\n\telse\n\t\treturn a;\n}\n\nint getall(int n){\n\tset<int>::iterator it = allfour.find(n);\n\tif (it != allfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, all[i] + all[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}\n\nint getodd(int n){\n\tset<int>::iterator it = oddfour.find(n);\n\tif (it != oddfour.end())\n\t\treturn 1;\n\telse{\n\t\tint minnum = 1000;\n\t\tfor (int i = 1; i < n / 2 + 1; i++){\n\t\t\tminnum = min(minnum, odd[i] + odd[n - i]);\n\t\t}\n\t\treturn minnum;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  int v[200];\n  FOR(i,0,200) v[i] = i * (i + 1) * (i + 2) / 6;\n\n  int dp[1000006];\n  FOR(i,0,1000006) dp[i] = 1e9;\n  dp[0] = 0;\n  FOR(i,0,1000006) {\n    FOR(j,0,v.size()) {\n      if(i - v[j] >= 0) dp[i] = min(dp[i], dp[i - v[j]] + 1);\n    }\n  }\n\n  int dp_even[1000006];\n  FOR(i,0,1000006) dp_even[i] = 1e9;\n  dp_even[0] = 0;\n  FOR(i,0,1000006) {\n    FOR(j,0,v.size()) {\n      if(v[j]%2 == 0) continue;\n      if(i - v[j] >= 0) dp_even[i] = min(dp_even[i], dp_even[i - v[j]] + 1);\n    }\n  }\n  while(cin>>n,n) {\n    cout << dp[n] << \" \" << dp_even[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n#define MAX_N 1000000\n\nint N;\nint inf = 1000000000;\n\nint d[MAX_N+1]; // ?????????j??¨?????????????????????????°??????°\n\nint calc_sn(int n){\n\treturn n*(n+1)*(n+2)/6;\n}\n\nvoid solve(){\n\td[0] = 0;\n    for(int i = 1; i <= N; i++){\n    \td[i] = inf;\n       \tfor (int j = 1; ; j++)\n        {\n        \tif(i < calc_sn(j)) break;\n            d[i] = min(d[i], d[i-calc_sn(j)]+1);\n        }\n    }\n    cout << d[N] << \" \";\n    d[0] = 0;\n    for(int i = 1; i <= N; i++){\n    \td[i] = inf;\n       \tfor (int j = 1; ; j++)\n        {\n        \tif(i < calc_sn(j)) break;\n        \tif(calc_sn(j) % 2 == 0) continue;\n            d[i] = min(d[i], d[i-calc_sn(j)]+1);\n        }\n    }\n    cout << d[N] << endl;\n}\n\nint main() {\n    while(1){\n    \tcin >> N;\n    \tif(N == 0) break;\n    \tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,j,k) for(int i=j;i<(int)(k);++i)\n#define foreach(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\nconst int INF = 99999999;\nconst double EPS = 1e-9;\n\nconst int MAX_N=1000001;\nint n;\nint dp[MAX_N][2];\n\nint main()\n{\n        rep(i,MAX_N)rep(j,2) dp[i][j]=INF;\n        dp[0][0]=dp[0][1]=0;\n        rep(i,MAX_N)for(int j=1;i+(j*(j+1)*(j+2)/6)<MAX_N;++j){\n                dp[i+(j*(j+1)*(j+2)/6)][0]=min(dp[i][0]+1,dp[i+(j*(j+1)*(j+2)/6)][0]);\n                if((j*(j+1)*(j+2)/6)&1) dp[i+(j*(j+1)*(j+2)/6)][1]\n                                                                        = min(dp[i][1]+1,dp[i+(j*(j+1)*(j+2)/6)][1]);\n        }\n\n        while(cin >> n,n) cout << dp[n][0] << \" \" << dp[n][1] << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n\ntypedef long long ll;\n\n#define N 1000000\n\nint x[1000001]={} , y[1000001]={};\n\nint main(void) {\n    vector<int> a,b;\n    int i=1;\n    while (i*(i+1)*(i+2)/6<=N){\n        int f = i*(i+1)*(i+2)/6;\n        a.push_back(f);\n        if (f%2==1)\n            b.push_back(f);\n        i++;\n    }\n    int n = a.size() , m = b.size();\n    FOR(i,1,N){\n        x[i] = N;\n        y[i] = N;\n    }\n    FOR(i,0,n){\n        REP(j,n){\n            if (i+a[j]>N)\n                break;\n            x[i+a[j]] = min(x[i+a[j]],x[i]+1);\n        }\n        REP(j,m){\n            if (i+b[j]>N)\n                break;\n            y[i+b[j]] = min(y[i+b[j]],y[i]+1);\n        }\n    }\n    while (cin >> n && n){\n        cout << x[n] << \" \" << y[n] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;a[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++)for(k=a[j];k<=1000000;k++){\n    if(a[j+1]>b[k+1])break;\n    b[k]=min(b[k],b[k-a[j]]+1);\n    if(a[j]%2)c[k]=min(c[k],c[k-a[j]]+1);\n  }\nwhile(cin>>n,n)cout<<b[n]<<' '<<c[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n;\n\nvoid solve(int *min,int flag,int c){\n\tint i;\n\tstatic int sum = 0, count = 0;\n\tif(count + 1 < *min && sum < n){\n\t\tfor(i = 0;((i + 1) * (i + 2) * (i + 3)) / 6 + sum <= n && i < c;i++);\n\t\twhile(i > 0){\n\t\t\tif(flag == 1 && i * (i + 1) * (i + 2) / 6 % 2 == 0){\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsum += i * (i + 1) * (i + 2) / 6;\n\t\t\tcount++;\n\t\t\tsolve(min,flag,i);\n\t\t\tsum -= i * (i + 1) * (i + 2) / 6;\n\t\t\tcount--;\n\t\t\ti--;\n\t\t}\n\t}\n\telse if(sum == n){\n\t\tif(count < *min)\n\t\t\t*min = count;\n\t}\n\treturn;\n}\n\nint main(void){\n\tint min;\n\tscanf(\"%d\",&n);\n\twhile(n != 0){\n\t\tmin = n;\n\t\tsolve(&min,0,0x7FFFFFFF);\n\t\tprintf(\"%d \",min);\n\t\tmin = n;\n\t\tsolve(&min,1,0x7FFFFFFF);\n\t\tprintf(\"%d\\n\",min);\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  1167.cpp\n// Author: ymiyamoto\n//\n// Created on Sat Dec  2 18:27:58 2017\n//\n\n#include <algorithm>\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nuint32_t polloc(uint32_t n)\n{\n  return n * (n + 1) * (n + 2) / 6;\n}\n\nstatic array<int32_t, 1000001> dp;\nstatic array<int32_t, 1000001> odddp;\n\nint32_t main()\n{\n  for (uint32_t i = 0; i < dp.size(); i++) {\n    dp[i] = odddp[i] = i;\n  }\n\n  vector<int64_t> pollocs;\n  for (uint32_t i = 0; i <= 85; i++) {\n    pollocs.push_back(polloc(i));\n  }\n\n  for (int64_t i = 0; i < (int64_t)dp.size(); i++) {\n    for (int64_t j = 0; j < (int64_t)pollocs.size(); j++) {\n      if (i - pollocs[j] >= 0) {\n        dp[i] = min(dp[i], dp[i - pollocs[j]] + 1);\n        if (pollocs[j] % 2 == 1) {\n          odddp[i] = min(odddp[i], odddp[i - pollocs[j]] + 1);\n        }\n      }\n    }\n  }\n\n  while (true) {\n    uint32_t n;\n    cin >> n;\n    if (n == 0) break;\n    cout << dp[n] << \" \" << odddp[n] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;a[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++)for(k=a[j];k<=1000000;k++){\n    if(j>b[k+1])break;\n    b[k]=min(b[k],b[k-a[j]]+1);\n    if(a[j]%2)c[k]=min(c[k],c[k-a[j]]+1);\n  }\nwhile(cin>>n,n)cout<<b[n]<<' '<<c[n]<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint dp1[1010101], dp2[1010101];\n\nvoid solve(int n) {\n    for (int i = 1; i <= n; i++) {\n        dp1[i] = INF;\n        dp2[i] = INF;\n    }\n    dp1[0] = dp2[0] = 0;\n    for (int i = 1; i < 202; i++) {\n        int polloc = i * (i + 1) * (i + 2) / 6;\n        if (polloc > n) break;\n        for (int j = polloc; j <= n; j++) {\n            dp1[j] = min(dp1[j], dp1[j - polloc] + 1);\n        }\n        if (polloc % 2) {\n            for (int j = polloc; j <= n; j++) {\n                dp2[j] = min(dp2[j], dp2[j - polloc] + 1);\n            }\n        }\n    }\n    cout << dp1[n] << ' ' << dp2[n] << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        solve(N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#define V_MAX 3\n//#define V_MAX 1000\nusing namespace std;\n\n\nint main(){\n  int n;\n  vector<int> v(V_MAX);\n  int i=0,mx=0;\n  int p[200],size;\n\n  while( cin>>n && n ){\n    if( i<V_MAX ) v[i]=n;\n    else          v.push_back(n);\n    i++;\n    mx=max(mx,n);\n  }\n  int vSize=i;\n\n  p[0]=0;\n  for( size=1; ; size++ ){\n    p[size]= size*(size+1)*(size+2)/6;\n    if( p[size]>mx ) break;\n  }\n\n  int dMAX = p[size-1] + 1;\n  int dp1[dMAX],dp2[dMAX];\n  int m,j ;\n  fill( dp1,dp1+dMAX,INT_MAX );\n  fill( dp2,dp2+dMAX,INT_MAX );\n\n  dp1[0]=0;\n  for( i=1;i<size;i++){\n    m=p[i];\n    for( j=m;j<dMAX;j++ )\n      dp1[j] = min( dp1[j],dp1[j-m]+1 );\n  }\n\n  dp2[0]=0;\n  for( i=1;i<size;i++){\n    if( p[i]%2==0 ) continue;\n    m=p[i];\n    for( j=m;j<dMAX;j++ )\n      dp2[j] = min( dp2[j],dp2[j-m]+1 );\n  }\n\n\n  \n  for( i=0;i<vSize;i++ )\n    cout << dp1[ v[i] ] << \" \" << dp2[ v[i] ] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1 << 25\n\nint dp[1500000];\nint dp2[1500000];\n\nint main()\n{\n  int n;\n  int tetra[200];\n  for(int i = 0; i < 200; i++) tetra[i] = (i+1)*(i+2)*(i+3)/6;\n  for(int i = 0; i < 1500000; i++) dp[i] = dp2[i] = INF;\n  dp[0] = dp2[0] = 0;\n  for(int i = 0; i < 200; i++){\n    dp[tetra[i]] = 1;\n    if(tetra[i]%2 == 1) dp2[tetra[i]] = 1;\n  }\n  for(int i = 0; i < 200; i++){\n    for(int j = 0; j + tetra[i] <= 1000000; j++){\n      dp[j+tetra[i]] = min(dp[j+tetra[i]], dp[j] + dp[tetra[i]]);\n      if(tetra[i]%2) dp2[j+tetra[i]] = min(dp2[j+tetra[i]], dp2[j] + dp2[tetra[i]]);\n    }\n  }\n  while(cin >> n, n){\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n \nint p[222];\nint memo[1111111];\nint memo2[1111111];\n \nint solve(int n){\n   \n  if(!n) return 0;\n  if(~memo[n]) return memo[n];\n \n  int ans = INF;\n  for(int i=1;i<181;i++) if(n>=p[i]) ans = min(ans, solve(n-p[i])+1);\n   \n  return memo[n] = ans;\n}\n \nint solve2(int n){\n   \n  if(!n) return 0;\n  if(n<0) return INF;\n  if(~memo2[n]) return memo2[n];\n \n  int ans = INF;\n  for(int i=1;i<181;i++) if(p[i]&1 && n>=p[i]) ans = min(ans, solve2(n-p[i])+1);\n \n  return memo2[n] = ans;\n}\n \nint main(){\n   \n  int n;\n   \n  memset(memo, -1, sizeof(memo));\n  memset(memo2, -1, sizeof(memo2));\n \n  for(int i=0;i<181;i++) p[i] = i*(i+1)*(i+2)/6;\n  while(cin >> n, n) cout << solve(n) << \" \" << solve2(n) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint x[19999999][2], a[999], b[999], s, n;\nint main() {\n\ta[0] = 1; b[0] = 1;\n\tfor (int i = 1; i < 300; i++) {\n\t\ta[i] = a[i - 1] + (i + 1)*(i + 2) / 2;\n\t\tif (a[i] % 2 == 1) {\n\t\t\ts++; b[s] = a[i];\n\t\t}\n\t}\n\tn = 10000000;\n\tmemset(x, 127, sizeof(x));\n\tx[0][0] = 0; x[0][1] = 0;\n\tfor (int i = 0; i < 200; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + a[i]][0] = min(x[j + a[i]][0], x[j][0] + 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < 50; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tx[j + b[i]][1] = min(x[j + b[i]][1], x[j][1] + 1);\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> n; if (!n) { break; }\n\t\tcout << x[n][0] << x[n][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n;\nint sum[222];\n\n//int dp[1111111][222];\nint dp[2][1111111];\n\n/*\nint solve(int s,int i,int f){\n  //if(!s) return 0;\n  if(i >= m) return s;\n  if(dp[s][i])return dp[s][i];\n\n  int ret = 1 << 28;\n  if(!((sum[i] + 1) % f)){\n    for(int j = 0;s - sum[i] * j >= 0 ; j++){\n      ret = min(ret,solve(s - sum[i] * j,i + 1,f) + j);\n    }\n  }\n  ret = min(ret,solve(s,i + 1,f));\n\n  return dp[s][i] = ret;\n}\n*/\nint solve(int s,int f){\n  if(!s) return 0;\n  if(dp[f-1][s]) return dp[f-1][s];\n\n  int ret = 1 << 28;\n  for(int i = 0; s >= sum[i]; i++){\n    if(!((sum[i] + 1) % f)){\n      ret = min(ret,solve(s - sum[i],f) + 1);\n    }\n  }\n  return dp[f-1][s] = ret;\n}\n\nint main(void){\n  sum[0] = 1;\n  for(int i = 1; sum[i-1] <= 1000000; i++){\n    sum[i] = sum[i-1] * (i + 3) / i;\n  }\n  for(int i = 1; i < 1000000; i++){\n    solve(i,1);\n    solve(i,2);\n  }\n  //puts(\"ok\");\n  while(1){\n    scanf(\"%d\",&n); if(!n) break;\n    printf(\"%d %d\\n\",dp[0][n],dp[1][n]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  constexpr int N = 1e4;\n  V<> a, b;\n  for (int i = 1; ; ++i) {\n    a.push_back(i * (i + 1) * (i + 2) / 6);\n    if (a.back() >= N) {\n      a.pop_back();\n      break;\n    }\n    if (a.back() & 1) b.push_back(a.back());\n  }\n  V<> p(N, -1), q(N, -1);\n  p[0] = q[0] = 0;\n  queue<int> que;\n  que.push(0);\n  while (!que.empty()) {\n    int i = que.front(); que.pop();\n    for (int e : a) if (i + e < N and p[i + e] == -1) {\n      p[i + e] = p[i] + 1;\n      que.push(i + e);\n    }\n  }\n  que.push(0);\n  while (!que.empty()) {\n    int i = que.front(); que.pop();\n    for (int e : b) if (i + e < N and q[i + e] == -1) {\n      q[i + e] = q[i] + 1;\n      que.push(i + e);\n    }\n  }\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    cout << p[n] << ' ' << q[n] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0;i < (int)(n);++i)\n#define RREP(i,n) for(int i = (int)n-1;i >= 0;--i)\n#define FOR(i,s,n) for(int i = s;i < (int)n;++i)\n#define RFOR(i,s,n) for(int i = (int)n-1;i >= s;--i)\n#define ALL(a) a.begin(),a.end()\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T>inline void out(T t){cout<<t<<\"\\n\";}\ntemplate<class T,class... Ts>inline void out(T t,Ts... ts){cout<<t<<\" \";out(ts...);}\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a = b;return true;}return false;}\nconstexpr int INF = 1e18;\n\nint dp[1000200],dp1[1000200];\n\nsigned main(){\n\tvector<int>v;\n\tFOR(i,1,10000){\n\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\tif(t > 1000000)break;\n\t\tv.emplace_back(t);\n\t}\n\tREP(i,1000200)dp[i] = dp1[i] = INF;\n\tdp[0] = dp1[0] = 0;\n\tREP(i,v.size()){\n\t\tREP(j,1000001){\n\t\t\tif(v[i] % 2){\n\t\t\t\tif(j + v[i] <= 1000000)CHMIN(dp1[j+v[i]],dp1[j]+1);\n\t\t\t}\n\t\t\tif(j + v[i] <= 1000000)CHMIN(dp[j+v[i]],dp[j]+1);\n\t\t}\n\t}\n\tint N;\n\twhile(cin >> N,N){\n\t\tout(dp[N],dp1[N]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int inf = 1e9;\nconst int maxN = 1000000;\n\nll f(ll n) {\n\treturn n * (n+1) * (n+2) / 6;\n}\n\nvector<int> makeS(int mod, int d) {\n\tvector<int> res;\n\tfor (int n = 1; f(n) <= maxN; ++n) {\n\t\tif ( f(n) % mod == d ) {\n\t\t\tres.push_back( f(n) );\n\t\t}\n\t}\n\treturn res;\n}\nvector<int> solve(const vector<int>& s) {\n\tvector<int> dp(maxN+1, inf); dp[0] = 0;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tfor (int j = 0; j <= maxN; ++j) {\n\t\t\tint nj = j + s[i];\n\t\t\tif (nj <= maxN) {\n\t\t\t\tdp[nj] = min(dp[nj], dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp;\n}\n\nint main() {\n\tvector<int> s0 = makeS(1, 0);\n\tvector<int> s1 = makeS(2, 1);\n\tvector<int> dp1 = solve(s0);\n\tvector<int> dp2 = solve(s1);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tcout << dp1[N] << \" \" << dp2[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\nbool dp[10][1000100] = {0};\n\nvoid solve(int n) {\n\tmemset(dp, 0, sizeof(dp));\n\n\tint ans = 1;\n\n\tfor (int i=0; V[i]<=n; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5 && !dp[i-1][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << \" \";\n\n\tmemset(dp, 0, sizeof(dp));\n\n\tans = 1;\n\n\tfor (int i=0; D[i]<=n; i++)\n\t\tdp[0][D[i]] = 1;\n\n\tfor (int i=1; i<=1000000 && !dp[1-i%2][n]; i++) {\n\t\tans++;\n\t\tfor (int j=0; j<=n; j++)\n\t\t\tdp[i%2][j] = 0;\n\t\tfor (int j=0; j<=n; j++) {\n\t\t\tif (!dp[1-i%2][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp[i%2][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( V[i-1]%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <cstdlib>\n#include <ctime>\n#include <time.h>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <numeric>\n#include <limits>\n#include <type_traits>\n\nusing namespace std;\n#define SAY_YES cout << \"YES\" << endl;\n#define SAY_Yes cout << \"Yes\" << endl;\n#define SAY_NO cout << \"NO\" << endl;\n#define SAY_No cout << \"No\" << endl;\n#define IFYES(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"YES\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"NO\" << endl;  \\\n    }\n#define IFYes(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"Yes\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"No\" << endl;  \\\n    }\n#define IFyes(TRUE_OR_FALSE)   \\\n    if (TRUE_OR_FALSE)         \\\n    {                          \\\n        cout << \"yes\" << endl; \\\n    }                          \\\n    else                       \\\n    {                          \\\n        cout << \"no\" << endl;  \\\n    }\n#define DEBUG_OUTPUT_ARRAY(XXX, ONE)                            \\\n    for (int i = 0; i < (ONE); i++)                             \\\n    {                                                           \\\n        cout << \"DEBUG: i = \" << i << \" -> \" << XXX[i] << endl; \\\n    }\n#define DEBUG_OUTPUT_ARRAY2(XXX, ONE, TWO)                             \\\n    for (int i = 0; i < (ONE); i++)                                    \\\n    {                                                                  \\\n        cout << \"<<< i = \" << i << \" >>>\" << endl;                     \\\n        for (int j = 0; j < (TWO); j++)                                \\\n        {                                                              \\\n            cout << \"DEBUG: j = \" << j << \" -> \" << XXX[i][j] << endl; \\\n        }                                                              \\\n    }\n#define DEBUG_OUTPUT_ARRAY2_BOX(XXX, ONE, TWO) \\\n    for (int i = 0; i < (ONE); i++)            \\\n    {                                          \\\n        cout << i << \"  \";                     \\\n        for (int j = 0; j < (TWO); j++)        \\\n        {                                      \\\n            cout << XXX[i][j] << \" \";          \\\n        }                                      \\\n        cout << endl;                          \\\n    }\n\ntypedef pair<long long int, long long int> pll;\n\n\nconst long long int mod = 1000000007;\nconst long long int INF = 1e18;\nlong long int N,M,sum=0,a[1005],b[1005],c[1005][30],dp[2000500]={},four[1000]={},dp2[2000500]={};\npll key[1005];\nstring S[6];\nint main()\n{\n    cout << fixed << setprecision(18);\n    cin>>N;\n    for(long long int i = 1; i <= 400; i++){\n        four[i]=i*(i+1)*(i+2)/6;\n    }\n    for(long long int i = 1; i <= 1000000; i++){\n        dp[i]=INF;\n        dp2[i]=INF;\n    }\n    \n    \n    for(long long int i = 0; i <= 999999; i++){\n        for(long long int j = 1; j <=200; j++){\n            if(i+four[j]<=1000000)dp[i+four[j]]=min(dp[i+four[j]],dp[i]+1);\n        }\n        for(long long int j = 1; j <=200; j++){\n            \n            if(four[j]%2==0){continue;}\n            if(i+four[j]<=1000000)dp2[i+four[j]]=min(dp2[i+four[j]],dp2[i]+1);\n        }\n    }\n    \n    while(N!=0){\n        cout<<dp[N]<<\" \"<<dp2[N]<<endl;\n        cin>>N;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nint main() {\n  vector<int> v[2];\n  for(int i=1; i<=200; i++) {\n    v[0].pb(i*(i+1)*(i+2)/6);\n    v[i*(i+1)*(i+2)/6%2].pb(i*(i+1)*(i+2)/6);\n  }\n  int d[2][1000001];\n  rep(i,2)rep(j,1000001) d[i][j]=MAX;\n  d[0][0]=d[1][0]=0;\n  rep(k,2) {\n    rep(i,v[k].size()) {\n      rep(j,1000001) {\n\tif(v[k][i]+j>1000001) break;\n\td[k][v[k][i]+j]=min(d[k][v[k][i]+j],d[k][j]+1);\n      }\n    }\n  }\n  int n;\n  while(R n && n) PR(d[0][n],d[1][n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1); \n\t  tmp=min(dp[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MAX_VAL = 1e6;\n\nvoid makePyramidal(vector<int>* pyramidal, vector<int>* odd_pyramidal, const int& max_val) {\n    for (int i = 1; ; i++) {\n        int val = i * (i+1) * (i+2) / 6;\n        if (val > max_val) { break; }\n        pyramidal->push_back(val);\n        if (val % 2) { odd_pyramidal->push_back(val); }\n    }\n    reverse(pyramidal->begin(), pyramidal->end());\n    reverse(odd_pyramidal->begin(), odd_pyramidal->end());\n}\n\nint searchPyramidal(const vector<int>& pyramidal, const int& val, const int& i, const int& n) {\n    if (val == 0) { return n; }\n    if (val < 0 or i >= pyramidal.size()) { return MAX_VAL; }\n    const int a = searchPyramidal(pyramidal, val - pyramidal[i], i, n + 1);\n    const int b = searchPyramidal(pyramidal, val - pyramidal[i], i + 1, n + 1);\n    const int c = searchPyramidal(pyramidal, val, i + 1, n);\n    return min(a, min(b, c));\n}\n\npair<int,int> solve(const vector<int>& pyramidal, const vector<int>& odd_pyramidal, const int& val) {\n    int a = searchPyramidal(pyramidal, val, 0, 0);\n    int b = searchPyramidal(odd_pyramidal, val, 0, 0);\n    return make_pair(a, b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    vector<int> pyramidal;\n    vector<int> odd_pyramidal;\n    makePyramidal(&pyramidal, &odd_pyramidal, MAX_VAL);\n\n    int val;\n    while (true) {\n        cin >> val;\n        if (val == 0) { break; }\n        auto p = solve(pyramidal, odd_pyramidal, val);\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0, i##_len = (n); i < i##_len; i++)\n#define reps(i, s, n) for(ll i = (s), i##_len = (n); i < i##_len; i++)\n#define rrep(i, n) for(ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, e, n) for(ll i = (n) - 1; i >= (e); i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n#define len(x) ((ll)(x).length())\n\nconst ll inf = LONG_LONG_MAX / 2 - 1;\nvector<ll> cnt(200), odd;\n\nvoid solve(ll n) {\n    if (cnt[0] == 0) {\n        rep(i, sz(cnt)) {\n            cnt[i] = (i + 1) * (i + 2) * (i + 3) / 6;\n            if (cnt[i] % 2 == 1) odd.push_back(cnt[i]);\n        }\n    }\n    vector<ll> dp(n + 1, inf);\n    rep(i, n + 1) dp[i] = i;\n    reps(i, 1, sz(cnt)) {\n        reps(j, cnt[i], n + 1) {\n            dp[j] = min(dp[j], dp[j - cnt[i]] + 1);\n        }\n    }\n    ll ans1 = dp[n];\n    rep(i, n + 1) dp[i] = i;\n    reps(i, 1, sz(odd)) {\n        reps(j, odd[i], n + 1) {\n            dp[j] = min(dp[j], dp[j - odd[i]] + 1);\n        }\n    }\n    ll ans2 = dp[n];\n    printf(\"%lld %lld\\n\", ans1, ans2);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // ifstream in(\"input.txt\");\n    // cin.rdbuf(in.rdbuf());\n    while(true) {\n        ll t;\n        cin >> t;\n        if (t == 0) break;\n        solve(t);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP_N(i,n,s) for(ll i=0; i<(ll)n; i+=s)\n#define REP(i,n) REP_N(i,n,1)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nvoid solution(ll output[1000001], int interval) {\n\toutput[0] = 0;\n\tll current_i = interval-1;\n\tREP(i, 1000001) if(i!=0) {\n\t\tll minimum = 1000001;\n\t\tREP_N(j, current_i+1, interval) if(j!=0) minimum = min(output[i - table[j]] + 1, minimum);\n\t\toutput[i] = minimum;\n\n\t\tif (table[current_i + interval] == i) current_i += interval;\n\t}\n}\n\nint main() {\n\t//freopen(\"Text.txt\", \"r\", stdin);\n\t\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i++]) table[i] = i*(i + 1)*(i + 2) / 6;\n\t}\n\n\tsolution(pollock, 1);\n\tsolution(dp, 4);\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define MAX 1000000\n#define INF 1000000000\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll num=0,cnt=3,i=0;\n  vector<ll> n_list,o_list;\n  while(num<=MAX){\n    num = (cnt)*(cnt-1)*(cnt-2);\n    num/=6;\n    n_list.push_back(num);\n    if(num%2==1){\n      o_list.push_back(num);\n    }\n    cnt++;\n  }\n  ll n;\n  cin >> n;\n  while(n!=0){\n    vector<ll> dp(n+1),odp(n+1);\n    fill(dp.begin(),dp.end(),INF);\n    fill(odp.begin(),odp.end(),INF);\n    dp[0]=0;\n    odp[0]=0;\n    for(int i=0;i<n_list.size();i++){\n      for(int j=n_list[i];j<=n;j++){\n        dp[j]=min(dp[j],dp[j-n_list[i]]+1);\n      }\n    }\n    for(int i=0;i<o_list.size();i++){\n      for(int j=o_list[i];j<=n;j++){\n        odp[j]=min(odp[j],odp[j-o_list[i]]+1);\n      }\n    }\n    cout << dp[n]<<\" \"<<odp[n]<<endl;\n    cin >> n;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 2013/11/15 Tazoe\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nint main()\n{\n\tvector<int> T;\t\t// 正四面体数\n\tfor(int n=1; ; n++){\n\t\tint t = n*(n+1)*(n+2)/6;\n\n\t\tif(t>=1000000)\n\t\t\tbreak;\n\n\t\tT.push_back(t);\n\t}\n\n\tint DP1[1000000];\t// 正四面体数の個数\n\tint DP2[1000000];\t// 奇数の正四面体数の個数\n\tDP1[0] = DP2[0] = 0;\n\tfor(int i=1; i<1000000; i++){\n\t\tDP1[i] = DP2[i] = 1000000;\n\t}\n\n\tfor(int i=0; i<T.size(); i++){\n\t\tfor(int j=T[i]; j<1000000; j++){\n\t\t\tDP1[j] = min(DP1[j], DP1[j-T[i]]+1);\n\t\t}\n\n\t\tif(T[i]%2==1){\n\t\t\tfor(int j=T[i]; j<1000000; j++){\n\t\t\t\tDP2[j] = min(DP2[j], DP2[j-T[i]]+1);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tint m;\n\t\tcin >> m;\n\n\t\tif(m==0)\n\t\t\tbreak;\n\n\t\tcout << DP1[m] << ' ' << DP2[m] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    vector<int> v, v_odd;\n    for (int i = 1; i < 1000; i++)\n    {\n        int tmp = (i * (i + 1) * (i + 2)) / 6;\n        if (tmp > 1000000)\n        {\n            break;\n        }\n        v.push_back(tmp);\n        if (tmp % 2 == 1)\n        {\n            v_odd.push_back(tmp);\n        }\n    }\n    vector<int> dp(2000000, 10000000);\n    vector<int> dp_odd(2000000, 10000000);\n    dp[0] = 0;\n    dp[1] = 1;\n    dp_odd[0] = 0;\n    dp_odd[1] = 1;\n    for (int i = 0; i < 1000000; i++)\n    {\n        for (int j : v)\n        {\n            dp[i + j] = min(dp[i + j], dp[i] + 1);\n        }\n        for (int j : v_odd)\n        {\n            dp_odd[i + j] = min(dp_odd[i + j], dp_odd[i] + 1);\n        }\n    }\n\n    while (1)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n        {\n            break;\n        }\n        cout << dp[n] << \" \" << dp_odd[n] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define INF 1000000\n\nint dp[1000001];\nint dp2[1000001];\n\nint main(){\n    int a[200];\n    memset(dp, INF, sizeof(dp));\n    memset(dp2, INF, sizeof(dp2));\n    \n    for(int i=1;i<200;i++){\n        a[i] = i*(i+1)*(i+2)/6;\n        if(a[i] > 1000000) break;\n        dp[a[i]] = 1;\n        if(a[i]%2) dp2[a[i]]=1;\n    }\n\n    for(int i=1;i<1000001;i++){\n        for(int j=1;j<200;j++){\n            if(i+a[j] > 1000000) break;\n            dp[i+a[j]] = min(dp[i+a[j]], dp[i]+1);\n            if(a[j]%2) dp2[i+a[j]] = min(dp2[i+a[j]], dp2[i]+1);\n        }\n    }\n    int n;\n    while(cin >> n && n){\n        printf(\"%d %d\\n\", dp[n], dp2[n]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i < (n);++i)\nusing namespace std;\ntemplate <class _t> inline bool chmax (_t& a,_t b){if(a<b){a=b;return true;}return false;} template <class _t> inline bool chmin (_t& a,_t b){if(a>b){a=b;return true;}return false;}\n\nconst long long inf = 1ll << 60;\nconst long long mod = 1000000007;\n\nint dx[4] = {1,0,-1,0};int dy[4] = {0,-1,0,1};\n\nint main() {\n    int n=1000000;\n    vector<int> dp(n),dp_odd(n);\n    vector<int> table;\n    rep(i,n) dp[i] = dp_odd[i] =  10010010;\n    for(int i=1;i<=200;i++){\n\tint tmp = i*(i+1)*(i+2)/6;\n\tif(tmp>=n)break;\n\tdp[tmp] = 1;\n\n\ttable.push_back(tmp);\n\tif(tmp%2==1) dp_odd[tmp]=1;\n    }\n\tfor(int j=0;j<n;j++){\n\t    for(int k=0;k<table.size();k++){\n\t\tif(j>table[k])chmin(dp[j],dp[j-table[k]]+1);\n\t\tif(j>table[k] && table[k]%2==1)chmin(dp_odd[j],dp_odd[j-table[k]]+1);\n\t    } \n\t}\n    while(1){\n\tint m;cin >> m;\n\tif(m==0) return 0;\n\tcout << dp[m] << \" \" << dp_odd[m]<< endl;;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst int maxN = 1000000;\nint dp1[maxN+1] = {0}, dp2[maxN+1] = {0};\nint temp[maxN+1];\n\ntypedef long long ll;\n\nint f(ll n) {\n\treturn n * (n+1) * (n+2) / 6;\n}\n\nvoid knapsack(int dp[], const vector<int>& v) {\n\tint *now = dp, *next = temp;\n\tfill(now, now+maxN+1, inf); now[0] = 0;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tfill(next, next+maxN+1, inf);\n\t\tfor (int j = 0; j <= maxN; ++j) {\n\t\t\tnext[j] = min(next[j], now[j]);\n\t\t\tint nj = j + v[i];\n\t\t\tif (nj <= maxN) {\n\t\t\t\tnow[nj] = min(now[nj], now[j]+1);\n\t\t\t}\n\t\t}\n\t\tswap(now, next);\n\t}\n\tfor (int i = 0; i <= maxN; ++i) {\n\t\tdp[i] = now[i];\n\t}\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tvector<int> v1, v2;\n\tREP(i, maxN+1) {\n\t\tif ( f(i) >= maxN ) break;\n\t\tv1.push_back( f(i) );\n\t\tif ( f(i) % 2 == 1 ) {\n\t\t\tv2.push_back( f(i) );\n\t\t}\n\t}\n\tknapsack(dp1, v1);\n\tknapsack(dp2, v2);\n\n\tint N;\n\twhile (cin >> N, N) {\n\t\tcout << dp1[N] << \" \" << dp2[N] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint tetrahedron(int);\n\nint index_direct_match(int);\nint index_direct_match_odd(int);\nint index_number(int);\nint index_number_odd(int);\n\nint main(int argc, char const *argv[]) {\n\n  int n;\n  int cnt_min;\n  int cnt_only_odd;\n\n  for(cin >> n;n != 0;cin >> n){\n\n    cout << index_number(n) << \" \" <<  index_number_odd(n) << endl;\n\n  }\n\n  //\n\n  return 0;\n}\n\nint tetrahedron(int k){\n\n  return k*(k+1)*(k+2)/6;\n\n}\n\nint index_number(int index){\n  static int memo[1000]={};\n  if(index>=1 && index<=3) return index;\n  else if(index_direct_match(index)) return 1;\n  else if(memo[index] != 0) return memo[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i++){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number( index - tetrahedron(i) ));\n    }\n    memo[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n\n}\n\nint index_direct_match(int index){\n\n  for(int i=1;i<200;i++){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_direct_match_odd(int index){\n\n  for(int i=1;i<200;i+=4){\n    if(index == tetrahedron(i)){\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint index_number_odd(int index){\n  static int memo2[1000]={};\n  if(index>=1 && index<=34) return index;\n  else if(index_direct_match_odd(index)) return 1;\n  else if(memo2[index] != 0) return memo2[index];\n  else{\n    vector<int> comp_array;\n    for(int i=1;index > tetrahedron(i);i+=4){\n      //cout << \"index:\" << index << endl;\n      //cout << \"tetra:\" << tetrahedron(i) << endl;\n      comp_array.push_back(1+index_number_odd( index - tetrahedron(i) ));\n    }\n    memo2[index]=(int)*min_element(comp_array.begin(),comp_array.end());\n    return *min_element(comp_array.begin(),comp_array.end());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)(テつエテ」ツδサテ渉嘉」ツδサ`)///\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvi v;\n\t\tFOR(i, 1, INF) {\n\t\t\tv.push_back(i*(i + 1)*(i + 2) / 6);\n\t\t\tif (v[i-1] >= n)break;\n\t\t}\n\t\tint m = v.size();\n\t\tvvi dp(m + 1, vi(n + 1, INF));\n\t\tdp[0][0] = 0;\n\t\tREP(i, m) {\n\t\t\tREP(j, n + 1) {\n\t\t\t\tif (j < v[i])dp[i + 1][j] = dp[i][j];\n\t\t\t\telse dp[i + 1][j] = min(dp[i][j] , dp[i+1][j - v[i]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << dp[m][n] << \" \";\n\t\tvvi dp2(m + 1, vi(n + 1, INF));\n\t\tdp2[0][0] = 0;\n\t\tREP(i, m) {\n\t\t\tif (v[i] % 2 == 0) {\n\t\t\t\tREP(j, n + 1)dp2[i + 1][j] = dp2[i][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tREP(j, n + 1) {\n\n\t\t\t\t\tif (j < v[i])dp2[i + 1][j] = dp2[i][j];\n\t\t\t\t\telse dp2[i + 1][j] = min(dp2[i][j], dp2[i + 1][j - v[i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dp2[m][n] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int MAX_N = 1000000;\n\nint cnt1[MAX_N+1],cnt2[MAX_N+1];\n\nint main()\n{\n    rep(i,MAX_N){\n        cnt1[i] = cnt2[i] = 10*MAX_N;\n    }\n    cnt1[0] = cnt2[0] = 0;\n    for(int j=1;;j++){\n        int val = j*(j+1)*(j+2)/6;\n        if(val > MAX_N){\n            break;\n        }\n        for(int i=0;i+val<=MAX_N;i++){\n            cnt1[i+val] = min(cnt1[i+val],cnt1[i]+1);\n        }\n        if(val%2){\n            for(int i=0;i+val<=MAX_N;i++){\n                cnt2[i+val] = min(cnt2[i+val],cnt2[i]+1);\n            }\n        }\n    }\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        cout << cnt1[n] << \" \" << cnt2[n] << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define SET(a,c) memset(a,c,sizeof(a))\n#define PB push_back\nusing namespace std;\n\nconst int MAX_N = 1e6;\nconst int INF = 0x3f3f3f3f;\n\nint dp[MAX_N], dp_odd[MAX_N];\n\nvoid solve(int n)\n{\n\tvector<int> m;\n\n\tSET(dp, INF);\n\tSET(dp_odd, INF);\n\t\n\tREP(i, MAX_N) {\n\t\tm.PB((i + 1) * (i + 2) * (i + 3) / 6);\n\t\tif (m.back() > MAX_N) break;\n\t}\n\t\n\tdp[0] = 0; dp_odd[0] = 0;\n\tREP(i, m.size()) {\n\t\tREP(j, n + 1) {\n\t\t\tif (j < m[i]) continue;\n\t\t\tdp[j] = min(dp[j], dp[j - m[i]] + 1);\n\t\t\tif (m[i] % 2) dp_odd[j] = min(dp_odd[j], dp_odd[j - m[i]] + 1);\n\t\t}\n\t}\t\n}\n\nint main()\n{\n\tint n;\n\tsolve(MAX_N);\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (!n) break;\n\t\tprintf(\"%d %d\\n\", dp[n], dp_odd[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nint n;\nvector<long long> dpall(1000100, 1e9);\nvector<long long> dpodd(1000100, 1e9);\nvector<long long> preall(220, 0);\nvector<long long> preodd;\n\nint main() {\n    for(int i = 1; i <= 200; ++i) {\n        preall.at(i-1) = (i*(i+1)*(i+2))/6;\n        if(preall.at(i-1) % 2 != 0) {\n            preodd.push_back(preall.at(i-1));\n        }\n    }\n    int oddlen = preodd.size();\n\n    dpall[0] = 0;\n    for(int i = 1; i < 200; ++i) {\n        for(int j = 0; j <= 1000010; ++j) {\n            if(j-preall.at(i-1) >= 0) {\n                chmin(dpall[j], dpall[j-preall.at(i-1)]+1);\n            }\n        }\n    }\n\n    dpodd[0] = 0;\n    for(int i = 1; i < oddlen; ++i) {\n        for(int j = 0; j <= 1000010; ++j) {\n            if(j-preodd.at(i-1) >= 0) {\n                chmin(dpodd[j], dpodd[j-preodd.at(i-1)]+1);\n            }\n        }\n    }\n\n    while(1) {\n        cin >> n;\n        if(n == 0) break;\n        cout << dpall[n] << \" \" << dpodd[n] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define INF 1000010\nusing namespace std;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nvector<int> num(200);\nvector<int> num_odd(200);\nvector<int> dp(1000011,INF);\nvector<int> dp_odd(1000011,INF);\nint main()\n{\n\tint i = 0;\n\twhile(i <= 185)\n\t{\n\t\tlong tmp = i*(i+1)*(i+2)/6;\n\t\tnum[i] = tmp;\n\t\tif(num[i] % 2) num_odd.push_back(tmp);\n\t\ti++;\n\t}\n\tdp[0] = dp_odd[0] = 0;\n\tfor(int i=0; i<num.size(); i++)\n\t{\n\t\tfor(int j=num[i]; j<=1000000; j++)\n\t\t{\n\t\t\tdp[j] = min(dp[j], dp[j - num[i]] + 1);\n\t\t}\n\t}\n\tfor(int i=0; i<num_odd.size(); i++)\n\t{\n\t\tfor(int j=num_odd[i]; j<=1000000; j++)\n\t\t{\n\t\t\tdp_odd[j] = min(dp_odd[j], dp_odd[j - num_odd[i]] + 1);\n\t\t}\n\t}\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tcout << dp[N] << \" \" << dp_odd[N] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 10000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\nint dp1[2][1000000 + 1];\nint dp2[2][1000000 + 1];\nvector<int> cnt1;\nvector<int> cnt2;\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    rep2(i, 1, 200) {\n        cnt1.push_back(i * (i + 1) * (i + 2) / 6);\n        if ((i * (i + 1) * (i + 2) / 6)% 2 == 1) {\n            cnt2.push_back(i * (i + 1) * (i + 2) / 6);\n        }\n    }\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        int cur1 = 1, pre1 = 0;\n        int cur2 = 1, pre2 = 0;\n        rep(j, n + 1) {\n            dp1[pre1][j] = INF;\n            dp2[pre2][j] = INF;\n        }\n        dp1[0][0] = 0;\n        dp2[0][0] = 0;\n        rep(i, 200) {\n            rep(j, n + 1) dp1[cur1][j] = INF;\n            rep(j, n + 1) {\n                dp1[cur1][j] = dp1[pre1][j];\n                if (j - cnt1[i] >= 0) {\n                    dp1[cur1][j] = min(dp1[cur1][j], dp1[cur1][j - cnt1[i]] + 1);\n                }\n            }\n            swap(cur1, pre1);\n        }\n        rep(i, cnt2.size()) {\n            rep(j, n + 1) dp2[cur2][j] = INF;\n            rep(j, n + 1) {\n                dp2[cur2][j] = dp2[pre2][j];\n                if (j - cnt2[i] >= 0) {\n                    dp2[cur2][j] = min(dp2[cur2][j], dp2[cur2][j - cnt2[i]] + 1);\n                }\n            }\n            swap(cur2, pre2);\n        }\n        cout << dp1[pre2][n] << \" \" << dp2[pre2][n] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int i,j,k,b[1000001],c[1000001],a[200],n;\n  for(i=0;a[i-1]<1000000;i++)a[i]=i*(i+1)*(i+2)/6;\n  for(j=0;j<=1000000;j++)b[j]=c[j]=j;\n  for(j=2;j<i;j++)for(k=a[j];k<=1000000;k++){\n    if(k>b[k+1])break;\n    b[k]=min(b[k],b[k-a[j]]+1);\n    if(a[j]%2)c[k]=min(c[k],c[k-a[j]]+1);\n  }\n while(cin>>n,n)cout<<b[n]<<' '<<c[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\n\nvector<int>nums;\nvector<int>oddnums;\n\nvector<vector<int>>memo(100001, vector<int>(190,-1));\nvector<vector<int>>oddmemo(100001, vector<int>(50,-1));\n\nint getans(const int num, const int used,const int atime) {\n\tif (memo[num][used] != -1) {\n\t\treturn memo[num][used];\n\t}\n\telse {\n\t\tif (num == 0)return memo[num][used] = 0;\n\t\tif (atime > 100)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <= used; ++i) {\n\t\t\tint minusnum = nums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 100) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getans(num - minusnum, i, atime + 1)+1);\n\t\t}\n\n\t\treturn memo[num][used] = ans;\n\t}\n}\nint getoddans(const int num, const int used, const int atime) {\n\tif (oddmemo[num][used] != -1) {\n\t\treturn  oddmemo[num][used];\n\t}\n\telse {\n\t\tif (num == 0)return oddmemo[num][used] = 0;\n\t\tif (atime > 100)return atime;\n\t\tint ans = num;\n\t\tfor (int i = 0; i <= min(int(oddnums.size()),used); ++i) {\n\t\t\tint minusnum = oddnums[i];\n\t\t\tif (minusnum > num) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (num / minusnum > 100) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = min(ans, getoddans(num - minusnum, i, atime + 1) + 1);\n\t\t}\n\n\t\treturn  oddmemo[num][used] = ans;\n\t}\n}\nint main() {\n\tfor (int i = 1; i < 190; ++i) {\n\t\tnums.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif (((i*(i + 1)*(i + 2)) / 6) % 2) {\n\n\t\t\n\t\t\toddnums.push_back((i*(i + 1)*(i + 2)) / 6);\n\t\t}\n\t}\n\n\twhile (1) {\n\t\tint n; cin >> n;\n\t\tif (!n)break;\n\t\tint normalans = getans(n, 189, 0);;\n\t\tint oddans = getoddans(n, 47, 0);\n\n\t\tcout << normalans << \" \" << oddans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\nconst int N = 1000000;\nconst int mod = 1000000007;\nconst int INF = 1 << 30;\n#define rep(i,n) for(int i=(ll)0;i<(ll)n;++i)\n#define ALL(x) x.begin(),x.end()\n#define pp pair<ll,ll>\n#define fi first\n#define se second\n#define pb push_back\n#define fix(n) fixed<<setprecision(n)\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nstring YN(bool b) { return(b ? \"YES\" : \"NO\"); }\nstring yn(bool b) { return(b ? \"Yes\" : \"No\"); }\nll ss[1000];//正四面体数\nvector<ll>v;\nll dp[1000000],dp2[1000000];\nint main() {\n\tv.pb(1);\n\tll n,now=1;\n\trep(i, 1000) {\n\t\tss[i] = (ll)i*(i + 1)*(i + 2) / 6;\n\t\tif (ss[i] % 2 == 1)v.pb(ss[i]);\n\t}\n\trep(i, 100000) {\n\t\tif (i < 2) { dp[i] = i; continue; }\n\t\tif (i >= ss[now + 1])++now;\n\t\tdp[i] = i / ss[now] + dp[i%ss[now]];\n\t\tfor (int j = now - 1; j >= 1; --j)dp[i] = min(dp[i], i / ss[j] + dp[i%ss[j]]);\n\t}\n\tnow = 1;\n\trep(i, 100000) {\n\t\tif (i < 2) { dp2[i] = i; continue; }\n\t\tif (i >= v[now + 1])++now;\n\t\tdp2[i] = i / v[now] + dp2[i%v[now]];\t\n\t\tfor (int j = now - 1; j >= 1; --j)dp2[i] = min(dp2[i], i / v[j] + dp2[i%v[j]]);\n\t\n\t}\n\twhile (cin >> n, n) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n  \n  int i, input, tetras[200] = {0}, ans[100][100] = {{0}, {0}};\n\n  for (i = 1; i <= 180; i++) {\n    tetras[i] = i * (i+1) * (i+2) / 6;\n  }\n\n  int a = 0;\n  while (cin >> input) {\n    if (input == 0) break;\n    int temp = input;\n    int j = 1, min = 1000000000;\n    while (tetras[j] <= input) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j++;\n      input = temp;\n    }\n    ans[a][0] = min;\n    j = 1, min = 1000000000;\n    while (tetras[j] <= input) {\n      int n = 0;\n      int k = j;\n      while (input > 0) {\n\tif (tetras[k] % 2 == 0) {\n\t  k--;\n\t  continue;\n\t}\n\tinput -= tetras[k];\n\tif (input >= 0) {\n\t  n++;\n\t} else {\n\t  input += tetras[k];\n\t  k--;\n\t  continue;\n\t}\n      }\n      if (min > n) min = n;\n      j++;\n      input = temp;\n    }\n    ans[a][1] = min;\n    a++;\n  }\n\n  int b;\n  for (b = 0; b < a; b++) {\n    cout << ans[b][0] << ' ' << ans[b][1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n#define all(r) (r).begin(),(r).end()\n#define gsort(st,en) sort((st),(en),greater<int>())\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing comd = complex<double>;\nusing pii = pair<int,int> ;\n\nconstexpr int imax = ((1<<30)-1)*2+1 ;\nconstexpr int inf = 100000000;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,-1,0,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ndouble CalcDist(comd p1, comd p2){\n  return sqrt(pow(p1.X - p2.X,2.0) + pow(p1.Y -p2.Y,2.0));\n}\n\ntemplate <typename T>\nvoid out(deque < T > d)\n{\n  for(size_t i = 0; i < d.size(); i++)\n  {\n    debug(d[i]);\n  }\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\nint n;\nint res =inf;\nint solve(int a,int b,int c,vector<int> v){\n  if(b == 0) res = inf;\n//   rep(i,b) cout <<\"\\t\";\n//   cout << a<< \" \" << b << \" \" << v[c]<<endl;\n  if(a == n){\n    res = min(res,b);\n    return b;\n  }\n  if(a > n || res <= b) return inf;\n  else{\n    REP(i,c,v.size()){\n      res = min(solve(a+v[i],b+1,i,v),res);\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int tmp=0,k = 1;\n  vector<int> suqnum(0),odd(0);\n  while(tmp < 1000000){\n    tmp = k * (k + 1) * (k + 2) / 6;\n    suqnum.pb(tmp);\n    if(tmp%2==1){\n      odd.pb(tmp);\n    }\n    ++k;\n  }\n  reverse(all(suqnum));\n  reverse(all(odd));\n  while(cin >> n){\n    if(n == 0)break;\n    int lb1= 0 ,lb2 = 0;\n    rep(i,suqnum.size()){\n      if(suqnum[i] <= n){\n        lb1 = i;\n        break;\n      }\n    }\n    rep(i,odd.size()){\n      if(odd[i] <= n){\n        lb2 = i;\n        break;\n      }\n    }\n    lb1 += n % suqnum[lb1] == 0;\n    lb2 += n % odd[lb2] == 0;\n    queue<pii> q;\n    q.push(make_pair(0,0));\n    while(!q.empty()){\n      pii p = q.front();q.pop();\n      REP(i,lb1,suqnum.size()){\n        if(p.se+suqnum[i] == n){\n          cout << p.fi+1<< \" \";\n          q = queue<pii>();\n          break;\n        }\n        else if(p.se+suqnum[i] < n){\n          q.push(make_pair(p.fi+1,p.se+suqnum[i]));\n        }\n      }\n    }\n    q.push(make_pair(0,0));\n    while(!q.empty()){\n      pii p = q.front();q.pop();\n      REP(i,lb2,odd.size()){\n        if(p.se+odd[i] == n){\n          cout << p.fi+1<< endl;\n          q = queue<pii>();\n          break;\n        }\n        else if(p.se+odd[i] < n){\n          q.push(make_pair(p.fi+1,p.se+odd[i]));\n        }\n      }\n    }\n//     cout << solve(0,0,lb1,suqnum)<<endl;\n//     cout << solve(0,0,lb2,odd) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    //cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    //cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint dp[2][1000000];\nint v[250];\nint main()\n{\n\tint n;\n\tfor (int j = 0; j < 1000000; j++)\n\t{\n\t\tdp[0][j] = 999999;\n\t\tdp[1][j] = 999999;\n\t}\n\tdp[0][0] = 0;\n\tdp[1][0] = 0;\n\tfor (int i = 1;i < 250; i++)\n\t{\n\t\tint k = i * (i + 1) * (i + 2) / 6;\n\t\tif (k >= 1000000)break;\n\t\tv[i - 1] = k;\n\t}\n\tfor (int i = 0; i < 1000000; i++)\n\t{\n\t\tfor (int j = 0;j < 250; j++)\n\t\t{\n\t\t\tif (i + v[j] >= 1000000)break;\n\t\t\tdp[0][i + v[j]] = min(dp[0][i + v[j]], dp[0][i] + 1);\n\t\t\tif (v[j] % 2 == 0)continue;\n\t\t\tdp[1][i + v[j]] = min(dp[1][i + v[j]], dp[1][i] + 1);\n\t\t}\n\t}\n\twhile (cin >> n && n != 0)\n\t{\n\t\tcout << dp[0][n] << \" \" << dp[1][n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint si[200];\nint dp_k[1000000];\nint dp[1000000];\n\nvoid mk(){\n  for(int i=0;i<200;i++){\n    si[i]=(i*(i+1)*(i+2))/6;\n    if(si[i]>1000000){break;}\n    dp[si[i]]=1;\n    if(si[i]%2==1)\n      dp_k[si[i]]=1;\n  }\n}\n\nint main()\n{\n  int x,y;\n  for(int i=0;i<200;i++)si[i]=1000000;\n  for(int i=0;i<1000000;i++){dp[i]=100000;dp_k[i]=100000;}\n  mk();\n  \n  \n  dp[0]=0;\n  dp_k[0]=0;\n  for(int i=1;i<1000000;i++){\n    for(int j=1;j<200;j++){\n      if((i+si[j])<1000000){\n\tdp[i+si[j]]=min(dp[i+si[j]],dp[i]+1);\n\tif(si[j]%2==1)\n\t  dp_k[i+si[j]]=min(dp_k[i+si[j]],dp_k[i]+1);\n      }\n    }\n  }\n    \n\n\n  for(;;){\n    cin >> x;\n    if(x==0)return 0;\n    cout << dp[x] <<\" \"<<dp_k[x]<<endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nusing namespace std;\n\nstatic const ll INF = 1e15;\n\n\nint main() {\n    vector<ll> tri;    \n    tri.reserve(1e6);\n    tri.push_back(0);\n    for (int i = 1; i < 1e6; i++) {\n        auto next = tri.back() + i;\n        if (next > 1e6) break;\n        tri.push_back(next);\n    }\n    vector<ll> tetra;\n    tetra.reserve(1e6);\n    tetra.push_back(0);\n    for (int i = 1; i < 1e6; i++) {\n        auto t = tri[i];\n        auto next = tetra.back() + t;\n        if (next > 1e6) break;\n        tetra.push_back(next);\n    }\n    vector<int> dp1(1e6 + 1);\n    vector<int> dp2(1e6 + 1);\n    for (int i = 0; i <= 1e6; i++) {\n        dp1[i] = i;\n        dp2[i] = i;\n    }\n    for (int i = 2; i <= 1e6; i++) {\n        int u = dp1[i];\n        for (int j = 1; j < tetra.size(); j++) {\n            if (tetra[j] > i) break;\n            u = min(u, dp1[i - tetra[j]] + 1);\n        }\n        dp1[i] = u;\n    }\n    for (int i = 2; i <= 1e6; i++) {\n        int u = dp2[i];\n        for (int j = 1; j < tetra.size(); j++) {\n            if (tetra[j] > i) break;\n            if (tetra[j] % 2 == 1) {\n                u = min(u, dp2[i - tetra[j]] + 1);\n            }\n        }\n        dp2[i] = u;\n    }\n    while (true) {\n        int a;\n        cin >> a;\n        if (a == 0) return 0;\n        cout << dp1[a] << \" \" << dp2[a] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <tuple>\n#include <cstdio>\n#include <bitset>\n#include <sstream>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <cstring>\n#include <set>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\n#define DEBUG_ //!!提出時にコメントアウト!!\n#ifdef DEBUG_\n\t#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#else\n\t#define dump(x)  ;\n#endif\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define eb emplace_back\n\n//#define int long long\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\n\ntemplate <typename T>\nstd::string printVector(const std::vector<T> &data)\n{\n    std::stringstream ss;\n    std::ostream_iterator<T> out_it(ss, \", \");\n    ss << \"[\";\n    std::copy(data.begin(), data.end() - 1, out_it);\n    ss << data.back() << \"]\";\n    return ss.str();\n}\n\nconst int MOD = 1e9+7;\nconst LL LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n\nint dp[1123456] = {};\nint dp2[1123456] = {};\n\nsigned main(int argc, char const *argv[])\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    REP(i,1123456) {\n        dp[i] = INF;\n        dp2[i] = INF;\n    }\n    dp[0] = 0;\n    dp2[0] = 0;\n    VL tetra;\n    VL oddtetra;\n    int cnt = 1;\n    while(1){\n        LL tmp = cnt * (cnt+1) * (cnt+2) / 6;\n        if(tmp <= 1e6){\n            tetra.eb(tmp);\n            if(tmp % 2 == 1) oddtetra.eb(tmp);\n            cnt++;\n        }\n        else{\n            break;\n        }\n    }\n    //dump(cnt)\n    //cout << printVector(tetra) << endl;\n\n    for(int p : tetra){\n        FOR(i,p,1000456){\n            dp[i] = min(dp[i-p]+1, dp[i]);\n        }\n    }\n    for(int p : oddtetra){\n        FOR(i,p,1000456){\n            dp2[i] = min(dp2[i-p]+1, dp2[i]);\n        }\n    }\n\n    //REP(i,50){\n    //    cout << i << \":\" << dp2[i] << endl;\n    //}\n    while(1){\n        int x; cin >> x;\n        if(x == 0) break;\n\n        cout << dp[x] << \" \" << dp2[x] << endl;\n    }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nint N;\n\nint L[200];\nint M[200];\nint M_max;\n\nvoid init() {\n    for (int i = 1; i <= 200; i++) {\n        L[i - 1] = (i * (i + 1) * (i + 2)) / 6;\n    }\n\n    int j = 0;\n    for (int i = 0; i < 200; i++) {\n        if (L[i] % 2 == 1) {\n            M[j++] = L[i];\n        }\n    }\n    M_max = j;\n}\n\nint f(int nth, int s) {\n    int r = N - s;\n    int start = distance(L, upper_bound(L, L + 200, r)) - 1;\n\n    int m = 100;\n    for (int i = start; i >= 0 && r <= (5 - nth) * L[i]; i--) {\n        if (r == L[i]) {\n            return nth + 1;\n        }\n\n        m = min(m, f(nth + 1, s + L[i]));\n    }\n\n    return m;\n}\n\nint g(int nth, int s) {\n    int r = N - s;\n    int start = distance(M, upper_bound(M, M + M_max, r)) - 1;\n\n    int m = 100;\n    for (int i = start; i >= 0; i--) {\n        if (r == M[i]) {\n            return nth + 1;\n        }\n\n        m = min(m, g(nth + 1, s + M[i]));\n    }\n\n    return m;\n}\n\nvoid solve() {\n    printf(\"%d %d\\n\", f(0, 0), g(0, 0));\n}\n\nint main() {\n    init();\n    while (true) {\n        cin >> N;\n        if (!N) {\n            break;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint a[200];\nint b[200];\nint pollock[1000001];\nint oddpollock[1000001];\nint n,count;\n\nvoid f(){\n\tcount=1;\n\tb[0]=1;\n\ta[0]=1;\n\tfor(int i=1;i<200;i++){\n\t\ta[i]=a[i-1]*(i+3)/i;\n\t\tif(a[i]%2==1){\n\t\t\tb[count]=a[i];\n\t\t\tcount++;\n\t\t}\n\t}\n}\n\nint main(){\n\tf();\n\tpollock[0]=oddpollock[0]=0;\n\tpollock[1]=oddpollock[1]=1;\n\tfor(int i=2;i<1000000;i++){\n\t\tpollock[i]=pollock[i-1]+1;\n\t\tfor(int j=1;i>=a[j];j++){\n\t\t\tif(pollock[i]>pollock[i-a[j]]+1)pollock[i]=pollock[i-a[j]]+1;\n\t\t}\n\t}\n\tfor(int i=2;i<1000000;i++){\n\t\toddpollock[i]=oddpollock[i-1]+1;\n\t\tfor(int j=1;i>=b[j];j++){\n\t\t\tif(oddpollock[i]>oddpollock[i-b[j]]+1)oddpollock[i]=oddpollock[i-b[j]]+1;\n\t\t}\n\t}\n\twhile(1){\n\t\tcin >>n;\n\t\tif(n==0)break;\n\t\tcout <<pollock[n] <<\" \" <<oddpollock[n] <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n    vi four;\n    int n = 1;\n    while(true) {\n        int num = n*(n+1)*(n+2)/6;\n        if(num > 1000000) {\n            break; \n        } else {\n            four.push_back(num);\n            n++;\n        }\n    }\n    int fsize = four.size();\n\n    vi dp(1000000+1, INF);\n    vi dpk(1000000+1, INF);\n    dp[0] = dpk[0] = 0;\n \n    FOR(i, 1, 1000000) {\n        REP(j, fsize) {\n            if(i-four[j] >= 0) {\n                dp[i] = min(dp[i-four[j]]+1, dp[i]);\n                if(four[j]%2) {\n                    dpk[i] = min(dpk[i-four[j]]+1, dpk[i]);\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    while(cin >> n, n) {\n        cout << dp[n] << \" \" << dpk[n] << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\nunsigned int tetra[190];\n\nclass Node{\npublic:\n\tint deep;\n\tint sum;\n\tint num;\n\tNode(int d,int s,int n){\n\t\tdeep=d;\n\t\tsum=s;\n\t\tnum=n;\n\t}\n\tbool operator < (const Node &o) const{\n\t\treturn deep >o.deep;\n\t}\n};\ntypedef queue <Node> Q;\n\nint bfs(int limit){\n\tQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.front();\n\t\tpq.pop();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=182;i++){\n\t\t\tif(cur.sum+tetra[i]>limit)break;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+tetra[i],i));\n\t\t}\n\t}\n\treturn -1;\n}\nint bfs2(int limit){\n\tQ pq;\n\tpq.push(Node(0,0,1));\n\twhile(!pq.empty()){\n\t\tNode cur=pq.front();\n\t\tpq.pop();\n\t\tif(cur.sum==limit)return cur.deep;\n\t\tfor(int i=cur.num;i<=182;i++){\n\t\t\tif(cur.sum+tetra[i]>limit)break;\n\t\t\tif(!(tetra[i]%2))continue;\n\t\t\tpq.push(Node(cur.deep+1,cur.sum+tetra[i],i));\n\t\t}\n\t}\n\treturn -1;\n}\n\nint\nmain(){\n\ttetra[1]=1;\n\tfor(int i=0;i<=192;i++){\n\t\ttetra[i]=(i*(i+1)*(i+2))/6;\n\t}\n\twhile(true){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tint count;\n\t\tif((count=bfs(n))>0){\n\t\t\tcout<<count;\n\t\t}\n\t\tif((count=bfs2(n))>0){\n\t\t\tcout<<\" \"<<count<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <string.h>\n\nusing namespace std;\n\nint f[1000001];\n\nint main()\n{\n\tint t_num[182];\n\tint t_num_odd[182];\n\t\n\tint k=0;\n\tfor (int i=1;i<182;++i)\n\t{\n\t\tt_num[i-1] = i*(i+1)*(i+2)/6;\n\t\tif (t_num[i-1] % 2 == 1)\n\t\t{\n\t\t\tt_num_odd[k] = t_num[i-1];\n\t\t\t++k;\n\t\t}\t\t\n\t}\n\t\n\tint n;\n\tcin >> n;\n\t\n\twhile (n)\n\t{\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tfor (int j=0;j<181;++j)\n\t\t\t{\n\t\t\t\tif (i>=t_num[j]) f[i] = min(f[i],f[i-t_num[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << \" \";\n\t\t\n\t\tmemset(f,1000001,sizeof(f));\n\t\tf[0] = 0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t{\n\t\t\tfor (int j=0;j<k;++j)\n\t\t\t{\n\t\t\t\tif (i>=t_num_odd[j]) f[i] = min(f[i],f[i-t_num_odd[j]]+1);\n\t\t\t}\n\t\t}\n\t\tcout << f[n] << endl;\n\t\t\n\t\tcin >> n;\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint MAX;\nvector<int> V;\nvector<int> D;\nint N;\nint M;\n\nvoid solve(int n) {\n\tbool **dp = new bool*[6];\n\tfor (int i=0; i<6; i++) {\n\t\tdp[i] = new bool[MAX+10];\n\t\tfor (int j=0; j<MAX+10; j++)\n\t\t\tdp[i][j] = 0;\n\t}\n\n\tfor (int i=0; i<N; i++)\n\t\tdp[0][V[i]] = 1;\n\n\tfor (int i=1; i<5; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp[i-1][j]) continue;\n\t\t\tfor (int k=0; j+V[k]<=n; k++)\n\t\t\t\tdp[i][j+V[k]] = 1;\n\t\t}\n\t}\n\n\tfor (int i=0; i<5; i++) {\n\t\tif (dp[i][n]) {\n\t\t\tcout << i+1 << \" \";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i=0; i<6; i++)\n\t\tdelete [] dp[i];\n\tdelete [] dp;\n\n\n\t// \n\tbool **dp2 = new bool*[n+5];\n\tfor (int i=0; i<n+5; i++) {\n\t\tdp2[i] = new bool[MAX+10];\n\t\tfor (int j=0; j<MAX+10; j++)\n\t\t\tdp2[i][j] = 0;\n\t}\n\n\tfor (int i=0; i<M; i++)\n\t\tdp2[0][D[i]] = 1;\n\t\n\tfor (int i=1; i<n; i++) {\n\t\tfor (int j=0; j<n; j++) {\n\t\t\tif (!dp2[i-1][j]) continue;\n\t\t\tfor (int k=0; j+D[k]<=n; k++)\n\t\t\t\tdp2[i][j+D[k]] = 1;\n\t\t}\n\t}\n\n\tfor (int i=0; i<n; i++) {\n\t\tif (dp2[i][n]) {\n\t\t\tcout << i+1 << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int i=0; i<n+5; i++)\n\t\tdelete [] dp2[i];\n\tdelete [] dp2;\n}\n\nint main() {\n\tMAX = (int)pow(10.0, 6);\n\tfor (int i=1; i*(i+1)*(i+2)/6<=MAX; i++) {\n\t\tV.push_back(i*(i+1)*(i+2)/6);\n\t\tif ( (i*(i+1)*(i+2)/6)%2==1 ) D.push_back(i*(i+1)*(i+2)/6);\n\t}\n\tN = (int)V.size();\n\tM = (int)D.size();\n\n\tint n;\n\tcin >> n;\n\twhile (n!=0) { \n\t\tsolve(n);\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nint dp[5000001];\nint dp2[5000001];\n\nint func(int v){\n\tif(dp[v]!=11451419)return dp[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n\t\tif(v-i*(i+1)*(i+2)/6>=0)cnt=min(cnt,func(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp[v]=cnt+1);\n}\n\nint func2(int v){\n\tif(dp2[v]!=11451419)return dp2[v];\n\tif(v==0)return 0;\n\tint cnt=11451419;\n\tfor(int i=1;i*(i+1)*(i+2)/6<=1000000;i++){\n\t\tif((i*(i+1)*(i+2)/6)%2!=1)continue;\n\t\tif(v-i*(i+1)*(i+2)/6>=0)cnt=min(cnt,func2(v-i*(i+1)*(i+2)/6));\n\t}\n\treturn (dp2[v]=cnt+1);\n}\n\nint main(void){\n\tint n;\n\tfor(int i=1;i<=2000000;i++)dp[i]=dp2[i]=11451419;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tprintf(\"%d %d\\n\",func(n),func2(n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <stdlib.h>\n#include <string.h>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <stdio.h>\n#include <tuple>\n#include <bitset>\n#include <cfloat>\n#include <fstream>\n#include <limits.h>\n#include <list>\n#include <math.h>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <cassert>\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nusing namespace std;\n#define int long long\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define P pair<ll, ll>\n#define sz(x) (ll)x.size()\n#define ALL(x) (x).begin(),(x).end()\n#define ALLR(x) (x).rbegin(),(x).rend()\n#define VE vector<ll>\n#define COUT(x) cout<<(x)<<endl\n#define MA map<ll,ll>\n#define SE set<ll>\n#define PQ priority_queue<ll>\n#define PQR priority_queue<ll,VE,greater<ll>>\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define EPS (1e-14)\n#define pb push_back\nlong long MOD = 1000000007;\n//const long long MOD = 998244353;\nconst long long INF = 1LL << 60;\nconst double PI = acos(-1.0);\nusing Graph = vector<VE>;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%MOD + MOD) % MOD) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\nstruct combination {\n\tvector<mint> fact, ifact;\n\tcombination(int n) :fact(n + 1), ifact(n + 1) {\n\t\t//assert(n < MOD);\n\t\tfact[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n\t\tifact[n] = fact[n].inv();\n\t\tfor (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n\t}\n\tmint operator()(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn fact[n] * ifact[k] * ifact[n - k];\n\t}\n}com(10);\nstruct Sieve {\n\tint n;\n\tvector<int> f, primes;\n\t\n\tSieve(int n = 1) :n(n), f(n + 1) {\n\t\tf[0] = f[1] = -1;\n\t\tfor (ll i = 2; i <= n; ++i) {\n\t\t\tif (f[i]) continue;\n\t\t\tprimes.push_back(i);\n\t\t\tf[i] = i;\n\t\t\tfor (ll j = i * i; j <= n; j += i) {\n\t\t\t\tif (!f[j]) f[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool isPrime(int x) { return f[x] == x; }\n\t\n\tvector<int> factorList(int x) {\n\t\tvector<int> res;\n\t\twhile (x != 1) {\n\t\t\tres.push_back(f[x]);\n\t\t\tx /= f[x];\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<P> factor(int x) {\n\t\tvector<int> fl = factorList(x);\n\t\tif (fl.size() == 0) return {};\n\t\tvector<P> res(1, P(fl[0], 0));\n\t\tfor (int p : fl) {\n\t\t\tif (res.back().first == p) {\n\t\t\t\tres.back().second++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.emplace_back(p, 1);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nclass UnionFind {\npublic:\n\tvector <ll> par; \n\tvector <ll> siz; \n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1) {\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.resize(sz_, 1);\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { \n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; \n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\t\t\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\tbool issame(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) {\n\t\treturn siz[root(x)];\n\t}\n};\ntemplate<class t> t gcd(t a, t b) { return b != 0 ? gcd(b, a % b) : a; }\nll lcm(ll a, ll b) {\n\tll g = gcd(a, b);\n\treturn a * b / g;\n}\nbool prime(ll n) {\n\tfor (ll i = 2; i <= sqrt(n); i++) {\n\t\tif (n%i == 0)return false;\n\t}\n\treturn n != 1;\n}\nmap<ll, ll> prime_factor(ll n) {\n\tmap<ll, ll> ret;\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tret[i]++;\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n != 1) ret[n] = 1;\n\treturn ret;\n}\nll modinv(ll a, ll m) {\n\tll b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvector<pair<char, int>> RunLength(string s) {\n\tif (s.size() == 0)return {};\n\tvector<pair<char, int>>res(1, pair<char, int>(s[0], 0));\n\tfor (char p : s) {\n\t\tif (res.back().first == p) {\n\t\t\tres.back().second++;\n\t\t}\n\t\telse {\n\t\t\tres.emplace_back(p, 1);\n\t\t}\n\t}\n\treturn res;\n}\n// Digit Count\nint GetDigit(int num) {\n\treturn log10(num) + 1;\n}\n// bit calculation[how many \"1\"] (= __builtin_popcount())\nint bit_count(int n) {\n\tint cnt = 0;\n\twhile (n > 0) {\n\t\tif (n % 2 == 1)cnt++;\n\t\tn /= 2;\n\t}\n\treturn cnt;\n}\nmint POW(mint n, int p) {\n\tif (p == 0)return 1;\n\tif (p % 2 == 0) {\n\t\tmint t = POW(n, p / 2);\n\t\treturn t * t;\n\t}\n\treturn n * POW(n, p - 1);\n}\n\nconst ll dx[4] = { 1,0,-1,0 };\nconst ll dy[4] = { 0,1,0,-1 };\nstruct edge { ll to, cost; };\ntypedef long double ld;\nint dp[1000010];\nint dp2[1000010];\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t//cout << fixed << setprecision(15);\n\tint n;\n\tVE a, b;\n\trep(i, 200) {\n\t\tif (i == 0)continue;\n\t\ta.push_back(i*(i + 1)*(i + 2) / 6);\n\t\tif ((i * (i + 1)*(i + 2) / 6) % 2 == 1)b.push_back(i*(i + 1)*(i + 2) / 6);\n\t}\n\trep(i, 1000010) {\n\t\tdp[i] = INF, dp2[i] = INF;\n\t}\n\tdp[0] = 0; dp2[0] = 0;\n\trep(i, a.size()) {\n\t\tfor (int j = a[i]; j <= 1000010; j++) {\n\t\t\tchmin(dp[j], dp[j - a[i]] + 1);\n\t\t}\n\t}\n\trep(i, b.size()) {\n\t\tfor (int j = b[i]; j <= 1000010; j++) {\n\t\t\tchmin(dp2[j], dp2[j - b[i]] + 1);\n\t\t}\n\t}\n\twhile (cin >> n) {\n\t\tif (n == 0)break;\n\t\tcout << dp[n] <<\" \"<< dp2[n] << endl;\n\t}\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iterator>\n\nusing namespace std;\n\nint N;\n\nint L[200];\nint M[200];\nint M_max;\nint dp[1000001];\n\nvoid init() {\n    for (int i = 1; i <= 200; i++) {\n        L[i - 1] = (i * (i + 1) * (i + 2)) / 6;\n    }\n\n    int j = 0;\n    for (int i = 0; i < 200 && L[i] <= 1000000; i++) {\n        if (L[i] % 2 == 1) {\n            M[j++] = L[i];\n        }\n    }\n    M_max = j;\n\n    for (int i = 0; i <= 1000000; i++) {\n        dp[i] = 10000000;\n    }\n    dp[0] = 0;\n    for (int i = 1; i <= 1000000; i++) {\n        for (int j = 0; j < M_max && M[j] <= i; j++) {\n            dp[i] = min(dp[i], dp[i - M[j]] + 1);\n        }\n    }\n}\n\nint f(int nth, int s) {\n    int r = N - s;\n    int start = distance(L, upper_bound(L, L + 200, r)) - 1;\n\n    int m = 100;\n    for (int i = start; i >= 0 && r <= (5 - nth) * L[i]; i--) {\n        if (r == L[i]) {\n            return nth + 1;\n        }\n\n        m = min(m, f(nth + 1, s + L[i]));\n    }\n\n    return m;\n}\n\nvoid solve() {\n    printf(\"%d %d\\n\", f(0, 0), dp[N]);\n}\n\nint main() {\n    init();\n    while (true) {\n        scanf(\"%d\", &N);\n        if (!N) {\n            break;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1000000],kisuu[1000000];\nint main(){\n    fill(dp,dp+1000000,1<<29);\n    fill(kisuu,kisuu+1000000,1<<29);\n    dp[0]=0;\n    kisuu[0]=0;\n    for(int i=1;i<500;i++){\n\tint s=i*(i+1)*(i+2)/6;\n\t    for(int j=s;j<1000000;j++){\n\t    dp[j]=min(dp[j],dp[j-s]+1);\n\t    }\n\t    if((s&1)==0)continue;\n\t    for(int j=s;j<1000000;j++){\n\t    kisuu[j]=min(kisuu[j],kisuu[j-s]+1);\n\t    }\n\t}\n\tint k;\n\twhile(cin>>k,k){\n\t    cout<<dp[k]<<\" \"<<kisuu[k]<<endl;\n\t    }\n    }"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint all[N+1],odd[N+1];\nint pollock[1000];\nint num;\n\nint BackTrack(int n,int type){\n  int i,tmp,ans = N+1;\n  if(type && odd[n]<=N)return odd[n];\n  if(!type && all[n]<=N)return all[n];\n  //if(n==0)return 0;\n\n  for(i=num-1;i>=0;i--){\n    //printf(\"%d\\n\",pollock[i]);\n    if(pollock[i]>n)continue;\n    if(type && !(pollock[i]&1) )continue;\n    tmp = BackTrack(n-pollock[i],type);\n    if(ans > tmp+1)ans = tmp+1;\n  }\n\n  if(type)odd[n] = ans;\n  if(!type)all[n] = ans;\n  return ans;\n}\n\nint main(){\n  int i,n,tmp;\n\n  for(i=0;i<=N;i++)all[i] = odd[i] = N+1;\n  all[0] = odd[0] = 0;\n\n  for(num=1;;num++){\n    tmp = num*(num+1)*(num+2)/6;\n    if(tmp>N)break;\n    pollock[num-1] = tmp;\n  }\n  num--;\n  while(scanf(\"%d\",&n) && n){\n    printf(\"%d %d\\n\",BackTrack(n,0),BackTrack(n,1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nvector<ll> seis;\nvector<ll> dp(1000000+1,190);\nvector<ll> odp(1000000+1,190);\n\nbool solve(){\n    ll n;\n    cin>>n;\n    if(n==0)return false;\n\n    cout<<dp[n]<<\" \"<<odp[n]<<\"\\n\";\n    return true;\n}\n\nint main() {\n    ll t=1;\n    ll n=1;\n    while(t<=1000000) {\n        t=n*(n+1)*(n+2)/6;\n        seis.emplace_back(t);\n        ++n;\n    }\n\n    dp[0]=0;\n    for(int i = 1;i <= 1000000;++i) {\n        dp[i]=i;\n        for(int j = 0;j < 181;++j) {\n            if(i<seis[j])break;\n\n            dp[i]=min(dp[i],dp[i-seis[j]]+1);\n        }\n        //cerr<<dp[i]<<endl;\n    }\n\n    odp[0]=0;\n    for(int i = 1;i <= 1000000;++i) {\n        odp[i]=i;\n        for(int j = 0;j < 181;++j) {\n            if(i<seis[j])break;\n            if(seis[j]%2==0)continue;\n\n            odp[i]=min(odp[i],odp[i-seis[j]]+1);\n        }\n    }\n\n\n\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include \"math.h\"\n \nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vin;\ntypedef vector<vin> vvin;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vp;\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define drep(i,a,b) for(ll i=(a);i>=(b);--i)\n#define SIZE(a) int((a).size())\nconst int MOD=1e9+7;\n\nint main(){\n  vll w(200);vvll dp(1000001,vll(2,MOD));\n  rep(i,0,200){\n    w[i]=((i+1)*(i+2)*(i+3))/6;\n    \n  }\n  dp[0][0]=dp[0][1]=0;\n  rep(i,1,1000001){\n    rep(j,0,200){\n      if(i>=w[j]&&dp[i-w[j]][0]!=MOD){\n        dp[i][0]=min(dp[i-w[j]][0]+1,dp[i][0]);\n        if(w[j]%2&&dp[i-w[j]][1]!=MOD){dp[i][1]=min(dp[i-w[j]][1]+1,dp[i][1]);}\n      }\n    }\n  }\n  ll n=1;\n  while(n!=0){\n    cin>>n;\n    if(n==0)break;\n    cout<<dp[n][0]<<\" \"<<dp[n][1]<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\n\ntypedef long long ll;\n\nll f(ll n) {\n\treturn n * (n+1) * (n+2) / 6;\n}\n\nvector<int> makeS(int mod, int d) {\n\tint n = 1;\n\tvector<int> res;\n\twhile (1) {\n\t\tif ( f(n) > N ) break;\n\t\tif ( f(n) % mod == d ) {\n\t\t\tres.push_back( f(n) );\n\t\t}\n\t\t++n;\n\t}\n\treturn res;\n}\n\nconst int inf = 1e9;\nconst int maxN = 1000000;\nint dp[maxN+1];\nint solve(const vector<int>& s) {\n\tfill(dp, dp+maxN, inf); dp[0] = 0;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tfor (int j = 0; j <= N; ++j) {\n\t\t\tint nj = j + s[i];\n\t\t\tif (nj <= N) {\n\t\t\t\tdp[nj] = min(dp[nj], dp[j]+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[N];\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tvector<int> s0 = makeS(1, 0);\n\t\tvector<int> s1 = makeS(2, 1);\n\t\tcout << solve(s0) << \" \" << solve(s1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    ////\n    int dp[100000];\n    //fill(dp,dp + x+1,100000);\n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t}\n      }\n    }\n\n    cout << dp[x] << \" \";\n    //fill(dp,dp + x + 1,100000);\n  \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    //printf(\"%d\\n\",count_ki);\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t // dp[i+coin_ki[j]]=min(dp[i+coin_ki[j]],dp[i]+1);\n\t}\n      }\n    }\n   \n    cout << dp[x] << endl;\n  \n    ///*/\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define rep(i, j) for(int i = 0; i < j; i++)\n#define f(i, k, j) for(int i = k; i < j; i++)\n#define P pair<int, int>\nconst int INF = 1000010;\n\nint n, dp[INF], dp2[INF];\nvector<int> c, ctmp;\n\nvoid solve(){\n    for(int i = 2; ; i++){\n        int tmp = (i * (i + 1) * (i + 2)) / 6;\n        if(tmp >= INF) break;\n        else{\n            c.push_back(tmp);\n            if(tmp % 2 == 1) ctmp.push_back(tmp);\n        }\n    }\n    rep(i, INF){\n        dp[i] = i;\n        dp2[i] = i;\n    }\n\n    rep(i, c.size()){\n        for(int j = c[i]; j < INF; j++){\n            dp[j] = min(dp[j], dp[j - c[i]] + 1);\n        }\n    }\n    rep(i, ctmp.size()){\n        for(int j = ctmp[i]; j < INF; j++){\n            dp2[j] = min(dp2[j], dp2[j - ctmp[i]] + 1);\n        }\n    }\n}\n\nint main(){\n    solve();\n    while(cin >>n && n){\n        cout <<dp[n] <<\" \" <<dp2[n] <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define N 1000000\n#define INFINITY 2000000000\nusing namespace std;\nint DP(int);\nint DP2(int);\nint m=1,m2=1;\nint dp[N],dp2[N],data[N];\nvector<int> data2;\nint main(){\n  int i,out,out2,n,c;\n  data2.push_back(0);\n  for(i=1;i<N;i++){\n    data[i]=i*(i+1)*(i+2)/6;\n    if(data[i]>N){\n      c=i;\n    }\n    if(data[i]%2==1){\n      data2.push_back(data[i]);\n    }\n  }\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    out=DP(n);\n    out2=DP2(n);\n    cout << out << ' ' << out2 << endl;\n  }\n  return 0;\n}\nint DP(int n){\n  int i,j,s;\n  for(i=1;i<N;i++){\n    if(data[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  if(s>=m){\n    m=s;\n    for(i=0;i<=n;i++) dp[i]=INFINITY;\n    dp[0]=0;\n    for(i=1;i<=s;i++){\n      for(j=data[i];j<=n;j++){\n\tdp[j]=min(dp[j],dp[j-data[i]]+1);\n      }\n    }\n  }\n  return dp[n];\n}\nint DP2(int n){\n  int i,j,s,len;\n  len=data2.size();\n  for(i=1;i<len;i++){\n    if(data2[i]>n){\n      s=i-1;\n      break;\n    }\n  }\n  if(s>=m2){\n    m2=s;\n    for(i=0;i<=n;i++) dp2[i]=INFINITY;\n    dp2[0]=0;\n    for(i=1;i<=s;i++){\n      for(j=data2[i];j<=n;j++){\n\tdp2[j]=min(dp2[j],dp2[j-data2[i]]+1);\n      }\n    }\n  }\n  return dp2[n];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<deque>\n#include<list>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\n#define MAX 1000000\n\nvector<int> p;\n\nint main() {\n\tp.push_back(0);\n\tfor (int i = 1; p[i - 1] < MAX; i++) {\n\t\tp.push_back(i*(i + 1)*(i + 2) / 6);\n\t\t//cout << p[i] << endl;\n\t}\n\n\tstatic int dp[MAX + 1], dp2[MAX + 1];\n\n\tfor (int i = 0; i <= MAX; i++) {\n\t\tdp[i] = dp2[i] = i;\n\t}\n\n\tfor (int i = 1; i < p.size() - 1; i++) {\n\t\t//cout << i << \" \";\n\t\tfor (int j = p[i]; j <= MAX; j++) {\n\t\t\tdp[j] = min(dp[j - p[i]] + 1, dp[j]);\n\t\t}\n\n\t\tif (p[i] % 2 == 1) {\n\t\t\tfor (int j = p[i]; j <= MAX; j++) {\n\t\t\t\tdp2[j] = min(dp2[j - p[i]] + 1, dp2[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int n; cin >> n, n;) {\n\t\tcout << dp[n] << \" \" << dp2[n] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-8;\n\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n#define MAX_N 1000000\nint memo[MAX_N+1];\n\nint plc(int n) { return n * (n + 1) * (n + 2) / 6; }\n\nint solve(int n, bool skip_even) {\n  fill(memo, memo+MAX_N+1, 1<<30);\n  for (int i = 1; plc(i) <= MAX_N; i++) {\n    if (skip_even && plc(i) % 2 == 0) continue;\n    memo[plc(i)] = 1;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; plc(j) <= i; j++) {\n      if (skip_even && plc(j) % 2 == 0) continue;\n      memo[i] = min(memo[i], memo[i-plc(j)] + 1);\n    }\n  }\n  return memo[n];\n}\n\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int n;\n  while (cin >> n, n) {\n    cout << solve(n, false) << \" \" << solve(n, true) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define  M 1e6\nusing namespace std;\ntypedef long long int ll;\nvector<ll> x,y;\nll f(int n){\n\treturn n*(n+1)*(n+2)/6;\n}\nvoid make(void){\n\tint i=1;\nwhile(f(i)<M){\nx.push_back(f(i));\nif(f(i)%2==1){\n\ty.push_back(f(i));\n}\n\ti++;\n}\n}\nint main(void){\n\tmake();\nvector<ll> num(M,6),num2(M,1000000);\nfor(ll i=0;i<x.size();i++){\nnum[x[i]]=1;\n}\nfor(ll i=0;i<y.size();i++){\n\tnum2[y[i]]=1;\n}\nfor(ll i=0;i<x.size();i++){\n\tfor(ll j=x[i];j<M;j++){\n\t\tnum[j]=min(num[j],num[j-x[i]]+1);\n\t}\n}\nfor(ll i=0;i<y.size();i++){\n\tfor(ll j=y[i];j<M;j++){\n\t\tnum2[j]=min(num2[j],num2[j-y[i]]+1);\n\t}\n}\nint n;\n\nwhile(1){\n\tcin>>n;\n\tif(n==0)break;\n\n\tcout<<num[n]<<\" \"<<num2[n]<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\nconst int MAX = (int)1e6 + 1;\n\nint main() {\n    // pre\n    vector<int> tetras(1, 0);\n    for (int i = 1; ; i++) {\n        int t = [](int n){ return n * (n + 1) * (n + 2) / 6; }(i);\n        if (t > 1e6) break;\n        tetras.push_back(t);\n    }\n    // cout << tetras.size() << endl;  // 180\n\n    // dp_all, dp_odd\n    vector<int> dp_all(MAX, INF), dp_odd(MAX, INF);\n    dp_all[0] = dp_odd[0] = 0;\n    for (int cur : tetras) {\n        for (int j = cur; j < MAX; j++) {\n            dp_all[j] = min(dp_all[j], dp_all[j - cur] + 1);\n            if (cur % 2) dp_odd[j] = min(dp_odd[j], dp_odd[j - cur] + 1);\n        }\n    }\n\n    // post\n    int n;\n    while (cin >> n, n) {\n        cout << dp_all[n] << \" \" << dp_odd[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n\n#define INF (int)1e09\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::setprecision;\nusing std::fixed;\nusing std::pair;\nusing std::make_pair;\nusing std::min;\nusing std::max;\nusing std::string;\nusing std::vector;\nusing std::list;\nusing std::map;\nusing std::set; // insert erase find count\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n\ntypedef vector<int> VI;\ntypedef vector<vector<int> > VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, pair<int, int> > PIII;\n\nint main(void) {\n    int bas = 0;\n    int tri = 0;\n    int fou = 0;\n\n    VI total;\n    VI odd;\n\n    VI ans_total(1e06, INF);\n    VI ans_odd(1e06, INF);\n\n    while (1) {\n        bas++;\n        tri += bas;\n        fou += tri;\n        if (fou >= 1e06) {\n            break;\n        }\n        total.push_back(fou);\n        ans_total[fou] = 1;\n        if (fou % 2 == 1) {\n            odd.push_back(fou);\n            ans_odd[fou] = 1;\n        }\n\n    }\n    int size_total = (int)total.size();\n    int size_odd = (int)odd.size();\n    int posi;\n\n    for (int i = 0; i < size_total; i++) {\n        posi = total[i];\n        for (int j = posi + 1; j < 1e06; j++) {\n            ans_total[j] = min(ans_total[j], ans_total[posi] + ans_total[j - posi]);\n        }\n    }\n    for (int i = 0; i < size_odd; i++) {\n        posi = odd[i];\n        for (int j = posi + 1; j < 1e06; j++) {\n            ans_odd[j] = min(ans_odd[j], ans_odd[posi] + ans_odd[j - posi]);\n        }\n    }\n\n    int input;\n    while (1) {\n        cin >> input;\n        if (input == 0) {\n            break;\n        }\n        cout << ans_total[input] << \" \" << ans_odd[input] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define pb push_back \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i, n) for( int i = 0; i < (n); i++ )\n#define Rrep(i, a, n) for( int i = (a); i < (n); i++ )\n#define All(v) v.begin(), v.end()\n\ntypedef pair<int, int> Pii; \ntypedef pair<int, Pii> Pip;\n//const int INF = 1107110711071107;\n\nint dp[1000001];\nint dp_odd[1000001];\nint four[210];\nint x;\n\nsigned main() {\n  Rep(i, 210) four[i] = i * (i+1) * (i+2) / 6;\n  \n  Rep(i, 1000001) dp[i] = i;\n  Rrep(i, 2, 200) {\n    Rep(j, 1000001) {\n      if ( j+four[i] <= 1000000 ) {\n\tdp[j+four[i]] = min(dp[j+four[i]], dp[j]+1);\n      }\n    }\n  }\n\n  Rep(i, 1000001) dp_odd[i] = i;\n  Rrep(i, 2, 40) {\n    Rep(j, 1000001) {\n      dp_odd[j] = min(dp_odd[j], dp_odd[j]);\n      if ( j+four[(i-1)*4+1] <= 1000000 ) {\n\tdp_odd[j+four[(i-1)*4+1]] = min(dp_odd[j+four[(i-1)*4+1]], dp_odd[j]+1);\n      }\n    }\n  }\n \n  while ( cin >> x, x ) {\n    cout << dp[x] << \" \" << dp_odd[x] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\n\tint n,table[200];\n\tint* dp = new int[1000000];\n\tint* odd_dp = new int[1000000];\n\n\tfor(int i=0; i < 200; i++)table[i] = i*(i+1)*(i+2)/6;\n\n\tfor(int i=0; i < 1000000; i++){\n\t\todd_dp[i] = 20000000;\n\t\tdp[i] = 20000000;\n\t}\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\n\tfor(int i = 2; i < 1000000; i++){\n\t\tfor(int k = 1; k < 200; k++){\n\t\t\tif(table[k] <= i){\n\t\t\t\tdp[i] = (dp[i] <= dp[i-table[k]]+1)?dp[i]:dp[i-table[k]]+1;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\todd_dp[0] = 0;\n\todd_dp[1] = 1;\n\n\tfor(int i = 2; i < 1000000; i++){\n\t\tfor(int k = 1; k < 200; k++){\n\t\t\tif(table[k] <= i && table[k]%2 == 1){\n\t\t\t\todd_dp[i] = (odd_dp[i] <= odd_dp[i-table[k]]+1)?odd_dp[i]:odd_dp[i-table[k]]+1;\n\t\t\t}else if(table[k] > i)break;\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tprintf(\"%d %d\\n\",dp[n],odd_dp[n]);\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  vector<int> T;\n  {\n    int t = 1;\n    while(true){\n      long long s = t*(t+1)*(t+2)/6;\n      if(s > 1e6) break;\n      T.push_back(s);\n      ++t;\n    }\n  }\n  const int INF = 1e9;\n\n  int n = 1e6;\n\n  vector<int> dp(n+1,INF), dp2(n+1,INF);\n  dp[0] = 0;\n  dp2[0] = 0;\n  for(int i = 0; i <= n; ++i){\n    for(auto e : T){\n      if(i+e > n) break;\n      dp[i+e] = min(dp[i+e],dp[i]+1);\n      if(e%2)\n        dp2[i+e] = min(dp2[i+e],dp2[i]+1);\n    }\n  }\n\n\n  while(cin >> n, n){\n    cout << dp[n] << \" \" << dp2[n] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const MAX = 1000001;\nint const INF = 1<<29;\nint dpa[MAX+1];\nint dpo[MAX+1];\n\nint main() {\n  \n  \n  fill(dpa, dpa+MAX, INF);\n  fill(dpo, dpo+MAX, INF);\n  \n  dpa[0] = dpo[0] = 0;\n  \n  for(int i=1; ; i++) {\n    int n = i*(i+1)*(i+2)/6;\n    if(n > MAX) break;\n    for(int j=n; j<=MAX; j++) {\n      dpa[j] = min(dpa[j], dpa[j-n]+1);\n      if(n%2) {\n\tdpo[j] = min(dpo[j], dpo[j-n]+1);\n      }\n    }\n  }\n  \n  for(int N; cin >> N && N;) {\n    cout << dpa[N] << ' ' << dpo[N] << endl;\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000005LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\nstatic const int N = 1000005;\n\nint n;\nll K;\nint dp[N],dpo[N];\nll pollock[N],oollock[N];\nll pmax,omax;\nint cmax;\nint a;\n\nint pol()\n{\n\tscanf(\"%d\",&n);\n\tif(n==0)return -1;\n\tif(cmax>=n){\n\t\ta = dpo[n];\n\t\treturn dp[n];\n\t}\n\twhile(pollock[pmax]<=n){\n\t\tpmax++;\n\t\tpollock[pmax] = pmax*(pmax+1)*(pmax+2)/6;\n\t\tif(pollock[pmax]%2==1){\n\t\t\tomax++;\n\t\t\toollock[omax]=pollock[pmax];\n\t\t}\n\t}\n\tint k=1,j=1,s=1,f=1;\n\tfor(int i=cmax+1;i<=n;i++){\n\t\twhile(pollock[j]<=i)j++;\n\t\tint minv = 9;\n\t\tfor(int c=(j-10>0?j-10:1);c<j;c++){\n\t\t\tminv = min(minv,dp[i-pollock[c]]+1);\n\t\t}\n\t\tdp[i] = minv;\n\n\t\twhile(oollock[k]<=i&&k<=omax){\n\t\t\tk++;\n\t\t}\n\t\tminv = 99;\n\t\tint c;\n\t\tfor(c=(k-10>0?1:1);c<k;c++){\n\t\t\tminv = min(minv,dpo[i-oollock[c]]+1);\n\t\t}\n\t\tdpo[i] = minv;\n\t\t//printf(\"(%d:%d)\",i,k);\n\t}\n\tcmax=n;\n\ta = dpo[n];\n\treturn dp[n];\n}\nint main(){\n\tpmax=0;\n\tcmax=omax=0;\n\tdp[0]=0;\n\tdpo[0]=0;\n\tpollock[0]=oollock[0]=0;\n\twhile(1){\n\t\tint p = pol();\n\t\tif(p==-1)return 0;\n\t\tprintf(\"%d %d\\n\",p,a);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main(void)\n{\n  for(;;){\n    int x;\n    cin >> x;\n\n    if(x==0)\n      break;\n\n    int count=0;\n    int count_ki=0;\n    int tmp;\n    \n\n    int coin[100000];\n    int coin_ki[100000];\n   \n    int tmp2=0;\n  \n    for(int i=1;i<x;i++){\n      tmp=i*(i+1)*(i+2)/6;\n      if(tmp>x)break;\n      coin[i-1]=tmp;\n      count=i;\n      if(coin[i-1]%2==1){\n\tcoin_ki[tmp2++]=coin[i-1];\n\tcount_ki=tmp2;\n      }\n    }\n    int dp[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp[i]=100000;\n\n    dp[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count-1;j++){\n\tif(i+coin[j]<=x){\n\t  //dp[i+coin[j]]=min(dp[i+coin[j]],dp[i]+1);\n\t  tmp=min(dp[i+coin[j]],dp[i]+1);\n\t  //dp[i+coin[j]]=tmp;\n\t}\n      }\n    }\n\n\n    int ans1=1;\n\n    int dp2[100000];\n    \n    for(int i=0;i<100000;i++)\n      dp2[i]=100000;\n\n\n\n    dp2[0]=0;\n    for(int i = 0;i<x;i++){\n      for(int j=0;j<count_ki;j++){\n\tif(i+coin_ki[j]<=x){\n\t  //dp2[i+coin_ki[j]]=min(dp2[i+coin_ki[j]],dp2[i]+1);\n\t  tmp=min(dp2[i+coin_ki[j]],dp[i]+1);\n\t  //dp[i+coin_ki[j]]=tmp;\n\t}\n      }\n    }\n   \n    \n    int ans2=1;\n    \n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  return 0;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm> // next_permutation\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <list>\n#include <numeric> //accumulate\n//#include <unordered_map> //???????????\\??¢??°\n#include <fstream> //ifstream, ofstream\n\n#define NDEBUG //NDEBUG??????????????????????????´???assert?????????????????????????????????NDEBUG????????????????????¨\n#include <cassert> //assert\n\n\nusing namespace std;\n\n//???????????°??????TEST????????????????????¬???????????????????????????????????¢????????????\n#define TEST //*******************************************************************************************************************************************\n//?????????????????¨??§?????\\????????????????????????????????°?????????????¨???????????????????dout???????????????????????§???????????¬??????????????????????????????????????????\n//??????????????????????????????????????????????????????????§?CPU???????£??????????????????§???TLE?????????????????????????????????????????§????????¨???                           ????????????????????????cerr????????£????????????????????????????????????\n#ifdef TEST\n#define dout cout\n#else\nstringstream dummy; //???????????°??????dout?????????????????????????????????\n#define dout dummy.str(\"\"); dummy.clear(stringstream::goodbit); dummy //dummy?????????????????????????????????????????¨?????¢?????¢???????????????\n//???????????¨??????????????????goodbit?????????????????????????????¨???????????´????????????????????????????????¨?????°?????????????????§???????????????????????????????????? http://d.hatena.ne.jp/linden/20060427/p1\n#endif\n\n//?¨??????????????????????????????????????????????????????´??????OUTPUT2TEXTFILE????????????????????¬???????????????????????????????????¢????????????\n//#define OUTPUT2TEXTFILE //*******************************************************************************************************************************************\n#ifdef OUTPUT2TEXTFILE\n#define dout outputfile //??¨????????????TLE????????§?????????dout?????¨??¨??????????????¢????????????????????????????????????????????§????¨????????????´??????????????£??????????????????????¨?????????????????????????????????????????????§?????????????????????\n//TEST??????????????????????????¨???outputfile??????????????????????????????\n#define OUTPUTFILENAME \"output.txt\"\nofstream outputfile(OUTPUTFILENAME);\n#define OutputFilePath \"/Users/Nag/Documents/Prgm/Test/DerivedData/Test/Build/Products/Debug/output.txt\"\n#endif\n\n#define disp(A) dout << #A << \" = \" << (A) << endl\n#define disP(A) dout << setw(3) << (A) << \" \" // << setw(3) ??????????????\\????????????\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n\n#define dispAll(A,n) dout << #A << \" = \"; rep(j, 0, (n)) {disP(A[j]);} dout << endl\n\ntypedef vector<int> vi;\nconst int INF = 1e9-1;\n\n\nint tetrahedral(int n) {\n    assert( (n*(n+1)*(n+2)) % 6 == 0);\n    return n*(n+1)*(n+2)/6;\n}\n\nint tetrahedralOdd(int n) {\n    n = n*4-3;\n    assert( (n*(n+1)*(n+2)) % 6 == 0);\n    return n*(n+1)*(n+2)/6;\n}\n\nint iMaxForTetrahedral(int x) { //?????¶??°x??\\???????????§?????£?????¢?????°???i?????????\n    assert(x>0);\n    \n    int i = 1;\n    while(tetrahedral(i)<=x) i++;\n    \n    return --i;\n}\n\nint iMaxForTetrahedralOdd(int x) { //?????¶??°x??\\???????????§????\\???°??£?????¢?????°???i?????????\n    assert(x>0);\n    \n    int i = 1;\n    while(tetrahedralOdd(i)<=x) i++;\n    \n    return --i;\n}\n\n\n\nint main(){\n    \n    vi a;\n    int aa;\n    int a_max = 0;\n    \n    //read input, at the same time, find the max number\n    while(1) {\n        cin >> aa;\n        if(aa==0) break;\n        \n        a.push_back(aa);\n        if( a_max < aa) a_max = aa;\n    }\n    \n    \n    \n    int N=a_max; //??£?????¢?????°????????????????????????????????????????????°\n\n    vi T;\n    T.push_back(0); //T[0] = 0\n    rep(i,1,N+1) T.push_back(INF); //T[1] ... T[N] = INF\n    \n    rep(i, 1, iMaxForTetrahedral(N)+1 ) {\n        rep(j, tetrahedral(i), N+1) {\n            T[j] = min( T[j], T[j-tetrahedral(i)] + 1 );\n            \n            //                disp(i);\n            //                disp(j);\n            //\n            //                disp(tetrahedral(i));\n            //\n            //\n            //                dout<<\"N = \";\n            //                rep(i,0,N+1) disP(i);\n            //                dout<<endl;\n            //                dispAll(T, N+1);\n            //                dout<<\"----------T\\n\";\n        }\n    }\n    \n    \n    \n    \n    vi S;\n    S.push_back(0); //S[0] = 0\n    rep(i,1,N+1) S.push_back(INF); //S[1] ... S[N] = INF\n    \n    rep(i, 1, iMaxForTetrahedralOdd(N)+1 ) {\n        rep(j, tetrahedralOdd(i), N+1) {\n            S[j] = min( S[j], S[j-tetrahedralOdd(i)] + 1 );\n            \n            //                disp(i);\n            //                disp(j);\n            //\n            //                dout<<\"N = \";\n            //                rep(i,0,N+1) disP(i);\n            //                dout<<endl;\n            //                dispAll(S, N+1);\n            //                dout<<\"----------S\\n\";\n        }\n    }\n    \n    \n    \n    \n    for( vi::iterator v = a.begin(); v!=a.end(); v++) {\n//        disp(*v);\n        cout << T[*v] << \" \" << S[*v] << endl;\n    }\n    \n    \n    \n    \n    \n    \n#ifdef OUTPUT2TEXTFILE\n    outputfile.close();\n    cout << \"\\\"\" << OutputFilePath << \"\\\"\" << endl;\n#endif\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i,n) for(ll i=0;i<(ll)n; ++i)\n\nll table[1000000];\nll pollock[1000001];\nll dp[1000001];\n\nvoid solution(ll output[1000001], int interval) {\n\toutput[0] = 0;\n\tll current_i = interval-1;\n\tREP(i, 1000001) {\n\t\tif (i == 0) continue;\n\t\tif (table[current_i + interval] == i) {\n\t\t\toutput[i] = 1; current_i += interval;\n\t\t\tcontinue;\n\t\t}\n\n\t\tll minimum = 1000001;\n\t\tfor (ll j = 1; j <= current_i; j += interval) {\n\t\t\tminimum = min(output[i - table[j]] + 1, minimum);\n\t\t}\n\t\toutput[i] = minimum;\n\t}\n}\n\nint main() {\n\t//freopen(\"Text.txt\", \"r\", stdin);\n\t\n\tll size = 0;\n\t{\n\t\tll i = 0;\n\t\ttable[0] = 0;\n\t\twhile (1000001 > table[i]) {\n\t\t\ti++;\n\t\t\ttable[i] = i*(i + 1)*(i + 2) / 6;\n\t\t}\n\t\tsize = i;\n\t}\n\n\tsolution(pollock, 1);\n\tsolution(dp, 4);\n\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\t\n\t\tcout << pollock[n] << \" \" << dp[n] << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n\n\n\nint main() {\n    int s4[101];\n    vector<int> s4_k;\n    REP(i, 101){\n        s4[i] = i * (i + 1) * (i + 2) / 6;\n        if(s4[i] & 1){\n            s4_k.push_back(i * (i + 1) * (i + 2) / 6);\n            // cout << s4[i] << endl;\n        }\n    }\n    \n    int n;\n    cin >> n;\n    while(n != 0){\n        vector<vector<int>> dp(102, vector<int>(n + 1, 1e9));\n        dp[0][0] = 0;\n        \n        for(int i = 1; i <= 101; i++){\n            REP(j, n + 1){\n                if(s4[i - 1] <= j){\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - s4[i - 1]] + 1);\n                }\n                else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[101][n] << ' ';\n        \n        \n        \n        REP(i, s4_k.size() + 1){\n            REP(j, n + 1){\n                dp[i][j] = 1e9\n                ;\n            }\n        }\n        dp[0][0] = 0;\n        \n        for(int i = 1; i <= s4_k.size(); i++){\n            REP(j, n + 1){\n                if(s4_k[i - 1] <= j){\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - s4_k[i - 1]] + 1);\n                }\n                else{\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        \n        /*\n        REP(i, 5){\n            REP(j, n + 1){\n                cout << dp[i][j] << ' ';\n            }\n            cout << endl;\n        }\n        */\n        \n        cout << dp[s4_k.size()][n] << endl;\n        \n        \n        \n        cin >> n;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n#define M_MAX 1000001\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nvector<int>r;\nint dp[M_MAX], odp[M_MAX];\n\nint main(){\n  fill(dp, dp+M_MAX, INF);\n  //  fprintf(stderr, \"error\\n\");\n  fill(odp, odp+M_MAX, INF);\n\n  int n = 0;\n  while(++n){\n    int x = n*(n+1)*(n+2)/6;\n    if(x > 1000000) break;\n    r.push_back(x);\n    //    printf(\"%d %d\\n\", n, x);\n  }\n\n  dp[0] = odp[0] = 0;\n\n  REP(i, 0, r.size()){\n    int m = r[i];\n    REP(j, m, M_MAX+1)\n      dp[j] = min(dp[j], dp[j-m]+1);\n    if(m%2)\n      REP(j, m, M_MAX+1)\n\todp[j] = min(odp[j], odp[j-m]+1);\n  }\n\n  //  printf(\"end\\n\");\n  while(scanf(\"%d\", &n) && n)\n    printf(\"%d %d\\n\", dp[n], odp[n]);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    vector<int> dp_all(1000001, 1000000);\n    vector<int> dp_odd(1000001, 1000000);\n\n    dp_all[0] = dp_odd[0] = 0;\n    for(int i = 1; i <= 181; ++i) {\n        int n = i*(i+1)*(i+2)/6;\n        for(int j = 0; j+n <= 1000000; ++j) {\n            dp_all[j+n] = min(dp_all[j+n], dp_all[j] + 1);\n            if(n % 2 == 1) dp_odd[j+n] = min(dp_odd[j+n], dp_odd[j] + 1);\n        }\n    }\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        cout << dp_all[N] << ' ' << dp_odd[N] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0;}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0;}\n\nconst int INF = 1001001001;\nint main() {\n    int dp[1000001],odddp[1000001];\n    rep(i,1000001) {\n        dp[i] = INF;\n        odddp[i] = INF;\n    }      \n    dp[0] = 0;\n    odddp[0] = 0;\n    for(int i = 1;;i++) {\n        int num = i*(i+1)*(i+2)/6;\n        if(num>1000000) break;\n        for(int j = num;j<=1000000;j++) {\n            dp[j] = min(dp[j],dp[j-num] + 1);\n            if(num%2==1) {\n                odddp[j] = min(odddp[j],odddp[j-num] + 1);\n            }\n        }\n    }\n    while(true) {\n        int n;\n        cin >> n;\n        if(n==0) break;\n        cout << dp[n] << \" \" << odddp[n] << endl;\n    }\n\n}\n"
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Mutable as MV\nimport qualified Control.Monad.ST as ST\nimport qualified Debug.Trace as Log\nimport qualified Data.Vector.Generic as GV\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\n\n\nmain :: IO ()\nmain = do\n  let !t1 = V.force $ dpTable 1e6\n      !t2 = V.force $ dpTableOdd 1e6\n  -- print fs\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) ++ ' ':show (t2 V.! x)\n      hFlush stdout\n      continue\n\nf :: Int -> Int\nf !n = (n * (n+1) * (n+2)) `div` 6\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = constructN'' n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge !v\n      | k == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l $!g r) maxBound fs\n      where\n        k = V.length v\n        g !fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n\n-- constructN' :: Int -> (V.Vector a -> a) -> V.Vector a\n-- constructN' !n fun = ST.runST $ do\n--     v  <- MV.new n\n--     flip fix 0 $ \\loop !len -> do\n--       if len == n\n--         then V.freeze v\n--         else do\n--         v' <- V.unsafeFreeze v\n--         let !x = fun (V.unsafeTake len v')\n--         x `seq` MV.write v len x\n--         GV.elemseq v' x $ loop (len+1)\n\nconstructN'' :: Int -> (V.Vector a -> a) -> V.Vector a\nconstructN'' !n fun = ST.runST $ do\n    v  <- MV.new n\n    v' <- V.unsafeFreeze v\n    flip fix 0 $ \\loop !len -> do\n      if len == n\n        then return v'\n        else do\n        let v'' = V.unsafeTake len v'\n            !x = fun v''\n        GV.elemseq v'' x $ MV.write v len x\n        loop (len+1)\n    \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = constructN'' n ge\n  where\n    ge !v\n      | V.length v == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l (g r)) maxBound fsOdd -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "Haskell",
    "code": "module Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!))\nimport qualified Data.Vector as V\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ solve x\n      continue\n  return ()\n\nsolve :: Int -> String\nsolve x = show (dpTable 200 ! x) ++ ' ':show (dpTableOdd 200 ! x)\n\nf :: Int -> Int\nf n = n * (n+1) * (n+2) `div` 6\n\nfs :: [Int]\nfs = map f [1..]\n\nfsOdd :: [Int]\nfsOdd = filter odd fs\n\ndpTable :: Int -> V.Vector Int\ndpTable n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fs]\n      where\n        k = length v\ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fsOdd]\n      where\n        k = length v\n       "
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -v #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ solve x\n      continue\n  return ()\n\nsolve :: Int -> String\nsolve x = show (dpTable 200 ! x) ++ ' ':show (dpTableOdd 200 ! x)\n\nf :: Int -> Int\nf n = n * (n+1) * (n+2) `div` 6\n\nfs :: [Int]\nfs = map f [1..]\n\nfsOdd :: [Int]\nfsOdd = filter odd fs\n\ndpTable :: Int -> V.Vector Int\ndpTable n = V.constructN n gen\n  where\n\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fs]\n      where\n        k = length v\ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n gen\n  where\n    gen :: V.Vector Int -> Int\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fsOdd]\n      where\n        k = length v\n       "
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -v #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ solve x\n      continue\n  return ()\n\nsolve :: Int -> String\nsolve x = show (dpTable 200 ! x) ++ ' ':show (dpTableOdd 200 ! x)\n\nf :: Int -> Int\nf n = n * (n+1) * (n+2) `div` 6\n\nfs :: [Int]\nfs = map f [1..]\n\nfsOdd :: [Int]\nfsOdd = filter odd fs\n\ndpTable :: Int -> V.Vector Int\ndpTable n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fs]\n      where\n        k = length v\ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fsOdd]\n      where\n        k = length v\n       "
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -Odph #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Mutable as MV\nimport qualified Control.Monad.ST as ST\nimport qualified Debug.Trace as Log\nimport qualified Data.Vector.Generic as GV\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\n\n\nmain :: IO ()\nmain = do\n  let !t1 = V.force $ dpTable 1e6\n      !t2 = V.force $ dpTableOdd 1e6\n  -- print fs\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) ++ ' ':show (t2 V.! x)\n      hFlush stdout\n      continue\n\nf :: Int -> Int\nf !n = (n * (n+1) * (n+2)) `div` 6\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = constructN'' n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge !v\n      | k == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l $!g r) maxBound fs\n      where\n        k = V.length v\n        g !fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n\n-- constructN' :: Int -> (V.Vector a -> a) -> V.Vector a\n-- constructN' !n fun = ST.runST $ do\n--     v  <- MV.new n\n--     flip fix 0 $ \\loop !len -> do\n--       if len == n\n--         then V.freeze v\n--         else do\n--         v' <- V.unsafeFreeze v\n--         let !x = fun (V.unsafeTake len v')\n--         x `seq` MV.write v len x\n--         GV.elemseq v' x $ loop (len+1)\n\nconstructN'' :: Int -> (V.Vector a -> a) -> V.Vector a\nconstructN'' !n fun = ST.runST $ do\n    v  <- MV.new n\n    v' <- V.unsafeFreeze v\n    flip fix 0 $ \\loop !len -> do\n      if len == n\n        then return v'\n        else do\n        let v'' = V.unsafeTake len v'\n            !x = fun v''\n        GV.elemseq v'' x $ MV.write v len x\n        loop (len+1)\n    \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = constructN'' n ge\n  where\n    ge !v\n      | V.length v == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l (g r)) maxBound fsOdd -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -Odph #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport Debug.Trace (traceShow)\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\n\nmain :: IO ()\nmain = do\n  let !t1 = dpTable 1e6\n      !t2 = dpTableOdd 1e6\n  -- print fs\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) ++ ' ':show (t2 V.! x)\n      -- hFlush stdout\n      continue\n  return ()\n\nf :: Int -> Int\nf !n = (n * (n+1) * (n+2)) `div` 6\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n{-# NOINLINE fsOdd #-}\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = V.constructN n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge v\n      | k == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l (g r)) maxBound fs -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n                          \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n ge\n  where\n    -- gen :: V.Vector Int -> Int\n    ge !v\n      | V.length v == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l (g r)) maxBound fsOdd -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n--      | otherwise       = 1 + V.foldl' min maxBound [ v V.! (k - fi) | fi <- fsOdd, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "Haskell",
    "code": "module Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ solve x\n      continue\n  return ()\n\nsolve :: Int -> String\nsolve x = show (dpTable 200 ! x) ++ ' ':show (dpTableOdd 200 ! x)\n\nf :: Int -> Int\nf n = n * (n+1) * (n+2) `div` 6\n\nfs :: [Int]\nfs = map f [1..]\n\nfsOdd :: [Int]\nfsOdd = filter odd fs\n\ndpTable :: Int -> V.Vector Int\ndpTable n = V.constructN n gen\n  where\n    gen :: V.Vector Int -> Int\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fs]\n      where\n        k = length v\ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n gen\n  where\n    gen :: V.Vector Int -> Int\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fsOdd]\n      where\n        k = length v\n        \n       "
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport Debug.Trace (traceShow)\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  let !t1 = dpTable 1e6\n      !t2 = dpTableOdd 1e6\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) -- ++ ' ':show (t2 V.! x)\n      hFlush stdout\n      continue\n  return ()\n\n\n-- solve :: Int -> String\n-- solve x = show (dpTable 1e3 ! x) ++ ' ':show (dpTableOdd 1e3 ! x)\n\nf :: Int -> Int\nf !n = n * (n+1) * (n+2) `div` 6\n{-# INLINE f #-}\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n{-# INLINE fs #-}\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n{-# INLINE fsOdd #-}\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = V.constructN n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge v\n      | k == 0 = 0\n      -- | k == 1 = 1\n      | otherwise       = 1 + V.foldl' min maxBound (V.map g fs) -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n        \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n ge\n  where\n    -- gen :: V.Vector Int -> Int\n    ge !v\n      | V.length v == 0 = 0\n      -- | V.length v == 1 = 1\n      | otherwise       = 1 + V.foldl' min maxBound (V.map g fsOdd) -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n--      | otherwise       = 1 + V.foldl' min maxBound [ v V.! (k - fi) | fi <- fsOdd, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "Haskell",
    "code": "module Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ solve x\n      continue\n  return ()\n\nsolve :: Int -> String\nsolve x = show (dpTable 200 ! x) ++ ' ':show (dpTableOdd 200 ! x)\n\nf :: Int -> Int\nf n = n * (n+1) * (n+2) `div` 6\n\nfs :: [Int]\nfs = map f [1..]\n\nfsOdd :: [Int]\nfsOdd = filter odd fs\n\n\ndpTable n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fs]\n      where\n        k = length v\n\ndpTableOdd n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fsOdd]\n      where\n        k = length v\n       "
  },
  {
    "language": "Haskell",
    "code": "{-# OPTIONS_GHC -O2 #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport Debug.Trace (traceShow)\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\n\nmain :: IO ()\nmain = do\n  let !t1 = dpTable 1e6\n      !t2 = dpTableOdd 1e6\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) ++ ' ':show (t2 V.! x)\n      hFlush stdout\n      continue\n  return ()\n\n-- solve :: Int -> String\n-- solve x = show (dpTable 1e3 ! x) ++ ' ':show (dpTableOdd 1e3 ! x)\n\nf :: Int -> Int\nf !n = n * (n+1) * (n+2) `div` 6\n{-# INLINE f #-}\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n{-# NOINLINE fs #-}\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n{-# NOINLINE fsOdd #-}\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = V.constructN n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge v\n      | k == 0 = 0\n      | otherwise       = 1 + V.foldl' min maxBound (V.map g fs) -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n                          \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n ge\n  where\n    -- gen :: V.Vector Int -> Int\n    ge !v\n      | V.length v == 0 = 0\n      | otherwise       = 1 + V.foldl' min maxBound (V.map g fsOdd) -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n--      | otherwise       = 1 + V.foldl' min maxBound [ v V.! (k - fi) | fi <- fsOdd, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "Haskell",
    "code": "module Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ solve x\n      continue\n  return ()\n\nsolve :: Int -> String\nsolve x = show (dpTable 200 ! x) ++ ' ':show (dpTableOdd 200 ! x)\n\nf :: Int -> Int\nf n = n * (n+1) * (n+2) `div` 6\n\nfs :: [Int]\nfs = map f [1..]\n\nfsOdd :: [Int]\nfsOdd = filter odd fs\n\ndpTable :: Int -> V.Vector Int\ndpTable n = V.constructN n gen\n  where\n    gen :: V.Vector Int -> Int\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fs]\n      where\n        k = V.length v\ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n gen\n  where\n    gen :: V.Vector Int -> Int\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fsOdd]\n      where\n        k = V.length v\n        \n       "
  },
  {
    "language": "Haskell",
    "code": "module Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!))\nimport qualified Data.Vector as V\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\nmain :: IO ()\nmain = do\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ solve x\n      continue\n  return ()\n\nsolve :: Int -> String\nsolve x = show (dpTable 200 ! x) ++ ' ':show (dpTableOdd 200 ! x)\n\nf :: Int -> Int\nf n = n * (n+1) * (n+2) `div` 6\n\nfs :: [Int]\nfs = map f [1..]\n\nfsOdd :: [Int]\nfsOdd = filter odd fs\n\ndpTable :: Int -> V.Vector Int\ndpTable n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fs]\n      where\n        k = length v\ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n gen\n  where\n    gen v\n      | V.length v == 0 = 0\n      | V.length v == 1 = 1\n      | otherwise       = minimum [ 1 + v ! (k - fi) | fi <- takeWhile (\\fi -> k - fi >= 0) fsOdd]\n      where\n        k = length v\n       "
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Mutable as MV\nimport qualified Control.Monad.ST as ST\nimport qualified Debug.Trace as Log\nimport qualified Data.Vector.Generic as GV\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\n\n\nmain :: IO ()\nmain = do\n  let !t1 = V.force $ dpTable 1e6\n      !t2 = V.force $ dpTableOdd 1e6\n  -- print fs\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) ++ ' ':show (t2 V.! x)\n      --hFlush stdout\n      continue\n\nf :: Int -> Int\nf !n = (n * (n+1) * (n+2)) `div` 6\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = constructN'' n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge v\n      | k == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l $!g r) maxBound fs\n                          -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g !fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n\n-- constructN' :: Int -> (V.Vector a -> a) -> V.Vector a\n-- constructN' !n fun = ST.runST $ do\n--     v  <- MV.new n\n--     flip fix 0 $ \\loop !len -> do\n--       if len == n\n--         then V.freeze v\n--         else do\n--         v' <- V.unsafeFreeze v\n--         let !x = fun (V.unsafeTake len v')\n--         x `seq` MV.write v len x\n--         GV.elemseq v' x $ loop (len+1)\n\nconstructN'' :: Int -> (V.Vector a -> a) -> V.Vector a\nconstructN'' !n fun = ST.runST $ do\n    v  <- MV.new n\n    v' <- V.unsafeFreeze v\n    flip fix 0 $ \\loop !len -> do\n      if len == n\n        then return v'\n        else do\n        let v'' = V.unsafeTake len v'\n            !x = fun v''\n        GV.elemseq v'' x $ MV.write v len x\n        loop (len+1)\n    \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = constructN'' n ge\n  where\n    ge !v\n      | V.length v == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l (g r)) maxBound fsOdd -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport Debug.Trace (traceShow)\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\n\nmain :: IO ()\nmain = do\n  let !t1 = dpTable 1e6\n      !t2 = dpTableOdd 1e6\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) ++ ' ':show (t2 V.! x)\n      hFlush stdout\n      continue\n  return ()\n\n-- solve :: Int -> String\n-- solve x = show (dpTable 1e3 ! x) ++ ' ':show (dpTableOdd 1e3 ! x)\n\nf :: Int -> Int\nf !n = n * (n+1) * (n+2) `div` 6\n{-# INLINE f #-}\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n{-# NOINLINE fs #-}\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n{-# NOINLINE fsOdd #-}\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = V.constructN n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge v\n      | k == 0 = 0\n      | otherwise       = 1 + V.foldl' min maxBound (V.map g fs) -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n                          \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = V.constructN n ge\n  where\n    -- gen :: V.Vector Int -> Int\n    ge !v\n      | V.length v == 0 = 0\n      | otherwise       = 1 + V.foldl' min maxBound (V.map g fsOdd) -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n--      | otherwise       = 1 + V.foldl' min maxBound [ v V.! (k - fi) | fi <- fsOdd, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE Rank2Types #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE NumDecimals #-}\nmodule Main (main) where\nimport Control.Applicative\nimport qualified Data.ByteString as BS\nimport qualified Data.ByteString.Char8 as BS\nimport Data.Function (fix)\nimport Data.Maybe (fromJust)\nimport Data.Vector ((!),Vector())\nimport qualified Data.Vector as V\nimport Debug.Trace (traceId)\nimport Debug.Trace (traceShowId)\nimport System.IO (hFlush)\nimport System.IO (stdout)\nimport Data.Vector.Unboxed ((!))\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Mutable as MV\nimport qualified Control.Monad.ST as ST\nimport qualified Debug.Trace as Log\n\ngetInt :: IO Int\ngetInt = fst . fromJust . BS.readInt <$> BS.getLine\n\n\nmain :: IO ()\nmain = do\n  let !t1 = V.force $ dpTable 1e6\n      !t2 = V.force $ dpTableOdd 1e6\n  -- print fs\n  fix $ \\continue -> do\n    x <- getInt\n    if (x == 0)\n      then return ()\n      else do\n      putStrLn $ show (t1 V.! x) ++ ' ':show (t2 V.! x)\n      hFlush stdout\n      continue\n\nf :: Int -> Int\nf !n = (n * (n+1) * (n+2)) `div` 6\n\nfs :: Vector Int\nfs = V.map f $ V.enumFromTo 1 200\n\nfsOdd :: Vector Int\nfsOdd = V.filter odd $ fs\n\ndpTable :: Int -> V.Vector Int\n-- dpTable n | traceShow n False = undefined\ndpTable n = constructN' n ge\n  where\n    ge :: V.Vector Int -> Int\n    ge v\n      | k == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l $!g r) maxBound fs -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n      where\n        k = V.length v\n        g !fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n\nconstructN' :: Int -> (V.Vector a -> a) -> V.Vector a\nconstructN' !n fun = ST.runST $ do\n    v  <- MV.new n\n    flip fix 0 $ \\loop !len -> do\n      if len == n\n        then V.unsafeFreeze v\n        else do\n        !v' <- V.unsafeFreeze v\n        let x = fun (V.unsafeTake len v')\n        MV.write v len x\n        loop (len+1)\n    \ndpTableOdd :: Int -> V.Vector Int\ndpTableOdd n = constructN' n ge\n  where\n    -- gen :: V.Vector Int -> Int\n    ge !v\n      | V.length v == 0 = 0\n      | otherwise       = 1 + V.foldl' (\\l r -> min l (g r)) maxBound fsOdd -- [ v V.! (k - fi) | fi <- fs, k - fi >= 0]\n--      | otherwise       = 1 + V.foldl' min maxBound [ v V.! (k - fi) | fi <- fsOdd, k - fi >= 0]\n      where\n        k = V.length v\n        g fi\n          | k - fi >= 0 = v V.! (k - fi)\n          | otherwise   = maxBound\n       \n       "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint min(int x,int y)\n{\n\tif(x>=y) return y;\n\treturn x;\n}\n\nint main(void)\n{\n\tint i,j,k,l,n,a[1000],b[1000],dp[1000][1000001];\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\ta[0]=0;\n\t\ti=1;\n\t\twhile(1)\n\t\t{\n\t\t\ta[i]=(i*(i+1)*(i+2))/6;\n\t\t\tif(a[i]>n) break;\n\t\t\ti++;\n\t\t}\n\t\tk=i;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[1][i]=i;\n\t\t}\n\t\tfor(i=2;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-a[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \",dp[k][n]);\n\t\tb[0]=0;\n\t\ti=0;\n\t\tj=1;\n\t\twhile(1)\n\t\t{\n\t\t\tif(a[j]%2==1)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tb[i]=a[j];\n\t\t\t\t\n\t\t\t}\n\t\t\tif(b[i]>n) break;\n\t\t\tj++;\n\t\t}\n\t\tl=i-1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[1][i]=i;\n\t\t}\n\t\tfor(i=2;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(b[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-b[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[l][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1167\nTitle Pollock's conjecture\n@kankichi573\n*/\n#include <stdio.h>\n#include <limits.h>\n#define UPPER 181\nint n;\nint tetrah[UPPER+1];\nint ans_table[1000000];\nint ans_table_odd[1000000];\n//\nint find_odd(int x)\n{\n        int ret=find(x);\n        if((ret % 4)==1)\n                return(ret);\n        else if((ret % 4)==0)\n                return(ret-3);\n        else if((ret % 4)==2) \n                return(ret-1);\n        else\n                return(ret-2);\n}\nint find_(int x,int l,int u)\n{\n        int c;\n\n        if(x>=tetrah[l] && x<tetrah[l+1])\n                return(l);\n        if(x>=tetrah[u-1] && x<tetrah[u])\n                return(u-1);\n        c=(l+u)/2;\n        if(x>=tetrah[c] && x<tetrah[c+1])\n                return(c);\n        if(x>=tetrah[c+1])\n                return(find_(x,c+1,u));\n        if(x<tetrah[c])\n                return(find_(x,l,c-1));\n\n}\nint find(int x)\n{\n        return(find_(x,1,UPPER));\n}\n\nvoid init()\n{\n        int i;\n        for(i=1;i<=UPPER;i++)\n                tetrah[i]=i*(i+1)*(i+2)/6;\n\n}\n\nint solve_odd(int x)\n{\n        int i,min_,ret,v;\n\n        if(ret=ans_table_odd[x])\n                return(ret);\n        if(x<tetrah[5])\n                return(x);\n        \n        min_=INT_MAX;\n        for(i=find_odd(x);i>=1;i -= 4)\n        {\n                v=x - i*(i+1)*(i+2)/6;\n                if(v==0)\n                        return(1);\n                ret=solve_odd(v);\n                if(ret < min_)\n                        min_ = ret;\n        }\n        ans_table_odd[x]=min_+1;\n        return(min_+1);\n}\n\nint solve(int x)\n{\n        int i,min_,v,f,ret;\n        \n        //printf(\"SV=%d\\n\",x);\n        if(ret=ans_table[x])\n                return(ret);\n\n        if(x<tetrah[2])\n                return(x);\n\n        min_=INT_MAX;\n\n        f=find(x);\n        //printf(\"F=%d %d\",f,f*(f+1)*(f+2)/6);\n        for(i=f;i>=2;i--)\n        {\n                v=x - i*(i+1)*(i+2)/6;\n                if(v==0)\n                        return(1);\n                ret=solve(v);\n                if(ret < min_)\n                        min_ = ret;\n        }\n        ans_table[x]=min_+1;\n        return(min_+1);\n}\nmain()\n{\n        int i;\n\n        init();\n\n        for(i=0;i<1000000;i++)\n        {\n                solve(i);\n                solve_odd(i);\n        }\n        while(EOF!=scanf(\"%d\",&n) && n)\n        {\n                // printf(\"%d \\n\",solve(n));\n                printf(\"%d %d\\n\",solve(n),solve_odd(n));\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(a,b)a<b?a:b\n#define N 1000010\nint o[200],s[200],dp1[N],dp2[N],n,i,j,k,x;;\n\nvoid f(int t[200],int dp[N])\n{\n\tint i,j;\n\tdp[0]=0;\n\tfor(i=0;t[i];i++)\n\t\tfor(j=0;j<=N;j++)\n\t\t\tif(j>=t[i])\n\t\t\t\tdp[j]=min(dp[j],dp[j-t[i]]+1);\n}\n\nint main()\n{\n\tfor(i=1,j=k=0;i*(i+1)*(i+2)/6<=N;i++)\n\t{\n\t\tx=i*(i+1)*(i+2)/6;\n\t\tif(x%2)\n\t\t\to[j++]=x;\n\t\ts[k++]=x;\n\t}\n\tmemset(dp1,0x7f,sizeof(dp1));\n\tmemset(dp2,0x7f,sizeof(dp2));\n\tf(s,dp1);\n\tf(o,dp2);\n\tfor(;scanf(\"%d\",&n),n;)\n\t\tprintf(\"%d %d\\n\",dp1[n],dp2[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define tetra(N) N*(N+1)*(N+2)/6\n#define N_MAX 1000000\n\nint main(int argc, char* argv[]){\n\tint *a=malloc((N_MAX+1)*sizeof(int)), *b=malloc((N_MAX+1)*sizeof(int)), i, j;\n\t\n\t/* initialize */\n\tfor(i=1; i<=N_MAX; i++) a[i]=N_MAX, b[i]=N_MAX;\n\t\n\t/* solve */\n\tfor(i=1; tetra(i)<=N_MAX; i++){\n\t\ta[tetra(i)]=1;\n\t\tif(i%4==1) b[tetra(i)]=1;\n\t}\n\tfor(i=1; i<=N_MAX; i++)\n\t\tfor(j=1; i+tetra(j)<=N_MAX; j++){\n\t\t\tif(a[i+tetra(j)]>a[i]+1) a[i+tetra(j)]=a[i]+1;\n\t\t\tif(j%4==1 && b[i+tetra(j)]>b[i]+1) b[i+tetra(j)]=b[i]+1;\n\t\t}\n\t\n\t/* show */\n\twhile(scanf(\"%d\",&i), i!=0) printf(\"%d %d\\n\",a[i],b[i]);\n\t\n\tfree(a), free(b);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAXI 1000000\n// DP(????????????????????????)\nint main(void){\n  int dp[MAXI+1], dp2[MAXI+1];\n  int i, j, t, n;\n  for(i=0; i<=MAXI; i++) dp[i] = dp2[i] = i;\n  i = 2;\n  while(1){\n    if((t = (int) i * (i+1) * (i+2) / 6) > MAXI) break;\n    if(t % 2)\n      for(j=t; j<=MAXI; j++)\n        if(dp2[j] > dp2[j-t] + 1) dp2[j] = dp2[j-t] + 1;\n    for(j=t; j<=MAXI; j++){\n      if(dp[j] > dp[j-t] + 1) dp[j] = dp[j-t] + 1;\n    }\n    i++;\n  }\n  while(1){\n    scanf(\"%d\", &n);\n    if(n == 0) break;\n    printf(\"%d %d\\n\", dp[n], dp2[n]);\n  }\n} "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void){\n\twhile(1){\n\t\tint n, i=0, j, k;\n\t\tint a[100];\n\t\tint dp[1000001];\n\t\tint dq[1000001];\n\t\t\n\t\tfor(k=0; k<1000001; k++){\n\t\t\tdp[k] = 25000;\n\t\t\tdq[k] = 25000;\n\t\t}\n\t\t\n\t\tdp[0]=0;\n\t\tdq[0]=0;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0) break;\n\t\t\n\t\twhile(1){\n\t\t\ta[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t\tif(a[i] > n) break;\n\t\t\ti++;\n\t\t}\n\t\t\t\n\t\tfor(k=0; k<=n; k++){\n\t\t\tfor(j=0; j<i; j++){\n\t\t\t\tif(k-a[j] >= 0) {\n\t\t\t\t\tif(dp[k] > dp[k-a[j]]+1)\n\t\t\t\t\t\tdp[k] = dp[k-a[j]]+1;\n\t\t\t\t\telse dp[k] = dp[k];\n\t\t\t\t\t\n\t\t\t\t\tif(a[j]%2 != 0){\n\t\t\t\t\t\tif(dq[k] > dq[k-a[j]]+1)\n\t\t\t\t\t\t\tdq[k] = dq[k-a[j]]+1;\n\t\t\t\t\t\telse dq[k] = dq[k];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t//for(k=0; k<=n; k++)\n\t\t\t//printf(\"dp[%d]=%d\\n\",k,dp[k]);\n\t\t\n\t\tprintf(\"%d %d\\n\", dp[n], dq[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint N(int n){\n  return n*(n+1)*(n+2)/6;\n}\n\nmain(){\n  int i,j,n,fx[1000000],d=1,min,fy[1000000],nn=1;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    \n    \n    fx[0] = 0;\n    fy[0] = 0;\n    for(i=nn;i<=n;i++){\n      if(i == N(d+1)) d++;\n      \n      min = -1;\n      for(j=1;j<=d;j++){\n\tif(min == -1 || fx[i-N(j)]+1 < min) min = fx[i-N(j)]+1;\n      }\n      fx[i] = min;\n      \n      min = -1;\n      for(j=1;j<=d;j++){\n\tif(N(j)%2 == 0) continue;\n\telse if(min == -1 || fy[i-N(j)]+1 < min) min = fy[i-N(j)]+1;\n      }\n      fy[i] = min;\n    }\n    \n    \n    if(nn < n) nn = n+1;\n    \n    printf(\"%d %d\\n\",fx[n],fy[n]);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a,b) a<b?a:b\n\nint main(){\n\tint n;\n\tint i,j;\n\tint c;\n\tint a[1000001];\n\tint b[1000001];\n \n\tfor(i = 0;i < 1000001;i++){\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\n\tfor(i = 3,c = 4;c < 1000001;i++){\n\t\tfor(j = c;j < 1000001;j++){\n\t\t\ta[j] = min(a[j],a[j-c]+1);\n\t\t}\n\t\tif(c % 2){\n\t\t\tfor(j = c;j < 1000001;j++){\n\t\t\t\tb[j] = min(b[j],b[j-c]+1);\n\t\t\t}\n\t\t}\n\t\tc = i * (i+1) * (i+2) / 6;\n\t}\n\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",a[n],b[n]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000\n\n//\"all\" is the table of the answers for all pollock numbers\n//\"odd\" is the table of the answers for odd pollock numbers\nint all[N+1],odd[N+1];\nint pollock[1000],num;\n\nint BackTrack(int n,int type){\n  int i,tmp,ans = N+1;\n  //if n is already searched, return answer on table\n  if(type && odd[n]<=N)return odd[n];\n  if(!type && all[n]<=N)return all[n];\n\n  for(i=num-1;i>0;i--){\n    if(pollock[i]>n)continue;\n    if(type && !(pollock[i]&1) )continue;\n    tmp = BackTrack(n-pollock[i],type);\n    if(ans > tmp+1)ans = tmp+1;\n  }\n\n  //memorize n-th answer\n  if(type)odd[n] = ans;\n  else all[n] = ans;\n  return ans;\n}\n\nint main(void){\n  int i,n,tmp;\n\n  //initialize table (filling SUP)\n  for(i=0;i<=N;i++)all[i] = odd[i] = N+1;\n  all[0] = odd[0] = 0;\n\n  for(num=1;;num++){\n    tmp = num*(num+1)*(num+2)/6;\n    if(tmp>N)break;\n    pollock[num] = tmp;\n  }\n\n  while(scanf(\"%d\",&n) && n){\n    printf(\"%d %d\\n\",BackTrack(n,0),BackTrack(n,1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\t\n#define inf (INT_MAX-1)\n#define INF 9223372036854775807\n#define sq(n) ((n)*(n))\n#define rep(i,n) for(i=0;i<n;i++)\n#define rev(i,n) for(i=n-1;i>=0;i--)\nconst int mod=(int)1e09+7;\n\nint in(void){\n\tint i;scanf(\"%d\",&i);\n\treturn i;\n}\nlong long llin(void){\n\tlong long i;scanf(\"%lld\",&i);\n\treturn i;\n}\ndouble din(void){\n\tdouble i;scanf(\"%lf\",&i);\n\treturn i;\n}\nvoid chin(char s[]){\n\tscanf(\"%s\",s);\n}\nvoid print(int a){\n\tprintf(\"%d\\n\",a);\n}\nvoid llprint(long long a){\n\tprintf(\"%lld\\n\",a);\n}\nvoid dprint(double a){\n\tprintf(\"%.10f\\n\",a);\n}\nvoid print2(int a,int b){\n\tprintf(\"%d %d\\n\",a,b);\n}\nlong long max(long long a,long long b){\n\treturn a>b?a:b;\n}\nlong long min(long long a,long long b){\n\treturn a<b?a:b;\n}\ndouble dmax(double a,double b){\n\treturn a>b?a:b;\n}\nint cmp(const void *a,const void *b){\n\treturn *(long long *)a-*(long long *)b;\n}\n\nint dp[1000000];\nint dp_o[1000000];\nint tetra[200];\nint tetra_o[200];\n\nint main(void){\n\tint n,t,i,j;\n\tt=0;\n\trep(i,200){\n\t\ttetra[i]=i*(i+1)*(i+2)/6;\n\t\tif(tetra[i]%2){\n\t\t\ttetra_o[t++]=tetra[i];\n\t\t}\n\t}\n\trep(i,1000000){\n\t\tdp[i]=dp_o[i]=inf;\n\t}\n\tdp[0]=dp_o[0]=0;\n\trep(i,200){\n\t\tfor(j=tetra[i];j<1000000;j++){\n\t\t\tdp[j]=min(dp[j],dp[j-tetra[i]]+1);\n\t\t}\n\t}\n\trep(i,t){\n\t\tfor(j=tetra_o[i];j<1000000;j++){\n\t\t\tdp_o[j]=min(dp_o[j],dp_o[j-tetra_o[i]]+1);\n\t\t}\n\t}\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n) break;\n\t\tprintf(\"%d %d\\n\",dp[n],dp_o[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 1000000 - 1\nint main(){\n\tint n,i,input;\n\tint tn, tmp;\n\tint tetra_n[181];\n\tint *tetra_sum, *tetra_sum_odd;\n\tchar a[10];\n\tfor (n = 0; n <= 180; n++) tetra_n[n] = n*(n+1)*(n+2) / 6;\n\ttetra_sum = (int *) malloc(sizeof(int) * (MAX+1));\n\ttetra_sum_odd = (int *) malloc(sizeof(int) * (MAX+1));\n\ttetra_sum[0] = 0;\n\ttetra_sum_odd[0] = 0;\n\tfor (i = 1; i <= MAX; i++){ \n\t\ttetra_sum[i] = MAX; \n\t\ttetra_sum_odd[i] = MAX;\n\t}\n\tfor (n = 1; n <= 180; n++){\n\t\ttn = tetra_n[n];\n\t\tif (tn % 2 == 0) {\n\t\t\tfor (i = tn; i <= MAX; i++){\n\t\t\t\ttmp = tetra_sum[i-tn] + 1;\n\t\t\t\tif (tmp < tetra_sum[i]) tetra_sum[i] = tmp;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = tn; i <= MAX; i++){\n\t\t\t\ttmp = tetra_sum[i-tn] + 1;\n\t\t\t\tif (tmp < tetra_sum[i]) tetra_sum[i] = tmp;\n\t\t\t\ttmp = tetra_sum_odd[i-tn] + 1;\n\t\t\t\tif (tmp < tetra_sum_odd[i]) tetra_sum_odd[i] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1){\n\t\tinput = atof(fgets(a, sizeof(a) / sizeof(a[0]), stdin));\n\t\tif (input == 0) break;\n\t\tprintf(\"%d %d\\n\", tetra_sum[input], tetra_sum_odd[input]);\n\t}\n\tfree(tetra_sum);\n\tfree(tetra_sum_odd);\n \treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "a[181],b1[1000000],b2[1000000];\nvoid ite(n){\n\tint m,k,l,i;\n\tb1[0] = b2[0] = 0;\n\tfor(m=1;m<=n;m++){\n\t\ti = 0;\n\t\tk = l = -1;\n\t\tfor(i=1;i<181;i++){\n\t\t\tif(m >= a[i] && b1[m-a[i]] >= 0 && (k < 0 || b1[m-a[i]] + 1 < k))\n\t\t\t\tk = b1[m-a[i]] + 1;\n\t\t\tif((a[i]&1) && m >= a[i] && b2[m-a[i]] >= 0 && (l < 0 || b2[m-a[i]] + 1 < l))\n\t\t\t\tl = b2[m-a[i]] + 1;\n\t\t}\n\t\tb1[m] = k;\n\t\tb2[m] = l;\n\t}\n}\n\nmain(n){\n\tfor(n=1;n<181;n++)a[n]=n*(n+1)*(n+2)/6;\n\tite(999999);\n\tfor(;scanf(\"%d\",&n),n;)printf(\"%d %d\\n\",b1[n],b2[n]);\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int PMAX = 180;\nconst int OMAX = 45;\n\nconst int MAX = 1000000;\nint tp[MAX];\nint to[MAX];\n\nint main(void)\n{\n    int i, j, n;\n    int p[PMAX], o[OMAX];\n\n    for (i = j = 1; (n = i * (i + 1) * (i + 2) / 6) < MAX; ++i) {\n        p[i] = n;\n        if (n % 2 == 1)\n            o[j++] = n;\n    }\n\n    memset(tp, MAX, sizeof(tp));\n    memset(to, MAX, sizeof(to));\n    tp[0] = to[0] = 0;\n    for (i = 0; i < MAX; ++i)\n        for (j = 1; j < PMAX; ++j)\n            if (i + p[j] < MAX && tp[i + p[j]] > tp[i] + 1)\n                tp[i + p[j]] = tp[i] + 1;\n    for (i = 0; i < MAX; ++i)\n        for (j = 1; j < OMAX; ++j)\n            if (i + o[j] < MAX && to[i + o[j]] > to[i] + 1)\n                to[i + o[j]] = to[i] + 1;\n\n    for (;;) {\n        int n;\n\n        scanf(\"%d\", &n);\n        if (n == 0)\n            break;\n\n        printf(\"%d %d\\n\", tp[n], to[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a,b) a<b?a:b\n\nint main(){\n\tint n;\n\tint i;\n\tint c;\n\tint a[1000001];\n\tint b[1000001];\n \n\tfor(i = 0;i < 1000001;i++){\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\n\tfor(i = 3,c = 4;i < 1000001;i++){\n\t\tfor(j = a;j < 1000001;j++){\n\t\t\ta[i] = min(a[i],a[i-c]+1);\n\t\t}\n\t\tif(a % 2){\n\t\t\tfor(j = a;j < 1000001;j++){\n\t\t\t\tb[i] = min(b[i],b[i-c]+1);\n\t\t\t}\n\t\t}\n\t\tc = i * (i+1) * (i+2) / 6;\n\t}\n\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",a[n],b[n]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint N(int n){\n  return n*(n+1)*(n+2)/6;\n}\n\nmain(){\n  int i,j,n,fx[1000000],d=1,min,fy[1000000],nn=1;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    \n    \n    fx[0] = 0;\n    fy[0] = 0;\n    for(i=nn;i<=n;i++){\n      if(i == N(d+1)) d++;\n      \n      min = -1;\n      for(j=1;j<=d;j++){\n\tif(min == -1 || fx[i-N(j)]+1 < min) min = fx[i-N(j)]+1;\n      }\n      fx[i] = min;\n      \n      min = -1;\n      for(j=1;j<=d;j++){\n\tif(N(j)%2 == 0) continue;\n\telse if(min == -1 || fy[i-N(j)]+1 < min) min = fy[i-N(j)]+1;\n      }\n      fy[i] = min;\n    }\n    \n    \n    if(nn < n) nn = n;\n    \n    printf(\"%d %d\\n\",fx[n],fy[n]);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX 1000000 - 1\nint main(){\n\tint n,i,input;\n\tint tn, tmp;\n\tint tetra_n[181];\n\tint *tetra_sum, *tetra_sum_odd;\n\tchar a[10];\n\tfor (n = 0; n <= 180; n++) tetra_n[n] = n*(n+1)*(n+2) / 6;\n\ttetra_sum = (int *) malloc(sizeof(int) * (MAX+1));\n\ttetra_sum_odd = (int *) malloc(sizeof(int) * (MAX+1));\n\ttetra_sum[0] = 0;\n\ttetra_sum_odd[0] = 0;\n\tfor (i = 1; i <= MAX; i++){ \n\t\ttetra_sum[i] = MAX; \n\t\ttetra_sum_odd[i] = MAX;\n\t}\n\tfor (n = 1; n <= 180; n++){\n\t\ttn = tetra_n[n];\n\t\tif (tn % 2 == 0) {\n\t\t\tfor (i = tn; i <= MAX; i++){\n\t\t\t\ttmp = tetra_sum[i-tn] + 1;\n\t\t\t\tif (tmp < tetra_sum[i]) tetra_sum[i] = tmp;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = tn; i <= MAX; i++){\n\t\t\t\ttmp = tetra_sum[i-tn] + 1;\n\t\t\t\tif (tmp < tetra_sum[i]) tetra_sum[i] = tmp;\n\t\t\t\ttmp = tetra_sum_odd[i-tn] + 1;\n\t\t\t\tif (tmp < tetra_sum_odd[i]) tetra_sum_odd[i] = tmp;\n\t\t\t}\n\t\t}\n\t}\n\twhile (1){\n\t\tinput = atof(fgets(a, sizeof(a) / sizeof(a[0]), stdin));\n\t\tif (input == 0) break;\n\t\tprintf(\"%d %d\\n\", tetra_sum[input], tetra_sum_odd[input]);\n\t}\n\tfree(tetra_sum);\n\tfree(tetra_sum);\n \treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint min(int b,int c)\n{\n\tint M;\n\tif(b!=0 && c!=0)\n\t{\n\t   M=b;\n\t   if(M>c) M=c;\n\t}\n\telse\n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn M;\n}\n\nint main(void)\n{\n\tint i,j,k,l,z,n,a[1000],e[1000],dp[1000][1000001],dp2[1000][1000001];\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\ta[0]=0;\n\t\te[0]=0;\n\t\tj=1;\n\t\tz=0;\n\t\tfor(i=1;z==0;i++)\n\t\t{\n\t\t\ta[i]=(i*(i+1)*(i+2))/6;\n\t\t\tif(a[i]>n) z=-1;\n\t\t\tif(a[i]%2==1)\n\t\t\t{\n\t\t\t\te[j]=a[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tk=i;\n\t\tl=j-1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-a[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp2[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(e[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=min(dp2[i][j-e[i]]+1,dp2[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=dp2[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp[k][n],dp2[l][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 1000000\n#define MIN(A,B) \\\n  ( (B) < (A) ? (B) : (A) )\n\nstatic int d[ 2 ][ N ];\n\nstatic int\ndpFSA (\n  int *k_operafan,\n  int n\n  )\n{\n  int i;\n\n  if ( ~k_operafan[ n ] ) ;\n  else\n  {\n    k_operafan[ n ] = n;\n    for ( i = 2; i < n; ++i )\n    {\n      k_operafan[ n ]\n        = MIN( k_operafan[ n ]\n             , dpFSA ( k_operafan, i ) + dpFSA ( k_operafan, n - i ) );\n    }\n  }\n\n  return ( k_operafan[ n ] );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  /* メモ化配列初期化 */\n  memset ( d, -1, sizeof ( d ) );\n  for ( i = 1; ; ++i )\n  {\n    const int c = i * ( i + 1 ) * ( i + 2 ) / 6;\n\n    if ( c >= N )\n      break ;\n\n    d[ 0 ][ c ] = 1;\n    if ( c % 2 == 1 )\n    {\n      d[ 1 ][ c ] = 1;\n    }\n  }\n\n  for ( ; ; )\n  {\n    int n;\n\n    scanf ( \"%d\", &n );\n    if ( n == 0 ) break ;\n\n    printf ( \"%d %d\\n\", dpFSA ( d[ 0 ], n ), dpFSA ( d[ 1 ], n ) );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define S(type,x) fscanf(stdin,\"%\"#type,&x)\n#define N (int)1e6\n#define MIN(a,b) a<b?a:b\nint dp[N + 1],\n\todd[N + 1];\nint main() {\n\tint i;\n\tfor (i = 0; i <= N; i++) dp[i] = odd[i] = i;\n\tint p = 4, n = 3;\n\tfor (; p <= N; n++) {\n\t\tfor (i = 0; i+p <= N; i++) {\n\t\t\tdp[i + p] = MIN(dp[i + p], dp[i] + 1);\n\t\t\tif (p & 1) odd[i + p] = MIN(odd[i + p], odd[i] + 1);\n\t\t}\n\t\tp = n*(n + 1)*(n + 2) / 6;\n\t}\n\twhile (S(d, n), n)fprintf(stdout, \"%d %d\\n\", dp[n], odd[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1167\nMaximum Sum Sequence\n*/\n#include <stdio.h>\n#include <limits.h>\n#define MAXVAL 1000000\n#define MAX4MENNO 182\n#define MAX4MENNOODD 46\nint simen_table[MAX4MENNO+1];\nint simen_odd_table[MAX4MENNO+1];\nint polloc_table[MAXVAL];\nint polloc_odd_table[MAXVAL];\nint N;\n\n\nvoid make_simen()\n{\n  int i,j,k,l;\n  int simen,wa1,wa2,wa3,wa4;\n\n  for(i=0;i<MAXVAL;i++)\n    polloc_table[i]=INT_MAX;\n\n  for(i=1;i<=MAX4MENNO;i++)\n    {\n      wa1 = (i*(i+1)*(i+2))/6;\n      simen_table[i]=wa1;\n      \n      if(wa1 < MAXVAL && polloc_table[wa1] > 1)\n\tpolloc_table[wa1]=1;\n    }\n\n\n  for(i=1;i<=MAX4MENNO;i++)\n    for(j=i;j<=MAX4MENNO;j++)\n      {\n\twa2 = simen_table[i]+simen_table[j];\n\tif(wa2 < MAXVAL && polloc_table[wa2] > 2)\n\t  polloc_table[wa2]=2;\n\tfor(k=j;k<=MAX4MENNO;k++)\n\t  {\n\t    wa3 = wa2 + simen_table[k];\n\t    if(wa3 < MAXVAL && polloc_table[wa3] > 3)\n\t      polloc_table[wa3]=3;\n\t    for(l=k;l<=MAX4MENNO;l++)\n\t      {\n\t\twa4 = wa3 + simen_table[l];\n\t\tif(wa4 < MAXVAL && polloc_table[wa4] > 4)\n\t\t  polloc_table[wa4]=4;\n\t      }\n\t  }\n      }\n\n  //for(i=1;i<=10;i++)\n    // printf(\"p%d:%d\\n\",i,polloc_table[i]);\n}\n\nvoid make_simen_odd()\n{   \n  int i,j,j1,k,simen;\n\n  for(i=1;i<=MAX4MENNO;i++)\n    {\n      j=(i-1)*4+1;\n      simen_odd_table[i]=j*(j+1)*(j+2)/6;\n      //if(i<10)\n      //printf(\"%d\\n\",simen_odd_table[i]);\n    }\n  for(i=1;i<MAXVAL;i++)\n    polloc_odd_table[i]=INT_MAX;\n  \n  for(i=1;i<simen_odd_table[2];i++)\n    polloc_odd_table[i]=i;\n\n  //  for(i=2;i<=MAX4MENNOODD;i++)\n  for(i=2;i<=4;i++)\n    for(simen=simen_odd_table[i],j=simen,j1=1;j<MAXVAL;j+=simen,j1++)\n      for(k=0;k<simen;k++)\n\tif(polloc_odd_table[j+k] > j1+polloc_odd_table[k])\n\t  polloc_odd_table[j+k] = j1+polloc_odd_table[k];\n}\nint polloc(int n)\n{\n  int i,k1,k2,ret,mink;\n  //printf(\"N:%d;\",n);\n  ret=polloc_table[n];\n\n  if(ret != INT_MAX)\n    return(ret);\n  mink=INT_MAX;\n  for(i=1;i<=n/2;i++)\n    { \n      k1=polloc(i);\n      if(k1 > mink -1)\n\tcontinue;\n      k2=polloc(n-i);\n      if(k2 > mink -1)\n\tcontinue;\n      if(mink > k1+k2)\n\tmink = k1+k2;\n      if(mink==2)\n       break;\n    }\n    return(mink);  \n}\n\nint polloc_odd(int n)\n{\n  return(polloc_odd_table[n]);\n}\n\nmain()\n{\n  int ret,ret1;\n\n  make_simen();\n  make_simen_odd();\n  while (EOF != scanf(\"%d\",&N) && N)\n    {\n      ret=polloc(N);\n      ret1=polloc_odd(N);\n\n      printf(\"%d %d\\n\",ret,ret1);\n    }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n/* 200*(200+1)*(200+2)/6==1353400 */\nint num_list[200];\n\nint result_normal[1000001];\nint result_kisuu[1000001];\n\nint main(void) {\n\tint n;\n\tfor(n=1;n<=200;n++) {\n\t\tnum_list[n-1]=n*(n+1)*(n+2)/6;\n\t}\n\tresult_normal[0]=result_kisuu[0]=0;\n\tfor(n=1;n<1000000;n++) {\n\t\tint i;\n\t\tint normal=10000000;\n\t\tint kisuu=10000000;\n\t\tfor(i=0;i<200 && num_list[i]<=n;i++) {\n\t\t\tint nowresult;\n\t\t\tnowresult=result_normal[n-num_list[i]]+1;\n\t\t\tif(nowresult<normal)normal=nowresult;\n\t\t\tif(num_list[i]%2==1) {\n\t\t\t\tnowresult=result_kisuu[n-num_list[i]]+1;\n\t\t\t\tif(nowresult<kisuu)kisuu=nowresult;\n\t\t\t}\n\t\t}\n\t\tresult_normal[n]=normal;\n\t\tresult_kisuu[n]=kisuu;\n\t}\n\twhile(scanf(\"%d\",&n)==1 && n>0) {\n\t\tprintf(\"%d %d\\n\",result_normal[n],result_kisuu[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define num 100000\n#define true 1\n#define false 0\n\nvoid pollock();\nint min(int f1,int f2);\nint *dp_ki;\nint *dp;\nint N;\n\nint main(){\n\n  dp_ki = (int *)malloc(num);\n  dp = (int *)malloc(num);\n  for(int i=0;i<num;i++){\n    dp[i]=i;\n    dp_ki[i]=i;\n  }\n  pollock();\n\n  while(scanf(\"%d\",&N),N){\n    printf(\"%d %d\\n\",dp[N],dp_ki[N] );\n  }\n\n  free(dp_ki);\n  free(dp);\n  exit(0);\n}\n\nint min(int f1,int f2){\n  if(f1>f2){\n    return f2;\n  }else{\n    return f1;\n  }\n}\n\nvoid pollock(){\n  for(int n=3,p=4;p<num;n++){\n    for(int i=0;i+p<num;i++){\n      dp[i+p] = min(dp[i+p],dp[i]+1);\n    }\n    if(p%2){\n      for(int i=0;i+p<num;i++){\n        dp_ki[i+p] = min(dp_ki[i+p],dp_ki[i]+1);\n      }\n    }\n    p= n*(n+1)*(n+2)/6;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint min(int b,int c)\n{\n\tint M;\n\tif(b!=0 && c!=0)\n\t{\n\t   M=b;\n\t   if(M>c) M=c;\n\t}\n\telse\n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn M;\n}\n\nint main(void)\n{\n\tint i,j,k,l,z,n,a[1000],e[1000],dp[1000][1000001],dp2[1000][1000001];\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\ta[0]=0;\n\t\ti=1;\n\t\tz=0;\n\t\twhile(z==0)\n\t\t{\n\t\t\ta[i]=(i*(i+1)*(i+2))/6;\n\t\t\tif(a[i]>n) z=-1;\n\t\t\ti++;\n\t\t}\n\t\tk=i;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-a[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te[0]=0;\n\t\ti=0;\n\t\tj=1;\n\t\tz=0;\n\t\twhile(z==0)\n\t\t{\n\t\t\tif(a[j]%2==1)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\te[i]=a[j];\n\t\t\t\t\n\t\t\t}\n\t\t\tif(e[i]>n) z=-1;\n\t\t\tj++;\n\t\t}\n\t\tl=i-1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp2[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(e[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=min(dp2[i][j-e[i]]+1,dp2[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=dp2[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp[k][n],dp2[l][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\n#include<stdbool.h>\n#include<assert.h>\n#include<ctype.h>\ntypedef long long ll;\ntypedef long double ld;\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define rrep(i,l,r)for(ll i=(l);i>=(r);i--)\n#define INF (1LL<<60)\n#define MOD1 1000000007\n#define MOD2 998244353\n#define MAX_N (1 << 20)\n#define YES printf(\"Yes\\n\")\n#define NO printf(\"No\\n\")\n#define PN printf(\"\\n\")\n#define charsize 100005 //10^5+5\n#define PI 3.141592653589793238\n\nvoid swap(ll *a, ll *b){ll c;c=*b;*b=*a;*a= c;}\nvoid cin(ll *n){ scanf(\"%lld\",&(*n)); }\nll max2(ll a,ll b){return a>=b?a:b;}\nll min2(ll a,ll b){return a>=b?b:a;}\nll min3(ll a, ll b, ll c){return (a<=b && a<=c) ? a : b<=c ? b : c;}\nll max3(ll a, ll b, ll c){return (a>=b && a>=c) ? a : b>=c ? b : c;}\nll minn(ll n, ll a[]){ll b=INF;rep(i,0,n) b=min2(b,a[i]);return b;}\nll maxn(ll n, ll a[]){ll b=-INF;rep(i,0,n) b=max2(b,a[i]);return b;}\nll POW(ll a, ll b){ll c=1;rep(i,0,b) c*=a;return c;}\ndouble POW_d(double a, double b){double c=1;rep(i,0,b) c*=a;return c;}\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\nll mod_MOD1(ll n){n+= n<0?((-n)/MOD1+1)*MOD1:0; return n%=MOD1;}\nll mod_p(ll n ,ll p){n+= n<0?((-n)/p+1)*p:0; return n%=p;}\nll change_into_num(char s[] , ll len, ll p){ return !p ? 0 : POW(10,p-1)*(s[len-p]-'0') + change_into_num(s,len,p-1); }\nll digits(ll a, ll b){return a/b?1+digits(a/b,b):1;}\nll base(ll n, ll a, ll i){return i==1?n%a:base(n/a,a,i-1);}\nll is_inArr1(ll x, ll n){ return ( x<0 || x>=n ) ? 0 : 1 ; }\nll is_inArr2(ll y, ll x, ll h, ll w){ return ( y<0 || y>=h || x<0 || x>=w ) ? 0 : 1 ; }\n\n\nvoid lr_lower( int *l, int *r, ll am, ll val , int type ){ (type<3) ? ( am < val ?  ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ) : ( am <= val ? ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ); }\nvoid lr_upper( int *l, int *r, ll am, ll val , int type ){ (type<3) ? ( am <= val ?  ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ) : ( am < val ? ( *l = (*l+*r)/2 ) : ( *r= (*l+*r)/2 ) ); }\nint cmp_lower( ll a, ll b, int type ){ return (type==1) ? ( a==b ? 1 : 0 ) : (type==2) ? ( a>=b ? 1 : 0 ) : ( a>b ? 1 : 0 ) ; }\nint cmp_upper( ll a, ll b, int type ){ return (type==1) ? ( a==b ? 1 : 0 ) : (type==2) ? ( a<=b ? 1 : 0 ) : ( a<b ? 1 : 0 ) ; }\n// return smallest p  which meets  a[p]==val :1  >=:2   >:3\nll lower_bound( ll a[], int l, int r, ll val , int type ){  while(r-l>1) lr_lower(&l,&r,a[ (l+r)/2 ],val,type);  return cmp_lower(a[l],val,type) ? l : cmp_lower(a[r],val,type) ? r : -1;  }\n// return biggest p  which meets   a[p]==val :1  <=:2   <:3\nll upper_bound( ll a[], int l, int r, ll val , int type ){  while(r-l>1) lr_upper(&l,&r,a[ (l+r)/2 ],val,type); return cmp_upper(a[r],val,type) ? r : cmp_upper(a[l],val,type) ? l : -1; }\n// count i  which meets ai==x\nll count(ll a[], int l, int r, ll x){  int p = lower_bound(a,l,r,x,1);  return p==-1 ? 0 : upper_bound(a,p,r,x,1)-p+1; }\n\nll *factors[2] , fac_cnt=0 , is_factor_prepared=0;\nll factor_pre(){  rep(i,0,1){ if(is_factor_prepared++) return 0; }  ll tmp=(1e6)/2+1, fac_tmp[tmp];  rep(i,0,tmp){fac_tmp[i]=i?2*i+1:2;}  rep(i,1,tmp){if(fac_tmp[i]){  repp(j,3,tmp/(2*i+1)+1,2 ){  if( j*(2*i+1)<tmp ) fac_tmp[ (j*(2*i+1)-1)/2 ]=0;  }  }else continue;}  rep(i,0,tmp){if(fac_tmp[i]){  rep(j,0,2){ factors[j] = realloc( factors[j] , sizeof(ll)*( fac_cnt +1 ) );  factors[j][j?fac_cnt++:fac_cnt]=j?0:fac_tmp[i];  }  } }  return 0;  }\nll factor(ll n, ll new_common_plus){ factor_pre();  rep(i,0,fac_cnt){ ll cnt=0; rep(j,0,1){ while( ( cnt+= n %factors[0][i]==0 ? 1 : 0 )  && (n/=factors[0][i]) %factors[0][i]==0 ) continue; } factors[1][i]= new_common_plus==1 ? cnt :  new_common_plus==2 ? max2(factors[1][i],cnt) : factors[1][i]+cnt ;  if( factors[0][i]> n ) break; } return n; }\nll judge_prime(ll n){ factor_pre(); rep(i,0,fac_cnt){ if(n<factors[0][i]*factors[0][i] || n==factors[0][i]) break; else if(n%factors[0][i]==0) n/=n; }  return n==1?0:1; }\n\nll *mf_arr,*inv_arr,*finv_arr,is_minv_made=0,is_mf_made=0,num_of_inv=2*1e6+10;\nll makeinv(ll n , ll mod){  rep(i,0,1){if(is_minv_made++) return 0;}  inv_arr = realloc(inv_arr, sizeof(ll)*2 );  finv_arr = realloc(finv_arr, sizeof(ll)*2 );  inv_arr[1]=1;finv_arr[0]=finv_arr[1]=1;  rep(i,2,n+1){  inv_arr = realloc(inv_arr, sizeof(ll)*(i+1) );  finv_arr = realloc(finv_arr, sizeof(ll)*(i+1) );  inv_arr[i]= mod - inv_arr[mod%i] * (mod / i) % mod;  finv_arr[i] = finv_arr[i - 1] * inv_arr[i] % mod;  }  return 0; }\nll make_mf(ll n, ll mod){  rep(i,0,1){ if(is_mf_made++) return 0; }  mf_arr = realloc(mf_arr, sizeof(ll)*2 );  ll x=1;  mf_arr[0]=mf_arr[1]=x;  rep(i,2,n+1){   x=x*i%mod;  mf_arr = realloc(mf_arr, sizeof(ll)*(i+1) );  mf_arr[i]=x; }  return 0;  }\nll m_inv(ll x, ll mod, ll is_fac ){ makeinv(num_of_inv,mod);  return is_fac?finv_arr[x]:inv_arr[x]; }\nll m_f(ll x, ll mod){  make_mf(num_of_inv,mod);  return mf_arr[x];  }\nll mod_nck(ll n, ll k, ll mod){ return m_f(n,mod)*m_inv(k,mod,1)%mod*m_inv(n-k,mod,1)%mod; }\nll m_p(ll r,ll n,ll mod){  ll t=1,s=r;  while(n>0){ t = (n&1) ? t*s%mod : t;  s=s*s%mod; n>>=1; }  return r?t:0;  }\nll m_mul2(ll a, ll b, ll mod){ return a*b%mod; }\nll m_mul3(ll a, ll b, ll c, ll mod){ return m_mul2(a*b%mod,c,mod); }\nll m_mul4(ll a, ll b, ll c, ll d, ll mod){ return m_mul3(a*b%mod,c,d,mod); }\nll m_mul5(ll a, ll b, ll c, ll d, ll e, ll mod){ return m_mul4(a*b%mod,c,d,e,mod); }\n\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nint cmp_string( const void * a , const void * b ) {  return strcmp( (char *)a , (char *)b ); }  // qsort((void*)s,n,sizeof(s[0]),int_sort );\nint cmp_char(const void * a, const void * b) { return *(char *)a - *(char *)b;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nvoid sort_string(int n,int size,char s[][size]){ qsort( (void*)s , n , sizeof(s[0]) , cmp_string ); }\nvoid sort_char(char *s){ qsort( (void *)s , strlen(s) , sizeof(char) , cmp_char ); }\nll unique_string(ll n ,ll size, char s[][size]){ ll ans=1; rep(i,1,n) if( strcmp(s[i],s[i-1]) ) ans++; return ans; }\nll unique_num(ll n , ll a[]){ ll ans=1; rep(i,1,n) if( a[i]!=a[i-1] ) ans++; return ans; }\n\ntypedef struct{ ll a , b;}fr;\nint cmp1( const void *p, const void *q ) { return ((fr*)p) ->a - ((fr*)q)->a;}\nint cmp2( const void *p, const void *q ) { return ((fr*)q) ->a - ((fr*)p)->a;}\nvoid strsortup(fr*a,int n){qsort(a,n,sizeof(fr),cmp1);}\nvoid strsortdown(fr*a,int n){qsort(a,n,sizeof(fr),cmp2);}\n\n\n\n\n// char s[1151154];\nll pol[1000];\nll pol_o[1000];\nll pol_cnt,pol_o_cnt;\nll mem[1151151];\nll mem_o[1151151];\n\nll pollock(){\n    ll cnt=0;\n    rep(i,0,1e6){\n        if( (i+1)*(i+2)*(i+3)/6 > POW(10,6) ){\n            pol_cnt=i; pol_o_cnt=cnt; break;\n        }\n        pol[i]=(i+1)*(i+2)*(i+3)/6;\n        mem[pol[i]]=1;\n        if(pol[i]%2){\n            pol_o[cnt++]=pol[i];\n            mem_o[pol[i]]=1;\n        }\n    }\n    return 0;\n}\n\n\nll dfs(ll x){\n    // printf(\"%lld\\n\",x);\n    if(!x) return 0;\n    if(mem[x]) return mem[x];\n    ll ans=INF;\n    ll p=upper_bound(pol,0,pol_cnt-1,x,2);\n    if(p==-1){ return -1; }\n    rrep(i,p,0){\n        // printf(\"%lld %lld %lld\\n\",x,pol[i],ans);\n        ll t=dfs(x-pol[i]);\n        // printf(\"%lld %lld %lld\\n\",i,t,ans);\n        if(t==-1) continue;\n        ans=min2(ans,t);\n    }\n    if(ans>1e15) return -1;\n    mem[x]=ans+1;\n    return ans+1;\n}\n\nll dfs_o(ll x){\n    // printf(\"%lld\\n\",x);\n    if(!x) return 0;\n    if(mem_o[x]) return mem_o[x];\n    ll ans=INF;\n    ll p=upper_bound(pol_o,0,pol_o_cnt-1,x,2);\n    // printf(\"%lld\\n\",p);\n    if(p==-1){ return -1; }\n    rrep(i,p,0){\n        // if(pol_o[i]+pol_o[i]<x) break;\n        // printf(\"%lld %lld %lld\\n\",x,pol[i],ans);\n        ll t=dfs_o(x-pol_o[i]);\n        // printf(\"%lld %lld %lld\\n\",i,t,ans);\n        if(t==-1) continue;\n        ans=min2(ans,t);\n    }\n    if(ans>1e15) return -1;\n    mem_o[x]=ans+1;\n    return ans+1;\n}\n\nint main(void){\n    // fgets(s,sizeof(s),stdin); \n    ll n;\n    pollock();\n    while(1){\n        cin(&n);\n        if(!n) break;\n        printf(\"%lld %lld\\n\",dfs(n),dfs_o(n) );\n    }\n\n    // ll [n];\n    // rep(i,0,n){\n    //     cin(&[i]);\n    // }\n\n    // printf(\"%lld\\n\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000001\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint min(int a, int b){\n  if(a<b)return a;\n  else return b;\n}\n\nint dp[2000000];\nint DP[2000000];\n\nint main(){\n  int i,j,x;\n\n  for(i=1;i<=1000000;i++){\n   \n    dp[i]=i;\n    DP[i]=i;\n    for(j=1;;j++){\n      x=j*(j+1)*(j+2)/6;\n      if(i-x<0)break;\n      dp[i]=min(dp[i],dp[i-x]+1);\n      if(x%2==1){\n\tDP[i]=min(DP[i],DP[i-x]+1);\n      }\n    }\n  }\n\n\n  while(1){\n    scanf(\"%d\",&x);\n    if(x==0)break;\n    printf(\"%d %d\\n\",dp[x],DP[x]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_X     1000000\n#define INFINITY  MAX_X\n#define tetra(n)  ((n) * ((n)+1) * ((n)+2) / 6)\n\nint polloc(int x, int oddOnly)\n{\n  static int solution[MAX_X];\n  int i, j;\n\n  /* initialize */\n  for (i = 1; i <= x; i++) {\n    solution[i] = INFINITY;\n  }\n  for (i = 1; tetra(i) <= x; i++) {\n    if (! oddOnly || tetra(i) % 2 == 1) {\n      solution[tetra(i)] = 1;\n    }\n  }\n\n  /* dynamic programming */\n  for (i = 1; i <= x; i++) {\n    for (j = 1; j < i; j++) {\n      if (solution[i] > solution[j] + solution[i - j]) {\n          solution[i] = solution[j] + solution[i - j];\n      }\n    }\n  }\n  return solution[x];\n}\n\nint main()\n{\n  int x;\n  for (;;) {\n    scanf(\"%d\", &x);\n    if (x == 0) break;\n    printf(\"%d %d\\n\", polloc(x, 0), polloc(x, 1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define num 100000\n#define true 1\n#define false 0\n\nvoid pollock();\nint min(int f1,int f2);\nint *dp_ki;\nint *dp;\nint N;\n\nint main(){\n  dp_ki = (int *)malloc(num * sizeof(int));\n  dp = (int *)malloc(num * sizeof(int));\n  for(int i=0;i<num;i++){\n    dp[i]=i;\n    dp_ki[i]=i;\n  }\n  pollock();\n\n  while(scanf(\"%d\",&N),N){\n    printf(\"%d %d\\n\",dp[N],dp_ki[N] );\n  }\n\n  free(dp_ki);\n  free(dp);\n  exit(0);\n}\n\nint min(int f1,int f2){\n  if(f1>f2){\n    return f2;\n  }else{\n    return f1;\n  }\n}\n\nvoid pollock(){\n  for(int n=3,p=4;p<num;n++){\n    for(int i=0;i+p<num;i++){\n      dp[i+p] = min(dp[i+p],dp[i]+1);\n      // dp[i+p] = dp[i] + 1;\n    }\n    if(p%2){\n      for(int i=0;i+p<num;i++){\n        dp_ki[i+p] = min(dp_ki[i+p],dp_ki[i]+1);\n        // dp_ki[i+p] = dp_ki[i] + 1;\n      }\n    }\n    p= n*(n+1)*(n+2)/6;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 1000000\n\n/* 正四面体数列 */\nint tetra[200]; /* 10^6以下の正四面体数は180個 */\nint tetra_l;\nint tetra_odd[100];\nint tetra_odd_l;\n\nint divide[MAX+1]; /* ある正整数を和で表すために必要な正四面体数の個数 */\nint divide_odd[MAX+1]; /* ある正整数を和で表すために必要な「奇数」正四面体数の個数 */\n#define UNKNOWN 0\n\nint main(void) {\n\tint n, i;\n\n\t// 正四面体数列を生成する\n\tfor (i = 1, tetra_l = 0, tetra_odd_l = 0; (n = i * (i + 1) * (i + 2) / 6) <= MAX; i++) {\n\t\ttetra[tetra_l++] = n;\n\t\tif (n % 2 != 0) tetra_odd[tetra_odd_l++] = n; /* 奇数のみの正四面体数列 */\n\t}\n\n\t/* 初期化する */\n\tfor (n = 0; n <= MAX; n++) {\n\t\tdivide[n] = UNKNOWN;\n\t\tdivide_odd[n] = UNKNOWN;\n\t}\n\n\t/* 入力されうる全ての正整数について、必要な正四面体数の個数を求める */\n\t/* 正四面体数 */\n\tfor (i = 0; i < tetra_l; i++) divide[tetra[i]] = 1;\n\tfor (i = 0; i < tetra_odd_l; i++) divide_odd[tetra_odd[i]] = 1;\n\t/* 正四面体数でない正整数 */\n\tfor (n = 1; n <= MAX; n++) {\n\t\t/* (個数が既知の正整数 + 正四面体数) に必要な個数は、その既知の個数に1を加えた数である */\n\t\tfor (i = 0; i < tetra_l && n + tetra[i] <= MAX; i++) {\n\t\t\tif (divide[n + tetra[i]] == UNKNOWN || divide[n] + 1 < divide[n + tetra[i]]) {\n\t\t\t\tdivide[n + tetra[i]] = divide[n] + 1;\n\t\t\t}\n\t\t}\n\t\t/* 奇数のみの場合 */\n\t\tfor (i = 0; i < tetra_odd_l && n + tetra_odd[i] <= MAX; i++) {\n\t\t\tif (divide_odd[n + tetra_odd[i]] == UNKNOWN || divide_odd[n] + 1 < divide_odd[n + tetra_odd[i]]) {\n\t\t\t\tdivide_odd[n + tetra_odd[i]] = divide_odd[n] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* 与えられる正整数毎の処理 */\n\twhile (scanf(\"%d\", &n) == 1 && n > 0 && n <= MAX) printf(\"%d %d\\n\", divide[n], divide_odd[n]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 1000000\n#define MIN(A,B) \\\n  ( (B) < (A) ? (B) : (A) )\n\nstatic int k_operafan[ 2 ][ N ];\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i, j;\n  int mode;\n\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  k_operafan[ 0 ][ 0 ] = k_operafan[ 1 ][ 0 ] = 0;\n  for ( mode = 0; mode <= 1; ++mode )\n  for ( i = 1; i < N; ++i )\n  {\n    k_operafan[ mode ][ i ] = i;\n    for ( j = 1; ; ++j )\n    {\n      const int c = j * ( j + 1 ) * ( j + 2 ) / 6;\n\n      if ( i - c < 0 )\n        break ;\n      if ( mode && ( c % 2 == 0 ) )\n        continue ;\n\n      k_operafan[ mode ][ i ] = MIN( k_operafan[ mode ][ i ]\n                                   , k_operafan[ mode ][ i - c ] + 1 );\n    }\n  }\n\n  for ( ; ; )\n  {\n    int n;\n\n    scanf ( \"%d\", &n );\n    if ( n == 0 ) break ;\n\n    printf ( \"%d %d\\n\", k_operafan[ 0 ][ n ], k_operafan[ 1 ][ n ] );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\n#define MAX (int)1e+6\n\nint main(void)\n{\n\n  int i,j;\n  int a[181],b[46];\n  int n;\n  int dp1[MAX],dp2[MAX];\n\n  b[0] = 0;\n  j = 1;\n  for(i=0;i<181;i++){\n    a[i] = i * (i+1) * (i+2) / 6;\n    if(a[i]%2){\n      b[j] = a[i];\n      j++;\n    }\n  }\n\n  for(i=0;i<MAX;i++){\n    dp1[i] = 6;\n    dp2[i] = 1000000;\n  }\n\n  for(i=0;i<MAX;i++){\n    for(j=0;j<181;j++){\n      if(i>a[j]){\n\tif(dp1[i] > dp1[i-a[j]]+1){\n\t  dp1[i] = dp1[i-a[j]]+1;\n\t}\n      }else if(i==a[j]){\n\tdp1[i]=1;\n      }else break;\n    }\n  }\n  \n  for(i=0;i<MAX;i++){\n    for(j=0;j<46;j++){\n      if(i>b[j]){\n\tif(dp2[i] > dp2[i-b[j]]+1){\n\t  dp2[i] = dp2[i-b[j]]+1;\n\t}\n      }else if(i==b[j]){\n\tdp2[i]=1;\n      }else break;\n    }\n  }\n\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(!n)break;\n\n    printf(\"%d %d\\n\",dp1[n],dp2[n]);\n\n   \n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C",
    "code": "a[181],m1[1000000],m2[1000000],T;\nint s(p,n,f){\n\tint *m=p,d=180;\n\tif(!n)return 0;\n\tif(m[n]<1000000)return m[n];\n\tfor(;d;d--){\n\t\tif(a[d]>n||(f&&!(a[d]&1)))continue;\n\t\tT=s(p,n-a[d],f)+1;\n\t\tif(m[n]>T)m[n]=T;\n\t}\n\treturn m[n];\n}\n\nmain(n){\n\tfor(n=1;n<181;n++)a[n]=n*(n+1)*(n+2)/6;\n\tmemset(m1,99,sizeof(m1));\n\tmemset(m2,99,sizeof(m2));\n\tfor(;scanf(\"%d\",&n),n;)printf(\"%d %d\\n\",s(m1,n,0,0),s(m2,n,0,1));\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main() {\n  int N;\n  int simen[1000];\n  int i, j;\n  int value, newValue;\n  int data1[1000000], data2[1000000];\n\n  for(i = 0; i < 1000; i++) {\n    simen[i] = i*(i+1)*(i+2)/6;\n  }\n\n  data1[0] = 0;\n  for(i = 1; i < 1000000; i++) {\n    data1[i] = 999999;\n    for(j = 1; j <= i; j++) {\n      if(simen[j] > i) break;\n      newValue = data1[i-simen[j]]+1;\n      if(newValue < data1[i]) data1[i] = newValue;\n    }\n  }\n\n  data2[0] = 0;\n  for(i = 1; i < 1000000; i++) {\n    data2[i] = 999999;\n    for(j = 1; j <= i; j++) {\n      if(simen[j] > i) break;\n      if(simen[j] % 2 == 0) continue;\n      newValue = data2[i-simen[j]]+1;\n      if(newValue < data2[i]) data2[i] = newValue;\n    }\n  }\n\n  while(1) {\n    scanf(\"%d\", &N);\n    if(N == 0) break;\n    printf(\"%d %d\\n\", data1[N], data2[N]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define num 1000000\n#define true 1\n#define false 0\n\nvoid pollock();\nint min(int f1,int f2);\nint *dp_ki;\nint *dp;\nint N;\n\nint main(){\n  dp_ki = (int *)malloc(num * sizeof(int));\n  dp = (int *)malloc(num * sizeof(int));\n  for(int i=0;i<num;i++){\n    dp[i]=i;\n    dp_ki[i]=i;\n  }\n  pollock();\n\n  while(scanf(\"%d\",&N),N){\n    printf(\"%d %d\\n\",dp[N],dp_ki[N] );\n  }\n\n  free(dp_ki);\n  free(dp);\n  exit(0);\n}\n\nint min(int f1,int f2){\n  if(f1>f2){\n    return f2;\n  }else{\n    return f1;\n  }\n}\n\nvoid pollock(){\n  for(int n=3,p=4;p<num;n++){\n    for(int i=0;i+p<num;i++){\n      dp[i+p] = min(dp[i+p],dp[i]+1);\n      // dp[i+p] = dp[i] + 1;\n    }\n    if(p%2){\n      for(int i=0;i+p<num;i++){\n        dp_ki[i+p] = min(dp_ki[i+p],dp_ki[i]+1);\n        // dp_ki[i+p] = dp_ki[i] + 1;\n      }\n    }\n    p= n*(n+1)*(n+2)/6;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#define _USE_MATH_DEFINES\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>\n#define EPS 1e-10\n#define sq(n) ((n)*(n))\n#define rep(i,n) for(i=0;i<n;i++)\n#define rev(i,n) for(i=n-1;i>=0;i--)\n#define sort(a,n) qsort(a,n,sizeof(TYPE),cmp)\n#define sort_r(a,n) qsort(a,n,sizeof(TYPE),cmp_r);\n#define chsort(s,n) qsort(s,n,sizeof(char),cmp)\n#define chsort_r(s,n) qsort(s,n,sizeof(char),char_cmp_r);\n#define TYPE int\n#define MEMSET(a) memset(a,0,sizeof(a))\nlong long mod=(long long)1e09+7;\nint inf=1<<29;\nlong long llinf=1ll<<60;\n\nint in(void){\n    int i;scanf(\"%d\",&i);\n    return i;\n}\nlong long llin(void){\n    long long i;scanf(\"%lld\",&i);\n    return i;\n}\ndouble din(void){\n    double i;scanf(\"%lf\",&i);\n    return i;\n}\nvoid chin(char s[]){\n    scanf(\"%s\",s);\n}\nvoid print(int a){\n    printf(\"%d\\n\",a);\n}\nvoid llprint(long long a){\n    printf(\"%lld\\n\",a);\n}\nvoid dprint(double a){\n    printf(\"%.10f\\n\",a);\n}\nvoid print2(int a,int b){\n    printf(\"%d %d\\n\",a,b);\n}\nlong long max(long long a,long long b){\n    return a>b?a:b;\n}\nlong long min(long long a,long long b){\n    return a<b?a:b;\n}\nint cmp(const void *a,const void *b){\n    return *(TYPE *)a-*(TYPE *)b;\n}\nint cmp_r(const void *a,const void *b){\n    return *(TYPE *)b-*(TYPE *)a;\n}\nint char_cmp(const void *a,const void *b){\n    return strcmp((char *)a,(char *)b);\n}\nint char_cmp_r(const void *a,const void *b){\n    return strcmp((char *)b,(char *)a);\n}\nvoid swap(int *a,int *b){\n    int t=*a;\n    *a=*b;\n    *b=t;\n}\nlong long gcd(long long x,long long y){\n    return x%y?gcd(y,x%y):y;\n}\nlong long lcm(long long x,long long y){\n    return x/gcd(x,y)*y;\n}\n\n// write codes below this\n// when you use 'sort',\n// make sure TYPE macro is correct\nint dp[1000001];\nint dp_o[1000001];\nint pn[200];\nint po[200];\n\nint main(void){\n    int n,i,j=0,s;\n    rep(i,200){\n        pn[i]=i*(i+1)*(i+2)/6;\n        if(pn[i]%2)po[j++]=pn[i];\n    }\n    s=j;\n    rep(i,1000001)dp[i]=dp_o[i]=inf;\n    dp[0]=dp_o[0]=0;\n    rep(i,200){\n        for(j=pn[i];j<1000001;j++){\n            dp[j]=min(dp[j-pn[i]]+1,dp[j]);\n        }\n    }\n    rep(i,s){\n        for(j=po[i];j<1000001;j++){\n            dp_o[j]=min(dp_o[j-po[i]]+1,dp_o[j]);\n        }\n    }\n    while(1){\n        n=in();\n        if(!n)break;\n        print2(dp[n],dp_o[n]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void){\n\twhile(1){\n\t\tint n, i=0, j, k;\n\t\tint a[100];\n\t\tint dp[1000001];\n\t\tint dq[1000001];\n\t\t\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n==0) break;\n\t\t\n\t\tfor(k=0; k<=n; k++){\n\t\t\tdp[k] = 25000;\n\t\t\tdq[k] = 25000;\n\t\t}\n\t\t\n\t\tdp[0]=0;\n\t\tdq[0]=0;\n\t\t\n\t\t\n\t\twhile(1){\n\t\t\ta[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t\tif(a[i] > n) break;\n\t\t\ti++;\n\t\t}\n\t\t\t\n\t\tfor(k=0; k<=n; k++){\n\t\t\tfor(j=0; j<i; j++){\n\t\t\t\tif(k-a[j] >= 0) {\n\t\t\t\t\tif(dp[k] > dp[k-a[j]]+1)\n\t\t\t\t\t\tdp[k] = dp[k-a[j]]+1;\n\t\t\t\t\telse dp[k] = dp[k];\n\t\t\t\t\t\n\t\t\t\t\tif(a[j]%2 != 0){\n\t\t\t\t\t\tif(dq[k] > dq[k-a[j]]+1)\n\t\t\t\t\t\t\tdq[k] = dq[k-a[j]]+1;\n\t\t\t\t\t\telse dq[k] = dq[k];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t//for(k=0; k<=n; k++)\n\t\t\t//printf(\"dp[%d]=%d\\n\",k,dp[k]);\n\t\t\n\t\tprintf(\"%d %d\\n\", dp[n], dq[n]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "a[181],m1[1000000],m2[1000000],T;\nint s(p,n,d,c,f){\n\tint *m=p;\n\tif(!n)return 0;\n\tif(m[n]<1000000)return m[n];\n\tfor(;d;d--){\n\t\tif(a[d]>n||(f&&!(a[d]&1)))continue;\n\t\tT=s(p,n%a[d],d-1,c+n/a[d],f)+n/a[d];\n\t\tif(m[n]>T)m[n]=T;\n\t}\n\treturn m[n];\n}\n\n//#define R(s,i)for(i=s;i<181;i++)\n//#define Z(e,n)if(e>1000000)break;if(b[e]>n)b[e]=n;\n//b[1000000];\nmain(n){\n\tfor(n=1;n<181;n++)a[n]=n*(n+1)*(n+2)/6;\n\tmemset(m1,99,sizeof(m1));\n\tmemset(m2,99,sizeof(m2));\n/*\n\tmemset(b,99,sizeof(b));\n\tR(1,i){\n\t\tZ(a[i],1)R(i,j){\n\t\t\tZ(a[i]+a[j],2)R(j,k){\n\t\t\t\tZ(a[i]+a[j]+a[k],3)R(k,l){\n\t\t\t\t\tZ(a[i]+a[j]+a[k]+a[l],4)R(l,m){\nprintf(\"%d %d %d %d %d\\n\",i,j,k,l,m);\n\t\t\t\t\t\tZ(a[i]+a[j]+a[k]+a[l]+a[m],5)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n*/\n\tfor(;scanf(\"%d\",&n),n;)printf(\"%d %d\\n\",s(m1,n,180,0,0),s(m2,n,180,0,1));\nexit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(void){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 1167\n   Pollock's conjecture\n   \n*/\n\n#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\nint *a, min;\n\nvoid dfs_odd(int x, int i, int c)\n{\n  if(min < c)\n    {\n      return ;\n    }\n  for(; i > 0; i--)\n    {\n      if(a[i] % 2 == 0)\n\tcontinue;\n      if(x - a[i] == 0)\n\t{\n\t  if(min > c)\n\t    {\n\t      min = c;\n\t      return ;\n\t    }\n\t}\n      else if(x - a[i] > 0)\n\tdfs_odd(x - a[i], i, c + 1);\n    }\n  return ;\n}\n\nvoid dfs(int x, int i, int c)\n{\n  if(min < c)\n    {\n      return ;\n    }\n  for(; i > 0; i--)\n    {\n      if(x - a[i] == 0)\n\t{\n\t  if(min > c)\n\t    {\n\t      min = c;\n\t      return ;\n\t    }\n\t}\n\t\n      else if(x - a[i] > 0)\n\tdfs(x - a[i], i, c + 1);\n    }\n  return ;\n}\n\n\n\nint main(void)\n{\n  int x, i, max_a;\n  for(i = 1; i * (i + 1) * (i + 2) / 6 < 1000000; i++);\n  max_a = i;\n  a = malloc(sizeof(int) * max_a);\n\n  for(i = 1; i < max_a; i++)\n    {\n      a[i] = i * (i + 1) * (i + 2) / 6;\n    }\n  int m;\n  while(scanf(\"%d\", &x), x)\n    {\n      min = INT_MAX;\n      for(i = 1; x >= a[i]; i++);\n      m = i - 1;\n      dfs(x, m, 1);\n      printf(\"%d \", min);\n      min = INT_MAX;\n      dfs_odd(x, m, 1);\n      printf(\"%d\\n\", min);\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nmain(){\n  int data[1000], i, min2, j, k, n, min, ans[1000000], ans2[1000000];\n\n  for(i=0;i<1000;i++){\n    data[i]=(i+1)*(i+2)*(i+3)/6;\n  }\n\n  ans[0]=0;\n  ans2[0]=0;\n  for(i=1;i<1000000;i++){\n    min=1000000;\n    min2=1000000;\n    for(j=0;data[j]<=i;j++){\n      if(min>ans[i-data[j]]) min=ans[i-data[j]]+1;\n      if(data[j]%2!=0){\n\tif(min2>ans2[i-data[j]]) min2=ans2[i-data[j]]+1;\n      }\n    }\n    ans[i]=min;\n    ans2[i]=min2;\n  }\n  while(1){\n    scanf(\"%d\", &n);\n    if(n==0) break;\n    printf(\"%d %d\\n\", ans[n], ans2[n]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint bs (int [], int, int);\n\nint min(int b,int c)\n{\n\tint M;\n\tif(b!=0 && c!=0)\n\t{\n\t   M=b;\n\t   if(M>c) M=c;\n\t}\n\telse\n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn M;\n}\n\nint main(void)\n{\n\tint i,j,k,l,n,a[500],e[500],dp[2][1000001],dp2[2][1000001];\n\t\n\ta[0]=0;\n    for(i=1;a[i]<=500;i++)\n    {\n\t\ta[i]=i*(i+1)*(i+2);\n\t\ta[i]=a[i]/6;\n\t}\n\te[0]=0;\n\tj=1;\n\tfor(i=1;i<=500;i++)\n\t{\n\t\ta[i]=i*(i+1)*(i+2);\n\t\ta[i]=a[i]/6;\n\t\tif(a[i]%2==1)\n\t\t{\n\t\t\te[j]=a[i];\n\t\t\tj++;\n\t\t}\n\t}\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tk=bs(a,501,n);\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[1][j]=min(dp[1][j-a[i]]+1,dp[0][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[1][j]=dp[0][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tdp[0][j]=dp[1][j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \",dp[1][n]);\n\t\tl=bs(e,j,n);\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp2[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(e[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp2[1][j]=min(dp2[1][j-e[i]]+1,dp2[0][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[1][j]=dp2[0][j];\n\t\t\t\t}\n\t\t\t\tfor(j=0;j<=n;j++)\n\t\t\t    {\n\t\t\t\t   dp2[0][j]=dp2[1][j];\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp2[1][n]);\n\t}\n\treturn 0;\n}\n\nint bs (int D[], int n, int c) \n {\n    int j,k,l;\n    j=0;\n    k=n-1;\n    while(1)\n    {\n        if(j<=k)\n        {\n            l=(j+k)/2;\n            if(D[l] > c)\n            {\n                k=l-1;\n            }\n            else if(D[l+1] < c)\n            {\n                j=l+1;\n            }\n            else\n            {\n                return l;\n            }\n        }\n        else\n        {\n            return k;\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a,b) a<b?a:b\n\nint main(){\n\tint n;\n\tint i,j;\n\tint c;\n\tint a[1000001];\n\tint b[1000001];\n \n\tfor(i = 0;i < 1000001;i++){\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\n\tfor(i = 3,c = 4;i < 1000001;i++){\n\t\tfor(j = a;j < 1000001;j++){\n\t\t\ta[i] = min(a[i],a[i-c]+1);\n\t\t}\n\t\tif(a % 2){\n\t\t\tfor(j = a;j < 1000001;j++){\n\t\t\t\tb[i] = min(b[i],b[i-c]+1);\n\t\t\t}\n\t\t}\n\t\tc = i * (i+1) * (i+2) / 6;\n\t}\n\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",a[n],b[n]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int d[1000010],c[1000010],M=1e6,a,i,j;\n  for(i=0;i<M;i++)d[i]=c[i]=1e9;\n  d[0]=c[0]=0;\n  for(i=1;i<100;i++){\n    a=(i*(i+1)*(i+2))/6;\n    for(j=0;j+a<M;j++)d[j+a]=MIN(d[j+a],d[j]+1);\n    if(a%2){\n      for(j=0;j+a<M;j++)c[j+a]=MIN(c[j+a],c[j]+1);\n    }\n  }\n  while(scanf(\"%d\",&a),a)printf(\"%d %d\\n\",d[a],c[a]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint numbers[180];\n\nint memo[2][180][1000000];\n\nint tansaku(int pos,int rest,int force_kisuu) {\n\tint i;\n\tint result=0x10000000;\n\tint now;\n\tif(rest==0)return 0;\n\tif(numbers[pos]>rest)return 0x10000000;\n\tif(memo[force_kisuu][pos][rest]>0) {\n\t\treturn memo[force_kisuu][pos][rest]-1;\n\t}\n\tfor(i=pos;i<180 && numbers[i]<=rest;i++) {\n\t\tif(!force_kisuu || numbers[i]%2!=0) {\n\t\t\tnow=tansaku(i,rest-numbers[i],force_kisuu)+1;\n\t\t\tif(now<result)result=now;\n\t\t}\n\t}\n\tmemo[force_kisuu][pos][rest]=result+1;\n\treturn result;\n}\n\nint main(void) {\n\tint i;\n\tint query;\n\n\tfor(i=0;i<180;i++)numbers[i]=i+1;\n\tfor(i=1;i<180;i++)numbers[i]+=numbers[i-1];\n\tfor(i=1;i<180;i++)numbers[i]+=numbers[i-1];\n\n\twhile(1) {\n\t\tscanf(\"%d\",&query);\n\t\tif(query==0)break;\n\t\tprintf(\"%d %d\\n\",tansaku(0,query,0),tansaku(0,query,1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1167: Pollock's conjecture\n// 2017.9.14 bal4u@uu\n\n#include <stdio.h>\n\n#define min(a,b) ((a)<=(b)?(a):(b))\n#define MAX 1000000\n#define N 181\nint tbl[N+3], a[MAX+3], b[MAX+3];\n\nint main()\n{\n\tint n, i, j;\n\n\tfor (n = 1; n <= N; n++) tbl[n] = tbl[n-1] + (n*(n+1) >> 1);\n\tfor (i = 1; i <= MAX; i++) {\n\t\ta[i] = b[i] = i;\n\t\tfor (j = 0; tbl[j] <= i; j++) {\n\t\t\ta[i] = min(a[i], a[i-tbl[j]]+1);\n\t\t\tif (tbl[j] & 1) b[i] = min(b[i], b[i-tbl[j]]+1);\n\t\t}\n\t}\n\twhile(scanf(\"%d\", &n) && n)\tprintf(\"%d %d\\n\", a[n], b[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define min(x, y) ((x)<(y)?(x):(y))\n\nint s[200], dp0[1000010], dp1[1000010];\n\nint main(void)\n{\n    int i, j, k, n;\n    for(k=1;k*(k+1)*(k+2)<6000000;++k) {\n        int t=k*(k+1)*(k+2)/6;\n        dp0[t]=1;\n        if (t%2) dp1[t]=1;\n        s[k]=t;\n    }\n    for(i=1;i<1000010;++i) {\n        if (!dp0[i]) {\n            dp0[i]=i;\n            for(j=1;j<k&&s[j]<i;++j)\n                dp0[i]=min(dp0[i], dp0[i-s[j]]+dp0[s[j]]);\n        }\n        if (!dp1[i]) {\n            dp1[i]=i;\n            for(j=1;j<k&&s[j]<i;j+=2)\n                dp1[i]=min(dp1[i], dp1[i-s[j]]+dp1[s[j]]);\n        }\n    }\n\n    while (scanf(\"%d\", &n), n) {\n        printf(\"%d %d\\n\", dp0[n], dp1[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define num 100000\n#define true 1\n#define false 0\n\nvoid pollock();\nint min(int f1,int f2);\nint *dp_ki;\nint *dp;\nint N;\n\nint main(){\n  dp_ki = (int *)malloc(num * sizeof(int));\n  dp = (int *)malloc(num * sizeof(int));\n  for(int i=0;i<num;i++){\n    dp[i]=i;\n    dp_ki[i]=i;\n  }\n  pollock();\n\n  while(scanf(\"%d\",&N),N){\n    printf(\"%d %d\\n\",dp[N],dp_ki[N] );\n  }\n\n  free(dp_ki);\n  free(dp);\n  exit(0);\n}\n\nint min(int f1,int f2){\n  if(f1>f2){\n    return f2;\n  }else{\n    return f1;\n  }\n}\n\nvoid pollock(){\n  for(int n=3,p=4;p<num;n++){\n    for(int i=0;i+p<num;i++){\n      dp[i+p] = min(dp[i+p],dp[i]+1);\n    }\n    if(p%2){\n      for(int i=0;i+p<num;i++){\n        dp_ki[i+p] = min(dp_ki[i+p],dp_ki[i]+1);\n      }\n    }\n    p= n*(n+1)*(n+2)/6;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  //while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",n,n);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main() {\n  int N;\n  int simen[1000];\n  int i, j;\n  int value, newValue;\n  int data[1000000];\n\n  for(i = 0; i < 1000; i++) {\n    simen[i] = i*(i+1)*(i+2)/6;\n  }\n\n  while(1) {\n    scanf(\"%d\", &N);\n    if(N == 0) break;\n    data[0] = 0;\n    for(i = 1; i <= N; i++) {\n      data[i] = 999999;\n      for(j = 1; j <= i; j++) {\n\tif(simen[j] > i) break;\n\tnewValue = data[i-simen[j]]+1;\n\tif(newValue < data[i]) data[i] = newValue;\n      }\n    }\n    printf(\"%d \", data[N]);\n    for(i = 1; i <= N; i++) {\n      data[i] = 999999;\n      for(j = 1; j <= i; j++) {\n\tif(simen[j] > i) break;\n\tif(simen[j] % 2 == 0) continue;\n\tnewValue = data[i-simen[j]]+1;\n\tif(newValue < data[i]) data[i] = newValue;\n      }\n    }\n    printf(\"%d\\n\", data[N]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(a,b)a<b?a:b\nint o[200],s[200],dp[1000000],n,i,j,k,x;;\n\nint f(int t[200])\n{\n\tint i,j;\n\tmemset(dp,0x77,sizeof(dp));\n\tdp[0]=0;\n\tfor(i=0;t[i];i++)\n\t\tfor(j=0;j<=n;j++)\n\t\t\tif(j>=t[i])\n\t\t\t\tdp[j]=min(dp[j],dp[j-t[i]]+1);\n\treturn dp[n];\n}\n\nint main()\n{\n\tfor(i=1,j=k=0;i*(i+1)*(i+2)/6<=1000000;i++)\n\t{\n\t\tx=i*(i+1)*(i+2)/6;\n\t\tif(x%2)\n\t\t\to[j++]=x;\n\t\ts[k++]=x;\n\t}\n\tfor(;scanf(\"%d\",&n),n;)\n\t\tprintf(\"%d %d\\n\",f(s),f(o));\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define min(a, b)   (((a) < (b))?(a):(b))\n\nint n1[1000000];\nint n2[1000000];\n\nint main(void)\n{\n    int a;\n    int i, j, k;\n    int n;\n    \n    for (i = 0; i < 1000000; i++){\n        j = 1;\n        while (1){\n            n = j * (j + 1) * (j + 2) / 6;\n            if ((i + n) >= 1000000){\n                break;\n            }\n            if (n1[i + n] == 0){\n                n1[i + n] =  n1[i] + 1;\n            }\n            else {\n                n1[i + n] = min(n1[i + n], n1[i] + 1);\n            }\n            if (n % 2 == 1){\n                if (n2[i + n] == 0){\n                    n2[i + n] =  n2[i] + 1;\n                }\n                else {\n                    n2[i + n] = min(n2[i + n], n2[i] + 1);\n                }\n            }\n            j++;\n        }\n    }\n\n    \n    while (1){\n        scanf(\"%d\", &a);\n        if (a == 0){\n            break;\n        }\n        printf(\"%d %d\\n\", n1[a], n2[a]);\n    }\n    \n    return (0);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint N(int n){\n  return n*(n+1)*(n+2)/6;\n}\n\nmain(){\n  int i,j,n,fx[1000000],d=1,min,fy[1000000];\n\n  fx[0] = 0;\n  fy[0] = 0;\n  for(i=1;i<1000000;i++){\n    if(i == N(d+1)) d++;\n\n    min = -1;\n    for(j=1;j<=d;j++){\n      if(min == -1 || fx[i-N(j)]+1 < min) min = fx[i-N(j)]+1;\n    }\n    fx[i] = min;\n\n    min = -1;\n    for(j=1;j<=d;j++){\n      if(N(j)%2 == 0) continue;\n      else if(min == -1 || fy[i-N(j)]+1 < min) min = fy[i-N(j)]+1;\n    }\n    fy[i] = min;\n  }\n\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    printf(\"%d %d\\n\",fx[n],fy[n]);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nconst int PMAX = 180;\nconst int OMAX = 45;\n\n#define MAX 1000000\nint tp[MAX];\nint to[MAX];\n\nint main(void)\n{\n    int i, j, n;\n    int p[PMAX], o[OMAX];\n\n    for (i = j = 1; (n = i * (i + 1) * (i + 2) / 6) < MAX; ++i) {\n        p[i] = n;\n        if (n % 2 == 1)\n            o[j++] = n;\n    }\n\n    memset(tp, MAX, sizeof(tp));\n    memset(to, MAX, sizeof(to));\n    tp[0] = to[0] = 0;\n    for (i = 0; i < MAX; ++i)\n        for (j = 1; j < PMAX; ++j)\n            if (i + p[j] < MAX && tp[i + p[j]] > tp[i] + 1)\n                tp[i + p[j]] = tp[i] + 1;\n    for (i = 0; i < MAX; ++i)\n        for (j = 1; j < OMAX; ++j)\n            if (i + o[j] < MAX && to[i + o[j]] > to[i] + 1)\n                to[i + o[j]] = to[i] + 1;\n\n    for (;;) {\n        int n;\n\n        scanf(\"%d\", &n);\n        if (n == 0)\n            break;\n\n        printf(\"%d %d\\n\", tp[n], to[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define num 100000\n#define true 1\n#define false 0\n\nvoid pollock();\nint min(int f1,int f2);\nint *dp_ki;\nint *dp;\nint N;\n\nint main(){\n  dp_ki = (int *)malloc(num * sizeof(int));\n  dp = (int *)malloc(num * sizeof(int));\n  for(int i=0;i<num;i++){\n    dp[i]=i;\n    dp_ki[i]=i;\n  }\n  pollock();\n\n  while(scanf(\"%d\",&N),N){\n    printf(\"%d %d\\n\",dp[N],dp_ki[N] );\n  }\n\n  free(dp_ki);\n  free(dp);\n  exit(0);\n}\n\nint min(int f1,int f2){\n  if(f1>f2){\n    return f2;\n  }else{\n    return f1;\n  }\n}\n\nvoid pollock(){\n  for(int n=3,p=4;p<num;n++){\n    for(int i=0;i+p<num;i++){\n      dp[i+p] = min(dp[i+p],dp[i]+1);\n      // dp[i+p] = dp[i] + 1;\n    }\n    if(p%2){\n      for(int i=0;i+p<num;i++){\n        dp_ki[i+p] = min(dp_ki[i+p],dp_ki[i]+1);\n        // dp_ki[i+p] = dp_ki[i] + 1;\n      }\n    }\n    p= n*(n+1)*(n+2)/6;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n  //while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",n,n);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a,b) a<b?a:b\n\nint main(){\n\tint n;\n\tint i,j;\n\tint c;\n\tint a[1000001];\n\tint b[1000001];\n \n\tfor(i = 0;i < 1000001;i++){\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\n\tfor(i = 3,c = 4;i < 1000001;i++){\n\t\tfor(j = c;j < 1000001;j++){\n\t\t\ta[i] = min(a[i],a[i-c]+1);\n\t\t}\n\t\tif(c % 2){\n\t\t\tfor(j = a;j < 1000001;j++){\n\t\t\t\tb[i] = min(b[i],b[i-c]+1);\n\t\t\t}\n\t\t}\n\t\tc = i * (i+1) * (i+2) / 6;\n\t}\n\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",a[n],b[n]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nmain(){\n  int data[1000], i, min2, j, k, n, min, ans[1000000], ans2[1000000];\n\n  for(i=0;i<1000;i++){\n    data[i]=(i+1)*(i+2)*(i+3)/6;\n  }\n\n  ans[0]=0;\n  ans2[0]=0;\n  for(i=1;i<1000000;i++){\n    min=1000000;\n    min2=1000000;\n    for(j=0;data[j]<=i;j++){\n      if(min>ans[i-data[j]]+1) min=ans[i-data[j]]+1;\n      if(data[j]%2!=0){\n\tif(min2>ans2[i-data[j]]+1) min2=ans2[i-data[j]]+1;\n      }\n    }\n    ans[i]=min;\n    ans2[i]=min2;\n  }\n  while(1){\n    scanf(\"%d\", &n);\n    if(n==0) break;\n    printf(\"%d %d\\n\", ans[n], ans2[n]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint bs (int [], int, int);\n\nint min(int b,int c)\n{\n\tif(b>=c) return c;\n\treturn b;\n}\n\nint main(void)\n{\n\tint i,j,n,a,dp[1000001],dp2[1000001];\n\t\n\tfor(i=0;i<=1000000;i++)\n\t{\n\t\tdp[i]=i;\n\t\tdp2[i]=i;\n\t}\n\tfor(i=3,a=4;a<=1000000;i++)\n\t{\n\t\tfor(j=a;j<=1000000;j++)\n\t\t{\n\t\t\tdp[j]=min(dp[j],dp[j-a]+1);\n\t\t}\n\t\t\n\t\tif(a%2==1)\n\t\t{\n\t\t\tfor(j=a;j<=1000000;j++)\n\t\t    {\n\t\t\t    dp2[j]=min(dp2[j],dp2[j-a]+1);\n\t    \t}\n\t\t}\n\t\ta=i*(i+1)*(i+2)/6;\n\t}\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tprintf(\"%d %d\\n\",dp[n],dp2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a,b) a<b?a:b\n\nint main(){\n\tint n;\n\tint i,j;\n\tint c;\n\tint a[1000001];\n\tint b[1000001];\n \n\tfor(i = 0;i < 1000001;i++){\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\n\tfor(i = 3,c = 4;c < 1000001;i++){\n\t\tfor(j = c;j < 1000001;j++){\n\t\t\ta[j] = min(a[j],a[j-c]+1);\n\t\t}\n\t\tif(c % 2){\n\t\t\tfor(j = a;j < 1000001;j++){\n\t\t\t\tb[j] = min(b[j],b[j-c]+1);\n\t\t\t}\n\t\t}\n\t\tc = i * (i+1) * (i+2) / 6;\n\t}\n\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",a[n],b[n]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint d[1000010],c[1000010],M=1000005,a,i,j;\nint main(){\n  for(i=0;i<M;i++)d[i]=c[i]=1e7;\n  d[0]=c[0]=0;\n  for(i=1;i<210;i++){\n    a=(i*(i+1)*(i+2))/6;\n    for(j=0;j+a<M;j++)d[j+a]=MIN(d[j+a],d[j]+1);\n    if(a%2){\n      for(j=0;j+a<M;j++)c[j+a]=MIN(c[j+a],c[j]+1);\n    }\n  }\n  while(scanf(\"%d\",&a),a)printf(\"%d %d\\n\",d[a],c[a]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint bs (int [], int, int);\n\nint min(int b,int c)\n{\n\tint M;\n\tif(b!=0 && c!=0)\n\t{\n\t   M=b;\n\t   if(M>c) M=c;\n\t}\n\telse\n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn M;\n}\n\nint main(void)\n{\n\tint i,j,k,l,n,a[500],e[500],dp[1000][1000001],dp2[1000][1000001];\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\ta[0]=0;\n\t\te[0]=0;\n\t\tj=1;\n\t\tfor(i=1;i<=500;i++)\n\t\t{\n\t\t\ta[i]=(i*(i+1)*(i+2))/6;\n\t\t\tif(a[i]%2==1)\n\t\t\t{\n\t\t\t\te[j]=a[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tk=bs(a,501,n);\n\t\tl=bs(e,j,n);\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-a[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp2[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(e[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=min(dp2[i][j-e[i]]+1,dp2[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=dp2[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp[k][n],dp2[l][n]);\n\t}\n\treturn 0;\n}\n\nint bs (int D[], int n, int c) \n {\n    int j,k,l;\n    j=0;\n    k=n-1;\n    while(1)\n    {\n        if(j<=k)\n        {\n            l=(j+k)/2;\n            if(D[l] > c)\n            {\n                k=l-1;\n            }\n            else if(D[l+1] < c)\n            {\n                j=l+1;\n            }\n            else\n            {\n                return l;\n            }\n        }\n        else\n        {\n            return k;\n        }\n    }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define BUF_SIZE 10\n\nint get_int(void) {\n  int num;\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return 0;\n  sscanf(line, \"%d\", &num);\n#else\n#error\n#endif\n  return num;\n}\n\n#define SET_MAX 1000000\n#define INPUT_MAX 999999 // less than or equal\n// 6000000**(1/3) = 181.7\n// 180*181*182/6 < 181**3/6 < INPUT_MAX < 181*182*183/6\n#define NUM_MAX 180\nstruct pair {\n    int min;\n    int odd_min;\n};\n\n#include <limits.h>\n#define min(a,b) ((a) > (b) ? (b) : (a))\n\nint main(void) {\n    struct pair ans[SET_MAX] = {0};\n    int idx = 0;\n    int i;\n    int tetra_area[NUM_MAX+1];\n    // calc idx:1 ~ 99\n    for(i = 1; i <= NUM_MAX; i++) {\n        tetra_area[i] = i*(i+1)*(i+2)/6;\n    }\n    // answer to 1st question\n    static int dp[INPUT_MAX+1];\n    // answer to 2nd question\n    static int odd_dp[INPUT_MAX+1];\n\n    // In case of len = 1\n    for(i = 0; i < INPUT_MAX+1; i++) {\n        dp[i] = odd_dp[i] = i;\n    }\n    // calc len limit\n    int len;\n    for(len = 2; len <= NUM_MAX; len++) {\n        int target = tetra_area[len];\n        // update dp\n        for(i = target; i <= INPUT_MAX; i++) {\n            dp[i] = min(dp[i], dp[i-target]+1);\n        }\n    }\n    for(len = 2; len <= NUM_MAX; len++) {\n        int target = tetra_area[len];\n        if(!(target%2)) continue; //require odd number\n        for(i = target; i <= INPUT_MAX; i++) {\n            odd_dp[i] = min(odd_dp[i], odd_dp[i-target]+1);\n        }\n    }\n    // query\n    while(1) {\n        int sum = get_int();\n        if(!sum) break;\n        ans[idx].min = dp[sum]; ans[idx].odd_min = odd_dp[sum];\n        idx++;\n    }\n\n    for(i = 0; i < idx; i++) {\n        printf(\"%d %d\\n\", ans[i].min, ans[i].odd_min);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "a[181],m1[1000000],m2[1000000],T;\nint s(p,n,f){\n\tint *m=p,d=180;\n\tif(!n)return 0;\n\tif(m[n]<1000000)return m[n];\n\tfor(;d;d--){\n\t\tif(a[d]>n||(f&&!(a[d]&1)))continue;\n\t\tT=s(p,n-a[d],f)+1;\n\t\tif(m[n]>T)m[n]=T;\n\t}\n\treturn m[n];\n}\n\nmain(n){\n\tfor(n=1;n<181;n++)a[n]=n*(n+1)*(n+2)/6;\n\tmemset(m1,99,sizeof(m1));\n\tmemset(m2,99,sizeof(m2));\n\tfor(;scanf(\"%d\",&n),n;)printf(\"%d %d\\n\",s(m1,n,0),s(m2,n,1));\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 1000000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a,b) a<b?a:b\n\nint main(){\n\tint n;\n\tint i,j;\n\tint c;\n\tint a[1000001];\n\tint b[1000001];\n \n\tfor(i = 0;i < 1000001;i++){\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\n\tfor(i = 3,c = 4;i < 1000001;i++){\n\t\tfor(j = c;j < 1000001;j++){\n\t\t\ta[j] = min(a[j],a[j-c]+1);\n\t\t}\n\t\tif(c % 2){\n\t\t\tfor(j = a;j < 1000001;j++){\n\t\t\t\tb[j] = min(b[j],b[j-c]+1);\n\t\t\t}\n\t\t}\n\t\tc = i * (i+1) * (i+2) / 6;\n\t}\n\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",a[n],b[n]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define tetra(N) N*(N+1)*(N+2)/6\n#define isEven(N) N%2==0\n#define N_MAX 1000000\n\nint main(int argc, char* argv[]){\n\tint *min=malloc((N_MAX+1)*sizeof(int)), *minOdd=malloc((N_MAX+1)*sizeof(int)), i, n;\n\t\n\t/* initialize */\n\tfor(i=1; i<=N_MAX; i++) min[i]=-1, minOdd[i]=-1;\n\t\n\t/* problem 1 */\n\tfor(i=1; tetra(i)<=N_MAX; i++) min[tetra(i)]=1;\n\tfor(i=1; i<=N_MAX; i++){\n\t\tint j, minLocal=N_MAX;\n\t\tif(min[i]!=-1) continue;\n\t\tfor(j=1; i-tetra(j)>0; j++)\n\t\t\tif(min[i-tetra(j)]!=-1 && min[i-tetra(j)]+1<minLocal) minLocal=min[i-tetra(j)]+1;\n\t\tif(minLocal!=N_MAX) min[i]=minLocal;\n\t}\n\t\n\t/* problem 2 */\n\tfor(i=1; tetra(i)<=N_MAX; i++){\n\t\tif(isEven(tetra(i))) continue;\n\t\tminOdd[tetra(i)]=1;\n\t}\n\tfor(i=1; i<=N_MAX; i++){\n\t\tint j, minLocal=N_MAX;\n\t\tif(minOdd[i]!=-1) continue;\n\t\tfor(j=1; i-tetra(j)>0; j++){\n\t\t\tif(isEven(tetra(j))) continue;\n\t\t\tif(minOdd[i-tetra(j)]!=-1 && minOdd[i-tetra(j)]+1<minLocal) minLocal=minOdd[i-tetra(j)]+1;\n\t\t}\n\t\tif(minLocal!=N_MAX) minOdd[i]=minLocal;\n\t}\n\t\n\twhile(scanf(\"%d\",&n), n!=0) printf(\"%d %d\\n\",min[n],minOdd[n]);\n\t\n\tfree(min), free(minOdd);\n}\n\t\n\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint min(int x,int y)\n{\n\tif(x>=y) return y;\n\treturn x;\n}\n\nint main(void)\n{\n\tint i,j,k,l,n,a[1000],b[1000],dp[1000][1000001];\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\ta[0]=0;\n\t\ti=1;\n\t\twhile(1)\n\t\t{\n\t\t\ta[i]=(i*(i+1)*(i+2))/6;\n\t\t\tif(a[i]>n) break;\n\t\t\ti++;\n\t\t}\n\t\tk=i;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t\tdp[1][i]=i;\n\t\t}\n\t\tfor(i=2;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-a[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \",dp[k][n]);\n\t\tb[0]=0;\n\t\ti=0;\n\t\tj=1;\n\t\twhile(1)\n\t\t{\n\t\t\tif(a[j]%2==1)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\tb[i]=a[j];\n\t\t\t\t\n\t\t\t}\n\t\t\tif(b[i]>n) break;\n\t\t\tj++;\n\t\t}\n\t\tl=i-1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t\tdp[1][i]=i;\n\t\t}\n\t\tfor(i=2;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(b[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-b[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[l][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#define num 100000\n#define true 1\n#define false 0\n\nvoid pollock();\nint min(int f1,int f2);\nint *dp_ki;\nint *dp;\nint N;\n\nint main(){\n  dp_ki = (int *)malloc(num * sizeof(int));\n  dp = (int *)malloc(num * sizeof(int));\n  for(int i=0;i<num;i++){\n    dp[i]=i;\n    dp_ki[i]=i;\n  }\n  pollock();\n\n  while(scanf(\"%d\",&N),N){\n    printf(\"%d %d\\n\",dp[N],dp_ki[N] );\n    // printf(\"%d\\n\",dp[N] );\n  }\n\n  free(dp_ki);\n  free(dp);\n  exit(0);\n}\n\nint min(int f1,int f2){\n  if(f1>f2){\n    return f2;\n  }else{\n    return f1;\n  }\n}\n\nvoid pollock(){\n  for(int n=3,p=4;p<num;n++){\n    for(int i=0;i+p<num;i++){\n      dp[i+p] = min(dp[i+p],dp[i]+1);\n    }\n    if(p%2){\n      for(int i=0;i+p<num;i++){\n        dp_ki[i+p] = min(dp_ki[i+p],dp_ki[i]+1);\n      }\n    }\n    p= n*(n+1)*(n+2)/6;\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "a[181],m1[1000000],m2[1000000],T;\nint s(p,n,c,f){\n\tint *m=p,d=180;\n\tif(!n)return 0;\n\tif(m[n]<1000000)return m[n];\n\tfor(;d;d--){\n\t\tif(a[d]>n||(f&&!(a[d]&1)))continue;\n\t\tT=s(p,n-a[d],c+1,f)+1;\n\t\tif(m[n]>T)m[n]=T;\n\t}\n\treturn m[n];\n}\n\nmain(n){\n\tfor(n=1;n<181;n++)a[n]=n*(n+1)*(n+2)/6;\n\tmemset(m1,99,sizeof(m1));\n\tmemset(m2,99,sizeof(m2));\n\tfor(;scanf(\"%d\",&n),n;)printf(\"%d %d\\n\",s(m1,n,0,0),s(m2,n,0,1));\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1167: Pollock's conjecture\n// 2017.9.14 bal4u@uu\n// 2017.11.23\n\n#include <stdio.h>\n#include <string.h>\n\n#define min(a,b) ((a)<=(b)?(a):(b))\n#define MAX 1000000\n#define N 181\nint tbl[N+3], a[MAX+3], b[MAX+3];\n\nint main()\n{\n\tint n, i, j, k;\n\n\tfor (n = 1; n <= N; n++) tbl[n] = tbl[n-1] + (n*(n+1) >> 1);\n\tfor (i = 1; i <= MAX; i++) {\n\t\ta[i] = b[i] = i;\n\t\tfor (j = 0; tbl[j] <= i; j++) {\n\t\t\tk = i-tbl[j];\n\t\t\tif (a[k]+1 < a[i]) a[i] = a[k]+1;\n\t\t\tif (tbl[j] & 1 && b[k]+1 < b[i]) b[i] = b[k]+1;\n\t\t}\n\t}\n\twhile(scanf(\"%d\", &n) && n)\tprintf(\"%d %d\\n\", a[n], b[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint tetrahedral[200];\nint tetrahedralOdd[200];\nint map[1000000], oddmap[1000000];\n\nvoid init()\n{\n\tint i;\n\tfor (i = 0; i < 200; i++)\n\t{\n\t\ttetrahedral[i] = ((i + 1) * (i + 2) * (i)) / 6;\n\t}\n\tfor (i = 0; i < 1000000; i++)\n\t{\n\t\tmap[i] = oddmap[i] = 1000000;\n\t}\n\tmap[0] = oddmap[0] = 0;\n\tmap[1] = oddmap[1] = 1;\n\tfor (i = 2; i < 1000000; i++)\n\t{\n\t\tfor (int j = 1; tetrahedral[j] <= i; j++)\n\t\t{\n\t\t\tif (map[i] > map[i - tetrahedral[j]] + 1)\n\t\t\t\tmap[i] = map[i - tetrahedral[j]] + 1;\n\t\t\tif (tetrahedral[j] % 2 && oddmap[i] > oddmap[i - tetrahedral[j]] + 1)\n\t\t\t\toddmap[i] = oddmap[i - tetrahedral[j]] + 1;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinit();\n\tfor (int input, out1, out2; (scanf(\"%d\", &input)) && input != 0; printf(\"%d %d\\n\", out1, out2))\n\t{\n\t\tout1 = map[input];\n\t\tout2 = oddmap[input];\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint d[1000010],c[1000010],M=1e6+5,a,i,j;\nint main(){\n  for(i=0;i<M;i++)d[i]=c[i]=1e9;\n  d[0]=c[0]=0;\n  for(i=1;i<110;i++){\n    a=(i*(i+1)*(i+2))/6;\n    for(j=0;j+a<M;j++)d[j+a]=MIN(d[j+a],d[j]+1);\n    if(a%2){\n      for(j=0;j+a<M;j++)c[j+a]=MIN(c[j+a],c[j]+1);\n    }\n  }\n  while(scanf(\"%d\",&a),a)printf(\"%d %d\\n\",d[a],c[a]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid min(int);\nvoid minsosu(int);\n\nint main(){\n\t\n\tint n;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmin(n);\n\t\tminsosu(n);\n\t}\n\treturn 0;\n}\n\nvoid min(int n){\n\tint cnt=0,i;\n\tint reTet[5]={35,20,10,4,1};\n\twhile(n!=0){\n\t\tfor(i=0;i<5;i++){\n\t\t\tprintf(\"n=%d\\n\",n);\n\t\t\tif(n-reTet[i]>=0){\n\t\t\t\tprintf(\"reTet[i]=%d\\n\",reTet[i]);\n\t\t\t\tn-=reTet[i];\n\t\t\t\tcnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\",cnt);\n\treturn 0;\n}\n\nvoid minsosu(int n){\n\tint cnt=0,i;\n\tint reTet[2]={35,1};\n\twhile(n!=0){\n\t\tfor(i=0;i<2;i++){\n\t\t\tif(n-reTet[i]>=0){\n\t\t\t\tn-=reTet[i];\n\t\t\t\tcnt++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\" %d\\n\",cnt);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint min(int b,int c)\n{\n\tint M;\n\tif(b!=0 && c!=0)\n\t{\n\t   M=b;\n\t   if(M>c) M=c;\n\t}\n\telse\n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn M;\n}\n\nint main(void)\n{\n\t\n\twhile(1)\n\t{\n\t\tint i,j,k,l,z,n,a[1000],e[1000],dp[1000][1000001],dp2[1000][1000001];\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\ta[0]=0;\n\t\tz=0;\n\t\tfor(i=1;z==0;i++)\n\t\t{\n\t\t\ta[i]=(i*(i+1)*(i+2))/6;\n\t\t\tif(a[i]>n) z=-1;\n\t\t}\n\t\tk=i;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-a[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\te[0]=0;\n\t\ti=0;\n\t\tz=0;\n\t\tfor(j=1;z==0;j++)\n\t\t{\n\t\t\tif(a[j]%2==1)\n\t\t\t{\n\t\t\t\ti++;\n\t\t\t\te[i]=a[j];\t\n\t\t\t}\n\t\t\tif(e[i]>n) z=-1;\n\t\t}\n\t\tl=i-1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp2[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(e[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=min(dp2[i][j-e[i]]+1,dp2[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=dp2[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp[k][n],dp2[l][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint numbers[180];\n\nint memo[2][180][1000000];\n\nint tansaku(int pos,int rest,int force_kisuu) {\n\tint i;\n\tint result=0x10000000;\n\tint now;\n\tif(rest==0)return 0;\n\tif(numbers[pos]>rest)return 0x10000000;\n\tif(memo[force_kisuu][pos][rest-1]>0) {\n\t\treturn memo[force_kisuu][pos][rest-1]-1;\n\t}\n\tfor(i=pos;i<180 && numbers[i]<=rest;i++) {\n\t\tif(!force_kisuu || numbers[i]%2!=0) {\n\t\t\tnow=tansaku(i,rest-numbers[i],force_kisuu)+1;\n\t\t\tif(now<result)result=now;\n\t\t}\n\t}\n\tmemo[force_kisuu][pos][rest-1]=result+1;\n\treturn result;\n}\n\nint main(void) {\n\tint i;\n\tint query;\n\tint ans,ans_kisuu;\n\n\tfor(i=0;i<180;i++)numbers[i]=i+1;\n\tfor(i=1;i<180;i++)numbers[i]+=numbers[i-1];\n\tfor(i=1;i<180;i++)numbers[i]+=numbers[i-1];\n\n\twhile(1) {\n\t\tscanf(\"%d\",&query);\n\t\tif(query==0)break;\n\t\tans=tansaku(0,query,0);\n\t\tans_kisuu=tansaku(0,query,1);\n\t\tprintf(\"%d %d\\n\",ans,ans_kisuu);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define M 1000010\nint zMIN(int a,int b){\n  if(a==0||a>b)return b;\n  return a;\n}\nint d1[M],d2[M];\nint main(){\n  int n=200,t[200],i,j;\n  for(i=1;i<200;i++)t[i]=i*(i+1)*(i+2)/6;\n  for(i=0;i<M;i++){\n    for(j=1;j<200;j++){\n      if(i+t[j]>=M)continue;\n                d1[i+t[j]]=zMIN(d1[i+t[j]],d1[i]+1);\n      if(t[j]%2)d2[i+t[j]]=zMIN(d2[i+t[j]],d2[i]+1);\n    }\n  }\n  while(scanf(\"%d\",&n),n)printf(\"%d %d\\n\",d1[n],d2[n]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint numbers[200];\n\nint memo[200][1000001];\n\nint tansaku(int pos,int rest,int force_kisuu) {\n\tint i;\n\tint result=0x10000000;\n\tint now;\n\tif(rest==0)return 0;\n\tif(numbers[pos]>rest)return 0x10000000;\n\tif(memo[pos][rest]>0)return memo[pos][rest]-1;\n\tfor(i=pos;i<200 && numbers[i]<=rest;i++) {\n\t\tif(!force_kisuu || numbers[i]%2!=0) {\n\t\t\tnow=tansaku(i,rest-numbers[i],force_kisuu)+1;\n\t\t\tif(now<result)result=now;\n\t\t}\n\t}\n\tmemo[pos][rest]=result+1;\n\treturn result;\n}\n\nint main(void) {\n\tint i;\n\tint query;\n\tint ans,ans_kisuu;\n\n\tfor(i=0;i<200;i++)numbers[i]=i+1;\n\tfor(i=1;i<200;i++)numbers[i]+=numbers[i-1];\n\tfor(i=1;i<200;i++)numbers[i]+=numbers[i-1];\n\n\twhile(1) {\n\t\tscanf(\"%d\",&query);\n\t\tif(query==0)break;\n\t\tmemset(memo,0,sizeof(memo));\n\t\tans=tansaku(0,query,0);\n\t\tmemset(memo,0,sizeof(memo));\n\t\tans_kisuu=tansaku(0,query,1);\n\t\tprintf(\"%d %d\\n\",ans,ans_kisuu);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_X     1000000\n#define INFINITY  MAX_X\n#define tetra(n)  ((n) * ((n)+1) * ((n)+2) / 6)\n\n/* compute all solutions for x = 1 to (MAX_X-1) */\nvoid polloc(int solution[], int oddOnly)\n{\n  int i, j, t;\n\n  /* initialize */\n  for (i = 1; i < MAX_X; i++) {\n    solution[i] = INFINITY;\n  }\n  for (i = 1; (t = tetra(i)) < MAX_X; i++) {\n    if (! oddOnly || t % 2 == 1) {\n      solution[t] = 1;\n    }\n  }\n\n  /* dynamic programming */\n  for (i = 1; i < MAX_X; i++) {\n    for (j = 1; (t = tetra(j)) < i; j++) {\n      if (solution[i] > solution[t] + solution[i - t]) {\n          solution[i] = solution[t] + solution[i - t];\n      }\n    }\n  }\n}\n\nint main()\n{\n  static int solution[2][MAX_X];\n  int x;\n\n  polloc(solution[0], 0);\n  polloc(solution[1], 1); /* odd only */\n\n  for (;;) {\n    scanf(\"%d\", &x);\n    if (x == 0) break;\n    printf(\"%d %d\\n\", solution[0][x], solution[1][x]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX (1000000-1)\n\nint tcomp[MAX+1];\t// 各自然数を構成するために必要な正四面体数の数\nint otcomp[MAX+1];\t// 各自然数を構成するために必要な奇数の正四面体数の数\n\nint min(int a,int b){\n\treturn a<b?a:b;\n}\nint main(){\n\tint i,n,m;\n\tint in;\n\tfor(i=0;i<=MAX;i++){\n\t\ttcomp[i]=otcomp[i]=MAX;\n\t}\n\ttcomp[0]=otcomp[0]=0;\n\tfor(i=0;i<=MAX;i++){\n\t\tfor(n=1;;n++){\n\t\t\tm = n*(n+1)*(n+2)/6;\n\t\t\tif(MAX < i+m)break;\n\t\t\ttcomp[i+m] = min(tcomp[i+m],tcomp[i]+1);\n\t\t\tif(m&1)\n\t\t\t\totcomp[i+m] = min(otcomp[i+m],otcomp[i]+1);\n\t\t}\n\t}\n\twhile(scanf(\"%d\",&in)==1&&in){\n\t\tprintf(\"%d %d\\n\",tcomp[in],otcomp[in]);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 1000000\n#define MIN(A,B) \\\n  ( (B) < (A) ? (B) : (A) )\n\nstatic int k_operafan[ 2 ][ N ];\n\nstatic int\ndpFSA (\n  int mode,\n  int n\n  )\n{\n  int i;\n\n  if ( ~k_operafan[ mode ][ n ] ) ;\n  else\n  {\n    k_operafan[ mode ][ n ] = n;\n    for ( i = 1; ; ++i )\n    {\n      const int c = i * ( i + 1 ) * ( i + 2 ) / 6;\n\n      if ( c > n )\n        break ;\n      if ( mode && ( c % 2 == 0 ) )\n        continue ;\n\n      k_operafan[ mode ][ n ] = MIN( k_operafan[ mode ][ n ]\n                                   , dpFSA ( mode, n - c ) + 1 );\n    }\n  }\n\n  return ( k_operafan[ mode ][ n ] );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  memset ( k_operafan, -1, sizeof ( k_operafan ) );\n  k_operafan[ 0 ][ 0 ] = k_operafan[ 1 ][ 0 ] = 0;\n\n  for ( ; ; )\n  {\n    int n;\n\n    scanf ( \"%d\", &n );\n    if ( n == 0 ) break ;\n\n    printf ( \"%d %d\\n\", dpFSA ( 0, n ), dpFSA ( 1, n ) );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint bs (int [], int, int);\n\nint min(int b,int c)\n{\n\tif(b>=c) return c;\n\treturn b;\n}\n\nint main(void)\n{\n\tint i,j,n,a,dp[1000001],dp2[1000001];\n\t\n\tfor(i=0;i<=1000000;i++)\n\t{\n\t\tdp[i]=i;\n\t\tdp2[i]=i;\n\t}\n\tfor(i=3,a=4;a<=1000000;i++)\n\t{\n\t\tfor(j=0;j+a<=1000000;j++)\n\t\t{\n\t\t\tdp[j+a]=min(dp[j+a],dp[j]+1);\n\t\t}\n\t\t\n\t\tif(a%2==1)\n\t\t{\n\t\t\tfor(j=0;j+a<=1000000;j++)\n\t\t    {\n\t\t\t    dp2[j+a]=min(dp2[j+a],dp2[j]+1);\n\t    \t}\n\t\t}\n\t\ta=i*(i+1)*(i+2)/6;\n\t}\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tprintf(\"%d %d\\n\",dp[n],dp2[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\n\nll dp1[1000010];\nll dp2[1000010];\nint main(){\n\trep(i,0,1000005)dp1[i]=dp2[i]=INF;\n\tdp1[0]=dp2[0]=0;\n\trep(n,1,200){\n\t\tll s=n*(n+1)*(n+2)/6;\n\t\trep(i,0,1000005-s)dp1[i+s]=min(dp1[i+s],dp1[i]+1);\n\t\tif(s%2)rep(i,0,1000005-s)dp2[i+s]=min(dp2[i+s],dp2[i]+1);\n\t}\n\tll n;\n\twhile(scanf(\"%lld\",&n),n){\n\t\tprintf(\"%lld %lld\\n\",dp1[n],dp2[n]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint d[1000010],c[1000010],M=1e6+5,a,i,j;\nint main(){\n  for(i=0;i<M;i++)d[i]=c[i]=1e9;\n  d[0]=c[0]=0;\n  for(i=1;i<100;i++){\n    a=(i*(i+1)*(i+2))/6;\n    for(j=0;j+a<M;j++)d[j+a]=MIN(d[j+a],d[j]+1);\n    if(a%2){\n      for(j=0;j+a<M;j++)c[j+a]=MIN(c[j+a],c[j]+1);\n    }\n  }\n  while(scanf(\"%d\",&a),a)printf(\"%d %d\\n\",d[a],c[a]);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "//icpc2010dC test using InformationScience2008[3] ite()\na[181],b1[1000000],b2[1000000];\nvoid ite(n){\n  int m,k,l,i;\n  b1[0] = b2[0] = 0;\n  for(m=1;m<=n;m++){\n    i = 0;\n    k = l = -1;\n    for(i=1;i<181;i++){\n      if(m >= a[i] && b1[m-a[i]] >= 0 && (k < 0 || b1[m-a[i]] + 1 < k))\n        k = b1[m-a[i]] + 1;\n      if((a[i]&1) && m >= a[i] && b2[m-a[i]] >= 0 && (l < 0 || b2[m-a[i]] + 1 < l))\n        l = b2[m-a[i]] + 1;\n    }\n    b1[m] = k;\n    b2[m] = l;\n  }\n}\n\nmain(n){\n\tfor(n=1;n<181;n++)a[n]=n*(n+1)*(n+2)/6;\n\tite(999999);\n\tfor(;scanf(\"%d\",&n),n;)printf(\"%d %d\\n\",b1[n],b2[n]);\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n * 1167.c: Pollock's conjecture\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_N\t(1000000)\n#define MAX_THN\t(200)\n\n/* global variables */\n\nstatic int sums[MAX_N + 1], osums[MAX_N + 1];\nstatic int thns[MAX_THN], othns[MAX_THN];\n\n/* subroutines */\n\nvoid min_sums(int *sums, int n_thn, int *thns) {\n  int i, j, k, s1, thn;\n\n  for (i = 0; i <= MAX_N; i++) sums[i] = i;\n\n  for (k = 0; k < n_thn; k++) {\n    thn = thns[k];\n    for (i = thn; i <= MAX_N; i++) {\n      j = i - thn;\n      s1 = sums[j] + 1;\n      if (sums[i] > s1) sums[i] = s1;\n    }\n  }\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int k, n, n_thn, n_othn, thn;\n\n  n_thn = n_othn = 0;\n  for (k = 0;; k++) {\n    thn = k * (k + 1) * (k + 2) / 6;\n    if (thn >= MAX_N) break;\n    thns[n_thn++] = thn;\n    if (thn & 1) othns[n_othn++] = thn;\n  }\n\n  min_sums(sums, n_thn, thns);\n  min_sums(osums, n_othn, othns);\n\n  for (;;) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n\n    printf(\"%d %d\\n\", sums[n], osums[n]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define min(a,b) a<b?a:b\n\nint main(){\n\tint n;\n\tint i,j;\n\tint c;\n\tint a[1000001];\n\tint b[1000001];\n \n\tfor(i = 0;i < 1000001;i++){\n\t\ta[i] = i;\n\t\tb[i] = i;\n\t}\n\n\tfor(i = 3,c = 4;i < 1000001;i++){\n\t\tfor(j = a;j < 1000001;j++){\n\t\t\ta[i] = min(a[i],a[i-c]+1);\n\t\t}\n\t\tif(c % 2){\n\t\t\tfor(j = a;j < 1000001;j++){\n\t\t\t\tb[i] = min(b[i],b[i-c]+1);\n\t\t\t}\n\t\t}\n\t\tc = i * (i+1) * (i+2) / 6;\n\t}\n\n\twhile(scanf(\"%d\",&n),n){\n\t\tprintf(\"%d %d\\n\",a[n],b[n]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint min(int b,int c)\n{\n\tint M;\n\tif(b!=0 && c!=0)\n\t{\n\t   M=b;\n\t   if(M>c) M=c;\n\t}\n\telse\n\t{\n\t\tif(b==0)\n\t\t{\n\t\t\treturn c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t}\n\treturn M;\n}\n\nint main(void)\n{\n\tint i,j,k,l,z,n,a[1000],e[1000],dp[1000][1000001],dp2[1000][1000001];\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\ta[0]=0;\n\t\te[0]=0;\n\t\tj=1;\n\t\tz=0;\n\t\tfor(i=1;z==0;i++)\n\t\t{\n\t\t\ta[i]=(i*(i+1)*(i+2))/6;\n\t\t\tif(a[i]>n) z=-1;\n\t\t\tif(a[i]%2==1)\n\t\t\t{\n\t\t\t\tb[j]=a[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tk=i;\n\t\tl=j-1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=k;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(a[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=min(dp[i][j-a[i]]+1,dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp[i][j]=dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tdp2[0][i]=0;\n\t\t}\n\t\tfor(i=1;i<=l;i++)\n\t\t{\n\t\t\tfor(j=0;j<=n;j++)\n\t\t\t{\n\t\t\t\tif(e[i]<=j)\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=min(dp2[i][j-e[i]]+1,dp2[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdp2[i][j]=dp2[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",dp[k][n],dp2[l][n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 10000\n\nint min(int a,int b){return (a>b)?b:a;}\n\nint dp[N],dp_odd[N];\n\nint main(){\n  int i,j,n,tmp;\n  int plc[1000],num;\n\n  for(i=0;i<N;i++)dp[i] = dp_odd[i] = N+1;\n  dp[0] = dp_odd[0] = 0;\n\n  tmp = 1;\n  for(num=1;;num++){\n    plc[num] = tmp;\n    tmp *= num+3; tmp /= num;\n    if(tmp>=N)break;\n  }\n  \n  for(i=0;i<N;i++){\n    for(j=1;j<num;j++){\n      if(i<plc[j])break;\n      dp[i] = min(dp[i],dp[i-plc[j]]+1);\n      if(plc[j]&1)dp_odd[i] = min(dp_odd[i],dp_odd[i-plc[j]]+1);\n    }\n  }\n\n  //while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",dp[n],dp_odd[n]);\n  while(scanf(\"%d\",&n) && n)printf(\"%d %d\\n\",n,n);\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val tetra = Array(180, { 0 })\n    var (_i, _n) = Pair(1, 1)\n    while (_n < 1000000) {\n        tetra[_i-1] = _n\n        _n = ++_i*(_i+1)*(_i+2)/6\n    }\n    val tetra_odd = Array(45, { 0 })\n    var (__i, __j, __n) = arrayOf(1, 0, 1)\n    while (__n < 1000000) {\n        if (__n.and(1) == 1) {\n            tetra_odd[__j] = __n\n            __j++\n        }\n        __n = ++__i*(__i+1)*(__i+2) / 6\n    }\n\n    while (true) {\n        val N = sc.nextInt()\n        if (N == 0) break\n        val dp = Array(N+1, { 1000000 })\n        dp[0] = 0\n        for (n in tetra) {\n            if (n > N) break\n            for (i in n..N) {\n                dp[i] = Math.min(dp[i], dp[i - n] + 1)\n            }\n        }\n        val ans = dp[N]\n        dp.fill( 1000000, 1)\n        for (n in tetra_odd) {\n            for (i in n..N) {\n                dp[i] = Math.min(dp[i], dp[i-n]+1)\n            }\n        }\n        println(\"${ans} ${dp[N]}\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val tetra = Array(180, { 0 })\n    var (_i, _n) = Pair(1, 1)\n    while (_n < 1000000) {\n        tetra[_i-1] = _n\n        _n = ++_i*(_i+1)*(_i+2)/6\n    }\n    val tetra_odd = Array(45, { 0 })\n    var (__i, __j, __n) = arrayOf(1, 0, 1)\n    while (__n < 1000000) {\n        if (__n.and(1) == 1) {\n            tetra_odd[__j] = __n\n            __j++\n        }\n        __n = ++__i*(__i+1)*(__i+2) / 6\n    }\n    val dp = Array(1000001, { 0 })\n\n    while (true) {\n        val N = sc.nextInt()\n        if (N == 0) break\n        dp.fill(1000000, 1)\n        dp[0] = 0\n        for (n in tetra) {\n            if (n > N) break\n            for (i in n..N) {\n                dp[i] = Math.min(dp[i], dp[i-n] + 1)\n            }\n        }\n        val ans = dp[N]\n        dp.fill( 1000000, 1)\n        for (n in tetra_odd) {\n            for (i in n..N) {\n                dp[i] = Math.min(dp[i], dp[i-n]+1)\n            }\n        }\n        println(\"${ans} ${dp[N]}\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val max_n = 1000000\n\n    val dp = IntArray(max_n+1)\n    dp.fill(max_n, 1)\n    var (i, n) = Pair(1, 1)\n    while (n <= max_n) {\n        for (j in n..max_n)  dp[j] = Math.min(dp[j], dp[j-n]+1)\n        n = ++i*(i+1)*(i+2)/6\n    }\n\n    val dp_odd = IntArray(max_n+1)\n    dp_odd.fill(max_n, 1)\n    i = 1; n = 1\n    while (n <= max_n) {\n        if (n.and(1) == 1)  for (j in n..max_n) dp_odd[j] = Math.min(dp_odd[j], dp_odd[j-n]+1)\n        n = ++i*(i+1)*(i+2) / 6\n    }\n\n    while (true) {\n        val N = sc.nextInt()\n        if (N == 0) break\n        println(\"${dp[N]} ${dp_odd[N]}\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val tetra = Array(180, { 0 })\n    var (_i, _n) = Pair(1, 1)\n    while (_n < 1000000) {\n        tetra[_i-1] = _n\n        _n = ++_i*(_i+1)*(_i+2)/6\n    }\n\n    while (true) {\n        val N = sc.nextInt()\n        if (N == 0) break\n        val dp = Array(N+1, { 1000000 })\n        dp[0] = 0\n        val dp_odd = dp.clone()\n        for (n in tetra) {\n            if (n > N) break\n            for (i in n..N) {\n                dp[i] = Math.min(dp[i], dp[i-n]+1)\n            }\n            if (n.and(1) == 1) {\n                for (i in n..N) {\n                    dp_odd[i] = Math.min(dp_odd[i], dp_odd[i-n]+1)\n                }\n            }\n        }\n        println(\"${dp[N]} ${dp_odd[N]}\")\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args: Array<String>) {\n    val sc = Scanner(System.`in`)\n    val tetra = Array(180, { 0 })\n    var (_i, _n) = Pair(1, 1)\n    while (_n < 1000000) {\n        tetra[_i-1] = _n\n        _n = ++_i*(_i+1)*(_i+2)/6\n    }\n    val tetra_odd = Array(45, { 0 })\n    var (__i, __j, __n) = arrayOf(1, 0, 1)\n    while (__n < 1000000) {\n        if (__n.and(1) == 1) {\n            tetra_odd[__j] = __n\n            __j++\n        }\n        __n = ++__i*(__i+1)*(__i+2) / 6\n    }\n    val dp = IntArray(1000001)\n\n    while (true) {\n        val N = sc.nextInt()\n        if (N == 0) break\n        dp.fill(1000000, 1)\n        dp[0] = 0\n        for (n in tetra) {\n            if (n > N) break\n            for (i in n..N) {\n                dp[i] = Math.min(dp[i], dp[i-n] + 1)\n            }\n        }\n        val ans = dp[N]\n        dp.fill( 1000000, 1)\n        for (n in tetra_odd) {\n            for (i in n..N) {\n                dp[i] = Math.min(dp[i], dp[i-n]+1)\n            }\n        }\n        println(\"${ans} ${dp[N]}\")\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n=Integer.parseInt(in.next());\n\t\t\tif(n==0)break;\n\n\t\t\tList<Integer> A=new ArrayList<>(), B=new ArrayList<>();\n\n\t\t\tint j=1,s=1;\n\t\t\twhile(s<=n){\n\t\t\t\tA.add(s);\n\t\t\t\tif(s%2==1)B.add(s);\n\t\t\t\tj++;\n\t\t\t\ts=j*(j+1)*(j+2)/6;\n\t\t\t}\n\n\t\t\tint DP[]=new int[n+1],INF=2000000000;\n\t\t\tfor(int i=1;i<=n;i++)DP[i]=INF;\n\n\t\t\tfor(int i=0;i<A.size();i++){\n\t\t\t\tint t=A.get(i);\n\t\t\t\tfor(int k=0;k+t<=n;k++){\n\t\t\t\t\tDP[k+t]=Math.min(DP[k]+1, DP[k+t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPrintWriter out=new PrintWriter(System.out);\n\t\t\tout.print(DP[n]+\" \");\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++)DP[i]=INF;\n\t\t\t\n\t\t\tfor(int i=0;i<B.size();i++){\n\t\t\t\tint t=B.get(i);\n\t\t\t\tfor(int k=0;k+t<=n;k++){\n\t\t\t\t\tDP[k+t]=Math.min(DP[k+t], DP[k]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(DP[n]);\n\t\t\tout.flush();\n\t\t}\n\t\t\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    ArrayList<Integer> list;\n    ArrayList<Integer> list2;\n\n    list = new ArrayList<>();\n    list2 = new ArrayList<>();\n    int pre = 1;\n    int n = 1;\n    while((pre = n*(n+1)*(n+2)/6)<1000000) {\n      n++;\n      if(pre%2==1) list.add(pre);\n      list2.add(pre);\n    }\n    int input = 0;\n\n    while((input=scan.nextInt())!=0) {\n      int[] dp = new int[input+1];\n      System.out.print(calc(input,dp,list2)+\" \");\n      dp = new int[input+1];\n      System.out.println(calc(input,dp,list));\n    }\n  }\n\n  static int calc(int sum, int[] dp, ArrayList<Integer> list) {\n    if(dp[sum]>0) return dp[sum];\n    if(sum==0) return 0;\n    int max = 0;\n    int count = 999999;\n    for(int i = list.size()-1; i >= 0; i--) {\n      max = list.get(i);\n      if(max==sum) return 1;\n      if(max<sum) {\n        int res = 1 + calc(sum-max,dp,list);\n        count = Math.min(res, count);\n        dp[sum-max] = res;\n      }\n    }\n    return count;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] list1 = new int[180];\n\t\tint[] dp1 = new int[1000000];\n\t\tint[] dp2 = new int[1000000]; \n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tlist1[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t}\n\n\t\tArrays.fill(dp1, 2 << 27);\n\t\tArrays.fill(dp2, 2 << 27);\n\n\t\tdp1[0] = dp2[0] =  0;\n\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tint tmp = list1[i];\n\t\t\tif(list1[i] % 2 == 0)\n\t\t\tfor(int j = tmp; j < 1000000; j++) {\n\t\t\t\tdp1[j] = Math.min(dp1[j-tmp]+1, dp1[j]);\n\t\t\t}\n\t\t\telse\n\t\t\tfor(int j = tmp; j < 1000000; j++) {\n\t\t\t\tdp1[j] = Math.min(dp1[j-tmp]+1, dp1[j]);\n\t\t\t\tdp2[j] = Math.min(dp2[j-tmp]+1, dp2[j]);\n\t\t\t}\n\t\t}\n\t\twhile(true) {\n\t\t\tint a = sc.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tSystem.out.println(dp1[a] + \" \" + dp2[a]);\n\t\t}\n\t}\n\t\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int N,min,cnt;\n\tstatic int[] a =new int[180];\n\tstatic int[] b =new int[45];\n\tstatic int[] alreadyA;\n\tstatic int[] alreadyB;\n\tstatic{\n\t\tint cnt=0;\n\t\tfor(int i = 1;tetrahedral(i)<=1000000;i++){\n\t\t\tint t = tetrahedral(i);\n\t\t\ta[cnt++]=t;\n\t\t}\n\t\tfor(int i = 0;i<a.length;i++){\n\t\t\t//System.out.println(a[i]);\n\t\t}\t\t\n\t\talreadyA=new int[1000000];\n\t\talreadyB=new int[1000000];\n\t\tcnt=0;\n\t\tfor(int i = 1;tetrahedral(i)<=1000000;i++){\n\t\t\tint t = tetrahedral(i);\n\t\t\tif(t%2==1){\n\t\t\t\tb[cnt++]=t;\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tArrays.fill(alreadyA, 0);\n\t\tArrays.fill(alreadyB, 0);\n\t\ta();\n\t\twhile(true){\n\t\t\tN =cin.nextInt();\n\t\t\tif(N==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt=0;min=Integer.MAX_VALUE;\n\t\t\t\n\t\t\tSystem.out.print(alreadyA[N]);\n\t\t\tSystem.out.println(\" \"+alreadyB[N]);\n\t\t}\n\n\t}\n\tstatic void a(){\n\t\tfor(int i= 1;i<1000000;i++){\n\t\t\tint mina=Integer.MAX_VALUE;\n\t\t\tint minb=Integer.MAX_VALUE;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int j=0;j<180&&a[j]<=i;j++){\n\t\t\t\tmina=Math.min(1+alreadyA[i-a[j]],mina);\n\t\t\t\tif(a[j]%2==1){\n\t\t\t\t\tminb=Math.min(1+alreadyB[i-a[j]],minb);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(i+\" \" +x+\" \" +y + \" \" +min);\n\t\t\talreadyA[i]=mina;\n\t\t\talreadyB[i]=minb;\n\t\t}\n\t}\n\tstatic int tetrahedral(int a){\n\t\treturn (a*(a+1)*(a+2))/6;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static final int MAXNUM = 1000000;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] tetra = new int[200];\n\t\tint m = 0;\n\t\tfor(int i=1;i<200;i++) {\n\t\t\ttetra[i] = i * (i+1) * (i+2) / 6;\n\t\t\tif (tetra[i] > MAXNUM) {\n\t\t\t\tm = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint[] dp1 = new int[MAXNUM+1];\n\t\tint[] dp2 = new int[MAXNUM+1];\n\t\tArrays.fill(dp1, Integer.MAX_VALUE);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\tdp1[0] = dp2[0] = 0;\n\t\tfor(int i=1;i<=MAXNUM;i++) {\n\t\t\tfor(int j=1;j<m;j++) {\n\t\t\t\tif (i - tetra[j] < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdp1[i] = Math.min(dp1[i],dp1[i-tetra[j]]+1);\n\t\t\t\tif ((tetra[j]&1)==1) {\n\t\t\t\t\tdp2[i] = Math.min(dp2[i],dp2[i-tetra[j]]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(dp1[n] + \" \" + dp2[n]);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tvoid run() {\n\n\t\tint[] fd = new int[180];\n\n\t\tint[] fd2 = new int[180];\n\n\t\tint k=0;\n\n\t\tfor (int i = 1, j = 0; i * (i + 1) * (i + 2) / 6 < 1000000; i++, j++) {\n\n\t\t\tfd[j] = i * (i + 1) * (i + 2) / 6;\n\n\t\t\tif ((fd[j] & 1) == 1) {\n\n\t\t\t\tfd2[k] = fd[j];\n\n\t\t\t\tk++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfd2 = Arrays.copyOfRange(fd2,0 , k);\n\n\t\t\n\n\t\tint dp[] = new int[1000000];\n\n\t\tint dp2[] = new int[1000000];\n\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\n\t\tdp[0] = dp2[0] = 0;\n\n//\t\tSystem.out.println(Arrays.toString(fd));\n\n//\t\tSystem.out.println(Arrays.toString(fd2));\n\n\t\tfor (int i = 0; i < 1000000; i++) {\n\n\t\t\tif (dp[i] == Integer.MAX_VALUE)\n\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = 0; j < fd.length; j++) {\n\n\t\t\t\tif (i + fd[j] >= 1000000)\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdp[i + fd[j]] = Math.min(dp[i] + 1, dp[i + fd[j]]);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < 1000000; i++) {\n\n\t\t\tif (dp2[i] == Integer.MAX_VALUE)\n\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = 0; j < fd2.length; j++) {\n\n\t\t\t\tif (i + fd2[j] >= 1000000)\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdp2[i + fd2[j]] = Math.min(dp2[i] + 1, dp2[i + fd2[j]]);\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tfor (;;) {\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif (n == 0)\n\n\t\t\t\tbreak;\n\n\t\t\tSystem.out.println(dp[n] + \" \" + dp2[n]);\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n   //     Scanner sc = new Scanner(System.in);\n        int[] list1 = new int[180];\n        int[] cnt1 = new int[1000001];\n        int[] cnt2 = new int[1000001]; \n        for(int i = 0; i < 180; i++) {\n            list1[i] = (i+1)*(i+2)*(i+3)/6;\n        }\n        // Here your code !\n        for(int i = 0; i <= 1000000; i++){\n            cnt1[i] = i;\n            cnt2[i] = i;\n        }\n        \n        for(int n = 3, p = 4; p <= 1000000; n++){\n            for(int i = 0; i+p <= 1000000; i++){\n                cnt1[i+p] = Math.min(cnt1[i+p], cnt1[i] + 1);\n            }\n            if(p % 2 == 1){\n                for(int i = 0; i+p <= 1000000; i++){\n                    cnt2[i+p] = Math.min(cnt2[i+p], cnt2[i] + 1);\n                }\n            }\n            // p?????????????????§??´??°\n            p = n * (n+1) * (n+2) / 6;\n        }\n        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            int num = Integer.parseInt(br.readLine());\n            if(num == 0) break;\n            System.out.println(cnt1[num] + \" \" + cnt2[num]);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] simen=new int[1000];\n\tstatic int[] kisu_simen=new int[48];\n\tstatic int INF=1000000007;\n\tpublic static void main(String[] args) {\n\t\tfor(int i=0; i<200; i++) {\n\t\t\tint tmp=(i+1)*(i+2)*(i+3)/6;\n\t\t\tfor(int j=0; j<5; j++) {\n\t\t\t\tsimen[i*5+j]=tmp;\n\t\t\t}\n\t\t}\n\t\tint num=0;\n\t\tint counter=0;\n\t\twhile(true) {\n\t\t\tif(counter>=47) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(num*(num+1)*(num+2)/6%2==1) {\n\t\t\t\t\tkisu_simen[counter]=num*(num+1)*(num+2)/6;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum++;\n\t\t}\n\t\tint[] pollock=new int[1000002];\n\t\tint[] pollock_k=new int[1000002];\n\t\tArrays.fill(pollock,INF);\n\t\tArrays.fill(pollock_k,INF);\n\t\tpollock[0]=0;\n\t\tpollock_k[0]=0;\n\t\tint sum=0;\n\t\tfor(int i=0; i<1000; i++) {\n\t\t\tfor(int j=0; j<=Math.min(sum,1000001); j++) {\n\t\t\t\tif(pollock[j]<INF) {\n\t\t\t\t\tif(j+simen[i]<=1000000) {\n\t\t\t\t\t\tpollock[j+simen[i]]=Math.min(pollock[j+simen[i]], pollock[j]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum+=simen[i];\n\t\t}\n\t\tfor(int i=0; i<48; i++) {\n\t\t\tfor(int j=0; j<=1000000; j++) {\n\t\t\t\tif(j-kisu_simen[i]>=0) {\n\t\t\t\t\tpollock_k[j]=Math.min(pollock_k[j], pollock_k[j-kisu_simen[i]]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint input=sc.nextInt();\n\t\t\tif(input==0) {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(pollock[input]+\" \"+pollock_k[input]);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static int sub(List<Integer> list, int n){\n\t\t\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> count = new LinkedList<Integer>();\n\t\t\n\t\tqueue.add(n);\n\t\tcount.add(0);\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tint co = count.poll();\n\t\t\t\n\t\t\tif(cur == 0){\n\t\t\t\treturn co;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i : list){\n\t\t\t\tif(i > cur){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tqueue.add(cur - i);\n\t\t\t\tcount.add(co + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tArrayList<Integer> odd_list = new ArrayList<Integer>();\n\t\t\n\t\tfor(int i = 1; (i * (i + 1) * (i + 2))/6 < 1000000; i++){\n\t\t\tlist.add((i * (i + 1) * (i + 2))/6);\n\t\t\tif(((i * (i + 1) * (i + 2))/6) % 2 == 1){\n\t\t\t\todd_list.add((i * (i + 1) * (i + 2))/6);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sub(list,n) + \" \" + sub(odd_list,n));\n\t\t}\n\t\t\n\t\t\n\t}\n}\t"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\n\t\tHashMap<Integer, Integer> vals = new HashMap<>();\n\t\tint maxN = 1;\n\t\tint val = 1;\n\t\tint maxValN = 0;\n\t\twhile (val < 1000000) {\n\t\t\tvals.put(maxN, val);\n\t\t\tif (val % 2 == 1) {\n\t\t\t\tmaxValN = maxN;\n\t\t\t}\n\t\t\tmaxN++;\n\n\t\t\tval = maxN * (maxN + 1) * (maxN + 2) / 6;\n\n\t\t}\n\t\tmaxN--;\n\n\t\tint[][] dp = new int[maxN + 1][1000000];\n\t\tint[][] dp1 = new int[maxN + 1][1000000];\n\n\t\tfor (int[] is : dp) {\n\t\t\tArrays.fill(is, 100);\n\t\t}\n\n\t\tfor (int[] is : dp1) {\n\t\t\tArrays.fill(is, 100);\n\t\t}\n\t\tint temp = 1;\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tint minVal = vals.get(i);\n\t\t\tfor (int j = 0; j < 1000000; j++) {\n\t\t\t\tif (i == 1) {\n\t\t\t\t\tdp[i][j] = j;\n\t\t\t\t\tdp1[i][j] = j;\n\n\t\t\t\t} else if (i > 1 && j - minVal >= 0) {\n\t\t\t\t\tif (minVal % 2 == 1) {\n\t\t\t\t\t\tdp1[i][j] = Math.min(dp1[temp][j], dp1[i][j - minVal] + 1);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j], dp[i][j - minVal] + 1);\n\t\t\t\t} else {\n\t\t\t\t\tif (minVal % 2 == 1) {\n\t\t\t\t\t\tdp1[i][j] = dp1[temp][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (minVal % 2 == 1) {\n\t\t\t\ttemp = i;\n\t\t\t}\n\n\t\t}\n\n\t\tint n;\n\t\twhile ((n = s.nextInt()) != 0) {\n\t\t\tSystem.out.print(dp[maxN][n] + \" \");\n\t\t\tSystem.out.println(dp1[maxValN][n]);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic void run() {\n\t\tdp[1] = 1;\n\t\tdpK[1] = 1;\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int n){\n\t\tint m = calcDP(n);\n\t\tint mK = calcDPK(n);\n\t\tSystem.out.println(m + \" \" + mK);\n\t}\n\tint[] dp = new int[1000001];\n\tpublic int calcDP(int n){\n\t\tif(n == 0) return 0;\n\t\telse if(dp[n] != 0) return dp[n];\n\t\telse{\n\t\t\tint min = 10;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\t\tif(n - t < 0) break;\n\t\t\t\tint m = calcDP(n - t) + 1;\n\t\t\t\tif(m < min) \n\t\t\t\t\tmin = m;\n\t\t\t}\n\t\t\tdp[n] = min;\n\t\t\treturn dp[n];\n\t\t}\n\t}\n\tint[] dpK = new int[1000001];\n\tpublic int calcDPK(int n){\n\t\tif(n == 0) return 0;\n\t\telse if(dpK[n] != 0) return dpK[n];\n\t\telse{\n\t\t\tint min = 10000000;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\t\tif(n - t < 0) break;\n\t\t\t\tif(t % 2 == 1){\n\t\t\t\t\tint m = calcDPK(n - t) + 1;\n\t\t\t\t\tif(m < min) min = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdpK[n] = min;\n\t\t\treturn dpK[n];\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tfinal int max = 1000000;\n\t\tint[] vals = new int[200];\n\t\tint maxN = 1;\n\t\tint val = 1;\n\t\tint maxValN = 0;\n\n\t\tArrayList<Integer> arrayList = new ArrayList<>();\n\t\tint n;\n\t\twhile ((n = s.nextInt()) != 0) {\n\t\t\tarrayList.add(n);\n\t\t}\n\n\t\twhile (val < max) {\n\t\t\tvals[maxN] = val;\n\t\t\tif (val % 2 == 1) {\n\t\t\t\tmaxValN = maxN;\n\t\t\t}\n\t\t\tmaxN++;\n\t\t\tval = maxN * (maxN + 1) * (maxN + 2) / 6;\n\t\t}\n\t\tmaxN--;\n\n\t\tint[] dp = new int[max];\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tdp[i] = 1000000000;\n\t\t}\n\t\tdp[0] = 0;\n\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tfor (int j = vals[i]; j < max; j++) {\n\t\t\t\tdp[j] = Math.min(dp[j], dp[j - vals[i]] + 1);\n\t\t\t}\n\n\t\t}\n\t\tint[][] b = new int[arrayList.size()][2];\n\t\tfor (int i = 0; i < arrayList.size(); i++) {\n\t\t\tb[i][0] = dp[arrayList.get(i)];\n\t\t}\n\t\tfor (int i = 0; i < dp.length; i++) {\n\t\t\tdp[i] = 1000000000;\n\t\t}\n\t\tdp[0] = 0;\n\n\t\tfor (int i = 1; i <= maxN; i++) {\n\t\t\tif ((vals[i] % 2) != 1)\n\t\t\t\tcontinue;\n\t\t\tfor (int j = vals[i]; j < max; j++) {\n\t\t\t\tdp[j] = Math.min(dp[j], dp[j - vals[i]] + 1);\n\t\t\t}\n\n\t\t}\n\t\tfor (int i = 0; i < arrayList.size(); i++) {\n\t\t\tb[i][1] = dp[arrayList.get(i)];\n\t\t}\n\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tSystem.out.println(b[i][0] + \" \" + b[i][1]);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tvoid doIt() {\n\t\tnew Pollocks_conjecture().main();\n\t}\n\n\tclass Pollocks_conjecture{\n\t\tfinal int MAX = Integer.MAX_VALUE;\n\t\tScanner sc = new Scanner(System.in);\n\t\tfinal int LEN = 1000000;\n\t\tvoid main() {\n\t\t\tList<Integer> li = new ArrayList<>();\n\t\t\tfor(int i = 1; i < LEN; i++) {\n\t\t\t\tint val = cul(i);\n\t\t\t\tif(val <= LEN) {\n\t\t\t\t\tli.add(val);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint dp[] = new int[LEN];\n\t\t\tint dpe[] = new int[LEN];\n\t\t\tArrays.fill(dp, MAX);\n\t\t\tArrays.fill(dpe, MAX);\n\t\t\tdp[0] = 0;\n\t\t\tdpe[0] = 0;\n\t\t\tfor(int i = 1; i <= li.size(); i++) {\n\t\t\t\tint w = li.get(i - 1);\n\t\t\t\tfor(int j = w; j < LEN; j ++) {\n\t\t\t\t\tdp[j] = Math.min(dp[j], dp[j - w] + 1);\n\t\t\t\t}\n\t\t\t\tif(w % 2 != 0) {\n\t\t\t\t\tfor(int j = w; j < LEN; j ++) {\n\t\t\t\t\t\tdpe[j] = Math.min(dpe[j], dpe[j - w] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\twhile(true) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint len = 0;\n\t\t\t\tif(n == 0) return;\t\t\n\t\t\t\tSystem.out.println(dp[n] + \" \" + dpe[n]);\n\t\t\t}\n\t\t}\n\n\t\tint cul(int n) {\n\t\t\treturn (n) * (n + 1) * (n + 2) / 6;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doIt();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic final int MAX = 1000000;\n\tstatic int[][] dp = new int[2][MAX];\n\t\n\t// nを表す必要な正四面体の最小個数を返す\n\tstatic int Search(int k, int n){\n\t\t// 計算されている\n\t\tif(dp[k][n]!=-1){\n\t\t\treturn dp[k][n];\n\t\t}\n\t\t// 再帰によりnを減らすので0の終了条件\n\t\telse if(n==0){\n\t\t\treturn 0;\n\t\t}\n\t\t// 最大値で初期化\n\t\tint min = Integer.MAX_VALUE;\n\t\t// 1番目の正四面体から順にひたすら\n\t\tfor(int i=1;;i++){\n\t\t\t// i 番目の正四面体における粒の数は j\n\t\t\tint j = i*(i+1)*(i+2)/6;\n\t\t\t// 求めたい整数より粒が多い\n\t\t\tif(j>n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 奇数判定時、正四面体の数が偶数\n\t\t\telse if(k==1&&j%2==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 再帰呼び出し\n\t\t\t// 　整数nからj個引いた整数において\n\t\t\t// 　　必要な正四面体の最小の個数を\n\t\t\t// 　　　Search(k,n-j)で呼び出す\n\t\t\t// 　　　　+1はその結果に対してj個足した\n\t\t\t// 　　　　　正四面体1個を意味する\n\t\t\tmin = Math.min(min, Search(k,n-j)+1);\n\t\t}\n\t\t// 整数nの最小個数が求まったので登録\n\t\tdp[k][n] = min;\n\t\t// 最小値を返す\n\t\treturn min;\n\t}\n\t\n\tstatic void dp(){\n\t\t// 整数 i を小さいのから順に\n\t\t// 　必要な正四面体の最小個数を調べる\n\t\tfor(int i=0;i<MAX;i++){\n\t\t\tSearch(0,i);\n\t\t\tSearch(1,i);\t\t// 奇数\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tfor(int i=0;i<2;i++){\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\tdp();\n\t\twhile(true){\n\t\t\tint n = stdIn.nextInt();\n\t\t\tif(n==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(dp[0][n]+\" \"+dp[1][n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic final int INF=Integer.MAX_VALUE;\n\tstatic int[] dp,dp2;\n\tstatic BitSet ef,of;\n\n\tstatic void solve() {\n\t\tdp=new int[(int)1e6+1];\n\t\tdp2=new int[(int)1e6+1];\n\t\tef=new BitSet((int)1e7);\n\t\tof=new BitSet((int)1e7);\n\t\tArrays.fill(dp,INF);\n\t\tArrays.fill(dp2,INF);\n\t\tdp[0]=dp2[0]=0;\n\t\tint[] tet=new int[100];\n\t\tfor(int i=1;i<100;i++){\n\t\t\ttet[i]=tet[i-1]+i*(i+1)/2;\n\t\t\tif(i%4==1)\n\t\t\t\tof.set(tet[i]);\n\t\t\telse\n\t\t\t\tef.set(tet[i]);\n\t\t}\n\n\t\tfor(;;){\n\t\t\tint n=ir.nextInt();\n\t\t\tif(n==0)\n\t\t\t\tbreak;\n\t\t\tout.println(count(n,tet)+\" \"+count_odd(n,tet));\n\t\t}\n\t}\n\n\tstatic int count(int n,int[] tet){\n\t\tif(dp[n]!=INF)\n\t\t\treturn dp[n];\n\t\tif(ef.get(n)||of.get(n))\n\t\t\treturn 1;\n\t\tfor(int i=1;i<=n/2;i++){\n\t\t\tdp[n]=Math.min(dp[n], count(i,tet)+count(n-i,tet));\n\t\t}\n\t\treturn dp[n];\n\t}\n\n\tstatic int count_odd(int n,int[] tet){\n\t\tif(dp2[n]!=INF)\n\t\t\treturn dp2[n];\n\t\tif(of.get(n))\n\t\t\treturn 1;\n\t\tfor(int i=1;i<=n/2;i++){\n\t\t\tdp2[n]=Math.min(dp2[n], count_odd(i,tet)+count_odd(n-i,tet));\n\t\t}\n\t\treturn dp2[n];\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    int[] LUT = new int[1000];\n    for (int i = 1; i < 1000; ++i) {\n      LUT[i] = i * (i + 1) * (i + 2) / 6;\n    }\n    int[] dp = new int[1000000 + 1];\n    Arrays.fill(dp, 1 << 28);\n    dp[0] = 0;\n    for (int i = 1; i < 1000; ++i) {\n      for (int j = 0; j <= 1000000; ++j) {\n        int next = j + LUT[i];\n        if (next > 1000000) {\n          break;\n        }\n        dp[next] = Math.min(dp[next], dp[j] + 1);\n      }\n    }\n    int[] ep = new int[1000000 + 1];\n    Arrays.fill(ep, 1 << 28);\n    ep[0] = 0;\n    for (int i = 1; i < 1000; ++i) {\n      if (LUT[i] % 2 == 0) {\n        continue;\n      }\n      for (int j = 0; j <= 1000000; ++j) {\n        int next = j + LUT[i];\n        if (next > 1000000) {\n          break;\n        }\n        ep[next] = Math.min(ep[next], ep[j] + 1);\n      }\n    }\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n\n      System.out.println(dp[n] + \" \" + ep[n]);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] list1 = makeList();\n\t\tint[] dp1 = new int[1000000];\n\t\tint[] dp2 = new int[1000000]; \n\n\t\tArrays.fill(dp1, 2 << 27);\n\t\tArrays.fill(dp2, 2 << 27);\n\n\t\tdp1[0] = dp2[0] =  0;\n\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tint tmp = list1[i];\n\t\t\tif(list1[i] % 2 == 0)\n\t\t\tfor(int j = tmp; j < 1000000; j++) {\n\t\t\t\tdp1[j] = Math.min(dp1[j-tmp]+1, dp1[j]);\n\t\t\t}\n\t\t\telse\n\t\t\tfor(int j = tmp; j < 1000000; j++) {\n\t\t\t\tdp1[j] = Math.min(dp1[j-tmp]+1, dp1[j]);\n\t\t\t\tdp2[j] = Math.min(dp2[j-tmp]+1, dp2[j]);\n\t\t\t}\n\t\t}\n\t\twhile(true) {\n\t\t\tint a = sc.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tSystem.out.println(dp1[a] + \" \" + dp2[a]);\n\t\t}\n\t}\n\tfinal static int[] makeList() {\n\t\tint[] list1 = new int[180];\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tlist1[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t}\n\t\treturn list1;\n\t}\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Pollock's conjecture\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] p = new int[181];\n\t\tfor(int i=1;i<181;i++){\n\t\t\tp[i] = (i*(i+1)*(i+2))/6;\n\t\t}\n\t\tint[] dp = new int[1000000+1];\n\t\tint[] dp2 = new int[1000000+1];\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\tfor(int i=1;i<=1000000;i++){\n\t\t\tfor(int j=1;j<181;j++){\n\t\t\t\tif(i-p[j]>=0){\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i-p[j]]+1);\n\t\t\t\t\tif(p[j]%2==1){\n\t\t\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i-p[j]]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tSystem.out.println(dp[n]+\" \"+dp2[n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint n;\n\tint[] b = new int[180];\n\tint[] c = new int[45];\n\tint[] d = new int[1000000];\n\tint[] e = new int[1000000];\n\tArrayDeque<Integer> list = new ArrayDeque<Integer>();\n\t\n\tpublic void init(){\n\t\tint sum=0;\n\t\tfor(int i=1;i<=180;i++){\n\t\t\tb[i-1]=(i*(i+1)*(i+2))/6;\n\t\t\tif(b[i-1]%2==1){\n\t\t\t\tc[sum]=b[i-1];\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void funcA(){\n\t\tlist.offer(0);\n\t\tint z=1;\n\t\tint i=0;\n\t\twhile(z<1000000){\n\t\t\ti++;\n\t\t\tint x = list.size();\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tint y = list.poll();\n\t\t\t\tfor(int k=0;k<180;k++){\n\t\t\t\t\tint sum = y + b[k];\n\t\t\t\t\tif(sum<1000000 && d[sum]==0){\n\t\t\t\t\t\td[sum]=i;\n\t\t\t\t\t\tlist.offer(sum);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void funcB(){\n\t\tlist.clear();\n\t\tlist.offer(0);\n\t\tint z=1;\n\t\tint i=0;\n\t\twhile(z<1000000){\n\t\t\ti++;\n\t\t\tint x = list.size();\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tint y = list.poll();\n\t\t\t\tfor(int k=0;k<45;k++){\n\t\t\t\t\tint sum = y + c[k];\n\t\t\t\t\tif(sum<1000000 && e[sum]==0){\n\t\t\t\t\t\te[sum]=i;\n\t\t\t\t\t\tlist.offer(sum);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void print(){\n\t\tSystem.out.println(d[n] + \" \" + e[n]);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain C = new Main();\n\t\tScanner sc = new Scanner(System.in);\n\t\tC.init();\n\t\tC.funcA();\n\t\tC.funcB();\n\t\tint exit=0;\n\t\twhile(exit==0){\n\t\t\tC.n = sc.nextInt();\n\t\t\tif(C.n==0)exit=1;\n\t\t\tif(exit==0){\t\n\t\t\t\tC.print();\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    int[] all_num = new int[10000];\n    final static int max = 1000000;\n    int devise(int num){\n        int index = 0;\n        for(int i = 0;i < 1417;i++){\n            if(all_num[i] >= num){\n                index = i - 1;\n            }\n        }\n        return index;\n    }\n    int clac(int count, int ans,int num,int index,int nowindex){\n        if((ans + all_num[nowindex]) == num){\n            nowindex = 0;\n            return count;\n        }\n        else if((ans + all_num[nowindex]) < num){\n            ans += all_num[nowindex];\n            nowindex++;\n            System.out.println(nowindex);\n            count++;\n        }\n        else if((ans + all_num[nowindex]) >= num){\n            index--;\n            nowindex = 0;\n        }\n        return clac(count,ans,num,index,nowindex);\n    }\n    int looping(int count,int ans,int num,int index){\n        ans = all_num[index];\n        for(int i = index;i <= -1;i++){\n            if((ans + all_num[i]) == num){\n                System.out.println(\"count:\"+count+\" ans:\"+ans);\n                return count;\n            }\n            else if((ans + all_num[i]) < num){\n                ans += all_num[i];\n                count++;\n            }\n            else if((ans + all_num[i]) >= num){\n                index--;\n            }\n            return looping(count,ans, num, index);\n        }\n        return count;\n    }\n    void doteki(){\n        for(int i = 0; i < 10000;i++){\n            all_num[i] = ((i+1)*(i+2)*(i+3))/6;\n            if(all_num[i] < max){\n                //System.out.println(all_num[i]);\n            }\n            else\n                break;\n        }\n    }\n    boolean kisuu(int num){\n        if(num % 2 == 1){\n            return true;\n        }\n        return false;\n    }\n    void run() throws IOException{\n        //System.out.println(num);\n        doteki();\n        int num;\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            num = Integer.parseInt(in.readLine());\n            int index = 0;\n            int count = 0;\n            int ans = 0;\n            int ans_count = 10000;\n            if(num == 0){\n                break;\n            }\n            index = devise(num);\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(ans + all_num[j] > num){\n                        j--;\n                    }\n                    else if(ans + all_num[j] < num){\n                        ans += all_num[j];\n                        count++;\n                    }\n                    else if(ans + all_num[j] == num){\n                        count++;\n                        if(ans_count >= count){\n                            ans_count = count;\n                            count = 0;\n                        }\n                        break;\n                    }\n                }\n            }\n            System.out.print(ans_count);\n            //?\\???°??¨\n            count = 0;\n            ans = 0;\n            ans_count = 100000;\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(kisuu(all_num[j]) == true){\n                        if(ans + all_num[j] > num){\n                            j--;\n                        }\n                        else if(ans + all_num[j] < num){\n                            ans += all_num[j];\n                            count++;\n                        }\n                        else if(ans + all_num[j] == num){\n                            count++;\n                            if(ans_count >= count){\n                                ans_count = count;\n                                count = 0;\n                            }\n                            break;\n                        }\n                    }\n                    else{\n                        j--;\n                    }\n                }\n            }\n            System.out.print(\" \"+ans_count);\n            System.out.println();\n\n        }\n\n\n\n    }\n    public static void main(String[] args) throws IOException{\n        Main ma = new Main();\n        ma.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic int[] list1 = new int[180];\n\tstatic int[] list2 = new int[45];\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tmakeList();\n\t\tint[] dp1 = new int[1000000];\n\t\tint[] dp2 = new int[1000000]; \n\t\t\n\n\t\tArrays.fill(dp1, 2 << 27);\n\t\tArrays.fill(dp2, 2 << 27);\n\n\t\tdp1[0] = dp2[0] =  0;\n\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tfor(int j = 0; j < 1000000; j++) {\n\t\t\t\tif(j + list1[i]  >= 1000000) break;\n\t\t\t\tdp1[j + list1[i]] = Math.min(dp1[j+list1[i]], dp1[j] + 1);\n\t\t\t\tif(list1[i] % 2 == 1) dp2[j + list1[i]] = Math.min(dp2[j+list1[i]], dp2[j]+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true) {\n\t\t\tint a = sc.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tSystem.out.println(dp1[a] + \" \" + dp2[a]);\n\t\t}\n\t}\n\t\n\tstatic void makeList() {\n\t\tint count1 = 0;\n\t\tint count2 = 0;\n\t\tfor(int i = 1; i < 1000001; i++) {\n\t\t\tint sum = i*(i+1)*(i+2)/6;\n\t\t\tif(sum > 1000001) break;\n\t\t\tif(sum % 2 == 1) {\n\t\t\t\tlist1[count1++] = sum;\n\t\t\t\tlist2[count2++] = sum;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlist1[count1++] = sum;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tint n;\n\tint[] pollock = new int[180];\n\tint[] cnt = new int[1000001];\n\tint[] cnt2 = new int[1000001];\n\t\n\tvoid initPollock() {\n\t\tfor (int i = 1; i <= pollock.length; i++) {\n\t\t\tpollock[i-1] = (i * (i+1) * (i+2)) / 6;\n\t\t}\n\t}\n\t\n\tpublic Main() {\n\t\tinitPollock();\n\t\tArrays.fill(cnt, 1000000);\n\t\tArrays.fill(cnt2, 1000000);\n\t\tcnt[0] = 0; cnt2[0] = 0;\n\t\tfor (int i = 0; i < pollock.length; i++) {\n\t\t\tint pol = pollock[i];\n\t\t\tif (pol % 2 == 0) {\n\t\t\t\tfor (int j = pol; j <= 1000000; j++) {\n\t\t\t\t\tcnt[j] = Math.min(cnt[j], cnt[j - pol] + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = pol; j <= 1000000; j++) {\n\t\t\t\t\tcnt[j] = Math.min(cnt[j], cnt[j - pol] + 1);\n\t\t\t\t\tcnt2[j] = Math.min(cnt2[j], cnt2[j - pol] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tSystem.out.println(cnt[n] + \" \" + cnt2[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew Main();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(solve(input));\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static String solve(int input) {\n\t\tint c = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tc = i;\n\t\t\tlist.add((i*(i+1)*(i+2))/6);\n\t\t}\n\n\t\tint[][] dp = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return dp[input-1][c-1];\n\n\t\tint c2 = 0;\n\t\tArrayList list2 = new ArrayList();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tif(((i*(i+1)*(i+2)/6) % 2) != 0) {\n\t\t\t\tc2++;\n\t\t\t\tlist2.add((i*(i+1)*(i+2))/6);\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp2 = new int[input][c2];\n\n\t\tfor(int i=0 ; i<c2 ; i++) {\n\t\t\tint v2 = Integer.parseInt(list2.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp2[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v2) == 0) {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2), dp2[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v2) {\n\t\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2)+dp2[((j+1)%v2) - 1][i-1], dp2[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[input-1][c-1] + \" \" + dp2[input-1][c2-1];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.InputStream;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n/**\n * @author kumar1\n * \n */\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tInputStream in = System.in;\n\t\tScanner scanner = new Scanner(in);\n\t\tLinkedList<String> ans = new LinkedList<String>();\n\t\t// DPでとく\n\t\tint[] map = new int[1000001];\n\t\tfor(int i=0; i < map.length; i++)\n\t\t\tmap[i] = 1000001;\n\t\tint[] mapodd = new int[map.length];\n\t\tfor(int i=0; i < mapodd.length; i++)\n\t\t\tmapodd[i] = 1000001;\n\t\tfor(int n=0; ; n++) {\n\t\t\tint pollock = n * (n + 1) * (n + 2) / 6;\n\t\t\tif(pollock > 1000000)\n\t\t\t\tbreak;\n\t\t\tmap[pollock] = 1;\n\t\t\tfor(int i=0; i < 1000001; i++) {\n\t\t\t\tif(i - pollock < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tmap[i] = Math.min(map[i], map[i - pollock] + 1);\t\n\t\t\t}\n\t\t\tif(pollock % 2 == 1) {\n\t\t\t\tmapodd[pollock] = 1;\n\t\t\t\tfor(int i=0; i < 1000001; i++) {\n\t\t\t\t\tif(i - pollock < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmapodd[i] = Math.min(mapodd[i], mapodd[i - pollock] + 1);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (true) {\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (x == 0)\n\t\t\t\tbreak;\n\t\t\tans.add(map[x] + \" \" + mapodd[x]);\n\t\t}\n\t\tscanner.close();\n\t\tfor (String a : ans) {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t}\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int n;\n\tpublic static final int max = 1000000;\n\tpublic static ArrayList<Integer> all;\n\tpublic static ArrayList<Integer> odd;\n\tpublic static void main(String[] args){\n\t\tall = new ArrayList<Integer>();\n\t\todd = new ArrayList<Integer>();\n\t\tfor(int i=1; i<=1000; i++){\n\t\t\tlong num = (long)i*(i+1)*(i+2)/6;\n\t\t\tif(num > max) break;\n\t\t\tall.add((int)num);\n\t\t\tif(num % 2 == 1){\n\t\t\t\todd.add((int)num);\n\t\t\t}\n\t\t}\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\tresall = max;\n\t\t\tresodd = max;\n\t\t\tdfsall(all.size()-1, 0, 0);\n\t\t\tdfsodd(odd.size()-1, 0, 0);\n\t\t\tSystem.out.println(resall+\" \"+resodd);\n\t\t}\n\t}\n\t\n\tpublic static int resodd;\n\tpublic static void dfsodd(int start, int sum, int depth){\n\t\tif(sum == n){\n\t\t\tresodd = Math.min(resodd, depth);\n\t\t\treturn;\n\t\t}\n\t\tif(sum > n || depth >= resodd) return;\n\t\tfor(int i=start; i>=0; i--){\n\t\t\tdfsodd(i, sum+odd.get(i), depth+1);\n\t\t}\n\t}\n\t\n\tpublic static int resall;\n\tpublic static void dfsall(int start, int sum, int depth){\n\t\tif(sum == n){\n\t\t\tresall = Math.min(resall, depth);\n\t\t\treturn;\n\t\t}\n\t\tif(depth >= 5 || sum > n) return;\n\t\tfor(int i=start; i>=0 && sum+all.get(i)*(5-depth)>=n; i--){\n\t\t\tdfsall(i, sum+all.get(i), depth+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic void run() {\n\t\tdp[1] = 1;\n\t\tdpK[1] = 1;\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int n){\n\t\tint m = calcDP(n);\n\t\tint mK = calcDPK(n);\n\t\tSystem.out.println(m + \" \" + mK);\n\t}\n\tint[] dp = new int[1000001];\n\tpublic int calcDP(int n){\n\t\tif(n == 0) return 0;\n\t\telse{\n\t\t\tint min = 10;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\t\tif(n - t < 0) break;\n\t\t\t\tint m;\n\t\t\t\tif(dp[n-t] != 0) m = dp[n-t] + 1;\n\t\t\t\telse m = calcDP(n - t) + 1;\n\t\t\t\tif(m < min) \n\t\t\t\t\tmin = m;\n\t\t\t}\n\t\t\tdp[n] = min;\n\t\t\treturn dp[n];\n\t\t}\n\t}\n\tint[] dpK = new int[1000001];\n\tpublic int calcDPK(int n){\n\t\tif(n == 0) return 0;\n\t\telse{\n\t\t\tint min = 10000000;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\t\tif(n - t < 0) break;\n\t\t\t\tif(t % 2 == 1){\n\t\t\t\t\tint m;\n\t\t\t\t\tif(dpK[n-t] != 0) m = dpK[n-t] + 1;\n\t\t\t\t\telse m = calcDPK(n - t) + 1;\n\t\t\t\t\tif(m < min) min = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdpK[n] = min;\n\t\t\treturn dpK[n];\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] dp1=new int[1000000];\n\tstatic int[] dp2=new int[1000000];\n\t\n\tstatic void n() {\n\t\tfor(int num=1; num*(num+1)*(num+2)/6<1000000; num++) {\n\t\t\tdp1[num*(num+1)*(num+2)/6]=1;\n\t\t\tif((num*(num+1)*(num+2)/6)%2!=0){\n\t\t\t\tdp2[num*(num+1)*(num+2)/6]=1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0) break;\n\t\t\t\tArrays.fill(dp1, 100000000);\n\t\t\t\tArrays.fill(dp2, 100000000);\n\t\t\t\tn();\n\t\t\t\t\n\t\t\t\tfor(int num=1; num<=N; num++) {\n\t\t\t\t\tfor(int i=1; i<num; i++) {\n\t\t\t\t\t\tdp1[num]=Math.min(dp1[num], dp1[num-i]+dp1[i]);\n\t\t\t\t\t\t//System.out.println(\"i=\"+i+\"dp1[\"+num+\"]=\"+dp1[num]);\n\t\t\t\t\t\tdp2[num]=Math.min(dp2[num], dp2[num-i]+dp2[i]);\n\t\t\t\t\t\t//System.out.println(\"i=\"+i+\"dp2[\"+num+\"]=\"+dp2[num]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(dp1[N]+\" \"+dp2[N]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tshort[] DP = new short[1000001];\n\t\tshort[] ODD_DP = new short[1000001];\n\t\t\n\t\tfor(int j = 0; j <= 1000000; j++){\n\t\t\tDP[j] = ODD_DP[j] = -1;\n\t\t}\n\t\t\n\t\tDP[0] = 0;\n\t\tODD_DP[0] = 0;\n\t\t\n\t\tfor(int i = 0; i < 58; i++){\n\t\t\tint number = ((i + 1) * (i + 2) * (i + 3)) / 6;\n\t\t\t\n\t\t\tfor(int j = 0; j <= (100000 - number); j++){\n\t\t\t\tif(DP[j] != -1){\n\t\t\t\t\tif(DP[j + number] == -1){\n\t\t\t\t\t\tDP[j + number] = (short) (DP[j] + 1);\n\t\t\t\t\t}else if(DP[j + number] > DP[j] + 1){\n\t\t\t\t\t\tDP[j + number] = (short) (DP[j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(number % 2 == 1){\n\t\t\t\tfor(int j = 0; j <= (100000 - number); j++){\n\t\t\t\t\tif(ODD_DP[j] != -1){\n\t\t\t\t\t\tif(ODD_DP[j + number] == -1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (short) (ODD_DP[j] + 1);\n\t\t\t\t\t\t}else if(ODD_DP[j + number] > ODD_DP[j] + 1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (short) (ODD_DP[j] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(DP[n] + \" \" + ODD_DP[n]);\n\t\t\t\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport javax.naming.BinaryRefAddr;\n\nimport static java.lang.System.*;\n\nclass Main {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n\n\n    public void run() {\n    \tList<Integer> pollock=new ArrayList<Integer>();\n\n    \tfor(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    \t\tpollock.add(i*(i+1)*(i+2)/6);\n    \t}\n\n    \tint[] dp=new int[100000],dp2=new int[100000];\n\n    \tfor(int i=1;i<100000;i++){\n    \t\tint min=Integer.MAX_VALUE;\n    \t\tfor(int j:pollock){\n    \t\t\tif(i-j>=0)min=Math.min(min,dp[i-j]+1);\n    \t\t}\n    \t\tdp[i]=min;\n    \t}\n\n    \tfor(int i=1;i<100000;i++){\n    \t\tint min=Integer.MAX_VALUE;\n    \t\tfor(int j:pollock){\n    \t\t\tif(i-j>=0 && j%2==1)\n    \t\t\t\tmin=Math.min(min,dp2[i-j]+1);\n    \t\t}\n    \t\tdp2[i]=min;\n    \t}\n\n\n    \twhile(true){\n        \tint n=sc.nextInt();\n        \tif(n==0)return;\n\n        \tln(dp[n]+\" \"+dp2[n]);\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public int[] nextIntArray(int n){\n        int[] res=new int[n];\n        for(int i=0;i<n;i++){\n            res[i]=sc.nextInt();\n        }\n        return res;\n    }\n    public static void pr(Object o) {\n        out.print(o);\n    }\n    public static void ln(Object o) {\n        out.println(o);\n    }\n    public static void ln() {\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic int[] dp = new int[1000001];\n\tstatic int[] dp2 = new int[1000001];\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tfill(dp, 100000000);\n\t\tfill(dp2, 100000000);\n\t\tdp[0] = dp2[0] = 0;\n\t\tdp[1] = dp2[1] = 1;\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tfor (int j = 1; ; j++) {\n\t\t\t\tint a = f(j);\n\t\t\t\tint b = i - a;\n\t\t\t\tif (b < 0) break;\n\t\t\t\tdp[i] = min(dp[i], 1 + dp[b]);\n\t\t\t\tif (a % 2 == 1)\n\t\t\t\t\tdp2[i] = min(dp2[i], 1 + dp2[b]);\n\t\t\t}\n\t\t}\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N;\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tif (N == 0) return false;\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\tSystem.out.println(dp[N] + \" \" + dp2[N]);\n\t}\n\n\n\tstatic int f(int n) {\n\t\treturn n * (n + 1) * (n + 2) / 6;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// int nnn=3*(3+1)*(3+2)/6;\n\t\t// System.out.println(nnn);\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tint min = 1000000;\n\t\t\t// int tate = n * (n + 1) * (n + 2);\n\n\t\t\t// tate++;\n\t\t\tlong[][] dp = new long[181][n + 1];\n\t\t\tlong[][] dpki = new long[181][n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tdp[1][i] = i;\n\t\t\t\tdp[0][i] = 1000000;\n\n\t\t\t\tdpki[1][i] = i;\n\t\t\t\tdpki[0][i] = 1000000;\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < 181; i++) {\n\n\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\n\t\t\t\tint sum = i * (i + 1) * (i + 2) / 6;\n\n\t\t\t\tfor(int j=sum;j<=n;j++){\n\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],dp[i][j-sum]+1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tif (sum <= n && dp[i - 1][sum] > 1)\n\t\t\t\t\tdp[i][sum] = 1;\n\t\t\t\tint count = 2;\n\t\t\t\tfor (int j = sum * 2; j <= n; j += sum) {\n\t\t\t\t\tif (dp[i - 1][j] > count)\n\t\t\t\t\t\tdp[i][j] = count;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\t// for (int k = 2; n / sum >= k; k++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (n >= j + sum && dp[i - 1][j + sum] > dp[i - 1][j] + 1 && dp[i][j + sum] > dp[i - 1][j] + 1)\n\t\t\t\t\t\tdp[i][j + sum] = dp[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t\t// }\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < 181; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\tdpki[i][j] = dpki[i - 1][j];\n\n\t\t\t\tint sum2 = i * (i + 1) * (i + 2) / 6;\n\n\t\t\t\tif (sum2 % 2 == 0)\n\t\t\t\t\tcontinue;\n\n//\t\t\t\tif(dpki[i][sum2]>1)dp[i][sum2]=1;\n\t\t\t\tfor(int j=sum2;j<=n;j++){\n\t\t\t\t\tdpki[i][j]=Math.min(dpki[i][j],dpki[i][j-sum2]+1);\n\t\t\t\t}\n\t\t\t\t\n/*\t\t\t\tif (sum2 <= n && dpki[i - 1][sum2] > 1)dpki[i][sum2] = 1;\n\t\t\t\tint count2 = 2;\n\t\t\t\tfor (int j = sum2 * 2; j <= n; j += sum2) {\n\t\t\t\t\tif (dpki[i - 1][j] > count2)\n\t\t\t\t\t\tdpki[i][j] = count2;\n\t\t\t\t\tcount2++;\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (n >= j + sum2 && dpki[i][j + sum2] > dpki[i][j] + 1)dpki[i][j + sum2] = dpki[i][j] + 1;\n\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tfor (int k = 1; n / sum2 >= k; k++) {\n\t\t\t\t\tint sss=sum2*k;\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tif (n >= j + sss && dpki[i][j + sss] > dpki[i][j] + 1)dpki[i][j + sss] = dpki[i][j] + 1;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t/*\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tSystem.out.print(dpki[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n*/\n\t\t\tint result = 1000000;\n\t\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\t// System.out.println(dp[i][n]);\n\t\t\t\tif (dp[i][n] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult = (int) Math.min(dp[i][n], result);\n\n\t\t\t}\n\t\t\tint result2 = 1000000;\n\t\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\t// System.out.println(dp[i][n]);\n\t\t\t\tif (dpki[i][n] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult2 = (int) Math.min(dpki[i][n], result2);\n\n\t\t\t}\n\n\t\t\tSystem.out.print(result+\" \");\n\t\t\tSystem.out.println(result2);\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class PollockConjecture {\n\tScanner in = new Scanner(System.in);\n\tint n;\n\tint[] pollock = new int[180];\n\tint[] cnt = new int[1000001];\n\tint[] cnt2 = new int[1000001];\n\t\n\tvoid initPollock() {\n\t\tfor (int i = 1; i <= pollock.length; i++) {\n\t\t\tpollock[i-1] = (i * (i+1) * (i+2)) / 6;\n\t\t}\n\t}\n\t\n\tpublic PollockConjecture() {\n\t\tinitPollock();\n\t\tArrays.fill(cnt, 1000000);\n\t\tArrays.fill(cnt2, 1000000);\n\t\tcnt[0] = 0; cnt2[0] = 0;\n\t\tfor (int i = 0; i < pollock.length; i++) {\n\t\t\tint pol = pollock[i];\n\t\t\tif (pol % 2 == 0) {\n\t\t\t\tfor (int j = pol; j <= 1000000; j++) {\n\t\t\t\t\tcnt[j] = Math.min(cnt[j], cnt[j - pol] + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = pol; j <= 1000000; j++) {\n\t\t\t\t\tcnt[j] = Math.min(cnt[j], cnt[j - pol] + 1);\n\t\t\t\t\tcnt2[j] = Math.min(cnt2[j], cnt2[j - pol] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tn = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\tSystem.out.println(cnt[n] + \" \" + cnt2[n]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tnew PollockConjecture();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tstatic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] ary = new int[200];\n\t\tint[] ary2 = new int[200];\n\t\tint p = 1;\n\t\tfor(int i = 1; i < 200; i++){\n\t\t\tary[i] = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(ary[i] % 2 == 1){\n\t\t\t\tary2[p] = ary[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\twhile(0 < n){\n\t\t\tSystem.out.println(solve(n, ary) + \" \" + solve(n, ary2));\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\tstatic int solve(int n, int[] ary){\n\t\tint[] dp = new int[n + 1];\n\t\tArrays.fill(dp, 1000000);\n\t\tdp[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j < ary.length; j++)\n\t\t\t\tif(i < ary[j]) break;\n\t\t\t\telse if(dp[i - ary[j]] + 1 < dp[i]) dp[i] = dp[i - ary[j]] + 1;\n\t\t}\n\t\treturn dp[n];\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    ArrayList<Integer> list;\n    ArrayList<Integer> list2;\n\n    list = new ArrayList<>();\n    list2 = new ArrayList<>();\n    int pre = 1;\n    int n = 1;\n    while((pre = n*(n+1)*(n+2)/6)<1000000) {\n      n++;\n      if(pre%2==1) list.add(pre);\n      list2.add(pre);\n    }\n    int input = 0;\n\n    int[] dp2 = new int[1000001];\n    int[] dp = new int[1000001];\n    while((input=scan.nextInt())!=0) {\n      System.out.print(calc(input,dp2,list2)+\" \");\n      System.out.println(calc(input,dp,list));\n    }\n  }\n\n  static int calc(int sum, int[] dp, ArrayList<Integer> list) {\n    if(sum==0) return 0;\n    if(dp[sum]>0) return dp[sum];\n    int max = 0;\n    int count = 999999;\n    int res = 0;\n    for(int i = list.size()-1; i >= 0; i--) {\n      max = list.get(i);\n      if(max==sum) {\n        res = 1;\n        break;\n      }\n      if(max<sum) {\n        res = 1 + calc(sum-max,dp,list);\n        count = Math.min(res, count);\n      }\n    }\n    count = Math.min(res, count);\n    dp[sum] = count;\n    return count;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int[] lib = new int[180];\n    int[] lib2 = new int[45];\n    int libi = 0;\n    int lib2i = 0;\n    for (int i = 1; ; i++) {\n      int k = (i * (i + 1) * (i + 2)) / 6;\n      lib[libi++] = k;\n      if (k % 2 == 1) {\n        lib2[lib2i++] = k;\n      }\n      if (k >= 1000000) {\n        break;\n      }\n    }\n    System.out.println(libi);\n    System.out.println(lib2i);\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      System.out.println(calc(n, lib) + \" \" + calc(n, lib2));\n    }\n  }\n\n  static int calc(int n, int[] lib) {\n    short[][] dp = new short[lib.length][n + 1];\n    for (int i = 0; i < 300; i++) {\n      for (int j = 0; j < n + 1; j++) {\n        dp[i][j] = Short.MAX_VALUE;\n      }\n    }\n    for (short i = 0; i <= n; i++) {\n      dp[0][i] = i;\n    }\n    for (int i = 1; i < lib.length; i++) {\n      int v = lib[i];\n      if (lib[i] > n) {\n//        System.out.println(\"--------\");\n//        for (int o = 0; o < i; ++o) {\n//          for (int j = 0; j <= n; ++j) {\n//            System.out.printf(\" %2d\", dp[o][j]);\n//          }\n//          System.out.println();\n//        }\n\n        return dp[i - 1][n];\n      }\n      for (int j = 0; j <= n; j++) {\n        if (dp[i - 1][j] == Integer.MAX_VALUE) {\n          continue;\n        }\n        for (int k = 0; j + k * v <= n; k++) {\n          dp[i][j + k * v] = (short) Math.min(dp[i][j + k * v], dp[i - 1][j] + k);\n        }\n      }\n    }\n    return dp[lib.length][n];\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint[][] dp=new int[(int)1e6+1][2];\n\t\tint[] tet=new int[1001];\n\t\tint[] tet2=new int[500];\n\t\tfor(int i=0;i<=1000;i++)\n\t\t\ttet[i]=i*(i+1)*(i+2)/6;\n\t\tfor(int i=0;i<500;i++)\n\t\t\ttet2[i]=tet[i*2+1];\n\t\tfor(int i=1;i<=(int)1e6;i++)\n\t\t\tArrays.fill(dp[i],Integer.MAX_VALUE);\n\t\tfor(int i=1;i<=(int)1e6;i++){\n\t\t\tfor(int j=1;j*(j+1)*(j+2)<=6*i;j++){\n\t\t\t\tdp[i][0]=Math.min(dp[i][0],dp[i-j*(j+1)*(j+2)/6][0]+1);\n\t\t\t\tif(j%4==1)\n\t\t\t\t\tdp[i][1]=Math.min(dp[i][1],dp[i-j*(j+1)*(j+2)/6][1]+1);\n\t\t\t}\n\t\t}\n\t\tfor(;;){\n\t\t\tint n=ir.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tout.println(dp[n][0]+\" \"+dp[n][1]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tint[] p = new int[181];\n\tint[] oddp = new int[46];\n\t\n\tint[] memo = new int[1000001];\n\tint[] oddmemo = new int[1000001];\n\t\n\tint calc(int n, int index) {\n\t\tif (memo[n] == 0) {\n\t\t\tif (index == 0) return n;\n\t\t\t\n\t\t\twhile (n < p[index]) index--;\n\t\t\tif (n == p[index]) return 1;\n\t\t\t\n\t\t\tint min = 1000000;\n\t\t\tfor (int i = index; i >= 0; i--) {\n\t\t\t\tmin = Math.min(min, calc(n-p[i], i));\n\t\t\t}\n\t\t\tmemo[n] = min+1;\n\t\t}\n\t\t\n\t\treturn memo[n];\n\t}\n\t\n\tint calcodd(int n, int index) {\n\t\tif (oddmemo[n] == 0) {\n\t\t\tif (index == 0) return n;\n\t\t\t\n\t\t\twhile (n < oddp[index]) index--;\n\t\t\tif (n == oddp[index]) return 1;\n\t\t\t\n\t\t\tint min = 1000000;\n\t\t\tfor (int i = index; i >= 0; i--) {\n\t\t\t\t\n\t\t\t\tmin = Math.min(min, calcodd(n-oddp[i], i));\n\t\t\t}\n\t\t\toddmemo[n] = min+1;\n\t\t}\n\t\t\n\t\treturn oddmemo[n];\n\t}\n\t\n\tvoid run() {\n\t\tint n;\n\t\t\n\t\t\n\t\tfor (int i = 0; i < 181; i++) {\n\t\t\tp[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t\tif (i % 4 == 0) {\n\t\t\t\toddp[i/4] = (i+1)*(i+2)*(i+3)/6;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\n\t\t\tout.printf(\"%d %d\\n\", calc(n, 180), calcodd(n, 45));\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint max=1000001;\n\n\tint[] dp1, dp2;\n\tint n;\n\n\tvoid run(){\n\t\tdp1=new int[max];\n\t\tdp2=new int[max];\n\t\tfill(dp1, INF);\n\t\tfill(dp2, INF);\n\t\tdp1[0]=0;\n\t\tdp2[0]=0;\n\n\t\tfor(int i=0; i<max; i++){\n\t\t\tfor(int j=1, sum=1; i+sum<max; j++, sum+=j*(j+1)/2){\n\t\t\t\tdp1[i+sum]=min(dp1[i+sum], dp1[i]+1);\n\t\t\t\tif(sum%2==1){\n\t\t\t\t\tdp2[i+sum]=min(dp2[i+sum], dp2[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tprintln(dp1[n]+\" \"+dp2[n]);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main{\n\tstatic int[][] pollock = new int[2][1000000];\n\n\tstatic void Conjecture(){\n\t\tint n = 1;\n\t\tArrays.fill(pollock[0], 1000000);\n\t\tArrays.fill(pollock[1], 1000000);\n\n\t\twhile(n*(n+1)*(n+2)<1000000*6){\n\t\t\tpollock[0][n*(n+1)*(n+2)/6] = 1;\n\t\t\tif((n*(n+1)*(n+2)/6)%2==1){\n\t\t\t\tpollock[1][n*(n+1)*(n+2)/6] = 1;\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\n\t\tn = 1;\n\t\tfor(int i=2; i<1000000; i++){\n\t\t\tif(pollock[0][i]==1) n++;\n\n\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\tpollock[0][i] = Math.min(pollock[0][i], pollock[0][i-j*(j+1)*(j+2)/6]+1);\n\t\t\t\tif((j*(j+1)*(j+2)/6)%2==1){\n\t\t\t\t\tpollock[1][i] = Math.min(pollock[1][i], pollock[1][i-j*(j+1)*(j+2)/6]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tConjecture();\n\n\t\twhile(true){\n\t\t\tint num = sc.nextInt();\n\t\t\tif(num==0) break;\n\t\t\tSystem.out.println(pollock[0][num] + \" \" + pollock[1][num]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic final int INF=Integer.MAX_VALUE;\n\tstatic int[] dp,dp2;\n\tstatic BitSet ef,of;\n\n\tstatic void solve() {\n\t\tdp=new int[(int)1e6];\n\t\tdp2=new int[(int)1e6];\n\t\tef=new BitSet((int)1e7);\n\t\tof=new BitSet((int)1e7);\n\t\tArrays.fill(dp,INF);\n\t\tArrays.fill(dp2,INF);\n\t\tdp[0]=dp2[0]=0;\n\t\tint[] tet=new int[100];\n\t\tfor(int i=1;i<100;i++){\n\t\t\ttet[i]=tet[i-1]+i*(i+1)/2;\n\t\t\tif(i%4==1)\n\t\t\t\tof.set(tet[i]);\n\t\t\telse\n\t\t\t\tef.set(tet[i]);\n\t\t}\n\n\t\tfor(;;){\n\t\t\tint n=ir.nextInt();\n\t\t\tif(n==0)\n\t\t\t\tbreak;\n\t\t\tout.println(count(n,tet)+\" \"+count_odd(n,tet));\n\t\t}\n\t}\n\n\tstatic int count(int n,int[] tet){\n\t\tif(dp[n]!=INF)\n\t\t\treturn dp[n];\n\t\tif(ef.get(n)||of.get(n))\n\t\t\treturn 1;\n\t\tfor(int i=1;i<=n/2;i++){\n\t\t\tdp[n]=Math.min(dp[n], count(i,tet)+count(n-i,tet));\n\t\t}\n\t\treturn dp[n];\n\t}\n\n\tstatic int count_odd(int n,int[] tet){\n\t\tif(dp2[n]!=INF)\n\t\t\treturn dp2[n];\n\t\tif(of.get(n))\n\t\t\treturn 1;\n\t\tfor(int i=1;i<=n/2;i++){\n\t\t\tdp2[n]=Math.min(dp2[n], count_odd(i,tet)+count_odd(n-i,tet));\n\t\t}\n\t\treturn dp2[n];\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/*\nicpc??´?????????\n2010??´ ?????? C??????\n*/\nimport java.io.*;\n\nclass HOME_C {\n\tstatic int map[];\n\tstatic int mapb[];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\trun();\n\t\t} catch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\tprivate static void run() throws IOException{\n\t\tfinal int MAX = 1000000;\n\t\tint n;\n\t\tint instant;\n\t\tmap = new int[MAX+1];\n\t\tmapb = new int[MAX+1];\n\t\t\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tfor(int i=1;i<=MAX;i++) {\n\t\t\t//if(i%100000==0)System.out.print(\".\");\n\t\t\tmap[i] = f(i);\n\t\t\tmapb[i] = fb(i);\n\t\t}\n\t\t//System.out.println(\"\");\n\t\t\n\t\twhile(true) {\n\t\t\tn = Integer.parseInt(in.readLine()); //???????????£?????????\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tSystem.out.println(map[n] + \" \" + mapb[n]);\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tprivate static int f(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > map[n-tk]) {\n\t\t\t\t\tmin = map[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 1+min;\n\t}\n\t\n\tprivate static int fb(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0 || tk%2==0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > mapb[n-tk]) {\n\t\t\t\t\tmin = mapb[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\treturn 1+min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic void solve() {\n\t\tint maxN = 1000000, INF = Integer.MAX_VALUE;\n\t\tint[][] ary = new int[2][maxN + 1];\n\t\tArrays.fill(ary[0], INF);\n\t\tArrays.fill(ary[1], INF);\n\t\tary[0][0] = ary[1][0] = 0;\n\t\tArrayList<Integer> rt = new ArrayList<Integer>();\n\t\tArrayList<Integer> rt_odd = new ArrayList<Integer>();\n\t\tfor (int i = 1;; i++) {\n\t\t\tint rt_i = rt(i);\n\t\t\tif (rt_i >= maxN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trt.add(rt_i);\n\t\t\tif (rt_i % 2 == 1) {\n\t\t\t\trt_odd.add(rt_i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= maxN; i++) {\n\t\t\tif (ary[0][i] < INF) {\n\t\t\t\tfor (int j = 0; j < rt.size(); j++) {\n\t\t\t\t\tint rt_j = rt.get(j);\n\t\t\t\t\tif (i + rt_j <= maxN) {\n\t\t\t\t\t\tary[0][i + rt_j] = min(ary[0][i + rt_j], ary[0][i] + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ary[1][i] < INF) {\n\t\t\t\tfor (int j = 0; j < rt_odd.size(); j++) {\n\t\t\t\t\tint rt_odd_j = rt_odd.get(j);\n\t\t\t\t\tif (i + rt_odd_j <= maxN) {\n\t\t\t\t\t\tary[1][i + rt_odd_j] = min(ary[1][i + rt_odd_j], ary[1][i] + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tout.println(ary[0][N] + \" \" + ary[1][N]);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tsolve();\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a < b ? b : a;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic int rt(int n) {\n\t\treturn n * (n + 1) * (n + 2) / 6;\n\t}\n\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte()) {\n\t\t\treturn buffer[ptr++];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn '!' <= c && c <= '~';\n\t}\n\n\tprivate void skipUnprintable() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tpublic boolean hasNext() {\n\t\tskipUnprintable();\n\t\treturn hasNextByte();\n\t}\n\n\tpublic int nextInt() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.InputStream;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * @author kumar1\n * \n */\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tInputStream in = System.in;\n\t\tScanner scanner = new Scanner(in);\n\t\tLinkedList<String> ans = new LinkedList<String>();\n\t\twhile (true) {\n\t\t\tint x = scanner.nextInt();\n\t\t\tif (x == 0)\n\t\t\t\tbreak;\n\t\t\t// x以下の正四面体数をすべて求める\n\t\t\tLinkedList<Integer> tetras = new LinkedList<Integer>();\n\t\t\tfor (int n = 1;; n++) {\n\t\t\t\tint nt = n * (n + 1) * (n + 2) / 6;\n\t\t\t\tif (nt > x)\n\t\t\t\t\tbreak;\n\t\t\t\ttetras.add(nt);\n\t\t\t}\n\t\t\t// x以下の奇数な正四面体数をすべて求める\n\t\t\tLinkedList<Integer> oddtetras = new LinkedList<Integer>();\n\t\t\tfor (int tetra : tetras) {\n\t\t\t\tif(tetra % 2 == 1)\n\t\t\t\t\toddtetras.add(tetra);\n\t\t\t}\n\t\t\t// BFSでとく\n\t\t\tint ansa = bfs(tetras, x);\n\t\t\tint ansb = bfs(oddtetras, x);\n\t\t\tans.add(ansa + \" \" + ansb);\n\t\t}\n\t\tscanner.close();\n\t\tfor(String a : ans) {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t}\n\n\t/**\n\t * @param tetras\n\t * @return\n\t */\n\tprivate static int bfs(LinkedList<Integer> tetras, int o) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tMap<Integer, Integer> map = new ConcurrentHashMap<Integer, Integer>();\n\t\tfor(int tetra : tetras) {\n\t\t\tmap.put(tetra, 1);\n\t\t\tif(tetra == o)\n\t\t\t\treturn 1;\n\t\t}\n\t\twhile(true) {\n\t\t\tfor(Entry<Integer, Integer> e : map.entrySet()) {\n\t\t\t\t//System.out.println(e.getKey());\n\t\t\t\tfor(int tetra : tetras) {\n\t\t\t\t\tint sum = e.getKey() + tetra;\n\t\t\t\t\tif(map.containsKey(sum) && sum <= map.get(sum))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif(sum == o)\n\t\t\t\t\t\treturn e.getValue() + 1;\n\t\t\t\t\tmap.put(sum, e.getValue() + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return 0;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] tri = new int[200];\n\t\tfor (int i = 0; i < tri.length; i++)\n\t\t\ttri[i] = i * (i + 1) * (i + 2) / 6;\n\t\tint[] answer = new int[1000001];\n\t\tint[] answer_odd = new int[1000001];\n\t\tanswer[0] = 0;\n\t\tanswer_odd[0] = 0;\n\t\tfor (int i = 1; i < answer.length; i++) {\n\t\t\tanswer[i] = i;\n\t\t\tanswer_odd[i] = i;\n\t\t\tfor (int j = 0; tri[j] <= i; j++) {\n\t\t\t\tanswer[i] = Math.min(answer[i], answer[i - tri[j]] + 1);\n\t\t\t\tif (tri[j] % 2 == 1)\n\t\t\t\t\tanswer_odd[i] = Math.min(answer_odd[i], answer_odd[i\n\t\t\t\t\t\t\t- tri[j]] + 1);\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tSystem.out.println(answer[n] + \" \" + answer_odd[n]);\n\t\t}\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int n;\n\tpublic static final int max = 1000000;\n\tpublic static BitSet bsall;\n\tpublic static BitSet bsodd;\n\tpublic static void main(String[] args){\n\t\tbsall = new BitSet(max);\n\t\tbsodd = new BitSet(max);\n\t\tfor(int i=1; i<=1000; i++){\n\t\t\tlong num = (long)i*(i+1)*(i+2)/6;\n\t\t\tif(num > max) break;\n\t\t\tbsall.set((int)num);\n\t\t\tif(num % 2 == 1){\n\t\t\t\tbsodd.set((int)num);\n\t\t\t}\n\t\t}\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\tresall = max;\n\t\t\tresodd = max;\n\t\t\tdfsall(max, 0, 0);\n\t\t\tdfsodd(max, 0, 0);\n\t\t\tSystem.out.println(resall+\" \"+resodd);\n\t\t}\n\t}\n\t\n\tpublic static int resodd;\n\tpublic static void dfsodd(int start, int sum, int depth){\n\t\tif(sum == n){\n\t\t\tresodd = Math.min(resodd, depth);\n\t\t\treturn;\n\t\t}\n\t\tif(sum > n) return;\n\t\tfor(int i=bsodd.previousSetBit(start); i!=-1; i=bsodd.previousSetBit(i-1)){\n\t\t\tdfsodd(i, sum+i, depth+1);\n\t\t}\n\t}\n\t\n\tpublic static int resall;\n\tpublic static void dfsall(int start, int sum, int depth){\n\t\tif(sum == n){\n\t\t\tresall = Math.min(resall, depth);\n\t\t\treturn;\n\t\t}\n\t\tif(depth >= 5 || sum > n) return;\n\t\tfor(int i=bsall.previousSetBit(start)\n\t\t\t\t; i!=-1 && i*(5-depth)+sum>=n\n\t\t\t\t; i=bsall.previousSetBit(i-1)){\n\t\t\tdfsall(i, sum+i, depth+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int n;\n\tpublic static final int max = 1000000;\n\tpublic static ArrayList<Integer> all;\n\tpublic static ArrayList<Integer> odd;\n\tpublic static void main(String[] args){\n\t\tall = new ArrayList<Integer>();\n\t\todd = new ArrayList<Integer>();\n\t\tfor(int i=1; i<=1000; i++){\n\t\t\tlong num = (long)i*(i+1)*(i+2)/6;\n\t\t\tif(num > max) break;\n\t\t\tall.add((int)num);\n\t\t\tif(num % 2 == 1){\n\t\t\t\todd.add((int)num);\n\t\t\t}\n\t\t}\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n == 0) return;\n\t\t\tresall = max;\n\t\t\tresodd = max;\n\t\t\tdfsall(all.size()-1, 0, 0);\n\t\t\tdfsodd(odd.size()-1, 0, 0);\n\t\t\tSystem.out.println(resall+\" \"+resodd);\n\t\t}\n\t}\n\t\n\tpublic static int resodd;\n\tpublic static void dfsodd(int start, int sum, int depth){\n\t\tif(sum == n){\n\t\t\tresodd = Math.min(resodd, depth);\n\t\t\treturn;\n\t\t}\n\t\tif(sum > n) return;\n\t\tfor(int i=start; i>=0; i--){\n\t\t\tdfsodd(i, sum+odd.get(i), depth+1);\n\t\t}\n\t}\n\t\n\tpublic static int resall;\n\tpublic static void dfsall(int start, int sum, int depth){\n\t\tif(sum == n){\n\t\t\tresall = Math.min(resall, depth);\n\t\t\treturn;\n\t\t}\n\t\tif(depth >= 5 || sum > n) return;\n\t\tfor(int i=start; i>=0; i--){\n\t\t\tdfsall(i, sum+all.get(i), depth+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\t\n\t\twhile(true){\n\t\t\tint n=Integer.parseInt(in.next());\n\t\t\tif(n==0)break;\n\n\t\t\tList<Integer> A=new ArrayList<>(), B=new ArrayList<>();\n\n\t\t\tint j=1,s=1;\n\t\t\twhile(s<=n){\n\t\t\t\tA.add(s);\n\t\t\t\tif(s%2==1)B.add(s);\n\t\t\t\tj++;\n\t\t\t\ts=j*(j+1)*(j+2)/6;\n\t\t\t}\n\n\t\t\tint DP[]=new int[n+1],INF=2000000000;\n\t\t\tfor(int i=1;i<=n;i++)DP[i]=INF;\n\n\t\t\tfor(int i=0;i<A.size();i++){\n\t\t\t\tint t=A.get(i);\n\t\t\t\tfor(int k=0;k+t<=n;k++){\n\t\t\t\t\tDP[k+t]=Math.min(DP[k]+1, DP[k+t]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.print(DP[n]+\" \");\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++)DP[i]=INF;\n\t\t\t\n\t\t\tfor(int i=0;i<B.size();i++){\n\t\t\t\tint t=B.get(i);\n\t\t\t\tfor(int k=0;k+t<=n;k++){\n\t\t\t\t\tDP[k+t]=Math.min(DP[k+t], DP[k]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(DP[n]);\n\t\t\t\n\t\t}\n\t\t\n\t\tout.flush();\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Pollock's conjecture - Time Limit Exceeded\n */\npublic class Main {\n\n\tstatic final int MAX = 1000000;\n\tstatic final int MAX3 = 1500;\n\tstatic final int MAX4 = 200;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tint[] R3 = new int[MAX3];\n\t\tint[] R4 = new int[MAX4];\n\n\t\tR3[1] = 1;\n\t\tfor (int i = 2; i < R3.length; i++) {\n\t\t\tR3[i] = R3[i - 1] + i;\n\t\t}\n\n\t\tR4[1] = 1;\n\t\tfor (int i = 2; i < R4.length; i++) {\n\t\t\tR4[i] = R4[i - 1] + R3[i];\n\t\t}\n\n\t\tint[][] dp = new int[2][MAX];\n\t\tfor (int i = 1; i < dp[0].length; i++) dp[1][i] = dp[0][i] = i;\n\t\t//decided i < 4\n\t\tfor (int i = 4; i < dp[0].length; i++) {\n\t\t\tfor (int j = 2; j < R4.length; j++) {\n\t\t\t\tif (i - R4[j] >= 0) {\n\t\t\t\t\tdp[0][i] = Math.min(dp[0][i], dp[0][i - R4[j]] + 1);\n\t\t\t\t\tif (R4[j] % 2 != 0) {\n\t\t\t\t\t\tdp[1][i] = Math.min(dp[1][i], dp[1][i - R4[j]] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tSystem.out.println(dp[0][n] + \" \" + dp[1][n]);\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class Main{\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1167();\n\t}\n\t\n\tclass AOJ1167{\n\t\tAOJ1167(){\n\t\t\tsolve(1000000);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tSystem.out.println(dp[n]+\" \"+dp2[n]);\n\t\t\t}\n\t\t}\n\t\tfinal int INF=1<<29;\n\t\tint[] a,b;\n\t\tint[] dp,dp2;\n\t\tvoid solve(int n){\n\t\t\tfinal int MAX=1000000;\n\t\t\ta=new int[MAX+1];\n\t\t\tb=new int[MAX+1];\n\t\t\tfor(int i=1,j=1; true; ++i){\n\t\t\t\ta[i]=i*(i+1)*(i+2)/6;\n\t\t\t\tif(a[i]%2==1)\tb[j++]=a[i];\n\t\t\t\tif(a[i]>=MAX)\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdp=new int[n+1];\n\t\t\tfor(int i=0; i<=n; ++i)dp[i]=INF;\n\t\t\tdp[0]=0;\n\t\t\tfor(int i=1; a[i]<=n; ++i){\n\t\t\t\tfor(int j=0; j<=n; ++j){\n\t\t\t\t\tint tmp=j-a[i];\n\t\t\t\t\tif(tmp>=0){\n\t\t\t\t\t\tdp[j]=min(dp[j], dp[j-a[i]]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp2=new int[n+1];\n\t\t\tfor(int i=0; i<=n; ++i)dp2[i]=INF;\n\t\t\tdp2[0]=0;\n\t\t\tfor(int i=1; b[i]<=n; ++i){\n\t\t\t\tfor(int j=0; j<=n; ++j){\n\t\t\t\t\tint tmp=j-b[i];\n\t\t\t\t\tif(tmp>=0){\n\t\t\t\t\t\tdp2[j]=min(dp2[j], dp2[j-b[i]]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] map;\n\tstatic int[][] directions8 = { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 },\n\t\t\t{ 1, 1 } };\n\tstatic int[][] directions4 = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\tstatic int ans;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint[] porockNums = new int[200];\n\t\tint[] oddPorockNums = new int[200];\n\t\tint porockedNum[] = new int[1000000];\n\t\tint oddPorockedNum[] = new int[1000000];\n\n\t\tint tmp = 0;\n\t\tint arrayIdx = 0;\n\t\tint oddArrayIdx = 0;\n\t\tfor (int i = 1; true; i++) {\n\t\t\ttmp = i * (i + 1) * (i + 2) / 6;\n\t\t\tporockNums[arrayIdx] = tmp;\n\t\t\tif (tmp >= 1000000) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tporockedNum[tmp] = 1;\n\t\t\tif (tmp % 2 == 1) {\n\t\t\t\toddPorockNums[oddArrayIdx] = tmp;\n\t\t\t\toddPorockedNum[tmp] = 1;\n\t\t\t\toddArrayIdx++;\n\t\t\t}\n\t\t\tarrayIdx++;\n\t\t}\n\n\t\twhile (true) {\n\n\t\t\tint n = sc.nextInt();\n\t\t\tans = 0;\n\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint addedTimes = 1;\n\t\t\twhile (porockedNum[n] == 0) {\n\n\t\t\t\tfor (int i = 1; i < 1000000; i++) {\n\t\t\t\t\tif (porockedNum[i] == addedTimes) {\n\t\t\t\t\t\tfor (int p : porockNums) {\n\t\t\t\t\t\t\tif (i + p > n) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (porockedNum[i + p] != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tporockedNum[i + p] = addedTimes + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddedTimes++;\n\t\t\t}\n\t\t\taddedTimes = 1;\n\t\t\twhile (oddPorockedNum[n] == 0) {\n\t\t\t\tfor (int i = 1; i < 1000000; i++) {\n\t\t\t\t\tif (oddPorockedNum[i] == addedTimes) {\n\t\t\t\t\t\tfor (int p : oddPorockNums) {\n\t\t\t\t\t\t\tif (i + p > n) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (oddPorockedNum[i + p] != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toddPorockedNum[i + p] = addedTimes + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddedTimes++;\n\t\t\t}\n\t\t\tSystem.out.println(porockedNum[n] + \" \" + oddPorockedNum[n]);\n\t\t}\n\t}\n\n\t// BFS用に二つの配列を足し算する\n\tstatic int[] addArrayElms(int[] a, int[] b) {\n\t\tint[] c = new int[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t\treturn c;\n\t}\n\n\t// //二分探索\n\t// k <= num となる最小の配列要素kのインデックスを返す\n\tstatic private int binarySearch(int num, int[] orderedArray) {\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedArray.length;\n\t\tint mid;\n\n\t\twhile (upperBorder - lowerBorder > 1) {\n\t\t\tmid = (upperBorder + lowerBorder) / 2;\n\t\t\tif (orderedArray[mid] <= num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t} else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t// //二分探索\n\t// k <= num となる最小の配列要素kのインデックスを返す\n\tstatic private int binarySearch(long num, long[] orderedArray) {\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedArray.length;\n\t\tint mid;\n\n\t\twhile (upperBorder - lowerBorder > 1) {\n\t\t\tmid = (upperBorder + lowerBorder) / 2;\n\t\t\tif (orderedArray[mid] <= num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t} else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t// 二分探索\n\t// k <= num となる最小のList要素kのインデックスを返す\n\tstatic private int binarySearch(long num, ArrayList<Long> orderedList) {\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedList.size();\n\t\tint mid;\n\n\t\twhile (upperBorder - lowerBorder > 1) {\n\t\t\tmid = (upperBorder + lowerBorder) / 2;\n\t\t\tif (orderedList.get(mid) <= num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t} else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t// aとbの最小公倍数を求める\n\tpublic static int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\tint ns[] = new int[1000], os[] = new int[1000];\n\t\tint dp1[] = new int [1000001], dp2[] = new int[1000001];\n\t\tint pos = 0;\n\t\tfor(int i=1; ;i++){\n\t\t\tns[i] = i*(i+1)*(i+2)/6;\n\t\t\tif(ns[i]%2 == 1){\n\t\t\t\tos[pos++] = ns[i];\n\t\t\t}\n\t\t\tif(ns[i] > 3000000) break;\n\t\t}\n\t\tfor(int i=1; i<1000001;i++) dp1[i] = dp2[i] = 1<<29;\n\t\tfor(int i=1; i<1000001;i++){\n\t\t\tfor(int j=0; j<1000; j++){\n\t\t\t\tif(ns[j] > i) break;\n\t\t\t\tdp1[i] = Math.min(dp1[i], dp1[i-ns[j]]+1);\n\t\t\t}\n\t\t\tfor(int j=0; j<1000; j++){\n\t\t\t\tif(os[j] > i) break;\n\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i-os[j]]+1);\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0) return ;\n\t\t\tSystem.out.printf(\"%d %d\\n\", dp1[n], dp2[n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n//\tstatic int[] min = new int[1000000 + 1];\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t\n\t\tint[][] min = new int[2][1000000 + 1];\n\t\tArrays.fill(min[0], 20000);\n\t\tArrays.fill(min[1], 20000);\n\t\tmin[0][1] = 1;\n\t\tmin[1][1] = 1;\n\t\tfor(int i = 2; i <= 1000000; i++){\n\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\tint tmp = j * (j + 1) * (j + 2) / 6;\n\t\t\t\tif(i == tmp){\n\t\t\t\t\tmin[0][i] = 1;\n\t\t\t\t}else if(i > tmp){\n\t\t\t\t\tmin[0][i] = Math.min(min[0][i], min[0][i - tmp] + 1);\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i <= 1000000; i++){\n\t\t\tfor(int j = 1; j < i; j += 2){\n\t\t\t\tint tmp = j * (j + 1) * (j + 2) / 6;\n\t\t\t\tif(tmp % 2 != 0){\n\t\t\t\t\tif(i == tmp){\n\t\t\t\t\t\tmin[1][i] = 1;\n\t\t\t\t\t}else if(i > tmp){\n\t\t\t\t\t\tmin[1][i] = Math.min(min[1][i], min[1][i - tmp] + 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(n != 0){\n/*\n\t\t\tint[] test = new int[n + 1];\n\t\t\tArrays.fill(test, 20000);\n\t\t\ttest[1] = 1;\n\t\t\tfor(int i = 2; i <= n; i++){\n\t\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\t\tint tmp = j * (j + 1) * (j + 2) / 6;\n\t\t\t\t\tif(i == tmp){\n\t\t\t\t\t\ttest[i] = 1;\n\t\t\t\t\t}else if(i > tmp){\n\t\t\t\t\t\ttest[i] = Math.min(test[i], test[i - tmp] + 1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.print(test[n]);\n\t\t\tArrays.fill(test, 20000);\n\t\t\ttest[1] = 1;\n\t\t\tfor(int i = 2; i <= n; i++){\n\t\t\t\tfor(int j = 1; j < i; j += 2){\n\t\t\t\t\tint tmp = j * (j + 1) * (j + 2) / 6;\n\t\t\t\t\tif(tmp % 2 != 0){\n\t\t\t\t\t\tif(i == tmp){\n\t\t\t\t\t\t\ttest[i] = 1;\n\t\t\t\t\t\t}else if(i > tmp){\n\t\t\t\t\t\t\ttest[i] = Math.min(test[i], test[i - tmp] + 1);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\" \" + test[n]);*/\n\t\t\tSystem.out.println(min[0][n] + \" \" + min[1][n]);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n/*\tstatic int func(int n){\n\t\tif(min[n] > 0){\n\t\t\treturn min[n];\n\t\t}\n\t\tint res = 20000;\n\t\tint tmp = n;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\ttmp = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(n == tmp){\n\t\t\t\tmin[n] = 1;\n\t\t\t\treturn min[n];\n\t\t\t}else if(n > tmp){\n\t\t\t\tres = Math.min(res, func(n - tmp) + 1);\n\t\t\t}else if(n < tmp){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmin[n] = res;\n\t\treturn res;\n\t}\n\tstatic int oddfunc(int n){\n\t\tif(min[n] > 0){\n\t\t\treturn min[n];\n\t\t}\n\t\tint res = 20000;\n\t\tint tmp = n;\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\ttmp = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(tmp % 2 != 0){\n\t\t\t\tif(n == tmp){\n\t\t\t\t\tmin[n] = 1;\n\t\t\t\t\treturn min[n];\n\t\t\t\t}else if(n > tmp){\n\t\t\t\t\tres = Math.min(res, oddfunc(n - tmp) + 1);\n\t\t\t\t}else if(n < tmp){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin[n] = res;\n\t\treturn res;\n\t}*/\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tint[] p = new int[181];\n\tint[] oddp = new int[46];\n\t\n\tint[] memo = new int[1000001];\n\tint[] oddmemo = new int[1000001];\n\t\n\tint calc(int n, int index) {\n\t\tif (memo[n] == 0) {\n\t\t\tif (index == 0) memo[n] = n;\n\t\t\telse {\n\t\t\t\twhile (n < p[index]) index--;\n\t\t\t\tif (n == p[index]) memo[n] = 1;\n\t\t\t\telse {\n\t\t\t\t\tint min = 1000000;\n\t\t\t\t\tfor (int i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (min >= n/p[i])\n\t\t\t\t\t\t\tmin = Math.min(min, calc(n-p[i], i));\n\t\t\t\t\t}\n\t\t\t\t\tmemo[n] = min+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn memo[n];\n\t}\n\t\n\tint calcodd(int n, int index) {\n\t\tif (oddmemo[n] == 0) {\n\t\t\tif (index == 0) oddmemo[n] = n;\n\t\t\telse {\n\t\t\t\twhile (n < oddp[index]) index--;\n\t\t\t\tif (n == oddp[index]) oddmemo[n] = 1;\n\t\t\t\telse {\n\t\t\t\t\tint min = 1000000;\n\t\t\t\t\tfor (int i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (min >= n/oddp[i])\n\t\t\t\t\t\t\tmin = Math.min(min, calcodd(n-oddp[i], i));\n\t\t\t\t\t}\n\t\t\t\t\toddmemo[n] = min+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn oddmemo[n];\n\t}\n\t\n\tvoid run() {\n\t\tint n;\n\t\n\t\t\n\t\tfor (int i = 0; i < 181; i++) {\n\t\t\tp[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t\tif (i % 4 == 0) {\n\t\t\t\toddp[i/4] = (i+1)*(i+2)*(i+3)/6;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\n\t\t\tout.printf(\"%d %d\\n\", calc(n, 180), calcodd(n, 45));\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "/*\nicpc??´?????????\n2010??´ ?????? C??????\n*/\nimport java.io.*;\n\nclass HOME_C {\n\tstatic int map[];\n\tstatic int mapb[];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\trun();\n\t\t} catch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\tprivate static void run() throws IOException{\n\t\tfinal int MAX = 1000000;\n\t\tint n;\n\t\tint instant;\n\t\tmap = new int[MAX+1];\n\t\tmapb = new int[MAX+1];\n\t\t\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tfor(int i=1;i<=MAX;i++) {\n\t\t\t//if(i%100000==0)System.out.print(\".\");\n\t\t\tmap[i] = f(i);\n\t\t\t//mapb[i] = fb(i);\n\t\t}\n\t\t//System.out.println(\"\");\n\t\t\n\t\twhile(true) {\n\t\t\tn = Integer.parseInt(in.readLine()); //???????????£?????????\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\t//System.out.println(map[n] + \" \" + mapb[n]);\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tprivate static int f(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > map[n-tk]) {\n\t\t\t\t\tmin = map[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 1+min;\n\t}\n\t\n\tprivate static int fb(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0 || tk%2==0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > mapb[n-tk]) {\n\t\t\t\t\tmin = mapb[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\treturn 1+min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tfinal int MAX = 1000 * 1000;\n\tfinal int INF = 1 << 29;\n\tint dp[];\n\tint dp2[];\n\n\tvoid init() {\n\t\tdp = new int[MAX + 1];\n\t\tdp2 = new int[MAX + 1];\n\t\tArrays.fill(dp, INF);\n\t\tArrays.fill(dp2, INF);\n\t\t// dp[i][j] i番目までのtetraの和でjを作る時の最小個数\n\t\t// dp[i+1][j] = Math.min(dp[i][j],dp[i][j-tetra[i+1]]+1);\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\tfor (int i = 1;; i++) {\n\t\t\tint tetra = i * (i + 1) * (i + 2) / 6;\n\t\t\tif (tetra > MAX)\n\t\t\t\tbreak;\n\t\t\tfor (int j = 1; j <= MAX; j++) {\n\t\t\t\tif (j - tetra < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[j] = Math.min(dp[j], dp[j - tetra] + 1);\n\t\t\t\tif (tetra % 2 != 0) {\n\t\t\t\t\tdp2[j] = Math.min(dp2[j], dp2[j - tetra] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tinit();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tSystem.out.println(dp[n] + \" \" + dp2[n]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        int max = 1000000;\n        int tList[] = new int[181];\n        for (int i = 1; i < 181; i++) {\n            tList[i - 1] = i * (i + 1) * (i + 2) / 6;\n        }\n        int dp[] = new int[max + 1];\n        int dpOdd[] = new int[max + 1];\n        dp[0] = 0;\n        dpOdd[0] = 0;\n        for (int i = 1; i <= max; i++) {\n            int dpmin = Integer.MAX_VALUE;\n            int dpOddmin = Integer.MAX_VALUE;\n            for (int j : tList) {\n                if (j > i)\n                    break;\n                if (dp[i - j] < dpmin) {\n                    dpmin = dp[i - j];\n                }\n                if (j % 2 != 0 && dpOdd[i - j] < dpOddmin) {\n                    dpOddmin = dpOdd[i - j];\n                }\n            }\n            dp[i] = dpmin + 1;\n            dpOdd[i] = dpOddmin + 1;\n        }\n        Scanner scan = new Scanner(System.in);\n        while (true) {\n            String str = scan.nextLine();\n            int input = Integer.parseInt(str);\n            if (input == 0)\n                break;\n            System.out.printf(\"%d %d%n\", dp[input], dpOdd[input]);\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n\n    void solve(){        \n        int[] pol = new int[180];\n        for(int i = 1; i <= 180; i++){\n            pol[i - 1] = i * (i + 1) * (i + 2) / 6;\n        }\n        int[] odd = new int[45];\n        int index = 0;\n        for(int i = 1; i <= 180; i++){\n            int result = i * (i + 1) * (i + 2) / 6;\n            if(result % 2 == 1){\n                odd[index] = result;\n                index++;\n            }\n        }\n        \n        int N = ni();\n        List<Integer> ans = new ArrayList<>();\n        List<Integer> oddAns = new ArrayList<>();\n        while(N != 0){\n            int[] dp = new int[N + 1];\n            fill(dp, INF / 2);\n            dp[0] = 0;\n\n            for(int i = 0; i <= N; i++){\n                for(int j = 0; j < 180; j++){\n                    if(pol[j] > i) break;\n                    dp[i] = min(dp[i], dp[i - pol[j]] + 1);\n                }\n            }\n\n            ans.add(dp[N]);\n            \n            fill(dp, INF / 2);\n            dp[0] = 0;\n            for(int i = 0; i <= N; i++){\n                for(int j = 0; j < 45; j++){\n                    if(odd[j] > i) break;\n                    dp[i] = min(dp[i], dp[i - odd[j]] + 1);\n                }\n            }\n\n            oddAns.add(dp[N]);\n            N = ni();\n        }\n\n        for(int i = 0; i < ans.size(); i++){\n            System.out.println(ans.get(i) + \" \" + oddAns.get(i));\n        }\n\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n\n    private FastScanner scan = new FastScanner();\n    //private final int MOD = 1_000_000_007;\n    private final int MOD = 998244353;\n    private final int INF = 2147483647;\n    private final long LINF = 9223372036854775807L;\n    private long[] fac;\n    private long[] finv;\n    private long[] inv;\n\n    // Scanner\n    int ni(){ return scan.nextInt();}\n    int[] ni(int n){int[] a = new int[n]; for(int i = 0; i < n; i++){a[i] = ni();} return a;}\n    int[][] ni(int y, int x){int[][] a = new int[y][x];\n        for(int i = 0; i < y; i++){for(int j = 0; j < x; j++){a[i][j] = ni();}} return a;}\n    long nl(){return scan.nextLong();}\n    long[] nl(int n){long[] a = new long[n]; for(int i = 0; i < n; i++){a[i] = nl();} return a;}\n    long[][] nl(int y, int x){long[][] a = new long[y][x];\n        for(int i = 0; i < y; i++){for(int j = 0; j < x; j++){a[i][j] = nl();}} return a;}\n    String ns(){return scan.next();}\n    String[] ns(int n){String[] a = new String[n]; for(int i = 0; i < n; i++){a[i] = ns();} return a;}\n    String[][] ns(int y, int x){String[][] a = new String[y][x];\n        for(int i = 0; i < y; i++){for(int j = 0; j < x; j++){a[i][j] = ns();}} return a;}\n\n    // Mathematics\n    int max(int a, int b){return Math.max(a, b);}\n    long max(long a, long b){return Math.max(a, b);}\n    double max(double a, double b){return Math.max(a, b);}\n    int max(int[] a){int max = a[0]; for(int value:a){max = max(max,value);} return max;}\n    long max(long[] a){long max = a[0]; for(long value:a){max = max(max,value);} return max;}\n    double max(double[] a){double max = a[0]; for(double value:a){max = max(max,value);} return max;}\n    int min(int a, int b){return Math.min(a, b);}\n    long min(long a, long b){return Math.min(a, b);}\n    double min(double a, double b){return Math.min(a, b);}\n    int min(int[] a){int min = a[0]; for(int value:a){min = min(min,value);} return min;}\n    long min(long[] a){long min = a[0]; for(long value:a){min = min(min,value);} return min;}\n    double min(double[] a){double min = a[0]; for(double value:a){min = min(min,value);} return min;}\n    long sum(int[] a){long sum = 0; for(int value:a){sum += value;} return sum;}\n    long sum(long[] a){long sum = 0; for(long value:a){sum += value;} return sum;}\n    double sum(double[] a){double sum = 0; for(double value:a){sum += value;} return sum;}\n    int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}\n    long gcd(long a, long b){return b == 0 ? a : gcd(b, a % b);}\n    int lcm(int a, int b){return a / gcd(a, b) * b;}\n    long lcm(long a, long b){return a / gcd(a, b) * b;}\n    long fact(int n){ if(n == 0){ return 1; } long a = n; for(long i = n - 1; i >= 2; i--){ a = a % MOD * i; } return a; }\n    long fact(long n){ if(n == 0){ return 1; } long a = n; for(long i = n - 1; i >= 2; i--){ a = a % MOD * i; } return a; }\n    // nPr(int)\n    long npr(int n, int r){\n        long a = 1;\n        for(int i = n; i > n - r; i--){\n            a *= i;\n        }\n        return a;\n    }\n    // nPr(long)\n    long npr(long n, long r){\n        long a = 1;\n        for(long i = n; i > n - r; i--){\n            a *= i;\n        }\n        return a;\n    }\n    // 素数判定(int)\n    boolean checkPrime(int n){\n        for(int i = 2; i * i <= n; i++){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n    // 素数判定(long)\n    boolean checkPrime(long n){\n        for(long i = 2; i * i <= n; i++){\n            if(n % i == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n    // mod pにおける累乗 a^n\n    long modpow(long a, long n, long p){\n        long res = 1;\n        while(n > 0){\n            if((n & 1) == 1){\n                res = res * a % p;\n            }\n            a = a * a % p;\n            n = n >> 1;\n        }\n        return res;\n    }\n    // mod pにおけるaの逆元a^-1\n    long modinv(long a, long p){\n        return modpow(a, p - 2, p);\n    }\n    // fac,finv,invの初期化\n    void comInit(int max){\n        fac = new long[max];\n        finv = new long[max];\n        inv = new long[max];\n        fac[0] = fac[1] = 1;\n        finv[0] = finv[1] = 1;\n        inv[1] = 1;\n        for(int i = 2; i < max; i++){\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n    // 二項係数nCr\n    long com(int n, int r){\n        if(n < r || (n < 0 || r < 0)){\n            return 0;\n        }\n        return fac[n] * (finv[r] * finv[n - r] % MOD) % MOD;\n    }\n    // 二項係数nCr（nが10^9など巨大なとき用）\n    long ncr(long n, long k){\n        long a = 1;\n        long b = 1;\n        for(int i = 1; i <= k; i++){\n            a = a * (n + 1 - i) % MOD;\n            b = b * i % MOD;\n        }\n        \n        return modinv(b, MOD) * a % MOD;\n    }\n    // 二次元上の二点間の距離\n    double distance(double x1, double y1, double x2, double y2){\n        double dist = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n        return dist;\n    }\n    // 三次元上の二点間の距離\n    double distance(double x1, double y1, double z1, double x2, double y2, double z2){\n        double dist = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));\n        return dist;\n    }\n\n\n    // Array\n    void sort(int[] a){ Arrays.sort(a);}\n    void sort(long[] a){ Arrays.sort(a);}\n    void sort(double[] a){ Arrays.sort(a);}\n    void sort(String[] a){ Arrays.sort(a);}\n    int[] reverse(int[] a){\n        int[] reversed = new int[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    long[] reverse(long[] a){\n        long[] reversed = new long[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    double[] reverse(double[] a){\n        double[] reversed = new double[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    char[] reverse(char[] a){\n        char[] reversed = new char[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    String[] reverse(String[] a){\n        String[] reversed = new String[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    boolean[] reverse(boolean[] a){\n        boolean[] reversed = new boolean[a.length];\n        for(int i = 0; i < a.length; i++){\n            reversed[a.length - i - 1] = a[i];\n        }\n        return reversed;\n    }\n    void fill(int[] array, int x) { Arrays.fill(array, x); }\n    void fill(long[] array, long x) { Arrays.fill(array, x); }\n    void fill(double[] array, double x) { Arrays.fill(array, x); }\n    void fill(boolean[] array, boolean x) { Arrays.fill(array, x); }\n    void fill(int[][] array, int x) { for(int a[] : array) { fill(a, x); } }\n    void fill(long[][] array, long x) { for(long a[] : array) { fill(a, x); } }\n    void fill(double[][] array, double x) { for(double a[] : array) { fill(a, x); } }\n    void fill(boolean[][] array, boolean x) { for(boolean a[] : array) { fill(a, x); } }\n    void fill(int[][][] array, int x) { for(int[][] ary : array) { for(int[] a : ary){ fill(a, x); } } }\n    void fill(long[][][] array, long x) { for(long[][] ary : array) { for(long[] a : ary){ fill(a, x); } } }\n\n    // Algorithm\n    // 深さ優先探索\n    /*\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        List<Integer> list;\n    */\n    int minCost = INF;\n    void dfs(HashMap<Integer, List<Integer>> graph, int v, boolean[] seen, long[] x){\n        seen[v] = true;\n        if(!graph.containsKey(v) || graph.get(v).size() == 0) return;\n        List<Integer> todo = graph.get(v);\n        for(int next : todo){\n            if(seen[next]) continue;\n            x[next] += x[v];\n            dfs(graph, next, seen, x);\n        }\n    }\n    // 幅優先探索\n    /*\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\n        List<Integer> list;\n    */\n    void bfs(HashMap<Integer, List<Integer>> graph, int v, int[] dist){\n        Queue<Integer> que = new ArrayDeque<>();\n        que.add(v);\n\n        while(que.size() > 0){\n            v = que.poll();\n            if(!graph.containsKey(v)) continue;\n            for(int next : graph.get(v)){\n                if(dist[next] != -1) continue;\n                dist[next] = dist[v] + 1;\n                que.add(next);\n            }\n        }\n    }\n    // ダイクストラ法\n    Node[] dijkstra(HashMap<Integer, List<Integer>> graph, int size, int v, boolean[] flag, int[][] cost, int[] temp, int X){\n        Queue<Node> queue = new PriorityQueue<>(new MyComparator());\n        Node[] nodes = new Node[size];\n        int[] hot = new int[size]; // 最後に暑すぎる部屋を出た時刻\n        int[] cold = new int[size]; // 最後に寒すぎる部屋を出た時刻\n        for(int i = 0; i < size; i++){\n            nodes[i] = new Node(i, INF, -1);            // id, dist, pastを指定して初期化\n        }\n        /* for(int key : graph.keySet()){\n            nodes[key] = new Node(key, INF, -1);    // id, dist, pastを指定して初期化\n        } */\n       \n        nodes[v].dist = 0;  // 始点のコストを0に\n        try{\n            queue.add(nodes[v].clone());\n        } catch(CloneNotSupportedException e){\n            e.printStackTrace();\n        }\n\n        while(queue.size() > 0){\n            Node now = queue.poll();        // 未確定の中で最もコストの低いノードを取り出す\n            //flag[now.id] = true;                // 確定\n            if(temp[now.id] != 1) flag[now.id] = true;\n            if(!graph.containsKey(now.id)) continue;\n            for(int next : graph.get(now.id)){      // 辺で繋がっているノードを順にチェック\n                if(flag[next] || nodes[next].dist < nodes[now.id].dist + cost[now.id][next]) continue;\n                if(Math.abs(temp[now.id] - temp[next]) == 2 && cost[now.id][next] < X) continue;//\n                int lastTime = 0;   //\n                if(temp[next] == 0){\n                    lastTime = hot[now.id];\n                } else if(temp[next] == 2){\n                    lastTime = cold[now.id];\n                }\n                if(cost[now.id][next] < X - lastTime){ //\n                    int min = INF;\n                    for(int next2 : graph.get(now.id)){\n                        if(next2 == next || Math.abs(temp[next2] - temp[next]) == 2) continue;\n                        min = min(min, cost[now.id][next2]);\n                    }\n                    if(min == INF) continue;\n                    min *= 2;\n                    while(nodes[now.id].dist + cost[now.id][next] + min < X + lastTime){\n                        min += min;\n                    }\n                    if(nodes[next].dist < nodes[now.id].dist + cost[now.id][next] + min) continue;\n                    nodes[next].dist = nodes[now.id].dist + cost[now.id][next] + min;     // distを更新\n                    nodes[next].past = now.id;                                                    // pastを現在のノードに\n                    hot[next] = hot[now.id] + cost[now.id][next] + min;\n                    cold[next] = cold[now.id] + cost[now.id][next] + min;\n                    if(temp[next] == 2) hot[next] = 0;\n                    if(temp[next] == 0) cold[next] = 0;\n                    try{\n                        queue.add(nodes[next].clone());\n                    } catch (CloneNotSupportedException e){\n                        e.printStackTrace();\n                    }\n                    continue;\n                }//\n                nodes[next].dist = nodes[now.id].dist + cost[now.id][next];     // distを更新\n                nodes[next].past = now.id;                                                    // pastを現在のノードに\n                hot[next] = hot[now.id] + cost[now.id][next]; //\n                cold[next] = cold[now.id] + cost[now.id][next];\n                if(temp[next] == 2) hot[next] = 0;\n                if(temp[next] == 0) cold[next] = 0; //\n                try{\n                    queue.add(nodes[next].clone());\n                } catch (CloneNotSupportedException e){\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        return nodes;\n    }\n    \n    // ソート済みint型配列でkey以上の値の最小indexを返す\n    int lowerBound(int[] a, int key){\n        int ng = -1;\n        int ok = a.length;\n        while(Math.abs(ok - ng) > 1){\n            int mid = (ok + ng) / 2; \n            if(a[mid] >= key){\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n        return ok;\n    }\n    // ソート済みlong型配列でkey以上の値の最小indexを返す\n    int lowerBound(long[] a, long key){\n        int ng = -1;\n        int ok = a.length;\n        while(Math.abs(ok - ng) > 1){\n            int mid = (ok + ng) / 2; \n            if(a[mid] >= key){\n                ok = mid;\n            } else {\n                ng = mid;\n            }\n        }\n        return ok;\n    }\n    // 文字列sとtの最長共通部分列の長さを返す\n    int lcs(String s , String t){\n        int[][] dp = new int[s.length() + 1][t.length() + 1];\n\n        for(int i = 0; i < s.length(); i++){\n            for(int j = 0; j < t.length(); j++){\n                if(s.charAt(i) == t.charAt(j)){\n                    dp[i + 1][j + 1] = max(dp[i][j] + 1, dp[i + 1][j + 1]);\n                }\n                dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i + 1][j]);\n                dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j + 1]);\n            }\n        }\n\n        return dp[s.length()][t.length()];\n    }\n\n}\n// ダイクストラ法におけるノード\nclass Node implements Cloneable{\n    int id;             // ノード番号\n    int dist;           // 最低必要コスト\n    int past;           // 直前の頂点\n\n    Node(int id, int dist, int past){\n        this.id = id;\n        this.dist = dist;\n        this.past = past;\n    }\n    @Override\n    protected Node clone() throws CloneNotSupportedException{\n        Node node = (Node)super.clone();\n        return node;\n    }\n    public String toString(){\n        return \"[\" + id + \", \" + dist + \" ,\" + past + \"]\";\n    }\n}\n// ダイクストラ法における重み比較のComparator\nclass MyComparator implements Comparator<Node>{\n    @Override\n    public int compare(Node n1, Node n2){\n        int dist1 = n1.dist;\n        int dist2 = n2.dist;\n        if(dist1 < dist2){\n            return -1;\n        } else if(dist1 > dist2){\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n// 辺の情報を持つクラス\nclass Edge implements Cloneable{\n    int from;       // どの頂点から\n    int to;          //  どの頂点へ\n    double cost;       // 辺の重み\n\n    Edge(int from, int to, double cost){\n        this.from = from;\n        this.to = to;\n        this.cost = cost;\n    }\n    @Override\n    protected Edge clone() throws CloneNotSupportedException{\n        Edge edge = (Edge)super.clone();\n        return edge;\n    }\n    public String toString(){\n        return \"[\" + from + \" to \" + to + \",\" + cost + \"]\";\n    }\n}\n// 辺の重み比較のComparator\nclass EdgeComparator implements Comparator<Edge>{\n    @Override\n    public int compare(Edge e1, Edge e2){\n        double cost1 = e1.cost;\n        double cost2 = e2.cost;\n        if(cost1 < cost2){\n            return -1;\n        } else if(cost1 > cost2){\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n// Union-Find\nclass UnionFind{\n    int[] par;\n    int[] size;\n    UnionFind(int N){\n        par = new int[N];\n        size = new int[N];\n        for(int i = 0; i < N; i++){\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    void init(int N){\n        for(int i = 0; i < N; i++){\n            par[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int root(int x){\n        if(par[x] == x){\n            return x;\n        } else {\n            return par[x] = root(par[x]);\n        }\n    }\n\n    boolean same(int x, int y){\n        return root(x) == root(y);\n    }\n\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(size[x] < size[y]){\n            int tmp = x;\n            x = y;\n            y = tmp;\n        }\n        size[x] += size[y];\n        par[y] = x;\n    }\n\n    int size(int x){\n        return size[root(x)];\n    }\n\n}\n\n// 順列を管理する\nclass Permutation {\n    private int number;\n    private int listSize;\n    private int searched;\n    private int nextIndex;\n    private int[][] permList;\n\n    Permutation(int num) {\n        this.number = num;\n        this.listSize  = this.fact(this.number);\n        this.searched   = 0;\n        this.nextIndex = 0;\n        this.permList  = new int[this.listSize][this.number];\n\n        this.create(0, new int[this.number], new boolean[this.number]);\n    }\n\n    int[] nextPerm() {\n        return permList[this.nextIndex++];\n    }\n\n    boolean isNext() {\n        if(this.nextIndex < this.listSize) {\n            return true;\n        } else {\n            this.nextIndex = 0;\n            return false;\n        }\n    }\n\n    int fact(int n){\n        return n == 0 ? 1 : n * fact(n-1);\n    }\n\n    void create(int num, int[] list, boolean[] flag) {\n        if(num == this.number) {\n            copyArray(list, permList[this.searched]);\n            this.searched++;\n        }\n        for(int i = 0; i < this.number; i++){\n            if(flag[i]) continue;\n            list[num] = i;\n            flag[i] = true;\n            this.create(num+1, list, flag);\n            flag[i] = false;\n\n        }\n    }\n\n    void copyArray(int[] from, int[] to) {\n        for(int i=0; i<from.length; i++) to[i] = from[i];\n    }\n\n    void printNum(int[] nums) {\n        for(int n : nums) System.out.print(n);\n        System.out.println();\n    }\n}\n\n// 標準のScannerより高速に標準入力する\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(solve(input));\n\t\t}\n\t}\n\n\tpublic static String solve(int input) {\n\t\tint c = 0;\n\t\tArrayList list = new ArrayList();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tc = i;\n\t\t\tlist.add((i*(i+1)*(i+2))/6);\n\t\t}\n\n\t\tint[][] dp = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return dp[input-1][c-1];\n\n\t\tint c2 = 0;\n\t\tArrayList list2 = new ArrayList();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tif(((i*(i+1)*(i+2)/6) % 2) != 0) {\n\t\t\t\tc2++;\n\t\t\t\tlist2.add((i*(i+1)*(i+2))/6);\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp2 = new int[input][c2];\n\n\t\tfor(int i=0 ; i<c2 ; i++) {\n\t\t\tint v2 = Integer.parseInt(list2.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp2[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v2) == 0) {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2), dp2[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v2) {\n\t\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2)+dp2[((j+1)%v2) - 1][i-1], dp2[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[input-1][c-1] + \" \" + dp2[input-1][c2-1];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tshort[] DP = new short[1000001];\n\t\tshort[] ODD_DP = new short[1000001];\n\t\t\n\t\tfor(int j = 0; j <= 1000000; j++){\n\t\t\tDP[j] = ODD_DP[j] = -1;\n\t\t}\n\t\t\n\t\tDP[0] = 0;\n\t\tODD_DP[0] = 0;\n\t\t\n\t\tfor(int i = 0; ; i++){\n\t\t\tint number = ((i + 1) * (i + 2) * (i + 3)) / 6;\n\t\t\t\n\t\t\tif(number > 1000000){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j <= (100000 - number); j++){\n\t\t\t\tif(DP[j] != -1){\n\t\t\t\t\tif(DP[j + number] == -1){\n\t\t\t\t\t\tDP[j + number] = (short) (DP[j] + 1);\n\t\t\t\t\t}else if(DP[j + number] > DP[j] + 1){\n\t\t\t\t\t\tDP[j + number] = (short) (DP[j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(number % 2 == 1){\n\t\t\t\tfor(int j = 0; j <= (100000 - number); j++){\n\t\t\t\t\tif(ODD_DP[j] != -1){\n\t\t\t\t\t\tif(ODD_DP[j + number] == -1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (short) (ODD_DP[j] + 1);\n\t\t\t\t\t\t}else if(ODD_DP[j + number] > ODD_DP[j] + 1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (short) (ODD_DP[j] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(DP[n] + \" \" + ODD_DP[n]);\n\t\t\t\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[][] dp;\n\tstatic int n;\n\tstatic int INF = 2 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\tdp = new int[n+1][list.size()+1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][0] = 0;\n\t\t\tdp();\n\t\t\tansA = dp[n][list.size()];\n\t\t\tdp = new int[n+1][oddList.size()+1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][0] = 0;\n\t\t\toddDp();\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-list.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-oddList.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 1000000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new C().doIt();\n    }\n    class C{\n    \tArrayList<Integer> array = new ArrayList<Integer>();\n    \tArrayList<Integer> array2 = new ArrayList<Integer>();\n    \tArrayList<Integer> array3 = new ArrayList<Integer>();\n        void doIt(){\n        \tint a[] = new int [1000001];\n        \tint b[] = new int [1000001];\n        \tint num = 1;\n        \tint cnt = 2;\n        \twhile(num <= 1000000){\n//        \t\tSystem.out.println(num);\n        \t\tarray.add(num);\n        \t\tnum = num + cnt;\n        \t\tcnt += 1;\n        \t}\n        \tnum = 1;cnt = 1;\n        \twhile(num <= 1000000){\n//        \t\tSystem.out.println(num);\n        \t\tarray2.add(num);\n        \t\tif(num % 2 == 1){\n        \t\t\tarray3.add(num);\n//        \t\t\tSystem.out.println(num);\n        \t\t}\n        \t\tnum = num + array.get(cnt);\n        \t\tcnt += 1;\n        \t}\n//        \tSystem.out.println(array2.size()+\" \"+array3.size());\n        \tArrays.fill(a,100000);\n        \ta[0] = 0;\n        \tint length = array2.size();\n        \tfor(int i = 0;i < 20000;i++){\n        \t\tfor(int j = 0;j < length;j++){\n        \t\t\tint pos = array2.get(j);\n        \t\t\tif(i + pos > 1000000)break;\n        \t\t\ta[i+pos] = Math.min(a[i]+1,a[i+pos]);\n        \t\t}\n        \t}\n        \tArrays.fill(b,100000);\n        \tb[0] = 0;\n        \tlength = array3.size();\n        \tfor(int i = 0;i < 100000;i++){\n        \t\tfor(int j = 0;j < length;j++){\n        \t\t\tint pos = array3.get(j);\n        \t\t\tif(i + pos > 1000000)break;\n        \t\t\tb[i+pos] = Math.min(b[i]+1,b[i+pos]);\n        \t\t}\n        \t}\n        \twhile(true){\n        \t\tint n = sc.nextInt();\n        \t\tif(n == 0)break;\n        \t\tSystem.out.println(a[n]+\" \"+b[n]);\n        \t}\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\n\tstatic int min = Integer.MAX_VALUE;\n\tstatic int odd_min = Integer.MAX_VALUE;\n\tstatic int limit = 180;\n\n\t public static void main(String[] args)throws Exception{\n\n\t\t Scanner sc = new Scanner(System.in);\n\n\t\t while(true)\n\t\t {\n\t\t\t int n = sc.nextInt();\n\n\t\t\t if(n == 0)\n\t\t\t\t return;\n\n\t\t\t min = Integer.MAX_VALUE;\n\t\t\t odd_min = Integer.MAX_VALUE;\n\t\t\t int result;\n\t\t\t \n\t\t\t search(0,0,n);\n\t\t\t search_odd(0,0,n);\n\n\t\t\t System.out.print(min);\n\t\t\t System.out.print(\" \");\n\t\t\t System.out.println(odd_min);\n\n\t\t\t //System.out.println(n * (n+1) * (n+2) / 6);\n\n\t\t }\n\n\t }\n\n\t private static void search(int sum,int count,int n)\n\t {\n\t\t \n\t//\t System.out.println(\"\"+sum+\":\"+count);\n\t\t \n\t\t //?????????????????°???????°????????????§?????????????????£????????????????¶???????????????????????????§????????????\n\t\t if(count >= min)\n\t\t\t return;\n\n\t\t //????????????????????????????????´??????????°?????????´??°????\\?\n\t\t if(sum == n)\n\t\t {\n\t\t\t if(count < min)\n\t\t\t\t min = count;\n\n\t\t\t return;\n\t\t }\n\n\t\tfor(int i=1;i<limit;i++)\n\t\t{\n\t\t\tint num =(i * (i+1) * (i+2) / 6);\n\t\t//\tSystem.out.println(i);\n\t\t\tif(num > n - sum)\n\t\t\t\treturn;\n\t\t\tsearch(sum + num ,count+1,n);\n\t\t}\n\n\t }\n\t \n\t private static void search_odd(int sum,int count,int n)\n\t {\n\t\t if(sum == n)\n\t\t\t System.out.println(\"\"+sum+\":\"+count);\n\t\t \n\t\t //?????????????????°???????°????????????§?????????????????£????????????????¶???????????????????????????§????????????\n\t\t if(count >= odd_min)\n\t\t\t return;\n\t\t \n\t\t if(sum >n)\n\t\t\t return;\n\n\t\t //????????????????????????????????´??????????°?????????´??°????\\?\n\t\t if(sum == n)\n\t\t {\n\t\t\t if(count < odd_min)\n\t\t\t\t odd_min = count;\n\n\t\t\t return;\n\t\t }\n\n\t\tfor(int i=1;i<limit;i++)\n\t\t{\n\t\t\tint num =(i * (i+1) * (i+2) / 6);\n\t\t//\tSystem.out.println(\"\"+(sum+num)+\":\"+ (count+1) );\n\t\t\tif(num > n - sum)\n\t\t\t\treturn;\n\t\t\tif(num % 2 == 1)\n\t\t\t\tsearch_odd(sum + num ,count+1,n);\n\t\t}\n\n\t }\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] dp1=new int[1000000];\n\tstatic int[] dp2=new int[1000000];\n\t\n\tstatic void n() {\n\t\tfor(int num=1; num*(num+1)*(num+2)/6<1000000; num++) {\n\t\t\tdp1[num*(num+1)*(num+2)/6]=1;\n\t\t\tif((num*(num+1)*(num+2)/6)%2!=0){\n\t\t\t\tdp2[num*(num+1)*(num+2)/6]=1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void dp() {\n\t\tfor(int num=1; num<=1000000; num++) {\n\t\t\tfor(int i=1; i<num; i++) {\n\t\t\t\tdp1[num]=Math.min(dp1[num], dp1[num-i]+dp1[i]);\n\t\t\t\t//System.out.println(\"i=\"+i+\"dp1[\"+num+\"]=\"+dp1[num]);\n\t\t\t\tdp2[num]=Math.min(dp2[num], dp2[num-i]+dp2[i]);\n\t\t\t\t//System.out.println(\"i=\"+i+\"dp2[\"+num+\"]=\"+dp2[num]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\tArrays.fill(dp1, 100000000);\n\t\t\tArrays.fill(dp2, 100000000);\n\t\t\tn();\n\t\t\tdp();\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0) break;\n\t\t\t\t\n//\t\t\t\tfor(int num=1; num<=N; num++) {\n//\t\t\t\t\tfor(int i=1; i<num; i++) {\n//\t\t\t\t\t\tdp1[num]=Math.min(dp1[num], dp1[num-i]+dp1[i]);\n//\t\t\t\t\t\t//System.out.println(\"i=\"+i+\"dp1[\"+num+\"]=\"+dp1[num]);\n//\t\t\t\t\t\tdp2[num]=Math.min(dp2[num], dp2[num-i]+dp2[i]);\n//\t\t\t\t\t\t//System.out.println(\"i=\"+i+\"dp2[\"+num+\"]=\"+dp2[num]);\n//\t\t\t\t\t}\n//\t\t\t\t}\n\t\t\t\tSystem.out.println(dp1[N]+\" \"+dp2[N]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main \n{\n\n\tpublic static void main(String[] args) \n\t{\n\t\tlong[] tet = new long[201];\n\t\tlong[] tot = new long[1000001];\n\t\tlong[] totodd = new long[1000001];\n\t\t\n\t\tlong[] odd = new long[201];\n\t\t\n\t\tint filled = 0;\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<>();\n\t\tPriorityQueue<Integer> pq2 = new PriorityQueue<>();\n\n\t\tint odds = 0;\n\t\tfor(int i = 0; i <= 200; i++)\n\t\t{\n\t\t\ttet[i] = (i * (i+1) * (i+2)) / 6;\n\t\t\t\n\t\t\tif(tet[i] <= 1000000)\n\t\t\t{\n\t\t\t\tif(tet[i]%2 != 0)\n\t\t\t\t{\n\t\t\t\t\todd[odds] = tet[i];\n\t\t\t\t\todds++;\n\t\t\t\t\tpq2.add((int)tet[i]);\n\t\t\t\t\ttotodd[(int)tet[i]] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttot[(int)tet[i]] = 1;\n\t\t\t\tfilled++;\n\t\t\t\tpq.add((int)tet[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\t\n//\t\tSystem.out.println(Arrays.toString(tet));\n//\t\tSystem.out.println(Arrays.toString(odd));\n\n\t\t\n\t\tint curt = 0;\n\t\t\n\t\twhile(!pq.isEmpty())\n\t\t{\n\t\t\tint pos = pq.poll();\n\t\t\t\n\t\t\tfor(int i = 0; i <= 200; i++)\n\t\t\t{\n\t\t\t\tif(pos + tet[i] <= 1000000)\n\t\t\t\t{\n\t\t\t\t\tint next = pos + (int)tet[i];\n\t\t\t\t\tif(tot[next] == 0 || tot[next] > tot[pos]+1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttot[next] = tot[pos]+1;\n\t\t\t\t\t\tpq.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!pq2.isEmpty())\n\t\t{\n\t\t\tint pos = pq2.poll();\n\t\t\t\n\t\t\tfor(int i = 0; i <= 200; i++)\n\t\t\t{\n\t\t\t\tif(pos + odd[i] <= 1000000)\n\t\t\t\t{\n\t\t\t\t\tint next = pos + (int)odd[i];\n\t\t\t\t\tif(totodd[next] == 0 || totodd[next] > totodd[pos]+1)\n\t\t\t\t\t{\n\t\t\t\t\t\ttotodd[next] = totodd[pos]+1;\n\t\t\t\t\t\tpq2.add(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(\"DONE\");\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint in = sc.nextInt();\n\t\twhile(in != 0)\n\t\t{\n\t\t\tSystem.out.println(tot[in] + \" \" + totodd[in]);\n\t\t\tin = sc.nextInt();\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int MAX = 1000000;\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)) {\n\t\t\tint[] pol = new int[200];\n\t\t\tfor(int i=1; i<200; i++) {\n\t\t\t\tpol[i] = (i * (i + 1) * (i + 2)) / 6;\n\t\t\t}\n\t\t\t\n\t\t\tint[] dp = new int[MAX+1];\n\t\t\tint[] dp2 = new int[MAX+1];\n\t\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\t\tdp[0] = 0;\n\t\t\tdp2[0] = 0;\n\t\t\tfor(int i=1; i<MAX; i++) {\n\t\t\t\tfor(int j=1; j<200; j++) {\n\t\t\t\t\tif(i - pol[j] >= 0) {\n\t\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i-pol[j]]+1);\n\t\t\t\t\t\tif(pol[j] % 2 == 1) {\n\t\t\t\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i-pol[j]]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(n == 0) break;\n\t\t\t\tSystem.out.println(dp[n] + \" \" + dp2[n]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tint[] list = new int[1000000];\n\tpublic void run() {\n\t\tmakeList();\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int n){\n\t\titer(n, 0, 0);\n\t\titer2(n, 0, 0);\n\t\tSystem.out.println(minSum + \" \" + minSumK);\n\t\tminSum = 1000000;\n\t\tminSumK = 1000000;\n\t}\n\tint minSum = 1000000;\n\tint minSumK = 1000000;\n\tpublic void iter(int n, int sum, int count){\n\t\tif(n == 0){\n\t\t\tif(sum < minSum) \n\t\t\t\tminSum = sum;\n\t\t}\n\t\telse{\n\t\t\tfor(int i = count; i <= n; i++){\n\t\t\t\tif(n - i < 0) break;\n\t\t\t\telse if(list[i] > 0) iter(n -i, sum + 1, i);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void iter2(int n, int sumK, int count){\n\t\tif(n == 0){\n\t\t\tif(sumK < minSumK) \n\t\t\t\tminSumK = sumK;\n\t\t}\n\t\telse{\n\t\t\tfor(int i = count; i <= n; i++){\n\t\t\t\tif(n - i < 0) break;\n\t\t\t\tif(list[i] == 1) iter2(n - i, sumK + 1, i);\n\t\t\t}\n\t\t}\n\t}\n\tpublic void makeList(){\n\t\tfor(int i = 1; i < 1000000; i++){\n\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(t > 1000000) break;\n\t\t\telse if(t % 2 == 1) list[t] = 1;\n\t\t\telse list[t] = 2;\n \t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint max=1000001;\n\n\tint[] dp1, a;\n\tint n;\n\n\tvoid run(){\n\t\tdp1=new int[max];\n\t\ta=new int[max];\n\n\t\tfill(dp1, INF);\n\t\tdp1[0]=0;\n\t\tfor(int j=0; j<5; j++){\n\t\t\tSystem.arraycopy(dp1, 0, a, 0, max);\n\t\t\tfor(int k=0; k*(k+1)*(k+2)/6<max; k++){\n\t\t\t\tint m=k*(k+1)*(k+2)/6;\n\t\t\t\tfor(int i=0; i+m<max; i++){\n\t\t\t\t\tdp1[i+m]=min(dp1[i+m], a[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint[] dp2=new int[n+1];\n\t\tfill(dp2, INF);\n\t\tdp2[0]=0;\n\t\tfor(int j=0;; j++){\n\t\t\tSystem.arraycopy(dp2, 0, a, 0, n+1);\n\t\t\tfor(int k=0; k*(k+1)*(k+2)/6<n+1; k++){\n\t\t\t\tint m=k*(k+1)*(k+2)/6;\n\t\t\t\tif(m%2==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i+m<n+1; i++){\n\t\t\t\t\tdp2[i+m]=min(dp2[i+m], a[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(dp);\n\t\t\tif(dp2[n]<INF){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintln(dp1[n]+\" \"+dp2[n]);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main3 {\n\n\tstatic int N,min,cnt;\n\tstatic int[] a =new int[180];\n\tstatic int[] b =new int[45];\n\tstatic int[] alreadyA;\n\tstatic int[] alreadyB;\n\tstatic{\n\t\tint cnt=0;\n\t\tfor(int i = 1;tetrahedral(i)<=1000000;i++){\n\t\t\tint t = tetrahedral(i);\n\t\t\ta[cnt++]=t;\n\t\t}\n\t\tfor(int i = 0;i<a.length;i++){\n\t\t\t//System.out.println(a[i]);\n\t\t}\t\t\n\t\talreadyA=new int[1000000];\n\t\talreadyB=new int[1000000];\n\t\tcnt=0;\n\t\tfor(int i = 1;tetrahedral(i)<=1000000;i++){\n\t\t\tint t = tetrahedral(i);\n\t\t\tif(t%2==1){\n\t\t\t\tb[cnt++]=t;\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tArrays.fill(alreadyA, 0);\n\t\tArrays.fill(alreadyB, 0);\n\t\ta();\n\t\twhile(true){\n\t\t\tN =cin.nextInt();\n\t\t\tif(N==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt=0;min=Integer.MAX_VALUE;\n\t\t\t\n\t\t\tSystem.out.print(alreadyA[N]);\n\t\t\tSystem.out.println(\" \"+alreadyB[N]);\n\t\t}\n\n\t}\n\tstatic void a(){\n\t\tfor(int i= 1;i<1000000;i++){\n\t\t\tint mina=Integer.MAX_VALUE;\n\t\t\tint minb=Integer.MAX_VALUE;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int j=0;j<180&&a[j]<=i;j++){\n\t\t\t\tmina=Math.min(1+alreadyA[i-a[j]],mina);\n\t\t\t\tif(a[j]%2==1){\n\t\t\t\t\tminb=Math.min(1+alreadyB[i-a[j]],minb);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(i+\" \" +x+\" \" +y + \" \" +min);\n\t\t\talreadyA[i]=mina;\n\t\t\talreadyB[i]=minb;\n\t\t}\n\t}\n\tstatic int tetrahedral(int a){\n\t\treturn (a*(a+1)*(a+2))/6;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic int max = 1000001;\n\tstatic int simentai(int n){\n\t\treturn n*(n+1)*(n+2)/6;\n\t}\n\tpublic static void main(String[] args) {\n\t\tList<Integer> data = new ArrayList<Integer>();\n\t\tfor(int i=0;simentai(i)<max;i++){\n\t\t\tdata.add(simentai(i));\n\t\t\tif(data.get(i)>max)break;\n\t\t}\n\t\tint num[]=new int[max];\n\t\tfor(int i=0;i<max;i++)num[i]=i;//初期化(四面体が全て1の場合にしておく)\n\t\tfor(int i=2;i<data.size();i++){//四面体の数だけ進める。\n\t\t\tfor(int s=0;s<max;s++){//0からひとつずつ進める。\n\t\t\t\tif(s-data.get(i)<0)continue;\n\t\t\t\tint test=num[s-data.get(i)]+1;//四面体数ぶん前に戻ってその通り方+1(今回の)\n\t\t\t\tnum[s]=Math.min(test,num[s]);\n\t\t\t}\n\t\t}\n\t\tint kisuu[] = new int[max];\n\t\tfor(int i=0;i<max;i++)kisuu[i]=i;//初期化\n\t\tfor(int i=2;i<data.size();i++){\n\t\t\tif(data.get(i)%2==0)continue;//偶数ならはじく\n\t\t\tfor(int s=0;s<max;s++){\n\t\t\t\tif(s-data.get(i)<0)continue;\n\t\t\t\tint test = kisuu[s-data.get(i)]+1;\n\t\t\t\tif(s==5)System.out.println(kisuu[s]+\" or \"+test+\" \"+i);\n\t\t\t\tkisuu[s]=Math.min(kisuu[s], test);\n\t\t\t}\n\t\t}\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tSystem.out.println(num[n]+\" \"+kisuu[n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int min = Integer.MAX_VALUE;\n\tstatic int odd_min = Integer.MAX_VALUE;\n\tstatic int limit = 180;\n\n\t public static void main(String[] args)throws Exception{\n\n\t\t limit = 1000000;\n\n\t\t int[] dp = new int[limit];\n\t\t int[] dp_odd = new int[limit];\n\t\t \n\t\t for(int i=0;i<limit;i++)\n\t\t {\n\t\t\t dp[i]=i; \n\t\t\t dp_odd[i]=i;\n\t\t }\n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp[j] =Math.min(j/frame,dp[j]); \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp[j] = Math.min(dp[j % frame] + count,dp[j]);\n\t\t\t }\n\t\t }\n\t\t \n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t if(frame % 2 ==0)\n\t\t\t\t continue;\t\t\n\t\t\t \n\t\t\t \n\t\t\t //??±?????£???\n\t\t\tfor(int j = frame;j<limit;j++)\n\t\t\t{\n\t\t\t\t dp_odd[j] = Math.min(dp_odd[j],dp_odd[j-frame]+1);\n\t\n\t\t\t}\n\t\t\t \n\t\t\t/* \n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp_odd[j] =Math.min(j/frame,dp_odd[j]); \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp_odd[j] = Math.min(dp_odd[j % frame] + count,dp_odd[j]);\n\t\t\t }\n\t\t\t \n\t\t\t */\n\t\t }\n\t\t \n\n\t\t Scanner sc = new Scanner(System.in);\n\n\t\t while(true)\n\t\t {\n\t\t\t int n = sc.nextInt();\n\n\t\t\t if(n == 0)\n\t\t\t\t return;\n\n\t\t\t System.out.print(dp[n]);\n\t\t\t System.out.print(\" \");\n\t\t\t System.out.println(dp_odd[n]);\n\n\t\t }\n\n\t }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic byte[][] dp;\n\tstatic byte[][] odp;\n\tstatic int n;\n\tstatic byte INF = Byte.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\tn = 1000000;\n\t\tdp = new byte[1000001][list.size()+1];\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp();\n\t\t\n\t\todp = new byte[1000001][oddList.size()+1];\n\t\tSystem.gc();\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(odp[i], INF);\n\t\t}\n\t\todp[0][0] = 0;\n\t\toddDp();\n\t\tSystem.gc();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n][list.size()];\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = (byte) (dp[i-list.get(j-1)][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 100000 == 0)\n\t\t\t\tSystem.gc();\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = (byte) (dp[i-oddList.get(j-1)][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int[] lib = new int[181];\n    int[] lib2 = new int[46];\n    int libi = 0;\n    int lib2i = 0;\n    for (int i = 1; ; i++) {\n      int k = (i * (i + 1) * (i + 2)) / 6;\n      lib[libi++] = k;\n      if (k % 2 == 1) {\n        lib2[lib2i++] = k;\n      }\n      if (k >= 1000000) {\n        break;\n      }\n    }\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      System.out.println(calc(n, lib) + \" \" + calc(n, lib2));\n    }\n  }\n\n  static int calc(int n, int[] lib) {\n    int[][] dp = new int[lib.length][n + 1];\n    for (int i = 0; i < lib.length; i++) {\n      for (int j = 0; j < n + 1; j++) {\n        dp[i][j] = Integer.MAX_VALUE;\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      dp[0][i] = i;\n    }\n    for (int i = 1; i < lib.length; i++) {\n      int v = lib[i];\n      if (lib[i] > n) {\n//        System.out.println(\"--------\");\n//        for (int o = 0; o < i; ++o) {\n//          for (int j = 0; j <= n; ++j) {\n//            System.out.printf(\" %2d\", dp[o][j]);\n//          }\n//          System.out.println();\n//        }\n\n        return dp[i - 1][n];\n      }\n      for (int j = 0; j <= n; j++) {\n        if (dp[i - 1][j] == Integer.MAX_VALUE) {\n          continue;\n        }\n        for (int k = 0; j + k * v <= n; k++) {\n          dp[i][j + k * v] = Math.min(dp[i][j + k * v], dp[i - 1][j] + k);\n        }\n      }\n    }\n    return dp[lib.length][n];\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n    static Pollock[] pol = new Pollock[1000000];\n    static int count=0;\n\n    static class Pollock{\n        int all;\n        int odd;\n\n        Pollock(int all, int odd) {\n            this.all = all;\n            this.odd = odd;\n        }\n    }\n\n    public static void main(String[] args) {\n        pol[0]=new Pollock(0,0);\n        while (true) {\n            int N = s.nextInt();\n            if (N == 0) break;\n\n            if(N>count)\n                calc(N);\n\n            System.out.println(pol[N].all+\" \"+pol[N].odd);\n        }\n    }\n\n    public static void calc(int N){\n        while(count<N){\n            calc_min(++count);\n        }\n\n    }\n\n    public static void calc_min(int count){\n        int i=1;\n        int min_all=pol[count-1].all+1;\n        int min_odd=pol[count-1].odd+1;\n\n        while(true){\n            i++;\n            int tetrahedron=i*(i+1)*(i+2)/6;\n            if(tetrahedron>count) break;\n\n            min_all=Math.min(min_all,pol[count-tetrahedron].all+1);\n            if(tetrahedron%2==1)\n                min_odd=Math.min(min_odd,pol[count-tetrahedron].odd+1);\n        }\n        pol[count]=new Pollock(min_all,min_odd);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \npublic class Main {\n     \n\tstatic int N;\n\tstatic int max;\n\t\n\tstatic void bfs1()\n\t{\n\t\tLinkedList<Integer> sum = new LinkedList<Integer>();\n\t\tLinkedList<Integer> num = new LinkedList<Integer>();\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\t\n\t\tfor (int i = max; i >= 1; i--) {\n\t\t\tsum.offer(new Integer(0));\n\t\t\tnum.offer(new Integer(i));\n\t\t\tindex.offer(new Integer(1));\n\t\t}\n\t\t\n\t\twhile (!sum.isEmpty()) {\n\t\t\tint ss = sum.poll().intValue();\n\t\t\tint nn = num.poll().intValue();\n\t\t\tint ii = index.poll().intValue();\n\t\t\t\n\t\t\tss += nn * (nn + 1) * (nn + 2) / 6;\n\t\t\tif(ss == N)\n\t\t\t{\n\t\t\t\tSystem.out.print(ii);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(ss > N) continue;\n\t\t\tif(ii == 1000) continue;\n\t\t\tfor (int i = nn; i >= 1; i--) {\n\t\t\t\tif((ss+i * (i + 1) * (i + 2) / 6) > N) continue;\n\t\t\t\tsum.offer(new Integer(ss));\n\t\t\t\tnum.offer(new Integer(i));\n\t\t\t\tindex.offer(new Integer(ii+1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfs2()\n\t{\n\t\tLinkedList<Integer> sum = new LinkedList<Integer>();\n\t\tLinkedList<Integer> num = new LinkedList<Integer>();\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\t\n\t\tfor (int i = max; i >= 1; i--) {\n\t\t\tif((i*(i+1)*(i+2)/6) % 2 == 0) continue;\n\t\t\tsum.offer(new Integer(0));\n\t\t\tnum.offer(new Integer(i));\n\t\t\tindex.offer(new Integer(1));\n\t\t}\n\t\t\n\t\twhile (!sum.isEmpty()) {\n\t\t\tint ss = sum.poll().intValue();\n\t\t\tint nn = num.poll().intValue();\n\t\t\tint ii = index.poll().intValue();\n\t\t\t\n\t\t\tss += nn * (nn + 1) * (nn + 2) / 6;\n\t\t\tif(ss == N)\n\t\t\t{\n\t\t\t\tSystem.out.print(ii);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(ss > N) continue;\n\t\t\tif(ii == 1000) continue;\n\t\t\tfor (int i = nn; i >= 1; i--) {\n\t\t\t\tif((i*(i+1)*(i+2)/6)%2 == 0) continue;\n\t\t\t\tif((ss+i * (i + 1) * (i + 2) / 6) > N) continue;\n\t\t\t\tsum.offer(new Integer(ss));\n\t\t\t\tnum.offer(new Integer(i));\n\t\t\t\tindex.offer(new Integer(ii+1));\n\t\t\t}\n\t\t}\n\t}\n    \n    static void start()\n    {\n    \tfor (max = 1; max < 200; max++) {\n\t\t\tif(N <= (max*(max+1)*(max+2)/6)) break;\n\t\t}\n    \t//System.out.print(max);\n    \tbfs1();\n    \tSystem.out.print(\" \");\n    \tbfs2();\n    \tSystem.out.println(\"\");\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \t\n        \tif(N == 0) break;\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\twhile(true) {\n\t\t\tint n = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tint tmp = n;\n\t\t\tint c = 0;\n\t\t\tqueue.removeAll(queue);\n\t\t\tint ans = solv(n);\n\t\t\tIN:while(true) {\n\t\t\tfor(int i = oddList.size()-1; i >= 0; i--) {\n\t\t\t\t\tif(oddList.get(i) <= tmp) {\n\t\t\t\t\t\ttmp -= oddList.get(i);\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp == 0) {\n\t\t\t\t\t\tbreak IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans + \" \" + c);\n\t\t\t\n\t\t}\n\t}\n\tpublic static ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\tpublic static int solv(int a) {\n\t\tint ans = 0;\n\t\tqueue.add(new Data(a,0,0));\n\t\twhile(true) {\n\t\t\tint ax = bfs(queue.poll());\n\t\t\tif(ax != 0) {\n\t\t\t\treturn ax;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int  bfs(Data a) {\n\t\tif(a.a == a.b) return a.c;\n\t\tif(a.a < a.b) return 0;\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tqueue.add(new Data(a.a,a.b + list.get(i),a.c+1));\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 1000000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 10e6) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nclass Data {\n\tint a;\n\tint b;\n\tint c;\n\tData(int d, int e, int f) {\n\t\ta = d;\n\t\tb = e;\n\t\tc = f;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\nimport javax.naming.InitialContext;\n \npublic class Main {\n     \n\tstatic int N;\n\tstatic int dp1[];\n\tstatic int dp2[];\n\t\n\tstatic void init()\n\t{\n\t\tdp1 = new int[1000001];\n\t\tdp1[0] = 0;\n\t\tdp1[1] = 1;\n\t\tfor(int i = 2;i <= 1000000;i++)\n\t\t{\n\t\t\tdp1[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 1; j < 200; j++) {\n\t\t\t\tint d = j*(j+1)*(j+2)/6;\n\t\t\t\tif(i - d < 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(i - d == 0)\n\t\t\t\t{\n\t\t\t\t\tdp1[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdp1[i] = Math.min(dp1[i], dp1[i-d]+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp2 = new int[1000001];\n\t\tdp2[0] = 0;\n\t\tdp2[1] = 1;\n\t\tfor(int i = 2;i <= 1000000;i++)\n\t\t{\n\t\t\tdp2[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 1; j < 200; j++) {\n\t\t\t\tint d = j*(j+1)*(j+2)/6;\n\t\t\t\tif(d % 2 == 0) continue;\n\t\t\t\tif(i - d < 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(i - d == 0)\n\t\t\t\t{\n\t\t\t\t\tdp2[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i-d]+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n    \n    static void start()\n    {\n    \tSystem.out.printf(\"%d %d\\n\", dp1[N], dp2[N]);\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        init();\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \t\n        \tif(N == 0) break;\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new C().doIt();\n    }\n    class C{\n    \tArrayList<Integer> array = new ArrayList<Integer>();\n    \tArrayList<Integer> array2 = new ArrayList<Integer>();\n    \tArrayList<Integer> array3 = new ArrayList<Integer>();\n        void doIt(){\n        \tint a[] = new int [1000001];\n        \tint b[] = new int [1000001];\n        \tint num = 1;\n        \tint cnt = 2;\n        \twhile(num <= 1000000){\n//        \t\tSystem.out.println(num);\n        \t\tarray.add(num);\n        \t\tnum = num + cnt;\n        \t\tcnt += 1;\n        \t}\n        \tnum = 1;cnt = 1;\n        \twhile(num <= 1000000){\n//        \t\tSystem.out.println(num);\n        \t\tarray2.add(num);\n        \t\tif(num % 2 == 1){\n        \t\t\tarray3.add(num);\n//        \t\t\tSystem.out.println(num);\n        \t\t}\n        \t\tnum = num + array.get(cnt);\n        \t\tcnt += 1;\n        \t}\n//        \tSystem.out.println(array2.size()+\" \"+array3.size());\n        \tArrays.fill(a,100000);\n        \ta[0] = 0;\n        \tint length = array2.size();\n        \tfor(int i = 0;i < 1000000;i++){\n        \t\tfor(int j = 0;j < length;j++){\n        \t\t\tint pos = array2.get(j);\n        \t\t\tif(i + pos > 1000000)break;\n        \t\t\ta[i+pos] = Math.min(a[i]+1,a[i+pos]);\n        \t\t}\n        \t}\n        \tArrays.fill(b,100000);\n        \tb[0] = 0;\n        \tlength = array3.size();\n        \tfor(int i = 0;i < 1000000;i++){\n        \t\tfor(int j = 0;j < length;j++){\n        \t\t\tint pos = array3.get(j);\n        \t\t\tif(i + pos > 1000000)break;\n        \t\t\tb[i+pos] = Math.min(b[i]+1,b[i+pos]);\n        \t\t}\n        \t}\n//        \tfor(int i = 0;i < 501;i++){\n//        \t\tSystem.out.println(i+\" \"+a[i]+\" \"+b[i]);\n//        \t}\n        \twhile(true){\n        \t\tint n = sc.nextInt();\n        \t\tif(n == 0)break;\n        \t\tSystem.out.println(a[n]+\" \"+b[n]);\n        \t}\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    int[] all_num = new int[10000];\n    final static int max = 1000000000;\n    int devise(int num){\n        int index = 0;\n        for(int i = 0;i < 1417;i++){\n            if(all_num[i] >= num){\n                index = i - 1;\n            }\n        }\n        return index;\n    }\n    void doteki(){\n        for(int i = 0; i < 10000;i++){\n            all_num[i] = ((i+1)*(i+2)*(i+3))/6;\n            if(all_num[i] < max){\n                //System.out.println(all_num[i]);\n            }\n            else\n                break;\n        }\n    }\n    boolean kisuu(int num){\n        if(num % 2 == 1){\n            return true;\n        }\n        return false;\n    }\n    void run() throws IOException{\n        //System.out.println(num);\n        doteki();\n        int num;\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            num = Integer.parseInt(in.readLine());\n            int index = 0;\n            int count = 0;\n            int ans = 0;\n            int ans_count = max;\n            if(num == 0){\n                break;\n            }\n            index = devise(num);\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(ans + all_num[j] > num){\n                        j--;\n                    }\n                    else if(ans + all_num[j] < num){\n                        ans += all_num[j];\n                        count++;\n                    }\n                    else if(ans + all_num[j] == num){\n                        count++;\n                        if(ans_count >= count){\n                            ans_count = count;\n                            count = 0;\n                        }\n                        break;\n                    }\n                }\n            }\n            System.out.print(ans_count);\n            //?\\???°??¨\n            count = 0;\n            ans = 0;\n            ans_count = max;\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(kisuu(all_num[j]) == true){\n                        if(ans + all_num[j] > num){\n                            j--;\n                        }\n                        else if(ans + all_num[j] < num){\n                            ans += all_num[j];\n                            count++;\n                        }\n                        else if(ans + all_num[j] == num){\n                            count++;\n                            if(ans_count >= count){\n                                ans_count = count;\n                                count = 0;\n                            }\n                            break;\n                        }\n                    }\n                    else{\n                        j--;\n                    }\n                }\n            }\n            System.out.print(\" \"+ans_count);\n            System.out.println();\n\n        }\n\n\n\n    }\n    public static void main(String[] args) throws IOException{\n        Main ma = new Main();\n        ma.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic final int MAX = 1000000;\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\t\n\tstatic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] ary = new int[200];\n\t\tint[] ary2 = new int[200];\n\t\tint[] dp = new int[MAX + 1];\n\t\tint[] dp2 = new int[MAX + 1];\n\t\tint p = 1;\n\t\tfor(int i = 1; i < 200; i++){\n\t\t\tary[i] = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(ary[i] % 2 == 1){\n\t\t\t\tary2[p] = ary[i];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tsolve(MAX, ary, dp);\n\t\tsolve(MAX, ary2, dp2);\n\t\twhile(0 < n){\n\t\t\tSystem.out.println(dp[n] + \" \" + dp2[n]);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\tstatic int solve(int n, int[] ary, int[] dp){\n\t\t//int[] dp = new int[n + 1];\n\t\tArrays.fill(dp, 1000000);\n\t\tdp[0] = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j < ary.length; j++)\n\t\t\t\tif(i < ary[j]) break;\n\t\t\t\telse if(dp[i - ary[j]] + 1 < dp[i]) dp[i] = dp[i - ary[j]] + 1;\n\t\t}\n\t\treturn dp[n];\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int[] lib = new int[300];\n    int[] lib2 = new int[300];\n    int libi = 0;\n    int lib2i = 0;\n    for (int i = 1; ; i++) {\n      int k = (i * (i + 1) * (i + 2)) / 6;\n      lib[libi++] = k;\n      if (k % 2 == 1) {\n        lib2[lib2i++] = k;\n      }\n      if (k >= 1000000) {\n        break;\n      }\n    }\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      System.out.println(calc(n, lib) + \" \" + calc(n, lib2));\n    }\n  }\n\n  public static int calc(int n, int[] lib) {\n    int[][] dp = new int[300][n + 1];\n    for (int i = 0; i < 300; i++) {\n      for (int j = 0; j < n + 1; j++) {\n        dp[i][j] = Integer.MAX_VALUE;\n      }\n    }\n    for (int i = 0; i <= n; i++) {\n      dp[0][i] = i;\n    }\n    for (int i = 1; i < lib.length; i++) {\n      int v = lib[i];\n      if (lib[i] > n) {\n//        System.out.println(\"--------\");\n//        for (int o = 0; o < i; ++o) {\n//          for (int j = 0; j <= n; ++j) {\n//            System.out.printf(\" %2d\", dp[o][j]);\n//          }\n//          System.out.println();\n//        }\n\n        return dp[i - 1][n];\n      }\n      for (int j = 0; j <= n; j++) {\n        if (dp[i - 1][j] == Integer.MAX_VALUE) {\n          continue;\n        }\n        for (int k = 0; j + k * v <= n; k++) {\n          dp[i][j + k * v] = Math.min(dp[i][j + k * v], dp[i - 1][j] + k);\n        }\n      }\n    }\n    return dp[lib.length][n];\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal int MAX_N = 1000000;\n\tfinal int INF = Integer.MAX_VALUE;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint[] dp1 = new int[MAX_N + 1];\n\t\tint[] dp2 = new int[MAX_N + 1];\n\t\tfor (int i = 1; i <= MAX_N; i++)\n\t\t\tdp1[i] = dp2[i] = INF;\n\n\t\tint[] pollock = new int[MAX_N]; //{ 1, 4, 10, 20, 35 };\n\t\tint pCount = 0;\n\t\tfor (int i = 1;;i++) {\n\t\t\tint p = (i * (i + 1) * (i + 2)) / 6;\n\t\t\tif (p > MAX_N)\n\t\t\t\tbreak;\n\t\t\tpollock[pCount++] = p;\n\t\t\tif (DEBUG)\n\t\t\t\tSystem.out.println(pollock[pCount - 1]);\n\t\t}\n\t\tif (DEBUG)\n\t\t\tSystem.out.println(pCount);\n\n\t\tfor (int i = 1; i <= MAX_N; i++) {\n\t\t\tfor (int j = 0; j < pCount; j++) {\n\t\t\t\tif (i - pollock[j] < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdp1[i] = Math.min(dp1[i], dp1[i - pollock[j]] + 1);\n\t\t\t\tif (pollock[j] % 2 == 1)\n\t\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i - pollock[j]] + 1);\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(dp1[n] + \" \" + dp2[n]);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main2010C {\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint[] pol = new int[1000000];\n\t\tArrayList<Integer> p1 = new ArrayList<>();\n\t\tint[] pol_odd = new int[1000000];\n\t\tArrayList<Integer> p1_odd = new ArrayList<>();\n\t\t\n\t\tint num = 1;\n\t\tfor(int i=1;num<1000000;i++){\n\t\t\tp1.add(num);\n\t\t\tif((num&1)==1){\n\t\t\t\tp1_odd.add(num);\n\t\t\t}\n\t\t\tnum = num * (i+3) / i;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<1000000;i++){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int j=0;j<p1.size();j++){\n\t\t\t\tif(i-p1.get(j)<0) break;\n\t\t\t\tmin = Math.min(min,pol[i-p1.get(j)]);\n\t\t\t}\n\t\t\tpol[i] = min + 1;\n\t\t\t\n\t\t\tmin = Integer.MAX_VALUE;\n\t\t\tfor(int j=0;j<p1_odd.size();j++){\n\t\t\t\tif(i-p1_odd.get(j)<0) break;\n\t\t\t\tmin = Math.min(min,pol_odd[i-p1_odd.get(j)]);\n\t\t\t}\n\t\t\tpol_odd[i] = min + 1;\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tint x = in.nextInt();\n\t\t\tif(x==0) break;\n\t\t\telse{\n\t\t\t\tSystem.out.println(pol[x]+\" \"+pol_odd[x]);\n\t\t\t}\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic int[] dp = new int[1000001];\n\tstatic int[] dp2 = new int[1000001];\n\tpublic static void main(String[] args) {\n\t\tfill(dp, -1);\n\t\tfill(dp2, -1);\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N;\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tif (N == 0) return false;\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\tSystem.out.println(rec(N) + \" \" + rec2(N));\n\t}\n\t\n\tstatic int rec(int v) {\n\t\tif (v <= 0) return 0;\n\t\telse if (v == 1) return 1;\n\t\telse if (dp[v] != -1) {\n\t\t\treturn dp[v];\n\t\t}\n\t\tint ret = Integer.MAX_VALUE;\n\t\tfor (int i = 1; ; i++) {\n\t\t\tint a = f(i);\n\t\t\tint b = v - a;\n\t\t\tif (b < 0) break;\n\t\t\tret = min(ret, 1 + rec(b));\n\t\t}\n\t\tdp[v] = ret;\n\t\treturn ret;\n\t}\n\t\n\tstatic int rec2(int v) {\n\t\tif (v <= 0) return 0;\n\t\telse if (v == 1) return 1;\n\t\telse if (dp2[v] != -1) {\n\t\t\treturn dp2[v];\n\t\t}\n\t\tint ret = Integer.MAX_VALUE;\n\t\tfor (int i = 1; ; i++) {\n\t\t\tint a = f(i);\n\t\t\tint b = v - a;\n\t\t\tif (a % 2 == 0) continue;\n\t\t\tif (b < 0) break;\n\t\t\tret = min(ret, 1 + rec2(b));\n\t\t}\n\t\tdp2[v] = ret;\n\t\treturn ret;\n\t}\n\n\n\tstatic int f(int n) {\n\t\treturn n * (n + 1) * (n + 2) / 6;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic int[] dp = new int[201];\n\tstatic int[] dp2 = new int[201];\n\tpublic static void main(String[] args) {\n\t\tfill(dp, -1);\n\t\tfill(dp2, -1);\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N;\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tif (N == 0) return false;\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\tSystem.out.println(rec(N) + \" \" + rec2(N));\n\t}\n\t\n\tstatic int rec(int v) {\n\t\tif (v <= 0) return 0;\n\t\telse if (v == 1) return 1;\n\t\telse if (dp[v] != -1) {\n\t\t\treturn dp[v];\n\t\t}\n\t\tint ret = Integer.MAX_VALUE;\n\t\tfor (int i = 1; ; i++) {\n\t\t\tint a = f(i);\n\t\t\tint b = v - a;\n\t\t\tif (b < 0) break;\n\t\t\tret = min(ret, 1 + rec(b));\n\t\t}\n\t\tdp[v] = ret;\n\t\treturn ret;\n\t}\n\t\n\tstatic int rec2(int v) {\n\t\tif (v <= 0) return 0;\n\t\telse if (v == 1) return 1;\n\t\telse if (dp2[v] != -1) {\n\t\t\treturn dp2[v];\n\t\t}\n\t\tint ret = Integer.MAX_VALUE;\n\t\tfor (int i = 1; ; i++) {\n\t\t\tint a = f(i);\n\t\t\tint b = v - a;\n\t\t\tif (a % 2 == 0) continue;\n\t\t\tif (b < 0) break;\n\t\t\tret = min(ret, 1 + rec2(b));\n\t\t}\n\t\tdp2[v] = ret;\n\t\treturn ret;\n\t}\n\n\n\tstatic int f(int n) {\n\t\treturn n * (n + 1) * (n + 2) / 6;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// int nnn=3*(3+1)*(3+2)/6;\n\t\t// System.out.println(nnn);\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tint min = 1000000;\n\t\t\t// int tate = n * (n + 1) * (n + 2);\n\n\t\t\t// tate++;\n//\t\t\tlong[][] dp = new long[181][n+ 1];\n\t\t\tlong[] dp = new long[n+ 1];\n\t\t\tlong[] dpki = new long[n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tdp[i] = i;\n//\t\t\t\tdp[0][i] = 1000000;\n\n\t\t\t\tdpki[i] = i;\n\t\t\t\t//dpki[0][i] = 1000000;\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < 181; i++) {\n\n\t\t\t//\tfor (int j = 1; j <= n; j++)\n\t\t\t//\t\tdp[i][j] = dp[i - 1][j];\n\n\t\t\t\tint sum = i * (i + 1) * (i + 2) / 6;\n\n\t\t\t\tfor(int j=sum;j<=n;j++){\n\t\t\t\t\tdp[j]=Math.min(dp[j],dp[j-sum]+1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tif (sum <= n && dp[i - 1][sum] > 1)\n\t\t\t\t\tdp[i][sum] = 1;\n\t\t\t\tint count = 2;\n\t\t\t\tfor (int j = sum * 2; j <= n; j += sum) {\n\t\t\t\t\tif (dp[i - 1][j] > count)\n\t\t\t\t\t\tdp[i][j] = count;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\n\t\t\t\t// for (int k = 2; n / sum >= k; k++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (n >= j + sum && dp[i - 1][j + sum] > dp[i - 1][j] + 1 && dp[i][j + sum] > dp[i - 1][j] + 1)\n\t\t\t\t\t\tdp[i][j + sum] = dp[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t\t// }\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\tfor (int i = 2; i < 181; i++) {\n\t\t\t\t//for (int j = 1; j <= n; j++)\n\t\t\t\t//\tdpki[i][j] = dpki[i - 1][j];\n\n\t\t\t\tint sum2 = i * (i + 1) * (i + 2) / 6;\n\n\t\t\t\tif (sum2 % 2 == 0)\n\t\t\t\t\tcontinue;\n\n//\t\t\t\tif(dpki[i][sum2]>1)dp[i][sum2]=1;\n\t\t\t\tfor(int j=sum2;j<=n;j++){\n\t\t\t\t\tdpki[j]=Math.min(dpki[j],dpki[j-sum2]+1);\n\t\t\t\t}\n\t\t\t\t\n/*\t\t\t\tif (sum2 <= n && dpki[i - 1][sum2] > 1)dpki[i][sum2] = 1;\n\t\t\t\tint count2 = 2;\n\t\t\t\tfor (int j = sum2 * 2; j <= n; j += sum2) {\n\t\t\t\t\tif (dpki[i - 1][j] > count2)\n\t\t\t\t\t\tdpki[i][j] = count2;\n\t\t\t\t\tcount2++;\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (n >= j + sum2 && dpki[i][j + sum2] > dpki[i][j] + 1)dpki[i][j + sum2] = dpki[i][j] + 1;\n\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tfor (int k = 1; n / sum2 >= k; k++) {\n\t\t\t\t\tint sss=sum2*k;\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tif (n >= j + sss && dpki[i][j + sss] > dpki[i][j] + 1)dpki[i][j + sss] = dpki[i][j] + 1;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t/*\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\t\tSystem.out.print(dpki[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n*/\n\t\t\tlong result = dp[n];\n\t\t\tlong result2 = dpki[n];\n\t/*\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\t// System.out.println(dp[i][n]);\n\t\t\t\tif (dp[i][n] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult = (int) Math.min(dp[i][n], result);\n\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\t// System.out.println(dp[i][n]);\n\t\t\t\tif (dpki[i][n] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult2 = (int) Math.min(dpki[i][n], result2);\n\n\t\t\t}\n*/\n\t\t\tSystem.out.print(result+\" \");\n\t\t\tSystem.out.println(result2);\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint[] tetra;\n\tint ans;\n\tint[] dp1, dp2;\n\n\tint dp1(int sum) {\n\t\tif (sum < 0) {\n\t\t\treturn 200;\n\t\t}\n\t\tif (sum == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp1[sum]) {\n\t\t\treturn dp1[sum];\n\t\t}\n\t\tint res = 200;\n\t\tfor (int i = 199; 1 <= i; i--) {\n\t\t\tres = Math.min(res, dp1(sum - tetra[i]) + 1);\n\t\t}\n\t\treturn dp1[sum] = res;\n\t}\n\n\tint dp2(int sum) {\n\t\tif (sum < 0) {\n\t\t\treturn 200;\n\t\t}\n\t\tif (sum == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp2[sum]) {\n\t\t\treturn dp2[sum];\n\t\t}\n\t\tint res = 200;\n\t\tfor (int i = 199; 1 <= i; i--) {\n\t\t\tif (tetra[i] % 2 == 0) continue;\n\t\t\tres = Math.min(res, dp2(sum - tetra[i]) + 1);\n\t\t}\n\t\treturn dp2[sum] = res;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\ttetra = new int[200];\n\t\tdp1 = new int[2000000];\n\t\tdp2 = new int[2000000];\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\ttetra[i] = i*(i+1)*(i+2)/6;\n\t\t}\n\n\t\tArrays.fill(dp1, -1);\n\t\tArrays.fill(dp2, -1);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.print(dp1(n) + \" \");\n\t\t\tSystem.out.println(dp2(n));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int min = Integer.MAX_VALUE;\n\tstatic int odd_min = Integer.MAX_VALUE;\n\tstatic int limit = 180;\n\n\t public static void main(String[] args)throws Exception{\n\n\t\t limit = 1000000;\n\n\t\t int[] dp = new int[limit];\n\t\t int[] dp_odd = new int[limit];\n\t\t \n\t\t for(int i=0;i<limit;i++)\n\t\t {\n\t\t\t dp[i]=i; \n\t\t\t dp_odd[i]=i;\n\t\t }\n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp[j] =j /frame; \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp[j] = Math.min(dp[j % frame] + count,dp[j]);\n\t\t\t }\n\t\t }\n\t\t \n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t if(frame % 2 ==0)\n\t\t\t\t continue;\n\t\t\t \n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp_odd[j] =j /frame; \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp_odd[j] = Math.min(dp_odd[j % frame] + count,dp_odd[j]);\n\t\t\t }\n\t\t }\n\t\t \n\n\t\t Scanner sc = new Scanner(System.in);\n\n\t\t while(true)\n\t\t {\n\t\t\t int n = sc.nextInt();\n\n\t\t\t if(n == 0)\n\t\t\t\t return;\n\n\t\t\t System.out.print(dp[n]);\n\t\t\t System.out.print(\" \");\n\t\t\t System.out.println(dp_odd[n]);\n\n\t\t }\n\n\t }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int INF=1<<26;\n\tfinal int[] vx={0,1,0,-1}, vy={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tnew Main().C();\n\t}\n\t\n\tvoid C(){\n\t\tArrayList<Integer> in=new ArrayList<Integer>();\n\t\tint max=0;\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tin.add(n);\n\t\t\tmax=max(max,n);\n\t\t}\n\t\t\n\t\tint[] k=new int[max+1],a=new int[max+1];\n\t\tArrays.fill(k, INF);\tArrays.fill(a, INF);\n\t\tfor(int n=1;;n++){\n\t\t\tint temp=n*(n+1)*(n+2)/6;\n\t\t\tif(temp>max)\tbreak;\n\t\t\ta[temp]=1;\n\t\t\tif(temp%2==1)\tk[temp]=1;\n\t\t}\n\t\t\n\t\tfor(int i=2; i<=max; i++){\n\t\t\tfor(int j=1; j*2<=i; j++){\n\t\t\t\ta[i]=min(a[i],a[j]+a[i-j]);\n\t\t\t\tk[i]=min(k[i],k[j]+k[i-j]);\n\t\t\t}\n\t\t}\n\t\t\n//\t\tSystem.out.println(\"K\");\n//\t\tfor(int i=1; i<=max; i++)\tSystem.out.print(k[i]+\" \");\n\t\t\n\t\tfor(int i:in){\n\t\t\tSystem.out.println(a[i]+\" \"+k[i]);\n\t\t}\n\t}\n\t\n\tvoid A(){\n\t\tfinal int[] xdis={-1,0,1,0}, ydis={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint n= sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<Integer, Integer[] > map = new HashMap<Integer, Integer[]>();\n\t\t\tInteger [] first = {0,0};\n\t\t\tmap.put(0, first);\n\t\t\tfor(int i=1; i < n; i++){\n\t\t\t\tint ni = sc.nextInt();\n\t\t\t\tint di = sc.nextInt();\n\t\t\t\tInteger [] now = map.get(ni);\n\t\t\t\tint newx = now[0] + xdis[di];\n\t\t\t\tint newy = now[1] + ydis[di];\n\t\t\t\tInteger [] newarray = {newx, newy};\n\t\t\t\tmap.put(i, newarray);\n\t\t\t}\n\t\t\tfirst = map.get(0);\n\t\t\tint minx =first[0];\n\t\t\tint maxx = minx;\n\t\t\tint miny = first[1];\n\t\t\tint maxy = first[1];\n\t\t\tfor(Integer now: map.keySet()){\n\t\t\t\tInteger [] nowarray = map.get(now);\n\t\t\t\tint x = nowarray[0];\n\t\t\t\tint y = nowarray[1];\n\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\tmaxx = Math.max(maxx, x);\n\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\tmaxy = Math.max(maxy, y);\n\t\t\t\t\n\t\t\t}\n\t\t\tint resx = maxx - minx +1;\n\t\t\tint resy = maxy - miny + 1;\n\t\t\tSystem.out.println(resx + \" \" + resy );\n\t\t}\n\t}\n\t\n\tvoid B(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tboolean[][] ww=new boolean[W*2+2][2*H+1],hh=new boolean[2*W+1][2*H+2];\n\t\t\tfor(int i=1; i<=H; i++){\n\t\t\t\tfor(int x=1; x<W; x++)\tww[2*x+1][i]=sc.nextInt()==1;\n\t\t\t\tif(i<H)\tfor(int y=1; y<=W; y++)\thh[y][2*i+1]=sc.nextInt()==1;\n\t\t\t}\n\t\t\t\n\t\t\t//disp(hh);\n\t\t\t\n\t\t\tPriorityQueue<CB> open=new PriorityQueue<CB>();\n\t\t\topen.add(new CB(1,1,1));\n\t\t\tint[][] close=new int[W+1][H+1];\n\t\t\tfor(int i=0; i<=W; i++)\tfor(int j=0; j<=H; j++)\tclose[i][j]=INF;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tCB now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i];\n\t\t\t\t\tif(!(0<xx && xx<=W && 0<yy && yy<=H))\tcontinue;\n\t\t\t\t\tint x2=(2*now.x+2*xx)/2,y2=(2*now.y+2*yy)/2;\n\t\t\t\t\tif(ww[x2][now.y] || hh[now.x][y2]){\n\t\t\t\t\t\t//System.out.println(x2+\" \"+y2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.s+1>=close[xx][yy])\tcontinue;\n\t\t\t\t\tif(xx==W && yy==H){\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new CB(xx,yy,now.s+1));\n\t\t\t\t\tclose[xx][yy]=now.s+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?0:ans));\n\t\t}\n\t}\n\tclass CB implements Comparable<CB>{\n\t\tint x,y,s;\n\t\tCB(int x,int y,int s){this.x=x; this.y=y;this.s=s;}\n\t\t@Override public int compareTo(CB o) {\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tvoid disp(boolean[][] b){\n\t\tfor(int y=0; y<b[0].length; y++){\n\t\t\tfor(int x=0; x<b.length; x++)\tSystem.out.print(b[x][y]?1:0);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    int[] all_num = new int[10000];\n    final static int max = 1000000;\n    int devise(int num){\n        int index = 0;\n        for(int i = 0;i < 1417;i++){\n            if(all_num[i] >= num){\n                index = i - 1;\n            }\n        }\n        return index;\n    }\n    void doteki(){\n        for(int i = 0; i < 10000;i++){\n            all_num[i] = ((i+1)*(i+2)*(i+3))/6;\n            if(all_num[i] < max){\n                //System.out.println(all_num[i]);\n            }\n            else\n                break;\n        }\n    }\n    boolean kisuu(int num){\n        if(num % 2 == 1){\n            return true;\n        }\n        return false;\n    }\n    void run() throws IOException{\n        //System.out.println(num);\n        doteki();\n        int num;\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            num = Integer.parseInt(in.readLine());\n            int index = 0;\n            int count = 0;\n            int ans = 0;\n            int ans_count = 32766;\n            if(num == 0){\n                break;\n            }\n            index = devise(num);\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(ans + all_num[j] > num){\n                        j--;\n                    }\n                    else if(ans + all_num[j] < num){\n                        ans += all_num[j];\n                        count++;\n                    }\n                    else if(ans + all_num[j] == num){\n                        count++;\n                        if(ans_count >= count){\n                            ans_count = count;\n                            count = 0;\n                        }\n                        break;\n                    }\n                }\n            }\n            System.out.print(ans_count);\n            //?\\???°??¨\n            count = 0;\n            ans = 0;\n            ans_count = 32766;\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(kisuu(all_num[j]) == true){\n                        if(ans + all_num[j] > num){\n                            j--;\n                        }\n                        else if(ans + all_num[j] < num){\n                            ans += all_num[j];\n                            count++;\n                        }\n                        else if(ans + all_num[j] == num){\n                            count++;\n                            if(ans_count >= count){\n                                ans_count = count;\n                                count = 0;\n                            }\n                            break;\n                        }\n                    }\n                    else{\n                        j--;\n                    }\n                }\n            }\n            System.out.print(\" \"+ans_count);\n            System.out.println();\n\n        }\n\n\n\n    }\n    public static void main(String[] args) throws IOException{\n        Main ma = new Main();\n        ma.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint MAX = 1000000;\n\t\tint[][] ans = new int[2][MAX];\n\t\tArrays.fill(ans[0], MAX * 2);\n\t\tArrays.fill(ans[1], MAX * 2);\n\t\tans[0][0] = ans[1][0] = 0;\n\t\tfor (int i = 1;; ++i) {\n\t\t\tint tetra = i * (i + 1) * (i + 2) / 6;\n\t\t\tif (tetra >= MAX) break;\n\t\t\tfor (int j = 0; j + tetra < MAX; ++j) {\n\t\t\t\tans[0][j + tetra] = Math.min(ans[0][j] + 1, ans[0][j + tetra]);\n\t\t\t}\n\t\t\tif (tetra % 2 != 0) {\n\t\t\t\tfor (int j = 0; j + tetra < MAX; ++j) {\n\t\t\t\t\tans[1][j + tetra] = Math.min(ans[1][j] + 1, ans[1][j + tetra]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tSystem.out.println(ans[0][N] + \" \" + ans[1][N]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define num 100000\n#define true 1\n#define false 0\n\nvoid pollock();\nint min(int f1,int f2);\nint *dp_ki;\nint *dp;\nint N;\n\nint main(){\n  dp_ki = (int *)malloc(num * sizeof(int));\n  dp = (int *)malloc(num * sizeof(int));\n  for(int i=0;i<num;i++){\n    dp[i]=i;\n    dp_ki[i]=i;\n  }\n  pollock();\n\n  while(scanf(\"%d\",&N),N){\n    printf(\"%d %d\\n\",dp[N],dp_ki[N] );\n  }\n\n  free(dp_ki);\n  free(dp);\n  exit(0);\n}\n\nint min(int f1,int f2){\n  if(f1>f2){\n    return f2;\n  }else{\n    return f1;\n  }\n}\n\nvoid pollock(){\n  for(int n=3,p=4;p<num;n++){\n    for(int i=0;i+p<num;i++){\n      dp[i+p] = min(dp[i+p],dp[i]+1);\n    }\n    if(p%2){\n      for(int i=0;i+p<num;i++){\n        dp_ki[i+p] = min(dp_ki[i+p],dp_ki[i]+1);\n      }\n    }\n    p= n*(n+1)*(n+2)/6;\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.util.*;\n\n\npublic class Main {\n\tstatic final long MOD=1000000007;\n\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\tint[] dp=new int[1000001];\n\t\tArrayList<Integer> arrayList=new ArrayList<>();\n\t\tArrayList<Integer> arrayListodd=new ArrayList<>();\n\t\tint n=1;\n\t\tint[] dp2=new int[1000001];\n\t\tArrays.fill(dp, Integer.MAX_VALUE/2);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE/2);\n\t\tdp[0]=0;\n\t\tdp2[0]=0;\n\t\twhile (n*(n+1)*(n+2)/6<=1000001) {\n\t\t\tif (n*(n+1)*(n+2)/6%2==1) {\n\t\t\t\tarrayListodd.add(n*(n+1)*(n+2)/6);\n\t\t\t}\n\t\t\tarrayList.add(n*(n+1)*(n+2)/6);\n\t\t\tn++;\n\t\t}\n\t\tfor (int i = 1; i < dp.length; i++) {\n\t\t\tfor (Integer integer : arrayList) {\n\t\t\t\tif (i-integer>=0) {\n\t\t\t\t\tdp[i]=Math.min(dp[i], dp[i-integer]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < dp2.length; i++) {\n\t\t\tfor (Integer integer : arrayListodd) {\n\t\t\t\tif (i-integer>=0) {\n\t\t\t\t\tdp2[i]=Math.min(dp2[i], dp2[i-integer]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (true) {\n\t\t\tint N=sc.nextInt();\n\t\t\tif (N==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tout.println(dp[N]+\" \"+dp2[N]);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\t\n\t\tsolve();\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tSystem.out.println(dp[0][n] +\" \" +dp[1][n]);\n\t\t}\n\t}\n\n\tint[][] dp = new int[2][1000001];\n\tpublic void solve() {\n\t\tint[] tetra = new int[200];\n\t\tfor(int i=1;i<tetra.length;i++){\n\t\t\ttetra[i] = i*(i+1)*(i+2)/6;\n\t\t}\n\t\t\n\t\t\n\t\tArrays.fill(dp[0], 10000);\n\t\tArrays.fill(dp[1], 10000);\n\t\tdp[0][0] = dp[1][0] =0;\n\t\tfor(int i=1;i<tetra.length;i++){\n\t\t\tint t = tetra[i];\n\t\t\tfor(int j=0;j<dp[0].length-t;j++){\n\t\t\t\tdp[0][j+t] = Math.min(dp[0][j+t], dp[0][j]+1);\n\t\t\t\tif(t%2==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[1][j+t] = Math.min(dp[1][j+t], dp[1][j]+1);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n \n \npublic class Main {\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        //181\n        \n        int[] tetranum = new int[180];\n        int odd_n = 0;\n        \n    \tfor(int i=0; i<180; i++){\n    \t    tetranum[i] = i+1;\n    \t    tetranum[i] *= (i+2);\n    \t    tetranum[i] *= (i+3);\n    \t    tetranum[i] /= 6;\n    \t    if(tetranum[i]%2 == 1) odd_n++;\n    \t}\n        \n        int[] odd_tetra = new int[odd_n];\n        int moving = 0;\n        \n    \tfor(int i=0; i<180; i++){\n    \t    if(tetranum[i]%2==1){\n    \t        odd_tetra[moving] = tetranum[i];\n    \t        moving++;\n    \t    }\n    \t}\n    \t\n        int[] dp = new int[1000010];     //iを表す時の個数のmin\n        int[] oddp = new int[1000010];     //iを表す時の個数のmin\n        \n        dp[0]=0;\n        for(int j=1; j<1000010; j++){\n            dp[j] = -1;  //don't know\n        }\n        \n        oddp[0]=0;\n        for(int j=1; j<1000010; j++){\n            oddp[j] = -1;  //don't know\n        }\n        \n        boolean all_fin=false;\n        moving=0;\n        while(!all_fin){\n            all_fin=true;\n            for(int j=1; j<1000010; j++){\n                if(dp[j] < 0){\n    \t            for(int i=0; i<180; i++){\n    \t                if(tetranum[i] <= j){\n    \t                    if(dp[j-tetranum[i]] == moving){\n    \t                        dp[j] = moving+1;\n    \t                    }\n    \t                }\n    \t            }\n    \t            all_fin=false;\n                }\n            }\n            moving++;\n        }\n        \n        all_fin=false;\n        moving=0;\n        while(!all_fin){\n            all_fin=true;\n            for(int j=1; j<1000010; j++){\n                if(oddp[j] < 0){\n    \t            for(int i=0; i<odd_n; i++){\n    \t                if(odd_tetra[i] <= j){\n    \t                    if(oddp[j-odd_tetra[i]] == moving){\n    \t                        oddp[j] = moving+1;\n    \t                    }\n    \t                }\n    \t            }\n    \t            all_fin=false;\n                }\n            }\n            moving++;\n        }\n        \n        int a=0;\n        while(true){\n            a = sc.nextInt();\n            if(a==0) break;\n            out.println(dp[a]+\" \"+oddp[a]);\n        }\n        \n        \n        out.flush();\n    }\n    \n    private static int minExcept(int[] dt, int ex){\n        int min=Integer.MAX_VALUE;\n        \n    \tfor(int i=0; i<dt.length; i++){\n    \t    if((i != ex) && (dt[i] < min)) min = dt[i];\n    \t}\n    \treturn min;\n    }\n    \n    private static int abs(int a){\n        if(a>=0) return a;\n        else return -a;\n    }\n    private static int min(int a, int b){\n        if(a>b) return b;\n        else return a;\n    }\n    private static int min2(int... ins){\n        int min = ins[0];\n        \n    \tfor(int i=1; i<ins.length; i++){\n    \t    if(ins[i] < min) min = ins[i];\n    \t}\n    \treturn min;\n    }\n    private static int max(int a, int b){\n        if(a>b) return a;\n        else return b;\n    }\n    private static int max2(int... ins){\n        int max = ins[0];\n        \n    \tfor(int i=1; i<ins.length; i++){\n    \t    if(ins[i] > max) max = ins[i];\n    \t}\n    \treturn max;\n    }\n    \n    \n    static void show_i2d_array(long[][] dt){\n        PrintWriter out = new PrintWriter(System.out);\n    \tfor(int i=0; i<dt[0].length; i++){\n    \t\tfor(int j=0; j<dt.length; j++){\n    \t\t    out.print(dt[j][i]+\",\");\n    \t\t}\n    \t\tout.println(\"<-city=\"+i);\n    \t}\n    \tout.flush();\n    }\n    \n    public static void combSort(int[][] origin, int ln){\n        int h=ln*10/13, tmp=0;\n        boolean fin=true;\n        while((h>1)||(!fin)){\n            fin=true;\n            for(int i=0; i < ln-h; i++){\n                if(origin[i][0] > origin[i+h][0]){\n                    tmp=origin[i][0];\n                    origin[i][0]=origin[i+h][0];\n                    origin[i+h][0]=tmp;\n                    tmp=origin[i][1];\n                    origin[i][1]=origin[i+h][1];\n                    origin[i+h][1]=tmp;\n                    fin=false;\n                }\n            }\n            h *=10;\n            h/=13;\n        }\n    }\n}\n \nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    public boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() { return Double.parseDouble(next());}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(solve(input));\n\t\t}\n\t}\n\n\tpublic static String solve(int input) {\n\t\tint c = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tc = i;\n\t\t\tlist.add((i*(i+1)*(i+2))/6);\n\t\t}\n\n\t\tint[][] dp = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return dp[input-1][c-1];\n\n\t\tint c2 = 0;\n\t\tArrayList list2 = new ArrayList();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tif(((i*(i+1)*(i+2)/6) % 2) != 0) {\n\t\t\t\tc2++;\n\t\t\t\tlist2.add((i*(i+1)*(i+2))/6);\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp2 = new int[input][c2];\n\n\t\tfor(int i=0 ; i<c2 ; i++) {\n\t\t\tint v2 = Integer.parseInt(list2.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp2[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v2) == 0) {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2), dp2[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v2) {\n\t\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2)+dp2[((j+1)%v2) - 1][i-1], dp2[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[input-1][c-1] + \" \" + dp2[input-1][c2-1];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tint ele = 0;\n\t\tfor (int i = 1; ele < 1000000; i++) {\n\t\t\tele = i * (i + 1) * (i + 2) / 6;\n\t\t\tlist.add(ele);\n\t\t}\n\t\tint[] dp = new int[1000000];\n\t\tint[] dp2 = new int[1000000];\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < 1000000; i++) {\n\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\tif (i - list.get(j) >= 0) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - list.get(j)] + 1);\n\t\t\t\t\tif (list.get(j) % 2 == 1) {\n\t\t\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i - list.get(j)] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(dp[n] + \" \" + dp2[n]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int lim) {\n\t\treturn 0 <= h && h < lim && 0 <= w && w < lim;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\nimport java.text.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tArrayList<Integer> tri = new ArrayList<Integer>();\n\t\tfor(int i=1; ; i++){\n\t\t\tif(i*(i+1)*(i+2)/6>1000000) break;\n\t\t\ttri.add(i*(i+1)*(i+2)/6);\n\t\t}\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t// use all trinumber\n\t\t\tint k=-1;\n\t\t\tfor(int i=0; tri.get(i)<=n && i<tri.size()-1; i++){\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tint ans = 1000000;\n\t\t\tint begin = k;\n\t\t\tdo{\n\t\t\t\tint start = k;\n\t\t\t\tint preans = 0;\n\t\t\t\tint caln = n;\n\t\t\t\twhile(caln!=0){\n\t\t\t\t\tif(caln>=tri.get(start)){\n\t\t\t\t\t\tcaln = caln-tri.get(start);\n\t\t\t\t\t\tpreans++;\n\t\t\t\t\t}\n\t\t\t\t\telse start--;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t\tif(ans>preans) ans = preans;\n\t\t\t}while(n<tri.get(k)*ans);\n\n\t\t\tint ans2 = 1000000;\n\t\t\tdo{\n\t\t\t\tint start = begin;\n\t\t\t\tint preans = 0;\n\t\t\t\tint caln = n;\n\t\t\t\twhile(caln!=0){\n\t\t\t\t\tif(caln>=tri.get(start) && tri.get(start)%2==1){\n\t\t\t\t\t\tcaln = caln-tri.get(start);\n\t\t\t\t\t\tpreans++;\n\t\t\t\t\t}\n\t\t\t\t\telse start--;\n\t\t\t\t}\n\t\t\t\tk--;\n\t\t\t\tif(ans2>preans) ans2 = preans;\n\t\t\t\tif(k<0) break;\n\t\t\t}while(n<tri.get(k)*ans2);\n\t\t\t\n\t\t\tSystem.out.println(ans+\" \"+ans2);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\twhile(true) {\n\t\t\tint n = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\t\n\t\t\tint tmp = n;\n\t\t\tint c = 0;\n\t\t\tqueue.removeAll(queue);\n\t\t\tint ans = solv(n);\n\t\t\tIN:while(true) {\n\t\t\tfor(int i = oddList.size()-1; i >= 0; i--) {\n\t\t\t\t\tif(oddList.get(i) <= tmp) {\n\t\t\t\t\t\ttmp -= oddList.get(i);\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp == 0) {\n\t\t\t\t\t\tbreak IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans + \" \" + c);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\tpublic static ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\tpublic static int solv(int a) {\n\t\tint ans = 0;\n\t\tqueue.add(new Data(a,0,0));\n\t\twhile(true) {\n\t\t\tint ax = bfs(queue.poll());\n\t\t\tif(ax != 0) {\n\t\t\t\treturn ax;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int  bfs(Data a) {\n\t\tif(a.a == a.b) return a.c;\n\t\tif(a.a < a.b) return 0;\n\t\tfor(int i = 0; i < list.size(); i++) {\n\t\t\tqueue.add(new Data(a.a,a.b + list.get(i),a.c+1));\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 1000000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 100000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\nclass Data {\n\tint a;\n\tint b;\n\tint c;\n\tData(int d, int e, int f) {\n\t\ta = d;\n\t\tb = e;\n\t\tc = f;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\t\n\tpublic void run() {\n\t\tdp[1] = 1;\n\t\tdpK[1] = 1;\n\t\tfor(int i = 1; i < 1000001; i++){\n\t\t\tcalcDP(i);\n\t\t\tcalcDPK(i);\n\t\t}\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0 )break;\n\t\t\telse calc(n);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int n){\n\t\tSystem.out.println(dp[n] + \" \" + dpK[n]);\n\t}\n\tint[] dp = new int[1000001];\n\tpublic int calcDP(int n){\n\t\tif(n == 0) return 0;\n\t\telse if(dp[n] != 0) return dp[n];\n\t\telse{\n\t\t\tint min = 10;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\t\tif(n - t < 0) break;\n\t\t\t\tint m;\n\t\t\t\tif(dp[n-t] != 0) m = dp[n-t] + 1;\n\t\t\t\telse m = calcDP(n - t) + 1;\n\t\t\t\tif(m < min) \n\t\t\t\t\tmin = m;\n\t\t\t}\n\t\t\tdp[n] = min;\n\t\t\treturn dp[n];\n\t\t}\n\t}\n\tint[] dpK = new int[1000001];\n\tpublic int calcDPK(int n){\n\t\tif(n == 0) return 0;\n\t\telse if(dpK[n] != 0) return dpK[n];\n\t\telse{\n\t\t\tint min = 10000000;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tint t = i * (i + 1) * (i + 2) / 6;\n\t\t\t\tif(n - t < 0) break;\n\t\t\t\tif(t % 2 == 1){\n\t\t\t\t\tint m;\n\t\t\t\t\tif(dpK[n-t] != 0) m = dpK[n-t] + 1;\n\t\t\t\t\telse m = calcDPK(n - t) + 1;\n\t\t\t\t\tif(m < min) min = m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdpK[n] = min;\n\t\t\treturn dpK[n];\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\n\tstatic void solve() {\n\t\tint[][] dp=new int[(int)1e6+1][2];\n\t\tint[] tet=new int[1001];\n\t\tint[] tet2=new int[500];\n\t\tfor(int i=0;i<=1000;i++)\n\t\t\ttet[i]=i*(i+1)*(i+2)/6;\n\t\tfor(int i=0;i<500;i++)\n\t\t\ttet2[i]=tet[i*2+1];\n\t\tfor(int i=1;i<=(int)1e6;i++)\n\t\t\tArrays.fill(dp[i],Integer.MAX_VALUE);\n\t\tfor(int i=1;i<=(int)1e6;i++){\n\t\t\tfor(int j=1;j*(j+1)*(j+2)<=6*i;j++){\n\t\t\t\tdp[i][0]=Math.min(dp[i][0],dp[i-j*(j+1)*(j+2)/6][0]+1);\n\t\t\t\tif(j%2==1&&j*(j+1)*(j+2)!=6*i)\n\t\t\t\t\tdp[i][1]=Math.min(dp[i][1],dp[i-j*(j+1)*(j+2)/6][1]+1);\n\t\t\t}\n\t\t}\n\t\tfor(;;){\n\t\t\tint n=ir.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tout.println(dp[n][0]+\" \"+dp[n][1]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n    int[] all_num = new int[10000];\n    final static int max = 1000000;\n    int devise(int num){\n        int index = 0;\n        for(int i = 0;i < 1417;i++){\n            if(all_num[i] >= num){\n                index = i - 1;\n            }\n        }\n        return index;\n    }\n    void doteki(){\n        for(int i = 0; i < 10000;i++){\n            all_num[i] = ((i+1)*(i+2)*(i+3))/6;\n            if(all_num[i] < max){\n                //System.out.println(all_num[i]);\n            }\n            else\n                break;\n        }\n    }\n    boolean kisuu(int num){\n        if(num % 2 == 1){\n            return true;\n        }\n        return false;\n    }\n    void run() throws IOException{\n        //System.out.println(num);\n        doteki();\n        int num;\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            num = Integer.parseInt(in.readLine());\n            int index = 0;\n            int count = 0;\n            int ans = 0;\n            int ans_count = 10000;\n            if(num == 0){\n                break;\n            }\n            index = devise(num);\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(ans + all_num[j] > num){\n                        j--;\n                    }\n                    else if(ans + all_num[j] < num){\n                        ans += all_num[j];\n                        count++;\n                    }\n                    else if(ans + all_num[j] == num){\n                        count++;\n                        if(ans_count >= count){\n                            ans_count = count;\n                            count = 0;\n                        }\n                        break;\n                    }\n                }\n            }\n            System.out.print(ans_count);\n            //?\\???°??¨\n            count = 0;\n            ans = 0;\n            ans_count = 32766;\n            for(int i = index;i > -1;i--){\n                ans = 0;\n                for(int j = i;j > -1;){\n                    if(kisuu(all_num[j]) == true){\n                        if(ans + all_num[j] > num){\n                            j--;\n                        }\n                        else if(ans + all_num[j] < num){\n                            ans += all_num[j];\n                            count++;\n                        }\n                        else if(ans + all_num[j] == num){\n                            count++;\n                            if(ans_count >= count){\n                                ans_count = count;\n                                count = 0;\n                            }\n                            break;\n                        }\n                    }\n                    else{\n                        j--;\n                    }\n                }\n            }\n            System.out.print(\" \"+ans_count);\n            System.out.println();\n\n        }\n\n\n\n    }\n    public static void main(String[] args) throws IOException{\n        Main ma = new Main();\n        ma.run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(solve(input));\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static String solve(int input) {\n\t\tint c = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tc = i;\n\t\t\tlist.add((i*(i+1)*(i+2))/6);\n\t\t}\n\n\t\tint[][] dp = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return dp[input-1][c-1];\n\n\t\tint c2 = 0;\n\t\tArrayList list2 = new ArrayList();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tif(((i*(i+1)*(i+2)/6) % 2) != 0) {\n\t\t\t\tc2++;\n\t\t\t\tlist2.add((i*(i+1)*(i+2))/6);\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp2 = new int[input][c2];\n\n\t\tfor(int i=0 ; i<c2 ; i++) {\n\t\t\tint v2 = Integer.parseInt(list2.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp2[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v2) == 0) {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2), dp2[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v2) {\n\t\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2)+dp2[((j+1)%v2) - 1][i-1], dp2[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[input-1][c-1] + \" \" + dp2[input-1][c2-1];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] min = new int[1000000 + 1];\n\tstatic int[] oddmin = new int[1000000 + 1];\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tArrays.fill(min, -1);\n\t\tmin[1] = 1;\n\t\tArrays.fill(oddmin, -1);\n\t\toddmin[1] = 1;\n\t\twhile(n != 0){\n\t\t\tSystem.out.println(func(n) + \" \" + oddfunc(n));\n\t\t\tn = sc.nextInt();\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\tstatic int func(int n){\n\t\tif(min[n] > 0){\n\t\t\treturn min[n];\n\t\t}\n\t\tint res = 20000;\n\t\tint tmp = n;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\ttmp = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(n == tmp){\n\t\t\t\tmin[n] = 1;\n\t\t\t\treturn min[n];\n\t\t\t}else if(n > tmp){\n\t\t\t\tres = Math.min(res, func(n - tmp) + 1);\n\t\t\t}else if(n < tmp){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmin[n] = res;\n\t\treturn res;\n\t}\n\tstatic int oddfunc(int n){\n\t\tif(oddmin[n] > 0){\n\t\t\treturn oddmin[n];\n\t\t}\n\t\tint res = 20000;\n\t\tint tmp = n;\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\ttmp = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(tmp % 2 != 0){\n\t\t\t\tif(n == tmp){\n\t\t\t\t\toddmin[n] = 1;\n\t\t\t\t\treturn oddmin[n];\n\t\t\t\t}else if(n > tmp){\n\t\t\t\t\tres = Math.min(res, oddfunc(n - tmp) + 1);\n\t\t\t\t}else if(n < tmp){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toddmin[n] = res;\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tprivate static final int INF = 1000001;\n\n\tpublic static void main(String[] args) {\n\t\tint[] pollock = new int[180];// 180*181*182/6が条件内で最大の正四面体数\n\t\tfor (int i = 1; i <= pollock.length; i++) {\n\t\t\tpollock[i - 1] = (i * (i + 1) * (i + 2)) / 6;\n\t\t}\n\n\t\tint[][] dp = new int[2][INF];// dp[奇数？][jを作るのに必要な正四面体数の数の最小値]\n\t\tArrays.fill(dp[0], Integer.MAX_VALUE);// 全部用\n\t\tArrays.fill(dp[1], Integer.MAX_VALUE);// 奇数用\n\n\t\t// 最初は0\n\t\tdp[0][0] = 0;\n\t\tdp[1][0] = 0;\n\n\t\tfor (int i = 0; i < pollock.length; i++) {\n\t\t\tfor (int j = pollock[i]; j < INF; j++) {\n\t\t\t\t// 各pollock数について、調べる\n\t\t\t\tdp[0][j] = Math.min(dp[0][j], dp[0][j - pollock[i]] + 1);\n\t\t\t\tif (pollock[i] % 2 == 1) {\n\t\t\t\t\t// pollock数が奇数の時\n\t\t\t\t\tdp[1][j] = Math.min(dp[1][j], dp[1][j - pollock[i]] + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint N = nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSystem.out.println(dp[0][N] + \" \" + dp[1][N]);\n\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nextChar() {\n\t\ttry {\n\t\t\tint b = System.in.read();\n\t\t\twhile (b != -1 && (b == ' ' || b == '\\r' || b == '\\n'))\n\t\t\t\t;\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] arrs){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\tArrayList<Integer> pollock = new ArrayList<Integer>();\n\t\tArrayList<Integer> pollockk = new ArrayList<Integer>();\n\n\t\tint pollocknum = 0;\n\t\tint[] pollocktrue = new int[1000000 + 1];\n\t\tint[] pollocktrue2 = new int[1000001];\n\t\tArrays.fill(pollocktrue, Integer.MAX_VALUE/2);\n\t\tArrays.fill(pollocktrue2, Integer.MAX_VALUE/2);\n\t\t\n\t\tfor(int i = 1; pollocknum <= 1000000 - 1; i++){\n\t\t\tpollock.add(pollocknum); \n\t\t\tpollocktrue2[pollocknum] = 1;\n\t\t\tif(pollocknum%2 != 0){\n\t\t\t\tpollocktrue[pollocknum] = 1;\n\t\t\t\tpollockk.add(pollocknum);\n\t\t\t}\n\t\t\tpollocknum = (i * (i + 1) * (i + 2)) / 6;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < pollockk.size();i++){\n\t\t\tfor(int j = 0 ; j < pollocktrue.length; j++){\n\t\t\t\tif(j + pollockk.get(i) <= 1000000){\n\t\t\t\t\tpollocktrue[j + pollockk.get(i)] = Math.min(pollocktrue[j + pollockk.get(i)], pollocktrue[j] + 1); \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(int i = 0; i < pollock.size();i++){\n\t\t\tfor(int j = 0 ; j < pollocktrue2.length; j++){\n\t\t\t\tif(j + pollock.get(i) <= 1000000){\n\t\t\t\t\tpollocktrue2[j + pollock.get(i)] = Math.min(pollocktrue2[j + pollock.get(i)], pollocktrue2[j] + 1); \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tSystem.out.println(pollocktrue2[n]+ \" \"+ pollocktrue[n]);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tfor (int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; i++) {\n\t\t\tlist.add(i * (i + 1) * (i + 2) / 6);\n\t\t}\n\t\tint n = list.size();\n\t\tint m = 1000000;\n\t\tint[] dp1 = new int[m];\n\t\tint[] dp2 = new int[m];\n\t\tArrays.fill(dp1, Integer.MAX_VALUE);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\tdp1[0] = 0;\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (j - list.get(i) >= 0) {\n\t\t\t\t\tdp1[j] = Math.min(dp1[j], dp1[j - list.get(i)] + 1);\n\t\t\t\t\tif (list.get(i) % 2 == 1) {\n\t\t\t\t\t\tdp2[j] = Math.min(dp2[j], dp2[j - list.get(i)] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;;) {\n\t\t\tint ball = sc.nextInt();\n\t\t\tif (ball == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(dp1[ball] + \" \" + dp2[ball]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint[] tetra;\n\tint ans;\n\n\tvoid bt(int k, int count, int sum, int flg) {\n\t\tif (ans < count) {\n\t\t\treturn;\n\t\t}\n\t\tif (sum < 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (sum == 0) {\n\t\t\tans = count;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = k; 1 <= i; i--) {\n\t\t\tif (flg == 1 && tetra[i] % 2 == 0) continue;\n\t\t\tbt(i, count + 1, sum - tetra[i], flg);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\ttetra = new int[200];\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\ttetra[i] = i*(i+1)*(i+2)/6;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans = 1000;\n\t\t\tbt(199, 0, n, 0);\n\t\t\tSystem.out.print(ans + \" \");\n\t\t\tans = 1000;\n\t\t\tbt(199, 0, n, 1);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport javax.naming.BinaryRefAddr;\n\nimport static java.lang.System.*;\n\nclass Main {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n\n\n    public void run() {\n    \tList<Integer> pollock=new ArrayList<Integer>();\n\n    \tfor(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    \t\tpollock.add(i*(i+1)*(i+2)/6);\n    \t}\n\n    \tList<Integer> pollock2=new ArrayList<Integer>();\n    \tfor(int i=0;i<pollock.size();i++){\n    \t\tfor(int j=i;j<pollock.size();j++){\n    \t\t\tpollock2.add(pollock.get(i)+pollock.get(j));\n    \t\t}\n    \t}\n    \tCollections.sort(pollock2);\n\n    \twhile(true){\n        \tint n=sc.nextInt();\n        \tif(n==0)return;\n\n        \tint n1=n,n1c=10;\n        \tfor(int i1=0,v1=pollock.get(i1);v1<=n;v1=pollock.get(++i1)){\n        \t\tif(v1==n1)n1c=Math.min(1,n1c);\n        \t\tfor(int i2=i1,v2=pollock.get(i2);v2<=n-v1;v2=pollock.get(++i2)){\n            \t\tif(v1+v2==n1)n1c=Math.min(2,n1c);\n            \t\tif(Collections.binarySearch(pollock2,n-v1-v2)>=0){\n            \t\t\tn1c=Math.min(4,n1c);\n            \t\t}\n        \t\t\tfor(int i3=i2,v3=pollock.get(i3);v3<=n-v1-v2;v3=pollock.get(++i3)){\n                \t\tif(v1+v2+v3==n1)n1c=Math.min(3,n1c);\n                \t\tif(Collections.binarySearch(pollock2,n-v1-v2-v3)>=0){\n                \t\t\tn1c=Math.min(5,n1c);\n                \t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        \tint n2=n,n2c=0;\n        \tfor(int j=pollock.size()-1;j>=0;j--){\n        \t\tint v=pollock.get(j);\n        \t\tif(v%2==1){\n        \t\t\twhile(n2>=v){\n\t        \t\t\tn2-=v;\n        \t\t\t\tn2c++;\n        \t\t\t}\n        \t\t\tif(n2==0){\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n\n        \tln(n1c+\" \"+n2c);\n\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public int[] nextIntArray(int n){\n        int[] res=new int[n];\n        for(int i=0;i<n;i++){\n            res[i]=sc.nextInt();\n        }\n        return res;\n    }\n    public static void pr(Object o) {\n        out.print(o);\n    }\n    public static void ln(Object o) {\n        out.println(o);\n    }\n    public static void ln() {\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint[] tetra;\n\tint ans;\n\tint[] dp;\n\n\tint dp(int sum, boolean flg) {\n\t\tif (sum < 0) {\n\t\t\treturn 200;\n\t\t}\n\t\tif (sum == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp[sum]) {\n\t\t\treturn dp[sum];\n\t\t}\n\t\tint res = 200;\n\t\tfor (int i = 1; i < 200; i++) {\n\t\t\tif (flg && tetra[i] % 2 == 0) continue;\n\t\t\tres = Math.min(res, dp(sum - tetra[i], flg) + 1);\n\t\t}\n\t\treturn dp[sum] = res;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\ttetra = new int[200];\n\t\tdp = new int[200];\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\ttetra[i] = i*(i+1)*(i+2)/6;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tArrays.fill(dp, -1);\n\t\t\tSystem.out.print(dp(n, false) + \" \");\n\t\t\tArrays.fill(dp, -1);\n\t\t\tSystem.out.println(dp(n, true));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[] dp;\n\tstatic int[] odp;\n\tstatic int n;\n\tstatic int INF = 1 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tmakeList();\t\t\n\t\tdp = new int[1000001];\n\t\todp = new int[1000001];\n\t\tArrays.fill(dp, INF);\n\t\tArrays.fill(odp, INF);\n\t\tdp[0] = odp[0] = 0;\n\t\tdp();\n\t\toddDp();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n];\n\t\t\tansB = odp[n];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= 1000000; i++) {\n\t\t\tfor(int j = 0; j < list.size(); j++) {\n\t\t\t\tint a = list.get(j);\n\t\t\t\tif(i - a < 0) break;\n\t\t\t\tif(dp[i - a] + 1 < dp[i]) {\n\t\t\t\t\tdp[i] = dp[i-a] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= 1000000; i++) {\n\t\t\tfor(int j = 0; j < oddList.size(); j++) {\n\t\t\t\tint a = oddList.get(j);\n\t\t\t\tif(i - a < 0) break;\n\t\t\t\tif(odp[i - a]+1 < odp[i]) {\n\t\t\t\t\todp[i] = odp[i-a]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 182; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\ta /= 6;\n\t\t\t\tlist.add(a);\n\t\t\t\tif(a % 2 == 1) {\n\t\t\t\t\toddList.add(a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] arrs){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\tArrayList<Integer> pollock = new ArrayList<Integer>();\n\t\tArrayList<Integer> pollockk = new ArrayList<Integer>();\n\n\t\tint pollocknum = 0;\n\t\tint[] pollocktrue = new int[1000000 + 1];\n\t\tint[] pollocktrue2 = new int[1000001];\n\t\tArrays.fill(pollocktrue, Integer.MAX_VALUE/2);\n\t\tArrays.fill(pollocktrue2, Integer.MAX_VALUE/2);\n\t\t\n\t\tfor(int i = 1; pollocknum <= 1000000 - 1; i++){\n\t\t\tpollock.add(pollocknum); \n\t\t\tpollocktrue2[pollocknum] = 1;\n\t\t\tif(pollocknum%2 != 0){\n\t\t\t\tpollocktrue[pollocknum] = 1;\n\t\t\t\tpollockk.add(pollocknum);\n\t\t\t}\n\t\t\tpollocknum = (i * (i + 1) * (i + 2)) / 6;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < pollockk.size();i++){\n\t\t\tfor(int j = 0 ; j < pollocktrue.length; j++){\n\t\t\t\tif(j + pollockk.get(i) <= 1000000){\n\t\t\t\t\tpollocktrue[j + pollockk.get(i)] = Math.min(pollocktrue[j + pollockk.get(i)], pollocktrue[j] + 1); \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfor(int i = 0; i < pollock.size();i++){\n\t\t\tfor(int j = 0 ; j < pollocktrue2.length; j++){\n\t\t\t\tif(j + pollock.get(i) <= 1000000){\n\t\t\t\t\tpollocktrue2[j + pollock.get(i)] = Math.min(pollocktrue2[j + pollock.get(i)], pollocktrue2[j] + 1); \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(pollocktrue2[n]+ \" \"+ pollocktrue[n]);\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1167();\n\t}\n\t\n\tclass AOJ1167{\n\t\tint[] a1,a2,dp1,dp2;\n\t\tAOJ1167(){\n\t\t\tinitialize();\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tSystem.out.println(dp1[n]+\" \"+dp2[n]);\n\t\t\t}\n\t\t}\n\t\tvoid initialize(){\n\t\t\tfinal int MAX=1000000;\n\t\t\ta1=new int[200];\n\t\t\ta2=new int[50];\n\t\t\tfor(int i=1,i2=1; true; ++i){\n\t\t\t\tint tmp=i*(i+1)*(i+2)/6;\n\t\t\t\ta1[i]=tmp;\n\t\t\t\tif(tmp%2==1)\ta2[i2++]=tmp;\n\t\t\t\tif(tmp>MAX){\n\t\t\t\t\ta1[i+1]=MAX;\n\t\t\t\t\ta2[i2+1]=MAX;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp1=new int[MAX];\n\t\t\tdp2=new int[MAX];\n\t\t\tfor(int i=1; i<MAX; ++i){\n\t\t\t\tdp1[i]=MAX;\n\t\t\t\tdp2[i]=MAX;\n\t\t\t}\n\t\t\tfor(int i=1; a1[i]<MAX; ++i)for(int j=0; j<MAX; ++j)\tdp1[j]=min(dp1[j], j<a1[i]? dp1[j]: dp1[j-a1[i]]+1);\n\t\t\tfor(int i=1; a2[i]<MAX; ++i)for(int j=0; j<MAX; ++j)\tdp2[j]=min(dp2[j], j<a2[i]? dp2[j]: dp2[j-a2[i]]+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tprivate static int[] dp = new int[1000010];\n\tprivate static int[] dp2 = new int[1000010];\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t//ツスツタツッツクツオツーツバツーツフツδ債ーツ妥開ツ用\n\t\tfor(int i=1;i<=1000000;i+=100){\n\t\t\tsolve(i);\n\t\t\tsolve2(i);\n\t\t}\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tSystem.out.println(dp[n]+\" \"+dp2[n]);\n\t\t}\n\t}\n\n\tprivate static int solve(int n){\n\t\tif(n == 0) return 0;\n\t\tif(dp[n] != 0) return dp[n];\n\n\t\tint tmp = 0, res = Integer.MAX_VALUE;\n\t\tfor(int i=1;(tmp=i*(i+1)*(i+2)/6)<=n;i++){\n\t\t\tres = Math.min(res,solve(n-tmp));\n\t\t}\n\n\t\treturn dp[n]=(res+1);\n\t}\n\n\tprivate static int solve2(int n){\n\t\tif(n == 0) return 0;\n\t\tif(dp2[n] != 0) return dp2[n];\n\n\t\tint tmp = 0, res = Integer.MAX_VALUE;\n\t\tfor(int i=1;(tmp=i*(i+1)*(i+2)/6)<=n;i++){\n\t\t\tif(tmp % 2 == 1)\n\t\t\t\tres = Math.min(res,solve2(n-tmp));\n\t\t}\n\n\t\treturn dp2[n]=(res+1);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class AOJ_1167 {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tint ele = 0;\n\t\tfor (int i = 1; ele < 1000000; i++) {\n\t\t\tele = i * (i + 1) * (i + 2) / 6;\n\t\t\tlist.add(ele);\n\t\t}\n\t\tint[] dp = new int[1000000];\n\t\tint[] dp2 = new int[1000000];\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\tdp[0] = 0;\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < 1000000; i++) {\n\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\tif (i - list.get(j) >= 0) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - list.get(j)] + 1);\n\t\t\t\t\tif (list.get(j) % 2 == 1) {\n\t\t\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i - list.get(j)] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(dp[n] + \" \" + dp2[n]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew AOJ_1167().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int lim) {\n\t\treturn 0 <= h && h < lim && 0 <= w && w < lim;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(solve(input));\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static String solve(int input) {\n\t\tint c = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tc = i;\n\t\t\tlist.add((i*(i+1)*(i+2))/6);\n\t\t}\n\n\t\tint[][] dp = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return dp[input-1][c-1];\n\t\tint re = dp[input-1][c-1];\n\t\tdp = null;\n\t\tdp = new int[input][c];\n\n\t\tint[][] dp2 = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v2 = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(v2%2 == 0 && v2!=1) {\n\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t}else{\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp2[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v2) == 0) {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2), dp2[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v2) {\n\t\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2)+dp2[((j+1)%v2) - 1][i-1], dp2[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn re + \" \" + dp2[input-1][c-1];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint max=1000001;\n\n\tint[] dp1, a;\n\tint n;\n\n\tvoid run(){\n\t\tmax=10000;\n\t\tdp1=new int[max];\n\t\ta=new int[max];\n\n\t\tfill(dp1, INF);\n\t\tdp1[0]=0;\n\t\tfor(int j=0; j<5; j++){\n\t\t\tSystem.arraycopy(dp1, 0, a, 0, max);\n\t\t\tfor(int k=0; k*(k+1)*(k+2)/6<max; k++){\n\t\t\t\tint m=k*(k+1)*(k+2)/6;\n\t\t\t\tfor(int i=0; i+m<max; i++){\n\t\t\t\t\tdp1[i+m]=min(dp1[i+m], a[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint[] dp2=new int[n+1];\n\t\tfill(dp2, INF);\n\t\tdp2[0]=0;\n\t\tfor(int j=0;; j++){\n\t\t\tSystem.arraycopy(dp2, 0, a, 0, n+1);\n\t\t\tfor(int k=0; k*(k+1)*(k+2)/6<n+1; k++){\n\t\t\t\tint m=k*(k+1)*(k+2)/6;\n\t\t\t\tif(m%2==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i+m<n+1; i++){\n\t\t\t\t\tdp2[i+m]=min(dp2[i+m], a[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug(dp);\n\t\t\tif(dp2[n]<INF){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintln(dp1[n]+\" \"+dp2[n]);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[][] dp;\n\tstatic int n;\n\tstatic int INF = 2 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\tdp = new int[n+1][list.size()+1];\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][0] = 0;\n\t\t\tdp();\n\t\t\tansA = dp[n][list.size()];\n\t\t\tdp = new int[n+1][oddList.size()+1];\n\t\t\tSystem.gc();\n\t\t\tfor(int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][0] = 0;\n\t\t\toddDp();\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-list.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-oddList.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 500000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n \npublic class Main {\n     \n\tstatic int N;\n\tstatic int max;\n\t\n\tstatic void bfs1()\n\t{\n\t\tLinkedList<Integer> sum = new LinkedList<Integer>();\n\t\tLinkedList<Integer> num = new LinkedList<Integer>();\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\t\n\t\tfor (int i = max; i >= 1; i--) {\n\t\t\tsum.offer(new Integer(0));\n\t\t\tnum.offer(new Integer(i));\n\t\t\tindex.offer(new Integer(1));\n\t\t}\n\t\t\n\t\twhile (!sum.isEmpty()) {\n\t\t\tint ss = sum.poll().intValue();\n\t\t\tint nn = num.poll().intValue();\n\t\t\tint ii = index.poll().intValue();\n\t\t\t\n\t\t\tss += nn * (nn + 1) * (nn + 2) / 6;\n\t\t\tif(ss == N)\n\t\t\t{\n\t\t\t\tSystem.out.print(ii);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(ss > N) continue;\n\t\t\tif(ii == 1000) continue;\n\t\t\tfor (int i = nn; i >= 1; i--) {\n\t\t\t\tsum.offer(new Integer(ss));\n\t\t\t\tnum.offer(new Integer(i));\n\t\t\t\tindex.offer(new Integer(ii+1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void bfs2()\n\t{\n\t\tLinkedList<Integer> sum = new LinkedList<Integer>();\n\t\tLinkedList<Integer> num = new LinkedList<Integer>();\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\t\n\t\tfor (int i = max; i >= 1; i--) {\n\t\t\tif((i*(i+1)*(i+2)/6) % 2 == 0) continue;\n\t\t\tsum.offer(new Integer(0));\n\t\t\tnum.offer(new Integer(i));\n\t\t\tindex.offer(new Integer(1));\n\t\t}\n\t\t\n\t\twhile (!sum.isEmpty()) {\n\t\t\tint ss = sum.poll().intValue();\n\t\t\tint nn = num.poll().intValue();\n\t\t\tint ii = index.poll().intValue();\n\t\t\t\n\t\t\tss += nn * (nn + 1) * (nn + 2) / 6;\n\t\t\tif(ss == N)\n\t\t\t{\n\t\t\t\tSystem.out.print(ii);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(ss > N) continue;\n\t\t\tif(ii == 1000) continue;\n\t\t\tfor (int i = nn; i >= 1; i--) {\n\t\t\t\tif((i*(i+1)*(i+2)/6)%2 == 0) continue;\n\t\t\t\tsum.offer(new Integer(ss));\n\t\t\t\tnum.offer(new Integer(i));\n\t\t\t\tindex.offer(new Integer(ii+1));\n\t\t\t}\n\t\t}\n\t}\n    \n    static void start()\n    {\n    \tfor (max = 1; max < 200; max++) {\n\t\t\tif(N <= (max*(max+1)*(max+2)/6)) break;\n\t\t}\n    \t//System.out.print(max);\n    \tbfs1();\n    \tSystem.out.print(\" \");\n    \tbfs2();\n    \tSystem.out.println(\"\");\n    }\n     \n    public static void main(String[] args)\n    {\n        Scanner sca = new Scanner(System.in);\n        \n        while(true)\n        {\n        \tN = sca.nextInt();\n        \t\n        \tif(N == 0) break;\n            \n            start();\n        }\n        \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\nimport javax.script.AbstractScriptEngine;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\t// public static Graph g;\n\tstatic ArrayList<Integer> a = new ArrayList<Integer>();\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint p = 1;\n\t\tfor(int i = 2; p <= 1000000; i++){\n\t\t\ta.add(p);\n\t\t\tp = i * (i+1) * (i+2) / 6;\n\t\t}\n\t\t// aの長さはせいぜい180しかない\n\t\t\n\t\twhile(true){\n\t\t\tint num = Integer.parseInt(br.readLine());\n\t\t\tif(num == 0) break;\n\t\t\t\n\t\t\tint ans1 = dfs(num, a.size() - 1);\n\t\t\tint ans2 = dfsodd(num, a.size() - 1);\n\t\t\tSystem.out.println(ans1 + \" \" + ans2);\n\t\t}\n\t}\n\t\n\tstatic int dfs(int rest, int last){\n\t\tif(rest == 0) return 0;\n\t\t\n\t\tint ret = 10000000;\n\t\tfor(int i = last; i >= 0; i--){\n\t\t\tint n = a.get(i);\n\t\t\tif(n > rest) continue;\n\t\t\tret = Math.min(ret, 1 + dfs(rest - n, i));\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\n\t\n\tstatic int dfsodd(int rest, int last){\n\t\tif(rest == 0) return 0;\n\t\t\n\t\tint ret = 10000000;\n\t\tfor(int i = last; i >= 0; i--){\n\t\t\tint n = a.get(i);\n\t\t\tif(n % 2 == 0) continue;\n\t\t\tif(n > rest) continue;\n\t\t\tret = Math.min(ret, 1 + dfsodd(rest - n, i));\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n\n// --- ここから下はライブラリ ----------\n \nclass ArrayComp implements Comparator<int[]>{\n\tpublic int compare(int[] a, int[] b){\n\t\tint l = Math.min(a.length, b.length);\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i] == b[i]) continue;\n\t\t\treturn a[i] - b[i];\n\t\t}\n\t\treturn 0;\n\t}\n}\n \nclass Node extends ArrayList<Edge>{\n\tint index, depth = -1, dist = -1;\n\tNode(int index){this.index = index;}\n\tNode parent;\n\tboolean visited = false;\n}\nclass Edge{\n\tint from, to, cost;\n\tEdge(int from, int to, int cost){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n}\nclass NodeComparator implements Comparator<Node>{\n\tpublic int compare(Node a, Node b){\n\t\treturn a.dist - b.dist;\n\t}\n}\n \nclass Graph{\n\tNode n[];\n\tGraph(int node_count){\n\t\tn = new Node[node_count];\n\t\tfor(int i = 0; i < node_count; i++) n[i] = new Node(i);\n\t}\n\tpublic void add(Edge e){\n\t\tn[e.from].add(e);\n\t}\n\tpublic Node get(int i){return n[i];}\n\tpublic Node lca(int a, int b){\n\t\t// 浅い方をaとする\n\t\tNode nodeA, nodeB;\n\t\tif(n[a].depth < n[b].depth){\n\t\t\tnodeA = n[a];\n\t\t\tnodeB = n[b];\n\t\t}else{\n\t\t\tnodeA = n[b];\n\t\t\tnodeB = n[a];\n\t\t}\n\t\t// 同じ深さまで親をたどる\n\t\tint diff = nodeB.depth - nodeA.depth;\n\t\tfor(int k = 0; k < diff; k++){\n\t\t\tnodeB = nodeB.parent;\n\t\t}\n\t\t// 共通祖先を見つける\n\t\twhile(nodeA != nodeB){\n\t\t\tnodeA = nodeA.parent;\n\t\t\tnodeB = nodeB.parent;\n\t\t}\n\t\treturn nodeA;\n\t}\n\tpublic void calcDepth(int root){\n\t\tArrayDeque<Integer> que = new ArrayDeque<Integer>();\n\t\tque.push(root);\n\t\tn[root].depth = 0;\n \n\t\twhile(que.size() > 0){\n\t\t\tint curr = que.pop();\n\t\t\tNode curr_node = n[curr];\n\t\t\tfor(Edge e : curr_node){\n\t\t\t\tint next = e.to;\n\t\t\t\tNode next_node = n[next];\n\t\t\t\tif(next_node.depth == -1){\n\t\t\t\t\tnext_node.depth = curr_node.depth + 1;\n\t\t\t\t\tnext_node.parent = curr_node;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic int[] dijkstra(int s){\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>(n.length, new NodeComparator());\n\t\tNode start_node = new Node(s);\n\t\tstart_node.dist = 0;\n\t\tq.add(start_node);\n\t\tint[] dist = new int[n.length];\n\t\tfor (int i = 0; i < dist.length; i++)  dist[i] = -1;\n\t\tdist[s] = 0;\n \n\t\twhile(q.size() > 0){\n\t\t\tNode currNode = q.poll();\n\t\t\tif(dist[currNode.index] < currNode.dist) continue;\n\t\t\tfor(Edge e : n[currNode.index]){\n\t\t\t\tNode nextNode = new Node(e.to);\n\t\t\t\tnextNode.dist = currNode.dist + e.cost;\n\t\t\t\tif(dist[e.to] == -1 || dist[e.to] > nextNode.dist){\n\t\t\t\t\tdist[e.to] = nextNode.dist;\n\t\t\t\t\tq.add(nextNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n}\n \n \n \nclass Regex{\n\tPattern p; Matcher m; String str;\n\tRegex(String regex_str){p = Pattern.compile(regex_str);}\n\tvoid setStr(String str){m = p.matcher(str);}\n\tboolean find(){return m.find();}\n\tString group(int i){return m.group(i);}\n\tString group(){return m.group();}\n}\n \n/**\n * UnionFindTree \n * @author yoshikyoto\n */\nclass UnionFindTree{\n\tpublic int[] parent, rank;\n\tpublic int n;\n\tpublic int count;\n\t// 初期化\n\tUnionFindTree(int n){\n\t\tthis.n = n;\n\t\tcount = n;\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t// 根を求める\n\tint find(int x){\n\t\tif(parent[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t// xとyの集合を結合\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){\n\t\t\treturn;\n\t\t}\n\t\tif(rank[x] < rank[y]){\n\t\t\tparent[x] = y;\n\t\t\tcount--;\n\t\t}else{\n\t\t\tparent[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tcount--;\n\t\t}\n\t}\n\t// xとyが同じ集合か\n\tboolean same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n \n \n\n \nclass CountHashMap<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n \n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil extends MyIO{\n\tpublic static Random rand = new Random();\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){return (new StringBuffer(s)).reverse().toString();}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n\tpublic static int randomInt(int min, int max){return min + rand.nextInt(max - min + 1);}\n\tstatic boolean inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\tpublic static boolean isUpper(char c){return 'A'<=c&&c<='Z';}\n\tpublic static boolean isLower(char c){return 'a'<=c&&c<='z';}\n\tpublic static char toUpper(char c){\n\t\tif(isLower(c)) return (char)(c - 'a' + 'A');\n\t\treturn c;\n\t}\n\tpublic static char toLower(char c){\n\t\tif(isUpper(c)) return (char)(c - 'A' + 'a');\n\t\treturn c;\n\t}\n\tpublic static int[] swap(int[] arr, int i, int j){\n\t\tint[] ret = cp(arr);\n\t\tint tmp = ret[i];\n\t\tret[i] = ret[j];\n\t\tret[j] = tmp;\n\t\treturn ret;\n\t}\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n}\n \n/**\n * MyIO\n * @author yoshikyoto\n */\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static String line;\n \n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static boolean readToLine() throws IOException{return (line = br.readLine()) != null;}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n \nclass MyMath{\n\tpublic static int max(int[] arr){return max(arr, 0, arr.length-1);}\n\tpublic static int max(int[] arr, int l, int r){\n\t\tint max = arr[l];\n\t\tfor(int i = l+1; i <= r; i++)\n\t\t\tmax = Math.max(max, arr[i]);\n\t\treturn max;\n\t}\n\tpublic static int min(int[] arr){return min(arr, 0, arr.length-1);}\n\tpublic static int min(int[] arr, int l, int r){\n\t\tint min = arr[l];\n\t\tfor(int i = l+1; i <= r; i++)\n\t\t\tmin = Math.min(min, arr[i]);\n\t\treturn min;\n\t}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t\t// 並行な場合\n\t\tint m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t\tif(m == 0) return false;\n\t\t// 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t\tdouble r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t\tdouble s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t\treturn (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t\tif((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t\telse return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){return (x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){return sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){return Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){return Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tstatic long comb(long n, long m){\n\t\tif(n < m) return 0;\n\t\tlong c = 1; m = (n - m < m ? n - m : m);\n\t\tfor(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;}\n\t\treturn c;\n\t}\n\tstatic int gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\n\t/**\n\t * aの中から、合計がborderを超えるペア（重複除く）の数を数える\n\t */\n\tstatic int countPair(int[] a, int border){\n\t\tint count = 0, l = a.length, i = 0, j = l-1;\n\t\tfor (; i < l; i++) {\n\t\t\tfor (; j >= 0; j--) if(a[i] + a[j] <= border) break;\n\t\t\tcount += l - (j + 1);\n\t\t\tif(j < i) count--;\n\t\t}\n\t\treturn count/2;\n\t}\n\t// modに対応したDPのCombination\n\tstatic int mcomb(int n, int m, int mod){\n\t\tn = n - m;\n\t\tint[][] dp = new int[n+1][m+1];\n\t\tfor(int i = 0; i <= n; i++) dp[i][0] = 1;\n\t\tfor(int i = 0; i <= m; i++) dp[0][i] = 1;\n\t\t// mod = 0 の時は余りを取らない\n\t\tif(mod != 0){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m];\n\t\t// それ以外の時は mod をとっていく\n\t\t}else{\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m] % mod;\n\t\t}\n\t}\n\t\n\n\tstatic long mcomb(int n, int m, long mod){\n\t\tn = n - m;\n\t\tlong[][] dp = new long[n+1][m+1];\n\t\tfor(int i = 0; i <= n; i++) dp[i][0] = 1;\n\t\tfor(int i = 0; i <= m; i++) dp[0][i] = 1;\n\t\t// mod = 0 の時は余りを取らない\n\t\tif(mod != 0){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m];\n\t\t// それ以外の時は mod をとっていく\n\t\t}else{\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m] % mod;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic char[][] dp;\n\tstatic char[][] odp;\n\tstatic int n;\n\tstatic char INF = Character.MAX_VALUE;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\tn = 1000000;\n\t\tdp = new char[1000001][list.size()+1];\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp();\n\t\t\n\t\todp = new char[1000001][oddList.size()+1];\n\t\tSystem.gc();\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(odp[i], INF);\n\t\t}\n\t\todp[0][0] = 0;\n\t\toddDp();\n\t\tSystem.gc();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n][list.size()];\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = (char) (dp[i-list.get(j-1)][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 100000 == 0)\n\t\t\t\tSystem.gc();\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = (char) (dp[i-oddList.get(j-1)][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint[] pol = new int[1000000];\n\t\tArrayList<Integer> p1 = new ArrayList<>();\n\t\tint[] pol_odd = new int[1000000];\n\t\tArrayList<Integer> p1_odd = new ArrayList<>();\n\t\t\n\t\tint num = 1;\n\t\tfor(int i=1;num<1000000;i++){\n\t\t\tp1.add(num);\n\t\t\tif((num&1)==1){\n\t\t\t\tp1_odd.add(num);\n\t\t\t}\n\t\t\tnum = num * (i+3) / i;\n\t\t}\n\t\t\n\t\tfor(int i=1;i<1000000;i++){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int j=0;j<p1.size();j++){\n\t\t\t\tif(i-p1.get(j)<0) break;\n\t\t\t\tmin = Math.min(min,pol[i-p1.get(j)]);\n\t\t\t}\n\t\t\tpol[i] = min + 1;\n\t\t\t\n\t\t\tmin = Integer.MAX_VALUE;\n\t\t\tfor(int j=0;j<p1_odd.size();j++){\n\t\t\t\tif(i-p1_odd.get(j)<0) break;\n\t\t\t\tmin = Math.min(min,pol_odd[i-p1_odd.get(j)]);\n\t\t\t}\n\t\t\tpol_odd[i] = min + 1;\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tint x = in.nextInt();\n\t\t\tif(x==0) break;\n\t\t\telse{\n\t\t\t\tSystem.out.println(pol[x]+\" \"+pol_odd[x]);\n\t\t\t}\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "/*\n*/\nimport java.io.*;\n\nclass HOME_C {\n\tstatic int map[];\n\tstatic int mapb[];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\trun();\n\t\t} catch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\tprivate static void run() throws IOException{\n\t\tfinal int MAX = 1000000;\n\t\tint n;\n\t\tint instant;\n\t\tmap = new int[MAX+1];\n\t\tmapb = new int[MAX+1];\n\t\t\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tfor(int i=1;i<=MAX;i++) {\n\t\t\t//if(i%100000==0)System.out.print(\".\");\n\t\t\tmap[i] = f(i);\n\t\t\tmapb[i] = fb(i);\n\t\t}\n\t\t//System.out.println(\"\");\n\t\t\n\t\twhile(true) {\n\t\t\tn = Integer.parseInt(in.readLine());\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tSystem.out.println(map[n] + \" \" + mapb[n]);\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tprivate static int f(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > map[n-tk]) {\n\t\t\t\t\tmin = map[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 1+min;\n\t}\n\t\n\tprivate static int fb(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0 || tk%2==0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > mapb[n-tk]) {\n\t\t\t\t\tmin = mapb[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\treturn 1+min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic int[] list1 = new int[180];\n\tstatic int[] list2 = new int[45];\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tmakeList();\n\t\tint[] dp1 = new int[1000000];\n\t\tint[] dp2 = new int[1000000]; \n\t\t\n\n\t\tArrays.fill(dp1, 2 << 27);\n\t\tArrays.fill(dp2, 2 << 27);\n\n\t\tdp1[0] = dp2[0] =  0;\n\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tfor(int j = 0; j < 1000000; j++) {\n\t\t\t\tif(j + list1[i]  >= 1000000) break;\n\t\t\t\tdp1[j + list1[i]] = Math.min(dp1[j+list1[i]], dp1[j] + 1);\n\t\t\t\tif(list1[i] % 2 == 1) dp2[j + list1[i]] = Math.min(dp2[j+list1[i]], dp2[j]+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true) {\n\t\t\tint a = sc.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tSystem.out.println(dp1[a] + \" \" + dp2[a]);\n\t\t}\n\t}\n\t\n\tstatic void makeList() {\n\t\tint count1 = 0;\n\t\tfor(int i = 1; i < 181; i++) {\n\t\t\tint sum = i*(i+1)*(i+2)/6;\n\t\t\tlist1[count1++] = sum;\n\t\t}\n\t}\n\t\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint[] tetra;\n\tint ans;\n\tint[] dp;\n\n\tint dp(int sum, boolean flg) {\n\t\tif (sum < 0) {\n\t\t\treturn 200;\n\t\t}\n\t\tif (sum == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp[sum]) {\n\t\t\treturn dp[sum];\n\t\t}\n\t\tint res = 200;\n\t\tfor (int i = 1; i < 200; i++) {\n\t\t\tif (flg && tetra[i] % 2 == 0) continue;\n\t\t\tres = Math.min(res, dp(sum - tetra[i], flg) + 1);\n\t\t}\n\t\treturn dp[sum] = res;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\ttetra = new int[200];\n\t\tdp = new int[2000000];\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\ttetra[i] = i*(i+1)*(i+2)/6;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tArrays.fill(dp, -1);\n\t\t\tSystem.out.print(dp(n, false) + \" \");\n\t\t\tArrays.fill(dp, -1);\n\t\t\tSystem.out.println(dp(n, true));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[] dp;\n\tstatic int[] odp;\n\tstatic int n;\n\tstatic int INF = 1 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tmakeList();\t\t\n\t\tdp = new int[1000001];\n\t\todp = new int[1000001];\n\t\tArrays.fill(dp, INF);\n\t\tArrays.fill(odp, INF);\n\t\tdp[0] = odp[0] = 0;\n\t\tdp();\n\t\toddDp();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n];\n\t\t\tansB = odp[n];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= 1000000; i++) {\n\t\t\tfor(int j = 0; j < list.size(); j++) {\n\t\t\t\tif(i - list.get(j) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j)] + 1 < dp[i]) {\n\t\t\t\t\t\tdp[i] = dp[i-list.get(j)] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= 1000000; i++) {\n\t\t\tfor(int j = 0; j < oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j) >= 0) {\n\t\t\t\t\tif(odp[i-oddList.get(j)] + 1 < odp[i]) {\n\t\t\t\t\t\todp[i] = odp[i-oddList.get(j)]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int[] dp1 = new int[1000001];\n        int[] dp2 = new int[1000001];\n        for (int i = 1; i <= 1000000; i++) {\n            dp1[i] = dp2[i] = i;\n        }\n\n        for (int i = 2; i < 200; i++) {\n            int t = i * (i + 1) * (i + 2) / 6;\n\n            if (t > 1000000) {\n                break;\n            }\n\n            for (int j = t; j <= 1000000; j++) {\n                dp1[j] = Math.min(dp1[j], dp1[j - t] + 1);\n                if (t % 2 == 1) {\n                    dp2[j] = Math.min(dp2[j], dp2[j - t] + 1);\n                }\n            }\n        }\n\n        while (true) {\n            int n = ni();\n\n            if (n == 0) return;\n\n            out.println(dp1[n] + \" \" + dp2[n]);\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[][] dp;\n\tstatic int[][] odp;\n\tstatic int n;\n\tstatic int INF = 2 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\tn = 1000000;\n\t\tdp = new int[1000001][list.size()+1];\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp();\n\t\t\n\t\todp = new int[1000001][oddList.size()+1];\n\t\tSystem.gc();\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(odp[i], INF);\n\t\t}\n\t\todp[0][0] = 0;\n\t\toddDp();\n\t\t\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n][list.size()];\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-list.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-oddList.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 500000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tint[] p = new int[181];\n\tint[] oddp = new int[46];\n\t\n\tint[] memo = new int[1000001];\n\tint[] oddmemo = new int[1000001];\n\t\n\tint calc(int n) {\n\t\tif (memo[n] == 0) {\n\t\t\tint index = 180;\n\t\t\twhile (n < p[index]) index--;\n\t\t\tif (index == 0) memo[n] = n;\n\t\t\telse {\n\t\t\t\tif (n == p[index]) memo[n] = 1;\n\t\t\t\telse {\n\t\t\t\t\tint min = 1000000;\n\t\t\t\t\tfor (int i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (min >= n/p[i])\n\t\t\t\t\t\t\tmin = Math.min(min, calc(n-p[i]));\n\t\t\t\t\t}\n\t\t\t\t\tmemo[n] = min+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn memo[n];\n\t}\n\t\n\tint calcodd(int n) {\n\t\tif (oddmemo[n] == 0) {\n\t\t\tint index = 45;\n\t\t\twhile (n < oddp[index]) index--;\n\t\t\tif (index == 0) oddmemo[n] = n;\n\t\t\telse {\n\t\t\t\twhile (n < oddp[index]) index--;\n\t\t\t\tif (n == oddp[index]) oddmemo[n] = 1;\n\t\t\t\telse {\n\t\t\t\t\tint min = 1000000;\n\t\t\t\t\tfor (int i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (min >= n/oddp[i])\n\t\t\t\t\t\t\tmin = Math.min(min, calcodd(n-oddp[i]));\n\t\t\t\t\t}\n\t\t\t\t\toddmemo[n] = min+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn oddmemo[n];\n\t}\n\t\n\tvoid run() {\n\t\tint n;\n\t\n\t\t\n\t\tfor (int i = 0; i < 181; i++) {\n\t\t\tp[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t\tif (i % 4 == 0) {\n\t\t\t\toddp[i/4] = (i+1)*(i+2)*(i+3)/6;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) break;\n\n\t\t\tout.printf(\"%d %d\\n\", calc(n), calcodd(n));\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[] dp;\n\tstatic int[] odp;\n\tstatic int n;\n\tstatic int INF = 1 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\t\n\t\tmakeList();\t\t\n\t\tdp = new int[1000001];\n\t\todp = new int[1000001];\n\t\tArrays.fill(dp, INF);\n\t\tArrays.fill(odp, INF);\n\t\tdp[0] = odp[0] = 0;\n\t\tdp();\n\t\toddDp();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n];\n\t\t\tansB = odp[n];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= 1000000; i++) {\n\t\t\tfor(int j = 0; j < list.size(); j++) {\n\t\t\t\tint a = list.get(j);\n\t\t\t\tif(i - a < 0) break;\n\t\t\t\tif(dp[i - a] + 1 < dp[i]) {\n\t\t\t\t\tdp[i] = dp[i-a] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= 1000000; i++) {\n\t\t\tfor(int j = 0; j < oddList.size(); j++) {\n\t\t\t\tint a = oddList.get(j);\n\t\t\t\tif(i - a < 0) break;\n\t\t\t\tif(odp[i - a]+1 < odp[i]) {\n\t\t\t\t\todp[i] = odp[i-a]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[][] dp;\n\tstatic int[][] odp;\n\tstatic int n;\n\tstatic int INF = 2 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\tn = 1000000;\n\t\tdp = new int[1000001][list.size()+1];\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp();\n\t\t\n\t\todp = new int[1000001][oddList.size()+1];\n\t\tSystem.gc();\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(odp[i], INF);\n\t\t}\n\t\todp[0][0] = 0;\n\t\toddDp();\n\t\tSystem.gc();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n][list.size()];\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-list.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-oddList.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  Scanner sc;\n\n  Main() {\n    sc = new Scanner(System.in);\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  static int[] list;\n  static int[] dpa;\n  static int[] dpb;\n\n  static {\n    list = new int[1000];\n    for (int i = 0; i < 1000; ++i) {\n      list[i] = ((i + 1) * (i + 2) * (i + 3)) / 6;\n    }\n    dpa = new int[1000000];\n    Arrays.fill(dpa, 1 << 28);\n    dpa[0] = 0;\n    for (int i = 0; i < 1000; ++i) {\n      for (int j = 0; j < 1000000; ++j) {\n        if (j + list[i] >= 1000000) {\n          break;\n        }\n        dpa[j + list[i]] = Math.min(dpa[j + list[i]], dpa[j] + 1);\n      }\n    }\n\n    dpb = new int[1000000];\n    Arrays.fill(dpb, 1 << 28);\n    dpb[0] = 0;\n    for (int i = 0; i < 1000; ++i) {\n      if (list[i] % 2 != 1) {\n        continue;\n      }\n      for (int j = 0; j < 1000000; ++j) {\n        if (j + list[i] >= 1000000) {\n          break;\n        }\n        dpb[j + list[i]] = Math.min(dpb[j + list[i]], dpb[j] + 1);\n      }\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n\n      System.out.println(dpa[n] + \" \" + dpb[n]);\n    }\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport javax.naming.BinaryRefAddr;\n\nimport static java.lang.System.*;\n\nclass Main {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n\n\n    public void run() {\n    \tList<Integer> pollock=new ArrayList<Integer>();\n\n    \tfor(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    \t\tpollock.add(i*(i+1)*(i+2)/6);\n    \t}\n\n    \tint[] dp=new int[1000000],dp2=new int[1000000];\n\n    \tfor(int i=1;i<1000000;i++){\n    \t\tint min=Integer.MAX_VALUE;\n    \t\tfor(int j:pollock){\n    \t\t\tif(i-j>=0)min=Math.min(min,dp[i-j]+1);\n    \t\t}\n    \t\tdp[i]=min;\n    \t}\n\n    \tfor(int i=1;i<1000000;i++){\n    \t\tint min=Integer.MAX_VALUE;\n    \t\tfor(int j:pollock){\n    \t\t\tif(i-j>=0 && j%2==1)\n    \t\t\t\tmin=Math.min(min,dp2[i-j]+1);\n    \t\t}\n    \t\tdp2[i]=min;\n    \t}\n\n\n    \twhile(true){\n        \tint n=sc.nextInt();\n        \tif(n==0)return;\n\n        \tln(dp[n]+\" \"+dp2[n]);\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public int[] nextIntArray(int n){\n        int[] res=new int[n];\n        for(int i=0;i<n;i++){\n            res[i]=sc.nextInt();\n        }\n        return res;\n    }\n    public static void pr(Object o) {\n        out.print(o);\n    }\n    public static void ln(Object o) {\n        out.println(o);\n    }\n    public static void ln() {\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tshort[] DP = new short[1000001];\n\t\tshort[] ODD_DP = new short[1000001];\n\t\t\n\t\tfor(int j = 0; j <= 1000000; j++){\n\t\t\tDP[j] = ODD_DP[j] = -1;\n\t\t}\n\t\t\n\t\tDP[0] = 0;\n\t\tODD_DP[0] = 0;\n\t\t\n\t\tfor(int i = 0; ; i++){\n\t\t\tint number = ((i + 1) * (i + 2) * (i + 3)) / 6;\n\t\t\t\n\t\t\tif(number > 1000000){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j <= (1000000 - number); j++){\n\t\t\t\tif(DP[j] != -1){\n\t\t\t\t\tif(DP[j + number] == -1){\n\t\t\t\t\t\tDP[j + number] = (short) (DP[j] + 1);\n\t\t\t\t\t}else if(DP[j + number] > DP[j] + 1){\n\t\t\t\t\t\tDP[j + number] = (short) (DP[j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(number % 2 == 1){\n\t\t\t\tfor(int j = 0; j <= (1000000 - number); j++){\n\t\t\t\t\tif(ODD_DP[j] != -1){\n\t\t\t\t\t\tif(ODD_DP[j + number] == -1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (short) (ODD_DP[j] + 1);\n\t\t\t\t\t\t}else if(ODD_DP[j + number] > ODD_DP[j] + 1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (short) (ODD_DP[j] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(DP[n] + \" \" + ODD_DP[n]);\n\t\t\t\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\n\t\t// int nnn=3*(3+1)*(3+2)/6;\n\t\t// System.out.println(nnn);\n\t\tlong[] dp = new long[1000001];\n\t\tlong[] dpki = new long[1000001];\n\t\tint min = 1000000;\n\t\t// int tate = n * (n + 1) * (n + 2);\n\n\t\t// tate++;\n//\t\tlong[][] dp = new long[181][n+ 1];\n\n\t\tfor (int i = 1; i <= 1000000; i++) {\n\t\t\tdp[i] = i;\n//\t\t\tdp[0][i] = 1000000;\n\n\t\t\tdpki[i] = i;\n\t\t\t//dpki[0][i] = 1000000;\n\t\t}\n\n\t\tfor (int i = 2; i < 181; i++) {\n\n\t\t//\tfor (int j = 1; j <= n; j++)\n\t\t//\t\tdp[i][j] = dp[i - 1][j];\n\n\t\t\tint sum = i * (i + 1) * (i + 2) / 6;\n\n\t\t\tfor(int j=sum;j<=1000000;j++){\n\t\t\t\tdp[j]=Math.min(dp[j],dp[j-sum]+1);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\tif (sum <= n && dp[i - 1][sum] > 1)\n\t\t\t\tdp[i][sum] = 1;\n\t\t\tint count = 2;\n\t\t\tfor (int j = sum * 2; j <= n; j += sum) {\n\t\t\t\tif (dp[i - 1][j] > count)\n\t\t\t\t\tdp[i][j] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\t// for (int k = 2; n / sum >= k; k++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (n >= j + sum && dp[i - 1][j + sum] > dp[i - 1][j] + 1 && dp[i][j + sum] > dp[i - 1][j] + 1)\n\t\t\t\t\tdp[i][j + sum] = dp[i - 1][j] + 1;\n\t\t\t}\n\t\t\t// }\n\t\t\t*/\n\n\t\t}\n\n\t\tfor (int i = 2; i < 181; i++) {\n\t\t\t//for (int j = 1; j <= n; j++)\n\t\t\t//\tdpki[i][j] = dpki[i - 1][j];\n\n\t\t\tint sum2 = i * (i + 1) * (i + 2) / 6;\n\n\t\t\tif (sum2 % 2 == 0)\n\t\t\t\tcontinue;\n\n//\t\t\tif(dpki[i][sum2]>1)dp[i][sum2]=1;\n\t\t\tfor(int j=sum2;j<=1000000;j++){\n\t\t\t\tdpki[j]=Math.min(dpki[j],dpki[j-sum2]+1);\n\t\t\t}\n\t\t\t\n/*\t\t\t\tif (sum2 <= n && dpki[i - 1][sum2] > 1)dpki[i][sum2] = 1;\n\t\t\tint count2 = 2;\n\t\t\tfor (int j = sum2 * 2; j <= n; j += sum2) {\n\t\t\t\tif (dpki[i - 1][j] > count2)\n\t\t\t\t\tdpki[i][j] = count2;\n\t\t\t\tcount2++;\n\t\t\t}\n\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (n >= j + sum2 && dpki[i][j + sum2] > dpki[i][j] + 1)dpki[i][j + sum2] = dpki[i][j] + 1;\n\t\t\t\n\t\t\t}\n\n\t\t\t\n\t\t\tfor (int k = 1; n / sum2 >= k; k++) {\n\t\t\t\tint sss=sum2*k;\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (n >= j + sss && dpki[i][j + sss] > dpki[i][j] + 1)dpki[i][j + sss] = dpki[i][j] + 1;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t }\n\t\t\t */\n\t\t\t\n\t\t\t\n\t\t}\n/*\t\tfor (int i = 0; i < 181; i++) {\n\t\t\tfor (int j = 0; j <= n; j++) {\n\t\t\t\tSystem.out.print(dpki[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n*/\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\n\t\t\tlong result = dp[n];\n\t\t\tlong result2 = dpki[n];\n\t/*\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\t// System.out.println(dp[i][n]);\n\t\t\t\tif (dp[i][n] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult = (int) Math.min(dp[i][n], result);\n\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < 181; i++) {\n\t\t\t\t// System.out.println(dp[i][n]);\n\t\t\t\tif (dpki[i][n] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tresult2 = (int) Math.min(dpki[i][n], result2);\n\n\t\t\t}\n*/\n\t\t\tSystem.out.print(result+\" \");\n\t\t\tSystem.out.println(result2);\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int[] tetra = new int[200];\n    int[] Otetra = new int[200];\n    int[] ans = new int[1000000];\n    int[] odd = new int[1000000];\n\n    void run(){\n\tsetTetra();\n\tsolve();\n\twhile(sc.hasNext()){\n\t    int x = sc.nextInt();\n\t    if(x!=0)\n\t\tSystem.out.println(ans[x]+\" \"+odd[x]);\n\t}\n    }\n\n    void setTetra(){\n\tint o = 0;\n\tfor(int i=0; i<tetra.length; i++){\n\t    tetra[i] = (i*(i+1)*(i+2))/6;\n\t    if(tetra[i]%2==1)\n\t\tOtetra[o++] = tetra[i];\n\t}\n    }\n\n    void solve(){\n\tint max = Integer.MAX_VALUE;\n\tArrays.fill(ans, max);\n\tArrays.fill(odd, max);\n\n\tans[0] = 0;\n\tfor(int i=0; i<tetra.length; i++){\n\t    int a = tetra[i];\n\t    for(int j=a; j<ans.length; j++){\n\t\tif(ans[j-a] != max){\n\t\t    int newAns = ans[j-a]+1;\n\t\t    if(newAns < ans[j]) {\n\t\t\tans[j] = newAns;\t\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\todd[0] = 0;\n\tfor(int i=0; i<Otetra.length; i++){\n\t    int a = Otetra[i];\n\t    for(int j=a; j<odd.length; j++){\n\t\tif(odd[j-a] != max){\n\t\t    int newOdd = odd[j-a]+1;\n\t\t    if(newOdd < odd[j]) {\n\t\t\todd[j] = newOdd;\t\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(solve(input));\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static String solve(int input) {\n\t\tint c = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tc = i;\n\t\t\tlist.add((i*(i+1)*(i+2))/6);\n\t\t}\n\n\t\tint[][] dp = new int[input][c];\n\t\tint[][] dp2 = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif((v%2) != 0){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\t\t\tdp2[j][0] = j+1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v), dp2[j][i-1]);\n\t\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v)+dp2[((j+1)%v) - 1][i-1], dp2[j][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dp[input-1][c-1] + \" \" + dp2[input-1][c-1];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] list1 = new int[180];\n\t\tint[] dp1 = new int[1000000];\n\t\tint[] dp2 = new int[1000000]; \n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tlist1[i] = (i+1)*(i+2)*(i+3)/6;\n\t\t}\n\n\t\tArrays.fill(dp1, 2 << 27);\n\t\tArrays.fill(dp2, 2 << 27);\n\n\t\tdp1[0] = dp2[0] =  0;\n\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tint tmp = list1[i];\n\t\t\tif(list1[i] % 2 == 0)\n\t\t\tfor(int j = tmp; j < 1000000; j++) {\n\t\t\t\tdp1[j] = Math.min(dp1[j-tmp]+1, dp1[j]);\n\t\t\t}\n\t\t\telse\n\t\t\tfor(int j = list1[i]; j < 1000000; j++) {\n\t\t\t\tdp1[j] = Math.min(dp1[j-tmp]+1, dp1[j]);\n\t\t\t\tdp2[j] = Math.min(dp2[j-tmp]+1, dp2[j]);\n\t\t\t}\n\t\t}\n\t\twhile(true) {\n\t\t\tint a = sc.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tSystem.out.println(dp1[a] + \" \" + dp2[a]);\n\t\t}\n\t}\n\t\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    ArrayList<Integer> list;\n    ArrayList<Integer> list2;\n\n    list = new ArrayList<>();\n    list2 = new ArrayList<>();\n    int pre = 1;\n    int n = 1;\n    while((pre = n*(n+1)*(n+2)/6)<1000000) {\n      n++;\n      if(pre%2==1) list.add(pre);\n      list2.add(pre);\n    }\n    int input = 0;\n\n    int[] dp2 = new int[1000001];\n    int[] dp = new int[1000001];\n    while((input=scan.nextInt())!=0) {\n      System.out.print(calc(input,dp2,list2)+\" \");\n      System.out.println(calc(input,dp,list));\n    }\n  }\n\n  static int calc(int sum, int[] dp, ArrayList<Integer> list) {\n    if(sum==0) return 0;\n    if(dp[sum]>0) return dp[sum];\n    int max = 0;\n    int count = 999999;\n    int res = 0;\n    for(int i = list.size()-1; i >= 0; i--) {\n      max = list.get(i);\n      if(max==sum) {\n        res = 1;\n        break;\n      }\n      if(max<sum) {\n        res = 1 + calc(sum-max,dp,list);\n        count = Math.min(res, count);\n      }\n    }\n    dp[sum] = res;\n    return Math.min(count,res);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic short[][] dp;\n\tstatic short[][] odp;\n\tstatic int n;\n\tstatic short INF = 1024;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\tn = 1000000;\n\t\tdp = new short[1000001][list.size()+1];\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp();\n\t\t\n\t\todp = new short[1000001][oddList.size()+1];\n\t\tSystem.gc();\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(odp[i], INF);\n\t\t}\n\t\todp[0][0] = 0;\n\t\toddDp();\n\t\tSystem.gc();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n][list.size()];\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = (short) (dp[i-list.get(j-1)][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 100000 == 0)\n\t\t\t\tSystem.gc();\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = (short) (dp[i-oddList.get(j-1)][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\n\tstatic void solve() {\n\t\tint[] dp = new int[1000000];\n\t\tArrays.fill(dp,Integer.MAX_VALUE/2);\n\t\tdp[0] = 0;\n\n\t\tint[] odd = new int[1000000];\n\t\tArrays.fill(odd,Integer.MAX_VALUE/2);\n\t\todd[0] = 0;\n\n\n\t\tfor (int i=1; i<1000000; i++) {\n\t\t\tfor (int j=1; j<=i; j++) {\n\t\t\t\tint v = j*(j+1)*(j+2)/6;\n\t\t\t\tif (i < v) break;\n\t\t\t\tdp[i] = Math.min(dp[i], dp[i-v] + 1);\n\n\t\t\t\tif (v%2 == 0) continue;\n\t\t\t\tif (i < v) break;\n\t\t\t\todd[i] = Math.min(odd[i], odd[i-v] + 1);\n\t\t\t}\n\t\t}\n\n\t\twhile (true) {\n\t\t\tint q = in.nextInt();\n\t\t\tif (q == 0) break;\n\t\t\tout.println(dp[q]+\" \"+odd[q]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\t//trace(end-start + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.util.Arrays;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Pollock's conjecture\n */\npublic class Main {\n\n\tstatic final int MAX = 1000000;\n\tstatic final int MAX3 = 1500;\n\tstatic final int MAX4 = 200;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\n\t\tint[] R3 = new int[MAX3];\n\t\tint[] R4 = new int[MAX4];\n\t\tint[] R4O;\n\n\t\tR3[1] = 1;\n\t\tfor (int i = 2; i < R3.length; i++) {\n\t\t\tR3[i] = R3[i - 1] + i;\n\t\t}\n\n\t\tR4[1] = 1;\n\t\tfor (int i = 2; i < R4.length; i++) {\n\t\t\tR4[i] = R4[i - 1] + R3[i];\n\t\t}\n\n\t\tR4O = Arrays.stream(R4).filter(x -> x % 2 != 0).toArray();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tint[] dp = new int[n + 1];\n\t\t\tint[] dpo = new int[n + 1];\n\t\t\tfor (int i = 0; i < dp.length; i++) dp[i] = i;\n\t\t\tfor (int i = 0; i < dpo.length; i++) dpo[i] = i;\n\n\t\t\touter:\n\t\t\tfor (int i = 2; i < R4.length; i++) {\n\t\t\t\tfor (int j = 1; j <= dp.length / R4[i]; j++) {\n\t\t\t\t\tif (R4[i] * j > n) continue outer;\n\t\t\t\t\tfor (int k = R4[i] * j; k < dp.length; k++) {\n\t\t\t\t\t\tdp[k] = Math.min(dp[k], dp[k - R4[i] * j] + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\touter:\n\t\t\tfor (int i = 1; i < R4O.length; i++) {\n\t\t\t\tfor (int j = 1; j <= dpo.length / R4O[i]; j++) {\n\t\t\t\t\tif (R4O[i] * j > n) continue outer;\n\t\t\t\t\tfor (int k = R4O[i] * j; k < dpo.length; k++) {\n\t\t\t\t\t\tdpo[k] = Math.min(dpo[k], dpo[k - R4O[i] * j] + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(dp[n] + \" \" + dpo[n]);\n\n\t\t}//end while\n\t}//end main\n}"
  },
  {
    "language": "Java",
    "code": "/*\nicpc??´?????????\n2010??´ ?????? C??????\n*/\nimport java.io.*;\n\nclass HOME_C {\n\tstatic int map[];\n\tstatic int mapb[];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\trun();\n\t\t} catch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\tprivate static void run() throws IOException{\n\t\tfinal int MAX = 1000000;\n\t\tint n;\n\t\tint instant;\n\t\tmap = new int[MAX+1];\n\t\tmapb = new int[MAX+1];\n\t\t\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tfor(int i=1;i<=MAX;i++) {\n\t\t\t//if(i%100000==0)System.out.print(\".\");\n\t\t\tmap[i] = f(i);\n\t\t\tmapb[i] = fb(i);\n\t\t}\n\t\t//System.out.println(\"\");\n\t\t\n\t\twhile(true) {\n\t\t\tn = Integer.parseInt(in.readLine()); //???????????£?????????\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tSystem.out.println(map[n] + \" \" + mapb[n]);\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tprivate static int f(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > map[n-tk]) {\n\t\t\t\t\tmin = map[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 1+min;\n\t}\n\t\n\tprivate static int fb(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0 || tk%2==0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > mapb[n-tk]) {\n\t\t\t\t\tmin = mapb[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\treturn 1+min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int INF = Integer.MAX_VALUE;\n\n        ArrayList<Integer> pol = new ArrayList<Integer>();\n        int num = 1;\n        int po = num*(num+1)*(num+2)/6;\n        while(po < 1000000){\n            pol.add(new Integer(po));\n            num++;\n            po = num*(num+1)*(num+2)/6;\n        }\n\n        int[] cnt = new int[1000000];\n        int[] cnt2 = new int[1000000];\n        Arrays.fill(cnt, INF);\n        Arrays.fill(cnt2, INF);\n        cnt[0] = 0;\n        cnt2[0] = 0;\n        for(int i=0; i<pol.size(); i++){\n            int pp = pol.get(i);\n            for(int j=pp; j<1000000; j++){\n                cnt[j] = Math.min(cnt[j], cnt[j-pp]+1);\n                if(pp%2==1) cnt2[j] = Math.min(cnt2[j], cnt2[j-pp]+1);\n            }\n        }\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            System.out.println(cnt[n]+\" \"+cnt2[n]);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] min = new int[1000000 + 1];\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\n\t\twhile(n != 0){\n\t\t\tArrays.fill(min, -1);\n\t\t\tmin[1] = 1;\n\t\t\tSystem.out.print(func(n));\n\t\t\tArrays.fill(min, -1);\n\t\t\tmin[1] = 1;\n\t\t\tSystem.out.println(\" \" + oddfunc(n));\n\t\t\tn = sc.nextInt();\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\tstatic int func(int n){\n\t\tif(min[n] > 0){\n\t\t\treturn min[n];\n\t\t}\n\t\tint res = 20000;\n\t\tint tmp = n;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\ttmp = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(n == tmp){\n\t\t\t\tmin[n] = 1;\n\t\t\t\treturn min[n];\n\t\t\t}else if(n > tmp){\n\t\t\t\tres = Math.min(res, func(n - tmp) + 1);\n\t\t\t}else if(n < tmp){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmin[n] = res;\n\t\treturn res;\n\t}\n\tstatic int oddfunc(int n){\n\t\tif(min[n] > 0){\n\t\t\treturn min[n];\n\t\t}\n\t\tint res = 20000;\n\t\tint tmp = n;\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\ttmp = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(tmp % 2 != 0){\n\t\t\t\tif(n == tmp){\n\t\t\t\t\tmin[n] = 1;\n\t\t\t\t\treturn min[n];\n\t\t\t\t}else if(n > tmp){\n\t\t\t\t\tres = Math.min(res, oddfunc(n - tmp) + 1);\n\t\t\t\t}else if(n < tmp){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmin[n] = res;\n\t\treturn res;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tfinal int MAX_N = 1000002;\n\tint[] dp1 = new int[MAX_N], dp2 = new int[MAX_N];\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tArrays.fill(dp1, Integer.MAX_VALUE);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\tdp1[0] = dp2[0] = 0;\n\t\tfor(int i=0; i<MAX_N; i++){\n\t\t\tfor(int j=1, sum=1; i + sum < MAX_N; j++, sum += j*(j+1)/2){\n\t\t\t\tdp1[i+sum] = Math.min(dp1[i+sum], dp1[i]+1);\n\t\t\t\tif((sum&1)>0){\n\t\t\t\t\tdp2[i+sum] = Math.min(dp2[i+sum], dp2[i]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int n = in.nextInt(); n > 0; n = in.nextInt()){\n\t\t\tSystem.out.println(dp1[n] + \" \" + dp2[n]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] DP = new int[100001];\n\t\tint[] ODD_DP = new int[100001];\n\t\t\n\t\tArrays.fill(DP, -1);\n\t\tArrays.fill(ODD_DP, -1);\n\t\t\n\t\tDP[0] = 0;\n\t\tODD_DP[0] = 0;\n\t\t\n\t\tfor(int i = 0; i < 58; i++){\n\t\t\tint number = ((i + 1) * (i + 2) * (i + 3)) / 6;\n\t\t\t\n\t\t\tfor(int j = 0; j <= (100000 - number); j++){\n\t\t\t\tif(DP[j] != -1){\n\t\t\t\t\tif(DP[j + number] == -1){\n\t\t\t\t\t\tDP[j + number] = DP[j] + 1;\n\t\t\t\t\t}else if(DP[j + number] > DP[j] + 1){\n\t\t\t\t\t\tDP[j + number] = DP[j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(number % 2 == 1){\n\t\t\t\tfor(int j = 0; j <= (100000 - number); j++){\n\t\t\t\t\tif(ODD_DP[j] != -1){\n\t\t\t\t\t\tif(ODD_DP[j + number] == -1){\n\t\t\t\t\t\t\tODD_DP[j + number] = ODD_DP[j] + 1;\n\t\t\t\t\t\t}else if(ODD_DP[j + number] > ODD_DP[j] + 1){\n\t\t\t\t\t\t\tODD_DP[j + number] = ODD_DP[j] + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(DP[n] + \" \" + ODD_DP[n]);\n\t\t\t\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int[] dp = new int[1000000 + 1];\n    int[] dp2 = new int[1000000 + 1];\n    for (int i = 1; i < dp.length; i++) {\n      dp[i] = i;\n      dp2[i] = i;\n    }\n    for (int i = 1; ; i++) {\n      int k = (i * (i + 1) * (i + 2)) / 6;\n      if (k >= 1000000) {\n        break;\n      }\n      for (int j = 0; j + k < 1000000; j++) {\n        dp[j + k] = Math.min(dp[j + k], dp[j] + 1);\n      }\n      if (k % 2 == 1) {\n        for (int j = 0; j + k < 1000000; j++) {\n          dp2[j + k] = Math.min(dp2[j + k], dp2[j] + 1);\n        }\n      }\n    }\n\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      System.out.println(dp[n] + \" \" + dp2[n]);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Pollock's conjecture\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] p = new int[181];\n\t\tfor(int i=1;i<181;i++){\n\t\t\tp[i] = (i*(i+1)*(i+2))/6;\n\t\t}\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint[] dp = new int[n+1];\n\t\t\tint[] dp2 = new int[n+1];\n\t\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\t\tdp[0] = 0;\n\t\t\tdp2[0] = 0;\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<181;j++){\n\t\t\t\t\tif(i-p[j]>=0){\n\t\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i-p[j]]+1);\n\t\t\t\t\t\tif(p[j]%2==1){\n\t\t\t\t\t\t\tdp2[i] = Math.min(dp2[i], dp2[i-p[j]]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dp[n]+\" \"+dp2[n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic final int INF=Integer.MAX_VALUE;\n\tstatic int[] dp,dp2;\n\tstatic BitSet ef,of;\n\n\tstatic void solve() {\n\t\tdp=new int[(int)1e6+1];\n\t\tdp2=new int[(int)1e6+1];\n\t\tef=new BitSet((int)1e7);\n\t\tof=new BitSet((int)1e7);\n\t\tArrays.fill(dp,INF);\n\t\tArrays.fill(dp2,INF);\n\t\tdp[0]=dp2[0]=0;\n\t\tint[] tet=new int[100];\n\t\tfor(int i=1;i<100;i++){\n\t\t\ttet[i]=tet[i-1]+i*(i+1)/2;\n\t\t\tif(i%4==1)\n\t\t\t\tof.set(tet[i]);\n\t\t\telse\n\t\t\t\tef.set(tet[i]);\n\t\t}\n\n\t\tfor(;;){\n\t\t\tint n=ir.nextInt();\n\t\t\tif(n==0)\n\t\t\t\tbreak;\n\t\t\tout.println(count(n,tet)+\" \"+count_odd(i,tet));\n\t\t}\n\t}\n\n\tstatic int count(int n,int[] tet){\n\t\tif(dp[n]!=INF)\n\t\t\treturn dp[n];\n\t\tif(ef.get(n)||of.get(n))\n\t\t\treturn 1;\n\t\tfor(int i=1;i<=n/2;i++){\n\t\t\tdp[n]=Math.min(dp[n], count(i,tet)+count(n-i,tet));\n\t\t}\n\t\treturn dp[n];\n\t}\n\n\tstatic int count_odd(int n,int[] tet){\n\t\tif(dp2[n]!=INF)\n\t\t\treturn dp2[n];\n\t\tif(of.get(n))\n\t\t\treturn 1;\n\t\tfor(int i=1;i<=n/2;i++){\n\t\t\tdp2[n]=Math.min(dp2[n], count_odd(i,tet)+count_odd(n-i,tet));\n\t\t}\n\t\treturn dp2[n];\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tinit();\n\t\twhile (true){\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve(n));\n\t\t}\n\t}\n\t\n\tstatic int[] tri;\n\tstatic int[] quad;\n\tstatic int[] minQuad;\n\tstatic int[] minQuad2;\n\n\tstatic void init(){\n\t\ttri = new int[1500];\n\t\t\n\t\tfor(int i = 1; i < tri.length; i++){\n\t\t\ttri[i] = i*(i + 1)/2;\n\t\t}\n\t\t\n\t\tquad = new int[200];\n\t\tquad[1] = 1;\n\t\tfor(int i = 2; i < quad.length; i++){\n\t\t\tquad[i] = quad[i - 1] + tri[i];\n//\t\t\tSystem.out.println(\"i = \"+i+\" quad \"+quad[i]);\n\t\t}\n\t\t\n\t\tminQuad = new int[1000001];\n\t\tminQuad2 = new int[1000001];\n\t\tArrays.fill(minQuad, Integer.MAX_VALUE);\n\t\tArrays.fill(minQuad2, Integer.MAX_VALUE);\n\t\t\n\t\tminQuad[0] = 0;\n\t\tminQuad2[0] = 0;\n\t\t\n\t\tfor(int i = 1; i < minQuad.length ; i++){\n\t\t\tfor(int j = 1; j < quad.length; j++){\n\t\t\t\tif(quad[j] > i){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if(quad[j] == i){\n\t\t\t\t\tminQuad[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminQuad[i] = Math.min(minQuad[i], minQuad[quad[j]]+minQuad[i-quad[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 1; j < quad.length; j++){\n\t\t\t\tif(quad[j] > i){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(quad[j]%2 == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(quad[j] == i){\n\t\t\t\t\tminQuad2[i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tminQuad2[i] = Math.min(minQuad2[i], minQuad2[quad[j]]+minQuad2[i-quad[j]]);\n\t\t\t\t\t\n//\t\t\t\t\tif(i == 20)System.out.println(\"j = \"+j+\" (quad[j]=\"+quad[j]+\") \"+minQuad2[quad[j]]+\"+\"+minQuad2[i-quad[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tif(i < 100){\n//\t\t\t\tSystem.out.print(minQuad2[i]+\" \");\n//\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic String solve(int n){\n\t\t\n\t\treturn minQuad[n]+\" \"+minQuad2[n];\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int[] lib = new int[181];\n    int[] lib2 = new int[46];\n    int libi = 0;\n    int lib2i = 0;\n    for (int i = 1; ; i++) {\n      int k = (i * (i + 1) * (i + 2)) / 6;\n      lib[libi++] = k;\n      if (k % 2 == 1) {\n        lib2[lib2i++] = k;\n      }\n      if (k >= 1000000) {\n        break;\n      }\n    }\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      System.out.println(calc(n, lib) + \" \" + calc(n, lib2));\n    }\n  }\n\n  static int calc(int n, int[] lib) {\n    int[] dp = new int[n + 1];\n    for (int i = 0; i <= n; i++) {\n      dp[i] = i;\n    }\n    for (int i = 1; i < lib.length; i++) {\n      int[] dp2 = new int[n + 1];\n      int v = lib[i];\n      if (lib[i] > n) {\n//        System.out.println(\"--------\");\n//        for (int o = 0; o < i; ++o) {\n//          for (int j = 0; j <= n; ++j) {\n//            System.out.printf(\" %2d\", dp[o][j]);\n//          }\n//          System.out.println();\n//        }\n\n        return dp[n];\n      }\n      for (int j = 0; j <= n; j++) {\n        if (dp[j] == Integer.MAX_VALUE) {\n          continue;\n        }\n        for (int k = 0; j + k * v <= n; k++) {\n          dp2[j + k * v] = Math.min(dp2[j + k * v], dp[j] + k);\n        }\n        dp = dp2.clone();\n      }\n    }\n    return dp[n];\n  }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main{\n  static int N = 1000000;\n  public void run(java.io.InputStream in, java.io.PrintStream out){\n    java.util.Scanner sc = new java.util.Scanner(in);\n    int[] a, b, c;\n    int i, j, n;\n\n    a = new int[180];\n    b = new int[N]; c = new int[N];\n\n    for(i = 0;i < N;i++){\n      b[i] = N; c[i] = N;\n    }\n    for(i = 1;i * (i + 1) * (i + 2) / 6 < N;i++){\n      a[i - 1] = i * (i + 1) * (i + 2) / 6;\n      b[a[i - 1] - 1] = 1;\n      if((i * (i + 1) * (i + 2) / 6) % 2 == 1)c[a[i - 1] - 1] = 1;\n    }\n\n    for(i = 0;i < N;i++){\n      for(j = 0;j < 180;j++){\n        if(i + a[j] < N && b[i + a[j]] > b[i] + 1)b[i + a[j]] = b[i] + 1;\n        if(a[j] % 2 == 1 && i + a[j] < N\n        && c[i + a[j]] > c[i] + 1)c[i + a[j]] = c[i] + 1;\n      }\n    }\n\n    for(;;){\n      n = sc.nextInt();\n      if(n == 0)break;\n      out.println(b[n - 1] + \" \" + c[n - 1]);\n    }\n\n    sc.close();\n  }\n  public static void main(String[] args){\n    (new Main()).run(System.in, System.out);\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor (int i = 1; i * (i + 1) * (i + 2) / 6 <= 1000000; i++) {\n\t\t\tlist.add(i * (i + 1) * (i + 2) / 6);\n\t\t}\n\t\tint n = list.size();\n\t\tint m = 1000000;\n\t\tint[] dp1 = new int[m];\n\t\tint[] dp2 = new int[m];\n\t\tArrays.fill(dp1, Integer.MAX_VALUE);\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\t\tdp1[0] = 0;\n\t\tdp2[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (j - list.get(i) >= 0) {\n\t\t\t\t\tdp1[j] = Math.min(dp1[j], dp1[j - list.get(i)] + 1);\n\t\t\t\t\tif (list.get(i) % 2 == 1) {\n\t\t\t\t\t\tdp2[j] = Math.min(dp2[j], dp2[j - list.get(i)] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (;;) {\n\t\t\tint ball = sc.nextInt();\n\t\t\tif (ball == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(dp1[ball] + \" \" + dp2[ball]);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint[] DP = new int[1000001];\n\t\tint[] ODD_DP = new int[1000001];\n\t\t\n\t\tfor(int j = 0; j <= 1000000; j++){\n\t\t\tDP[j] = ODD_DP[j] = -1;\n\t\t}\n\t\t\n\t\tDP[0] = 0;\n\t\tODD_DP[0] = 0;\n\t\t\n\t\tfor(int i = 0; ; i++){\n\t\t\tint number = ((i + 1) * (i + 2) * (i + 3)) / 6;\n\t\t\t\n\t\t\tif(number > 1000000){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j <= (1000000 - number); j++){\n\t\t\t\tif(DP[j] != -1){\n\t\t\t\t\tif(DP[j + number] == -1){\n\t\t\t\t\t\tDP[j + number] = (DP[j] + 1);\n\t\t\t\t\t}else if(DP[j + number] > DP[j] + 1){\n\t\t\t\t\t\tDP[j + number] = (DP[j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(number % 2 == 1){\n\t\t\t\tfor(int j = 0; j <= (1000000 - number); j++){\n\t\t\t\t\tif(ODD_DP[j] != -1){\n\t\t\t\t\t\tif(ODD_DP[j + number] == -1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (ODD_DP[j] + 1);\n\t\t\t\t\t\t}else if(ODD_DP[j + number] > ODD_DP[j] + 1){\n\t\t\t\t\t\t\tODD_DP[j + number] = (ODD_DP[j] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(DP[n] + \" \" + ODD_DP[n]);\n\t\t\t\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int W;\n    int[] w,w2;\n    int[] dp,dp2;\n    int odd = 45,all = 180;\n    int INF = 1000000, max = 1000000;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int oddI = 0;\n        w = new int[180];\n        w2 = new int[45];\n        for(int i=1,j=i*(i+1)*(i+2)/6; j<max; i++,j=i*(i+1)*(i+2)/6){\n            w[i-1] = j;\n            if(j%2!=0) w2[oddI++] = j;\n        }\n\n        dp();\n\n        while(true){\n            W = sc.nextInt();\n            if(W==0) break;\n\n            System.out.println(dp[W]+\" \"+dp2[W]);\n        }\n    }\n\n    void dp(){\n        dp = new int[max]; dp2 = new int[max];\n        Arrays.fill(dp,INF); Arrays.fill(dp2,INF);\n        dp[0] = 0; dp2[0] = 0;\n        for(int i=0; i<all-1; i++){\n            for(int j=0; j<max; j++){\n                if(j-w[i]>=0){\n                    dp[j] = Math.min(dp[j], dp[j-w[i]]+1);\n                }\n                if(i<odd && j-w2[i]>=0){\n                    dp2[j] = Math.min(dp2[j], dp2[j-w2[i]]+1);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.System.*;\n\nclass Main {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n\n\n    public void run() {\n    \tList<Integer> pollock=new ArrayList<Integer>();\n\n    \tfor(int i=1;i*(i+1)*(i+2)/6<1000000;i++){\n    \t\tpollock.add(i*(i+1)*(i+2)/6);\n    \t}\n\n    \twhile(true){\n        \tint n=sc.nextInt();\n        \tif(n==0)return;\n\n        \tint n1=n,n1c=10;\n\n        \tfor(int i1=0;i1<=n;i1++){\n        \t\tint v1=pollock.get(i1);\n        \t\tif(v1==n1)n1c=Math.min(1,n1c);\n        \t\tfor(int i2=i1;i2<=n-i1;i2++){\n            \t\tint v2=pollock.get(i2);\n            \t\tif(v1+v2==n1)n1c=Math.min(2,n1c);\n        \t\t\tfor(int i3=i2;i3<=n-i1-i2;i3++){\n                \t\tint v3=pollock.get(i3);\n                \t\tif(v1+v2+v3==n1)n1c=Math.min(3,n1c);\n        \t\t\t\tfor(int i4=i3;i4<=n-i1-i2-i3;i4++){\n                    \t\tint v4=pollock.get(i4);\n                    \t\tif(v1+v2+v3+v4==n1)n1c=Math.min(4,n1c);\n        \t\t\t\t\tfor(int i5=i4;i5<=n-i1-i2-i3-i4;i5++){\n                        \t\tint v5=pollock.get(i5);\n                        \t\tif(v1+v2+v3+v4+v5==n1)n1c=Math.min(5,n1c);\n        \t\t\t\t\t}\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t}\n        \tint n2=n,n2c=0;\n        \tfor(int j=pollock.size()-1;j>=0;j--){\n        \t\tint v=pollock.get(j);\n        \t\tif(v%2==1){\n        \t\t\twhile(n2>=v){\n\t        \t\t\tn2-=v;\n        \t\t\t\tn2c++;\n        \t\t\t}\n        \t\t\tif(n2==0){\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n\n        \tln(n1c+\" \"+n2c);\n\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    public int[] nextIntArray(int n){\n        int[] res=new int[n];\n        for(int i=0;i<n;i++){\n            res[i]=sc.nextInt();\n        }\n        return res;\n    }\n    public static void pr(Object o) {\n        out.print(o);\n    }\n    public static void ln(Object o) {\n        out.println(o);\n    }\n    public static void ln() {\n        out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int N,min,cnt;\n\tstatic int[] a =new int[180];\n\tstatic int[] b =new int[45];\n\tstatic int[] already;\n\tstatic{\n\t\tint cnt=0;\n\t\tfor(int i = 1;tetrahedral(i)<=1000000;i++){\n\t\t\tint t = tetrahedral(i);\n\t\t\ta[cnt++]=t;\n\t\t}\n\t\tfor(int i = 0;i<a.length;i++){\n\t\t\t//System.out.println(a[i]);\n\t\t}\t\t\n\t\talready=new int[1000001];\n\t\tcnt=0;\n\t\tfor(int i = 1;tetrahedral(i)<=1000000;i++){\n\t\t\tint t = tetrahedral(i);\n\t\t\tif(t%2==1){\n\t\t\t\tb[cnt++]=t;\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tN =cin.nextInt();\n\t\t\tif(N==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt=0;\n\t\t\tArrays.fill(already, min=Integer.MAX_VALUE);\n\t\t\tbacktracka(0,0);\n\t\t\tSystem.out.print(min);\n\t\t\tcnt=0;\n\t\t\tArrays.fill(already, min=Integer.MAX_VALUE);\n\t\t\tbacktrackb(0,0);\n\t\t\tSystem.out.println(\" \"+min);\n\t\t}\n\n\t}\n\tstatic void backtrackb(int sum,int idx){\n\t\tif(sum==N){\n\t\t\tmin=Math.min(min, cnt);\n\t\t}\n\t\tif(already[sum]<cnt||idx==b.length||min<cnt)return;\n\t\tfor(int i = 0;sum+b[idx]*i<=N;i++){\n\t\t\tif(min<cnt+i){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(already[sum+b[idx]*i]<cnt+i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcnt+=i;\n\t\t\talready[sum+b[idx]*i]=cnt;\n\t\t\tbacktrackb(sum+b[idx]*i,idx+1);\n\t\t\tcnt-=i;\n\t\t}\n\t}\n\tstatic void backtracka(int sum,int idx){\n\t\t/*if(Arrays.binarySearch(a, N-sum)>=0){\n\t\t\tmin=Math.min(min, cnt+1);\n\t\t\treturn;\n\t\t}*/\n\t\tif(sum==N){\n\t\t\tmin=Math.min(min, cnt);\n\t\t}\n\t\tif(already[sum]<cnt||idx==a.length||min<cnt)return;\n\t\tfor(int i = 0;sum+a[idx]*i<=N;i++){\n\t\t\tif(min<cnt+i){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(already[sum+a[idx]*i]<cnt+i){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tcnt+=i;\n\t\t\talready[sum+a[idx]*i]=cnt;\n\t\t\tbacktracka(sum+a[idx]*i,idx+1);\n\t\t\tcnt-=i;\n\t\t}\n\t}\n\tstatic int tetrahedral(int a){\n\t\treturn (a*(a+1)*(a+2))/6;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/*\n*/\nimport java.io.*;\n\nclass Main {\n\tstatic int map[];\n\tstatic int mapb[];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\trun();\n\t\t} catch(IOException e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n\tprivate static void run() throws IOException{\n\t\tfinal int MAX = 1000000;\n\t\tint n;\n\t\tint instant;\n\t\tmap = new int[MAX+1];\n\t\tmapb = new int[MAX+1];\n\t\t\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tfor(int i=1;i<=MAX;i++) {\n\t\t\t//if(i%100000==0)System.out.print(\".\");\n\t\t\tmap[i] = f(i);\n\t\t\tmapb[i] = fb(i);\n\t\t}\n\t\t//System.out.println(\"\");\n\t\t\n\t\twhile(true) {\n\t\t\tn = Integer.parseInt(in.readLine());\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tSystem.out.println(map[n] + \" \" + mapb[n]);\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\n\tprivate static int f(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > map[n-tk]) {\n\t\t\t\t\tmin = map[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 1+min;\n\t}\n\t\n\tprivate static int fb(int n) {\n\t\tint instant;\n\t\tint min=1000000;\n\t\tint tk;\n\t\t\n\t\tif(n<=0) return 0;\n\t\t\n\t\tfor(int i=n;i>0;i--) {\n\t\t\tif(i>1000) {\n\t\t\t\ti = 1000;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\ttk = i*(i+1)*(i+2)/6;\n\t\t\t\n\t\t\tif(n-tk < 0 || tk%2==0) continue;\n\t\t\t\n\t\t\tif(map[n-tk] > 0) {\n\t\t\t\tif(min > mapb[n-tk]) {\n\t\t\t\t\tmin = mapb[n-tk];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(min > (instant=f(n-tk))) {\n\t\t\t\tmin = instant;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\treturn 1+min;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n\n    public static void main(String[] args) throws Exception {\n        int[] mapa = new int[1000000];\n        int[] mapb = new int[1000000];\n        for(int i=0;i<1000000;i++){\n        \tmapa[i] = i;\n        \tmapb[i] = i;\n        }\n        for(int i=0;i<1000000;i++){\n        \tfor(int j=1;j<181;j++){\n        \t\tint t = j*(j+1)*(j+2)/6;\n        \t\tif(i+t>=1000000){\n        \t\t\tbreak;\n        \t\t}\n        \t\tmapa[i+t] = Math.min(mapa[i+t],Math.min(mapa[i]+mapa[t],mapa[i]+1));\n        \t\tif(t%2==1){\n        \t\t\tmapb[i+t] = Math.min(mapb[i+t],Math.min(mapb[i]+mapb[t],mapb[i]+1));\n        \t\t}\n        \t}\n        }\n        while(true){\n        \tint n = sc.nextInt();\n        \tif(n==0){\n        \t\tbreak;\n        \t}\n        \tout.println(mapa[n]+\" \"+mapb[n]);\n        \tout.flush();\n        }\n        sc.close();\n        out.close();\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Reader {\n    private final InputStream sc;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.sc = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = sc\n\n.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n        \n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ sc.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int min = Integer.MAX_VALUE;\n\tstatic int odd_min = Integer.MAX_VALUE;\n\tstatic int limit = 180;\n\n\t public static void main(String[] args)throws Exception{\n\n\t\t limit = 1000000;\n\n\t\t int[] dp = new int[limit];\n\t\t int[] dp_odd = new int[limit];\n\t\t \n\t\t for(int i=0;i<limit;i++)\n\t\t {\n\t\t\t dp[i]=i; \n\t\t\t dp_odd[i]=i;\n\t\t }\n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp[j] =j /frame; \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp[j] = Math.min(dp[j % frame] + count,dp[j]);\n\t\t\t }\n\t\t }\n\t\t \n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t if(frame % 2 ==0)\n\t\t\t\t continue;\t\t\n\t\t\t \n\t\t\t //??±?????£???\n\t\t\t for(int j = frame;j<limit;j++)\n\t\t\t {\n\t\t\t\t dp_odd[j] = Math.min(dp_odd[j],dp_odd[j-frame]+1);\n\t\t\t }\n\t\t\t \n\t\t\t /*\n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp_odd[j] =j /frame; \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp_odd[j] = Math.min(dp_odd[j % frame] + count,dp_odd[j]);\n\t\t\t }\n\t\t\t */\n\t\t\t \n\t\t }\n\t\t \n\n\t\t Scanner sc = new Scanner(System.in);\n\n\t\t while(true)\n\t\t {\n\t\t\t int n = sc.nextInt();\n\n\t\t\t if(n == 0)\n\t\t\t\t return;\n\n\t\t\t System.out.print(dp[n]);\n\t\t\t System.out.print(\" \");\n\t\t\t System.out.println(dp_odd[n]);\n\n\t\t }\n\n\t }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tstatic ArrayList<Integer> list = new ArrayList<Integer>();\n\tstatic ArrayList<Integer> oddList = new ArrayList<Integer>();\n\tstatic int[][] dp;\n\tstatic int[][] odp;\n\tstatic int n;\n\tstatic int INF = 2 << 22;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tmakeList();\n\t\tn = 1000000;\n\t\tdp = new int[1000001][list.size()+1];\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][0] = 0;\n\t\tdp();\n\t\t\n\t\todp = new int[1000001][oddList.size()+1];\n\t\tSystem.gc();\n\t\tfor(int i = 1; i <= 1000000; i++) {\n\t\t\tArrays.fill(odp[i], INF);\n\t\t}\n\t\todp[0][0] = 0;\n\t\toddDp();\n\t\tSystem.gc();\n\t\twhile(true) {\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint ansA = 0;\n\t\t\tint ansB = 0;\n\t\t\t\n\t\t\tansA = dp[n][list.size()];\n\t\t\tansB = dp[n][oddList.size()];\n\t\t\tSystem.out.println(ansA + \" \" + ansB);\n\t\t}\n\t}\n\tpublic static void dp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= list.size(); j++) {\n\t\t\t\tif(i - list.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-list.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-list.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 100000 == 0)\n\t\t\t\tSystem.gc();\n\t\t}\n\t}\n\tpublic static void oddDp() {\n\t\tfor(int i = 0; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= oddList.size(); j++) {\n\t\t\t\tif(i - oddList.get(j-1) >= 0) {\n\t\t\t\t\tif(dp[i-oddList.get(j-1)][j] + 1 < dp[i][j-1]) {\n\t\t\t\t\t\tdp[i][j] = dp[i-oddList.get(j-1)][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i % 100000 == 0)\n\t\t\tSystem.gc();\n\t\t}\n\t\t\n\t}\n\tpublic static void makeList() {\n\t\tfor(int i = 1; i < 200000; i++) {\n\t\t\tint a = i * (i + 1) * (i + 2);\n\t\t\tif(a % 6 == 0) {\n\t\t\t\tif(a / 6 > 1000000) break;\n\t\t\t\tlist.add(a / 6);\n\t\t\t\tif((a / 6) % 2 == 1) {\n\t\t\t\t\toddList.add(a/6);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\n\n\nclass UnionFind{\n\tint Parent[];\n\tUnionFind(int n){//Initialize by -1\n\t\tParent=new int[n];\n\t\tArrays.fill(Parent, -1);\n\t}\n\tint root(int A) {//In which tree is A?\n\t\tif(Parent[A]<0)return A;\n\t\treturn Parent[A]=root(Parent[A]);\n    }\n\tint size(int A) {//size of tree which is include A\n\t\treturn -Parent[root(A)];\n\t}\n\tboolean connect(int A,int B) {//Connect A and B\n\t\tA=root(A);\n\t\tB=root(B);\n\t\tif(A==B) return false;\n\t\tif(size(A)<size(B)) {int C=0;C=B;B=A;A=C;}//SWAP\n\t\tParent[A]+=Parent[B];\n\t\tParent[B]=A;\n\t\treturn true;\n\t}\n}\nclass Pair<T,E>{\n\tpublic T first;\n\tpublic E second;\n\tvoid set(T x,E y){\n\t\tfirst=x;\n\t\tsecond=y;\n\t}\n}\t\nclass Pint{\n\tpublic int first;\n\tpublic int second;\n\tPint(int x,int y){\n\t\tfirst=x;\n\t\tsecond=y;\n\t}\n\tvoid set(int x,int y){\n\t\tfirst=x;\n\t\tsecond=y;\n\t}\n}\nclass Tpair{\n\tpublic int first;\n\tpublic int second;\n\tpublic long third;\n\tTpair(int x,int y,long z){\n\t\tfirst=x;\n\t\tsecond=y;\n\t\tthird=z;\n\t}\n\tvoid set(int x,int y,long z){\n\t\tfirst=x;\n\t\tsecond=y;\n\t\tthird=z;\n    }\n}\npublic class Main {\n\tstatic FastScanner scan=new FastScanner();\n\tstatic Scanner scanner=new Scanner(System.in);\n\tstatic Random rand=new Random();\n\tstatic long mod=1000000007;\n\tstatic double eps=1.0E-14;\n\tstatic int big=Integer.MAX_VALUE;\n\tstatic double PI=3.14159265358979323846262338327950288;\n\tstatic long modlcm(long a,long b) {return a*b*modinv(GCD(a,b),mod);}\n\tstatic long GCD (long a, long b) {return b>0?GCD(b,a%b):a;}\n\tstatic long lcm (long a, long b) {return a*b/GCD(a,b);}\n\tstatic int min(int a,int b) {return a<b?a:b;}\n\tstatic long factorial(int i) {return i==1?1:i*factorial(i-1);}\n\tstatic int max(int ...i) {int x=i[0];for(int e:i)x=Math.max(x,e);return x;}\n\tstatic int min(int ...i) {int x=i[0];for(int e:i)x=Math.min(x,e);return x;}\n\tstatic long gcd(long ...i) {long x=i[0];for(long e:i)x=GCD(x,e);return x;}\n\tstatic long lmax(long ...i) {long x=i[0];for(long e:i)x=Math.max(x,e);return x;}\n\tstatic long lmin(long ...i) {long x=i[0];for(long e:i)x=Math.min(x,e);return x;}\n\tpublic static void main(String[]$) throws IOException{\n\t\tint arr[]={1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,\n\t\t\t\t1140,1330,1540,1771,2024,2300,2600,2925,3276,3654,4060,4495,4960,5456,5984,6545,\n\t\t\t\t7140,7770,8436,9139,9880,10660,11480,12341,13244,14190,15180,16215,17296,18424,\n\t\t\t\t19600,20825,22100,23426,24804,26235,27720,29260,30856,32509,34220,35990,37820,\n\t\t\t\t39711,41664,43680,45760,47905,50116,52394,54740,57155,59640,62196,64824,67525,\n\t\t\t\t70300,73150,76076,79079,82160,85320,88560,91881,95284,98770,102340,105995,109736,\n\t\t\t\t113564,117480,121485,125580,129766,134044,138415,142880,147440,152096,156849,161700,\n\t\t\t\t166650,171700,176851,182104,187460,192920,198485,204156,209934,215820,221815,227920,\n\t\t\t\t234136,240464,246905,253460,260130,266916,273819,280840,287980,295240,302621,310124,\n\t\t\t\t317750,325500,333375,341376,349504,357760,366145,374660,383306,392084,400995,410040,\n\t\t\t\t419220,428536,437989,447580,457310,467180,477191,487344,497640,508080,518665,529396,\n\t\t\t\t540274,551300,562475,573800,585276,596904,608685,620620,632710,644956,657359,669920,\n\t\t\t\t682640,695520,708561,721764,735130,748660,762355,776216,790244,804440,818805,833340,\n\t\t\t\t848046,862924,877975,893200,908600,924176,939929,955860,971970,988260,1004731,1021384,\n\t\t\t\t1038220,1055240};\n\t\tint dp[]=new int[1000010];\n\t\tint odddp[]=new int[1000010];\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tArrays.fill(odddp, Integer.MAX_VALUE);\n\t\tdp[0]=0;\n\t\todddp[0]=0;\n\t\tfor(int i=1;;i++) {\n\t\t\tint num=i*(i+1)*(i+2)/6;\n\t\t\tif(num>=1000010)break;\n\t\t\tfor(int j=num;j<1000010;j++) {\n\t\t\t\tdp[j]=min(dp[j],dp[j-num]+1);\n\t\t\t\tif((num&1)>0) {\n\t\t\t\t\todddp[j]=min(odddp[j],odddp[j-num]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true) {\n\t\t\tint x=scan.nextInt();\n\t\t\tif(x==0)break;\n\t\t\tSystem.out.println(dp[x]+\" \"+odddp[x]);\n\t\t}\n\t}\n\tstatic long nCr(long n,long r,long m) {\n\t\tlong ans=1;\n\t\tfor(long i=0;i<r;i++) {\n\t\t\tans*=(n-i);\n\t\t\tans%=m;\n\t\t}\n\t\tfor(long i=0;i<=r;i++) {\n\t\t\tans*=modinv(i,m);\n\t\t\tans%=mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic int lower_bound(int a[],int key) {\n\t\tint ok=a.length;\n\t\tint ng=-1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid=(ok+ng)/2;\n\t\t\tif(a[mid]>=key)ok=mid;\n\t\t\telse ng=mid;\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic int upper_bound(int a[],int key) {\n\t\tint ok=a.length;\n\t\tint ng=-1;\n\t\twhile(Math.abs(ok-ng)>1) {\n\t\t\tint mid=(ok+ng)/2;\n\t\t\tif(a[mid]>key)ok=mid;\n\t\t\telse ng=mid;\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic boolean isPrime (long n) {\n\t\tif (n==2) return true;\n\t\tif (n<2 || n%2==0) return false;\n\t\tdouble d = Math.sqrt(n);\n\t\tfor (int i=3; i<=d; i+=2)if(n%i==0){return false;}\n\t\treturn true;\n\t}\n\tstatic int upper_division(int a,int b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic long lupper_division(long a,long b) {\n\t\tif(a%b==0) {\n\t\t\treturn a/b;\n\t\t}\n\t\telse {\n\t\t\treturn a/b+1;\n\t\t}\n\t}\n\tstatic int[] setArray(int a) {\n\t\tint b[]=new int[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextInt();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic long[] lsetArray(int a) {\n\t\tlong b[]=new long[a];\n\t\tfor(int i=0;i<a;i++) {\n\t\t\tb[i]=scan.nextLong();\n\t\t}\n\t\treturn b;\n\t}\n\tstatic String reverse(String str) {\n\t\tchar ch[]=new char[str.length()];\n\t\tchar chch[]=str.toCharArray();\n\t\tint a=str.length();\n\t\tfor(int i=0;i<upper_division(a,2);i++) {\n\t\t\tch[i]=chch[ch.length-i-1];\n\t\t\tch[ch.length-1-i]=chch[i];\n\t\t}\n\t\treturn String.valueOf(ch);\n\t}\n\tpublic static void printArray(int[] que) {\n\t\tfor(int i=0;i<que.length-1;i++) {\n\t\t\tSystem.out.print(que[i]+\" \");\n\t\t}\n\t\tSystem.out.println(que[que.length-1]);\n\t}\n\tpublic static void lprintArray(long[] que) {\n\t\tfor(int i=0;i<que.length-1;i++) {\n\t\t\tSystem.out.print(que[i]+\" \");\n\t\t}\n\t\tSystem.out.println(que[que.length-1]);\n\t}\n\tpublic static int[][] doublesort(int[][]a) {\n\t\tArrays.sort(a,(x,y)->Integer.compare(x[0],y[0]));\n\t\treturn a;\n\t}\n\tpublic static long[][] ldoublesort(long[][]a) {\n\t\tArrays.sort(a,(x,y)->Long.compare(x[0],y[0]));\n\t\treturn a;\n\t}\n\tstatic long modpow(long x,long n,long mo) {\n\t        long sum=1;\n\t        while(n>0) {\n\t            if((n&1)==1) {\n\t                sum=sum*x%mo;\n\t            }\n\t            x=x*x%mo;\n\t            n>>=1;\n\t        }\n\t        return sum;\n\t    }\n\tpublic static char[] revch(char ch[]) {\n\t\tchar ret[]=new char[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static int[] revint(int ch[]) {\n\t\tint ret[]=new int[ch.length];\n\t\tfor(int i=ch.length-1,j=0;i>=0;i--,j++) {\n\t\t\tret[j]=ch[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tpublic static void warshall_floyd(int v[][],int n) {\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tv[i][j]=min(v[i][j],v[i][k]+v[k][j]);\n\t}\t\n\tpublic static long modinv(long a,long m) {\n\t\tlong b=m,u=1,v=0;\n\t\twhile(b!=0) {\n\t\t\tlong t=a/b;\n\t\t\ta-=t*b;\n\t\t\tlong x=a;\n\t\t\ta=b;\n\t\t\tb=x;\n\t\t\t\n\t\t\tu-=t*v;\n\t\t\tx=u;\n\t\t\tu=v;\n\t\t\tv=x;\n\t\t}\n\t\tu%=m;\n\t\tif(u<0)u+=m;\n\t\treturn u;\n\t}\n}\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n}\t\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.lang.ArrayIndexOutOfBoundsException;\nimport java.math.BigInteger;\n\nimport javax.script.AbstractScriptEngine;\n\n\n/**\n * @author yoshikyoto\n */\nclass Main extends MyUtil{\n\t// public static Graph g;\n\t\n\tpublic static void main(String[] args) throws Exception{\n\n\t\tint[] dp = new int[1000001];\n\t\tint[] odp = new int[1000001];\n\t\tfor(int i = 0; i <= 1000000; i++){\n\t\t\tdp[i] = i;\n\t\t\todp[i] = i;\n\t\t}\n\t\t\n\t\tfor(int n = 3, p = 4; p <= 1000000; n++){\n\t\t\tfor(int i = 0; i+p <= 1000000; i++){\n\t\t\t\tdp[i+p] = Math.min(dp[i+p], dp[i] + 1);\n\t\t\t}\n\t\t\t\n\t\t\tif(p % 2 == 1){\n\t\t\t\tfor(int i = 0; i+p <= 1000000; i++){\n\t\t\t\t\todp[i+p] = Math.min(odp[i+p], odp[i] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// pの値をここで更新\n\t\t\tp = n * (n+1) * (n+2) / 6;\n\t\t}\n\t\t\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t// aの長さはせいぜい180しかない\n\t\t\n\t\twhile(true){\n\t\t\tint num = Integer.parseInt(br.readLine());\n\t\t\tif(num == 0) break;\n\t\t\tSystem.out.println(dp[num] + \" \" + odp[num]);\n\t\t}\n\t}\n}\n\n\n// --- ここから下はライブラリ ----------\n \nclass ArrayComp implements Comparator<int[]>{\n\tpublic int compare(int[] a, int[] b){\n\t\tint l = Math.min(a.length, b.length);\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i] == b[i]) continue;\n\t\t\treturn a[i] - b[i];\n\t\t}\n\t\treturn 0;\n\t}\n}\n \nclass Node extends ArrayList<Edge>{\n\tint index, depth = -1, dist = -1;\n\tNode(int index){this.index = index;}\n\tNode parent;\n\tboolean visited = false;\n}\nclass Edge{\n\tint from, to, cost;\n\tEdge(int from, int to, int cost){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n}\nclass NodeComparator implements Comparator<Node>{\n\tpublic int compare(Node a, Node b){\n\t\treturn a.dist - b.dist;\n\t}\n}\n \nclass Graph{\n\tNode n[];\n\tGraph(int node_count){\n\t\tn = new Node[node_count];\n\t\tfor(int i = 0; i < node_count; i++) n[i] = new Node(i);\n\t}\n\tpublic void add(Edge e){\n\t\tn[e.from].add(e);\n\t}\n\tpublic Node get(int i){return n[i];}\n\tpublic Node lca(int a, int b){\n\t\t// 浅い方をaとする\n\t\tNode nodeA, nodeB;\n\t\tif(n[a].depth < n[b].depth){\n\t\t\tnodeA = n[a];\n\t\t\tnodeB = n[b];\n\t\t}else{\n\t\t\tnodeA = n[b];\n\t\t\tnodeB = n[a];\n\t\t}\n\t\t// 同じ深さまで親をたどる\n\t\tint diff = nodeB.depth - nodeA.depth;\n\t\tfor(int k = 0; k < diff; k++){\n\t\t\tnodeB = nodeB.parent;\n\t\t}\n\t\t// 共通祖先を見つける\n\t\twhile(nodeA != nodeB){\n\t\t\tnodeA = nodeA.parent;\n\t\t\tnodeB = nodeB.parent;\n\t\t}\n\t\treturn nodeA;\n\t}\n\tpublic void calcDepth(int root){\n\t\tArrayDeque<Integer> que = new ArrayDeque<Integer>();\n\t\tque.push(root);\n\t\tn[root].depth = 0;\n \n\t\twhile(que.size() > 0){\n\t\t\tint curr = que.pop();\n\t\t\tNode curr_node = n[curr];\n\t\t\tfor(Edge e : curr_node){\n\t\t\t\tint next = e.to;\n\t\t\t\tNode next_node = n[next];\n\t\t\t\tif(next_node.depth == -1){\n\t\t\t\t\tnext_node.depth = curr_node.depth + 1;\n\t\t\t\t\tnext_node.parent = curr_node;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic int[] dijkstra(int s){\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>(n.length, new NodeComparator());\n\t\tNode start_node = new Node(s);\n\t\tstart_node.dist = 0;\n\t\tq.add(start_node);\n\t\tint[] dist = new int[n.length];\n\t\tfor (int i = 0; i < dist.length; i++)  dist[i] = -1;\n\t\tdist[s] = 0;\n \n\t\twhile(q.size() > 0){\n\t\t\tNode currNode = q.poll();\n\t\t\tif(dist[currNode.index] < currNode.dist) continue;\n\t\t\tfor(Edge e : n[currNode.index]){\n\t\t\t\tNode nextNode = new Node(e.to);\n\t\t\t\tnextNode.dist = currNode.dist + e.cost;\n\t\t\t\tif(dist[e.to] == -1 || dist[e.to] > nextNode.dist){\n\t\t\t\t\tdist[e.to] = nextNode.dist;\n\t\t\t\t\tq.add(nextNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n}\n \n \n \nclass Regex{\n\tPattern p; Matcher m; String str;\n\tRegex(String regex_str){p = Pattern.compile(regex_str);}\n\tvoid setStr(String str){m = p.matcher(str);}\n\tboolean find(){return m.find();}\n\tString group(int i){return m.group(i);}\n\tString group(){return m.group();}\n}\n \n/**\n * UnionFindTree \n * @author yoshikyoto\n */\nclass UnionFindTree{\n\tpublic int[] parent, rank;\n\tpublic int n;\n\tpublic int count;\n\t// 初期化\n\tUnionFindTree(int n){\n\t\tthis.n = n;\n\t\tcount = n;\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t// 根を求める\n\tint find(int x){\n\t\tif(parent[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t// xとyの集合を結合\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){\n\t\t\treturn;\n\t\t}\n\t\tif(rank[x] < rank[y]){\n\t\t\tparent[x] = y;\n\t\t\tcount--;\n\t\t}else{\n\t\t\tparent[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tcount--;\n\t\t}\n\t}\n\t// xとyが同じ集合か\n\tboolean same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n \n \n\n \nclass CountHashMap<E> extends HashMap<E, Integer>{\n\tArrayList<E> keyArray = new ArrayList<E>();\n\tpublic void add(E key){add(key, 1);}\n\tpublic void add(E key, Integer value){\n\t\tif(containsKey(key)){value += get(key);\n\t\t}else{keyArray.add(key);}\n\t\tput(key, value);\n\t}\n}\n \n/**\n * MyUtil\n * @author yoshikyoto\n */\nclass MyUtil extends MyIO{\n\tpublic static Random rand = new Random();\n\tpublic static int digit(int n){return String.valueOf(n).length();}\n\tpublic static String reverse(String s){return (new StringBuffer(s)).reverse().toString();}\n\tpublic static void dsort(int[] a){\n\t\tArrays.sort(a);\n\t\tint l = a.length;\n\t\tfor(int i = 0; i < l/2; i++){\n\t\t\tint tmp = a[i]; a[i] = a[l-1-i]; a[l-1-i] = tmp;\n\t\t}\n\t}\n\tpublic static void sleep(int t){try{Thread.sleep(t);}catch(Exception e){}}\n\tpublic static int sum(int[] a){int s = 0; for(int i = 0; i < a.length; i++)s+=a[i]; return s;}\n\tpublic static int[] cp(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) b[i] = a[i];\n\t\treturn b;\n\t}\n\tpublic static int randomInt(int min, int max){return min + rand.nextInt(max - min + 1);}\n\tstatic boolean inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\tpublic static boolean isUpper(char c){return 'A'<=c&&c<='Z';}\n\tpublic static boolean isLower(char c){return 'a'<=c&&c<='z';}\n\tpublic static char toUpper(char c){\n\t\tif(isLower(c)) return (char)(c - 'a' + 'A');\n\t\treturn c;\n\t}\n\tpublic static char toLower(char c){\n\t\tif(isUpper(c)) return (char)(c - 'A' + 'a');\n\t\treturn c;\n\t}\n\tpublic static int[] swap(int[] arr, int i, int j){\n\t\tint[] ret = cp(arr);\n\t\tint tmp = ret[i];\n\t\tret[i] = ret[j];\n\t\tret[j] = tmp;\n\t\treturn ret;\n\t}\n\tpublic static int toInt(boolean[] a){\n\t\tint pow = 1, ret = 0, l = a.length;\n\t\tfor(int i = 0; i < l; i++){\n\t\t\tif(a[i]) ret += pow;\n\t\t\tpow *= 2;\n\t\t}\n\t\treturn ret;\n\t}\n}\n \n/**\n * MyIO\n * @author yoshikyoto\n */\nclass MyIO extends MyMath{\n\tstatic Scanner sc = new Scanner(new InputStreamReader(System.in));\n\tpublic static char scNextChar(){return sc.next().charAt(0);}\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tpublic static String line;\n \n\tpublic static int ins[];\n\tpublic static int[] readIntMap() throws IOException{return parseInt(readLine().split(\" \"));}\n\tpublic static int readIntMap(int i) throws Exception{\n\t\tif(i == 0) ins = readIntMap();\n\t\treturn ins[i];\n\t}\n\tpublic static int[][] readIntMap(int n, int m) throws IOException{\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readIntMap();\n\t\treturn ret;\n\t}\n\tpublic static int[] readIntToMap(int n) throws IOException{\n\t\tint[] ret = new int[n];\n\t\tfor(int i = 0; i < n; i++) ret[i] = readInt();\n\t\treturn ret;\n\t}\n\tpublic static int[] readNoDistIntMap() throws IOException{\n\t\tString[] strs = readLine().split(\"\");\n\t\tint l = strs.length;\n\t\tint[] ret = new int[l-1];\n\t\tfor(int i = 1; i < l; i++)\n\t\t\tret[i-1] = parseInt(strs[i]);\n\t\treturn ret;\n\t}\n\tpublic static boolean readToLine() throws IOException{return (line = br.readLine()) != null;}\n\tpublic static String readLine() throws IOException{return br.readLine();}\n\tpublic static int readInt() throws IOException{return Integer.parseInt(br.readLine());}\n\tpublic static int[] parseInt(String[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Integer.parseInt(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static double[] parseDouble(String[] arr){\n\t\tdouble[] res = new double[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++)res[i] = Double.parseDouble(arr[i]);\n\t\treturn res;\n\t}\n\tpublic static boolean[] parseBool(String[] arr){\n\t\tint[] t = parseInt(arr);\n\t\tboolean[] res = new boolean[t.length];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tif(t[i] == 1){res[i] = true;\n\t\t\t}else{res[i] = false;}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int parseInt(Object o){return Integer.parseInt(o.toString());}\n}\n \nclass MyMath{\n\tpublic static int max(int[] arr){return max(arr, 0, arr.length-1);}\n\tpublic static int max(int[] arr, int l, int r){\n\t\tint max = arr[l];\n\t\tfor(int i = l+1; i <= r; i++)\n\t\t\tmax = Math.max(max, arr[i]);\n\t\treturn max;\n\t}\n\tpublic static int min(int[] arr){return min(arr, 0, arr.length-1);}\n\tpublic static int min(int[] arr, int l, int r){\n\t\tint min = arr[l];\n\t\tfor(int i = l+1; i <= r; i++)\n\t\t\tmin = Math.min(min, arr[i]);\n\t\treturn min;\n\t}\n\tpublic static boolean isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t\t// 並行な場合\n\t\tint m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n\t\tif(m == 0) return false;\n\t\t// 媒介変数の値が0より大きく1以下なら交差する、これは問題の状況によって変わるかも。\n\t\tdouble r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n\t\tdouble s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n\t\treturn (0 < r && r <= 1 && 0 < s && s <= 1);\n\t}\n\tpublic static boolean isParallel(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n\t\tif((x2-x1)*(y4-y3) == (y2-y1)*(x4-x3)) return true;\n\t\telse return false;\n\t}\n\tpublic static double sq(double d){return d*d;}\n\tpublic static int sq(int i){return i*i;}\n\tpublic static int sqdist(int x1, int y1, int x2, int y2){return (x1-x2) + sq(y1-y2);}\n\tpublic static double sqdist(double x1, double y1, double x2, double y2){return sq(x1-x2) + sq(y1-y2);}\n\tpublic static double dist(int x1, int y1, int x2, int y2){return Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tpublic static double dist(double x1, double y1, double x2, double y2){return Math.sqrt(sqdist(x1, y1, x2, y2));}\n\tstatic long comb(long n, long m){\n\t\tif(n < m) return 0;\n\t\tlong c = 1; m = (n - m < m ? n - m : m);\n\t\tfor(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;}\n\t\treturn c;\n\t}\n\tstatic int gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\n\t/**\n\t * aの中から、合計がborderを超えるペア（重複除く）の数を数える\n\t */\n\tstatic int countPair(int[] a, int border){\n\t\tint count = 0, l = a.length, i = 0, j = l-1;\n\t\tfor (; i < l; i++) {\n\t\t\tfor (; j >= 0; j--) if(a[i] + a[j] <= border) break;\n\t\t\tcount += l - (j + 1);\n\t\t\tif(j < i) count--;\n\t\t}\n\t\treturn count/2;\n\t}\n\t// modに対応したDPのCombination\n\tstatic int mcomb(int n, int m, int mod){\n\t\tn = n - m;\n\t\tint[][] dp = new int[n+1][m+1];\n\t\tfor(int i = 0; i <= n; i++) dp[i][0] = 1;\n\t\tfor(int i = 0; i <= m; i++) dp[0][i] = 1;\n\t\t// mod = 0 の時は余りを取らない\n\t\tif(mod != 0){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m];\n\t\t// それ以外の時は mod をとっていく\n\t\t}else{\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m] % mod;\n\t\t}\n\t}\n\t\n\n\tstatic long mcomb(int n, int m, long mod){\n\t\tn = n - m;\n\t\tlong[][] dp = new long[n+1][m+1];\n\t\tfor(int i = 0; i <= n; i++) dp[i][0] = 1;\n\t\tfor(int i = 0; i <= m; i++) dp[0][i] = 1;\n\t\t// mod = 0 の時は余りを取らない\n\t\tif(mod != 0){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m];\n\t\t// それ以外の時は mod をとっていく\n\t\t}else{\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dp[n][m] % mod;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic int[] list1 = new int[180];\n\tstatic int[] list2 = new int[45];\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tmakeList();\n\t\tint[] dp1 = new int[1000000];\n\t\tint[] dp2 = new int[1000000]; \n\t\t\n\n\t\tArrays.fill(dp1, 2 << 27);\n\t\tArrays.fill(dp2, 2 << 27);\n\n\t\tdp1[0] = dp2[0] =  0;\n\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tfor(int j = list1[i]; j < 1000000; j++) {\n\t\t\t\tdp1[j] = Math.min(dp1[j-list1[i]]+1, dp1[j]);\n\t\t\t\tif(list1[i] % 2 == 1) dp2[j] = Math.min(dp2[j-list1[i]]+1, dp2[j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true) {\n\t\t\tint a = sc.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tSystem.out.println(dp1[a] + \" \" + dp2[a]);\n\t\t}\n\t}\n\t\n\tstatic void makeList() {\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tint sum = (i+1)*(i+2)*(i+3)/6;\n\t\t\tlist1[i] = sum;\n\t\t}\n\t}\n\t\n\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\t\n\t\tsolve();\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tSystem.out.println(dp[0][n] +\" \" +dp[1][n]);\n\t\t}\n\t}\n\n\tint[][] dp = new int[2][100001];\n\tpublic void solve() {\n\t\tint[] tetra = new int[200];\n\t\tfor(int i=1;i<tetra.length;i++){\n\t\t\ttetra[i] = i*(i+1)*(i+2)/6;\n\t\t}\n\t\t\n\t\t\n\t\tArrays.fill(dp[0], 10000);\n\t\tArrays.fill(dp[1], 10000);\n\t\tdp[0][0] = dp[1][0] =0;\n\t\tfor(int i=1;i<tetra.length;i++){\n\t\t\tint t = tetra[i];\n\t\t\tfor(int j=0;j<dp[0].length-t;j++){\n\t\t\t\tdp[0][j+t] = Math.min(dp[0][j+t], dp[0][j]+1);\n\t\t\t\tif(t%2==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[1][j+t] = Math.min(dp[1][j+t], dp[1][j]+1);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(solve(input));\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static String solve(int input) {\n\t\tint c = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tc = i;\n\t\t\tlist.add((i*(i+1)*(i+2))/6);\n\t\t}\n\n\t\tint[][] dp = new int[input][c];\n\n\t\tfor(int i=0 ; i<c ; i++) {\n\t\t\tint v = Integer.parseInt(list.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v) == 0) {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v), dp[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v) {\n\t\t\t\t\t\tdp[j][i] = dp[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp[j][i] = Math.min(((j+1)/v)+dp[((j+1)%v) - 1][i-1], dp[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//return dp[input-1][c-1];\n\t\tint re = dp[input-1][c-1];\n\t\tdp = null;\n\t\tint c2 = 0;\n\t\tArrayList list2 = new ArrayList();\n\t\tfor(int i=1 ; (i*(i+1)*(i+2))/6 <= input ; i++) {\n\t\t\tif(((i*(i+1)*(i+2)/6) % 2) != 0) {\n\t\t\t\tc2++;\n\t\t\t\tlist2.add((i*(i+1)*(i+2))/6);\n\t\t\t}\n\t\t}\n\n\t\tint[][] dp2 = new int[input][c2];\n\n\t\tfor(int i=0 ; i<c2 ; i++) {\n\t\t\tint v2 = Integer.parseInt(list2.get(i).toString());\n\t\t\tfor(int j=0 ; j<input ; j++) {\n\t\t\t\tif(i == 0)\n\t\t\t\t\tdp2[j][0] = j+1;\n\t\t\t\telse {\n\t\t\t\t\tif(((j+1)%v2) == 0) {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2), dp2[j][i-1]);\n\t\t\t\t\t}else if((j+1) < v2) {\n\t\t\t\t\t\tdp2[j][i] = dp2[j][i-1];\n\t\t\t\t\t}else {\n\t\t\t\t\t\tdp2[j][i] = Math.min(((j+1)/v2)+dp2[((j+1)%v2) - 1][i-1], dp2[j][i-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn re + \" \" + dp2[input-1][c2-1];\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[] dp1=new int[1000001];\n\tstatic int[] dp2=new int[1000001];\n\tstatic int[] p=new int[100000];\n\tstatic int max=0;\n\t\n\tstatic void n() {\n\t\tfor(int num=1; num*(num+1)*(num+2)/6<1000000; num++) {\n\t\t\tdp1[num*(num+1)*(num+2)/6]=1;\n\t\t\tif((num*(num+1)*(num+2)/6)%2!=0){\n\t\t\t\tdp2[num*(num+1)*(num+2)/6]=1;\n\t\t\t}\n\t\t\tp[num]=num*(num+1)*(num+2)/6;\n\t\t\tmax=num;\n\t\t}\n\t}\n\n\tstatic void dp() {\n\t\tfor(int num=1; num<=1000000; num++) {\n\t\t\tfor(int i=1; i<=max; i++) {\n\t\t\t\tif(num>p[i]) {\n\t\t\t\t\tdp1[num]=Math.min(dp1[num], dp1[num-p[i]]+1);\n\t\t\t\t\t//System.out.println(\"i=\"+i+\"dp1[\"+num+\"]=\"+dp1[num]);\n\t\t\t\t\tif(p[i]%2!=0)\n\t\t\t\t\tdp2[num]=Math.min(dp2[num], dp2[num-p[i]]+1);\n\t\t\t\t\t//System.out.println(\"i=\"+i+\"dp2[\"+num+\"]=\"+dp2[num]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\tArrays.fill(dp1, 100000000);\n\t\t\tArrays.fill(dp2, 100000000);\n\t\t\tn();\n\t\t\tdp();\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0) break;\n\t\t\t\t\n\t\t\t\tSystem.out.println(dp1[N]+\" \"+dp2[N]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class Main{\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1167();\n\t}\n\t\n\tclass AOJ1167{\n\t\tAOJ1167(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0)\tbreak;\n\t\t\t\tsolve(n);\n\t\t\t}\n\t\t}\n\t\tfinal int INF=1<<29;\n\t\tvoid solve(int n){\n\t\t\tfinal int MAX=1000000;\n\t\t\tint[]\ta=new int[MAX+1],\n\t\t\t\t\tb=new int[MAX+1];\n\t\t\tfor(int i=1,j=1; true; ++i){\n\t\t\t\ta[i]=i*(i+1)*(i+2)/6;\n\t\t\t\tif(a[i]%2==1)\tb[j++]=a[i];\n\t\t\t\tif(a[i]>=MAX)\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] dp=new int[n+1];\n\t\t\tfor(int i=0; i<=n; ++i)dp[i]=INF;\n\t\t\tdp[0]=0;\n\t\t\tfor(int i=1; a[i]<=n; ++i){\n\t\t\t\tfor(int j=0; j<=n; ++j){\n\t\t\t\t\tint tmp=j-a[i];\n\t\t\t\t\tif(tmp>=0){\n\t\t\t\t\t\tdp[j]=min(dp[j], dp[j-a[i]]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(Arrays.toString(dp));\n\t\t\tSystem.out.print(dp[n]);\n\t\t\t\n\t\t\tfor(int i=0; i<=n; ++i)dp[i]=INF;\n\t\t\tdp[0]=0;\n\t\t\tfor(int i=1; b[i]<=n; ++i){\n\t\t\t\tfor(int j=0; j<=n; ++j){\n\t\t\t\t\tint tmp=j-b[i];\n\t\t\t\t\tif(tmp>=0){\n\t\t\t\t\t\tdp[j]=min(dp[j], dp[j-b[i]]+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(Arrays.toString(dp));\n\t\t\tSystem.out.println(\" \"+dp[n]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE;\n\t\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint MAX = 1000000;\n\t\tint [] dpAll = new int[MAX + 1];\n\t\tint [] dpOdd = new int[MAX + 1];\n\t\tArrays.fill(dpAll,INF);\n\t\tArrays.fill(dpOdd, INF);\n\t\tArrayList<Integer> data = new ArrayList<Integer>();\n\t\tfor(int i = 0; ;i++){\n\t\t\tint sum = i * (i + 1) * (i + 2) / 6;\n\t\t\tif(sum > MAX) break;\n\t\t\tdata.add(sum);\n\t\t}\n\t\tint len = data.size();\n\t\tfor(int i=0; i < len; i++){\n\t\t\tint value = data.get(i);\n\t\t\tdpAll[value] = 1;\n\t\t\tif(value % 2 == 1){\n\t\t\t\tdpOdd[value] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i <MAX; i++){\n\t\t\tfor(int j = 0;j < len; j++ ){\n\t\t\t\tint ind = i + data.get(j);\n\t\t\t\tif(ind <= MAX){\n\t\t\t\t\tint value = dpAll[i] + 1;\n\t\t\t\t\tdpAll[ind] = Math.min(value, dpAll[ind]);\n\t\t\t\t\tif(dpOdd[i] != INF && data.get(j) % 2 == 1){\n\t\t\t\t\t\tvalue = dpOdd[i] + 1;\n\t\t\t\t\t\tdpOdd[ind] = Math.min(value, dpOdd[ind]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tSystem.out.println(dpAll[n] + \" \" + dpOdd[n]);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int min;\n\tstatic int MAX=1000000;\n\tstatic int dp[]=new int[MAX];\n\tstatic int dp2[]=new int[MAX];\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n,i;\n\t\tArrays.fill(dp, -1);\n\t\tArrays.fill(dp2, -1);\n\t\tfor(i=0;i<MAX;i++){\n\t\t\tmin=1<<29;\n\t\t\tserch(i);\n\t\t\tmin=1<<29;\n\t\t\tserch2(i);\n\t\t}\n\t\twhile(true){\n\t\tn=sc.nextInt();\n\t\tif(n==0) break;\n\t\tSystem.out.println(dp[n]+\" \"+dp2[n]);\n\t\t}\n\t}\n\tstatic int serch(int N){\n\t\tint k;\n\t\tif(dp[N]!=-1) return dp[N];\n\t\tif(N==0){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=1;;i++){\n\t\t\tk=i*(i+1)*(i+2)/6;\n\t\t\tif(N<k) break;\n\t\t\tmin=Math.min(min, serch(N-k)+1);\n\t\t}\n\t\tdp[N]=min;\n\t\treturn min;\n\t}\n\tstatic int serch2(int N){\n\t\tint k;\n\t\tif(dp2[N]!=-1) return dp2[N];\n\t\tif(N==0){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=1;;i++){\n\t\t\tk=i*(i+1)*(i+2)/6;\n\t\t\tif(k%2==0) continue;\n\t\t\tif(N<k) break;\n\t\t\tmin=Math.min(min, serch2(N-k)+1);\n\t\t}\n\t\tdp2[N]=min;\n\t\treturn min;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tfinal int INF=1<<26;\n\tfinal int[] vx={0,1,0,-1}, vy={1,0,-1,0};\n\tpublic static void main(String[] args) {\n\t\tnew Main().C();\n\t}\n\t\n\t\n\tvoid D(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tint[][] b=new int[W][H],w=new int[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tb[x][y]=(Character.isDigit(line.charAt(x))?(line.charAt(x)-'0'):0);\n\t\t\t\t\t//w[x][y]\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] close=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\tvoid C(){\n\t\tArrayList<Integer> in=new ArrayList<Integer>();\n\t\tint max=0;\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)\tbreak;\n\t\t\tin.add(n);\n\t\t\tmax=max(max,n);\n\t\t}\n\t\t\n\t\tint[] k=new int[max+1],a=new int[max+1];\n\t\tArrays.fill(k, INF);\tArrays.fill(a, INF);\n\t\tArrayList<Integer> list=new ArrayList<Integer>();\n\t\tfor(int n=1;;n++){\n\t\t\tint temp=n*(n+1)*(n+2)/6;\n\t\t\tif(temp>max)\tbreak;\n\t\t\tlist.add(temp);\n\t\t\ta[temp]=1;\n\t\t\tif(temp%2==1)\tk[temp]=1;\n//\t\t\tfor(int i=1,j=temp; j<=max; i++,j+=temp){\n//\t\t\t\ta[j]=i;\n//\t\t\t\tif(temp%2==1)\tk[temp]=1;\n//\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=2; i<=max; i++){\n\t\t\t//if(a[i]<INF && k[i]<INF)\tcontinue;\n\t\t\tfor(int j:list){\n\t\t\t\tif(j>i)\tbreak;\n\t\t\t\ta[i]=min(a[i],a[j]+a[i-j]);\n\t\t\t\tk[i]=min(k[i],k[j]+k[i-j]);\n\t\t\t}\n//\t\t\tfor(int j=1; j*2<=i; j++){\n//\t\t\t\ta[i]=min(a[i],a[j]+a[i-j]);\n//\t\t\t\tk[i]=min(k[i],k[j]+k[i-j]);\n//\t\t\t}\n\t\t}\n\t\t\n//\t\tSystem.out.println(\"K\");\n//\t\tfor(int i=1; i<=max; i++)\tSystem.out.print(k[i]+\" \");\n\t\t\n\t\tfor(int i:in){\n\t\t\tSystem.out.println(a[i]+\" \"+k[i]);\n\t\t}\n\t}\n\t\n\tvoid A(){\n\t\tfinal int[] xdis={-1,0,1,0}, ydis={0,-1,0,1};\n\t\twhile(true){\n\t\t\tint n= sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<Integer, Integer[] > map = new HashMap<Integer, Integer[]>();\n\t\t\tInteger [] first = {0,0};\n\t\t\tmap.put(0, first);\n\t\t\tfor(int i=1; i < n; i++){\n\t\t\t\tint ni = sc.nextInt();\n\t\t\t\tint di = sc.nextInt();\n\t\t\t\tInteger [] now = map.get(ni);\n\t\t\t\tint newx = now[0] + xdis[di];\n\t\t\t\tint newy = now[1] + ydis[di];\n\t\t\t\tInteger [] newarray = {newx, newy};\n\t\t\t\tmap.put(i, newarray);\n\t\t\t}\n\t\t\tfirst = map.get(0);\n\t\t\tint minx =first[0];\n\t\t\tint maxx = minx;\n\t\t\tint miny = first[1];\n\t\t\tint maxy = first[1];\n\t\t\tfor(Integer now: map.keySet()){\n\t\t\t\tInteger [] nowarray = map.get(now);\n\t\t\t\tint x = nowarray[0];\n\t\t\t\tint y = nowarray[1];\n\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\tmaxx = Math.max(maxx, x);\n\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\tmaxy = Math.max(maxy, y);\n\t\t\t\t\n\t\t\t}\n\t\t\tint resx = maxx - minx +1;\n\t\t\tint resy = maxy - miny + 1;\n\t\t\tSystem.out.println(resx + \" \" + resy );\n\t\t}\n\t}\n\t\n\tvoid B(){\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tboolean[][] ww=new boolean[W*2+2][2*H+1],hh=new boolean[2*W+1][2*H+2];\n\t\t\tfor(int i=1; i<=H; i++){\n\t\t\t\tfor(int x=1; x<W; x++)\tww[2*x+1][i]=sc.nextInt()==1;\n\t\t\t\tif(i<H)\tfor(int y=1; y<=W; y++)\thh[y][2*i+1]=sc.nextInt()==1;\n\t\t\t}\n\t\t\t\n\t\t\t//disp(hh);\n\t\t\t\n\t\t\tPriorityQueue<CB> open=new PriorityQueue<CB>();\n\t\t\topen.add(new CB(1,1,1));\n\t\t\tint[][] close=new int[W+1][H+1];\n\t\t\tfor(int i=0; i<=W; i++)\tfor(int j=0; j<=H; j++)\tclose[i][j]=INF;\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tCB now=open.poll();\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint xx=now.x+vx[i],yy=now.y+vy[i];\n\t\t\t\t\tif(!(0<xx && xx<=W && 0<yy && yy<=H))\tcontinue;\n\t\t\t\t\tint x2=(2*now.x+2*xx)/2,y2=(2*now.y+2*yy)/2;\n\t\t\t\t\tif(ww[x2][now.y] || hh[now.x][y2]){\n\t\t\t\t\t\t//System.out.println(x2+\" \"+y2);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(now.s+1>=close[xx][yy])\tcontinue;\n\t\t\t\t\tif(xx==W && yy==H){\n\t\t\t\t\t\tans=min(ans,now.s+1);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\topen.add(new CB(xx,yy,now.s+1));\n\t\t\t\t\tclose[xx][yy]=now.s+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((ans>=INF?0:ans));\n\t\t}\n\t}\n\tclass CB implements Comparable<CB>{\n\t\tint x,y,s;\n\t\tCB(int x,int y,int s){this.x=x; this.y=y;this.s=s;}\n\t\t@Override public int compareTo(CB o) {\n\t\t\tif(this.s<o.s)\treturn -1;\n\t\t\tif(this.s>o.s)\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tvoid disp(boolean[][] b){\n\t\tfor(int y=0; y<b[0].length; y++){\n\t\t\tfor(int x=0; x<b.length; x++)\tSystem.out.print(b[x][y]?1:0);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tvoid run() {\n\n\t\tint[] fd = new int[180];\n\n\t\tint[] fd2 = new int[180];\n\n\t\tint k=0;\n\n\t\tfor (int i = 1, j = 0; i * (i + 1) * (i + 2) / 6 < 1000000; i++, j++) {\n\n\t\t\tfd[j] = i * (i + 1) * (i + 2) / 6;\n\n\t\t\tif ((fd[j] & 1) == 1) {\n\n\t\t\t\tfd2[k] = fd[j];\n\n\t\t\t\tk++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfd2 = Arrays.copyOfRange(fd2,0 , k);\n\n\t\t\n\n\t\tint dp[] = new int[1000000];\n\n\t\tint dp2[] = new int[1000000];\n\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\n\t\tArrays.fill(dp2, Integer.MAX_VALUE);\n\n\t\tdp[0] = dp2[0] = 0;\n\n\t\tSystem.out.println(Arrays.toString(fd));\n\n\t\tSystem.out.println(Arrays.toString(fd2));\n\n\t\tfor (int i = 0; i < 1000000; i++) {\n\n\t\t\tif (dp[i] == Integer.MAX_VALUE)\n\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = 0; j < fd.length; j++) {\n\n\t\t\t\tif (i + fd[j] >= 1000000)\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdp[i + fd[j]] = Math.min(dp[i] + 1, dp[i + fd[j]]);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < 1000000; i++) {\n\n\t\t\tif (dp2[i] == Integer.MAX_VALUE)\n\n\t\t\t\tcontinue;\n\n\t\t\tfor (int j = 0; j < fd2.length; j++) {\n\n\t\t\t\tif (i + fd2[j] >= 1000000)\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdp2[i + fd2[j]] = Math.min(dp2[i] + 1, dp2[i + fd2[j]]);\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tfor (;;) {\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif (n == 0)\n\n\t\t\t\tbreak;\n\n\t\t\tSystem.out.println(dp[n] + \" \" + dp2[n]);\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main{\n\n\tstatic int[] dp = new int[1000001];\n\tstatic int[] dp_odd = new int[1000001];\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\n\t\tsolve();\n\n\t\twhile(true){\n\t\t\tint input = Integer.parseInt(s.nextLine());\n\t\t\tif(input == 0)\n\t\t\t\treturn;\n\t\t\tSystem.out.println(dp[input] + \" \" + dp_odd[input]);\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void solve() {\n\t\tfor(int i=1 ; i<1000001 ; i++) {\n\t\t\tdp[i] = i;\n\t\t\tdp_odd[i] = i;\n\t\t}\n\n\t\tfor(int i=2 ; (i*(i+1)*(i+2)/6) < 1000000 ; i++) {\n\t\t\tint n = i*(i+1)*(i+2)/6;\n\t\t\tfor(int j=n ; j < 1000000 ; j++) {\n\t\t\t\tdp[j] = Math.min(dp[j], dp[j-n]+1);\n\t\t\t\tif((n%2) != 0)\n\t\t\t\t\tdp_odd[j] = Math.min(dp_odd[j], dp_odd[j-n]+1);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static void main(String[] arrs){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\tArrayList<Integer> pollock = new ArrayList<Integer>();\n\t\tArrayList<Integer> pollockk = new ArrayList<Integer>();\n\n\t\tint pollocknum = 0;\n\t\tint[] pollocktrue = new int[1000000 + 1];\n\t\tArrays.fill(pollocktrue, Integer.MAX_VALUE/2);\n\t\t\n\t\tfor(int i = 1; pollocknum <= 1000000 - 1; i++){\n\t\t\tif(pollocknum%2 != 0){\n\t\t\t\tpollocktrue[pollocknum] = 1;\n\t\t\t\tpollockk.add(pollocknum);\n\t\t\t}\n\t\t\tpollocknum = (i * (i + 1) * (i + 2)) / 6;\n\t\t\tpollock.add(pollocknum); \n\t\t}\n\t\t\n\t\tfor(int i = 0; i < pollockk.size();i++){\n\t\t\tfor(int j = 0 ; j < pollocktrue.length; j++){\n\t\t\t\tif(j + pollockk.get(i) <= 1000000){\n\t\t\t\t\tpollocktrue[j + pollockk.get(i)] = Math.min(pollocktrue[j + pollockk.get(i)], pollocktrue[j] + 1); \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\t\n\t\t\tArrayList<Integer> pollock2 = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> pollock3 = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> pollock4 = new ArrayList<Integer>();\n\t\t\t\n\n\t\t\tif(pollock.contains((Integer)n)){\n\t\t\t\tSystem.out.println(\"1 \" + pollocktrue[n]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpollocknum = 0;\n\t\t\tfor(int i = 0; pollock.get(i) < n ;i++){\n\t\t\t\t//System.out.println(i);\n\t\t\t\tfor(int j = i;  pollocknum <= n ;j++){\n\t\t\t\t\t//System.out.println(pollocknum);\n\t\t\t\t\tpollocknum = pollock.get(i) + pollock.get(j);\n\t\t\t\t\tpollock2.add(pollocknum);\n\t\t\t\t}\n\t\t\t\tpollocknum = 0;\n\t\t\t}\n\t\t\tif(pollock2.contains((Integer)n)){\n\t\t\t\tSystem.out.println(\"2 \"+ pollocktrue[n]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpollocknum = 0;\n\t\t\tCollections.sort(pollock2);\n\t\t\tfor(int i = 0; pollock.get(i) < n ;i++){\n\t\t\t\tfor(int j = 0; pollocknum <= n;j++){\n\t\t\t\t\tpollocknum = pollock.get(i) + pollock2.get(j);\n\t\t\t\t\tpollock3.add(pollocknum);\n\t\t\t\t}\n\t\t\t\tpollocknum = 0;\n\t\t\t}\n\t\t\tpollocknum = 0;\n\t\t\tfor(int i = 0; pollock2.get(i) < n ;i++){\n\t\t\t\tfor(int j = 0; pollocknum <= n;j++){\n\t\t\t\t\tpollocknum = pollock2.get(i) + pollock.get(j);\n\t\t\t\t\tpollock3.add(pollocknum);\n\t\t\t\t}\n\t\t\t\tpollocknum = 0;\n\t\t\t}\n\t\t\tif(pollock3.contains((Integer)n)){\n\t\t\t\tSystem.out.println(\"3 \"+ pollocktrue[n]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCollections.sort(pollock3);\n\t\t\tpollocknum = 0;\n\t\t\tfor(int i = 0; pollock.get(i) < n ;i++){\n\t\t\t\tfor(int j = 0; pollocknum <= 0 ;j++){\n\t\t\t\t\tpollocknum = pollock.get(i) + pollock3.get(j);\n\t\t\t\t\tpollock4.add(pollocknum);\n\t\t\t\t}\n\t\t\t\tpollocknum = 0;\n\t\t\t}\n\t\t\tpollocknum = 0;\n\t\t\tfor(int i = 0; pollock2.get(i) < n ;i++){\n\t\t\t\tfor(int j = i;  pollocknum <= n ;j++){\n\t\t\t\t\tpollocknum = pollock2.get(i) + pollock2.get(j);\n\t\t\t\t\tpollock4.add(pollocknum);\n\t\t\t\t}\n\t\t\t\tpollocknum = 0;\n\t\t\t}\n\t\t\tif(pollock4.contains((Integer)n)){\n\t\t\t\tSystem.out.println(\"4 \"+ pollocktrue[n]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCollections.sort(pollock4);\n\t\t\tSystem.out.println(\"5 \"+ pollocktrue[n]);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "package AOJ1167.copy;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int min = Integer.MAX_VALUE;\n\tstatic int odd_min = Integer.MAX_VALUE;\n\tstatic int limit = 180;\n\n\t public static void main(String[] args)throws Exception{\n\n\t\t limit = 1000000;\n\n\t\t int[] dp = new int[limit];\n\t\t int[] dp_odd = new int[limit];\n\t\t \n\t\t for(int i=0;i<limit;i++)\n\t\t {\n\t\t\t dp[i]=i; \n\t\t\t dp_odd[i]=i;\n\t\t }\n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp[j] =j /frame; \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp[j] = Math.min(dp[j % frame] + count,dp[j]);\n\t\t\t }\n\t\t }\n\t\t \n\n\t\t for(int i=2;i<181;i++)\n\t\t {\n\t\t\t int frame = i * (i+1) * (i+2) /6;\n\t\t\t \n\t\t\t if(frame % 2 ==0)\n\t\t\t\t continue;\n\t\t\t \n\t\t\t int count = 0;\n\t\t\t for(int j=1;j<limit;j++)\n\t\t\t {\n\t\t\t\t if(j % frame == 0){\n\t\t\t\t \t dp_odd[j] =j /frame; \n\t\t\t\t     count++;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t\t dp_odd[j] = Math.min(dp_odd[j % frame] + count,dp_odd[j]);\n\t\t\t }\n\t\t }\n\t\t \n\n\t\t Scanner sc = new Scanner(System.in);\n\n\t\t while(true)\n\t\t {\n\t\t\t int n = sc.nextInt();\n\n\t\t\t if(n == 0)\n\t\t\t\t return;\n\n\t\t\t System.out.print(dp[n]);\n\t\t\t System.out.print(\" \");\n\t\t\t System.out.println(dp_odd[n]);\n\n\t\t }\n\n\t }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int[] dp = new int[1000000 + 1];\n    int[] dp2 = new int[1000000 + 1];\n    for (int i = 1; i < dp.length; i++) {\n      dp[i] = i;\n      dp2[i] = i;\n    }\n    for (int i = 1; ; i++) {\n      int k = (i * (i + 1) * (i + 2)) / 6;\n      if (k >= 1000000) {\n        break;\n      }\n      for (int j = 0; j + k < 1000000; j++) {\n        dp[j + k] = Math.min(dp[j + k], dp[j] + 1);\n      }\n      if (k % 2 == 0) {\n        for (int j = 0; j + k < 1000000; j++) {\n          dp2[j + k] = Math.min(dp2[j + k], dp2[j] + 1);\n        }\n      }\n    }\n\n    while (true) {\n      int n = sc.nextInt();\n      if (n == 0) {\n        break;\n      }\n      System.out.println(dp[n] + \" \" + dp2[n]);\n    }\n  }\n\n  static int calc(int n, int[] lib) {\n    int[] dp = new int[n + 1];\n    for (int i = 0; i <= n; i++) {\n      dp[i] = i;\n    }\n    for (int i = 1; i < lib.length; i++) {\n      int[] dp2 = new int[n + 1];\n      int v = lib[i];\n      if (lib[i] > n) {\n//        System.out.println(\"--------\");\n//        for (int o = 0; o < i; ++o) {\n//          for (int j = 0; j <= n; ++j) {\n//            System.out.printf(\" %2d\", dp[o][j]);\n//          }\n//          System.out.println();\n//        }\n\n        return dp[n];\n      }\n      for (int j = 0; j <= n; j++) {\n        if (dp[j] == Integer.MAX_VALUE) {\n          continue;\n        }\n        for (int k = 0; j + k * v <= n; k++) {\n          dp2[j + k * v] = Math.min(dp2[j + k * v], dp[j] + k);\n        }\n        dp = dp2.clone();\n      }\n    }\n    return dp[n];\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n\tstatic int[] list1 = new int[180];\n\tstatic int[] list2 = new int[45];\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tmakeList();\n\t\tint[] dp1 = new int[1000000];\n\t\tint[] dp2 = new int[1000000]; \n\t\t\n\n\t\tArrays.fill(dp1, 2 << 27);\n\t\tArrays.fill(dp2, 2 << 27);\n\n\t\tdp1[0] = dp2[0] =  0;\n\n\t\tfor(int i = 0; i < 180; i++) {\n\t\t\tfor(int j = 0; j < 1000000; j++) {\n\t\t\t\tif(dp1[j] == 2 << 27) continue;\n\t\t\t\tif(j + list1[i]  >= 1000000) break;\n\t\t\t\tdp1[j + list1[i]] = Math.min(dp1[j+list1[i]], dp1[j] + 1);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 45; i++) {\n\t\t\tfor(int j = 0; j < 1000001; j++) {\n\t\t\t\tif(dp2[j] == 2 << 27) continue;\n\t\t\t\tif(j + list2[i] >= 1000000) break;\n\t\t\t\tdp2[j + list2[i]] = Math.min(dp2[j+list2[i]], dp2[j] + 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(true) {\n\t\t\tint a = sc.nextInt();\n\t\t\tif(a == 0) break;\n\t\t\tSystem.out.println(dp1[a] + \" \" + dp2[a]);\n\t\t}\n\t}\n\t\n\tstatic void makeList() {\n\t\tint count1 = 0;\n\t\tint count2 = 0;\n\t\tfor(int i = 1; i < 1000001; i++) {\n\t\t\tint sum = i*(i+1)*(i+2)/6;\n\t\t\tif(sum > 1000001) break;\n\t\t\tif(sum % 2 == 1) {\n\t\t\t\tlist1[count1++] = sum;\n\t\t\t\tlist2[count2++] = sum;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlist1[count1++] = sum;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\t\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Aizu\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar numbers = new List<int>();\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tvar value = int.Parse(ReadLine());\n\t\t\t\tif (value == 0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnumbers.Add(value);\n\t\t\t}\n\n\t\t\tvar max = numbers.Max();\n\n\t\t\tvar counts1 = new int[max + 1];\n\t\t\tfor(var i = 0; i <= max; i++)\n\t\t\t{\n\t\t\t\tcounts1[i] = int.MaxValue - 1;\n\t\t\t}\n\t\t\tcounts1[0] = 0;\n\n\t\t\tvar counts2 = new int[max + 1];\n\t\t\tfor (var i = 0; i <= max; i++)\n\t\t\t{\n\t\t\t\tcounts2[i] = int.MaxValue - 1;\n\t\t\t}\n\t\t\tcounts2[0] = 0;\n\n\t\t\tvar sums = new List<int>();\n\t\t\tvar index = 1;\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tvar sum = index * (index + 1) * (index + 2) / 6;\n\t\t\t\tif(sum > max)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsums.Add(sum);\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tfor(var i = 1; i <= max; i++)\n\t\t\t{\n\t\t\t\tfor(var j = 0; j < sums.Count; j++)\n\t\t\t\t{\n\t\t\t\t\tif(i >= sums[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tcounts1[i] = Min(counts1[i], counts1[i - sums[j]] + 1);\n\n\t\t\t\t\t\tif(sums[j] % 2 == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcounts2[i] = Min(counts2[i], counts2[i - sums[j]] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnumbers.ForEach(value => WriteLine($\"{counts1[value]} {counts2[value]}\"));\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n\n            var a = Enumerate(1000050, x => 1000000);\n            var b = Enumerate(1000050, x => 1000000);\n            a[0] = 0;\n            b[0] = 0;\n            for (int i = 1; i < 200; i++)\n            {\n                var x = i * (i + 1) * (i + 2) / 6;\n\n                for (int j = 0; j < 1000050; j++)\n                {\n                    if (j + x >= 1000050) break;\n                    a[j + x] = Math.Min(a[j + x], a[j] + 1);\n                    if (x % 2 == 1)\n                        b[j + x] = Math.Min(b[j + x], b[j] + 1);\n                }\n            }\n            Debug.WriteLine(149*150*151/6);\n            for (;;)\n            {\n                var n = ri;\n                if (n == 0) return;\n                IO.Printer.Out.WriteLine(\"{0} {1}\", a[n], b[n]);\n\n            }\n        }\n\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Math;\n \npublic class Solve{\n    static public int mod = 1000000007;\n    static public string al = \"abcdefghijklmnopqrstuvwxyz\";\n    public static void Main(){\n        // 方針\n        //\n        \n        var count = new int[1000001];\n        var countodd = new int[1000001];\n        for(int i=1;i<=1000000;i++){\n            count[i] = 999999999;\n            countodd[i] = 999999999;\n        }\n        for(int i=1;i<200;i++){\n            var f = i*(i+1)*(i+2)/6;\n            //WriteLine(f);\n            for(int j=f;j<=1000000;j++){\n                count[j] = Min(count[j],count[j-f]+1);\n                if(f%2 == 1) countodd[j] = Min(countodd[j],countodd[j-f]+1);\n            }\n        }\n        while(true){\n            var n = rint();\n            if(n == 0) break;\n            WriteLine($\"{count[n]} {countodd[n]}\");\n        }\n        \n        /*\n        var count = new int[66];\n        var countodd = new int[66];\n        for(int i=1;i<=65;i++){\n            count[i] = 999999999;\n            countodd[i] = 999999999;\n        }\n        for(int i=1;i<10;i++){\n            var f = i*(i+1)*(i+2)/6;\n            WriteLine(f);\n            for(int j=f;j<=65;j++){\n                count[j] = Min(count[j],count[j-f]+1);\n                if(i%2 == 1) countodd[j] = Min(countodd[j],count[j-f+1]);\n            }\n            WriteLine($\"       {countodd[40]}\");\n            //WriteLine(string.Join(\" \",countodd));\n        }\n        WriteLine(string.Join(\" \",count));\n        WriteLine(string.Join(\" \",countodd));\n        */\n\t\n\t\n    }\n    public static void swap(ref int a,ref int b){int temp = a;a= b;b = temp;}\n    static void charswap(ref char a,ref char b){char temp = a;a= b;b = temp;}\n    static int ncr(int n,int r){if(n<r)return 0;r = Min(r,n-r);long nn = 1;for(int i=n-r+1;i<=n;i++){nn = nn*i%mod;}long rr = 1;for(int i=1;i<=r;i++){rr = rr*i%mod;}rr = square((int)rr,mod-2);nn = nn * rr %mod;return (int)nn;}\n    // a^b mod\n    static int square(int a,int b){string binary = Convert.ToString(b,2);int bileng = binary.Length;long a_power = a;long value = 1;for(int i=bileng-1;i>=0;i--){if(binary[i] == '1'){value = value*a_power%mod;}a_power = a_power*a_power%mod;}return (int)value;}\n    static int square2(int a,int b){long output = 1;var list = new List<long>();int sh = 1;long n = a;list.Add(a);while(sh < b){sh *= 2;n = n*n%mod;list.Add(n);}for(int i=list.Count-1;i>=0;i--){if(b > sh){b -= sh;sh /= 2;output = output*list[i]%mod;}}return (int)output;}\n    //各種読取\n    static string rstr(){ return ReadLine(); }\n    static int rint(){ return int.Parse(ReadLine()); }\n    static long rlong(){ return long.Parse(ReadLine()); }\n    static string[] stra(){ return ReadLine().Split(' '); }\n    static char[] chara(){ string[] a=stra();string b=\"\";for(int i=0;i<a.Length;i++){b+=a[i];}return b.ToCharArray();}\n    static int[] inta(){ string[] read_str_array = ReadLine().Split(' '); int[] return_int_array = new int[read_str_array.Length]; for(int countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_int_array[countup_i] = int.Parse(read_str_array[countup_i]); } return return_int_array; }\n    static int[,] inta2(int num_array,int in_array){ int[,] int_array2 = new int[num_array,in_array]; for(int i=0;i<num_array;i++){ int[] temp_array = inta(); for(int j=0;j<in_array;j++){ int_array2[i,j] = temp_array[j]; } } return int_array2; }\n    static long[] longa(){ string[] read_str_array = ReadLine().Split(' '); long[] return_long_array = new long[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_long_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_long_array; }\n    static double[] doublea(){ string[] read_str_array = ReadLine().Split(' '); double[] return_double_array = new double[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_double_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_double_array; }\n    // -----------------------------\n    static long divideup(long divided,long divid){ long temp_divide = divided/divid; if(divided % divid > 0){ temp_divide++; } return temp_divide; }\n    static long GCD(long a,long b){ if(a < b){ long temp = a; a = b; b = temp; } if(a % b == 0){ return b; } else{ long temp = b; b = a%b; a = temp; return GCD(a,b); } }\n    static long LCM(long a,long b){ return a * b / GCD(a,b); }\n    static void WriteArray(int[,] a,int b,int c){for(int i=0;i<b;i++){for(int j=0;j<c;j++){if(j!=0) Write(\" \");Write(a[i,j]);}WriteLine();}}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing Library;\nusing static Library.Input;\n\nnamespace AtCoderTemplate {\n    class ProgramE {\n        static void Main () {\n            var array = Enumerable.Range(1, 200).ToArray();\n            for (int i = 1; i < 200; i++) array[i] += array[i - 1];\n            for (int i = 1; i < 200; i++) array[i] += array[i - 1];\n            var odd = array.Where(a => a % 2 == 1).ToArray();\n\n            var dp1 = Enumerable.Repeat(int.MaxValue >> 2, 1000001).ToArray();\n            dp1[0] = 0;\n            for (int i = 0; i < 200; i++)\n            {\n                for (int j = array[i]; j < 1000000; j++)\n                {\n                    dp1[j] = Math.Min(dp1[j], dp1[j - array[i]] + 1);\n                }\n            }\n\n            var dp2 = Enumerable.Repeat(int.MaxValue >> 2, 1000000).ToArray();\n            dp2[0] = 0;\n            foreach (var item in odd)\n            {\n                for (int j = item; j < 1000000; j++)\n                {\n                    dp2[j] = Math.Min(dp2[j], dp2[j - item] + 1);\n                }\n            }\n\n            while (true)\n            {\n                int N = NextInt;\n                if (N == 0) return;\n\n                System.Console.WriteLine($\"{dp1[N]} {dp2[N]}\");\n            }\n        }\n    }\n\n}\n\nnamespace Library {\n    class Input {\n        static IEnumerator<string> enumerator = new string[] { }.AsEnumerable ().GetEnumerator ();\n\n        public static string Line => Console.ReadLine ();\n\n        public static string[] StrArr => Line.Split (' ');\n\n        public static int NextInt => int.Parse (NextWord ());\n\n        public static long NextLong => long.Parse (NextWord ());\n\n        public static List<int> IntList => StrArr.Select (int.Parse).ToList ();\n\n        public static List<long> LongList => StrArr.Select (long.Parse).ToList ();\n\n        public static IEnumerable<long[]> TakeLine (int N) {\n            return Enumerable.Repeat (0, N).Select (_ => Console.ReadLine ().Split (' ').Select (long.Parse).ToArray ());\n        }\n\n        public static string NextWord () {\n            while (!enumerator.MoveNext ()) {\n                enumerator = StrArr.AsEnumerable ().GetEnumerator ();\n            }\n            return enumerator.Current;\n        }\n    }\n}\n\nnamespace Library {\n    \n    class Modular {\n        public const int mod = 1000000007;\n        public readonly long value;\n        public Modular (long value) { this.value = value; }\n        public static implicit operator Modular (long a) {\n            var m = a % mod;\n            return new Modular ((m < 0) ? m + mod : m);\n        }\n        public static Modular operator + (Modular a, Modular b) {\n            return a.value + b.value;\n        }\n        public static Modular operator - (Modular a, Modular b) {\n            return a.value - b.value;\n        }\n        public static Modular operator * (Modular a, Modular b) {\n            return a.value * b.value;\n        }\n        public static Modular Pow (Modular a, int n) {\n            switch (n) {\n                case 0:\n                    return 1;\n                case 1:\n                    return a;\n                default:\n                    var p = Pow (a, n / 2);\n                    return p * p * Pow (a, n % 2);\n            }\n        }\n        public static Modular operator / (Modular a, Modular b) {\n            return a * Pow (b, mod - 2);\n        }\n        private static readonly List<int> facs = new List<int> { 1 };\n        private static Modular Fac (int n) {\n            for (int i = facs.Count; i <= n; ++i) {\n                facs.Add ((int) (Math.BigMul (facs.Last (), i) % mod));\n            }\n            return facs[n];\n        }\n        public static Modular Ncr (int n, int r) {\n            return (n < r) ? 0 :\n                (n == r) ? 1 :\n                Fac (n) / (Fac (r) * Fac (n - r));\n        }\n        public static explicit operator int (Modular a) {\n            return (int) a.value;\n        }\n    }\n\n}\nnamespace Library {\n    class MyMath {\n        public static long Gcd (long a, long b) {\n            return b == 0 ? a : Gcd (b, a % b);\n        }\n\n        public static long Sqrt (long n) {\n            if (n < 0) return 0;\n            long a = 0, tmp = 0, b = 0;\n            for (int i = 62; i >= 0; i -= 2) {\n                tmp = (b << 1) + 1 <= (n >> i) ? 1 : 0;\n                a = a << 1 | tmp;\n                n -= (((b << 1) + 1) * tmp) << i;\n                b = (b << 1) + tmp + tmp;\n            }\n            return a;\n        }\n\n        public static long Nck (int n, int k) {\n            if (k == 0) return 1;\n            if (n == 0) return 0;\n            return n * Nck (n - 1, k - 1) / k;\n        }\n    }\n}\n\nnamespace Library {\n        public class PriorityQueue<T> {\n\n        readonly List<T> _heap = new List<T> ();\n        readonly Comparison<T> _comparison;\n\n        public PriorityQueue (Comparison<T> comparison) {\n            _comparison = comparison;\n        }\n\n        public PriorityQueue () : this (Comparer<T>.Default.Compare) { }\n\n        public PriorityQueue (IComparer<T> comparer) : this (comparer.Compare) { }\n\n        public void Enqueue (T item) {\n            _heap.Add (item);\n\n            int childID = _heap.Count - 1;\n            int parentID = (childID - 1) / 2;\n\n            while (childID > 0 && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                childID = parentID;\n                parentID = (parentID - 1) / 2;\n            }\n        }\n\n        public T Dequeue () {\n            var first = _heap.First ();\n            _heap[0] = _heap.Last ();\n            _heap.RemoveAt (_heap.Count - 1);\n\n            int parentID = 0;\n            int childID = parentID * 2 + 2;\n            if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n\n            while (childID < _heap.Count && _comparison (_heap[parentID], _heap[childID]) > 0) {\n                Swap (parentID, childID);\n                parentID = childID;\n                childID = parentID * 2 + 2;\n                if (childID >= _heap.Count || _comparison (_heap[childID], _heap[childID - 1]) > 0) childID--;\n            }\n\n            return first;\n        }\n\n        void Swap (int parent, int child) {\n            var tmp = _heap[parent];\n            _heap[parent] = _heap[child];\n            _heap[child] = tmp;\n        }\n\n        public T Peek () { return _heap[0]; }\n        public int Count => _heap.Count;\n        public bool Any () { return _heap.Any (); }\n        public List<T> Data => _heap;\n    }\n}\n\nnamespace Library {\n    \n    public class UnionFind {\n        public int[] Parents { get; set; }\n        public UnionFind (int size) {\n            Parents = Enumerable.Repeat (-1, size).ToArray ();\n        }\n\n        public int Find (int num) {\n            if (Parents[num] < 0) return num;\n\n            Parents[num] = Find (Parents[num]);\n            return Parents[num];\n        }\n\n        public int Size (int num) {\n            return -Parents[Find (num)];\n        }\n\n        public bool Same (int a, int b) {\n            return Find (a) == Find (b);\n        }\n\n        public void Unite (int a, int b) {\n            int x = Find (a), y = Find (b);\n\n            if (Size (x) > Size (y)) {\n                Parents[x] += Parents[y];\n                Parents[y] = x;\n            } else {\n                Parents[y] += Parents[x];\n                Parents[x] = y;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace _1167\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tint max = 1000000;\n\t\t\tList<int> num = new List<int>();\n\t\t\tList<int> odd = new List<int>();\n\t\t\tfor (int i = 1; ; i++)\n\t\t\t{\n\t\t\t\tint x = i * (i + 1) * (i + 2) / 6;\n\t\t\t\tif (x >= max * 2) break;\n\t\t\t\tnum.Add(x);\n\t\t\t\tif (x % 2 == 1) odd.Add(x);\n\t\t\t}\n\t\t\tint[] count = new int[max];\n\t\t\tint[] oddcount = new int[max];\n\t\t\tfor (int i = 1; i < max; i++)\n\t\t\t{\n\t\t\t\tint min = int.MaxValue;\n\t\t\t\tfor (int j = 0; num[j] <= i; j++)\n\t\t\t\t{\n\t\t\t\t\tmin = Math.Min(min, count[i - num[j]] + 1);\n\t\t\t\t}\n\t\t\t\tcount[i] = min;\n\t\t\t\tint oddmin = int.MaxValue;\n\t\t\t\tfor (int j = 0; odd[j] <= i; j++)\n\t\t\t\t{\n\t\t\t\t\toddmin = Math.Min(oddmin, oddcount[i - odd[j]] + 1);\n\t\t\t\t}\n\t\t\t\toddcount[i] = oddmin;\n\t\t\t}\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tint n = int.Parse(Console.ReadLine());\n\t\t\t\tif (n == 0) break;\n\t\t\t\tConsole.WriteLine(count[n] + \" \" + oddcount[n]);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using static System.Math;using static System.Console;using System.Collections.Generic;using System.Linq;using System;using System.Collections;\nusing System.Runtime.Serialization;\nusing System.Collections.Specialized;\nusing System.Security.Cryptography;\n\nclass Program\n{\n    #region Reader\n    static string ReadStr => Console.ReadLine();\n    static string[] ReadStrs => Console.ReadLine().Split(' ');\n    static int ReadInt => Convert.ToInt32(Console.ReadLine());\n    static int[] ReadInts => Console.ReadLine().Split(' ').Select(s => Convert.ToInt32(s)).ToArray();\n    static long ReadLong => Convert.ToInt64(Console.ReadLine());\n    static long[] ReadLongs => Console.ReadLine().Split(' ').Select(s => Convert.ToInt64(s)).ToArray();\n    #endregion\n    #region Method\n    static int mod = (int)Pow(10, 9) + 7;\n    public static int Mod(int a,int mod) { return a % mod >= 0 ? a % mod : a % mod + mod; }\n    public static long Mod(long a, int mod) { return a % mod >= 0 ? a % mod : a % mod + mod; }\n    #endregion\n\n\n\n\n\n    static void Main()\n    {\n\n        List<int> As = new List<int>();\n\n        int index = 0;\n        while (true)\n        {\n            int a = index * (index + 1) * (index + 2) / 6;\n            if (a <= 1000000)\n            {\n                As.Add(a);\n            }\n            else\n            {\n                break;\n            }\n            index++;\n        }\n        int M = As.Count;\n\n\n\n\n            int N = 1000000;\n\n\n            int infty = 1000000000;\n\n            //個数のdp[使ってよいポロック,生成された数字]\n\n\n\n            int[] ans = new int[N+1];\n            for (int i = 0; i < N+1; i++)\n            {\n                ans[i] = infty;\n            }\n            int[] prevDp = new int[N+1];\n            int[] currentDp;\n            for (int i = 0; i < N; i++)\n            {\n                prevDp[i] = infty;\n            }\n            prevDp[0] = 0;\n\n            for (int m = 1; m < M; m++)\n            {\n                currentDp = new int[N+1];\n                for (int i = 0; i <= N; i++)\n                {\n                    currentDp[i] = infty;\n                }\n                for (int n = 0; n <= N; n++)\n                {\n                    //m-1を使わなかったら\n                    //dp[m, n] = Min(dp[m - 1, n], dp[m, n]);\n                    currentDp[n] = Min(prevDp[n], currentDp[n]);\n\n                    if (n + As[m] <= N)\n                    {\n                        //使ったら(重複可)\n                        //dp[m, n + As[m - 1]] = Min(dp[m, n + As[m - 1]],dp[m, n] + 1);\n                        currentDp[n + As[m]] = Min(currentDp[n + As[m]], currentDp[n] + 1);\n    \n                            ans[n + As[m]] = Min(ans[n + As[m]], currentDp[n + As[m]]);\n                        \n                    }\n\n                }\n                prevDp = currentDp;\n            }\n\n\n\n\n            int[] ans2 = new int[N+1];\n            for (int i = 0; i < N+1; i++)\n            {\n                ans2[i] = infty;\n            }\n            prevDp = new int[N + 1];\n            currentDp = null;\n            for (int i = 0; i < N; i++)\n            {\n                prevDp[i] = infty;\n            }\n            prevDp[0] = 0;\n\n            for (int m = 1; m < M; m++)\n            {\n                currentDp = new int[N + 1];\n                for (int i = 0; i <= N; i++)\n                {\n                    currentDp[i] = infty;\n                }\n                for (int n = 0; n <= N; n++)\n                {\n                    //m-1を使わなかったら\n                    //dp[m, n] = Min(dp[m - 1, n], dp[m, n]);\n                    currentDp[n] = Min(prevDp[n], currentDp[n]);\n\n                    if (n + As[m] <= N&&As[m]%2 == 1)\n                    {\n                        //使ったら(重複可)\n                        //dp[m, n + As[m - 1]] = Min(dp[m, n + As[m - 1]],dp[m, n] + 1);\n                        currentDp[n + As[m]] = Min(currentDp[n + As[m]], currentDp[n] + 1);\n                \n                            ans2[n + As[m]] = Min(ans2[n + As[m]], currentDp[n + As[m]]);\n                        \n                    }\n\n                }\n                prevDp = currentDp;\n            }\n\n        List<string> anses = new List<string>();\n\n\n        while (true)\n        {\n            int q = ReadInt;\n            if(q == 0)\n            {\n                break;\n            }\n\n            anses.Add(ans[q] + \" \" + ans2[q]);\n\n        }\n\n\n\n\n        \n        WriteLine(string.Join(\"\\n\", anses));\n    }\n\n\n\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var dp,dp2,rtodd,rt;\n\n\nfunction bbb(n){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    rtodd = [];\n    rtodd.push(0);\n    while(a <= n){\n        if(a % 2){\n            m++;\n            rtodd.push(a);\n        }\n        c++;b+=c;a+=b;\n    }\n\n    dp2 = [];\n    dp2[0] = [];\n    dp2[0][0] = 0;\n    for(var i = 1;i <= n;i++){\n        dp2[0][i] = 1000000000;\n    }\n    for(var i = 1;i <= m;i++){\n        dp2[i] = [];\n        for(var j = 0;j <= n;j++){\n            if(j < rtodd[i])\n                dp2[i][j] = dp2[i - 1][j];\n            else\n                dp2[i][j] = dp2[i - 1][j] < dp2[i][j - rtodd[i]] + 1 ? dp2[i - 1][j] : dp2[i][j - rtodd[i]] + 1;\n        }\n    }\n\n    return dp2[m][n];\n}\n\n\nfunction aaa(n){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    rt = [];\n    rt.push(0);\n    while(a <= n){\n        m++;\n        rt.push(a);\n        c++;b+=c;a+=b;\n    }\n\n    dp1 = [];\n    dp1[0] = [];\n    dp1[0][0] = 0;\n    for(var i = 1;i <= n;i++){\n        dp1[0][i] = 1000000000;\n    }\n    for(var i = 1;i <= m;i++){\n        dp1[i] = [];\n        for(var j = 0;j <= n;j++){\n            if(j < rt[i])\n                dp1[i][j] = dp1[i - 1][j];\n            else\n                dp1[i][j] = dp1[i - 1][j] < dp1[i][j - rt[i]] + 1 ? dp1[i - 1][j] : dp1[i][j - rt[i]] + 1;\n        }\n    }\n\n    return dp1[m][n];\n}\n\nfunction Main(input){\n    input = input.split(\"\\n\");\n    \n}\nMain(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "var a=[1];\nfor(var i=1;i<1000000;i++)a[i]=a[i-1]+i+1;\nvar b=[1];\nvar i=1;\nwhile(true){\n   b[i]=b[i-1]+a[i];\n   if(b[i]>1000000)break;\n   i++;\n}\nvar dpA=[];\nvar dpB=[];\nfor(var i=0;i<1000000;i++)dpA[i]=Infinity;\nfor(var i=0;i<1000000;i++)dpB[i]=Infinity;\ndpA[0]=0;\ndpB[0]=0;\nfor(var j=0;j<b.length;j++){\n   for(var i=b[j];i<1000000;i++){\n      dpA[i]=Math.min(dpA[i-b[j]]+1,dpA[i]);\n      if(b[j]%2==1)dpB[i]=Math.min(dpB[i-b[j]]+1,dpB[i]);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\").map(Number);\nwhile(true){\n   var n=arr.shift();\n   if(n==0)break;\n   console.log(dpA[n]+\" \"+dpB[n]);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function aaa(n){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    var rtodd = [];\n    rtodd.push(0);\n    while(a <= n){\n        m++;\n        rtodd.push(a);\n        c++;b+=c;a+=b;\n    }\n\n    var dp = [];\n    dp[0] = [];\n    dp[0][0] = 0;\n    for(var i = 1;i <= n;i++){\n        dp[0][i] = 1000000000;\n    }\n    for(var i = 1;i <= m;i++){\n        dp[i] = [];\n        for(var j = 0;j <= n;j++){\n            if(j < rtodd[i])\n                dp[i][j] = dp[i - 1][j];\n            else\n                dp[i][j] = dp[i - 1][j] < dp[i][j - rtodd[i]] + 1 ? dp[i - 1][j] : dp[i][j - rtodd[i]] + 1;\n        }\n    }\n\n    return dp[m][n];\n}\n\nfunction bbb(n){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    var rtodd = [];\n    rtodd.push(0);\n    while(a <= n){\n        if(a % 2){\n            m++;\n            rtodd.push(a);\n        }\n        c++;b+=c;a+=b;\n    }\n\n    var dp = [];\n    dp[0] = [];\n    dp[0][0] = 0;\n    for(var i = 1;i <= n;i++){\n        dp[0][i] = 1000000000;\n    }\n    for(var i = 1;i <= m;i++){\n        dp[i] = [];\n        for(var j = 0;j <= n;j++){\n            if(j < rtodd[i])\n                dp[i][j] = dp[i - 1][j];\n            else\n                dp[i][j] = dp[i - 1][j] < dp[i][j - rtodd[i]] + 1 ? dp[i - 1][j] : dp[i][j - rtodd[i]] + 1;\n        }\n    }\n\n    return dp[m][n];\n}\n\n\nfunction Main(input){\n    input = input.split(\"\\n\");\n\n    for(var i = 0;1;i++){\n        var n = parseInt(input[i],10);\n        if(n == 0)\n            break;\n        console.log(aaa(n),bbb(n));\n    }\n    \n}\nMain(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "var a=[1];\nfor(var i=1;i<1000000;i++)a[i]=a[i-1]+i+1;\nvar b=[1];\nvar i=1;\nwhile(true){\n   b[i]=b[i-1]+a[i];\n   if(b[i]>1000000)break;\n   i++;\n}\nvar dpA=[];\nvar dpB=[];\ndpA[0]=0;\ndpB[0]=0;\nfor(var j=0;j<b.length;j++){\n   for(var i=b[j];i<1000000;i++){\n      dpA[i]=dpA[i-b[j]]+1;\n      if(b[j]%2==1)dpB[i]=dpB[i-b[j]]+1;\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\").map(Number);\nwhile(true){\n   var n=arr.shift();\n   if(n==0)break;\n   console.log(dpA[n]+\" \"+dpB[n]);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function Main(input) {\n    input = input.trim().split(\"\\n\").map(function(x) { return x.split(\" \")});    \n\tvar a=[1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,1540,1771,2024,2300,2600,2925,3276,3654,4060,4495,4960,5456,5984,6545,7140,7770,8436,9139,9880,10660,11480,12341,13244,14190,15180,16215,17296,18424,19600,20825,22100,23426,24804,26235,27720,29260,30856,32509,34220,35990,37820,39711,41664,43680,45760,47905,50116,52394,54740,57155,59640,62196,64824,67525,70300,73150,76076,79079,82160,85320,88560,91881,95284,98770,102340,105995,109736,113564,117480,121485,125580,129766,134044,138415,142880,147440,152096,156849,161700,166650,171700,176851,182104,187460,192920,198485,204156,209934,215820,221815,227920,234136,240464,246905,253460,260130,266916,273819,280840,287980,295240,302621,310124,317750,325500,333375,341376,349504,357760,366145,374660,383306,392084,400995,410040,419220,428536,437989,447580,457310,467180,477191,487344,497640,508080,518665,529396,540274,551300,562475,573800,585276,596904,608685,620620,632710,644956,657359,669920,682640,695520,708561,721764,735130,748660,762355,776216,790244,804440,818805,833340,848046,862924,877975,893200,908600,924176,939929,955860,971970,988260];\n\tvar b=[1,35,165,455,969,1771,2925,4495,6545,9139,12341,16215,20825,26235,32509,39711,47905,57155,67525,79079,91881,105995,121485,138415,156849,176851,198485,221815,246905,273819,302621,333375,366145,400995,437989,477191,518665,562475,608685,657359,708561,762355,818805,877975,939929];\n\tvar dpA = [];\n\tvar dpB = [];\n\tvar max = 1e+6;\n\tfor(var i = 0;i < max; i++) dpA[i]=Infinity;\n\tfor(var i = 0;i < max; i++) dpB[i]=Infinity;\n\tdpA[0] = 0;\n\tdpB[0] = 0;\n\tfor(var i = 0; i < 1000000; i++){\n\t\tfor(var j = 0; j < a.length; j++){\n\t\t\tif(i - a[j] >= 0) dpA[i] = Math.min(dpA[i - a[j]] + 1, dpA[i]);\n\t\t}\n\t\tfor(var j = 0; j < b.length; j++){\n\t\t\tif(i - b[j] >= 0) dpB[i] = Math.min(dpB[i - b[j]] + 1, dpB[i]);\n\t\t}\n\t}\n\twhile(true){\n\t   var n = input.shift();\n\t   if(n[0] === '0') break;\n\t   console.log(dpA[n]+\" \"+dpB[n]);\n\t}\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var a=[1];\nfor(var i=1;i<100000;i++)a[i]=a[i-1]+i+1;\nvar b=[1];\nvar i=1;\nwhile(true){\n   b[i]=b[i-1]+a[i];\n   if(b[i]>100000)break;\n   i++;\n}\nvar dpA=[];\nvar dpB=[];\nfor(var i=0;i<100000;i++)dpA[i]=Infinity;\nfor(var i=0;i<100000;i++)dpB[i]=Infinity;\ndpA[0]=0;\ndpB[0]=0;\nfor(var i=0;i<100000;i++){\n   for(var j=0;j<b.length;j++){\n      if(i-b[j]>=0)dpA[i]=Math.min(dpA[i-b[j]]+1,dpA[i]);\n      if(b[j]%2==1 && i-b[j]>=0)dpB[i]=Math.min(dpB[i-b[j]]+1,dpB[i]);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\").map(Number);\nwhile(true){\n   var n=arr.shift();\n   if(n==0)break;\n   console.log(dpA[n]+\" \"+dpB[n]);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var rt,rtodd;\n\nfunction aaa(n,dp1){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    rt = [];\n    rt.push(0);\n    while(a <= n){\n        m++;\n        rt.push(a);\n        c++;b+=c;a+=b;\n    }\n\n    dp1[0] = [];\n    dp1[0][0] = 0;\n\n    for(var i = 1;i <= n;i++){\n        dp1[0][i] = 1000000000;\n    }\n    for(var i = 1;i <= m;i++){\n\n        if(i > 2)\n            dp1[i - 2] = null;\n        dp1[i] = [];\n        for(var j = 0;j <= n;j++){\n            if(j < rt[i])\n                dp1[i][j] = dp1[i - 1][j];\n            else\n                dp1[i][j] = dp1[i - 1][j] < dp1[i][j - rt[i]] + 1 ? dp1[i - 1][j] : dp1[i][j - rt[i]] + 1;\n        }\n    }\n\n    return m;\n}\n\n\n\nfunction bbb(n,dp2){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    rtodd = [];\n    rtodd.push(0);\n    while(a <= n){\n        if(a % 2){\n            m++;\n            rtodd.push(a);\n        }\n        c++;b+=c;a+=b;\n    }\n\n    dp2[0] = [];\n    dp2[0][0] = 0;\n\n    for(var i = 1;i <= n;i++){\n        dp2[0][i] = 1000000000;\n    }\n    for(var i = 1;i <= m;i++){\n        if(dp2[i] > 2)\n            dp2[i - 2] = null;\n        dp2[i] = [];\n        for(var j = 0;j <= n;j++){\n            if(j < rtodd[i])\n                dp2[i][j] = dp2[i - 1][j];\n            else\n                dp2[i][j] = dp2[i - 1][j] < dp2[i][j - rtodd[i]] + 1 ? dp2[i - 1][j] : dp2[i][j - rtodd[i]] + 1;\n        }\n    }\n\n    return m;\n}\nfunction Main(input){\n    input = input.split(\"\\n\");\n    var dp1 = [],dp2 = [];\n\n    var m1 = aaa(1000000,dp1);var m2 = bbb(1000000,dp2);\n\n    for(var i = 0;1;i++){\n        var n = parseInt(input[i],10);\n        if(n == 0)\n            break;\n        var a = dp1[m1][n];var b = dp2[m2][n];\n        console.log(a,b);\n    }\n    \n}\n\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "function aaa(n){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    var rtodd = [];\n    rtodd.push(0);\n    while(a <= n){\n        m++;\n        rtodd.push(a);\n        c++;b+=c;a+=b;\n    }\n\n    var dp = [];\n    dp[0] = [];\n    dp[0][0] = 0;\n\n    for(var i = 1;i < 5;i++)\n        dp[i] = [];\n    for(var i = 1;i <= n;i++){\n        dp[0][i] = 1000000000;\n    }\n    for(var iii = 1;iii <= m;iii++){\n        var i = iii % 5;\n        var ii = i - 1;\n        if(ii < 0)\n            ii = 4;\n        for(var j = 0;j <= n;j++){\n            if(j < rtodd[i])\n                dp[i][j] = dp[ii][j];\n            else\n                dp[i][j] = dp[ii][j] < dp[i][j - rtodd[i]] + 1 ? dp[ii][j] : dp[i][j - rtodd[i]] + 1;\n        }\n    }\n\n    m %= 5;\n\n    return dp[m][n];\n}\n\n\n\nfunction bbb(n){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    var rtodd = [];\n    rtodd.push(0);\n    while(a <= n){\n        if(a % 2){\n            m++;\n            rtodd.push(a);\n        }\n        c++;b+=c;a+=b;\n    }\n\n    var dp = [];\n    dp[0] = [];\n    dp[0][0] = 0;\n\n    for(var i = 1;i < 5;i++)\n        dp[i] = [];\n    for(var i = 1;i <= n;i++){\n        dp[0][i] = 1000000000;\n    }\n    for(var iii = 1;iii <= m;iii++){\n        var i = iii % 5;\n        var ii = i - 1;\n        if(ii < 0)\n            ii = 4;\n        for(var j = 0;j <= n;j++){\n            if(j < rtodd[i])\n                dp[i][j] = dp[ii][j];\n            else\n                dp[i][j] = dp[ii][j] < dp[i][j - rtodd[i]] + 1 ? dp[ii][j] : dp[i][j - rtodd[i]] + 1;\n        }\n    }\n\n    m %= 5;\n\n    return dp[m][n];\n}\nfunction Main(input){\n    input = input.split(\"\\n\");\n\n    for(var i = 0;1;i++){\n        var n = parseInt(input[i],10);\n        if(n == 0)\n            break;\n        console.log(aaa(n),bbb(n));\n    }\n    \n}\nMain(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));"
  },
  {
    "language": "JavaScript",
    "code": "var a=[1];\nfor(var i=1;i<1000000;i++)a[i]=a[i-1]+i+1;\nvar b=[1];\nvar i=1;\nwhile(true){\n   b[i]=b[i-1]+a[i];\n   if(b[i]>1000000)break;\n   i++;\n}\nvar dpA=[];\nvar dpB=[];\nfor(var i=0;i<1000000;i++)dpA[i]=Infinity;\nfor(var i=0;i<1000000;i++)dpB[i]=Infinity;\ndpA[0]=0;\ndpB[0]=0;\nfor(var i=0;i<1000000;i++){\n   for(var j=0;j<b.length;j++){\n      if(i-b[j]>=0)dpA[i]=Math.min(dpA[i-b[j]]+1,dpA[i]);\n      if(b[j]%2==1 && i-b[j]>=0)dpB[i]=Math.min(dpB[i-b[j]]+1,dpB[i]);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\").map(Number);\nwhile(true){\n   var n=arr.shift();\n   if(n==0)break;\n   console.log(dpA[n]+\" \"+dpB[n]);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var rt,rtodd;\n\nfunction aaa(n,dp1){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    rt = [];\n    rt.push(0);\n    while(a <= n){\n        m++;\n        rt.push(a);\n        c++;b+=c;a+=b;\n    }\n\n    dp1[0] = [];\n    dp1[0][0] = 0;\n\n    for(var i = 1;i < 5;i++)\n        dp1[i] = [];\n    for(var i = 1;i <= n;i++){\n        dp1[0][i] = 1000000000;\n    }\n    for(var iii = 1;iii <= m;iii++){\n        var i = iii % 5;\n        var ii = i - 1;\n        if(ii < 0)\n            ii = 4;\n        for(var j = 0;j <= n;j++){\n            if(j < rt[iii])\n                dp1[i][j] = dp1[ii][j];\n            else\n                dp1[i][j] = dp1[ii][j] < dp1[i][j - rt[iii]] + 1 ? dp1[ii][j] : dp1[i][j - rt[iii]] + 1;\n        }\n    }\n\n    m %= 5;\n\n    return m;\n}\n\n\n\nfunction bbb(n,dp2){\n\n    var m = 0,a = 1,b = 1,c = 1;\n    rtodd = [];\n    rtodd.push(0);\n    while(a <= n){\n        if(a % 2){\n            m++;\n            rtodd.push(a);\n        }\n        c++;b+=c;a+=b;\n    }\n\n    dp2[0] = [];\n    dp2[0][0] = 0;\n\n    for(var i = 1;i < 5;i++)\n        dp2[i] = [];\n    for(var i = 1;i <= n;i++){\n        dp2[0][i] = 1000000000;\n    }\n    for(var iii = 1;iii <= m;iii++){\n        var i = iii % 5;\n        var ii = i - 1;\n        if(ii < 0)\n            ii = 4;\n        for(var j = 0;j <= n;j++){\n            if(j < rtodd[iii])\n                dp2[i][j] = dp2[ii][j];\n            else\n                dp2[i][j] = dp2[ii][j] < dp2[i][j - rtodd[iii]] + 1 ? dp2[ii][j] : dp2[i][j - rtodd[iii]] + 1;\n        }\n    }\n\n    m %= 5;\n\n    return m;\n}\nfunction Main(input){\n    input = input.split(\"\\n\");\n    var dp1 = [],dp2 = [];\n\n    var m1 = aaa(1000000,dp1);var m2 = bbb(1000000,dp2);\n\n    for(var i = 0;1;i++){\n        var n = parseInt(input[i],10);\n        if(n == 0)\n            break;\n        var a = dp1[m1][n];var b = dp2[m2][n];\n        console.log(a,b);\n    }\n    \n}\n\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\",\"utf8\"));"
  },
  {
    "language": "Ruby",
    "code": "N = 1_000_000\n\ndef unbounded_knapsack(items, budget)\n\ttable = [0]\n\titems.sort_by!(&:first)\n\tvalid_items = []\n\tfor i in 1..budget\n\t\ttable[i] = -Float::INFINITY\n\t\tvalid_items << items.shift while !items.empty? && items[0][0] <= i\n\t\tvalid_items.each{|c, v|\n\t\t\tx = table[i-c] + v\n\t\t\ttable[i] = x if x > table[i]\n\t\t}\n\tend\n\ttable\nend\n\nt = -> n { n * (n+1) * (n+2) / 6 }\nn = 1\nitems = []\nodd_items = []\nwhile t[n] < N\n\titems << [t[n], -1] \n\todd_items << items[-1]  if items[-1][0].odd?\n\tn += 1\nend\n\npollock = unbounded_knapsack(items, N)\nodd_pollock = unbounded_knapsack(odd_items, N)\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\tputs [-pollock[n], -odd_pollock[n]] * ' '\nend"
  },
  {
    "language": "Ruby",
    "code": "def min(a,b)\n  if a<b\n    return a\n  else\n    return b\n  end\nend\ndef make_array(pol,odd_pol)\n  i=1\n  while pol[-1]<1000000\n    i+=1\n    if (s=(i*(i+1)*(i+2))/6)%2==1\n      odd_pol.push(s)\n    end\n    pol.push((i*(i+1)*(i+2))/6)\n  end\n  return [pol,odd_pol]\nend\ndef solve(x,pol)\n  l=pol.length\n  ans=Array.new(x+1,100000)\n  ans[0]=0\n  for i in 0..x\n    for j in 0..l-1\n      k=1\n      while i>=k*pol[l-1-j]\n        ans[i]=min(ans[i],ans[i-k*pol[l-1-j]]+k)\n        k+=1\n      end\n    end\n  end\n  return ans[x]\nend\ndef odd_solve(x,odd_pol)\n  l=odd_pol.length\n  ans=Array.new(x+1,100000)\n  ans[0]=0\n  for i in 0..x\n    for j in 0..l-1\n      k=1\n      while i>=k*odd_pol[l-1-j]\n        ans[i]=min(ans[i],ans[i-k*odd_pol[l-1-j]]+k)\n        k+=1\n      end\n    end\n  end\n  return ans[x]\nend\n\npol=make_array([1],[1])[0]\nodd=make_array([1],[1])[1]\nwhile true\n  n=gets.to_i\n  if n==0\n    break\n  end\n  print solve(n,pol),\" \",odd_solve(n,odd),\"\\n\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def min(a,b)\n  if a<b\n    return a\n  else\n    return b\n  end\nend\ndef make_array(pol,odd_pol)\n  i=1\n  while pol[-1]<1000000\n    i+=1\n    if (s=(i*(i+1)*(i+2))/6)%2==1\n      odd_pol.push(s)\n    end\n    pol.push((i*(i+1)*(i+2))/6)\n  end\n  return [pol,odd_pol]\nend\ndef solve(x,pol)\n  l=pol.length\n  ans=Array.new(x+1,1000000)\n  ans[0]=0\n  for i in 0..x\n    for j in 0..l-1\n      if i>=pol[l-1-j]\n        ans[i]=min(ans[i],ans[i-pol[l-1-j]]+1)\n      end\n    end\n  end\n  return ans[x]\nend\ndef odd_solve(x,odd_pol)\n  l=odd_pol.length\n  ans=Array.new(x+1,1000000)\n  ans[0]=0\n  for i in 0..x\n    for j in 0..l-1\n      if i>=odd_pol[l-1-j]\n        ans[i]=min(ans[i],ans[i-odd_pol[l-1-j]]+1)\n      end\n    end\n  end\n  return ans[x]\nend\n\npol=make_array([1],[1])[0]\nodd=make_array([1],[1])[1]\nwhile true\n  n=gets.to_i\n  if n==0\n    break\n  end\n  print solve(n,pol),\" \",odd_solve(n,odd),\"\\n\"\nend"
  },
  {
    "language": "Ruby",
    "code": "### constants\n\nINF = 1 << 30\n\n### subroutines\n\ndef min_sums(n, ds)\n  sums = (n + 1).times.map{INF}\n  sums[0] = 0\n\n  for d in ds\n    for i in (0..n)\n      j = i + d\n      break if j > n\n      if sums[j] > sums[i] + 1\n        sums[j] = sums[i] + 1\n      end\n    end\n  end\n\n  sums[n]\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  thns = []\n  othns = []\n\n  for k in (1..n)\n    thn = k * (k + 1) * (k + 2) / 6\n    break if thn > n\n\n    thns << thn\n    othns << thn if thn.odd?\n  end\n  #p [thns, othns]\n\n  puts [min_sums(n, thns), min_sums(n, othns)].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "def tetras(nums)\n  nums.map{ |n| n * (n + 1) * (n + 2) / 6 }.take_while{ |n| n <= 1000000 }\nend\n\n@tetra = tetras((1..200)).reverse\n@tetra_odd = @tetra.select{ |t| t.odd? }\n\ndef bfs(n, tetra)\n  q = []\n  q << [n, 0]\n  loop do\n    s, c = q.shift\n    return c if s == 0\n    tetra.drop_while{ |t| t > s }.each do |t|\n      q << [s - t, c + 1]\n    end\n  end\nend\n\nwhile (n = gets.to_i) != 0\n  puts [bfs(n, @tetra), bfs(n, @tetra_odd)].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "MAX = 1e6.to_i\n\ntetra = (1..1/0.0).lazy.map{ |n| n * (n + 1) * (n + 2) / 6 }.take_while{ |n| n < MAX }.to_a.reverse\n\ndef tabulate(tetra, dp)\n  tetra.each do |t|\n    (0...MAX - t).each do |i|\n      dp[t + i] = dp[i] + 1 if dp[i] + 1 < dp[t + i]\n    end\n  end\nend\n\ndp = [MAX] * MAX\ndp_odd = [MAX] * MAX\ndp[0] = 0\ndp_odd[0] = 0\ntabulate(tetra, dp)\ntabulate(tetra.select{ |n| n.odd? }, dp_odd)\nwhile (n = gets.to_i) != 0\n  puts [dp[n], dp_odd[n]].join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "t = Array.new(180)\n(180).times do |i|\n    t[i] = (i*(i+1)*(i+2))/6\nend\not = t.select{|e| e.odd?}\ndp = Array.new(10**6+1,Float::INFINITY)\ndp[0] = 0\ndp2 = Array.new(10**6+1,Float::INFINITY)\ndp2[0] = 0\n\nt.each do |tn|\n    if tn % 2 == 0\n        tn.upto(10**6) do |i|\n            dp[i] = dp[i - tn] + 1 if dp[i - tn] + 1 < dp[i]\n        end\n    else\n        tn.upto(10**6) do |i|\n            dp[i] = dp[i - tn] + 1 if dp[i - tn] + 1 < dp[i]\n            dp2[i] = dp2[i - tn] + 1 if dp2[i - tn] + 1 < dp2[i]\n        end\n    end\nend\nloop do\n    n = gets.to_i\n    break if n == 0\n    puts \"#{dp[n]} #{dp2[n]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "max = 0\na = []\nt =Array.new(10**6+1,55)\ntt =Array.new(10**6+1,50)\n100.times do |n|\n  max = (n*(n+1)*(n+2)/6)\n  t[max] = 1\n  lol = max\n  next if(lol<1)\n  while (lol <= 1000000)\n    t[lol] = [t[lol],t[lol-max]+1].min\n    lol += 1\n  end\n  if(max.odd?)\n    tt[max] = 1\n    lol = max\n    while (lol <= 1000000)\n      tt[lol] = [tt[lol],tt[lol-max]+1].min\n      lol += 1\n    end\n  end\nend\nwhile ((m = gets.chomp.to_i) != 0)\n  puts \"#{t[m]} #{tt[m]}\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def make_array(pol,odd_pol)\n  i=1\n  while pol[-1]<1000000\n    i+=1\n    if (s=(i*(i+1)*(i+2))/6)%2==1\n      odd_pol.push(s)\n    end\n    pol.push((i*(i+1)*(i+2))/6)\n  end\n  return [pol,odd_pol]\nend\n\ndef solve(x,pol)\n  l=pol.length\n  count=0\n  tmp=x\n  for i in 0..l-1\n    while tmp>=pol[l-1-i]\n      tmp-=pol[l-1-i]\n      count++\n    end\n    if tmp==0\n      return count\n    end\n  end\nend\n\ndef odd_solve(x,odd_pol)\n  l=odd_pol.length\n  count=0\n  tmp=x\n  for i in 0..l-1\n    while tmp>=odd_pol[l-1-i]\n      tmp-=odd_pol[l-1-i]\n      count++\n    end\n    if tmp==0\n      return count\n    end\n  end\nend\n      \n\nloop do\n  pol=make_array([1],[1])[0]\n  odd=make_array([1],[1])[1]\n  n=gets.to_i\n  if n==0\n    break\n  end\n  print solve(n,pol),\" \",odd_solve(n,odd),\"\\n\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def make_array(pol,odd_pol)\n  i=1\n  while pol[-1]<1000000\n    i+=1\n    if (s=(i*(i+1)*(i+2))/6)%2==1\n      odd_pol.push(s)\n    end\n    pol.push((i*(i+1)*(i+2))/6)\n  end\n  return [pol,odd_pol]\nend\n\n\ndef solve(x,pol)\n  l=pol.length\n  count=0\n  tmp=x\n  for i in 0..l-1\n    while tmp>=pol[l-1-i]\n      tmp-=pol[l-1-i]\n      count++\n    end\n  end\n  return count\nend\n\ndef odd_solve(x,odd_pol)\n  l=odd_pol.length\n  count=0\n  tmp=x\n  for i in 0..l-1\n    while tmp>=odd_pol[l-1-i]\n      tmp-=odd_pol[l-1-i]\n      count++\n    end\n  end\n  return count\nend\n\npol=make_array([1],[1])[0]\nodd=make_array([1],[1])[1]\nwhile (n=gets.to_i)!=0\n  print solve(n,pol),\" \",odd_solve(n,odd),\"\\n\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def min(a,b)\n  if a<b\n    return a\n  else\n    return b\n  end\nend\ndef make_array(pol,odd_pol)\n  i=1\n  while pol[-1]<1000000\n    i+=1\n    if (s=(i*(i+1)*(i+2))/6)%2==1\n      odd_pol.push(s)\n    end\n    pol.push((i*(i+1)*(i+2))/6)\n  end\n  return [pol,odd_pol]\nend\ndef solve(x,pol)\n  l=pol.length\n  ans=Array.new(x+1,1000000)\n  ans[0]=0\n  for i in 0..x\n    for j in 0..l-1\n      k=1\n      while i>=k*pol[l-1-j]\n        ans[i]=min(ans[i],ans[i-k*pol[l-1-j]]+k)\n        k+=1\n      end\n    end\n  end\n  return ans[x]\nend\ndef odd_solve(x,odd_pol)\n  l=odd_pol.length\n  ans=Array.new(x+1,1000000)\n  ans[0]=0\n  for i in 0..x\n    for j in 0..l-1\n      k=1\n      while i>=k*odd_pol[l-1-j]\n        ans[i]=min(ans[i],ans[i-k*odd_pol[l-1-j]]+k)\n        k+=1\n      end\n    end\n  end\n  return ans[x]\nend\n\npol=make_array([1],[1])[0]\npol=make_array([1],[1])[1]\nwhile true\n  n=gets.to_i\n  if n==0\n    break\n  end\n  print solve(n,pol),\" \",odd_solve(n,odd),\"\\n\"\nend"
  },
  {
    "language": "Ruby",
    "code": "MAX = 1000001\ndp = Array.new(MAX, MAX)\nodd_dp = Array.new(MAX, MAX)\ndp[0] = odd_dp[0] = 0\n\nfor i in 1...181 do\n  num = i * (i + 1) * (i + 2) / 6\n  dp[num] = 1\n  if num % 2 == 1\n    odd_dp[num] = 1\n  end\n  for j in num...MAX do\n    if dp[j - num] + 1 < dp[j]\n      dp[j] = dp[j - num] + 1\n    end\n    if num % 2 == 1\n      if odd_dp[j - num] + 1 < odd_dp[j]\n        odd_dp[j] = odd_dp[j - num] + 1\n      end\n    end\n  end\nend\n\nloop do\n  n = gets.chomp.to_i\n  if n == 0\n    break\n  end\n  puts \"#{dp[n]} #{odd_dp[n]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "t = Array.new(13**2)\n(13**2).times do |i|\n    t[i] = (i*(i+1)*(i+2))/6\nend\not = t.select{|e| e.odd?}\ndp = Array.new(10**6+1,Float::INFINITY)\ndp[0] = 0\ndp2 = Array.new(10**6+1,Float::INFINITY)\ndp2[0] = 0\n\nt.each do |tn|\n    if tn % 2 == 0\n        tn.upto(10**6) do |i|\n            dp[i] = dp[i - tn] + 1 if dp[i - tn] + 1 < dp[i]\n        end\n    else\n        tn.upto(10**6) do |i|\n            dp[i] = dp[i - tn] + 1 if dp[i - tn] + 1 < dp[i]\n            dp2[i] = dp2[i - tn] + 1 if dp2[i - tn] + 1 < dp2[i]\n        end\n    end\nend\n\nputs \"READY\"\nloop do\n    n = gets.to_i\n    break if n == 0\n    puts \"#{dp[n]} #{dp2[n]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "def make_array(pol,odd_pol)\n  i=1\n  while pol[-1]<1000000\n    i+=1\n    if (s=(i*(i+1)*(i+2))/6)%2==1\n      odd_pol.push(s)\n    end\n    pol.push((i*(i+1)*(i+2))/6)\n  end\n  return [pol,odd_pol]\nend\n\ndef solve(x,pol)\n  l=pol.length\n  count=0\n  tmp=x\n  for i in 0..l-1\n    while tmp>=pol[l-1-i]\n      tmp-=pol[l-1-i]\n      count++\n    end\n    if tmp==0\n      return count\n    end\n  end\nend\n\ndef odd_solve(x,odd_pol)\n  l=odd_pol.length\n  count=0\n  tmp=x\n  for i in 0..l-1\n    while tmp>=odd_pol[l-1-i]\n      tmp-=odd_pol[l-1-i]\n      count++\n    end\n    if tmp==0\n      return count\n    end\n  end\nend\n      \n\nloop do\n  pol=make_array([1],[1])[0]\n  odd=make_array([1],[1])[1]\n  n=gets.to_i\n  if n==0\n    break\n  end\n  print solve(n,pol),\" \",odd_solve(n,odd),\"\\n\"\nend"
  },
  {
    "language": "Ruby",
    "code": "import itertools\n\nP1=[p*(p+1)*(p+2)/6 for p in range(1,181)]\nP2=[p for p in P1 if p%2]\n\nmaxnum=1000000\n\nA1=[5 for x in range(maxnum+1)]\nA2=[37 for x in range(maxnum+1)]\n\nfor X in [[P1,A1],[P2,A2]]:\n    P=X[0]\n    A=X[1]\n    mx=A[0]\n    tmp=P\n    bk=0\n    cnt=2\n    for p in tmp:\n        if p<maxnum:\n            A[p]=1\n            bk+=1\n    while cnt<mx:\n        tmp2=[]\n        for t in tmp:\n            for p in P:\n                if t+p > maxnum:    break\n                if A[t+p]>cnt:\n                    A[t+p]=cnt\n                    bk+=1\n                    tmp2.append(t+p)\n        tmp=tmp2[:]\n        cnt+=1\nwhile(1):\n    n=int(raw_input())\n    if n==0: break\n    print A1[n], A2[n]\n\n"
  },
  {
    "language": "Ruby",
    "code": "max = 0\na = []\nt =Array.new(10**6+1,55)\ntt =Array.new(10**6+1,50)\n181.times do |n|\n  max = (n*(n+1)*(n+2)/6)\n  t[max] = 1\n  lol = max\n  next if(lol<1)\n  while (lol <= 1000000)\n    t[lol] = [t[lol],t[lol-max]+1].min\n    lol += 1\n  end\n  if(max.odd?)\n    tt[max] = 1\n    lol = max\n    while (lol <= 1000000)\n      tt[lol] = [tt[lol],tt[lol-max]+1].min\n      lol += 1\n    end\n  end\nend\nwhile ((m = gets.chomp.to_i) != 0)\n  puts \"#{t[m]} #{tt[m]}\"\nend\n"
  },
  {
    "language": "Ruby",
    "code": "### constants\n\nMAX_N = 10 ** 6\n\n### subroutines\n\ndef min_sums(n, thns)\n  sums = (0..(n + 1)).to_a\n\n  for thn in thns\n    break if thn > n\n    for i in (0..(n - thn))\n      j = i + thn\n      if sums[j] > sums[i] + 1\n        sums[j] = sums[i] + 1\n      end\n    end\n  end\n\n  sums\nend\n\n### main\n\nthns = []\nothns = []\n\nfor k in (1..MAX_N)\n  thn = k * (k + 1) * (k + 2) / 6\n  break if thn >= MAX_N\n\n  thns << thn\n  othns << thn if thn.odd?\nend\n#p [thns.length, othns.length]; exit\n\nsums = min_sums(MAX_N, thns)\nosums = min_sums(MAX_N, othns)\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  puts [sums[n], osums[n]].join(' ')\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t_ \"container/heap\"\n\t\"fmt\"\n\t\"os\"\n\t_ \"sort\"\n\t\"strconv\"\n)\n\n// I/O\ntype Scanner struct {\n\tsc *bufio.Scanner\n}\n\nfunc NewScanner() *Scanner {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tsc.Buffer(make([]byte, 1024), int(1e+9))\n\treturn &Scanner{sc}\n}\n\nfunc (s *Scanner) nextStr() string {\n\ts.sc.Scan()\n\treturn s.sc.Text()\n}\n\nfunc (s *Scanner) nextInt() int {\n\ti, e := strconv.Atoi(s.nextStr())\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn i\n}\n\nfunc (s *Scanner) nextFloat() float64 {\n\tf, e := strconv.ParseFloat(s.nextStr(), 64)\n\tif e != nil {\n\t\tpanic(e)\n\t}\n\treturn f\n}\n\nfunc (s *Scanner) nextRuneSlice() []rune {\n\treturn []rune(s.nextStr())\n}\n\nfunc (s *Scanner) nextIntSlice(n int) []int {\n\tres := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tres[i] = s.nextInt()\n\t}\n\treturn res\n}\n\nfunc (s *Scanner) nextFloatSlice(n int) []float64 {\n\tres := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tres[i] = s.nextFloat()\n\t}\n\treturn res\n}\n\n// Arithmetic\nfunc max(nums ...int) int {\n\tm := nums[0]\n\tfor _, i := range nums {\n\t\tif m < i {\n\t\t\tm = i\n\t\t}\n\t}\n\treturn m\n}\n\nfunc min(nums ...int) int {\n\tm := nums[0]\n\tfor _, i := range nums {\n\t\tif m > i {\n\t\t\tm = i\n\t\t}\n\t}\n\treturn m\n}\n\nfunc abs(x int) int {\n\tif x > 0 {\n\t\treturn x\n\t}\n\treturn -x\n}\n\nfunc pow(x, y int) int {\n\tres := 1\n\tfor i := 0; i < y; i++ {\n\t\tres *= x\n\t}\n\treturn res\n}\n\nfunc ceil(a, b int) int {\n\tif a%b == 0 {\n\t\treturn a / b\n\t} else {\n\t\treturn a/b + 1\n\t}\n}\n\nfunc gcd(a, b int) int {\n\tif b == 0 {\n\t\treturn a\n\t}\n\treturn gcd(b, a%b)\n}\n\nfunc lcm(a, b int) int {\n\treturn a / gcd(a, b) * b\n}\n\n// Sort\ntype RuneSlice []rune\n\nfunc (a RuneSlice) Len() int           { return len(a) }\nfunc (a RuneSlice) Less(i, j int) bool { return a[i] < a[j] }\nfunc (a RuneSlice) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n\n// Main\nconst MOD = int(1e+9) + 7\nconst INF = 1 << 60\n\nfunc main() {\n\tsc := NewScanner()\n\twtr := bufio.NewWriter(os.Stdout)\n\tdefer wtr.Flush()\n\tvar nums []int\n\tfor i := 1; i < 2*100+1; i++ {\n\t\tnums = append(nums, i*(i+1)*(i+2)/6)\n\t}\n\tvar ins []int\n\tN := 0\n\tfor true {\n\t\tn := sc.nextInt()\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\tins = append(ins, n)\n\t\tN = max(N, n)\n\t}\n\tdp := make([]int, N+1)\n\tdp2 := make([]int, N+1)\n\tfor i := 1; i < N+1; i++ {\n\t\tdp[i] = INF\n\t\tdp2[i] = INF\n\t}\n\tfor i := 0; i < len(nums); i++ {\n\t\tn := nums[i]\n\t\tif n > N {\n\t\t\tbreak\n\t\t}\n\t\tfor j := 0; j < N+1; j++ {\n\t\t\tif j >= n {\n\t\t\t\tdp[j] = min(dp[j], dp[j-n]+1)\n\t\t\t\tif n%2 != 0 {\n\t\t\t\t\tdp2[j] = min(dp2[j], dp2[j-n]+1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 0; i < len(ins); i++ {\n\t\tfmt.Fprintln(wtr, dp[ins[i]], dp2[ins[i]])\n\t}\n}\n"
  },
  {
    "language": "OCaml",
    "code": "let dbg = Printf.printf \"[debug]%s\"\n\nlet id = fun x -> x\nlet tuple2 x y = (x,y)\nlet succ x = x + 1\nlet pred x = x - 1\n\nlet (++) n m =\n  let rec aux i acc =\n    if i = m then List.rev (m::acc)\n    else aux (i+1) (i::acc) in\n  if n > m then [] else aux n []\n\nlet (++^) n m = n ++ (m-1)\n\nlet scan fmt f = Scanf.sscanf (read_line ()) fmt f\n\nlet scan_lines n fmt f =\n  List.map (fun _ -> scan fmt f) (0++^n)\n\nlet scan_matrix n m e conv =\n  let arr = Array.make_matrix n m e in\n  Array.iteri (fun i line ->\n      let s = Scanf.Scanning.from_string @@ read_line () in\n      Array.iteri (fun j _ ->\n          arr.(i).(j) <- Scanf.bscanf s \" %s\" conv;\n        ) line) arr; arr\n\nlet between n x m = n <= x && x < m\n\nlet string_to_list s =\n  List.map (String.get s) (0 ++^ String.length s)\n\nlet m = List.map (fun i -> i*(i+1)*(i+2)/6) (1++200)\n\nlet max_val = 1_000_000\n\nlet dp = Array.init (max_val+1) (fun i -> if i = 0 then 0 else max_int)\nlet dp_odd = Array.init (max_val+1) (fun i -> if i = 0 then 0 else max_int);;\n\nList.iter (fun i ->\n    dp.(i) <-\n      List.fold_left (fun acc num ->\n          min acc\n            (if i >= num then succ dp.(i-num) else max_int)) max_int m)\n  (1++max_val);;\n\nlet m = List.filter (fun x -> x mod 2 = 1) m in\nList.iter (fun i ->\n    dp_odd.(i) <-\n      List.fold_left (fun acc num ->\n          min acc\n            (if i >= num then succ dp_odd.(i-num) else max_int)) max_int m)\n  (1++max_val)\n\nlet () =\n  let rec aux () =\n    let n = scan \"%d\" id in\n    if n <> 0 then\n      begin\n        Printf.printf \"%d %d\\n\" dp.(n) dp_odd.(n);\n        aux ()\n      end\n  in\n  aux ()\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int INF = 1<<30;\n    while(true) {\n        int N = readln.chomp.to!int;\n        if (N==0) break;\n        int[] ary = new int[N+1];\n        ary[] = INF;\n        ary[0] = 0;\n        while(true) {\n            foreach(int i; 0..N) {\n                if (ary[i]<INF) {\n                    for(int n=1; ; n++) {\n                        if (i+func(n)<=N) {\n                            ary[i+func(n)] = min(ary[i+func(n)], ary[i]+1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (ary[N] < INF) break;\n        }\n        ary[N].write;\n        \" \".write;\n        ary[] = INF;\n        ary[0] = 0;\n        while(true) {\n            foreach(int i; 0..N) {\n                if (ary[i]<INF) {\n                    for(int n=1; ; n++) {\n                        if (func(n)%2==0) continue;\n                        if (i+func(n)<=N) {\n                            ary[i+func(n)] = min(ary[i+func(n)], ary[i]+1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (ary[N] < INF) break;\n        }\n        ary[N].writeln;\n    }\n}\nint func(int n) {\n    return n*(n+1)*(n+2)/6;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\nint a;\nint[] p = [1,4,10,20,35];\nint[] dp,odp;\n\nvoid main(){\n    for(int i=6;i<80;i++){\n\tp ~= i * (i+1) * (i+2) / 6;\n    }\n    dp = new int[1000001];\n    odp = new int[1000001];\n    fill(dp,-1);\n    fill(odp,-1);\n    dp[0] = 0;\n    dp[1] = 1;\n    odp[0] = 0;\n    odp[1] = 1;\n    for(int i=to!int(p.length)-1;i>=0;i--){\n\tfor(int j=p[i];j<=1e6;j++){\n\t    if(dp[j-p[i]] > -1){\n\t\tif(dp[j] > -1)\n\t\t    dp[j] = min(dp[j],1 + dp[j-p[i]]);\n\t\telse dp[j] = 1 + dp[j-p[i]];\n\t    }\n\t    if(odp[j-p[i]] > -1){\n\t\tif(p[i] % 2 == 1){\n\t\t    if(odp[j] > -1)\n\t\t\todp[j] = min(odp[j],1 + odp[j-p[i]]);\n\t\t    else odp[j] = 1 + odp[j-p[i]];\n\t\t}\n\t    }\n\t}\n    }\n\n    while(true){\n\tint n = readln().chomp().to!int;\n\tif(n == 0) break;\n\twriteln(dp[n] , \" \" , odp[n]);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\nint a;\nint[] p = [1,4,10,20,35];\nint[] dp,odp;\n\n\nvoid main(){\n    for(int i=6;i<300;i++){\n\tp ~= i * (i+1) * (i+2) / 6;\n    }\n    dp = new int[1000001];\n    odp = new int[1000001];\n    fill(dp,-1);\n    fill(odp,-1);\n    dp[0] = 0;\n    odp[0] = 0;\n    for(int i=to!int(p.length)-1;i>=0;i--){\n\tfor(int j=p[i];j<=1e6;j++){\n\t    if(dp[j-p[i]] > -1){\n\t\tif(dp[j] > -1)\n\t\t    dp[j] = min(dp[j],1 + dp[j-p[i]]);\n\t\telse dp[j] = 1 + dp[j-p[i]];\n\t    }\n\t    if(odp[j-p[i]] > -1){\n\t\tif(p[i] % 2 == 1){\n\t\t    if(odp[j] > -1)\n\t\t\todp[j] = min(odp[j],1 + odp[j-p[i]]);\n\t\t    else odp[j] = 1 + odp[j-p[i]];\n\t\t}\n\t    }\n\t}\n    }\n\n    while(true){\n\tint n = readln().chomp().to!int;\n\tif(n == 0) break;\n\twriteln(dp[n] , \" \" , odp[n]);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n\n    auto dp = new long[1000001];\n    dp[] = 1L << 30;\n    dp[0] = 0;\n    foreach (t; T) {\n        foreach (i; 0 .. 100001) {\n            if (i + t > 1000000) continue;\n            dp[i + t] = min(dp[i + t], dp[i] + 1);\n        }\n    }\n\n    auto dp2 = new long[1000001];\n    dp2[] = 1L << 30;\n    dp2[0] = 0;\n    foreach (t; O) {\n        foreach (i; 0 .. 100001) {\n            if (i + t > 1000000) continue;\n            dp2[i + t] = min(dp2[i + t], dp2[i] + 1);\n        }\n    }\n\n    void solve() {\n        writeln(dp[N], \" \", dp2[N]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int maxN = 10^^6;\n    int[] f, f_odd;\n    for(int n=1; ;n++) {\n        f ~= func(n);\n        if (f.back > maxN) break;\n        if (f.back%2!=0) f_odd~= f.back;\n    }\n    int INF = 1<<30;\n\n    int[] ary = new int[maxN+1];\n    ary[] = INF;\n    ary[0] = 0;\n    foreach(int i; 0..maxN) {\n        if (ary[i]<INF) {\n            for(int n=0; n<f.length; n++) {\n                if (i+f[n]<=maxN) {\n                    ary[i+f[n]] = min(ary[i+f[n]], ary[i]+1);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    int[] _ary = new int[maxN+1];\n    _ary[] = INF;\n    _ary[0] = 0;\n    foreach(int i; 0..maxN) {\n        if (_ary[i]<INF) {\n            for(int n=0; n<f_odd.length; n++) {\n                if (i+f_odd[n]<=maxN) {\n                    _ary[i+f_odd[n]] = min(_ary[i+f_odd[n]], _ary[i]+1);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    while(true) {\n        int N = readln.chomp.to!int;\n        if (N==0) break;\n        writeln(ary[N], \" \", _ary[N]);\n    }\n}\nint func(int n) {\n    return n*(n+1)*(n+2)/6;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\nint a;\nint[] p = [1,4,10,20,35];\nint[] dp,odp;\n\nvoid main(){\n    for(int i=6;i<51;i++){\n\tp ~= i * (i+1) * (i+2) / 6;\n    }\n    dp = new int[1000001];\n    odp = new int[1000001];\n    fill(dp,-1);\n    fill(odp,-1);\n    dp[0] = 0;\n    dp[1] = 1;\n    odp[0] = 0;\n    odp[1] = 1;\n    for(int i=to!int(p.length)-1;i>=0;i--){\n\tfor(int j=p[i];j<=1e6;j++){\n\t    if(dp[j-p[i]] > -1){\n\t\tif(dp[j] > -1)\n\t\t    dp[j] = min(dp[j],1 + dp[j-p[i]]);\n\t\telse dp[j] = 1 + dp[j-p[i]];\n\t    }\n\t    if(odp[j-p[i]] > -1){\n\t\tif(p[i] % 2 == 1){\n\t\t    if(odp[j] > -1)\n\t\t\todp[j] = min(odp[j],1 + odp[j-p[i]]);\n\t\t    else odp[j] = 1 + odp[j-p[i]];\n\t\t}\n\t    }\n\t}\n    }\n\n    while(true){\n\tint n = readln().chomp().to!int;\n\tif(n == 0) break;\n\twriteln(dp[n] , \" \" , odp[n]);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.cstream;\nimport std.string;\n\nvoid main(string[] args){\nint[1000010] dp,dp1;\nint [2002] dp4;\nfor(int i=1;i<=1000000;i++){\n/+\ndp3[i]=cast(int)(0.5*i*(i+1));/++/\ndp4[i]+=dp3[i]+dp4[i-1];/++/\n+/\ndp1[i]=0;\ndp[i]=0;\n//dp2[i]=0;\nif(i<2000)dp4[i]+=cast(int)(0.5*i*(i+1)) + dp4[i-1];\n}\ndp1[1]=0;//ord\ndp[1]=0;//odd\nfor(int i=1;i<=1000000;i++){\nint minn=2000000,minnn=2000000;\n  for(int j=1;dp4[j]<=i;j++){\n       if(minn>dp1[i-dp4[j]]+1)minn=dp1[i-dp4[j]]+1;\n       if(dp4[j]%2 != 0){\n       if(minnn>dp[i-dp4[j]]+1)minnn=dp[i-dp4[j]]+1;\n       }\n   \n  }\ndp1[i]=minn;\ndp[i]=minnn;\n\n}\n\n\n\nint n,index=0;\nwhile(true){\nscanf(\"%d\",&n);\nif(n == 0)break;\n\nprintf(\"%d %d\\n\",dp1[n],dp[n]);\n/+\nindex = 0;\nfor(int i=1;i<=1000000;i++){\nif(dp4[index]<=n)index=i;\nelse break;\n}\n+/\n/+\nfor(int i;i<20;i++)writeln(dp4[i]);\nprintf(\"\\n\\n %d\\n\",index);\n+/\n\n\n}\n\n\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\nint a;\nint[] p = [1,4,10,20,35];\nint[] dp,odp;\n\nvoid main(){\n    for(int i=6;i<51;i++){\n\tp ~= i * (i+1) * (i+2) / 6;\n    }\n    dp = new int[1000001];\n    odp = new int[1000001];\n    fill(dp,-1);\n    fill(odp,-1);\n    dp[0] = 0;\n    dp[1] = 1;\n    odp[0] = 0;\n    odp[1] = 1;\n    for(int i=to!int(p.length)-1;i>=0;i--){\n\tfor(int j=p[i];j<=1e6;j++){\n\t    if(dp[j-p[i]] > -1){\n\t\tif(dp[j] > -1)\n\t\t    dp[j] = min(dp[j],1 + dp[j-p[i]]);\n\t\telse dp[j] = 1 + dp[j-p[i]];\n\t    }\n\t    if(odp[j-p[i]] > -1){\n\t\tif(p[i] % 2 == 1){\n\t\t    if(odp[j] > -1)\n\t\t\todp[j] = min(odp[j],1 + odp[j-p[i]]);\n\t\t    else odp[j] = 1 + odp[j-p[i]];\n\t\t}\n\t    }\n\t}\n    }\n\n    while(true){\n\tint n = readln().chomp().to!int;\n\tif(n == 0) break;\n\twriteln(dp[n] , \" \" , odp[n]);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.math;\nimport std.typecons;\nimport std.regex;\nimport std.range;\nint a;\nint[] p = [1,4,10,20,35];\nint[] dp,odp;\n\n\nvoid main(){\n    for(int i=6;i<100;i++){\n\tp ~= i * (i+1) * (i+2) / 6;\n    }\n    dp = new int[1000001];\n    odp = new int[1000001];\n    fill(dp,-1);\n    fill(odp,-1);\n    dp[0] = 0;\n    dp[1] = 1;\n    odp[0] = 0;\n    odp[1] = 1;\n    for(int i=to!int(p.length)-1;i>=0;i--){\n\tfor(int j=p[i];j<=1e6;j++){\n\t    if(dp[j-p[i]] > -1){\n\t\tif(dp[j] > -1)\n\t\t    dp[j] = min(dp[j],1 + dp[j-p[i]]);\n\t\telse dp[j] = 1 + dp[j-p[i]];\n\t    }\n\t    if(odp[j-p[i]] > -1){\n\t\tif(p[i] % 2 == 1){\n\t\t    if(odp[j] > -1)\n\t\t\todp[j] = min(odp[j],1 + odp[j-p[i]]);\n\t\t    else odp[j] = 1 + odp[j-p[i]];\n\t\t}\n\t    }\n\t}\n    }\n\n    while(true){\n\tint n = readln().chomp().to!int;\n\tif(n == 0) break;\n\twriteln(dp[n] , \" \" , odp[n]);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n    T.sort!\"a > b\";\n    O.sort!\"a > b\";\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n\n    auto dp = new long[1000001];\n    dp[] = 1L << 30;\n    dp[0] = 0;\n    foreach (t; T) {\n        foreach (i; 0 .. 1000001) {\n            if (i + t > 1000000) continue;\n            dp[i + t] = min(dp[i + t], dp[i] + 1);\n        }\n    }\n\n    auto dp2 = new long[1000001];\n    dp2[] = 1L << 30;\n    dp2[0] = 0;\n    foreach (t; O) {\n        foreach (i; 0 .. 1000001) {\n            if (i + t > 1000000) continue;\n            dp2[i + t] = min(dp2[i + t], dp2[i] + 1);\n        }\n    }\n\n    void solve() {\n        writeln(dp[N], \" \", dp2[N]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int maxN = 10^^6;\n    int[] f, f_odd;\n    for(int n=1; ;n++) {\n        f ~= func(n);\n        if (f.back > maxN) break;\n        if (f.back%2!=0) f_odd~= f.back;\n    }\n    int INF = 1<<30;\n    while(true) {\n        int N = readln.chomp.to!int;\n        if (N==0) break;\n        int[] ary = new int[N+1];\n        ary[] = INF;\n        ary[0] = 0;\n        while(true) {\n            foreach(int i; 0..N) {\n                if (ary[i]<INF) {\n                    for(int n=0; n<f.length; n++) {\n                        if (i+f[n]<=N) {\n                            ary[i+f[n]] = min(ary[i+f[n]], ary[i]+1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (ary[N] < INF) break;\n        }\n        ary[N].write;\n        \" \".write;\n        ary[] = INF;\n        ary[0] = 0;\n        while(true) {\n            foreach(int i; 0..N) {\n                if (ary[i]<INF) {\n                    for(int n=0; n<f_odd.length; n++) {\n                        if (i+f_odd[n]<=N) {\n                            ary[i+f_odd[n]] = min(ary[i+f_odd[n]], ary[i]+1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (ary[N] < INF) break;\n        }\n        ary[N].writeln;\n    }\n}\nint func(int n) {\n    return n*(n+1)*(n+2)/6;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n    O.sort!\"a > b\";\n    T.sort!\"a > b\";\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n\n    auto dp = new long[1000001];\n    dp[] = 1L << 30;\n    dp[0] = 0;\n    foreach (t; T) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp[i + t] = min(dp[i + t], dp[i] + 1);\n        }\n    }\n\n    auto dp2 = new long[1000001];\n    dp2[] = 1L << 30;\n    dp2[0] = 0;\n    foreach (t; O) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp2[i + t] = min(dp2[i + t], dp2[i] + 1);\n        }\n    }\n\n    void solve() {\n        writeln(dp[N], \" \", dp2[N]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int maxN = 10^^6;\n    int[] f, f_odd;\n    for(int n=1; ;n++) {\n        f ~= func(n);\n        if (f.back > maxN) break;\n        if (f.back%2!=0) f_odd~= f.back;\n    }\n    int INF = 1<<30;\n\n    int[] ary = new int[maxN+1];\n    ary[] = INF;\n    ary[0] = 0;\n    while(true) {\n        foreach(int i; 0..maxN) {\n            if (ary[i]<INF) {\n                for(int n=0; n<f.length; n++) {\n                    if (i+f[n]<=maxN) {\n                        ary[i+f[n]] = min(ary[i+f[n]], ary[i]+1);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        if (ary[maxN] < INF) break;\n    }\n    int[] _ary = new int[maxN+1];\n    _ary[] = INF;\n    _ary[0] = 0;\n    while(true) {\n        foreach(int i; 0..maxN) {\n            if (_ary[i]<INF) {\n                for(int n=0; n<f_odd.length; n++) {\n                    if (i+f_odd[n]<=maxN) {\n                        _ary[i+f_odd[n]] = min(_ary[i+f_odd[n]], _ary[i]+1);\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        if (_ary[maxN] < INF) break;\n    }\n\n    while(true) {\n        int N = readln.chomp.to!int;\n        if (N==0) break;\n        writeln(ary[N], \" \", _ary[N]);\n    }\n}\nint func(int n) {\n    return n*(n+1)*(n+2)/6;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric;\n\nvoid main()\n{\n    auto DP1 = new int[](10^^6+1);\n    auto DP2 = new int[](10^^6+1);\n\n    foreach (x; 1..10^^6+1) {\n        auto r = int.max/3, s = int.max/3;\n        foreach (n; 1..181) {\n            auto d = n*(n+1)*(n+2)/6;\n\n            if (x-d >= 0) r = min(r, DP1[x-d] + 1);\n            if (d%2 == 1 && x-d >= 0) s = min(s, DP2[x-d] + 1);\n        }\n        DP1[x] = r;\n        DP2[x] = s;\n    }\n\n    for (;;) {\n        auto N = readln.chomp.to!int;\n        if (N == 0) return;\n\n        writefln(\"%d %d\", DP1[N], DP2[N]);\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nvoid main() {\n    int maxN = 10^^6;\n    int[] f, f_odd;\n    for(int n=1; ;n++) {\n        f ~= func(n);\n        if (f.back > maxN) break;\n        if (f.back%2!=0) f_odd~= f.back;\n    }\n    int INF = 1<<30;\n\n    int[] ary = new int[maxN+1];\n    ary[] = INF;\n    ary[0] = 0;\n    foreach(int i; 0..maxN) {\n        for(int n=0; n<f.length; n++) {\n            if (i+f[n]<=maxN) {\n                ary[i+f[n]] = min(ary[i+f[n]], ary[i]+1);\n            } else {\n                break;\n            }\n        }\n    }\n    int[] _ary = new int[maxN+1];\n    _ary[] = INF;\n    _ary[0] = 0;\n    foreach(int i; 0..maxN) {\n        for(int n=0; n<f_odd.length; n++) {\n            if (i+f_odd[n]<=maxN) {\n                _ary[i+f_odd[n]] = min(_ary[i+f_odd[n]], _ary[i]+1);\n            } else {\n                break;\n            }\n        }\n    }\n\n    while(true) {\n        int N = readln.chomp.to!int;\n        if (N==0) break;\n        writeln(ary[N], \" \", _ary[N]);\n    }\n}\nint func(int n) {\n    return n*(n+1)*(n+2)/6;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.array, std.algorithm;\n\nulong[] getArray() {\n  auto ary = appender( new ulong[]( 0 ) );\n  foreach ( n; 1 .. 1000 ) {\n\timmutable ulong val = n * ( n + 1 ) * ( n + 2 ) / 6;\n\tif ( val >= 10 ^^ 6 ) {\n\t  break;\n\t} else {\n\t  ary.put( val );\n\t}\n  }\n  return ary.data;\n}\n\nulong[] getOddArray() {\n  immutable auto s = getArray().length;\n  auto ary = appender( new ulong[]( 0 ) );\n  foreach ( n; 1 .. s + 1 ) {\n\timmutable auto val = n * ( n + 1 ) * ( n + 2 ) / 6;\n\tif ( val % 2 == 1 ) {\n\t  ary.put( val );\n\t}\n  }\n  return ary.data;\n}\n\nvoid main()\n{\n  const ulong[] array = getArray();\n  const ulong[] oddArray = getOddArray();\n\n  ulong[] answer = new ulong[]( 100_0001 );\n  answer[] = 100_0000;\n  answer[ 0 ] = 0;\n  ulong[] oddAnswer = new ulong[]( 100_0001 );\n  oddAnswer[] = 100_0000;\n  oddAnswer[ 0 ] = 0;\n  \n  foreach ( i; 0 .. 100_0001 ) {\n\tforeach ( v; array ) {\n\t  if ( i + v <= 100_0000 ) {\n\t\tanswer[ i + v ] = min( answer[ i + v ], answer[ i ] + 1 );\n\t  }\n\t}\n\tforeach ( v; oddArray ) {\n\t  if ( i + v <= 100_0000 ) {\n\t\toddAnswer[ i + v ] = min( oddAnswer[ i + v ], oddAnswer[ i ] + 1 );\n\t  }\n\t}\n  }\n\n  while ( true ) {\n\timmutable int n = to!int( strip( readln ) );\n\tif ( n == 0 ) break;\n\twriteln( answer[ n ], \" \", oddAnswer[ n ] );\n  }  \n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n\n    auto dp = new long[1000001];\n    dp[] = 1L << 30;\n    dp[0] = 0;\n    foreach (t; T) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp[i + t] = min(dp[i + t], dp[i] + 1);\n        }\n    }\n\n    auto dp2 = new long[1000001];\n    dp2[] = 1L << 30;\n    dp2[0] = 0;\n    foreach (t; O) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp2[i + t] = min(dp2[i + t], dp2[i] + 1);\n        }\n    }\n\n    void solve() {\n        writeln(dp[N], \" \", dp2[N]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n\n    auto dp = new long[1000001];\n    dp[] = 1L << 30;\n    dp[0] = 0;\n    foreach (t; T) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp[i + t] = min(dp[i + t], dp[i] + 1);\n        }\n    }\n\n    auto dp2 = new long[1000001];\n    dp2[] = 1L << 30;\n    dp2[0] = 0;\n    foreach (t; O) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp2[i + t] = min(dp2[i + t], dp2[i] + 1);\n        }\n    }\n\n    void solve() {\n        writeln(dp[N], \" \", dp2[N]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n    O.sort!\"a > b\";\n    T.sort!\"a > b\";\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n\n    auto dp = new int[1000001];\n    dp[] = 1 << 28;\n    dp[0] = 0;\n    foreach (t; T) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp[i + t] = min(dp[i + t], dp[i] + 1);\n        }\n    }\n\n    auto dp2 = new int[1000001];\n    dp2[] = 1 << 28;\n    dp2[0] = 0;\n    foreach (t; O) {\n        foreach (i; 0 .. 100001) {\n            if (i + t >= 1000000) continue;\n            dp2[i + t] = min(dp2[i + t], dp2[i] + 1);\n        }\n    }\n\n    void solve() {\n        writeln(dp[N], \" \", dp2[N]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n    O.sort!\"a > b\";\n    T.sort!\"a > b\";\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n    void solve() {\n\n        int dfs(int[] T, int index, int X) {\n            int ret = int.max / 2;\n            if (X == 0) return 0;\n            if (index == T.length) return int.max / 2;\n            for (int i = X / T[index]; i >= 0; i--) {\n                ret = min(ret, dfs(T, index + 1, X - i * T[index]) + i);\n            }\n            return ret;\n        }\n\n        writeln(dfs(T, 0, N), \" \", dfs(O, 0, N));\n\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv, std.range;\nimport std.algorithm, std.array, std.typecons, std.container;\nimport std.math, std.numeric, std.random, core.bitop;\n\nenum inf = 1_001_001_001;\nenum infl = 1_001_001_001_001_001_001L;\nenum mod = 1_000_000_007L;\n\nenum lim = 10^^6;\n\nvoid main() {\n    auto f = new int[](2000);\n    foreach (i ; 1 .. 2000) {\n        f[i] = f[i - 1] + i;\n    }\n    foreach (i ; 1 .. 2000) {\n        f[i] += f[i - 1];\n    }\n    f = f.filter!(x => x < lim).array;\n    debug {\n        writeln(f);\n        writeln(f.length);\n    }\n    auto n = f.length.to!int;\n    auto dp = new int[](lim);\n    auto dp2 = new int[](lim);\n    dp[] = inf;\n    dp2[] = inf;\n    dp[0] = dp2[0] = 0;\n\n    foreach (i ; 0 .. n) {\n        foreach (j ; 0 .. lim) {\n            if (j + f[i] < lim) {\n                chmin(dp[j + f[i]], dp[j] + 1);\n                if (f[i] % 2) chmin(dp2[j + f[i]], dp2[j] + 1);\n            }\n        }\n    }\n\n    while (true) {\n        int x;\n        scan(x);\n        if (x == 0) return;\n        writefln(\"%s %s\", dp[x], dp2[x]);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid scan(T...)(ref T args) {\n    import std.stdio : readln;\n    import std.algorithm : splitter;\n    import std.conv : to;\n    import std.range.primitives;\n\n    auto line = readln().splitter();\n    foreach (ref arg; args) {\n        arg = line.front.to!(typeof(arg));\n        line.popFront();\n    }\n    assert(line.empty);\n}\n\nvoid fillAll(R, T)(ref R arr, T value) {\n    static if (is(typeof(arr[] = value))) {\n        arr[] = value;\n    }\n    else {\n        foreach (ref e; arr) {\n            fillAll(e, value);\n        }\n    }\n}\n\nbool chmin(T, U...)(ref T x, U args) {\n    bool isChanged;\n\n    foreach (arg; args) {\n        if (x > arg) {\n            x = arg;\n            isChanged = true;\n        }\n    }\n\n    return isChanged;\n}\n\nbool chmax(T, U...)(ref T x, U args) {\n    bool isChanged;\n\n    foreach (arg; args) {\n        if (x < arg) {\n            x = arg;\n            isChanged = true;\n        }\n    }\n\n    return isChanged;\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint[] T, O;\n\nint calc(int x) {\n    return x * (x + 1) * (x + 2) / 6;\n}\n\nvoid prepare() {\n    for (int i = 1; ; i++) {\n        int x = calc(i);\n        if (x > 1000000) break;\n        T ~= x;\n        if (x % 2 == 1) O ~= x;\n    }\n    T.sort!\"a > b\";\n    O.sort!\"a > b\";\n}\n\nvoid main() {\n    prepare;\n    int N;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        return true;\n    }\n\n    auto dp = new long[1000001];\n    dp[] = 1L << 30;\n    dp[0] = 0;\n    foreach (t; T) {\n        foreach (i; 0 .. 100001) {\n            if (i + t > 1000000) continue;\n            dp[i + t] = min(dp[i + t], dp[i] + 1);\n        }\n    }\n\n    auto dp2 = new long[1000001];\n    dp2[] = 1L << 30;\n    dp2[0] = 0;\n    foreach (t; O) {\n        foreach (i; 0 .. 100001) {\n            if (i + t > 1000000) continue;\n            dp2[i + t] = min(dp2[i + t], dp2[i] + 1);\n        }\n    }\n\n    void solve() {\n        writeln(dp[N], \" \", dp2[N]);\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "MAX=1000000\nINF=100000\nimport math\n\ndef f(a):\n\treturn (a*(a+1)*(a+2))/6\n\n\n\ndef solve(lst):\n\tglobal ans\n\tglobal n\n\tcount=2\n\twhile True:\n\n\t\t\n\t\tif ans[n]!=INF:\n\t\t\treturn ans[n]\n\n\t\tkeepans=list(ans)\n\t\t\n\t\tfor i in range(n+1):\n\t\t\tif ans[i]!=INF:\n\t\t\t\tfor j in range(n+1):\n\t\t\t\t\tif i+j<=n:\n\t\t\t\t\t\tif ans[j]!=INF and keepans[i+j]>ans[i]+ans[j] :\n\t\t\t\t\t\t\tkeepans[i+j]=ans[i]+ans[j]\n\t\t\t\t\t\t\t#print i,j,\"=\",keepans[i+j]\n\t\t\n\t\tc=0\n\t\tfor l in ans:\n\t\t\tif keepans[c]!=0:\n\t\t\t\tans[c]=keepans[c]\n\t\t\tc=c+1\n\t\t#print \"----------\"\n\t\tcount=count+1\n\n\n\n\n\nwhile True:\n\tn=int(raw_input())\n\tif n==0:\n\t\tbreak\n\n\tbox=[]\n\toddbox=[]\n\tans=[INF]*(n+1)\n\toddans=[INF]*(n+1)\n\n\n\n\n\tfor i in range(200):\n\t\tnum=f(i)\n\t\tif num>n: break\n\n\t\tbox.append(num)\n\t\tif i!=0:ans[num]=1\n\t\tif num%2==1:\n\t\t\toddbox.append(num)\n\t\t\toddans[num]=1\n\n\t\n\tprint solve(box)\n\tans=oddans\n\tprint solve(oddbox)"
  },
  {
    "language": "Python",
    "code": "INF = 1000000\n\nwhile True:\n    n = input()\n    n = int(n)\n\n    if n == 0:\n        break\n\n    i = 1\n    tetra = []\n    while True:\n        t = i*(1+i)*(2+i)/6\n        if t <= n:\n            tetra.append(int(t))\n            i += 1\n        else:\n            break\n\n    dp = [[INF for _ in range(n+1)] for _ in range(len(tetra)+1)]\n    for i in range(len(tetra)+1):\n        dp[i][0] = 0\n\n    for i in range(len(tetra)):\n        for j in range(n):\n            if j + tetra[i] <= n:\n                m = INF\n                for k in range(i+1):\n                    if dp[k+1][j] < m:\n                        m = dp[k+1][j]\n                dp[i+1][j+tetra[i]] = m+1\n\n    output = INF\n    for i in range(len(tetra)+1):\n        if dp[i][n] < output:\n            output = dp[i][n]\n\n    print(output)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    m = 10**6\n\n    a = [inf] * m\n    b = [inf] * m\n    a[0] = 0\n    b[0] = 0\n    for i in range(1,200):\n        t = i * (i+1) * (i+2) // 6\n        for j in range(t,m):\n            if a[j] > a[j-t] + 1:\n                a[j] = a[j-t] + 1\n        if t % 2 == 0:\n            continue\n        for j in range(t,m):\n            if b[j] > b[j-t] + 1:\n                b[j] = b[j-t] + 1\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append('{} {}'.format(a[n],b[n]))\n\n\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = [5] * 1000000\n    rec[0] = 0\n    \n    tetra_num = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n    \n    for i, a in enumerate(tetra_num):\n        for j, b in enumerate(tetra_num[i:], start=i):\n            if a + b >= 1000000:\n                break\n            for c in tetra_num[j:]:\n                if a + b + c >= 1000000:\n                    break\n                rec[a + b + c] = 3\n    \n    for i, a in enumerate(tetra_num, start=0):\n        for b in tetra_num[i:]:\n            if a + b >= 1000000:\n                break\n            rec[a + b] = 2\n    \n    for n in tetra_num:\n        rec[n] = 1\n    \n    for i, n in enumerate(rec[1:], start=1):\n        if n == 3:\n            for t in tetra_num:\n                if i + t >= 1000000:\n                    break\n                if rec[i + t] == 5:\n                    rec[i + t] = 4\n    \n    odd_rec = [1000000] * 1000000\n    odd_rec[0] = 0\n    \n    odd_tetra_num = tetra_num[::4]\n    \n    for odd_t in odd_tetra_num:\n        for i, tpl in enumerate(zip(odd_rec[odd_t:], odd_rec), start=odd_t):\n            a, b = tpl\n            b += 1\n            if b < a:\n                odd_rec[i] = b\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "N = 1000000\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    #if p_ > N +1:\n     #   continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\n\"\"\"\n    if p_%2==0:\n        continue\n    for j in range(p_,N):\n        if N2[j] >N2[j-p_]+1:\n            N2[j]=N2[j-p_]+1\n\"\"\"\n#print(\"a\")\nfor p_ in p2:\n#    if p_ > N +1 :\n #       continue\n    #n = min(p_*7,N+1)\n    for j in range(p_,N):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\n#print('a')\n\"\"\"\n\"\"\"\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = [1000000] * 1000000\n    rec[0] = 0\n    odd_rec = rec.copy()\n    \n    for i in range(1, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        for i, tpl in enumerate(zip(rec[t:t*3+1], rec), start=t):\n            a, b = tpl\n            b += 1\n            if b < a:\n                rec[i] = b\n        if t % 2:\n            for i, tpl in enumerate(zip(odd_rec[t:t*34+1], odd_rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    odd_rec[i] = b\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\nP1=[p*(p+1)*(p+2)/6 for p in range(1,181)]\nP2=[p for p in P1 if p%2]\n\nmaxnum=1000000\n\nA1=[999999 for x in range(maxnum+1)]\nA2=[999999 for x in range(maxnum+1)]\n\nfor X in [[P1,A1],[P2,A2]]:\n    P=X[0]\n    A=X[1]\n    tmp=P\n    bk=0\n    cnt=2\n    for p in tmp:\n        if p<maxnum:\n            A[p]=1\n            bk+=1\n    while bk<maxnum:\n        tmp2=[]\n        for t in tmp:\n            for p in P:\n                if t+p > maxnum:    break\n                if A[t+p]>cnt:\n                    A[t+p]=cnt\n                    bk+=1\n                    tmp2.append(t+p)\n        tmp=tmp2[:]\n        cnt+=1\nwhile(1):\n    n=int(raw_input())\n    if n==0: break\n    print A1[n], A2[n]\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input=sys.stdin.readline   \n    M=10**6\n\n    dp=[0]+[M]*M\n    dpo=[0]+[M]*M\n\n    for i in range(1,200):\n        t=i*(i+1)*(i+2)//6\n\n        for j in range(t,min(5*t,M)):\n            if j<t:\n                dp[j]=dp[j]\n            else:\n                dp[j]=min(dp[j],dp[j-t]+1)\n        \n        if t%2==1:\n            for j in range(t,M):\n                if j<t:\n                    dpo[j]=dpo[j]\n                else:\n                    dpo[j]=min(dpo[j],dpo[j-t]+1)\n    \n    while True:\n        n=int(input())\n        if n==0:\n            break\n        else:\n            print(dp[n],dpo[n])\n\nif __name__=='__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = list(range(1000000))\n    odd_rec = rec.copy()\n    \n    for i in range(2, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        if t % 2 == 0:\n            for i, tpl in enumerate(zip(rec[t:], rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n        else:\n            z_rec = zip(rec[t:], rec, odd_rec[t:], odd_rec)\n            for i, tpl in enumerate(z_rec, start=t):\n                a, b, c, d = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n                d += 1\n                if d < c:\n                    odd_rec[i] = d\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = list(range(1000000))\n    odd_rec = rec.copy()\n    \n    for i in range(2, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        if t % 2 == 0:\n            for i, tpl in enumerate(zip(rec[t:], rec), start=t):\n                a, b = tpl\n                b += 1\n                if a < b:\n                    rec[i] = a\n                else:\n                    rec[i] = b\n        else:\n            z_rec = zip(rec[t:], rec, odd_rec[t:], odd_rec)\n            for i, tpl in enumerate(z_rec, start=t):\n                a, b, c, d = tpl\n                b += 1\n                if a < b:\n                    rec[i] = a\n                else:\n                    rec[i] = b\n                d += 1\n                if c < d:\n                    odd_rec[i] = c\n                else:\n                    odd_rec[i] = d\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    pass\n"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\nN1[0] = 0\nN2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > len(N1) :\n        continue\n    for j in range(p_,len(N1)):\n#        print(j)\n        N1[j] = min(N1[j],N1[j-p_]+1)\n\nfor p_ in p2:\n    if p_ > len(N2) :\n        continue\n    for j in range(p_,len(N2)):\n        N2[j] = min(N2[j],N2[j-p_]+1)\n#print('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    #n = min(p_*5,N+1)\n    for j in range(p_,N):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\n#print('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "def pollockConjection():\n    inf=int(1e6)\n    dp=list(range(0,inf+1))\n    odp=list(range(0,inf+1))\n    n=2\n    s=1\n    os=1\n    while s<inf+1:\n        s=n*(n+1)*(n+2)//6\n        n+=1\n        if s%2==1:\n            os=s\n        for i in range(0,inf+1-s):\n            dp[i+s]=min(dp[i+s],dp[i]+1)\n            odp[i+os]=min(odp[i+os],odp[i]+1)\n    return dp,odp\n\nif __name__==\"__main__\":\n    dp,odp=pollockConjection()\n　　while True:\n    N=int(input())\n    if N==0:\n        break\n    print(dp[N],odp[N])\n\n\n"
  },
  {
    "language": "Python",
    "code": "\n\ndef calc():\n    n = 10**6\n\n    dataset = [t * (t + 1) * (t + 2) // 6 for t in range(1, 181)]\n\n    dp = [1000] * (n+1)\n    dp_odd = dp.copy()\n    dp[0] = 0\n    dp_odd[0] = 0\n    for j in range(n):\n        for d in dataset:\n            if j + d > n:\n                break\n            if dp[j + d] > dp[j] + 1:\n                dp[j + d] = dp[j] + 1\n            if d%2:\n                if dp_odd[j + d] > dp_odd[j] + 1:\n                    dp_odd[j + d] = dp_odd[j] + 1\n\n    return dp, dp_odd\n\n\nall, odd = calc()\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n\n    a = all[n]\n    o = odd[n]\n\n    print(a, o)\n\n"
  },
  {
    "language": "Python",
    "code": "MAX = 1000000\ntetra = []\ndp = [0] * (MAX+1)\ndpodd = [0] * (MAX+1)\n\nfor i in range(1,MAX+1):\n    dp[i] = i\n    dpodd[i] = i\n\n\ni = 0\nwhile True:\n    i += 1\n    t = i * (i+1) * (i+2) / 6\n    if t > MAX: break\n    tetra.append(t)\n\nfor p in tetra:\n    #print(p)\n    for i in range(0,MAX-p):\n        dp[i+p] = min(dp[i+p], dp[i]+1)\n        if p % 2 == 1:\n            dpodd[i+p] = min(dpodd[i+p], dpodd[i]+1)\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    print dp[n],dpodd[n]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom bisect import bisect_left, bisect\n\ndef solve():\n    i = 1\n    P = []\n    x = 1\n    M = 10**6\n    while x < M:\n        P.append(x)\n        i += 1\n        x = (i)*(i+1)*(i+2)//6\n    \n    P = P[1:]\n    Q = [p for p in P if p%2]\n    DP1 = list(range(M+1))\n    DP2 = list(range(M+1))\n    \n    for i in range(M):\n        for p in P[:bisect(P, M-i)]:\n            DP1[i+p] = min(DP1[i+p], DP1[i]+1)\n        for q in Q[:bisect(Q, M-i)]:\n            DP2[i+q] = min(DP2[i+q], DP2[i]+1)\n    \n    N = int(input())\n    \n    while N:\n        print(\"{} {}\".format(DP1[N], DP2[N]))\n        N = int(input())\n\n\nif __name__ == \"__main__\":\n    solve()\n    exit()\n"
  },
  {
    "language": "Python",
    "code": "with open(\"input.txt\") as f:\n    while True:\n        target = int(f.readline())\n        if target == 0:\n            break\n        pascal = []\n        tmp = 1\n        nexpas = 1\n        oddpas = []\n        while target >= nexpas:\n            pascal.append(nexpas)\n            if nexpas % 2 == 1:\n                oddpas.append(nexpas)\n            tmp += 1\n            nexpas = (tmp * (tmp + 1) * (tmp + 2)) // 6\n        length = len(pascal)\n\n        dp = [float(\"inf\") for n in range(target + 1)]\n        ans = - 1\n        for i in range(length):\n            dp[pascal[i]] = 1\n            if pascal[i] == target:\n                ans = 1\n        cnt = 0\n        while cnt < 10:\n            #print(dp)\n            cnt += 1\n            tmpdp = dp[:]\n            if ans != -1:\n                break\n            else:\n                for outer in range(target + 1):\n                    if dp[outer] != float(\"inf\"):\n                        nowcnt = dp[outer]\n\n                        for i in range(length):\n                            nextnum = outer + pascal[i]\n\n                            if nextnum > target:\n                                break\n                            elif nextnum == target:\n                                ans = nowcnt + 1\n                                break\n                            tmpdp[nextnum] = min(dp[nextnum],nowcnt + 1)\n            #print(dp,tmpdb)\n            dp = tmpdp\n\n        oddlen = len(oddpas)\n        odddp = [float(\"inf\") for n in range(target + 1)]\n        oddans = -1\n        for i in range(oddlen):\n            odddp[oddpas[i]] = 1\n            if oddpas[i] == target:\n                oddans = 1\n        cnt = 0\n        #print(oddpas)\n        while cnt < 50:\n            #print(odddp)\n            cnt += 1\n            tmpdp = odddp[:]\n            if oddans != -1:\n                break\n            else:\n                for outer in range(target + 1):\n                    if odddp[outer] != float(\"inf\"):\n                        nowcnt = odddp[outer]\n                        for i in range(oddlen):\n                            nextnum = outer + oddpas[i]\n                            #print(nextnum)\n                            if nextnum > target:\n                                break\n                            elif nextnum == target:\n                                oddans = nowcnt + 1\n                                break\n                            tmpdp[nextnum] = min(odddp[nextnum],nowcnt + 1)\n            odddp = tmpdp\n        print(str(ans) + \" \" + str(oddans))\n        #print(odddp,oddpas,oddans,target)\n        #print(dp,pascal,ans,target)"
  },
  {
    "language": "Python",
    "code": "def pollockConjection():\n    inf=int(1e6)\n    dp=list(range(0,inf+1))\n    odp=list(range(0,inf+1))\n    n=2\n    s=1\n    os=1\n    while s<inf+1:\n        s=n*(n+1)*(n+2)//6\n        n+=1\n        if s%2==1:\n            os=s\n        for i in range(0,inf+1-s):\n            dp[i+s]=min(dp[i+s],dp[i]+1)\n            odp[i+os]=min(odp[i+os],odp[i]+1)\n    return dp,odp\n\nif __name__==\"__main__\":\n    dp,odp=pollockConjection()\n    while True:\n        N=int(input())\n        if N==0:\n            break\n        print(dp[N],odp[N])\n"
  },
  {
    "language": "Python",
    "code": "MAX = 10**6 - 1\ninf = float(\"inf\")\ntetra_sum = [inf for i in range(MAX+1)]\ntetra_sum_odd = [inf for i in range(MAX+1)]\ntetra_sum[0] = 0\ntetra_sum_odd[0] = 0\nfor n in range(1,181):\n\ttetra_n = n * (n+1) * (n+2) / 6\n\tfor i in range(tetra_n,MAX+1):\n\t\tif tetra_sum[i-tetra_n] + 1 < tetra_sum[i]:\n\t\t\ttetra_sum[i] = tetra_sum[i-tetra_n] + 1\n\t\tif (tetra_n % 2) == 1 and tetra_sum_odd[i-tetra_n] + 1 < tetra_sum_odd[i]:\n\t\t\ttetra_sum_odd[i] = tetra_sum_odd[i-tetra_n] + 1\nwhile 1:\n\tN = int(raw_input())\n\tif N == 0:\n\t\tbreak\n\tprint tetra_sum[N], tetra_sum_odd[N]"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = [1000000] * 1000000\n    rec[0] = 0\n    odd_rec = rec.copy()\n    \n    for i in range(1, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        for i, tpl in enumerate(zip(rec[t:t*4], rec), start=t):\n            a, b = tpl\n            b += 1\n            if b < a:\n                rec[i] = b\n        if t % 2:\n            for i, tpl in enumerate(zip(odd_rec[t:t*35], odd_rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    odd_rec[i] = b\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = [1000000] * 1000000\n    rec[0] = 0\n    odd_rec = rec.copy()\n\n    for i in range(1, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        for i, tpl in enumerate(zip(rec[t:t*3+1], rec), start=t):\n            a, b = tpl\n            b += 1\n            if b < a:\n                rec[i] = b\n        if t % 2:\n            for i, tpl in enumerate(zip(odd_rec[t:t*34+1], odd_rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    odd_rec[i] = b\n\n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\n\nsolve()\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    target = int(input())\n    if target == 0:\n        break\n    pascal = []\n    tmp = 1\n    nexpas = 1\n    oddpas = []\n    while target >= nexpas:\n        pascal.append(nexpas)\n        if nexpas % 2 == 1:\n            oddpas.append(nexpas)\n        tmp += 1\n        nexpas = (tmp * (tmp + 1) * (tmp + 2)) // 6\n    length = len(pascal)\n\n    dp = [float(\"inf\") for n in range(target + 1)]\n    ans = - 1\n    for i in range(length):\n        dp[pascal[i]] = 1\n        if pascal[i] == target:\n            ans = 1\n    cnt = 0\n    while cnt < 10:\n        #print(dp)\n        cnt += 1\n        tmpdp = dp[:]\n        if ans != -1:\n            break\n        else:\n            for outer in range(target + 1):\n                if dp[outer] != float(\"inf\"):\n                    nowcnt = dp[outer]\n\n                    for i in range(length):\n                        nextnum = outer + pascal[i]\n\n                        if nextnum > target:\n                            break\n                        elif nextnum == target:\n                            ans = nowcnt + 1\n                            break\n                        tmpdp[nextnum] = min(dp[nextnum],nowcnt + 1)\n        #print(dp,tmpdb)\n        dp = tmpdp\n\n    oddlen = len(oddpas)\n    odddp = [float(\"inf\") for n in range(target + 1)]\n    oddans = -1\n    for i in range(oddlen):\n        odddp[oddpas[i]] = 1\n        if oddpas[i] == target:\n            oddans = 1\n    cnt = 0\n    #print(oddpas)\n    while cnt < 50:\n        #print(odddp)\n        cnt += 1\n        tmpdp = odddp[:]\n        if oddans != -1:\n            break\n        else:\n            for outer in range(target + 1):\n                if odddp[outer] != float(\"inf\"):\n                    nowcnt = odddp[outer]\n                    for i in range(oddlen):\n                        nextnum = outer + oddpas[i]\n                        #print(nextnum)\n                        if nextnum > target:\n                            break\n                        elif nextnum == target:\n                            oddans = nowcnt + 1\n                            break\n                        tmpdp[nextnum] = min(odddp[nextnum],nowcnt + 1)\n        odddp = tmpdp\n    print(str(ans) + \" \" + str(oddans))\n    #print(odddp,oddpas,oddans,target)\n    #print(dp,pascal,ans,target)"
  },
  {
    "language": "Python",
    "code": "R = 10**6+1\nT = [i*(i+1)*(2*i+1)/6 for i in xrange(145)]\ndp1 = [100]*R\ndp2 = [100]*R\nfor t in T:\n    dp1[t] = 1\n    for i in xrange(t,R):\n        if dp1[i-t]: dp1[i] = min(dp1[i],dp1[i-t]+1)\n    if t%2 == 0: continue\n    dp2[t] = 1\n    for i in xrange(t,R):\n        if dp2[i-t]: dp1[i] = min(dp2[i],dp2[i-t]+1)\nwhile 1:\n    n = int(raw_input())\n    print dp1[n],dp2[n]"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    file_input = sys.stdin\n    \n    def tetra_num(n):\n        for i in range(1, 181):\n            t = i * (i + 1) * (i + 2) // 6\n            if t <= n:\n                yield t\n            else:\n                break\n    \n    while True:\n        n = int(file_input.readline())\n        if n == 0:\n            break\n        \n        n_lim = 1000000\n        rec = [n_lim] * (n + 1)\n        rec[0] = 0\n        odd_rec = [n_lim] * (n + 1)\n        odd_rec[0] = 0\n        \n        for t in tetra_num(n):\n            if t % 2 == 0:\n                for i, tpl in enumerate(zip(rec[t:], rec), start=t):\n                    a, b = tpl\n                    rec[i] = min(a, b + 1)\n            else:\n                z_rec = zip(rec[t:], rec, odd_rec[t:], odd_rec)\n                for i, tpl in enumerate(z_rec, start=t):\n                    a, b, c, d = tpl\n                    rec[i] = min(a, b + 1)\n                    odd_rec[i] = min(c, d + 1)\n                    \n        print(rec[n], odd_rec[n])\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Here your code !\n\nn = []\nn.append(int(input()))\nwhile min(n):\n    n.append(int(input()))\n#triangle = [0]\npyramid = [0]\npyramid_kisu = []\nm = 0\nmemo = []\nmemo_kisu = []\n\nwhile pyramid[m] < max(n):\n    m += 1\n#    triangle.append(m+triangle[m-1])\n#    pyramid.append(triangle[m]+pyramid[m-1])\n    pyramid.append(int((m*(m+1)*(m+2))/6))\n\nfor i in pyramid:\n    if i % 2 == 1:\n        pyramid_kisu.append(i)\n\nfor i in range(len(pyramid_kisu)):\n    memo_kisu.append([0,[pyramid_kisu[i]]])\n\nfor i in range(m+1):\n    memo.append([[0],[],[],[],[],[]])\n    memo[i][1].append(pyramid[i])\n\nfor j in range(2,6):\n    for i in range(1,m):\n            for k in range(1,i+1):\n                for l in memo[k][j-1]:\n                    memo[i][j].append(pyramid[i]+l)\n\nkisu_len=[1]\nfor question in n:\n    flag = 0\n    if question == 0:\n        break\n    else:\n        for j in range(1,6):\n            for i in reversed(range(1,len(memo))):\n                if question in memo[i][j]:\n                    ans=j\n                    flag = 1\n                    break\n            if flag == 1:\n                break\n        \n        flag = 0\n        count = 1\n        while 1:\n            for i in range(len(memo_kisu)):\n                if question in memo_kisu[i][count]:\n                    ans_kisu = count\n                    kisu_len.append(ans_kisu)\n                    flag = 1\n               # if count >= max(kisu_len):\n                if count >= len(memo_kisu[2])-1:\n                  #  print(count,len(memo_kisu[2]))\n                    memo_kisu[i].append([])\n                    for k in range(i+1):\n                        for l in memo_kisu[k][count]:\n                            memo_kisu[i][count+1].append(pyramid_kisu[i]+l)\n                 \n            if flag == 1:\n                break\n            count += 1               \n    print(ans,ans_kisu)\n#print(kisu_len,memo_kisu[2][max(kisu_len)-1])\n#print(kisu_len,memo_kisu)"
  },
  {
    "language": "Python",
    "code": "#import time\n\ndef main():\n    inputlst=[]\n\n    while 1 :\n        n=int(input())\n        if n==0 : break\n        inputlst.append(n)\n\n    #start=time.time()\n\n    lst=[]\n\n    for i in range(1,181):\n        j=i*(i+1)*(i+2)//6\n        if j>=10**6 : break\n        lst.append(j)\n\n    olst=[i for i,x in enumerate(lst) if x%2==1]    \n\n    nlst=len(lst)\n\n    #dpのアップデート(i番目)は(i-1番目)の自身とこれまで計算したi番目の結果しか使わないので1次元配列で済む\n    dp=[i for i in range(10**6)]\n    dpo=[i for i in range(10**6)]\n\n\n    for i in range(nlst):\n        li=lst[i]\n        if i in olst:\n            for j in range(li,10**6):\n                if dp[j-li]+1<dp[j]:\n                    dp[j]=dp[j-li]+1\n                if dpo[j-li]+1<dpo[j]:\n                    dpo[j]=dpo[j-li]+1\n        else :\n            for j in range(li,10**6):\n                if dp[j-li]+1<dp[j]:\n                    dp[j]=dp[j-li]+1                \n\n    for x in inputlst:\n        print(\"{} {}\".format(dp[x],dpo[x]))\n\n    #print(time.time()-start)       \n\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "INF = 1000000\n\nwhile True:\n    n = input()\n    n = int(n)\n\n    if n == 0:\n        break\n\n    i = 1\n    tetra = []\n    while True:\n        t = i*(1+i)*(2+i)/6\n        if t <= n:\n            tetra.append(int(t))\n            i += 1\n        else:\n            break\n\n    dp1 = [INF for _ in range(n+1)]\n    dp2 = [INF for _ in range(n+1)]\n    dp1[0] = 0\n    dp2[0] = 0\n\n    for i in range(n):\n        for j in range(len(tetra)):\n            if i + tetra[j] <= n:\n                dp1[i+tetra[j]] = min(dp1[i+tetra[j]], dp1[i]+1)\n                if tetra[j] % 2 == 1:\n                    dp2[i+tetra[j]] = min(dp2[i+tetra[j]], dp2[i]+1)\n    \n    print(\"%d %d\" % (dp1[n], dp2[n]))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom bisect import bisect_left, bisect\n\ndef solve():\n    i = 1\n    P = []\n    x = 1\n    M = 10**6\n    while x < M:\n        P.append(x)\n        i += 1\n        x = (i)*(i+1)*(i+2)//6\n    \n    P = P[1:]\n    Q = [p for p in P if p%2]\n    DP1 = list(range(M+1))\n    DP2 = list(range(M+1))\n    \n    for i in range(M):\n        for p in P[:bisect(P, M-i)]:\n            DP1[i+p] = min(DP1[i+p], DP1[i]+1)\n        for q in Q[:bisect(Q, M-i)]:\n            DP2[i+q] = min(DP2[i+q], DP2[i]+1)\n    \n    N = int(input())\n    \n    while N:\n        print(\"{} {}\".format(DP1[N], DP2[N]))\n        N = int(input())\n    \nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**9)\nINF=10**18\nMOD=10**9+7\ninput=lambda: sys.stdin.readline().rstrip()\nYesNo=lambda b: print('Yes' if b else 'No')\nYESNO=lambda b: print('YES' if b else 'NO')\n\ndef main():\n    Q=[]\n    while True:\n        N=int(input())\n        if N==0:\n            break\n        Q.append(N)\n    MAX_Q=max(Q)\n    A=tuple((i+1)*(i+2)*(i+3)//6 for i in range(182))\n    A_odd=tuple(i for i in A if i%2)\n    A_even=tuple(i for i in A if i%2==0)\n    dp=[INF]*(MAX_Q+1)\n    dp[0]=0\n    for x in A_odd:\n        for k in range(x,MAX_Q+1):\n            if dp[k]>dp[k-x]+1:\n                dp[k]=dp[k-x]+1\n    ans=[]\n    for q in Q:\n        ans.append(dp[q])\n        \n    for x in A_even:\n        for k in range(x,MAX_Q+1):\n            dp[k]=min(dp[k],dp[k-x]+1)\n    for i,q in enumerate(Q):\n        print(dp[q],ans[i])\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    n = min(p_*7,N+1)\n    for j in range(p_,n):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\n#print('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    m = 10**6\n\n    a = [inf] * m\n    b = [inf] * m\n    a[0] = 0\n    b[0] = 0\n    for i in range(1,200):\n        t = i * (i+1) * (i+2) // 6\n        mm = min(t*5,m)\n        for j in range(t,mm):\n            if a[j] > a[j-t] + 1:\n                a[j] = a[j-t] + 1\n        if t % 2 == 0:\n            continue\n        for j in range(t,m):\n            if b[j] > b[j-t] + 1:\n                b[j] = b[j-t] + 1\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.append('{} {}'.format(a[n],b[n]))\n\n\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\nsq = [i for i in range(200)]\nfor i in range(199):\n    sq[i + 1] += sq[i]\nfor i in range(199):\n    sq[i + 1] += sq[i]\nss = []\nfor s in sq:\n    if s % 2:\n        ss.append(s)\n\ndp = defaultdict(lambda: False)\ncheck = defaultdict(lambda: False)\nfor s in sq:\n    dp[s] = True\n    check[s] = True\ndps = defaultdict(lambda: False)\nchecks = defaultdict(lambda: False)\nfor s in ss:\n    dps[s] = True\n    checks[s] = True\n\ndef main(n, ss, check, dp):\n    q = deque()\n    q.append((n, 1))\n    check[n] = True\n    if dp[n]:\n        return 1\n    while q:\n        a, i = q.pop()\n        for s in ss:\n            aa = a - s\n            if aa <= 0:\n                break\n            if not check[aa]:\n                check[aa] = True\n                q.appendleft((aa, i + 1))\n            else:\n                if dp[aa]:\n                    return i + 1\n\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    check = defaultdict(lambda: False)\n    for s in sq:\n        check[s] = True\n    checks = defaultdict(lambda: False)\n    for s in ss:\n        checks[s] = True\n    print(main(n, sq, check, dp), main(n, ss, checks,dps))\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Here your code !\n\nn = []\nn.append(int(input()))\nwhile min(n):\n    n.append(int(input()))\n#triangle = [0]\npyramid = [0]\npyramid_kisu = []\nm = 0\nmemo = []\nmemo_kisu = []\n\nwhile pyramid[m] < max(n):\n    m += 1\n#    triangle.append(m+triangle[m-1])\n#    pyramid.append(triangle[m]+pyramid[m-1])\n    pyramid.append(int((m*(m+1)*(m+2))/6))\n\nfor i in pyramid:\n    if i % 2 == 1:\n        pyramid_kisu.append(i)\n\nfor i in range(len(pyramid_kisu)):\n    memo_kisu.append([0,[pyramid_kisu[i]]])\n\nfor i in range(m+1):\n    memo.append([[0],[],[],[],[],[]])\n    memo[i][1].append(pyramid[i])\n\nfor j in range(2,6):\n    for i in range(1,m):\n            for k in range(1,i+1):\n                for l in memo[k][j-1]:\n                    memo[i][j].append(pyramid[i]+l)\n\nkisu_len=[0]\nfor question in n:\n    flag = 0\n    if question == 0:\n        break\n    else:\n        for j in range(1,6):\n            for i in reversed(range(1,len(memo))):\n                if question in memo[i][j]:\n                    ans=j\n                    flag = 1\n                    break\n            if flag == 1:\n                break\n        \n        flag = 0\n        count = 1\n        while 1:\n            for i in range(len(memo_kisu)):\n                if question in memo_kisu[i][count]:\n                    ans_kisu = count\n                    kisu_len.append(ans_kisu)\n                    flag = 1\n                elif count >= max(kisu_len):\n                    memo_kisu[i].append([])\n                    for k in range(i+1):\n                        for l in memo_kisu[k][count]:\n                            memo_kisu[i][count+1].append(pyramid_kisu[i]+l)\n            if flag == 1:\n                break\n            count += 1    \n    print(ans,ans_kisu)\n#print(kisu_len,memo_kisu[2][max(kisu_len)-1])"
  },
  {
    "language": "Python",
    "code": "def main():\n  INIT = 100\n  \n  query = []\n  ans = []\n  while True:\n    q = int(input())\n    if q == 0:\n      break\n    query.append(q)\n  MAX = max(query)\n  \n  table = [INIT] * (MAX + 1)\n  table[0] = 0\n  all_item = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n  odd_item = [i for i in all_item if i % 2]\n  eve_item = [i for i in all_item if not i % 2]\n  \n  for v in odd_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for q in query:\n    ans.append(table[q])\n  \n  for v in eve_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for i, q in enumerate(query):\n    print(table[q], ans[i])\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = list(range(1000000))\n    odd_rec = rec.copy()\n    \n    for i in range(2, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        if t % 2 == 0:\n            for i, tpl in enumerate(zip(rec[t:], rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n        else:\n            z_rec = zip(rec[t:], rec, odd_rec[t:], odd_rec)\n            for i, tpl in enumerate(z_rec, start=t):\n                a, b, c, d = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n                d += 1\n                if d < c:\n                    odd_rec[i] = d\n    \n    import sys\n    #file_input = sys.stdin\n    file_input = open(\"1167_in\", 'r')#\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    All = [i*(i+1)*(i+2)//6 for i in range(1, 182)]\n    inf = 10**18\n    n = 10**6\n    dp = [inf]*(n+1)\n    dpo = [inf]*(n+1)\n    dp[0] = 0\n    dpo[0] = 0\n    for j in All:\n        lim = min(j*5, n)\n        for i in range(j, lim+1):\n            dp[i] = min(dp[i-j]+1, dp[i])\n        for i in range(j, n):\n            if j%2==1:\n                dpo[i] = min(dpo[i-j]+1, dpo[i])\n    \n    while 1:\n        q = int(input())\n        if q==0:\n            break\n        print(dp[q], dpo[q])\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = [1000000] * 1000000\n    rec[0] = 0\n    odd_rec = rec.copy()\n    \n    for i in range(1, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        for i, tpl in enumerate(zip(rec[t:t*3+1], rec), start=t):\n            a, b = tpl\n            b += 1\n            if b < a:\n                rec[i] = b\n        if t % 2:\n            for i, tpl in enumerate(zip(odd_rec[t:t*34+1], odd_rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    odd_rec[i] = b\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "MAX = 1000000\ntetra = []\ndp = [0] * (MAX+1)\ndpodd = [0] * (MAX+1)\n\nfor i in range(1,MAX+1):\n    dp[i] = i\n    dpodd[i] = i\n\n\ni = 0\nwhile True:\n    i += 1\n    t = i * (i+1) * (i+2) // 6\n    if t > MAX: break\n    tetra.append(t)\n\nfor p in tetra:\n    #print(p)\n    for i in range(0,MAX-p):\n        dp[i+p] = min(dp[i+p], dp[i]+1)\n        if p % 2 == 1:\n            dpodd[i+p] = min(dpodd[i+p], dpodd[i]+1)\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    print (dp[n],dpodd[n])"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom bisect import bisect_left, bisect\n\ndef solve():\n    i = 1\n    P = []\n    x = 1\n    M = 10**6\n    while x < M:\n        P.append(x)\n        i += 1\n        x = (i)*(i+1)*(i+2)//6\n    \n    P = P[1:]\n    Q = [p for p in P if p%2]\n    DP1 = list(range(M+1))\n    DP2 = list(range(M+1))\n    \n    for i in range(M):\n        for p in P[:bisect(P, M-i)]:\n            DP1[i+p] = min(DP1[i+p], DP1[i]+1)\n        for q in Q[:bisect(Q, M-i)]:\n            DP2[i+q] = min(DP2[i+q], DP2[i]+1)\n    \n    N = int(input())\n    \n    while N:\n        print(\"{} {}\".format(DP1[N], DP2[N]))\n        N = int(input())\n    \nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "MAX = 10**6 - 1\ninf = float(\"inf\")\ntetra_n = [i*(i+1)*(i+2)/6 for i in range(1,181)]\ntetra_sum = [inf for i in range(MAX+1)]\ntetra_sum_odd = [inf for i in range(MAX+1)]\ntetra_sum[0] = 0\ntetra_sum_odd[0] = 0\nfor tn in tetra_n:\n\tif tn % 2 == 0:\n\t\tfor i in range(tn,MAX+1):\t\n\t\t\tif tetra_sum[i-tn] + 1 < tetra_sum[i]:\n\t\t\t\ttetra_sum[i] = tetra_sum[i-tn] + 1\n\telse :\n\t\tfor i in range(tn,MAX+1):\n\t\t\tif tetra_sum[i-tn] + 1 < tetra_sum[i]:\n\t\t\t\ttetra_sum[i] = tetra_sum[i-tn] + 1\n\t\t\tif tetra_sum_odd[i-tn] + 1 < tetra_sum_odd[i]:\n\t\t\t\ttetra_sum_odd[i] = tetra_sum_odd[i-tn] + 1\nwhile 1:\n\tN = int(raw_input())\n\tif N == 0:\n\t\tbreak\n\tprint tetra_sum[N], tetra_sum_odd[N]"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/problems/1167\n\n\ndef porok(n):\n    return n * (n+1) * (n+2) // 6\n\n\ndef dp_1(n):\n    for j in poroks_odd:\n        for i in range(j, n+1):\n            tmp = dp[i-j] + 1\n            if dp[i-j] + 1 < dp[i]:\n                dp[i] = dp[i-j] + 1\n\n\ndef dp_2(n):\n    for j in poroks_even:\n        for i in range(j, n+1):\n            tmp = dp[i-j] + 1\n            if dp[i-j] + 1 < dp[i]:\n                dp[i] = dp[i-j] + 1\n\n\nif __name__ == \"__main__\":\n    query_list = []\n    ans_even = []\n    while(True):\n        n = int(input())\n        if n == 0:\n            break\n        query_list.append(n)\n\n    poroks = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n    poroks_odd = [\n        porok_number for porok_number in poroks if porok_number % 2 == 1]\n    poroks_even = [\n        porok_number for porok_number in poroks if porok_number % 2 == 0]\n    dp = [100] * (max(query_list)+1)\n    dp[0] = 0\n\n    dp_1(max(query_list))\n\n    for q in query_list:\n        ans_even.append(dp[q])\n\n    dp_2(max(query_list))\n\n    for i, q in enumerate(query_list):\n        print('{} {}'.format(dp[q], ans_even[i]))\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  INIT = 100\n  \n  query = []\n  ans = []\n  while True:\n    q = int(input())\n    if q == 0:\n      break\n    query.append(q)\n  MAX = max(query)\n  \n  table = [INIT] * (MAX + 1)\n  table[0] = 0\n  all_item = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n  odd_item = [i for i in all_item if i % 2]\n  eve_item = [i for i in all_item if not i % 2]\n  \n  for v in odd_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for q in query:\n    ans.append(table[q])\n  \n  for v in eve_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for i, q in enumerate(query):\n    print(table[q], ans[i])\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  INIT = 100\n  \n  query = []\n  ans = []\n  while True:\n    q = int(input())\n    if q == 0:\n      break\n    query.append(q)\n  MAX = max(query)\n  \n  table = [INIT] * (MAX + 1)\n  table[0] = 0\n  all_item = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n  odd_item = [i for i in all_item if i % 2]\n  eve_item = [i for i in all_item if not i % 2]\n  \n  for v in odd_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for q in query:\n    ans.append(table[q])\n  \n  for v in eve_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for i, q in enumerate(query):\n    print(table[q], ans[i])\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip() \n\ndef resolve():\n    tetrahedral_num = [i*(i+1)*(i+2)//6 for i in range(1, 201)]\n    tetrahedral_num_odd = [i for i in tetrahedral_num if i%2==1]\n    n = []\n    while True:\n        tmp = int(input())\n        if tmp==0:\n            break\n        else:\n            n.append(tmp)\n    max_n = max(n)\n\n    # dp[i]: 数iを構成する最小個数\n    dp = [float('inf')]*(max_n+1)\n    dp[0] = 0\n    for i in range(1, max_n+1):\n        tmp = []\n        for j in tetrahedral_num:\n            if i-j>=0:\n                tmp.append(dp[i-j])\n        dp[i] = min(tmp) + 1\n\n    dp_odd = [float('inf')]*(max_n+1)\n    dp_odd[0] = 0\n    for i in range(1, max_n+1):\n        tmp = []\n        for j in tetrahedral_num_odd:\n            if i-j>=0:\n                tmp.append(dp_odd[i-j])\n        dp_odd[i] = min(tmp) + 1\n\n    for i in n:\n        print(dp[i], dp_odd[i])\n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\nprint('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    n = min(p_*5,10**6)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    for j in range(p_,N +1):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\nprint('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    target = int(input())\n    if target == 0:\n        break\n    pascal = []\n    tmp = 1\n    nexpas = 1\n    oddpas = []\n    while target >= nexpas:\n        pascal.append(nexpas)\n        if nexpas % 2 == 1:\n            oddpas.append(nexpas)\n        tmp += 1\n        nexpas = (tmp * (tmp + 1) * (tmp + 2)) // 6\n    length = len(pascal)\n    dp = [[float(\"inf\") for n in range(length)] for m in range(6)]\n    ans = - 1\n    for outer in range(6):\n        if ans != -1:\n            break\n        for inner in range(length):\n            if outer == 0:\n                initial = target - pascal[inner]\n                dp[outer][inner] = target - pascal[inner]\n                if initial == 0:\n                    ans = outer + 1\n                    break\n            else:\n                for i in range(length):\n                    nextval = dp[outer - 1][inner] - pascal[i]\n                    if nextval < 0:\n                        break\n                    elif nextval == 0:\n                        dp[outer][inner] = min(dp[outer][inner],nextval)\n                        ans = outer + 1\n                        break\n                    dp[outer][inner] = min(dp[outer][inner],nextval)\n    oddlen = len(oddpas)\n    odddp = [float(\"inf\") for n in range(oddlen)]\n    oddans = -1\n    for i in range(oddlen):\n        val = target - oddpas[i]\n        odddp[i] = val\n        if val == 0:\n            oddans = 1\n    cnt = 1\n    while True:\n        #print(odddp)\n        cnt += 1\n        tmpdp = odddp[:]\n        if oddans != -1:\n            break\n        for o in range(oddlen):\n            for i in range(oddlen):\n                nextval = odddp[o] - oddpas[i]\n                if nextval < 0:\n                    break\n                elif nextval == 0:\n                    oddans = cnt\n                    break\n                else:\n                     tmpdp[o] = min(odddp[0],nextval)\n        odddp = tmpdp\n    print(str(ans) + \" \" + str(oddans))\n    #print(odddp,oddpas,oddans,target)\n    #print(dp,pascal,ans,target)"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    #n = min(p_*5,N+1)\n    for j in range(p_,N):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\n#print('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "INIT = 100\n\nquery = []\nans = []\nwhile True:\n  q = int(input())\n  if q == 0:\n    break\n  query.append(q)\nMAX = max(query)\n\ntable = [INIT] * (MAX + 1)\ntable[0] = 0\nall_item = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\nodd_item = [i for i in all_item if i % 2]\neve_item = [i for i in all_item if not i % 2]\n\nfor v in odd_item:\n  for j in range(v, MAX + 1):\n    if table[j] > table[j - v] + 1:\n      table[j] = table[j - v] + 1\n\nfor q in query:\n  ans.append(table[q])\n\nfor v in eve_item:\n  for j in range(v, MAX + 1):\n    if table[j] > table[j - v] + 1:\n      table[j] = table[j - v] + 1\n\nfor i, q in enumerate(query):\n  print(table[q], ans[i])\n"
  },
  {
    "language": "Python",
    "code": "import itertools\n\nP1=[p*(p+1)*(p+2)/6 for p in range(1,181)]\nP2=[p for p in P1 if p%2]\n\nmaxnum=1000000\n\nA1=[5 for x in range(maxnum+1)]\nA2=[37 for x in range(maxnum+1)]\n\nfor X in [[P1,A1],[P2,A2]]:\n    P=X[0]\n    A=X[1]\n    mx=A[0]\n    tmp=P\n    bk=0\n    cnt=2\n    for p in tmp:\n        if p<maxnum:\n            A[p]=1\n            bk+=1\n    while cnt<mx:\n        tmp2=[]\n        for t in tmp:\n            for p in P:\n                if t+p > maxnum:    break\n                if A[t+p]>cnt:\n                    A[t+p]=cnt\n                    bk+=1\n                    tmp2.append(t+p)\n        tmp=tmp2[:]\n        cnt+=1\nwhile(1):\n    n=int(raw_input())\n    if n==0: break\n    print A1[n], A2[n]\n\n"
  },
  {
    "language": "Python",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n   //     Scanner sc = new Scanner(System.in);\n        int[] list1 = new int[180];\n        int[] cnt1 = new int[1000001];\n        int[] cnt2 = new int[1000001]; \n        for(int i = 0; i < 180; i++) {\n            list1[i] = (i+1)*(i+2)*(i+3)/6;\n        }\n        // Here your code !\n        for(int i = 0; i <= 1000000; i++){\n            cnt1[i] = i;\n            cnt2[i] = i;\n        }\n        \n        for(int n = 3, p = 4; p <= 1000000; n++){\n            for(int i = 0; i+p <= 1000000; i++){\n                cnt1[i+p] = Math.min(cnt1[i+p], cnt1[i] + 1);\n            }\n            if(p % 2 == 1){\n                for(int i = 0; i+p <= 1000000; i++){\n                    cnt2[i+p] = Math.min(cnt2[i+p], cnt2[i] + 1);\n                }\n            }\n            // p?????????????????§??´??°\n            p = n * (n+1) * (n+2) / 6;\n        }\n        \n        \n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        while(true){\n            int num = Integer.parseInt(br.readLine());\n            if(num == 0) break;\n            System.out.println(cnt1[num] + \" \" + cnt2[num]);\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Here your code !\n\nn = []\nn.append(int(input()))\nwhile min(n):\n    n.append(int(input()))\n#triangle = [0]\npyramid = [0]\npyramid_kisu = []\nm = 0\nmemo = []\nmemo_kisu = []\n\nwhile pyramid[m] < max(n):\n    m += 1\n#    triangle.append(m+triangle[m-1])\n#    pyramid.append(triangle[m]+pyramid[m-1])\n    pyramid.append(int((m*(m+1)*(m+2))/6))\n\nfor i in pyramid:\n    if i % 2 == 1:\n        pyramid_kisu.append(i)\n\nfor i in range(len(pyramid_kisu)):\n    memo_kisu.append([0,[pyramid_kisu[i]]])\n\nfor i in range(m+1):\n    memo.append([[0],[],[],[],[],[]])\n    memo[i][1].append(pyramid[i])\n\nfor j in range(2,6):\n    for i in range(1,m):\n            for k in range(1,i+1):\n                for l in memo[k][j-1]:\n                    memo[i][j].append(pyramid[i]+l)\n\nkisu_len=[1]\nfor question in n:\n    flag = 0\n    if question == 0:\n        break\n    else:\n        for j in range(1,6):\n            for i in reversed(range(1,len(memo))):\n                if question in memo[i][j]:\n                    ans=j\n                    flag = 1\n                    break\n            if flag == 1:\n                break\n        \n        flag = 0\n        count = 1\n        while 1:\n            for i in range(len(memo_kisu)):\n                if question in memo_kisu[i][count]:\n                    ans_kisu = count\n                    kisu_len.append(ans_kisu)\n                    flag = 1\n               # if count >= max(kisu_len):\n                if count >= len(memo_kisu[2])-1:\n                  #  print(count,len(memo_kisu[2]))\n                    memo_kisu[i].append([])\n                    for k in range(i+1):\n                        for l in memo_kisu[k][count]:\n                            memo_kisu[i][count+1].append(pyramid_kisu[i]+l)\n                 \n            if flag == 1:\n                break\n            count += 1               \n    print(ans,ans_kisu)\n#print(kisu_len,memo_kisu[2][max(kisu_len)-1])\n#print(kisu_len,memo_kisu)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    f = [i*(i+1)*(i+2)//6 for i in range(1,181)]\n    n = 10**6-1\n    dp = [i for i in range(n+1)]\n    dp_odd = [i for i in range(n+1)]\n    for i in range(n):\n        for j in f:\n            ni = i+j\n            if ni <= n:\n                nd = dp[i]+1\n                if nd < dp[ni]:\n                    dp[ni] = nd\n                if j&1:\n                    nd = dp_odd[i]+1\n                    if nd < dp_odd[ni]:\n                        dp_odd[ni] = nd\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        print(dp[n],dp_odd[n])\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1167 - ポロック予想\n# 配るDP でいってみよ～\n\nimport sys\n\n\ndef main():\n    tetra_nums = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n    N = 10 ** 6\n\n    dp = [i for i in range(N)]\n    dp_odd = [i for i in range(N)]\n\n    for n in range(N):\n        for tetra_num in tetra_nums:\n            next_n = n + tetra_num\n\n            if next_n < N:\n                next_dp = dp[n] + 1\n                if next_dp < dp[next_n]:\n                    dp[next_n] = next_dp\n\n                if tetra_num & 1:\n                    next_dp = dp_odd[n] + 1\n                    if next_dp < dp_odd[next_n]:\n                        dp_odd[next_n] = next_dp\n\n    while True:\n        num = int(sys.stdin.readline())\n        if num == 0:\n            break\n        print(dp[num], dp_odd[num])\n\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\nimport sys\nMAX = 10**6\nsys.setrecursionlimit(MAX)\narr1 = [1]\narr2 = [1]\nn = 1\nwhile True:\n    n += 1\n    tmp = n*(n+1)*(n+2)//6\n    if tmp > MAX: break\n    arr1.append(tmp)\n    if tmp%2:\n        arr2.append(tmp)\n\ndef rec(remain, depth, mindepth, onlyodd):\n    if remain == 0: return depth\n    if mindepth - depth <= 1: return mindepth\n    arr = arr2 if onlyodd else arr1\n    i = bisect.bisect_right(arr,remain)\n    if i == 1:\n        return min(mindepth, depth + remain)\n    for j in range(1,i):\n        mindepth = rec(remain-arr[j], depth+1, mindepth, onlyodd)\n    return mindepth\n\ndef solve(n, onlyodd=False):\n    return rec(n,0,n,onlyodd)\n\nwhile True:\n    N = int(input())\n    if N == 0: break\n    print('{0} {1}'.format(solve(N), solve(N,True)))\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = [1000000] * 1000000\n    rec[0] = 0\n    odd_rec = rec.copy()\n    \n    tetra_num = [i * (i + 1) * (i + 2) // 6 for i in range(1, 183)]\n    for t1, t2 in zip(tetra_num, tetra_num[2:]):\n        for i, tpl in enumerate(zip(rec[t1:t2], rec), start=t1):\n            a, b = tpl\n            b += 1\n            if b < a:\n                rec[i] = b\n    \n    odd_tetra_num = [t for t in tetra_num if t % 2 == 1]\n    for t1, t2 in zip(odd_tetra_num, odd_tetra_num[2:]):\n        for i, tpl in enumerate(zip(odd_rec[t1:t2], odd_rec), start=t1):\n            a, b = tpl\n            b += 1\n            if b < a:\n                odd_rec[i] = b\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Here your code !\n\nn = []\nn.append(int(input()))\nwhile min(n):\n    n.append(int(input()))\ntriangle = [0]\npyramid = [0]\npyramid_kisu = []\nm = 0\nmemo = []\nmemo_kisu = []\n\nwhile pyramid[m] < max(n):\n    m += 1\n    triangle.append(m+triangle[m-1])\n    pyramid.append(triangle[m]+pyramid[m-1])\n\nfor i in pyramid:\n    if i % 2 == 1:\n        pyramid_kisu.append(i)\n\nfor i in range(len(pyramid_kisu)):\n    memo_kisu.append([0,[pyramid_kisu[i]]])\n\n\n\n\nfor i in range(m+1):\n    memo.append([[0],[],[],[],[],[]])\n    memo[i][1].append(pyramid[i])\n\nfor j in range(2,6):\n    for i in range(1,m):\n            for k in range(1,i+1):\n                for l in memo[k][j-1]:\n                    memo[i][j].append(pyramid[i]+l)\n\nfor question in n:\n    flag = 0\n    if question == 0:\n        break\n    else:\n        for j in range(1,6):\n            for i in reversed(range(1,len(memo))):\n                if question in memo[i][j]:\n                    ans=j\n                    flag = 1\n                    break\n            if flag == 1:\n                break\n        \n        flag = 0\n        count = 1\n        while 1:\n            for i in range(len(memo_kisu)):\n                if question in memo_kisu[i][count]:\n                    ans_kisu = count\n                    flag = 1\n                else:\n                    memo_kisu[i].append([])\n                    for k in range(i+1):\n                        for l in memo_kisu[k][count]:\n                            memo_kisu[i][count+1].append(pyramid_kisu[i]+l)\n            if flag == 1:\n                break\n            count += 1    \n    print(ans,ans_kisu)"
  },
  {
    "language": "Python",
    "code": "import copy\n\nitem = [i *(i +1) * (i+2) //6 for i in range(1,181)]\nq = []\nwhile True:\n    in_ = int(input())\n    if in_ == 0:\n        break\n    q.append(in_)\n\nINIT = 1000\nMAX = max(q) +10\nans = [INIT] *MAX\nans[0] = 0\nodd_item = [i for i in item if i % 2 ==0 ]\neven_item = [i for i in item if not(i % 2 == 0)]\n\nfor i in even_item:\n    for j in range(0,MAX-i):\n        if ans[j+i] > ans[j] + 1:\n            ans[j+i] = ans[j] + 1\n\nans_ = copy.deepcopy(ans)\n\nfor i in odd_item:\n    for j in range(0,MAX-i):\n        if ans[j+i] > ans[j] + 1:\n            ans[j+i] = ans[j]+1\nfor i in q:\n    print(ans[i],ans_[i])\n"
  },
  {
    "language": "Python",
    "code": "def main():\n  INIT = 100\n  \n  query = []\n  ans = []\n  while True:\n    q = int(input())\n    if q == 0:\n      break\n    query.append(q)\n  MAX = max(query)\n  \n  table = [INIT] * (MAX + 1)\n  table[0] = 0\n  all_item = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n  odd_item = [i for i in all_item if i % 2]\n  eve_item = [i for i in all_item if not i % 2]\n  \n  for v in odd_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for q in query:\n    ans.append(table[q])\n  \n  for v in eve_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if tjv < 5 and table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for i, q in enumerate(query):\n    print(table[q], ans[i])\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom bisect import bisect_left, bisect\n\ndef solve():\n    ans = []\n    i = 1\n    P = []\n    x = 1\n    M = 10**6\n    while x < M:\n        P.append(x)\n        i += 1\n        x = (i)*(i+1)*(i+2)//6\n    \n    P = P[1:]\n    Q = [p for p in P if p%2]\n    DP1 = list(range(M+1))\n    DP2 = list(range(M+1))\n    \n    for i in range(M):\n        for p in P[:bisect(P, M-i)]:\n            DP1[i+p] = min(DP1[i+p], DP1[i]+1)\n        for q in Q[:bisect(Q, M-i)]:\n            DP2[i+q] = min(DP2[i+q], DP2[i]+1)\n    \n    N = int(input())\n    \n    while N:\n        ans.append(\"{} {}\".format(DP1[N], DP2[N]))\n        N = int(input())\n    print(\"\\n\".join(ans))\n\nif __name__ == \"__main__\":\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport collections\n\ndef reg_tetra(n):\n    return n * (n + 1) * (n + 2) // 6\n\n\ndef make_reg_tetra(m):\n    i, ans, flag = 1, [], reg_tetra(1)    \n    while m >= flag:\n        i += 1\n        ans.append(flag)\n        flag = reg_tetra(i)\n    return ans\n\n\ndef make_reg_tetra_odd(m):\n    return list(filter(lambda x: x % 2 != 0, make_reg_tetra(m)))\n\n\ndef rec_number(n, iter):\n    if dp[n][len(iter)] is not None:\n        return dp[n][len(iter)]\n    # ???????????¶\n    elif n < 0:\n        return 9999\n    elif n == 0:\n        return 0\n    # ?¶??¶??????¶\n    elif len(iter) == 1:\n        dp[n][len(iter)] = rec_number(n - 1, [1]) + 1\n    else:\n        dp[n][len(iter)] = min(rec_number(n - iter[-1], iter) + 1, rec_number(n, iter[:-1]))\n\n    return dp[n][len(iter)]\n\n# f = open(\"input.txt\", \"r\") ## debug\narr = []\nwhile True:\n    n = int(input())\n    # n = int(f.readline()) ## debug\n    if n == 0:\n        break\n    arr.append(n)\n\nfor n in arr:\n    arr_tetra, arr_tetra_odd = make_reg_tetra(n), make_reg_tetra_odd(n)\n    dp = [[None]*(n+1) for j in range(n+1)]\n    a = rec_number(n, arr_tetra)\n    dp = [[None]*(n+1) for j in range(n+1)]\n    b = rec_number(n, arr_tetra_odd)\n    print(a, b)"
  },
  {
    "language": "Python",
    "code": "MAX = 10**6 - 1\ninf = float(\"inf\")\ntetra_n = [i*(i+1)*(i+2)/6 for i in range(1,181)]\ntetra_sum = [inf for i in range(MAX+1)]\ntetra_sum_odd = [inf for i in range(MAX+1)]\ntetra_sum[0] = 0\ntetra_sum_odd[0] = 0\ntmp_max = 0\nfor tn in tetra_n:\n\ttmp_max = max(tmp_max + 4 * tn, 5 * tn)\n\tif (tn % 2) == 0:\n\t\tfor i in range(tn,min(tmp_max,MAX)+1):\t\n\t\t\tif tetra_sum[i-tn] + 1 < tetra_sum[i]:\n\t\t\t\ttetra_sum[i] = tetra_sum[i-tn] + 1\n\telse:\n\t\tfor i in range(tn,MAX+1):\t\n\t\t\tif i <= tmp_max and tetra_sum[i-tn] + 1 < tetra_sum[i]:\n\t\t\t\ttetra_sum[i] = tetra_sum[i-tn] + 1\n\t\t\tif tetra_sum_odd[i-tn] + 1 < tetra_sum_odd[i]:\n\t\t\t\ttetra_sum_odd[i] = tetra_sum_odd[i-tn] + 1\nwhile 1:\n\tN = int(raw_input())\n\tif N == 0:\n\t\tbreak\n\tprint tetra_sum[N], tetra_sum_odd[N]"
  },
  {
    "language": "Python",
    "code": "MAX=1000000\nINF=100000\nimport math\n\ndef f(a):\n\treturn (a*(a+1)*(a+2))/6\n\n\n\ndef solve(lst):\n\tglobal ans\n\tglobal n\n\tcount=2\n\twhile True:\n\n\t\t\n\t\tif ans[n]!=INF:\n\t\t\treturn ans[n]\n\n\t\tkeepans=[0]*(n+1)\n\t\t\n\t\tfor i in range(n+1):\n\t\t\tif ans[i]!=INF:\n\t\t\t\tfor j in range(n+1):\n\t\t\t\t\tif i+j<=n:\n\t\t\t\t\t\tif ans[j]!=INF and ans[i+j]>ans[i]+ans[j]:\n\t\t\t\t\t\t\tkeepans[i+j]=ans[i]+ans[j]\n\t\t\t\t\t\t\t#print i,j,\"=\",keepans[i+j]\n\t\t\n\t\tc=0\n\t\tfor l in ans:\n\t\t\tif keepans[c]!=0:\n\t\t\t\tans[c]=keepans[c]\n\t\t\tc=c+1\n\t\t#print \"----------\"\n\t\tcount=count+1\n\n\n\n\n\nwhile True:\n\tn=int(raw_input())\n\tif n==0:\n\t\tbreak\n\n\tbox=[]\n\toddbox=[]\n\tans=[INF]*(n+1)\n\toddans=[INF]*(n+1)\n\n\n\n\n\tfor i in range(200):\n\t\tnum=f(i)\n\t\tif num>n: break\n\n\t\tbox.append(num)\n\t\tif i!=0:ans[num]=1\n\t\tif num%2==1:\n\t\t\toddbox.append(num)\n\t\t\toddans[num]=1\n\n\t\n\tprint solve(box)\n\tans=oddans\n\tprint solve(oddbox)"
  },
  {
    "language": "Python",
    "code": "dp = [0] + [10 ** 10] * 10**6\nodd = [0] + [10 ** 10] * 10**6\nfor i in range(1, 10**6 + 1):\n    a = i * (i + 1) * (i + 2) // 6\n    if a > 10**6: break\n    for j in range(a, 10**6 + 1):\n        dp[j] = min(dp[j], dp[j - a] + 1)\n        if a & 1: odd[j] = min(odd[j], odd[j - a] + 1)\nwhile 1:\n    n=int(input())\n    if n==0:break\n    print(dp[n],odd[n])"
  },
  {
    "language": "Python",
    "code": "def main():\n  INIT = 100\n  \n  query = []\n  ans = []\n  while True:\n    q = int(input())\n    if q == 0:\n      break\n    query.append(q)\n  MAX = max(query)\n  \n  table = [INIT] * (MAX + 1)\n  table[0] = 0\n  all_item = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n  odd_item = [i for i in all_item if i % 2]\n  eve_item = [i for i in all_item if not i % 2]\n  \n  for v in odd_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for q in query:\n    ans.append(table[q])\n  \n  for v in eve_item:\n    for j in range(v, MAX + 1):\n      tjv = table[j - v]\n      if table[j] > tjv + 1:\n        table[j] = tjv + 1\n  \n  for i, q in enumerate(query):\n    print(table[q], ans[i])\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\ntetrahedral = [i*(i+1)*(i+2)//6 for i in range(1,185)]\noddtetrahedral = [i*(i+1)*(i+2)//6 for i in range(1,185,4)]\nINF = float(\"inf\")\nprint(oddtetrahedral)\"\"\"\ndp = [1e6+1]*(int(1e6)+1)\ndpodd = [1e6+1]*(int(1e6)+1)\n\ndp[0] = dpodd[0] = 0\n\nfor i in range(1, 181):\n    num = i*(i+1)*(i+2)//6\n    for j, tpl in enumerate(zip(dp[num:num*3+1], dp), start=num):\n        a, b = tpl\n        if (b+1 < a):\n            dp[j] = b+1\n    if (num&1):\n        for j, tpl in enumerate(zip(dpodd[num:num*34+1], dpodd), start=num):\n            a, b = tpl\n            if (b+1 < a):\n                dpodd[j] = b+1\n\n\n\"\"\"\nfor i in range(int(1e6)):\n    num = i*(i+1)*(i+2)//6\n    if (num>=1e6):\n        break\n    for j in range(num, int(1e6)):\n        dp[j] = min(dp[j], dp[j-num]+1)\n        if (num&1):\n            dpodd[j] = min(dpodd[j], dpodd[j-num]+1)\n\n\ndp = [INF]*int(1e6+1)\ndpodd = [INF]*int(1e6+1)\n\nfor a in tetrahedral:\n    if (a > int(1e6)):\n        break\n    dp[a] = 1\nfor b in oddtetrahedral:\n    if (b > int(1e6)):\n        break\n    dpodd[b] = 1\n\nfor i in range(int(1e6)+1):\n    for a in tetrahedral:\n        if (i+a <= int(1e6)):\n            dp[i+a] = min(dp[i+a], dp[i]+1)\n    for b in oddtetrahedral:\n        if (i+b <= int(1e6)):\n            dpodd[i+b] = min(dpodd[i+b], dpodd[i]+1)\n\"\"\"\n\ndef solve(N):\n    return (dp[N], dpodd[N])\n\n\"\"\"\n    dp = [INF]*(N+1)\n    dpodd = [INF]*(N+1)\n    for a in tetrahedral:\n        if (a > N):\n            break\n        dp[a] = 1\n    for b in oddtetrahedral:\n        if (b > N):\n            break\n        dpodd[b] = 1\n\n    def reca(n):\n        if (n < 0):\n            return INF\n        if (dp[n] != INF):\n            return dp[n]\n        dp[n] = min([reca(n-a)+1 for a in tetrahedral if (n-a>=0)])\n        return dp[n]\n\n    def recb(n):\n        if (n < 0):\n            return INF\n        if (dpodd[n] != INF):\n            return dpodd[n]\n        dpodd[n] = min([recb(n-b)+1 for b in oddtetrahedral])\n        return dpodd[n]\n\n    ret1 = reca(N)\n    ret2 = recb(N)\n    return (ret1, ret2)\n\"\"\"\n\ndef main():\n    ans = []\n    while True:\n        N = int(input())\n        if (N == 0):\n            break\n        ans.append(solve(N))\n\n    for i in ans:\n        print(*i)\n\nmain()\n\n\n\"\"\"\n    for i in range(N+1):\n        for a in tetrahedral:\n            if (i+a <= N):\n                dp[i+a] = min(dp[i+a], dp[i]+1)\n        for b in oddtetrahedral:\n            if (i+b <= N):\n                dpodd[i+b] = min(dpodd[i+b], dpodd[i]+1)\n    return (dp[N], dpodd[N])\n\"\"\"\n"
  },
  {
    "language": "Python",
    "code": "R = 10**6+1\nT = [i*(i+1)*(i+2)/6 for i in xrange(145)]\ndp1 = [1e10]*R\ndp2 = [1e10]*R\ndp1[0] = dp2[0] = 0\nfor t in T:\n    dp1[t] = 1\n    for i in xrange(t,R):\n        if dp1[i-t] < 1e10: dp1[i] = min(dp1[i],dp1[i-t]+1)\n    if t%2 == 0: continue\n    dp2[t] = 1\n    for i in xrange(t,R):\n        if dp2[i-t] < 1e10: dp2[i] = min(dp2[i],dp2[i-t]+1)\n\nwhile 1:\n    n = int(raw_input())\n    if n == 0: break\n    print dp1[n],dp2[n]"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = list(range(1000000))\n    odd_rec = rec.copy()\n    \n    for i in range(2, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        if t % 2 == 0:\n            for i, tpl in enumerate(zip(rec[t:], rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n        else:\n            z_rec = zip(rec[t:], rec, odd_rec[t:], odd_rec)\n            for i, tpl in enumerate(z_rec, start=t):\n                a, b, c, d = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n                d += 1\n                if d < c:\n                    odd_rec[i] = d\n    \n    import sys\n    file_input = sys.stdin\n    n = int(file_input.readline())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(file_input.readline())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from itertools import takewhile,count\nfrom time import perf_counter as timer\n\nM = 10**6\nnums = tuple(takewhile(lambda x: x < M, (m*(m+1)*(m+2)//6 for m in count(1))))\nodds = tuple(v for v in nums if v % 2)\n\ndp0 = [(M,M)]*M\ndp0[0] = (0,0)\nfor v,(c,i0) in enumerate(dp0):\n    c += 1\n    for i,n in enumerate(nums[-i0:],start=-i0):\n        x = v+n\n        if x >= M:\n            break\n        dp0[x] = min((c,-i),dp0[x])\n\ndp1 = [(M,M)]*M\ndp1[0] = (0,0)\nfor v,(c,i0) in enumerate(dp1):\n    c += 1\n    for i,n in enumerate(odds[-i0:],start=-i0):\n        x = v+n\n        if x >= M:\n            break\n        dp1[x] = min((c,-i),dp1[x])\n\n\nx = int(input())\nwhile x != 0:\n    print(dp0[x][0],dp1[x][0])\n    x = int(input())\n"
  },
  {
    "language": "Python",
    "code": "def pollockConjection():\n    inf=int(1e6)\n    dp=list(range(0,inf+1))\n    odp=list(range(0,inf+1))\n    n=2\n    s=1\n    os=1\n    while s<inf+1:\n        s=n*(n+1)*(n+2)//6\n        n+=1\n        if s%2==1:\n            os=s\n        for i in range(0,inf+1-s):\n            dp[i+s]=min(dp[i+s],dp[i]+1)\n        for i in range(0,inf+1-os):\n            odp[i+os]=min(odp[i+os],odp[i]+1)\n    return dp,odp\n\nif __name__==\"__main__\":\n    dp,odp=pollockConjection()\n    while True:\n        N=int(input())\n        if N==0:\n            break\n        print(dp[N],odp[N])\n"
  },
  {
    "language": "Python",
    "code": "MAX=1000000\nINF=100000\nimport math\n\ndef f(a):\n\treturn (a*(a+1)*(a+2))/6\n\n\n\ndef solve(lst):\n\tglobal ans\n\tglobal n\n\t\n\twhile True:\n\n\t\tkeepans=list(ans)\n\n\t\t\n\t\tfor i in range(n+1):\n\t\t\tif ans[i]!=INF:\n\t\t\t\tfor j in range(n+1):\n\t\t\t\t\tif ans[n]!=INF: return ans[n]\n\t\t\t\t\tif i+j<=n:\n\t\t\t\t\t\tif ans[j]!=INF and keepans[i+j]>ans[i]+ans[j] :\n\t\t\t\t\t\t\tkeepans[i+j]=ans[i]+ans[j]\n\t\t\t\t\t\t\tprint i,j,\"=\",keepans[i+j]\n\t\t\n\t\tans=list(keepans)\n\n\n\na1=[INF]*(MAX)\na2=[INF]*(MAX)\nans=[INF]*(MAX)\n\nwhile True:\n\tn=int(raw_input())\n\tif n==0:\n\t\tbreak\n\n\tbox=[]\n\toddbox=[]\n\t\n\n\n\tfor i in range(200):\n\t\tnum=f(i)\n\t\tif num>n: break\n\n\t\tbox.append(num)\n\t\tif i!=0:a1[num]=1\n\t\tif num%2==1:\n\t\t\toddbox.append(num)\n\t\t\ta2[num]=1\n\n\tans=list(a1)\n\tprint solve(box)\n\ta1=list(ans)\n\tans=list(a2)\n\tprint solve(oddbox)\n\ta2=list(ans)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = list(range(1000000))\n    odd_rec = rec.copy()\n     \n    for i in range(2, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        if t % 2 == 0:\n            for i, tpl in enumerate(zip(rec[t:], rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n        else:\n            z_rec = zip(rec[t:], rec, odd_rec[t:], odd_rec)\n            for i, tpl in enumerate(z_rec, start=t):\n                a, b, c, d = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n                d += 1\n                if d < c:\n                    odd_rec[i] = d\n     \n    n = int(input())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(input())\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "MAX = 1000010\ntetra = []\ndp = [0] * (MAX+1)\ndpodd = [0] * (MAX+1)\n\nfor i in range(1,MAX+1):\n    dp[i] = i\n    dpodd[i] = i\n\n\ni = 0\nwhile True:\n    i += 1\n    t = i * (i+1) * (i+2) // 6\n    if t > MAX: break\n    tetra.append(t)\n\nfor p in tetra:\n    #print(p)\n    for i in range(0,MAX-p):\n        dp[i+p] = min(dp[i+p], dp[i]+1)\n        if p % 2 == 1:\n            dpodd[i+p] = min(dpodd[i+p], dpodd[i]+1)\n\nwhile True:\n    n = int(raw_input())\n    if n == 0: break\n    print (dp[n],dpodd[n])"
  },
  {
    "language": "Python",
    "code": "n=1000001   \ni=1\np=[]\npo=[]\nnn=1\nwhile nn<n:\n    p.append(nn)\n    if nn%2==1:\n        po.append(nn)\n    i+=1\n    nn= i*(i+1)*(i+2)//6\nnp=len(p)\nnpo=len(po)\n\npp=[]\ndef dpf(nn,pp,nnp):\n    dpm=[i for i in range(nn+1)]\n    for ppi in pp[1:nnp]:\n        if ppi>nn:\n            break\n        for j in range(ppi,nn+1):\n            dpij=1+dpm[j-ppi]\n            if j>=ppi and dpm[j]>dpij:\n                dpm[j]=dpij\n#        print(\"i\",i,\"dpm:\",dpm)\n    return dpm\n\nnlist=[]\nwhile True:\n    n=int(input())\n    if n==0:\n        break\n    else:\n        nlist.append(n)\n\nnmax=max(nlist)\ndpm1=dpf(nmax,p,np)\ndpm2=dpf(nmax,po,npo)\n\nfor i in nlist:\n    print(dpm1[i],dpm2[i])\n        \n\n"
  },
  {
    "language": "Python",
    "code": "INF = 10**20\nMAX_INT = 10**6\na = [INF] * MAX_INT\nb = [INF] * MAX_INT\na[0],b[0] = 0,0\nfor i in range(1, 200):\n  t = i*(i+1)*(i+2)//6\n  mm = min(t*5, MAX_INT)\n  for j in range(t, mm):\n    if a[j] > a[j-t]+1:\n      a[j] = a[j-t]+1\n\n  if t%2==0: continue\n\n  for j in range(t, MAX_INT):\n    if b[j] > b[j-t]+1:\n      b[j] = b[j-t]+1\n\nwhile True:\n  N = int(input())\n  if N==0: exit()\n  print(a[N], b[N])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport copy\n\n\ndef solve():\n    n = 10**6\n    INF = 10**3\n    dp = [INF] * (n + 1)\n    dp[0] = 0\n    dp_odd = copy.deepcopy(dp)\n\n    for i in range(n):\n        for x in arr:\n            if i + x > n:\n                break\n            if dp[i + x] > dp[i] + 1:\n                dp[i + x] = dp[i] + 1\n            if x % 2:\n                if dp_odd[i + x] > dp_odd[i] + 1:\n                    dp_odd[i + x] = dp_odd[i] + 1\n\n    return dp, dp_odd\n\n\narr = [1]\n\nfor i in range(1, 180):\n    arr.append(arr[-1] * (i + 3) // i)\n\na, b = solve()\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        sys.exit()\n    print(a[n], b[n])\n"
  },
  {
    "language": "Python",
    "code": "print(\"\")\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n=int(input())\n    if n==0:break\n    dp=[0]+[10**10]*n\n    odd=[0]+[10**10]*n\n    for i in range(1,n+1):\n        a=i*(i+1)*(i+2)//6\n        if a>n:break\n        for j in range(a,n+1):\n            dp[j]=min(dp[j],dp[j-a]+1)\n            if a&1:odd[j]=min(odd[j],odd[j-a]+1)\n    print(dp[n],odd[n])"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    n = min(p_*5,10**6)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    n = min(p*5,N)\n    for j in range(p_,n):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\nprint('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "N=10**6\ndp = [i for i in range(N+1)]\nodd = [i for i in range(N+1)]\np=4;n=3\nwhile p<=N:\n    for i in range(N+1-p):\n        dp[i+p]=min(dp[i+p],dp[i]+1)\n        if p&1:odd[i+p]=min(odd[i+p],odd[i]+1)\n    p=n*(n+1)*(n+2)//6\n    n+=1\n\nwhile 1:\n    n=int(input())\n    if n==0:break\n    print(dp[n],odd[n])"
  },
  {
    "language": "Python",
    "code": "import copy\n\nitem = [i *(i +1) * (i+2) //6 for i in range(1,181)]\nq = []\nwhile True:\n    in_ = int(input())\n    if in_ == 0:\n        break\n    q.append(in_)\n\nINIT = 1000\nMAX = max(q) +10\nans = [INIT] *MAX\nans[0] = 0\nodd_item = [i for i in item if i % 2 ==0 ]\neven_item = [i for i in item if not(i % 2 == 0)]\n\nfor i in even_item:\n    for j in range(0,MAX-i):\n        if ans[j+i] > ans[j] + 1:\n            ans[j+i] = ans[j] + 1\n\nans_ = copy.deepcopy(ans)\n\nfor i in odd_item:\n    for j in range(0,MAX-i):\n        if ans[j+i] > ans[j] + 1:\n            ans[j+i] = ans[j]+1\nfor i in q:\n    print(ans[i],ans_[i])\n"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\nN1[0] = 0\nN2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    for j in range(p_,N+1):\n#        print(j)\n        N1[j] = min(N1[j],N1[j-p_]+1)\n\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    for j in range(p_,N +1):\n        N2[j] = min(N2[j],N2[j-p_]+1)\n#print('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    rec = list(range(1000000))\n    odd_rec = rec.copy()\n    \n    for i in range(2, 181):\n        t = i * (i + 1) * (i + 2) // 6\n        if t % 2 == 0:\n            for i, tpl in enumerate(zip(rec[t:], rec), start=t):\n                a, b = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n        else:\n            z_rec = zip(rec[t:], rec, odd_rec[t:], odd_rec)\n            for i, tpl in enumerate(z_rec, start=t):\n                a, b, c, d = tpl\n                b += 1\n                if b < a:\n                    rec[i] = b\n                d += 1\n                if d < c:\n                    odd_rec[i] = d\n    \n    n = int(input())\n    while n:\n        print(rec[n], odd_rec[n])\n        n = int(input())\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "N = 10**6\n\nN1 = [i for i in range(N+40)]\nN2 = [i for i in range(N+40)]\n\n#N1[0] = 0\n#N2[0] = 0\n\np = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1]\np2 = [n*(n+1)*(n+2)//6 for n in range(1,200) if n *(n+1)*(n+2)//6< N+1 and n *(n+1)*(n+2)//6 % 2 ==1 ]\n#print(p2)\nfor p_ in p:\n    if p_ > N +1:\n        continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n#        print(j)\n        if N1[j] > N1[j-p_] +1:\n            N1[j] = N1[j-p_]+1\nfor p_ in p2:\n    if p_ > N +1 :\n        continue\n    n = min(p_*5,N)\n    for j in range(p_,n):\n        if N2[j] > N2[j-p_]+1:\n            N2[j] = N2[j -p_]+1\n#print('a')\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    print(N1[n],N2[n])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\n\ndef inpl():\n    return list(map(int, input().split()))\n\n\ndef main():\n    max_p = 10**6\n    dp_all = [1000] * (max_p + 1)\n    dp_odd = dp_all.copy()\n    dp_all[0] = 0\n    dp_odd[0] = 0\n\n    pollocks = [i * (i + 1) * (i + 2) // 6 for i in range(1, 181)]\n\n    for i in range(max_p):\n        for p in pollocks:\n            if i + p > max_p:\n                break\n            if dp_all[i + p] > dp_all[i] + 1:\n                dp_all[i + p] = dp_all[i] + 1\n            if p % 2 and dp_odd[i + p] > dp_odd[i] + 1:\n                dp_odd[i + p] = dp_odd[i] + 1\n\n    while True:\n        p = int(input())\n        if p == 0:\n            break\n        print(dp_all[p], dp_odd[p])\n\n\nmain()\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::min;\n\nconst MAX: usize = std::usize::MAX;\n\nfn main() {\n    let mut nl = vec![];\n    loop {\n        let mut x = String::new();\n        std::io::stdin().read_line(&mut x).unwrap();\n        let n: usize = x.trim().parse().unwrap();\n        if n == 0 { break; }\n        nl.push(n)\n    }\n\n    let mut s = vec![];\n    let mut os = vec![];\n    for i in 1.. {\n        let d = i * (i + 1) * (i + 2) / 6;\n        if d > 1_000_000 { break; }\n        s.push(d);\n        if d % 2 == 1 {os.push(d)}\n    }\n    let mut dp = vec![MAX; 1_000_001];\n    let mut odp = vec![MAX; 1_000_001];\n    dp[0] = 0;\n    odp[0] = 0;\n    for j in 1..1_000_001 {\n        for &i in &s {\n            if j < i { break; }\n            dp[j] = min(dp[j], dp[j - i] + 1)\n        }\n        for &i in &os {\n            if j < i { break; }\n            odp[j] = min(odp[j], odp[j - i] + 1)\n        }\n    }\n    for i in nl {\n        println!(\"{} {}\", dp[i], odp[i]);\n    }\n}\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports)]\n#![allow(non_snake_case)]\nuse std::cmp::*;\nuse std::collections::*;\nuse std::io::Write;\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($e:expr),*) => {\n        #[cfg(debug_assertions)]\n        $({\n            let (e, mut err) = (stringify!($e), std::io::stderr());\n            writeln!(err, \"{} = {:?}\", e, $e).unwrap()\n        })*\n    };\n}\n\nfn main() {\n    let mut queries = vec![];\n    loop {\n        let a = read::<usize>();\n        if a == 0 {\n            break;\n        }\n        queries.push(a);\n    }\n    let max_query = *queries.iter().max().unwrap();\n    let mut dp = vec![std::usize::MAX; max_query + 1];\n    let mut pyramids = vec![];\n    for i in 1.. {\n        let number = i * (i + 1) * (i + 2) / 6;\n        if number > max_query {\n            break;\n        }\n        pyramids.push(number);\n        dp[number] = 1;\n    }\n\n    for i in 0..max_query + 1 {\n        if dp[i] == std::usize::MAX {\n            continue;\n        }\n        for &number in pyramids.iter() {\n            if i + number > max_query {\n                continue;\n            }\n            dp[i + number] = min(dp[i + number], dp[i] + 1);\n        }\n    }\n    let dp = dp;\n\n    let mut dp2 = vec![std::usize::MAX; max_query + 1];\n    let mut pyramids = vec![];\n    for i in 1.. {\n        let number = i * (i + 1) * (i + 2) / 6;\n        if number % 2 == 0 {\n            continue;\n        }\n        if number > max_query {\n            break;\n        }\n        pyramids.push(number);\n        dp2[number] = 1;\n    }\n\n    for i in 0..max_query + 1 {\n        if dp2[i] == std::usize::MAX {\n            continue;\n        }\n        for &number in pyramids.iter() {\n            if i + number > max_query {\n                continue;\n            }\n            dp2[i + number] = min(dp2[i + number], dp2[i] + 1);\n        }\n    }\n\n    for q in queries {\n        println!(\"{} {}\", dp[q], dp2[q]);\n    }\n}\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(dead_code)]\n#![allow(unused_macros)]\n#![allow(unused_imports)]\n\nuse std::str::FromStr;\nuse std::io::*;\nuse std::collections::*;\nuse std::cmp::*;\n\nstruct Scanner<I: Iterator<Item = char>> {\n    iter: std::iter::Peekable<I>,\n}\n\nmacro_rules! exit {\n    () => {{\n        exit!(0)\n    }};\n    ($code:expr) => {{\n        if cfg!(local) {\n            writeln!(std::io::stderr(), \"===== Terminated =====\")\n                .expect(\"failed printing to stderr\");\n        }\n        std::process::exit($code);\n    }}\n}\n\nimpl<I: Iterator<Item = char>> Scanner<I> {\n    pub fn new(iter: I) -> Scanner<I> {\n        Scanner {\n            iter: iter.peekable(),\n        }\n    }\n\n    pub fn safe_get_token(&mut self) -> Option<String> {\n        let token = self.iter\n            .by_ref()\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        if token.is_empty() {\n            None\n        } else {\n            Some(token)\n        }\n    }\n\n    pub fn token(&mut self) -> String {\n        self.safe_get_token().unwrap_or_else(|| exit!())\n    }\n\n    pub fn get<T: FromStr>(&mut self) -> T {\n        self.token().parse::<T>().unwrap_or_else(|_| exit!())\n    }\n\n    pub fn vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {\n        (0..len).map(|_| self.get()).collect()\n    }\n\n    pub fn mat<T: FromStr>(&mut self, row: usize, col: usize) -> Vec<Vec<T>> {\n        (0..row).map(|_| self.vec(col)).collect()\n    }\n\n    pub fn char(&mut self) -> char {\n        self.iter.next().unwrap_or_else(|| exit!())\n    }\n\n    pub fn chars(&mut self) -> Vec<char> {\n        self.get::<String>().chars().collect()\n    }\n\n    pub fn mat_chars(&mut self, row: usize) -> Vec<Vec<char>> {\n        (0..row).map(|_| self.chars()).collect()\n    }\n\n    pub fn line(&mut self) -> String {\n        if self.peek().is_some() {\n            self.iter\n                .by_ref()\n                .take_while(|&c| !(c == '\\n' || c == '\\r'))\n                .collect::<String>()\n        } else {\n            exit!();\n        }\n    }\n\n    pub fn peek(&mut self) -> Option<&char> {\n        self.iter.peek()\n    }\n}\n\nconst MAX: usize = 1000000;\nconst INF: i64 = 1 << 60;\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin.bytes().map(|c| c.unwrap() as char));\n    let mut t = Vec::new();\n    for i in (1..).take_while(|i| i * (i+1) * (i+2) / 6 <= MAX) {\n        t.push(i * (i+1) * (i+2) / 6);\n    }\n    let mut dp1 = vec![INF; MAX+1];\n    dp1[0] = 0;\n    for i in 0..MAX+1 {\n        for &ti in &t {\n            if i >= ti {\n                dp1[i] = min(dp1[i], dp1[i - ti] + 1);\n            }\n        }\n    }\n    let mut dp2 = vec![INF; MAX+1];\n    dp2[0] = 0;\n    for i in 1..MAX+1 {\n        for &ti in &t {\n            if ti % 2 == 0 { continue; }\n            if i >= ti {\n                dp2[i] = min(dp2[i], dp2[i - ti] + 1);\n            }\n        }\n    }\n    loop {\n        let N: usize = sc.get();\n        if N == 0 {\n            break;\n        }\n        println!(\"{} {}\", dp1[N], dp2[N]);\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n \n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n \n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n \n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n \n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n \n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n \n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n \n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n \nuse std::cmp::Ordering;\nuse std::cmp;\nuse std::cmp::min;\nuse std::collections::BTreeMap;\nuse std::process;\nuse std::cmp::Ord;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::collections::VecDeque;\nuse std::collections::BTreeSet;\nuse std::mem;\nuse std::collections::BinaryHeap;\n/// Equivalent to std::lowerbound and std::upperbound in c++\npub struct Scanner<R> {\n    stdin: R,\n}\n \nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\nfn main(){\n    let sssss = std::io::stdin();\n    let mut sc = Scanner { stdin: sssss.lock() };\n    let mut n = vec![0;200+1usize];\n    let mut n2 = n.clone();\n    let mut L = 1000001;\n    let mut now = 0;\n    for i in 1..n2.len(){\n        n[i-1] = i*(i+1)*(i+2)/6;\n        if n[i-1] %2 == 1{\n            n2[now] = n[i-1];\n            now+=1;\n        }\n    }\n    let mut dp = vec![INF as usize; L];\n    dp[0] = 0;\n    \n    let mut dp2 = vec![INF as usize; L];\n    dp2[0] = 0;\n    for i in 0..L{\n        for j in 0..n.len(){\n            if i + n[j] < L{\n                dp[i+n[j]] = cmp::min(dp[i+n[j]], dp[i] + 1);\n            }\n            if i + n2[j] < L{\n                dp2[i+n2[j]] = cmp::min(dp2[i+n2[j]], dp2[i] + 1);\n            }\n\n        }\n    }\n    while(true){\n        let mut N:usize = sc.read();\n        if N == 0{\n            break;\n        }\n        println!(\"{} {}\", dp[N], dp2[N]);\n\n    }\n}\n\npub static MOD:i64 = 1000000007;\npub static MODu:usize = 1000000007;\npub static eps:f64 = 1e-6;\nconst INF: i64 = 1 << 60;\n\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{Read, Write};\n\nfn run() {\n    let m = 1_000_000;\n    let mut dp = vec![m; m + 1];\n    let mut dp1 = vec![m; m + 1];\n    dp[0] = 0;\n    dp1[0] = 0;\n    for i in 1.. {\n        let k = i * (i + 1) * (i + 2) / 6;\n        if k > m {\n            break;\n        }\n        for j in k..(m + 1) {\n            dp[j] = std::cmp::min(dp[j], dp[j - k] + 1);\n            if k % 2 == 1 {\n                dp1[j] = std::cmp::min(dp1[j], dp1[j - k] + 1);\n            }\n        }\n    }\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    while let Some(s) = it.next() {\n        let n: usize = s.parse().unwrap();\n        if n == 0 {\n            break;\n        }\n        writeln!(out, \"{} {}\", dp[n], dp1[n]).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]