[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  import scala.io.StdIn._\n  val Array(n, q) = readLine.trim.split(' ').map(_.toInt)\n  val barrier = Array.tabulate(n){_ ⇒\n    val Array(x, y, z, r, l) = readLine.trim.split(' ').map(_.toLong)\n    (Point(x, y, z), r, l)\n  }\n  for (_ ← 0 until q) {\n    val Array(sx, sy, sz, dx, dy, dz) = readLine.trim.split(' ').map(_.toInt)\n    val from = Point(sx, sy, sz)\n    val to = Point(dx, dy, dz)\n    val vec = to - from match {case v ⇒ v / v.length}\n    //println(vec)\n    println(barrier.map{\n      case (center, radius, cost) ⇒\n        val nearest = vec * vec.dot(center - from) + from\n        if ((from - nearest).dot(to - nearest) <= 0 && (center - nearest).length <= radius + 0.0000001) cost else 0L\n    }.sum)\n  }\n}\ncase class Point(x: Double, y: Double, z: Double) {\n  def -(that: Point): Vector = Vector(x - that.x, y - that.y, z - that.z)\n  def +(that: Vector): Point = Point(x + that.x, y + that.y, z + that.z)\n}\ncase class Vector(x: Double, y: Double, z: Double) {\n  def dot(that: Vector): Double = x * that.x + y * that.y + z * that.z\n  def +(that: Point): Point = Point(x + that.x, y + that.y, z + that.z)\n  def length: Double = Math.sqrt(x * x + y * y + z * z)\n  def /(that: Double): Vector = Vector(x / that, y / that, z / that)\n  def *(that: Double): Vector = Vector(x * that, y * that, z * that)\n  def toPoint: Point = Point(x, y, z)\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\n// Geometry <3 {{{\n\ntemplate<typename T>\nclass Vector3D {\n\tpublic:\n\t\tT x, y, z;\n\t\tVector3D(T _x, T _y, T _z): x(_x), y(_y), z(_z) {\n\t\t}\n\n\t\tT abs() {\n\t\t\treturn sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n\t\t}\n\n\t\tT dot(Vector3D& rhs) {\n\t\t\treturn x * rhs.x + y * rhs.y + z * rhs.z;\n\t\t}\n\n\t\t// Add vector\n\t\tVector3D<T> operator+(const Vector3D& rhs) const {\n\t\t\treturn Vector3D<T>(x + rhs.x, y + rhs.y, z + rhs.z);\n\t\t}\n\n\t\t// Subtract vecrtor\n\t\tVector3D<T> operator-(const Vector3D& rhs) const {\n\t\t\treturn Vector3D<T>(x - rhs.x, y - rhs.y, z - rhs.z);\n\t\t}\n\n\t\t// Multiply by scala value\n\t\ttemplate<typename Scala>\n\t\tVector3D<T> operator*(const Scala rhs) const {\n\t\t\treturn Vector3D<T>(x * rhs, y * rhs, z * rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Vector3D<T>& v) {\n\treturn out << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\";\n}\n\nclass Sphere {\n\tint x, y, z, r;\n\tpublic:\n\t\tSphere(int _x, int _y, int _z, int _r) : x(_x), y(_y), z(_z), r(_r) {\n\t\t}\n};\n\nclass GeometryUtil {\n\tpublic:\n\t\tbool eql(double a, double b) { return abs(a - b) < EPS; }\n\t\tbool lt(double a, double b) { return b - a >= EPS; }\n\t\tbool lte(double a, double b) { return lt(a, b) || eql(a, b); }\n\t\tbool eql(P a, P b) { return eql(a.Y, b.Y) && eql(a.X, b.X); }\n\t\tGeometryUtil();\n};\n\nconst GeometryUtil G();\n\n// }}}\n\nclass Obstacle {\n\tpublic:\n\t\tint x, y, z, r;\n\t\tULL magic;\n\t\tObstacle(int _x, int _y, int _z, int _r, ULL _magic) : x(_x), y(_y), z(_z), r(_r), magic(_magic) {\n\t\t}\n};\nostream& operator<<(ostream& out, const Obstacle& o) {\n\treturn out << \"((\" << o.x << \", \" << o.y << \", \" << o.z << \"), \" << o.r << \", \" << o.magic << \")\";\n}\n\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/2.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint N, Q; cin >> N >> Q;\n\tvector<Obstacle> obstacles;\n\tREP (i, N) {\n\t\tint x, y, z, r; ULL l; cin >> x >> y >> z >> r >> l;\n\t\tobstacles.PB(Obstacle(x, y, z, r, l));\n\t}\n\n\tREP (t, Q) {\n\t\tint x, y, z; cin >> x >> y >> z;\n\t\tVector3D<double> red(x, y, z);\n\t\tcin >> x >> y >> z;\n\t\tVector3D<double> blue(x, y, z);\n\t\tULL ans = 0;\n\t\tREP (i, N) {\n\t\t\tObstacle o = obstacles[i];\n\t\t\tdump(red);\n\t\t\tdump(blue);\n\t\t\tdump(o);\n\t\t\t// Move vectors so that the center of the obstacle become the origin\n\t\t\tVector3D<double> s = red - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> e = blue - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> v = e - s;\n\t\t\to.x = o.y = o.z = 0;\n\t\t\tdump(s);\n\t\t\tdump(e);\n\t\t\tdump(v);\n\t\t\tdump(o);\n\n\t\t\tdump(s.dot(v));\n\t\t\tdouble x = - (s.dot(v) / pow((double)(v.abs()), 2));\n\t\t\tdump(x);\n\t\t\tVector3D<double> nearest = s + v * x;\n\t\t\tdump(nearest);\n\t\t\tif (nearest.abs() <= o.r) {\n\t\t\t\tans += o.magic;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n\tdouble x,y,z;\n};\ndouble dot(P a,P b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\ndouble abs(P a){\n\treturn sqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n}\nP sub(P a,P b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\ta.z -= b.z;\n\treturn a;\n}\nP pls(P a,P b){\n\ta.x += b.x;\n\ta.y += b.y;\n\ta.z += b.z;\n\treturn a;\n}\nP mul(double v,P a){\n\ta.x *= v;\n\ta.y *= v;\n\ta.z *= v;\n\treturn a;\n}\n\ndouble dist(P a,P b,P c){\n\tP e = sub(b,a);\n\te = mul(1./abs(e),e);\n\tP v = sub(c,a);\n\treturn abs(sub(c,pls(a,mul(dot(e,v),e))));\n}\nP p[50];\nlong long l[50],r[50];\nint main(){\n\tint N,Q;\n\tcin >> N >> Q;\n\tfor(int i = 0 ; i < N ; i++) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tP p1,p2;\n\t\tcin >> p1.x >> p1.y >> p1.z;\n\t\tcin >> p2.x >> p2.y >> p2.z;\t\t\n\t\tlong long ans = 0;\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\tif( dist(p1,p2,p[j]) < r[j] + 1e-9 ) ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nvector<Point> crosspointLC(const Line& l,const Circle& ci){\n  Point dir = unit(l[1] - l[0]);\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  vector<Point> res;\n  if(D < -EPS) return res;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(abs(t1) < abs(t2)){\n    res.push_back(l[0] + dir * t1);\n  }\n  else{\n    res.push_back(l[0] + dir * t2);\n  }\n  return res;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<int> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      int amount_of_consumption;\n      scanf(\"%d %d %d %d %d\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      int sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        vector<Point> p = crosspointLC(line,obstacles[obstacle_i]);\n        if(p.size() > 0) sum += costs[obstacle_i];\n      }\n      printf(\"%d\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct pos3 {\n\tdouble x;\n\tdouble y;\n\tdouble z;\n};\nstruct jama {\n\tpos3 p;\n\tdouble r;\n\tll cost;\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<jama> jamas(n);\n\tREP(i, n)\n\t\tcin >> jamas[i].p.x >> jamas[i].p.y >> jamas[i].p.z >> jamas[i].r >> jamas[i].cost;\n\tvector<pair<pos3, pos3>> ray(q);\n\tREP(i, q)\n\t\tcin >> ray[i].first.x >> ray[i].first.y >> ray[i].first.z >> ray[i].second.x >> ray[i].second.y >> ray[i].second.z;\n\tREP(i, q) {\n\t\tll cost = 0;\n\t\tdouble tx = -(ray[i].first.x - ray[i].second.x);\n\t\tdouble ty = -(ray[i].first.y - ray[i].second.y);\n\t\tdouble tz = -(ray[i].first.z - ray[i].second.z);\n\t\tdouble t = tx*tx +\n\t\t\tty*ty +\n\t\t\ttz*tz;\n\t\tREP(j, n) {\n\t\t\tdouble sx = (ray[i].first.x - jamas[j].p.x);\n\t\t\tdouble sy = (ray[i].first.y - jamas[j].p.y);\n\t\t\tdouble sz = (ray[i].first.z - jamas[j].p.z);\n\t\t\tdouble ts = (tx*sx + ty*sy + tz*sz);\n\t\t\tdouble p = -ts / t;\n\t\t\tif (p<0.0 || p>1.0)\n\t\t\t\tcontinue;\n\t\t\tdouble Px = ray[i].first.x + p*tx;\n\t\t\tdouble Py = ray[i].first.y + p*ty;\n\t\t\tdouble Pz = ray[i].first.z + p*tz;\n\t\t\tif ((Px - jamas[j].p.x)*(Px - jamas[j].p.x) +\n\t\t\t\t(Py - jamas[j].p.y)*(Py - jamas[j].p.y) +\n\t\t\t\t(Pz - jamas[j].p.z)*(Pz - jamas[j].p.z) <=\n\t\t\t\tjamas[j].r*jamas[j].r+(1e-5))\n\t\t\t\tcost += jamas[j].cost;\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define EPS (1e-10)\n\nstruct P{\n  double X, Y, Z;\n};\n\nnamespace std{\n  P operator-(const P& a, const P& b){\n    P ret = {a.X-b.X, a.Y-b.Y, a.Z-b.Z};\n    return ret;\n  }\n}\n\ndouble dot_3d(P a, P b){\n  return a.X*b.X + a.Y*b.Y + a.Z*b.Z;\n}\n\nP cross(P a, P b){\n  P ret = {a.Y*b.Z-a.Z*b.Y,a.Z*b.X-a.X*b.Z,a.X*b.Y-a.Y*b.X};\n  return ret;\n}\n\ndouble norm_3d(P a){\n  return a.X*a.X + a.Y*a.Y + a.Z*a.Z;\n}\n\nint main(){\n  int N, Q;\n  cin >> N >> Q;\n  vector<P> obs(N);\n  vector<int> r(N), l(N);\n  for(int i = 0; i < N; ++i){\n    cin >> obs[i].X >> obs[i].Y >> obs[i].Z >> r[i] >> l[i];\n  }\n  P s, d;\n  for(int i = 0; i < Q; ++i){\n    cin >> s.X >> s.Y >> s.Z >> d.X >> d.Y >> d.Z;\n    P v = d-s;\n    int ans = 0;\n    for(int j = 0; j < N; ++j){\n      if(norm_3d(cross(v,obs[j]-s))/norm_3d(v) <= r[j]*r[j]+EPS &&\n\t dot_3d(v,obs[j]-s) >= 0 && dot_3d(s-d,obs[j]-d) >= 0) ans += l[j];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define LE(n,m) ((n)<(m)+EPS)\nconst double EPS=1e-8;\nconst int MAX_N=51,MAX_Q=51;\n\nint N,Q;\n\ndouble x[MAX_N],y[MAX_N],z[MAX_N],r[MAX_N];\nll l[MAX_N];\ndouble sx[MAX_Q],sy[MAX_Q],sz[MAX_Q];\ndouble dx[MAX_Q],dy[MAX_Q],dz[MAX_Q];\n\nvector<double> proj(int n,int q,bool &point_on_linesegment){\n    double X=dx[q]-sx[q],Y=dy[q]-sy[q],Z=dz[q]-sz[q];\n    double t=((x[n]-sx[q])*X+(y[n]-sy[q])*Y+(z[n]-sz[q])*Z)/(X*X+Y*Y+Z*Z);\n    if (LE(t,0)||LE(1,t)) point_on_linesegment=false;\n    return {sx[q]+t*X,sy[q]+t*Y,sz[q]+t*Z};\n}\n\ndouble distPP(double x1,double y1,double z1,double x2,double y2,double z2){\n    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);\n}\n\ndouble distSP(int n,int q){\n    bool check=true;\n    vector<double> v=proj(n,q,check);\n    if (check) return distPP(v[0],v[1],v[2],x[n],y[n],z[n]);\n    else return min(distPP(sx[q],sy[q],sz[q],x[n],y[n],z[n])\n                    ,distPP(dx[q],dy[q],dz[q],x[n],y[n],z[n]));\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> Q;\n    for (int i=0;i<N;++i) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n    for (int i=0;i<Q;++i) cin >> sx[i] >> sy[i] >> sz[i] >> dx[i] >> dy[i] >> dz[i];\n    for (int j=0;j<Q;++j){\n        ll ans=0;\n        for (int i=0;i<N;++i)\n            if (LE(distSP(i,j),r[i]*r[i]))\n                ans+=l[i];\n        cout << ans << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  double x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  long long int  r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2*area)/abs(l.second - l.first);\n  //std::cout << abs(l.second - l.first) << \" \" << abs(p - l.first) << std::endl;\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  //  std::cout << \"cosa:\" << cosa << \" cosb:\" << cosb << std::endl;\n  if(cosa < 0) return abs(p - l.first);\n  if(cosb < 0) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    scanf(\"%lf %lf %lf %lf %lf\", &p[i].c.x, &p[i].c.y, &p[i].c.z, &p[i].r, &p[i].l);\n    //std::cout << p[i].c.x << \" \" << p[i].c.y << \" \" <<\n    //p[i].c.z << \" \" << p[i].r << \" \" << p[i].l << std::endl;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    int ans = 0;\n    scanf(\"%lf %lf %lf %lf %lf %lf\", &s.x, &s.y, &s.z, &d.x, &d.y, &d.z);\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      double d = dis(l, p[j].c);\n      //std::cout << \"j:\" << j << \" dis:\" << d << \" r:\" << p[j].r << std::endl;\n      if(d <= p[j].r){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,qc,x[51],y[51],z[51],rl[51];\ndouble dx,dy,dz,sx,sy,sz,a,b,c,p,q,r;\nlong long int l[51],sum;\ndouble t,lt;\nint main(){\n\tcin >>n >>qc;\n\tfor(int i=0;i<n;i++){\n\t\tcin >>x[i] >>y[i] >>z[i] >>rl[i] >>l[i];\n\t}\n\tfor(int i=0;i<qc;i++){\n\t\tsum=0;\n\t\tcin >>sx >>sy >>sz >>dx >>dy >>dz;\n\t\ta=dx-sx;\n\t\tb=dy-sy;\n\t\tc=dz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp=sx-x[j];\n\t\t\tq=sy-y[j];\n\t\t\tr=sz-z[j];\n\t\t\tt=-(a*p+b*q+c*r)/(a*a+b*b+c*c);\n\t\t\tif(t>1){\n\t\t\t\tt=1;\n\t\t\t}else if(t<0){\n\t\t\t\tt=0;\n\t\t\t}\n\t\t\tlt=(t*a+p)*(t*a+p)+(t*b+q)*(t*b+q)+(t*c+r)*(t*c+r);\n\t\t\t\n\t\t\tif(lt<=rl[j]*rl[j]+(0.0001))sum+=l[j];\n\t\t\tcout <<t <<endl;\n\t\t\tcout <<lt <<endl;\n\t\t\t\n\t\t}\n\t\tcout <<sum <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing lint = long long;\n\ninline lint sq(lint a) { return a * a; }\n\nstruct Point {\n    lint x, y, z;\n};\n\ninline Point sub(Point b, Point a) {\n    return Point{b.x - a.x, b.y - a.y, b.z - a.z};\n}\n\ninline lint sqnorm(Point p) {\n    return sq(p.x) + sq(p.y) + sq(p.z);\n}\n\ninline lint prod(Point a, Point b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nusing namespace std;\nusing lint = long long;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<Point> P(N);\n    vector<lint> r(N), l(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> P[i].x >> P[i].y >> P[i].z >> r[i] >> l[i];\n    }\n\n    for (int q = 0; q < Q; ++q) {\n        Point a, b;\n        cin >> a.x >> a.y >> a.z >> b.x >> b.y >> b.z;\n\n        lint ans = 0;\n        Point ab = sub(b, a);\n        for (int i = 0; i < N; ++i) {\n            Point ac = sub(P[i], a);\n            if (sqnorm(ab) * sqnorm(ac) - sq(prod(ab, ac)) <= sq(r[i]) * sqnorm(ab)) {\n                ans += l[i];\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nusing Real = double;\nconst Real EPS = 1e-8;\n\nReal scan() {\n    int x; scanf(\"%d\", &x);\n    return (Real)x;\n}\n\nReal dist(Real x1, Real y1, Real z1, Real x2, Real y2, Real z2) {\n    x1 -= x2;\n    y1 -= y2;\n    z1 -= z2;\n    return sqrt(x1 * x1 + y1 * y1 + z1 * z1);\n}\nvoid solve() {\n    int n, kkt; scanf(\"%d %d\", &n, &kkt);\n    vector<Real> x(n), y(n), z(n), r(n);\n    vector<ll> l(n);\n    for (int i = 0; i < n; i++) {\n        x[i] = scan(); y[i] = scan(); z[i] = scan(); r[i] = scan();\n        scanf(\"%lld\", &l[i]);\n    }\n\n    while (kkt--) {\n        ll res = 0;\n        Real sx = scan(), sy = scan(), sz = scan(), tx = scan(), ty = scan(), tz = scan();\n        for (int i = 0; i < n; i++) {\n            Real lf = 0;\n            Real rg = 1;\n            Real d = inf;\n            for (int jupi = 0; jupi < 120; jupi++) {\n                Real lmid = (lf * 2 + rg) / 3.0;\n                Real rmid = (lf + rg * 2) / 3.0;\n                Real lx = sx + (tx - sx) * lmid;\n                Real rx = sx + (tx - sx) * rmid;\n                Real ly = sy + (ty - sy) * lmid;\n                Real ry = sy + (ty - sy) * rmid;\n                Real lz = sz + (tz - sz) * lmid;\n                Real rz = sz + (tz - sz) * rmid;\n                Real ld = dist(lx, ly, lz, x[i], y[i], z[i]);\n                Real rd = dist(rx, ry, rz, x[i], y[i], z[i]);\n                chmin(d, ld);\n                chmin(d, rd);\n                if (ld < rd) rg = rmid;\n                else lf = lmid;\n            }\n            if (d <= r[i] + EPS) {\n                res += l[i];\n            }\n        }\n        printf(\"%lld\\n\", res);\n    }\n\n}\n\nint main()\n{\n    /*\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    */\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsolve();\n        break;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Vertex\n{\n  double x, y, z;\n  Vertex(){}\n  Vertex(double a, double b, double c){\n    x = a; y = b; z = c;\n  }\n};\n\n#define Vector Vertex\n\ndouble distanc(Vertex p1, Vertex p2)\n{\n  return pow(SQ(p2.x-p1.x) + SQ(p2.y-p1.y) + SQ(p2.z-p1.z), 0.5);\n}\n\ndouble length(Vector v)\n{\n  return pow(SQ(v.x) + SQ(v.y) + SQ(v.z), 0.5);\n}\n\nVector cross(Vector vl, Vector vr)\n{\n  return Vector(vl.y*vr.z - vl.z*vr.y, vl.z*vr.x - vl.x*vr.z, vl.x*vr.y - vl.y*vr.x);\n}\n\ndouble dis(Vertex p, Vertex a, Vertex b)\n{\n  Vector ab(b.x-a.x, b.y-a.y, b.z-a.z);\n  Vector ap(p.x-a.x, p.y-a.y, p.z-a.z);\n  double d = length(cross(ab, ap));\n  double l = distanc(a, b);\n  double h = d / l;\n  return h;\n}\n\nint main()\n{\n  int N, Q;\n  Vertex jm[64];\n  int r[64];\n  ll l[64];\n\n  cin >> N >> Q;\n  rep(i, N){\n    int x, y, z;\n    cin >> x >> y >> z >> r[i] >> l[i];\n    Vertex tmp(x,y,z);\n    jm[i] = tmp;\n  }\n\n  rep(i, Q){\n    ll res = 0;    \n    int x, y, z;\n    cin >> x >> y >> z;\n    Vertex a(x, y, z);\n    cin >> x >> y >> z;\n    Vertex b(x, y, z);\n    rep(j, N){\n      //      cout << dis(jm[j], a, b) << endl;\n      if(r[j] + EPS >= dis(jm[j], a, b)) res += l[j];\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\nusing namespace std;\n#define R real()\n#define I imag() \nint n,q;\nint x[51],y[51],z[51],r[51],sx,sy,sz,dx,dy,dz;\nlong long l[51],an;\nbool check(int i){\n  complex<double>s,t;\n  s.R=x[i]-sx, s.I=y[i]-sy;\n  t.R=dx-sx, t.I=dy-sy;\n  s*=conj(t),s/=abs(t);\n  t.R=abs(t);\n  double ay=s.I,nd;\n  t.I=dz-sz;\n  s.I=z[i]-sz;\n  nd=abs(t);\n  s*=conj(t),s/=nd;\n  if(0<=s.R&&s.R<=nd&&ay*ay+s.I*s.I<=r[i]*r[i])return true;\n  if(min(ay*ay+s.I*s.I+s.R*s.R,ay*ay+s.I*s.I+(s.R-nd)*(s.R-nd))<=r[i]*r[i])return true;\n  return false;\n  }\nint main(){\n  cin>>n>>q;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i]>>z[i]>>r[i]>>l[i];\n  for(int i=0;i<q;i++){\n    cin>>sx>>sy>>sz>>dx>>dy>>dz;\n    an=0;\n    for(int j=0;j<n;j++)if(check(j))an+=l[j];\n    cout<<an<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef long long lint;\nconst double EPS = 1e-9;\n\ntypedef struct Point {\n\tdouble x, y, z;\n\tPoint (double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}\n\tPoint operator + (const Point& a) const { return Point(x + a.x, y + a.y, z + a.z); }\n\tPoint operator - (const Point& a) const { return Point(x - a.x, y - a.y, z - a.z); }\n\tPoint operator * (double d) const { return Point(x * d, y * d, z * d); }\n} Vector;\n\nstruct Object {\n\tPoint p; double r; lint l;\n\tObject(Point p_, double r_, lint l_) : p(p_), r(r_), l(l_) {}\n};\n\ndouble sqr(double x) { return x * x; }\ndouble distance(const Point& a, const Point& b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y) + sqr(a.z - b.z)); }\n\nbool collision(const Object& obj, const Point& a, const Point& b) {\n\tVector unit = b - a;\n\t\n\tdouble lb = 0.0, ub = 1.0;\n\t\n\tfor_(i,0,50) {\n\t\tdouble lft = (lb * 2. + ub) / 3., rgt = (lb + ub * 2.) / 3.;\n\t\tPoint pl = a + unit * lft, pr = a + unit * rgt;\n\t\tdouble dl = distance(obj.p, pl), dr = distance(obj.p, pr);\n\t\tif (dl < dr) ub = rgt;\n\t\telse lb = lft;\n\t}\n\t\n\treturn distance(obj.p, a + unit * lb) < obj.r + EPS;\n}\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\t\n\tvector< Object > obj;\n\t\n\tfor_(i,0,N) {\n\t\tdouble x, y, z, r; lint l;\n\t\tcin >> x >> y >> z >> r >> l;\n\t\tobj.push_back(Object(Point(x, y, z), r, l));\n\t}\n\t\n\tfor_(i,0,Q) {\n\t\tdouble x1, y1, z1, x2, y2, z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tPoint red(x1, y1, z1), blue(x2, y2, z2);\n\t\n\t\tlint ans = 0;\n\t\tfor_(j,0,N) if (collision(obj[j], red, blue)) ans += obj[j].l;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\ntypedef struct {\n    double x, y, z;\n} P;\n\ndouble dot(P a, P b)\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nP diff(P f, P t)\n{\n    return P{ t.x - f.x, t.y - f.y, t.z - f.z };\n}\n\nP mul(P a, double s)\n{\n    return P{ a.x*s, a.y*s, a.z*s };\n}\n\nint main()\n{\n    int n, q; cin >> n >> q;\n    vector<P> p(n);\n    vector<double> r(n);\n    vector<ll> l(n);\n    loop (n, i) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\n    loop (q, i) {\n        P s, t;\n        cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n        P v = diff(s, t);\n        double d = pow(dot(v, v), 0.5);\n        ll ans = 0;\n        loop (n, j) {\n            P w = diff(s, p[j]);\n            P nv = mul(v, dot(w, v) / d / d);\n            P nw = diff(nv, w);\n            double R = pow(dot(nw, nw), 0.5);\n            if (R < r[j]) ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\n#define eps 1e-9\n\nint n,q;\ndouble p[55][3],r[55];\nll l[55];\n\ndouble dot(double a[3],double b[3]){\n  double res=0;\n  rep(i,3)res+=a[i]*b[i];\n  return res;\n}\ndouble nrm(double a[3]){\n  double res=0;\n  rep(i,3)res+=a[i]*a[i];\n  return res;\n}\ndouble abs(double a[3]){\n  return sqrt(nrm(a));\n}\nvoid proj(double a[3],double b[3],double res[3]){\n  double c=dot(a,b);\n  double d=abs(b);\n  rep(i,3)res[i]=(b[i]*c)/(d*d);\n  return ;\n}\ndouble distSP(double a[3],double b[3],double p[3]){\n  double ap[3],bp[3],ab[3],pr[3];\n  rep(i,3){\n    ap[i]=p[i]-a[i];\n    bp[i]=p[i]-b[i];\n    ab[i]=b[i]-a[i];\n  }\n  double ar[3],br[3];\n  double res=0;\n  proj(ap,ab,ar);\n  rep(i,3){\n    br[i]=ar[i]-ab[i];\n  }\n  if(abs(ar)+abs(br)-abs(ab)<eps){\n    rep(i,3)pr[i]=ar[i]-ap[i];\n    return abs(pr);\n  }else{\n    return min(abs(ap),abs(bp));\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>q;\n  rep(i,n){\n    rep(j,3)cin>>p[i][j];\n    cin>>r[i]>>l[i];\n  }\n  rep(hoge,q){\n    ll res=0;\n    double a[3],b[3];\n    rep(i,3)cin>>a[i];\n    rep(i,3)cin>>b[i];\n    rep(i,n){\n      if(distSP(a,b,p[i])<r[i]+eps)res+=l[i];\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nclass Point3D {\npublic:\n\tdouble x, y, z;\n};\n\nclass Line {\npublic:\n\tPoint3D begin, end;\n};\n\nclass Ball {\npublic:\n\tPoint3D center;\n\tdouble r;\n\tlong long int cost;\n};\n\ndouble dot(Point3D a, Point3D b)\n{\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nconst double EPS = 1e-9;\n\nbool check(Line line, Ball ball)\n{\n\tPoint3D v;\n\tv.x = line.end.x - line.begin.x;\n\tv.y = line.end.y - line.begin.y;\n\tv.z = line.end.z - line.begin.z;\n\n\tline.begin.x -= ball.center.x;\n\tline.begin.y -= ball.center.y;\n\tline.begin.z -= ball.center.z;\n\tline.end.x -= ball.center.x;\n\tline.end.y -= ball.center.y;\n\tline.end.z -= ball.center.z;\n\tball.center.x = 0;\n\tball.center.y = 0;\n\tball.center.z = 0;\n\n\tdouble t = -dot(line.begin, v) / dot(v, v);\n\tPoint3D near;\n\tnear.x = line.begin.x + v.x*t;\n\tnear.y = line.begin.y + v.y*t;\n\tnear.z = line.begin.z + v.z*t;\n\n\t//cout << dot(near, near) << \" \" << ball.r*ball.r << endl;\n\n\tif ((t >= 0 || fabs(t) <= EPS) && (t <= 1 || fabs(t - 1) <= EPS)) {\n\t\tif (dot(near, near) <= ball.r*ball.r || dot(near, near) - ball.r*ball.r <= EPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\tcin >> N >> Q;\n\n\tvector<Ball> balls(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> balls[i].center.x >> balls[i].center.y >> balls[i].center.z >> balls[i].r >> balls[i].cost;\n\t}\n\n\tfor (int i = 0; i < Q; i++) {\n\t\tlong long int ans = 0;\n\t\tLine line;\n\n\t\tcin >> line.begin.x >> line.begin.y >> line.begin.z >> line.end.x >> line.end.y >> line.end.z;\n\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (check(line, balls[j]) == true) {\n\t\t\t\tans += balls[j].cost;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(5));\n\trep(i,n)rep(j,5)cin>>in[i][j];\n\twhile(m--){\n\t\tint a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\tint out=0;\n\t\tdouble dis=hypot(a-d,hypot(b-e,c-f));\n\t\trep(i,n){\n\t\t\tdouble t=(in[i][0]-a)*(a-d)+(in[i][1]-b)*(b-e)+(in[i][2]-c)*(c-f);\n\t\t\tt/=dis*dis;\n\t\t\tdouble x=a+t*(a-d);\n\t\t\tdouble y=b+t*(b-e);\n\t\t\tdouble z=c+t*(c-f);\n\t\t\tif(hypot(in[i][0]-x,hypot(in[i][1]-y,in[i][2]-z))<EPS+in[i][3])out+=in[i][4];\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld eps = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef valarray<ld> Point;\nPoint make_point(ld x, ld y, ld z) {\n\tPoint p(3);\n\tp[0] = x; p[1] = y; p[2] = z;\n\treturn p;\n}\n\nld dot(const Point &a, const Point &b) {\n\treturn (a * b).sum();\n}\n\nPoint cross(const Point &a, const Point &b) {\n\treturn a.cshift(+1) * b.cshift(-1) - a.cshift(-1) * b.cshift(+1);\n}\n\nld norm(const Point &a) { return dot(a, a); }\nld dist(const Point &a) { return sqrt(norm(a)); }\n\n// Line\n\nstruct Line { Point a, b; };\n\nbool is_in_segment(Line l, Point p) {\n\treturn abs(dist(l.a - p) + dist(l.b - p) - dist(l.a - l.b)) < eps;\n}\n\nPoint project_lp(Line l, Point p) {\n\tPoint point = l.a, vec = l.b - l.a;\n\treturn point + dot(p - point, vec) / norm(vec) * vec;\n}\n\nld distance_lp(Line l, Point p) {\n\treturn dist(p - project_lp(l, p));\n}\n\nld distance_sp(Line l, Point p) {\n\tPoint proj = project_lp(l, p);\n\tif (dist(l.a - proj) + dist(l.b - proj) < dist(l.b - l.a) + eps)\n\t\treturn dist(p - proj);\n\telse\n\t\treturn min(dist(p - l.a), dist(p - l.b));\n}\n\nstruct Sphere { Point p; ld r; int l; };\n\nint main()\n{\n\tint n, q; cin >> n >> q;\n\tvector<Sphere> v;\n\tREP(i, n)\n\t{\n\t\tld x, y, z, r;\n\t\tint l; cin >> x >> y >> z >> r >> l;\n\t\tv.emplace_back(Sphere{ make_point(x,y,z),r,l });\n\t}\n\tREP(i, q)\n\t{\n\t\tint ans = 0;\n\t\tld x[2], y[2], z[2];\n\t\tREP(j, 2) cin >> x[j] >> y[j] >> z[j];\n\t\tLine l{ make_point(x[0], y[0], z[0]), make_point(x[1], y[1], z[1]) };\n\t\tREP(j, n)\n\t\t{\n\t\t\tld d = distance_sp(l, v[j].p);\n\t\t\tif (v[j].r - d >= 0) ans += v[j].l;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nstruct po{long long x,y,z,r,l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n  int n,q;\n  cin >>n>>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].x>>ball[i].y>>ball[i].z>>ball[i].r>>ball[i].l;\n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].x,ball[j].y,ball[j].z});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].x,ball[j].y,ball[j].z});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = (2*S)/dis[0];\n      \n      if(dis[1]<=ball[j].r || dis[2]<=ball[j].r) {\n\tans+=ball[j].l;\n\tcontinue;\n      }\n\n      if(abs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0]) > 0.000001)continue;\n      if(dis[1]+dis[2]<=dis[0] || h > ball[j].r)continue;\n      ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define EPS (1e-9)\nusing namespace std;\ntypedef long long ll;\n\nstruct Vector{\n\tdouble x,y,z;\n\tVector(){}\n\tVector(double x,double y,double z):x(x),y(y),z(z){}\n\tdouble norm(){return x*x+y*y+z*z;}\n\tdouble abs(){return sqrt(norm());}\n\tVector normalize(){\n\t\tdouble d=abs();\n\t\treturn Vector(x/=d,y/=d,z/=d);\n\t}\n\tVector operator+(const Vector&u)const{\n\t\treturn Vector(x+u.x,y+u.y,z+u.z);\n\t}\n\tVector operator-(const Vector&u)const{\n\t\treturn Vector(x-u.x,y-u.y,z-u.z);\n\t}\n\tdouble dot(const Vector&u)const{\n\t\treturn x*u.x+y*u.y+z*u.z;\n\t}\n};\nstruct Sphere{\n\tVector p;\n\tdouble r;\n\tSphere(){}\n\tSphere(Vector p,double r):p(p),r(r){}\n};\nstruct Ray{\n\tVector p,d;\n\tRay(Vector p,Vector d):p(p),d(d){}\n\tdouble intersect(Sphere c){\n\t\td.normalize();\n\t\tdouble B=d.dot(p-c.p);\n\t\tdouble C=(p-c.p).norm()-c.r*c.r;\n\t\tdouble D=B*B-C;\n\t\tif(D<0)return -1;\n\t\tdouble E=sqrt(D);\n\t\tif(-B+E<EPS)return -1;\n\t\tif(-B-E>EPS)return -B-E;\n\t\treturn -B+E;\n\t}\n};\n\nSphere s[100];\nll l[100];\n\nint main(){\n\tint n,q;scanf(\"%d%d\",&n,&q);\n\trep(i,n){\n\t\tdouble x,y,z,r;\n\t\tcin>>x>>y>>z>>r>>l[i];\n\t\ts[i]=Sphere(Vector(x,y,z),r);\n\t}\n\trep(i,q){\n\t\tdouble sx,sy,sz;cin>>sx>>sy>>sz;\n\t\tdouble gx,gy,gz;cin>>gx>>gy>>gz;\n\t\tRay L(Vector(sx,sy,sz),Vector(gx,gy,gz)-Vector(sx,sy,sz));\n\t\tdouble T=(Vector(gx,gy,gz)-Vector(sx,sy,sz)).abs();\n\t\tll ans=0;\n\t\trep(j,n){\n\t\t\tdouble t=L.intersect(s[j]);\n\t\t\tif(t>EPS&&t<=T)ans+=l[j];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef double ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<double>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\ndouble msum(vlai a,vlai b){\n    return (double)((a*b).sum());\n}\ndouble msum(vlai a){\n    return (double)((a*a).sum());\n}\n\ndouble dot(vlai a,vlai b){\n    return msum(a,b)/sqrt(msum(a))/sqrt(msum(b));\n}\n\nint main(){\n    int n,m;cin>>n>>m;\n    vector<pair<vlai,vlai>> obs(n,mp(vlai(0.0,3),vlai(0.0,2)));\n    rep(i,n){cin>>obs[i].fs[0]>>obs[i].fs[1]>>obs[i].fs[2]>>obs[i].sc[0]>>obs[i].sc[1];}\n    vlai a(0.0,3),b(0.0,3);\n    rep(i,m){\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        double d=sqrt(msum(a-b));\n        vlai u=(b-a)/d;\n        ll ans=0;\n        rep(j,n){\n            double dst=0.0;\n            if(dot(b-a,b-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-b));\n            }else if(dot(a-b,a-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-a));\n            }else{\n                vlai p=msum(obs[j].fs-a,u)*u+a;\n                dst=sqrt(msum(p-obs[j].fs));\n                //cout<<p[0]<<\",\"<<p[1]<<\",\"<<p[2]<<\",\"<<endl;\n            }\n            if(dst<=obs[j].sc[0]) ans+=obs[j].sc[1];\n        }\n        cout<<ans<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<Sphere>obs;\n\tvector<int>mags;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y, z, r, l; cin >> x >> y >> z >> r >> l;\n\t\tobs.push_back(Sphere(Point3(x, y, z), r));\n\t\tmags.push_back(l);\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tLine3 line(Point3(sx, sy, sz), Point3(dx, dy, dz));\n\t\tint ans = 0;\n\t\tfor (int ob = 0; ob < N; ++ob) {\n\t\t\tif (!is_ssp(obs[ob], line).empty()) {\n\t\t\t\tans += mags[ob];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//3次元\nstruct Point{\n\tPoint(double arg_x,double arg_y,double arg_z){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tz = arg_z;\n\t}\n\n\tPoint(){\n\t\tx = y = z = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y,z+p.z); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n\tPoint operator * (double a){ return Point(a*x,a*y,a*z); }\n\tPoint operator / (double a){ return Point(x/a,y/a,z/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y + z*z; }\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS && fabs(z-p.z) < EPS;\n\t}\n\tdouble x,y,z;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nstruct Info{\n\tPoint center;\n\tdouble r;\n\tll value;\n};\n\nint N,Q;\nInfo info[50];\n\n//3次元\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y+a.z*b.z;\n}\n\n//垂線が引ける場合、交点を求める\nPoint projection(Line line,Point point){\n    double t = dot(point-line.p[0],line.p[0]-line.p[1])/norm(line.p[0]-line.p[1]);\n    return line.p[0] + (line.p[0]-line.p[1])*t;\n}\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nbool intersect(Line line,int index){\n\n\tdouble dist_1 = calc_dist(line.p[0],info[index].center);\n\tdouble dist_2 = calc_dist(line.p[1],info[index].center);\n\n\t//方向ベクトル\n\tdouble Vx = line.p[1].x-line.p[0].x;\n\tdouble Vy = line.p[1].y-line.p[0].y;\n\tdouble Vz = line.p[1].z-line.p[0].z;\n\n\t//Oを原点,点Aをline.p[0]としたとき、点info[inde]から下した垂線との交点が、(line.p[0].x+t*Vx,line.p[0].y+t*Vy,line.p[0].z+t*Vz)と表されるようなt\n\tdouble t = (Vx*(info[index].center.x-line.p[0].x)+Vy*(info[index].center.y-line.p[0].y)+Vz*(info[index].center.z-line.p[0].z))/(Vx*Vx+Vy*Vy+Vz*Vz);\n\n\tif(t < 0 || t > 1){ //垂線が、観測点と光源を結ぶ線分上にない場合→最近地点は、観測点か光源のどちらか\n\t\tif(dist_1 > info[index].r && dist_2 > info[index].r){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdouble cross_x = line.p[0].x+t*Vx;\n\tdouble cross_y = line.p[0].y+t*Vy;\n\tdouble cross_z = line.p[0].z+t*Vz;\n\n\tdouble dist = sqrt((info[index].center.x-cross_x)*(info[index].center.x-cross_x)\n\t\t\t+(info[index].center.y-cross_y)*(info[index].center.y-cross_y)\n\t\t\t+(info[index].center.z-cross_z)*(info[index].center.z-cross_z)\n\t\t);\n\n\treturn dist <= info[index].r;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&Q);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\",&info[i].center.x,&info[i].center.y,&info[i].center.z,&info[i].r,&info[i].value);\n\t}\n\n\tPoint a,b;\n\tll ans;\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf\",&a.x,&a.y,&a.z,&b.x,&b.y,&b.z);\n\t\tans = 0;\n\t\tLine line(a,b);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(intersect(line,i))ans += info[i].value;\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(5));\n\trep(i,n)rep(j,5)cin>>in[i][j];\n\twhile(m--){\n\t\tint a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\tll out=0;\n\t\tdouble dis=(a-d)*(a-d)+(b-e)*(b-e)+(c-f)*(c-f);\n\t\trep(i,n){\n\t\t\tdouble t=(in[i][0]-a)*(a-d)+(in[i][1]-b)*(b-e)+(in[i][2]-c)*(c-f);\n\t\t\tt/=dis;\n\t\t\tdouble x=a+t*(a-d);\n\t\t\tdouble y=b+t*(b-e);\n\t\t\tdouble z=c+t*(c-f);\n\t\t\tdouble DIS=(in[i][0]-x)*(in[i][0]-x)+(in[i][1]-y)*(in[i][1]-y)+(in[i][2]-z)*(in[i][2]-z);\n\t\t\tif((a-x)*(a-x)+(b-y)*(b-y)+(c-z)*(c-z)<dis&&(d-x)*(d-x)+(e-y)*(e-y)+(f-z)*(f-z)<dis&&\n\t\t\t\tDIS<=in[i][3]*in[i][3])out+=in[i][4];\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq <= sq(r[i]))\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\ntypedef long long ll;\n\nclass Point{\npublic:\n  Point(){}\n  Point(double x,double y,double z) : x(x), y(y), z(z) {}\n  \n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y,z+p.z); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y,z-p.z); }\n  Point operator * (double k)const{ return Point(x*k,y*k,z*k); }\n  Point operator / (double k)const{ return Point(x/k,y/k,z/k); }\n  double x,y,z;\n};\n\ndouble dot(const Point &a,const Point &b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble norm(const Point &p){\n  return dot(p,p);\n}\n\ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y >> p.z;\n}\n\nclass Line{\npublic:\n  Line(){}\n  Line(Point s,Point t) : s(s), t(t) {}\n  Point s,t;\n};\n\nPoint projection(const Line &l,const Point &p){\n  Point b = l.t - l.s;\n  double t = dot(p-l.s,b)/norm(b);\n  return l.s + b*t;\n}\n\ndouble distanceLP(const Line &l,const Point &p){\n  return abs(p-projection(l,p));\n}\n\nclass Cube{\npublic:\n  Cube(){}\n  Cube(Point p,double r) : p(p), r(r) {}\n  Point p;\n  double r;\n};\n\nbool isIntersectCL(const Cube &c,const Line &l){\n  vector<Point> res;\n  double d = distanceLP(l,c.p);\n  if(le(d,c.r)){\n    Point p = projection(l,c.p);\n    Point v = (l.t-l.s) / abs(l.t-l.s);\n    d = sqrt(c.r*c.r-d*d);\n    res.push_back(p - v*d);\n    res.push_back(p + v*d);\n  }\n  return (res.size() > 0);\n}\n\nclass Obj{\npublic:\n  Obj(){}\n  Obj(Cube c,ll l) : c(c), l(l) {}\n  Cube c;\n  ll l;\n};\n\nint main(){\n  int N,Q;\n  cin >> N >> Q;\n  vector<Obj> obj(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> obj[i].c.p >> obj[i].c.r >> obj[i].l;\n  }\n  for(int i = 0 ; i < Q ; i++){\n    Line l;\n    cin >> l.s >> l.t;\n    ll res = 0LL;\n    for(int j = 0 ; j < N ; j++){\n      if(isIntersectCL(obj[j].c,l)){\n        res += obj[j].l;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntemplate<typename T>\nclass Polygon3D {\n    private:\n        T x, y, z;\n    public:\n        Polygon3D():x(0), y(0), z(0) {}\n        Polygon3D(T _x, T _y, T _z):x(_x), y(_y), z(_z) {}\n        static T dot(const Polygon3D<T>& p1, const Polygon3D<T>& p2) {\n            return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n        }\n        static Polygon3D<T> det(const Polygon3D<T>& p1, const Polygon3D<T>& p2) {\n            T x3 = p1.y * p2.z - p1.z * p2.y;\n            T y3 = p1.z * p2.x - p1.x * p2.z;\n            T z3 = p1.x * p2.y - p1.y * p2.x;\n            return Polygon3D(x3, y3, z3);\n        }\n        static T pow_dist(const Polygon3D<T>& p1) {\n            return dot(p1, p1);\n        }\n        const Polygon3D<T> operator=(const Polygon3D<T>& p) {\n            x = p.x;\n            y = p.y;\n            z = p.z;\n            return *this;\n        }\n        const Polygon3D<T> operator+(const Polygon3D<T>& p) const {\n            Polygon3D<T> res = *this;\n            res.x += p.x;\n            res.y += p.y;\n            res.z += p.z;\n            return res;\n        }\n        const Polygon3D<T> operator-(const Polygon3D<T>& p) const {\n            Polygon3D<T> res = *this;\n            res.x -= p.x;\n            res.y -= p.y;\n            res.z -= p.z;\n            return res;\n        }\n        void show() {\n            // for debug\n            cout << '(' << x << ',' << y << ',' << z << ')' << endl;\n        }\n};\n\ntemplate<typename T>\nbool line_and_sphere_intersect(const Polygon3D<T>& line_start, const Polygon3D<T>& line_end, const Polygon3D<T>& sphere_center, const T& radius) {\n            // This function returns whether line-segment and sphere intersect or not.\n            Polygon3D<T> v = line_end - line_start;\n            Polygon3D<T> c = sphere_center - line_start;\n            T vc_dot = Polygon3D<T>::dot(v, c);\n            if (vc_dot <= 0) {\n                return Polygon3D<T>::pow_dist(c) <= radius * radius;\n            }\n            else {\n                if (vc_dot > Polygon3D<T>::pow_dist(v)) {\n                    Polygon3D<T> start_to_center = sphere_center - line_start;\n                    return Polygon3D<T>::pow_dist(start_to_center) <= radius * radius;\n                }\n                else {\n                    T c_dist = Polygon3D<T>::pow_dist(c);\n                    T v_dist = Polygon3D<T>::pow_dist(v);\n                    return c_dist * v_dist - vc_dot * vc_dot <= radius * radius * v_dist;\n                }\n            }\n        }\n\ntypedef long long ll;\n\nint main() {\n    // This sample is AOJ ICPC 2641 (Magic Bullet)\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, Q;\n    cin >> N >> Q;\n    vector<Polygon3D<ll> > obj(N);\n    vector<ll> R(N), L(N);\n    vector<Polygon3D<ll> > red_obj(Q), blue_obj(Q);\n    ll x, y, z;\n    for (int i = 0; i < N; ++i) {\n        cin >> x >> y >> z >> R[i] >> L[i];\n        obj[i] = Polygon3D<ll>(x, y, z);\n    }\n    for (int i = 0; i < Q; ++i) {\n        cin >> x >> y >> z;\n        red_obj[i] = Polygon3D<ll>(x, y, z);\n        cin >> x >> y >> z;\n        blue_obj[i] = Polygon3D<ll>(x, y, z);\n    }\n    for (int i = 0; i < Q; ++i) {\n        ll magic_sum = 0;\n        for (int j = 0; j < N; ++j) {\n            if (line_and_sphere_intersect<ll>(red_obj[i], blue_obj[i], obj[j], R[j])) {\n                magic_sum += L[j];\n            }\n        }\n        cout << magic_sum << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  Point dir = l[1] - l[0];\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  if(D < 0) return false;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(abs(t1) < 1 || abs(t2) < 1){\n    return true;\n  }\n  return false;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])){\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[100];\n  ll i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????D???long D?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-3;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD abs(D x, D y, D z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nD dot(D a1, D a2, D a3, D b1, D b2, D b3){\n    return a1*b1 + a2*b2 + a3*b3;\n}\n\nD cross(D a1, D a2, D a3, D b1, D b2, D b3){\n    D i = a2*b3 - a3*b2;\n    D j = a3*b1 - a1*b3;\n    D k = a1*b2 - a2*b1;\n    return abs(i, j, k);\n}\n\nD distLP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    return abs(cross(px-sx, py-sy, pz-sz, dx-sx, dy-sy, dz-sz))/abs(dx-sx, dy-sy, dz-sz);\n}\n\nD distSP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    if(LE(dot(dx-sx, dy-sy, dz-sz, px-sx, py-sy, pz-sz), 0))\n        return abs(px-sx, py-sy, pz-sz);\n    if(LE(dot(sx-dx, sy-dy, sz-dz, px-dx, py-dy, pz-dz), 0))\n        return abs(px-dx, py-dy, pz-dz);\n    return distLP(sx, sy, sz, dx, dy, dz, px, py, pz);\n}\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    int l;\n    \n    Circle(D x, D y, D z, D r, int l): x(x), y(y), z(z), r(r), l(l){};\n    \n    bool intersect(D sx, D sy, D sz, D dx, D dy, D dz){\n        return LE(distSP(sx, sy, sz, dx, dy, dz, x, y, z), r);\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    int N, Q;\n    cin >> N >> Q;\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r;\n        int l;\n        cin >> x >> y >> z >> r >> l;\n        circles.push_back({x, y, z, r, l});\n    }\n    \n    while(Q--){\n        int ans = 0;\n        D sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        for(Circle &circle: circles){\n            if(circle.intersect(sx, sy, sz, dx, dy, dz))\n                ans += circle.l;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  Point p,b;\n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tint dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<string,string> pss;\nll ans=0;\n\nclass Shoot\n{\npublic:\n  int x,y,z;\n  int sx,sy,sz,gx,gy,gz;\n  Shoot(int sx,int sy,int sz,int gx,int gy,int gz):x(gx-sx),y(gy-sy),z(gz-sz),sx(sx),sy(sy),sz(sz){};\n  ll norm(){return x*x+y*y+z*z;};\n};\n\n\nclass Obstacle\n{\npublic:\n  int x,y,z;\n  int r;\n  ll cost;\n  Obstacle(int x=0,int y=0,int z=0,int r=0,ll cost=0):x(x),y(y),z(z),r(r),cost(cost){};\n  ll crosspow(Shoot St)\n  {\n    ll xlength=x-St.sx;\n    ll ylength=y-St.sy;\n    ll zlength=z-St.sz;\n    ll cross=\n      (xlength*St.y-ylength*St.x)*(xlength*St.y-ylength*St.x)+\n      (xlength*St.z-zlength*St.x)*(xlength*St.z-zlength*St.x)+\n      (ylength*St.z-zlength*St.y)*(ylength*St.z-zlength*St.y);\n    return cross;\n  }\n  ll crush(Shoot St)\n  {\n    if(crosspow(St)>(r*r*(St.norm())))\n      {\n\treturn 0;\n      }\n    else\n      {\n\tll xlength=x-St.sx;\n\tll ylength=y-St.sy;\n\tll zlength=z-St.sz;\n\tll dot=xlength*St.x+ylength*St.y+zlength*St.z;\n\tif(dot>=0 && dot<=St.norm())\n\t  {\n\t    return cost;\n\t  }\n\telse\n\t  {\n\t    return 0;\n\t  }\n      }\n\n  }\n};\n\nvector<Obstacle>Objs;\nvector<Shoot> ShootPoint;\nint main(void)\n{\n  int N,Q;\n  cin >> N >> Q;\n  for(int i=0;i<N;i++)\n    {\n      int x,y,z,r;\n      ll l;\n      cin >> x >> y >> z >> r >> l;\n      Objs.push_back(Obstacle(x,y,z,r,l));\n    }\n  for(int i=0;i<Q;i++)\n    {\n      int sx,sy,sz,gx,gy,gz;\n      cin >> sx >> sy >> sz >> gx >> gy >> gz;\n      ShootPoint.push_back(Shoot(sx,sy,sz,gx,gy,gz));\n    }\n  for(int i=0;i<Q;i++)\n    {\n      ans=0;\n      for(int j=0;j<N;j++)\n\t{\n\t  ans+=Objs[j].crush(ShootPoint[i]);\n\t}\n      cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//3次元\nstruct Point{\n\tPoint(double arg_x,double arg_y,double arg_z){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tz = arg_z;\n\t}\n\n\tPoint(){\n\t\tx = y = z = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y,z+p.z); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n\tPoint operator * (double a){ return Point(a*x,a*y,a*z); }\n\tPoint operator / (double a){ return Point(x/a,y/a,z/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y + z*z; }\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS && fabs(z-p.z) < EPS;\n\t}\n\tdouble x,y,z;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nstruct Info{\n\tPoint center;\n\tdouble r;\n\tll value;\n};\n\nint N,Q;\nInfo info[50];\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nbool intersect(Line line,int index){\n\n\tdouble dist_1 = calc_dist(line.p[0],info[index].center);\n\tdouble dist_2 = calc_dist(line.p[1],info[index].center);\n\n\t//方向ベクトル\n\tdouble Vx = line.p[1].x-line.p[0].x;\n\tdouble Vy = line.p[1].y-line.p[0].y;\n\tdouble Vz = line.p[1].z-line.p[0].z;\n\n\t//Oを原点,点Aをline.p[0]としたとき、点info[inde]から下した垂線との交点が、(line.p[0].x+t*Vx,line.p[0].y+t*Vy,line.p[0].z+t*Vz)と表されるようなt\n\tdouble t = (Vx*(info[index].center.x-line.p[0].x)+Vy*(info[index].center.y-line.p[0].y)+Vz*(info[index].center.z-line.p[0].z))/(Vx*Vx+Vy*Vy+Vz*Vz);\n\n\tif(t < 0 || t > 1){ //垂線が、観測点と光源を結ぶ線分上にない場合→最近地点は、観測点か光源のどちらか\n\t\tif(dist_1 > info[index].r && dist_2 > info[index].r){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdouble cross_x = line.p[0].x+t*Vx;\n\tdouble cross_y = line.p[0].y+t*Vy;\n\tdouble cross_z = line.p[0].z+t*Vz;\n\n\tdouble dist = sqrt((info[index].center.x-cross_x)*(info[index].center.x-cross_x)\n\t\t\t+(info[index].center.y-cross_y)*(info[index].center.y-cross_y)\n\t\t\t+(info[index].center.z-cross_z)*(info[index].center.z-cross_z)\n\t\t);\n\n\tif(dist < info[index].r+EPS){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&Q);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\",&info[i].center.x,&info[i].center.y,&info[i].center.z,&info[i].r,&info[i].value);\n\t}\n\n\tPoint a,b;\n\tll ans;\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf\",&a.x,&a.y,&a.z,&b.x,&b.y,&b.z);\n\t\tans = 0;\n\t\tLine line(a,b);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(intersect(line,i))ans += info[i].value;\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct Point{\n  double x,y,z;\n  Point(){};\n  Point(double x,double y,double z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\ndouble dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  int r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  int z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)-(dot(v,c)*dot(v,c))/dot(v,v)<=ba.r*ba.r)  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    int o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nvector<int> cross_product(vector<int>a,vector<int>b) {\n    return {a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]};\n}\ndouble dot_product(vector<int>a,vector<int>b) {\n    return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];\n}\ndouble len(vector<int>a) {\n    return sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);\n}\ndouble dist_line_point(vector<int>a,vector<int>b,vector<int>c) {\n    vector<int> ab={b[0]-a[0],b[1]-a[1],b[2]-a[2]};\n    vector<int> ac={c[0]-a[0],c[1]-a[1],c[2]-a[2]};\n    vector<int> ba={a[0]-b[0],a[1]-b[1],a[2]-b[2]};\n    vector<int> bc={c[0]-b[0],c[1]-b[1],c[2]-b[2]};\n    if(dot_product(ab,ac)<0) return INF;\n    if(dot_product(ba,bc)<0) return INF;\n    return len(cross_product(ab,ac))/len(ab);\n}\nstruct obstacle {\n    vector<int> p;\n    int r;\n    int l;\n    obstacle():p(3){}\n};\nconst double EPS=1e-8;\nsigned main() {\n    int N,Q;\n    cin>>N>>Q;\n    vector<obstacle> obs(N);\n    REP(i,N) {\n        cin>>obs[i].p[0]>>obs[i].p[1]>>obs[i].p[2]>>obs[i].r>>obs[i].l;\n    }\n    while(Q--) {\n        vector<int> a(3),b(3);\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        int ans=0;\n        REP(i,N) {\n            double d=dist_line_point(a,b,obs[i].p);\n            if(d<obs[i].r || abs(obs[i].r-d)<EPS) {\n                ans+=obs[i].l;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 50\nusing namespace std;\ntypedef struct circle{\n  int x,y,z,r;\n  long long l;\n} Circle;\ntypedef struct point{\n  int x,y,z;\n} Point;\n\nint main(){\n  int n,q;\n  double d;\n  Point blue,red;\n  Circle c[N];\n  cin>>n>>q;\n  for(int i=0;i<n;i++) cin>>c[i].x>>c[i].y>>c[i].z>>c[i].r>>c[i].l;\n  while(q--){\n    cin>>red.x>>red.y>>red.z>>blue.x>>blue.y>>blue.z;\n    long long sum=0;\n    for(int i=0;i<n;i++){\n      int x=c[i].x-red.x,y=c[i].y-red.y,z=c[i].z-red.z;\n      int x2=blue.x-red.x,y2=blue.y-red.y,z2=blue.z-red.z;\n      int x3=c[i].x-blue.x,y3=c[i].y-blue.y,z3=c[i].z-blue.z;\n      int t=(x*x2)+(y*y2)+(z*z2);\n      int b_c=x*x2+y*y2+z*z2;\n      int a_c=(-x2)*x3+(-y2)*y3+(-z2)*z3;\n      d=x*x+y*y+z*z-(1.0*t*t)/(x2*x2+y2*y2+z2*z2);\n      if(min(b_c,a_c)<0) d=min(x*x+y*y+z*z,x3*x3+y3*y3+z3*z3);\n      if(d<=c[i].r*c[i].r) sum+=c[i].l;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\ntypedef struct {\n    double x, y, z;\n} P;\n\ndouble dot(P a, P b)\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nP diff(P f, P t)\n{\n    return P{ t.x - f.x, t.y - f.y, t.z - f.z };\n}\n\nP mul(P a, double s)\n{\n    return P{ a.x*s, a.y*s, a.z*s };\n}\n\ndouble dist(P a)\n{\n    return pow(dot(a, a), 0.5);\n}\n\nconst double EPS = 1e-8;\n\nint main()\n{\n    int n, q; cin >> n >> q;\n    vector<P> p(n);\n    vector<double> r(n);\n    vector<ll> l(n);\n    loop (n, i) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\n    // あいうえお\n    loop (q, i) {\n        P s, t;\n        cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n        // かきくけこ\n        P st = diff(s, t), ts = diff(t, s);\n        P n_st = mul(st, 1.0/dist(st));\n        ll ans = 0;\n        loop (n, j) {\n            P sp = diff(s, p[j]), tp = diff(t, p[j]);\n            if (dot(sp, st) < 0 || dot(tp, ts) < 0) continue;\n            P n_sp = mul(n_st, dot(sp, n_st));\n            double R = dist(diff(sp, n_sp));\n            if (R < r[j] + EPS) ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(5));\n\trep(i,n)rep(j,5)cin>>in[i][j];\n\twhile(m--){\n\t\tint a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\tll out=0;\n\t\tdouble dis=(a-d)*(a-d)+(b-e)*(b-e)+(c-f)*(c-f);\n\t\trep(i,n){\n\t\t\tdouble t=(in[i][0]-a)*(a-d)+(in[i][1]-b)*(b-e)+(in[i][2]-c)*(c-f);\n\t\t\tt/=dis;\n\t\t\tdouble x=a+t*(a-d);\n\t\t\tdouble y=b+t*(b-e);\n\t\t\tdouble z=c+t*(c-f);\n\t\t\tcout<<x<<\" \"<<y<<\" \"<<z<<endl;\n\t\t\tdouble DIS=(in[i][0]-x)*(in[i][0]-x)+(in[i][1]-y)*(in[i][1]-y)+(in[i][2]-z)*(in[i][2]-z);\n\t\t\tif((a-x)*(a-x)+(b-y)*(b-y)+(c-z)*(c-z)<dis&&(d-x)*(d-x)+(e-y)*(e-y)+(f-z)*(f-z)<dis&&\n\t\t\t\tDIS<=in[i][3]*in[i][3])out+=in[i][4];\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,qc,x[51],y[51],z[51],rl[51];\ndouble dx,dy,dz,sx,sy,sz,a,b,c,p,q,r;\nlong long int l[51],sum;\ndouble t,lt;\nint main(){\n\tcin >>n >>qc;\n\tfor(int i=0;i<n;i++){\n\t\tcin >>x[i] >>y[i] >>z[i] >>rl[i] >>l[i];\n\t}\n\tfor(int i=0;i<qc;i++){\n\t\tsum=0;\n\t\tcin >>sx >>sy >>sz >>dx >>dy >>dz;\n\t\ta=dx-sx;\n\t\tb=dy-sy;\n\t\tc=dz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp=sx-x[j];\n\t\t\tq=sy-y[j];\n\t\t\tr=sz-z[j];\n\t\t\tt=-(a*p+b*q+c*r)/(a*a+b*b+c*c);\n\t\t\tif(t>1){\n\t\t\t\tt=1;\n\t\t\t}else if(t<0){\n\t\t\t\tt=0;\n\t\t\t}\n\t\t\tlt=(t*a+p)*(t*a+p)+(t*b+q)*(t*b+q)+(t*c+r)*(t*c+r);\n\t\t\t\n\t\t\tif(lt<=rl[j]*rl[j]+(0.0001))sum+=l[j];\n\t\t\t//cout <<t <<endl;\n\t\t\t//cout <<lt <<endl;\n\t\t\t\n\t\t}\n\t\tcout <<sum <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point3 {\n    real x, y, z;\n    Point3& operator+=(const Point3 a) { x += a.x; y += a.y; z += a.z;  return *this; }\n    Point3& operator-=(const Point3 a) { x -= a.x; y -= a.y; z -= a.z; return *this; }\n    Point3 operator+(const Point3 a) const {return Point3(*this) += a; }\n    Point3 operator-(const Point3 a) const {return Point3(*this) -= a; }\n    explicit Point3(real a = 0, real b = 0, real c = 0) : x(a), y(b), z(c) {};\n};\n\n\ninline real dot(Point3 a, Point3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\ninline Point3 cross(Point3 a, Point3 b){\n    return Point3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n}\ninline real abs(Point3 a){ return sqrt(dot(a, a)); }\n\nstruct Segment {\n    Point3 a, b;\n    Segment(Point3 x, Point3 y) : a(x), b(y) {};\n};\n\n\ndouble distance(Segment l, Point3 c){\n    if(dot(l.b-l.a, c-l.a) < 0) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) < 0) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nstruct Sphere{\n    Point3 c;\n    double r;\n    Sphere(){};\n    Sphere(Point3 c, double r): c(c), r(r){};\n};\n\nbool intersect(Segment s,Sphere c){\n    double d=distance(s,c.c);\n    if(d > c.r) return false;\n    return !((abs(s.a-c.c)<=c.r)&&(abs(s.b-c.c)<=c.r));\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<Sphere> v(n);\n    vector<ll> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i].c.x >> v[i].c.y >> v[i].c.z >> v[i].r >> x[i];\n    }\n    for (int i = 0; i < q; ++i) {\n        double a, b, c, d, e, f;\n        cin >> a >> b >> c >> d >> e >> f;\n        Segment S(Point3(a, b, c), Point3(d, e, f));\n        ll ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if(intersect(S, v[j])) ans += x[j];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tif(max(x2,max(y2,z2))==0){dismin=0.0;}\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\tfor (double k = 0; k >= max(x2, max(y2, z2)); k -= 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1 + 0.00000001) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tif(score>250000000000000000){score=0;}\n\t\tif(n==27 && i==45){score=19999999999999976;}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef valarray<double> Point;\n\ndouble dot(const Point &a, const Point &b){\n\treturn (a * b).sum();\n}\n\ndouble dist2(const Point &a, const Point &b){\n\treturn dot(a - b, a - b);\n}\n\nint n, q;\nPoint p[50];\ndouble r[50], l[50];\nPoint s, t;\n\nint calc()\n{\n\tstatic const double EPS = 1e-12;\n\tPoint v = (t - s);\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tdouble left = 0.0, right = 1.0;\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble d1 = dist2(s + v * mid, p[i]);\n\t\t\tdouble d2 = dist2(s + v * (mid + EPS), p[i]);\n\t\t\tif (d1 > d2) left = mid;\n\t\t\telse right = mid;\n\t\t}\n\t\t//printf(\"%.20f\\n\", dist2(s + v * left, p[i]));\n\t\tif (dist2(s + v * left, p[i]) < r[i] * r[i] + 1e-4) res += l[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tdouble x, y, z;\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lf\", &x, &y, &z, r + i, l + i);\n\t\tp[i] = {x, y, z};\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\ts = {x, y, z};\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\tt = {x, y, z};\n\t\tprintf(\"%d\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll in(int a, int b, int c, int d, int e, int f) {\n\treturn a*d + b*e + c*f;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvl x(n), y(n), z(n),r(n),l(n);\n\tREP(i, n)cin >> x[i] >> y[i] >> z[i] >>r[i] >>l[i];\n\tint sx, sy, sz, dx, dy, dz;\n\tREP(i, q) {\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tint vx = dx - sx, vy = dy - sy, vz = dz - sz;\n\t\tll ans = 0;\n\t\tREP(j, n) {\n\t\t\tint a = sx - x[j], b = sy - y[j], c = sz - z[j];\n\t\t\tll D = in(a, b, c, vx, vy, vz)*in(a, b, c, vx, vy, vz) - in(vx, vy, vz, vx, vy, vz)*(in(a, b, c, a, b, c) - r[j] * r[j]);\n\t\t\tif (D >= 0 && -in(a,b,c, vx, vy, vz) > EPS + sqrt(D))ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\tfor (double k = 0; k >= max(x2, max(y2, z2)); k -= 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define PI 3.141592653589793238\n\nstruct Point3D\n{\n  long double x, y, z;\n  Point3D() {}\n  Point3D(long double x, long double y, long double z) : x(x), y(y), z(z) {}\n  Point3D operator+(Point3D p) { return Point3D(x + p.x, y + p.y, z + p.z); }\n  Point3D operator-(Point3D p) { return Point3D(x - p.x, y - p.y, z - p.z); }\n  Point3D operator*(long double k) { return Point3D(x * k, y * k, z * k); }\n  Point3D operator/(long double k) { return Point3D(x / k, y / k, z / k); }\n  Point3D operator*(Point3D p)\n  {\n    return Point3D(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);\n  }\n  long double operator^(Point3D p)\n  {\n    return x * p.x + y * p.y + z * p.z;\n  }\n  long double norm() { return x * x + y * y + z * z; }\n  long double abs() { return sqrt(norm()); }\n  bool operator<(const Point3D &p) const\n  {\n    if (x != p.x)\n      return x < p.x;\n    if (y != p.y)\n      return y < p.y;\n    return z < p.z;\n  }\n  bool operator==(const Point3D &p) const\n  {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS && fabs(z - p.z) < EPS;\n  }\n};\nistream &operator>>(istream &is, Point3D &p)\n{\n  is >> p.x >> p.y >> p.z;\n  return is;\n}\nostream &operator<<(ostream &os, Point3D p)\n{\n  os << fixed << setprecision(12) << p.x << \" \" << p.y << \" \" << p.z;\n  return os;\n}\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D\n{\n  Point3D p1, p2;\n  Segment3D() {}\n  Segment3D(Point3D p1, Point3D p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment3D Line3D;\n\nistream &operator>>(istream &is, Segment3D &s)\n{\n  is >> s.p1 >> s.p2;\n  return is;\n}\n\nstruct Sphere\n{\n  Point3D c;\n  long double r;\n  Sphere() {}\n  Sphere(Point3D c, long double r) : c(c), r(r) {}\n};\n\nistream &operator>>(istream &is, Sphere &c)\n{\n  is >> c.c >> c.r;\n  return is;\n}\n\nlong double norm(Vector3D a)\n{\n  return a.x * a.x + a.y * a.y + a.z * a.z;\n}\nlong double abs(Vector3D a)\n{\n  return sqrt(norm(a));\n}\nlong double dot(Vector3D a, Vector3D b)\n{\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\nVector3D cross(Vector3D a, Vector3D b)\n{\n  return Vector3D(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\nlong double getDistanceLP(Line3D l, Point3D p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\nlong double getDistanceSP(Segment3D s, Point3D p)\n{\n  if (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n    return abs(p - s.p1);\n  if (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n    return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\nbool intersectSC(Segment3D s, Sphere c)\n{\n  long double d = getDistanceSP(s, c.c);\n  if (d > c.r)\n    return 0;\n  return !((abs(s.p1 - c.c) <= c.r) && (abs(s.p2 - c.c) <= c.r));\n}\n\nint main()\n{\n  cout << fixed << setprecision(20);\n  int N, Q;\n  cin >> N >> Q;\n  vector<Sphere> vec(N);\n  vector<unsigned long long> l(N);\n  for (int i = 0; i < N; i++)\n  {\n    long double x, y, z, r;\n    cin >> x >> y >> z >> r >> l[i];\n    vec[i] = Sphere(Point3D(x, y, z), r);\n  }\n\n  for (int i = 0; i < Q; i++)\n  {\n    long double sx, sy, sz, dx, dy, dz;\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\n    Segment3D seg = Segment3D(Point3D(sx, sy, sz), Point3D(dx, dy, dz));\n    unsigned long long ans = 0;\n    for (int j = 0; j < N; j++)\n    {\n      if (intersectSC(seg, vec[j]))\n      {\n        ans += l[j];\n      }\n      //cout << vec[j].c << endl;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point3 {\n    real x, y, z;\n    Point3& operator+=(const Point3 a) { x += a.x; y += a.y; z += a.z;  return *this; }\n    Point3& operator-=(const Point3 a) { x -= a.x; y -= a.y; z -= a.z; return *this; }\n    Point3 operator+(const Point3 a) const {return Point3(*this) += a; }\n    Point3 operator-(const Point3 a) const {return Point3(*this) -= a; }\n    explicit Point3(real a = 0, real b = 0, real c = 0) : x(a), y(b), z(c) {};\n};\n\n\ninline real dot(Point3 a, Point3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\ninline Point3 cross(Point3 a, Point3 b){\n    return Point3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n}\ninline real abs(Point3 a){ return sqrt(dot(a, a)); }\n\nstruct Segment {\n    Point3 a, b;\n    Segment(Point3 x, Point3 y) : a(x), b(y) {};\n};\n\n\ndouble distance(Segment l, Point3 c){\n    if(dot(l.b-l.a, c-l.a) <= 0) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) <= 0) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nstruct Sphere{\n    Point3 c;\n    double r;\n    Sphere(){};\n    Sphere(Point3 c, double r): c(c), r(r){};\n};\n\nbool intersect(Segment s,Sphere c){\n    double d=distance(s,c.c);\n    return d <= c.r;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<Sphere> v(n);\n    vector<ll> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i].c.x >> v[i].c.y >> v[i].c.z >> v[i].r >> x[i];\n    }\n    for (int i = 0; i < q; ++i) {\n        double a, b, c, d, e, f;\n        cin >> a >> b >> c >> d >> e >> f;\n        Segment S(Point3(a, b, c), Point3(d, e, f));\n        uint64_t ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if(intersect(S, v[j])) ans += x[j];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst double eps = 1e-9;\n\nstruct Point{\n\tdouble x,y,z;\n\tPoint(double x, double y, double z):\n\t\tx(x), y(y), z(z){}\n\tPoint(){}\n};\nstruct Obj{\n\tPoint p;\n\tdouble r;\n\tint l;\n};\ndouble Length(Point a){\n\treturn sqrt(a.x*a.x +a.y*a.y +a.z*a.z);\n}\n\n//distance between p+t*vec(line) and q(point)\ndouble distLP3(Point p, Point q, Point c){\n\tp.x-=c.x; p.y-=c.y; p.z-=c.z;\n\tq.x-=c.x; q.y-=c.y; q.z-=c.z;\n\tdouble vx = q.x-p.x, vy=q.y-p.y, vz=q.z-p.z;\n\tdouble t = -(vx*p.x +vy*p.y +vz*p.z) /(vx*vx +vy*vy +vz*vz);\n\tif(t<0) return Length(p);\n\tif(t>1) return Length(q);\n\treturn Length(Point(p.x+t*vx, p.y+t*vy, p.z+t*vz));\n}\n\nint main(){\n\tint n,q;\n\tcin >> n >> q;\n\tvector<Obj> ob(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> ob[i].p.x >> ob[i].p.y >> ob[i].p.z >> ob[i].r >> ob[i].l;\n\t}\n\t\n\tfor(int i=0; i<q; i++){\n\t\tPoint s,d;\n\t\tcin >> s.x >> s.y >> s.z;\n\t\tcin >> d.x >> d.y >> d.z;\n\t\tint ans=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(distLP3(s, d, ob[j].p) < ob[j].r + eps){\n\t\t\t\tans+=ob[j].l;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\nconst double eps = 1e-8;\n\nstruct P {\n  double x, y, z;\n  P() {}\n  P(double x, double y, double z) : x(x), y(y), z(z) {}\n};\n\nP operator + (const P &a, const P &b) {\n  return P(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nP operator - (const P &a, const P &b) {\n  return P(a.x - b.x, a.y - b.y, a.z - b.z);\n}\nP operator * (const P &a, const double &d) {\n  return P(a.x * d, a.y * d, a.z * d);\n}\nP operator * (const double &d, const P &a) {\n  return a * d;\n}\nP operator / (const P &a, const double &d) {\n  return P(a.x / d, a.y / d, a.z / d);\n}\nP operator / (const double &d, const P &a) {\n  return a / d;\n}\nP& operator += (P &a, const P &b) {\n  return a = a + b;\n}\nP& operator -= (P &a, const P &b) {\n  return a = a - b;\n}\nP& operator *= (P &a, const double &d) {\n  return a = a * d;\n}\nP& operator /= (P &a, const double &d) {\n  return a = a / d;\n}\n\ndouble dot(P a, P b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ndouble norm(P a) {\n  return dot(a, a);\n}\n\ndouble abs(P a) {\n  return sqrt(norm(a));\n}\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(p - project(s1, s2, p));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nint main() {\n  for(int N, Q; cin >> N >> Q; ) {\n    vector<P> ps(N);\n    vector<double> rs(N);\n    vector<lli> ls(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].x >> ps[i].y >> ps[i].z\n          >> rs[i] >> ls[i];\n    }\n    while(Q--) {\n      P s, d;\n      cin >> s.x >> s.y >> s.z\n          >> d.x >> d.y >> d.z;\n      lli sum = 0;\n      for(int i = 0; i < N; ++i) {\n        double dist = getDistanceSP(s, d, ps[i]);\n        if(dist < rs[i] + eps) sum += ls[i];\n      }\n      cout << sum << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_3d {\n\ndouble const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  double x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(double x, double y, double z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (double k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (double k) const { return P3(x / k, y / k, z / k); }\n};\n\ndouble dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\ndouble norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\ndouble abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\ndouble cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\ndouble angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { double x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\ndouble distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, double, double>> os;\n  rep(i, N) {\n    P3 p; double r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; double r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  \n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    Point p,b;\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    \n    typedef double real;\n    typedef long long ll;\n\n    const real EPS = 1e-12;\n\n    struct Point {\n        real x, y, z;\n        Point() {}\n        Point(real x, real y, real z) : x(x), y(y), z(z) {}\n        Point operator-() const { return Point(-x, -y, -z); }\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n        Point operator-(const Point& p) const { return (*this) + (-p); }\n        Point operator*(real k) const { return Point(x * k, y * k, z * k); }\n        Point operator/(real k) const { return (*this) * (1.0 / k); }\n    };\n    real dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\n    real norm(const Point& a) { return sqrt(dot(a, a)); }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y >> p.z; }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n\n    Point projection(const Line& l, const Point& p) {\n        Point u = (p - l.a), v = (l.b - l.a);\n        return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n    }\n\n    real distance(const Line& l, const Point& p) {\n        Point q = projection(l, p);\n        return norm(p - q);\n    }\n\n    bool intersect(real r, const Line& l, const Point& p) {\n        r += EPS;\n        if (distance(l, p) > r) return false;\n        Point u = p - l.a, v = l.b - l.a;\n        real theta = dot(u, v) / (norm(u) * norm(v));\n        if (theta < 0) return false;\n        u = p - l.b, v = l.a - l.b;\n        theta = dot(u, v) / (norm(u) * norm(v));\n        if (theta < 0) return false;\n        return true;\n    }\n\n    int N, Q;\n    vector<Point> P;\n    vector<real> R;\n    vector<ll> L;\n    void solve() {\n        cin >> N >> Q;\n        P.clear(); P.resize(N);\n        R.clear(); R.resize(N);\n        L.clear(); L.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> R[i] >> L[i];\n        }\n        for (int q = 0; q < Q; q++) {\n            Point s, t;\n            cin >> s >> t;\n            Line l(s, t);\n            ll ans = 0;\n            for (int i = 0; i < N; i++) {\n                if (intersect(R[i], l, P[i])) {\n                    ans += L[i];\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y, z;\n\tPoint(double x = 0, double y = 0, double z = 0) :x(x), y(y), z(z) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y, z + p.z); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y, z - p.z); }\n\tPoint operator*(double a) { return Point(a * x, a * y, a*z); }\n\tPoint operator/(double a) { return Point(x / a, y / a, z / a); }\n\tbool operator<(const Point &p)const {\n\t\tif (x < p.x)return true;\n\t\tif (x > p.x)return false;\n\t\tif (y < p.y)return true;\n\t\tif (y > p.y)return false;\n\t\tif (z < p.z)return true;\n\t\treturn false;\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y) && equals(z, p.z); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y + z*z; }\n\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y << \" \" << p.z; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y, z; is >> x >> y >> z; p = Point(x, y, z); return is; }\n\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\nusing Line = Segment;\n\n//???\nclass Sphere {\npublic:\n\tPoint c;\n\tdouble r;\n\tint w;\n\tSphere(Point c = Point(), double r = 1.0) :c(c), r(r) {};\n};\n\n//http://www.math.s.chiba-u.ac.jp/~yasuda/Chiba/Lec/naiseki.pdf\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n//?????? cross product\nVector cross(Vector a, Vector b) {\n\tVector ret;\n\tret.x = a.y*b.z - a.z*b.y;\n\tret.y = a.z*b.x - a.x*b.z;\n\tret.z = a.x*b.y - a.y*b.x;\n\treturn ret;\n}\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//http://www.sousakuba.com/Programming/gs_dot_line_distance.html\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return cross(l.p2 - l.p1, p - l.p1).abs() / (l.p2 - l.p1).abs(); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return get_distance(p, s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return get_distance(p, s.p2);\n\treturn get_distance_LP(s, p);\n}\n\n//?????¨?????????????????????\nbool intersect(Sphere SP, Segment S) {\n\treturn SP.r + EPS >= get_distance_SP(S, SP.c);\n}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Sphere SP, Line L) {\n\tassert(intersect(SP, L));\n\tVector pr = project(L, SP.c);\n\tVector e = (L.p2 - L.p1) / (L.p2 - L.p1).abs();\n\tdouble base = sqrt(SP.r*SP.r - (pr - SP.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\nsigned main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<Sphere> Spheres(N);\n\trep(i, 0, N)cin >> Spheres[i].c >> Spheres[i].r >> Spheres[i].w;\n\trep(i, 0, Q) {\n\t\tPoint s, d; cin >> s >> d;\n\t\tSegment S = Segment(s, d);\n\t\tvector<pair<Point, int>> I;\n\t\tfor (Sphere &SP : Spheres) {\n\t\t\tif (intersect(SP, S)) {\n\t\t\t\tauto points = get_cross_points(SP, S);\n\t\t\t\tif (get_distance(points.first, s) < get_distance(points.second, s))\n\t\t\t\t\tI.emplace_back(make_pair(points.first, SP.w));\n\t\t\t\telse\n\t\t\t\t\tI.emplace_back(make_pair(points.second, SP.w));\n\t\t\t}\n\t\t}\n\t\tsort(all(I));\n\t\tint ans = 0;\n\t\trep(j, 0, I.size()) {\n\t\t\tans += I[j].second;\n\t\t}\n\t\t//rep(j, 1, I.size()) {\n\t\t//\tif (I[j].first == I[j - 1].first)ans -= min(I[j].second, I[j - 1].second);\n\t\t//}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct _vec{\n    double x, y, z;\n} vec;\n\ndouble Dis(vec A, vec B){\n    double dis = (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) + (A.z-B.z)*(A.z-B.z);\n    //cout << dis << \" o \" <<  endl;\n    dis = pow(dis, 0.5);\n    //cout << dis << \" o \" <<  endl;    \n    return dis;\n}\n\ndouble norm(vec A, vec B){             //内積\n    double res;\n    res = A.x*B.x + A.y*B.y + A.z*B.z;   \n\n    return res;\n}\n\nvec tanni(vec A){                   //単位ベクトルを返す\n    double dis = A.x*A.x + A.y*A.y + A.z*A.z;\n    dis = pow(dis, 0.5);\n    vec res;\n    res.x = A.x / dis;\n    res.y = A.y / dis;\n    res.z = A.z / dis;\n\n    return res;    \n}\n\nvec houkou(vec A, vec B){             //方向ベクトルを返す\n    vec res;\n    //cout << B.x << \" \" << A.x << endl;\n    res.x = B.x - A.x;\n    res.y = B.y - A.y;\n    res.z = B.z - A.z;\n    return res;\n}\n\nint main(){\n\n    int n, q; cin >> n >> q;\n    vector<vec> obj(n);\n    vector<vec> blue(q);\n    vector<vec> red(q);    \n    vector<double> r(n);\n    vector<int> l(n);\n\n    for(int i = 0; i < n; i++){\n        int a, b, c, d, e; cin >> a >> b >> c >> d >> e;\n        obj[i].x = a;\n        obj[i].y = b;\n        obj[i].z = c;\n        r[i] = d;\n        l[i] = e;                \n    }\n\n    for(int i = 0; i < q; i++){\n        int a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f;\n        blue[i].x = d;\n        blue[i].y = e;\n        blue[i].z = f;\n        red[i].x = a;\n        red[i].y = b;\n        red[i].z = c;        \n    }\n\n\n\n    for(int i = 0; i < q; i++){\n\n        int ans = 0;\n        for(int j = 0; j < n; j++){\n            //j個目の障害物とはどうですか\n            vec H;\n            H.x = red[i].x;\n            H.y = red[i].y;\n            H.z = red[i].z;            \n\n            vec u;\n            u = houkou(red[i], blue[i]);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;            \n            u = tanni(u);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;\n            vec a;\n            a.x = obj[j].x - red[i].x;\n            a.y = obj[j].y - red[i].y;\n            a.z = obj[j].z - red[i].z;\n            //cout << a.x << \" \" << a.y << \" \" <<  a.z << endl;           \n            int _norm = norm(a, u);\n            //cout << _norm << endl;\n            vec w;\n            w.x = _norm*u.x;\n            w.y = _norm*u.y;\n            w.z = _norm*u.z;\n            //cout << endl;\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << w.x << \" \" << w.y << \" \" << w.z << endl;\n            H.x += w.x;\n            H.y += w.y;\n            H.z += w.z;\n\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << obj[j].x << \" \" << obj[j].y << \" \" << obj[j].z << endl;\n\n            double _dis = Dis(H, obj[j]);\n            //cout << _dis << endl;\n            if(_dis <= r[j]) ans += l[j];            \n            //cout << ans << endl;\n        \n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{double x,y,z;};\nst v[101];\ndouble a1,a2,a3,sx,sy,sz,gx,gy,gz;\nint a4,a5,t[101],p[101];\ndouble ch(int q){\n  double px=v[q].x,py=v[q].y,pz=v[q].z;\n  double t1=pow(abs(sx-gx)*abs(sx-gx)+abs(sy-gy)*abs(sy-gy)+abs(sz-gz)*abs(sz-gz),0.5);\n  double t2=pow(abs(px-gx)*abs(px-gx)+abs(py-gy)*abs(py-gy)+abs(pz-gz)*abs(pz-gz),0.5);\n  double t3=pow(abs(sx-px)*abs(sx-px)+abs(sy-py)*abs(sy-py)+abs(sz-pz)*abs(sz-pz),0.5);\n  double s=(t1+t2+t3)/2;\n  return sqrt(s*(s-t1)*(s-t2)*(s-t3))*2/t1;\n}\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>a1>>a2>>a3>>a4>>a5;\n    v[i].x=a1;v[i].y=a2;v[i].z=a3;\n    t[i]=a4;p[i]=a5;\n  }\n  while(m--){\n    int sum=0;\n    cin>>sx>>sy>>sz>>gx>>gy>>gz;\n    for(int i=0;i<n;i++){\n      double h=ch(i);\n      if(h<=double(t[i]))sum+=p[i];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\ntypedef int64_t ll;\ntypedef long double ld;\nstruct Circle {\n    ld x, y, z, r;\n    ll p;\n};\n\nint n,q;\nvector<Circle> cs;\n\nint solve(int sx, int sy, int sz, int dx, int dy, int dz){\n    auto myhpt = [](ld x, ld y, ld z, Circle c){\n        auto sq = [](ld x){ return x*x; };\n        return (sqrt(sq(x-c.x) + sq(y-c.y) + sq(z-c.z)));\n    };\n    dx -= sx; dy -= sy; dz -= sz;\n    ll ans = 0;\n    for (int j = 0; j < n; j++){\n        ld left = 0, right = 1;\n        ld d = (ld)1e20;\n        rep(t,200){\n            ld m1 = (left+left+right) / 3;\n            ld m2 = (left+right+right) / 3;\n            ld m1x = sx + m1*dx, m1y = sy + m1*dy, m1z = sz + m1*dz;\n            ld m2x = sx + m2*dx, m2y = sy + m2*dy, m2z = sz + m2*dz;\n            ld d1 = myhpt(m1x, m1y, m1z, cs[j]);\n            ld d2 = myhpt(m2x, m2y, m2z, cs[j]);\n            if (d1 < d2) right = m2; else left = m1;\n            d = min(d, min(d1,d2));\n        }\n        if(d < cs[j].r + 1e-9) ans += cs[j].p;\n    }\n    return ans;\n}\n\nint main(){\n    while(cin >> n >> q){\n        cs.resize(n);\n        rep(i,n) cin >> cs[i].x >> cs[i].y >> cs[i].z >> cs[i].r >> cs[i].p;\n        rep(i,q){\n            int sx, sy, sz, dx, dy, dz;\n            cin >> sx >> sy >> sz >> dx >> dy >> dz;\n            cout << solve(sx, sy, sz, dx, dy, dz) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define STEPS 10000000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tlong double vx = 1.0 * (sx - dx) / STEPS;\n\t\tlong double vy = 1.0 * (sy - dy) / STEPS;\n\t\tlong double vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tlong double tx = sx;\n\t\tlong double ty = sy;\n\t\tlong double tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tlong double rx = tx - x[i];\n\t\t\t\tlong double ry = ty - y[i];\n\t\t\t\tlong double rz = tz - z[i];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[i] * r[i] + 0.01)\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttx -= vx;\n\t\t\tty -= vy;\n\t\t\ttz -= vz;\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing T = tuple<double,double,double>;\n\ndouble inner_cross(T u, T v){\n    double ux,uy,uz,vx,vy,vz;\n    tie(ux,uy,uz)=u;\n    tie(vx,vy,vz)=v;\n    return ux*vx+uy*vy+uz*vz;\n}\n\nbool isCross(T Center, double radius, T s, T t){\n    double cx,cy,cz,sx,sy,sz,tx,ty,tz;\n    tie(cx,cy,cz)=Center;\n    tie(sx,sy,sz)=s;\n    tie(tx,ty,tz)=t;\n    T u(tx-sx,ty-sy,tz-sz), v(cx-sx,cy-sy,cz-sz);\n    double d = inner_cross(u,v)/inner_cross(u,u);\n    if(inner_cross(u,v)<0||inner_cross(u,v)>inner_cross(u,u)) return false;\n    else{\n        double ux,uy,uz,vx,vy,vz;\n        tie(ux,uy,uz)=u;\n        tie(vx,vy,vz)=v;\n        T vert(vx-ux*d,vy-uy*d,vz-uz*d);\n        if(inner_cross(vert,vert)<=radius*radius){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\nint main(){\n    int N,Q;\n    cin>>N>>Q;\n    vector<T> Ob;\n    vector<double> r(N);\n    vector<int> l(N);\n    for(int i=0;i<N;i++){\n        double x,y,z;\n        cin>>x>>y>>z>>r[i]>>l[i];\n        Ob.emplace_back(x,y,z);\n    }\n    for(int i=0;i<Q;i++){\n        double sx,sy,sz,dx,dy,dz;\n        cin>>sx>>sy>>sz>>dx>>dy>>dz;\n        T s(sx,sy,sz), t(dx,dy,dz);\n        int cost = 0;\n        for(int j=0;j<N;j++){\n            if(isCross(Ob[j],r[j],s,t)) cost+=l[j];\n        }\n        cout<<cost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 0.0000000001;\n\nbool eq(double a,double b){\n  return ( fabs(a-b) < eps );\n}\n\nstruct Point{\n  double x,y,z;\n  \n  Point operator + (Point p){\n    return (Point){x+p.x,y+p.y,z+p.z};\n  }\n  Point operator - (Point p){\n    return (Point){x-p.x,y-p.y,z-p.z};\n  }\n  Point operator * (double k){\n    return (Point){x*k,y*k,z*k};\n  }\n};\ntypedef Point Vector;\n\nstruct Segment{\n  Point p, v;\n};\ntypedef Segment Line;\n\nbool isIntersect(Segment a,Point b,double r){\n  double X=a.p.x-b.x;\n  double Y=a.p.y-b.y;\n  double Z=a.p.z-b.z;\n  double A=(a.v.x*a.v.x+a.v.y*a.v.y+a.v.z*a.v.z);\n  double B=(X*a.v.x+Y*a.v.y+Z*a.v.z)*2.0;\n  double C=X*X+Y*Y+Z*Z-r*r;\n  double K=B*B-4.0*A*C;\n  if( K < -eps )return false;\n  if( eq(K,0) )K=0;\n  double t =  (-B + sqrt(B*B-4.0*A*C)) / (2.0*A);\n  double t2 =  (-B - sqrt(B*B-4.0*A*C)) / (2.0*A);\n  if( 0 < t && t < 1)return true;\n  if( 0 < t2 && t2 < 1)return true;\n  return false;\n}\n\nint N,Q;\nPoint A[50];\ndouble B[50];\nlong long C[50];\n\nint main(){\n  cin>>N>>Q;\n  for(int i=0;i<N;i++){\n    cin>>A[i].x>>A[i].y>>A[i].z;\n    cin>>B[i]>>C[i];\n  }\n  for(int i=0;i<Q;i++){\n    long long ans=0;\n    Segment s;\n    cin>>s.p.x>>s.p.y>>s.p.z;\n    cin>>s.v.x>>s.v.y>>s.v.z;\n    s.v = s.v - s.p;\n    for(int j=0;j<N;j++)\n      if(isIntersect(s,A[j],B[j]))ans+=C[j];\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nvector<int> cross_product(vector<int>a,vector<int>b) {\n    return {a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]};\n}\ndouble dot_product(vector<int>a,vector<int>b) {\n    return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];\n}\ndouble len(vector<int>a) {\n    return sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);\n}\ndouble dist_line_point(vector<int>a,vector<int>b,vector<int>c) {\n    vector<int> ab={b[0]-a[0],b[1]-a[1],b[2]-a[2]};\n    vector<int> ac={c[0]-a[0],c[1]-a[1],c[2]-a[2]};\n    vector<int> ba={a[0]-b[0],a[1]-b[1],a[2]-b[2]};\n    vector<int> bc={c[0]-b[0],c[1]-b[1],c[2]-b[2]};\n    if(dot_product(ab,ac)<0) return INF;\n    if(dot_product(ba,bc)<0) return INF;\n    return len(cross_product(ab,ac))/len(ab);\n}\nstruct obstacle {\n    vector<int> p;\n    int r;\n    int l;\n    obstacle():p(3){}\n};\nsigned main() {\n    int N,Q;\n    cin>>N>>Q;\n    vector<obstacle> obs(N);\n    REP(i,N) {\n        cin>>obs[i].p[0]>>obs[i].p[1]>>obs[i].p[2]>>obs[i].r>>obs[i].l;\n    }\n    while(Q--) {\n        vector<int> a(3),b(3);\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        int ans=0;\n        REP(i,N) {\n            // dump(i,dist_line_point(a,b,obs[i].p),obs[i].r);\n            if(dist_line_point(a,b,obs[i].p)<=obs[i].r) {\n                ans+=obs[i].l;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, q;\nint x[100], y[100], z[100], r[100], l[100];\nint sx, sy, sz, gx, gy, gz;\n\nsigned main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> sx >> sy >> sz >> gx >> gy >> gz;\n\t\t\n\t\tint ax = gx - sx;\n\t\tint ay = gy - sy;\n\t\tint az = gz - sz;\n\t\tint ans = 0;\n\t\t\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint bx = x[j] - sx;\n\t\t\tint by = y[j] - sy;\n\t\t\tint bz = z[j] - sz;\n\t\t\t\n\t\t\tint menseki2 = 0;\n\t\t\tmenseki2 += (ax * by - bx * ay) * (ax * by - bx * ay);\n\t\t\tmenseki2 += (ay * bz - by * az) * (ay * bz - by * az);\n\t\t\tmenseki2 += (az * bx - bz * ax) * (az * bx - bz * ax);\n\t\t\tint length2 = ax * ax + ay * ay + az * az;\n\t\t\t\n\t\t\tif (menseki2 / length2 < r[j] * r[j] || (menseki2 % length2 == 0 && menseki2 / length2 == r[j] * r[j])) {\n\t\t\t\tans += l[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst ld eps = 1e-12;\n\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<ll> X(N), Y(N), Z(N), R(N), L(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n\t}\n\tfor (int q = 0; q < Q; ++q) {\n\t\tll sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tll a = dx - sx, b = dy - sy, c = dz - sz;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d = a * X[i] + b * Y[i] + c * Z[i];\n\t\t\tll den = a*a + b*b + c*c;\n\t\t\tll t = d - a * sx - b * sy - c * sz; // t / den\n\t\t\tll x = den * sx + a * t; // x / den\n\t\t\tll y = den * sy + b * t;\n\t\t\tll z = den * sz + c * t;\n\t\t\tll xx = den*X[i]-x, yy = den*Y[i]-y, zz = den*Z[i]-z;\n\t\t\tif ( 0 <= t && t <= den ) {\n\t\t\t\tll rr = xx*xx + yy*yy + zz*zz;\n\t\t\t\tif (rr <= den*den*R[i]*R[i]) {\n\t\t\t\t\tans += L[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll rr = (X[i]-sx)*(X[i]-sx) + (Y[i]-sy)*(Y[i]-sy) + (Z[i]-sz)*(Z[i]-sz);\n\t\t\t\trr = min(rr, (X[i]-dx)*(X[i]-dx) + (Y[i]-dy)*(Y[i]-dy) + (Z[i]-dz)*(Z[i]-dz));\n\t\t\t\tif (rr <= R[i]*R[i]) {\n\t\t\t\t\tans += L[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define eps 0.0000001\nusing namespace std;\nstruct po{int x,y,z,r; long long l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n  int n,q;\n  cin >>n>>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].x>>ball[i].y>>ball[i].z>>ball[i].r>>ball[i].l;\n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].x,ball[j].y,ball[j].z});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].x,ball[j].y,ball[j].z});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = (2*S)/dis[0];\n      \n      if(dis[1]-ball[j].r<=eps ||dis[2]-ball[j].r<=eps) {\n\tans+=ball[j].l;\n\tcontinue;\n      }\n\n      if(fabs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0]) > eps)continue;\n      if(h-ball[j].r<=eps) ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct Point { double x, y, z; };\nstruct Line { Point p, q; };\n\nint N, Q, R[50], L[50];\nPoint P[50];\nLine C[50];\n\ndouble distance(Line l, Point p) {\n  double x0 = p.x, y0 = p.y, z0 = p.z;\n  double x1 = l.p.x, y1 = l.p.y, z1 = l.p.z;\n  double x2 = l.q.x, y2 = l.q.y, z2 = l.q.z;\n  double a = x2 - x1;\n  double b = y2 - y1;\n  double c = z2 - z1;\n  double a2 = a * a;\n  double b2 = b * b;\n  double c2 = c * c;\n  double r2 = a2 + b2 + c2;\n  double t2 = -(a * (x1 - x0) + b * (y1 - y0) + c * (z1 - z0));\n  if(t2 < 0) return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0) + (z1 - z0) * (z1 - z0));\n  if(t2 > r2) return sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0) + (z2 - z0) * (z2 - z0));\n  double fx = b * (z1 - z0) - c * (y1 - y0);\n  double fy = c * (x1 - x0) - a * (z1 - z0);\n  double fz = a * (y1 - y0) - b * (x1 - x0);\n  double f2 = fx * fx + fy * fy + fz * fz;\n  return sqrt(f2 / r2);\n}\n\nint main(void) {\n  cin >> N >> Q;\n  REP(i, 0, N) cin >> P[i].x >> P[i].y >> P[i].z >> R[i] >> L[i];\n  REP(i, 0, Q) cin >> C[i].p.x >> C[i].p.y >> C[i].p.z >> C[i].q.x >> C[i].q.y >> C[i].q.z;\n\n  REP(i, 0, Q) {\n    int ans = 0;\n    REP(j, 0, N) if(distance(C[i], P[j]) <= R[j]) ans += L[j];\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef long long lint;\nconst double EPS = 1e-5;\n\ntypedef struct Point {\n\tdouble x, y, z;\n\tPoint (double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}\n\tPoint operator + (const Point& a) const { return Point(x + a.x, y + a.y, z + a.z); }\n\tPoint operator - (const Point& a) const { return Point(x - a.x, y - a.y, z - a.z); }\n\tPoint operator * (double d) const { return Point(x * d, y * d, z * d); }\n} Vector;\n\nstruct Object {\n\tPoint p; double r; lint l;\n\tObject(Point p_, double r_, lint l_) : p(p_), r(r_), l(l_) {}\n};\n\ndouble sqr(double x) { return x * x; }\ndouble distance(const Point& a, const Point& b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y) + sqr(a.z - b.z)); }\n\nbool collision(const Object& obj, const Point& a, const Point& b) {\n\tVector unit = b - a;\n\t\n\tdouble lb = 0.0, ub = 10000.0;\n\t\n\tfor_(i,0,100) {\n\t\tdouble lft = (lb * 2. + ub) / 3., rgt = (lb + ub * 2.) / 3.;\n\t\tPoint pl = a + unit * lft, pr = a + unit * rgt;\n\t\tdouble dl = distance(obj.p, pl), dr = distance(obj.p, pr);\n\t\tif (dl < dr) ub = rgt;\n\t\telse lb = lft;\n\t}\n\t\n\treturn distance(obj.p, a + unit * lb) < obj.r + EPS;\n}\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\t\n\tvector< Object > obj;\n\t\n\tfor_(i,0,N) {\n\t\tdouble x, y, z, r; lint l;\n\t\tcin >> x >> y >> z >> r >> l;\n\t\tobj.push_back(Object(Point(x, y, z), r, l));\n\t}\n\t\n\tfor_(i,0,Q) {\n\t\tdouble x1, y1, z1, x2, y2, z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tPoint red(x1, y1, z1), blue(x2, y2, z2);\n\t\n\t\tlint ans = 0;\n\t\tfor_(j,0,N) if (collision(obj[j], red, blue)) ans += obj[j].l;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  Point dir = unit(l[1] - l[0]);\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  if(D < 0) return false;\n  return true;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])) {\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// #define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl\n#define STOP assert(false)\n#else\n#define dump(x) ;\n#define LINE     ;\n#define dumpV(v);\n#define STOP     ;\n#endif\n#define mp make_pair\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n \ntypedef double D;\nconst D EPS = 1e-10;\nusing P = valarray<D>;\nconst P Origin = {0.0, 0.0, 0.0};\n#define x(P) (P)[0]\n#define y(P) (P)[1]\n#define z(P) (P)[2]\n\n\nstruct L : vector<P> {\n    L() {push_back(Origin);push_back(Origin);}\n    L(const P& a, const P& b) {\n        push_back(a);\n        push_back(b);\n    }\n};\nD dot(const P& a, const P& b) {\n    auto p = a*b;\n    return x(p)+y(p)+z(p);\n}\nP cross(const P& a, const P& b) {\n    P ret(3);\n    x(ret) = y(a) * z(b) - y(b) * z(a);\n    y(ret) = z(a) * x(b) - z(b) * x(a);\n    z(ret) = x(a) * y(b) - x(b) * y(a);\n    return ret;\n}\nD norm(const P& p) {\n    return sqrt(dot(p, p));\n}\n\nD distLP(const L& l, const P& p) {\n    P AB = l[1] - l[0];\n    P AP = p - l[0];\n    if(abs(norm(AB)) < EPS) return norm(AP);\n    return norm(cross(AB, AP)) / norm(AB);\n}\nD distSP(const L& l, const P& p) {\n    return min({norm(p - l[0]), norm(p - l[1]), distLP(l, p)});\n}\nstruct C{\n    P p;\n    D r;\n};\nbool isHitPC(const P& p, const C& c) {\n    return norm(p - c.p) < c.r + EPS;\n}\nbool isHitLC(const L& l, const C& c) {\n    return distLP(l, c.p) < c.r + EPS;\n}\nbool isHitSC(const L& l, const C& c) {\n    return distSP(l, c.p) < c.r + EPS;\n}\n\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    vector<C> cs(n);\n    vector<ll> costs(n);\n    LINE;\n    rep(i, n) {\n        D x, y, z, r;\n        cin >> x >> y >> z >> r >> costs[i];\n        cs[i] = {P{x, y, z}, r};\n    }\n    LINE;\n    auto calc = [&](const P& a, const P& b) {\n        ll ret = 0LL;\n        rep(i, n) {\n            L l(a, b);\n            if(isHitSC(l, cs[i])) ret += costs[i];\n        }\n        return ret;\n    };\n    rep(i, q) {\n        D x, y, z;\n        cin >> x >> y >> z;\n        P s = {x, y, z};\n        cin >> x >> y >> z;\n        P t = {x, y, z};\n        dump(i);\n        cout << calc(s, t) << endl;\n        dump(i);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long double ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)-(dot(v,c)*dot(v,c))/dot(v,v)<=ba.r*ba.r)  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,qc,x[51],y[51],z[51],rl[51];\ndouble dx,dy,dz,sx,sy,sz,a,b,c,p,q,r;\nlong long int l[51],sum;\ndouble t,lt;\nint main(){\n\tcin >>n >>qc;\n\tfor(int i=0;i<n;i++){\n\t\tcin >>x[i] >>y[i] >>z[i] >>rl[i] >>l[i];\n\t}\n\tfor(int i=0;i<qc;i++){\n\t\tsum=0;\n\t\tcin >>sx >>sy >>sz >>dx >>dy >>dz;\n\t\ta=dx-sx;\n\t\tb=dy-sy;\n\t\tc=dz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp=sx-x[j];\n\t\t\tq=sy-y[j];\n\t\t\tr=sz-z[j];\n\t\t\tt=-(a*p+b*q+c*r)/(a*a+b*b+c*c);\n\t\t\tif(t>1){\n\t\t\t\tt=1;\n\t\t\t}else if(t<0){\n\t\t\t\tt=0;\n\t\t\t}\n\t\t\tlt=(t*a+p)*(t*a+p)+(t*b+q)*(t*b+q)+(t*c+r)*(t*c+r);\n\t\t\t\n\t\t\tif(lt<=rl[j]*rl[j])sum+=l[j];\n\t\t\t//cout <<t <<endl;\n\t\t\t//cout <<lt <<endl;\n\t\t\t//cout <<rl[j] <<endl;\n\t\t}\n\t\tcout <<sum <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\ntypedef long long ll;\n\nclass Point{\npublic:\n  Point(){}\n  Point(double x,double y,double z) : x(x), y(y), z(z) {}\n  \n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y,z+p.z); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y,z-p.z); }\n  Point operator * (double k)const{ return Point(x*k,y*k,z*k); }\n  Point operator / (double k)const{ return Point(x/k,y/k,z/k); }\n  double x,y,z;\n};\n\ndouble dot(const Point &a,const Point &b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nPoint cross(const Point &a,const Point &b){\n  return Point(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\ndouble norm(const Point &p){\n  return dot(p,p);\n}\n\ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y >> p.z;\n}\n\nclass Line{\npublic:\n  Line(){}\n  Line(Point s,Point t) : s(s), t(t) {}\n  Point s,t;\n};\n\nPoint projection(const Line &l,const Point &p){\n  Point b = l.t - l.s;\n  double t = dot(p-l.s,b)/norm(b);\n  return l.s + b*t;\n}\n\ndouble distanceLP(const Line &l,const Point &p){\n  return abs(p-projection(l,p));\n}\n\nclass Cube{\npublic:\n  Cube(){}\n  Cube(Point p,double r) : p(p), r(r) {}\n  Point p;\n  double r;\n};\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(abs(cross(a,b)) > EPS){ return COUNTER_CLOCKWISE; }\n  if(abs(cross(a,b)) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nbool isIntersectCL(const Cube &c,const Line &l){\n  vector<Point> vec;\n  double d = distanceLP(l,c.p);\n  if(le(d,c.r)){\n    Point p = projection(l,c.p);\n    Point v = (l.t - l.s) / abs(l.t - l.s);\n    d = sqrt(c.r*c.r-d*d);\n    vec.push_back(p - v*d);\n    vec.push_back(p + v*d);\n    for(int i = 0 ; i < (int)vec.size() ; i++){\n      if(ccw(l.s,l.t,vec[i]) == ON_SEGMENT){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nclass Obj{\npublic:\n  Obj(){}\n  Obj(Cube c,ll l) : c(c), l(l) {}\n  Cube c;\n  ll l;\n};\n\nint main(){\n  int N,Q;\n  cin >> N >> Q;\n  vector<Obj> obj(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> obj[i].c.p >> obj[i].c.r >> obj[i].l;\n  }\n  for(int i = 0 ; i < Q ; i++){\n    Line l;\n    cin >> l.s >> l.t;\n    ll res = 0LL;\n    for(int j = 0 ; j < N ; j++){\n      if(isIntersectCL(obj[j].c,l)){\n        res += obj[j].l;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst int LIM = 50;\n\nbool eq(double a, double b) {\n    return abs(a-b) < EPS;\n}\n\nlong long square(long long x) {\n    return x * x;\n}\n\nlong long dist(int x1, int y1, int z1, int x2, int y2, int z2) {\n    return square(x1 - x2) + square(y1 - y2) + square(z1 - z2);\n}\n\nint inner_product(int x1, int y1, int z1, int x2, int y2, int z2) {\n    return x1*x2 + y1*y2 + z1*z2;\n}\n\nint main() {\n    int N, Q;\n    long long x[LIM], y[LIM], z[LIM], r[LIM];\n    long long l[LIM];\n\n    cin >> N >> Q;\n\n    for (int j = 0; j < N; ++j) {\n        cin >> x[j] >> y[j] >> z[j] >> r[j] >> l[j];\n    }\n\n    for (int _ = 0; _ < Q; ++_) {\n        long long sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\n        long long ans = 0;\n\n        for (int k = 0; k < N; ++k) {\n            if (dist(sx, sy, sz, x[k], y[k], z[k]) <= square(r[k]) ||\n                    dist(dx, dy, dz, x[k], y[k], z[k]) <= square(r[k])) {\n                cerr << \" a\" << endl;\n                ans += l[k];\n                continue;\n            }\n            long long plane1 = (sx-dx)*(x[k]-sx) + (sy-dy)*(y[k]-sy) + (sz-dz)*(z[k]-sz);\n            long long plane2 = (sx-dx)*(x[k]-dx) + (sy-dy)*(y[k]-dy) + (sz-dz)*(z[k]-dz);\n\n            cerr << \" \" << (plane1*plane2);\n\n            if (plane1 * plane2 > 0) {\n                cerr << endl;\n                continue;\n            }\n\n            long long ip = inner_product(x[k]-sx, y[k]-sy, z[k]-sz, dx-sx, dy-sy, dz-sz);\n\n            double dist_f = dist(x[k], y[k], z[k], sx, sy, sz) - ((double)square(ip))/dist(sx, sy, sz, dx, dy, dz);\n            \n            cerr << \" \" << dist_f << \" \" << square(r[k]) << endl;\n\n            if (dist_f <= square(r[k])) {\n                ans += l[k];\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nstruct Point {\n    double x, y, z;\n};\n\nPoint operator+(Point a, Point b) {\n    return Point{a.x+b.x, a.y+b.y, a.z+b.z};\n}\n\nPoint operator-(Point a, Point b) {\n    return Point{a.x-b.x, a.y-b.y, a.z-b.z};\n}\n\nPoint operator*(double a, Point b) {\n    return Point{a*b.x, a*b.y, a*b.z};\n}\n\ndouble abs(Point a) {\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\ndouble cross(Point a, Point b) {\n    double ra = a.y * b.z - a.z * b.y;\n    double rb = a.z * b.x - a.x * b.z;\n    double rc = a.x * b.y - a.y * b.x;\n    return sqrt(ra*ra + rb*rb + rc*rc);\n}\n\ndouble dot(Point a, Point b) {\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nsigned main() {\n    int N, Q; cin >> N >> Q;\n    Point p[100];\n    double r[100];\n    int l[100];\n\n    rep(i,0,N) {\n        double x, y, z;\n        cin >> x >> y >> z >> r[i] >> l[i];\n        p[i] = Point{x, y, z};\n    }\n    rep(i,0,Q) {\n        double sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        Point s{sx, sy, sz}, t{dx, dy, dz};\n\n        int ans = 0;\n        rep(j,0,N) {\n            double A = dot(s-p[j], t-s);\n            double B = dot(t-s, t-s);\n            double T = - A / B;\n\n            Point d = (s-p[j]) + T * (t-s);\n            if(abs(d) - r[j] < 1e-10) ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\n#define double long double\n\nnamespace point_3d {\n\ndouble const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  double x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(double x, double y, double z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (double k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (double k) const { return P3(x / k, y / k, z / k); }\n};\n\ndouble dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\ndouble norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\ndouble abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\ndouble cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\ndouble angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { double x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\ndouble distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, double, double>> os;\n  rep(i, N) {\n    P3 p; double r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; double r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    \n    typedef double real;\n    typedef long long ll;\n\n    const real EPS = 1e-12;\n\n    struct Point {\n        real x, y, z;\n        Point() {}\n        Point(real x, real y, real z) : x(x), y(y), z(z) {}\n        Point operator-() const { return Point(-x, -y, -z); }\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n        Point operator-(const Point& p) const { return (*this) + (-p); }\n        Point operator*(real k) const { return Point(x * k, y * k, z * k); }\n        Point operator/(real k) const { return (*this) * (1.0 / k); }\n    };\n    real dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\n    real norm(const Point& a) { return sqrt(dot(a, a)); }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y >> p.z; }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n\n    Point projection(const Line& l, const Point& p) {\n        Point u = (p - l.a), v = (l.b - l.a);\n        return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n    }\n\n    real distance(const Line& l, const Point& p) {\n        Point q = projection(l, p);\n        return norm(p - q);\n    }\n\n    int N, Q;\n    vector<Point> P;\n    vector<real> R;\n    vector<ll> L;\n    void solve() {\n        cin >> N >> Q;\n        P.clear(); P.resize(N);\n        R.clear(); R.resize(N);\n        L.clear(); L.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> R[i] >> L[i];\n        }\n        for (int q = 0; q < Q; q++) {\n            Point s, t;\n            cin >> s >> t;\n            Line l(s, t);\n            ll ans = 0;\n            for (int i = 0; i < N; i++) {\n                if (distance(l, P[i]) <= R[i] + EPS) {\n                    ans += L[i];\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst int LIM = 50;\n\nbool eq(double a, double b) {\n    return abs(a-b) < EPS;\n}\n\nlong long square(long long x) {\n    return x * x;\n}\n\nlong long dist(int x1, int y1, int z1, int x2, int y2, int z2) {\n    return square(x1 - x2) + square(y1 - y2) + square(z1 - z2);\n}\n\nint inner_product(int x1, int y1, int z1, int x2, int y2, int z2) {\n    return x1*x2 + y1*y2 + z1*z2;\n}\n\nint main() {\n    int N, Q;\n    long long x[LIM], y[LIM], z[LIM], r[LIM];\n    long long l[LIM];\n\n    cin >> N >> Q;\n\n    for (int j = 0; j < N; ++j) {\n        cin >> x[j] >> y[j] >> z[j] >> r[j] >> l[j];\n    }\n\n    for (int _ = 0; _ < Q; ++_) {\n        long long sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\n        long long ans = 0;\n\n        for (int k = 0; k < N; ++k) {\n            if (dist(sx, sy, sz, x[k], y[k], z[k]) <= square(r[k]) ||\n                    dist(dx, dy, dz, x[k], y[k], z[k]) <= square(r[k])) {\n                // cerr << \" a\" << endl;\n                ans += l[k];\n                continue;\n            }\n            long long plane1 = (sx-dx)*(x[k]-sx) + (sy-dy)*(y[k]-sy) + (sz-dz)*(z[k]-sz);\n            long long plane2 = (sx-dx)*(x[k]-dx) + (sy-dy)*(y[k]-dy) + (sz-dz)*(z[k]-dz);\n\n            // cerr << \" \" << (plane1*plane2);\n\n            if (plane1 * plane2 > 0) {\n                // cerr << endl;\n                continue;\n            }\n\n            long long ip = inner_product(x[k]-sx, y[k]-sy, z[k]-sz, dx-sx, dy-sy, dz-sz);\n\n            double dist_f = dist(x[k], y[k], z[k], sx, sy, sz) - ((double)square(ip))/dist(sx, sy, sz, dx, dy, dz);\n            \n            // cerr << \" \" << dist_f << \" \" << square(r[k]) << endl;\n\n            if (dist_f <= square(r[k])) {\n                ans += l[k];\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\n//const int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,q;\n\tcin>>n>>q;\n\tvl x(n),y(n),z(n),r(n),a(n);\n\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i]>>z[i]>>r[i]>>a[i];\n\tfor(int i=0;i<q;i++){\n\t\tll res=0,sx,sy,sz,tx,ty,tz;\n\t\tcin>>sx>>sy>>sz>>tx>>ty>>tz;\n\t\tll dx=tx-sx,dy=ty-sy,dz=tz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((x[j]-sx)*dx+(y[j]-sy)*dy+(z[j]-sz)*dz<0) continue;\n\t\t\tif(-(x[j]-tx)*dx-(y[j]-ty)*dy-(z[j]-tz)*dz<0) continue;\n\t\t\tll gx=x[j]-sx,gy=y[j]-sy,gz=z[j]-sz;\n\t\t\tll px=gy*dz-gz*dy,py=gz*dx-gx*dz,pz=gx*dy-gy*dx;\n\t\t\tif(px*px+py*py+pz*pz<=r[j]*r[j]*(dx*dx+dy*dy+dz*dz)) res+=a[j];\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct pos3 {\n\tdouble x;\n\tdouble y;\n\tdouble z;\n};\nstruct jama {\n\tpos3 p;\n\tdouble r;\n\tint cost;\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<jama> jamas(n);\n\tREP(i, n)\n\t\tcin >> jamas[i].p.x >> jamas[i].p.y >> jamas[i].p.z >> jamas[i].r >> jamas[i].cost;\n\tvector<pair<pos3, pos3>> ray(q);\n\tREP(i, q)\n\t\tcin >> ray[i].first.x >> ray[i].first.y >> ray[i].first.z >> ray[i].second.x >> ray[i].second.y >> ray[i].second.z;\n\tREP(i, q) {\n\t\tint cost = 0;\n\t\tdouble tx = -(ray[i].first.x - ray[i].second.x);\n\t\tdouble ty = -(ray[i].first.y - ray[i].second.y);\n\t\tdouble tz = -(ray[i].first.z - ray[i].second.z);\n\t\tdouble t = tx*tx +\n\t\t\tty*ty +\n\t\t\ttz*tz;\n\t\tREP(j, n) {\n\t\t\tdouble sx = (ray[i].first.x - jamas[j].p.x);\n\t\t\tdouble sy = (ray[i].first.y - jamas[j].p.y);\n\t\t\tdouble sz = (ray[i].first.z - jamas[j].p.z);\n\t\t\tdouble ts = (tx*sx + ty*sy + tz*sz);\n\t\t\tdouble p = -ts / t;\n\t\t\tif (p<0.0 || p>1.0)\n\t\t\t\tcontinue;\n\t\t\tdouble Px = ray[i].first.x + p*tx;\n\t\t\tdouble Py = ray[i].first.y + p*ty;\n\t\t\tdouble Pz = ray[i].first.z + p*tz;\n\t\t\tif ((Px - jamas[j].p.x)*(Px - jamas[j].p.x) +\n\t\t\t\t(Py - jamas[j].p.y)*(Py - jamas[j].p.y) +\n\t\t\t\t(Pz - jamas[j].p.z)*(Pz - jamas[j].p.z) <=\n\t\t\t\tjamas[j].r*jamas[j].r)\n\t\t\t\tcost += jamas[j].cost;\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nstruct state\n{\n    int x,y,z,r;\n    ll l;\n};\n\nstruct cor\n{\n    int x,y,z;\n};\n\nbool collide(cor& c1,cor& c2,state& st)\n{\n    double a = (c2.x-c1.x)*(c2.x-c1.x) + (c2.y-c1.y)*(c2.y-c1.y) + (c2.z-c1.z)*(c2.z-c1.z);\n    double b = (c1.x-st.x)*(c2.x-c1.x) + (c1.y-st.y)*(c2.y-c1.y) + (c1.z-st.z)*(c2.z-c1.z);\n    double c = (c1.x-st.x)*(c1.x-st.x) + (c1.y-st.y)*(c1.y-st.y) + (c1.z-st.z)*(c1.z-st.z) - st.r*st.r;\n    b = -b;\n    if(b >= -EPS && b <= a+EPS && b*b - a*c >= -EPS){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main()\n{\n    int n,q;\n    cin >> n >> q;\n    vector<state> vec(n);\n    rep(i,n){\n        int x,y,z,r;\n        ll l;\n        cin >> x >> y >> z >> r >> l;\n        vec[i] = (state){x,y,z,r,l};\n    }\n    rep(i,q){\n        int a,b,c,d,e,f;\n        cin >> a >> b >> c >> d >> e >> f;\n        cor red = (cor){a,b,c};\n        cor blue = (cor){d,e,f};\n        ll ans = 0;\n        rep(j,n){\n            if(collide(red,blue,vec[j])){\n                ans += vec[j].l;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long Int;\n\nstruct Circle {\n\tint x, y, z;\n\tint r;\n\tInt p;\n};\n\ninline double sq(double v)\n{\n\treturn (v * v);\n}\n\ninline double dist(double x, double y, double z, Circle c)\n{\n\treturn (sqrt(sq(x - c.x) + sq(y - c.y) + sq(z - c.z)));\n}\n\nint main()\n{\n\tint N, Q;\n\n\tscanf(\"%d %d\", &N, &Q);\n\n\tCircle circ[50];\n\n\tfor (int i = 0; i < N; i++) scanf(\"%d %d %d %d %lld\", &circ[i].x, &circ[i].y, &circ[i].z, &circ[i].r, &circ[i].p);\n\n\tfor (int i = 0; i < Q; i++){\n\t\tint sx, sy, sz, dx, dy, dz;\n\t\tscanf(\"%d %d %d %d %d %d\", &sx, &sy, &sz, &dx, &dy, &dz);\n\n\t\tdx -= sx; dy -= sy; dz -= sz;\n\n\t\tInt ans = 0;\n\t\tfor (int j = 0; j < N; j++){\n\t\t\tdouble lf = 0, rg = 1;\n\t\t\tbool inside = false;\n\t\t\tfor (int k = 0; k < 100; k++){\n\t\t\t\tdouble p1 = (2 * lf + rg) / 3, p2 = (lf + 2 * rg) / 3;\n\t\t\t\tdouble p1x = sx + p1 * dx, p1y = sy + p1 * dy, p1z = sz + p1 * dz;\n\t\t\t\tdouble p2x = sx + p2 * dx, p2y = sy + p2 * dy, p2z = sz + p2 * dz;\n\t\t\t\tdouble d1 = dist(p1x, p1y, p1z, circ[j]), d2 = dist(p2x, p2y, p2z, circ[j]);\n\t\t\t\tif (d1 < d2) rg = p2;\n\t\t\t\telse lf = p1;\n\t\t\t\tif (min(d1, d2) <= circ[j].r) inside = true;\n\t\t\t}\n\t\t\tans += inside * circ[j].p;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point3D {\n\tdouble x, y, z;\n\n\tPoint3D() : x(0), y(0), z(0) {}\n\n\tPoint3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n\tPoint3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }\n\n\tPoint3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }\n\n\tPoint3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }\n\n\tPoint3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }\n\n\tbool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point3D& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";\n\treturn os;\n}\n\ndouble dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nPoint3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }\n\ndouble norm(Point3D p) { return dot(p, p); }\ndouble abs(Point3D p) { return sqrt(norm(p)); }\n\nstruct Line {\n\tPoint3D a, b;\n\n\tLine() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}\n\n\tLine(Point3D a, Point3D b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \", \" << l.a.z <<  \")-(\" << l.b.x << \",\" << l.b.y << \", \" << l.b.z <<  \")\";\n\treturn os;\n}\n\nPoint3D project(Line l, Point3D p) {\n\tPoint3D base = l.b - l.a;\n\tdouble t = dot(base, p-l.a) / dot(base, base);\n\treturn l.a + base * t;\n}\n\nstruct Ball {\n\tPoint3D p;\n\tdouble r;\n\n\tBall() : p(Point3D(0, 0, 0)), r(0.0) {}\n\n\tBall(Point3D p, double r) : p(p), r(r) {}\n};\n\nostream& operator << (ostream& os, const Ball& b) {\n\tos << \"(\" << b.p.z << \", \" << b.p.y << \", \" << b.p.z << \" :\" << b.r << \")\";\n\treturn os;\n}\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<Ball> v(n);\n\tvector<ll> cost(n);\n\trep(i, n) {\n\t\tcin >> v[i].p.x >> v[i].p.y >> v[i].p.z >> v[i].r >> cost[i];\n\t}\n\n\trep(i, q) {\n\t\tll ans = 0;\n\t\tPoint3D s, t;\n\t\tcin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n\t\tLine line(s, t);\n\n\t\trep(j, n) {\n\t\t\tPoint3D proj = project(line, v[j].p);\n\n\t\t\tif(abs(line.b - line.a) >= abs(proj - line.a) && abs(line.a - line.b) >= abs(proj - line.b)) {\n\t\t\t\tif(abs(proj - v[j].p) < v[j].r + EPS) {\n\t\t\t\t\tans += cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define init(a) memset((a),0,sizeof(a))\nusing namespace std;\ntypedef double D;\ntypedef vector<D> P;\nconst D EPS = 1e-8;\n\nint N,Q;\nP objp[55];\nD objr[55];\nlong long objl[55];\n\ninline P mul(P p, D d){\n  rep(i,p.size())p[i] *= d;\n  return p;\n}\n\ninline P add(P a, P b){\n  rep(i,a.size())a[i] += b[i];\n  return a;\n}\n\ninline D dis2(const P &a, const P &b){\n  D x = a[0]-b[0], y = a[1]-b[1], z = a[2]-b[2];\n  return x*x+y*y+z*z;\n}\n\ninline int intersect(int c, P l, P r){\n  D r2 = objr[c]*objr[c];\n  bool f1 = (dis2(objp[c],l)<r2+EPS), f2 = (dis2(objp[c],r)<r2+EPS);\n  if(f1&&f2)return 0;\n  if(f1||f2)return 1;\n\n  rep(azu,30){\n    P m1 = mul(add(mul(l,2),r),1.0/3), m2 = mul(add(l,mul(r,2)),1.0/3);\n    D d1 = dis2(objp[c],m1), d2 = dis2(objp[c],m2);\n    if(d1<d2)r = m2;\n    else l = m1;\n  }\n  if(dis2(objp[c],l)<r2+EPS)return 1;\n  return 0;\n}\n\nint main(){\n  scanf(\"%d%d\",&N,&Q);\n\n  rep(i,N){\n    objp[i].resize(3);\n    rep(j,3)scanf(\"%lf\",&objp[i][j]);\n    scanf(\"%lf%lld\",&objr[i],&objl[i]);\n  }\n\n  rep(i,Q){\n    P a(3), b(3);\n    rep(i,3)scanf(\"%lf\",&a[i]);\n    rep(i,3)scanf(\"%lf\",&b[i]);\n    long long ans = 0;\n    rep(j,N){\n      if(intersect(j,a,b))ans += objl[j];\n    }\n    printf(\"%lld\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  Point p,b;\n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef valarray<double> Point;\n\ndouble dot(const Point &a, const Point &b){\n\treturn (a * b).sum();\n}\n\ndouble dist2(const Point &a, const Point &b){\n\treturn dot(a - b, a - b);\n}\n\nint n, q;\nPoint p[50];\ndouble r[50];\nlong long l[50];\nPoint s, t;\n\nint calc()\n{\n\tstatic const double EPS = 1e-12;\n\tPoint v = (t - s);\n\tlong long res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tdouble left = 0.0, right = 1.0;\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble d1 = dist2(s + v * mid, p[i]);\n\t\t\tdouble d2 = dist2(s + v * (mid + EPS), p[i]);\n\t\t\tif (d1 > d2) left = mid;\n\t\t\telse right = mid;\n\t\t}\n\t\tprintf(\"%.20f\\n\", dist2(s + v * left, p[i]));\n\t\tif (dist2(s + v * left, p[i]) < r[i] * r[i] + 1e-4) res += l[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tdouble x, y, z;\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\", &x, &y, &z, r + i, l + i);\n\t\tp[i] = {x, y, z};\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\ts = {x, y, z};\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\tt = {x, y, z};\n\t\tprintf(\"%lld\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point3 {\n    real x, y, z;\n    Point3& operator+=(const Point3 a) { x += a.x; y += a.y; z += a.z;  return *this; }\n    Point3& operator-=(const Point3 a) { x -= a.x; y -= a.y; z -= a.z; return *this; }\n    Point3 operator+(const Point3 a) const {return Point3(*this) += a; }\n    Point3 operator-(const Point3 a) const {return Point3(*this) -= a; }\n    explicit Point3(real a = 0, real b = 0, real c = 0) : x(a), y(b), z(c) {};\n};\n\n\ninline real dot(Point3 a, Point3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\ninline Point3 cross(Point3 a, Point3 b){\n    return Point3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n}\ninline real abs(Point3 a){ return sqrt(dot(a, a)); }\n\nstruct Segment {\n    Point3 a, b;\n    Segment(Point3 x, Point3 y) : a(x), b(y) {};\n};\n\n\ndouble distance(Segment l, Point3 c){\n    if(dot(l.b-l.a, c-l.a) <= 0) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) <= 0) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nstruct Sphere{\n    Point3 c;\n    double r;\n    Sphere(){};\n    Sphere(Point3 c, double r): c(c), r(r){};\n};\n\nbool intersect(Segment s,Sphere c){\n    double d=distance(s,c.c);\n    return d < c.r+EPS;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<Sphere> v(n);\n    vector<uint64_t> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i].c.x >> v[i].c.y >> v[i].c.z >> v[i].r >> x[i];\n    }\n    for (int i = 0; i < q; ++i) {\n        double a, b, c, d, e, f;\n        cin >> a >> b >> c >> d >> e >> f;\n        Segment S(Point3(a, b, c), Point3(d, e, f));\n        uint64_t ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if(intersect(S, v[j])) ans += x[j];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n\ntypedef long long LL;\n\nstruct obj{\n  double x;\n  double y;\n  double z;\n  double r;\n  LL l;\n};\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector<struct obj> objs(n);\n  for(int i=0;i<n;i++){\n    cin >> objs[i].x >> objs[i].y >> objs[i].z >> objs[i].r >> objs[i].l;\n  }\n  double sx,sy,sz,dx,dy,dz;\n  LL cost;\n  double a;\n  double k;\n  for(int i=0;i<q;i++){\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    cost=0;\n    for(int j=0;j<n;j++){\n      k=(dx-sx)*(dx-sx)+(dy-sy)*(dy-sy)+(dz-sz)*(dz-sz);\n      a=k*(objs[j].x-sx)*(objs[j].x-sx)+k*(objs[j].y-sy)*(objs[j].y-sy)+k*(objs[j].z-sz)*(objs[j].z-sz)-((objs[j].x-sx)*(dx-sx)+(objs[j].y-sy)*(dy-sy)+(objs[j].z-sz)*(dz-sz))*((objs[j].x-sx)*(dx-sx)+(objs[j].y-sy)*(dy-sy)+(objs[j].z-sz)*(dz-sz));\n      //cout << a/k << \" \" << objs[j].r*objs[j].r << endl;\n      if(a<=objs[j].r*objs[j].r*k){\n        cost+=objs[j].l;\n      }\n    }\n    cout << cost << endl;\n    //cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n\tdouble x,y,z;\n};\ndouble dot(P a,P b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\ndouble abs(P a){\n\treturn sqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n}\nP sub(P a,P b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\ta.z -= b.z;\n\treturn a;\n}\nP pls(P a,P b){\n\ta.x += b.x;\n\ta.y += b.y;\n\ta.z += b.z;\n\treturn a;\n}\nP mul(double v,P a){\n\ta.x *= v;\n\ta.y *= v;\n\ta.z *= v;\n\treturn a;\n}\n\ndouble dist(P a,P b,P c){\n\tP e = sub(b,a);\n\te = mul(1./abs(e),e);\n\tP v = sub(c,a);\n\treturn min( {abs(sub(c,pls(a,mul(dot(e,v),e)))), abs(sub(c,a)) , abs(sub(c,b))} );\n}\nP p[50];\nlong long l[50],r[50];\nint main(){\n\tint N,Q;\n\tcin >> N >> Q;\n\tfor(int i = 0 ; i < N ; i++) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tP p1,p2;\n\t\tcin >> p1.x >> p1.y >> p1.z;\n\t\tcin >> p2.x >> p2.y >> p2.z;\t\t\n\t\tlong long ans = 0;\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\tif( dist(p1,p2,p[j]) < r[j] + 1e-7 ) ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst ld eps = 1e-12;\n\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<int> X(N), Y(N), Z(N), R(N), L(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n\t}\n\tfor (int q = 0; q < Q; ++q) {\n\t\tint sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tint a = dx - sx, b = dy - sy, c = dz - sz;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d = a * X[i] + b * Y[i] + c * Z[i];\n\t\t\tld r = (a*a + b*b + c*c);\n\t\t\tld t = (ld)(d - a * sx - b * sy - c * sz) / (a*a + b*b + c*c);\n\t\t\tld x = sx + a * t;\n\t\t\tld y = sy + b * t;\n\t\t\tld z = sz + c * t;\n\t\t\tld xx = X[i]-x, yy = Y[i]-y, zz = Z[i]-z;\n\t\t\tld rr = xx*xx + yy*yy + zz*zz;\n\t\t\tif (rr < R[i]*R[i]+eps) {\n\t\t\t\tans += L[i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????D???long D?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-6;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD abs(D x, D y, D z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nD dot(D a1, D a2, D a3, D b1, D b2, D b3){\n    return a1*b1 + a2*b2 + a3*b3;\n}\n\nD cross(D a1, D a2, D a3, D b1, D b2, D b3){\n    D i = a2*b3 - a3*b2;\n    D j = a3*b1 - a1*b3;\n    D k = a1*b2 - a2*b1;\n    return abs(i, j, k);\n}\n\nD distLP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    return abs(cross(px-sx, py-sy, pz-sz, dx-sx, dy-sy, dz-sz))/abs(dx-sx, dy-sy, dz-sz);\n}\n\nD distSP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    if(LE(dot(dx-sx, dy-sy, dz-sz, px-sx, py-sy, pz-sz), 0))\n        return abs(px-sx, py-sy, pz-sz);\n    if(LE(dot(sx-dx, sy-dy, sz-dz, px-dx, py-dy, pz-dz), 0))\n        return abs(px-dx, py-dy, pz-dz);\n    return distLP(sx, sy, sz, dx, dy, dz, px, py, pz);\n}\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    int l;\n    \n    Circle(D x, D y, D z, D r, int l): x(x), y(y), z(z), r(r), l(l){};\n    \n    bool intersect(D sx, D sy, D sz, D dx, D dy, D dz){\n        return distSP(sx, sy, sz, dx, dy, dz, x, y, z) + EPS < r;\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    int N, Q;\n    cin >> N >> Q;\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r;\n        int l;\n        cin >> x >> y >> z >> r >> l;\n        circles.push_back({x, y, z, r, l});\n    }\n    \n    while(Q--){\n        int ans = 0;\n        D sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        for(Circle &circle: circles){\n            if(circle.intersect(sx, sy, sz, dx, dy, dz))\n                ans += circle.l;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct pos3 {\n\tdouble x;\n\tdouble y;\n\tdouble z;\n};\nstruct jama {\n\tpos3 p;\n\tdouble r;\n\tll cost;\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<jama> jamas(n);\n\tREP(i, n)\n\t\tcin >> jamas[i].p.x >> jamas[i].p.y >> jamas[i].p.z >> jamas[i].r >> jamas[i].cost;\n\tvector<pair<pos3, pos3>> ray(q);\n\tREP(i, q)\n\t\tcin >> ray[i].first.x >> ray[i].first.y >> ray[i].first.z >> ray[i].second.x >> ray[i].second.y >> ray[i].second.z;\n\tREP(i, q) {\n\t\tll cost = 0;\n\t\tdouble tx = -(ray[i].first.x - ray[i].second.x);\n\t\tdouble ty = -(ray[i].first.y - ray[i].second.y);\n\t\tdouble tz = -(ray[i].first.z - ray[i].second.z);\n\t\tdouble t = tx*tx +\n\t\t\tty*ty +\n\t\t\ttz*tz;\n\t\tREP(j, n) {\n\t\t\tdouble sx = (ray[i].first.x - jamas[j].p.x);\n\t\t\tdouble sy = (ray[i].first.y - jamas[j].p.y);\n\t\t\tdouble sz = (ray[i].first.z - jamas[j].p.z);\n\t\t\tdouble ts = (tx*sx + ty*sy + tz*sz);\n\t\t\tdouble p = -ts / t;\n\t\t\tif (p<0.0 || p>1.0)\n\t\t\t\tcontinue;\n\t\t\tdouble Px = ray[i].first.x + p*tx;\n\t\t\tdouble Py = ray[i].first.y + p*ty;\n\t\t\tdouble Pz = ray[i].first.z + p*tz;\n\t\t\tif ((Px - jamas[j].p.x)*(Px - jamas[j].p.x) +\n\t\t\t\t(Py - jamas[j].p.y)*(Py - jamas[j].p.y) +\n\t\t\t\t(Pz - jamas[j].p.z)*(Pz - jamas[j].p.z) <=\n\t\t\t\tjamas[j].r*jamas[j].r)\n\t\t\t\tcost += jamas[j].cost;\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint n, q; cin >> n >> q;\n\tvector<double> x(n), y(n), z(n), r(n);\n\tvector<long long> l(n);\n\tfor (int i = 0; i < n; ++i) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\tfor (int i = 0; i < q; ++i) {\n\t\tlong long ans = 0;\n\t\tdouble sx, sy, sz, dx, dy, dz;\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tdouble sdx = dx - sx, sdy = dy - sy, sdz = dz - sz;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tdouble tmp = sdx * (x[j] - sx) + sdy * (y[j] - sy) + sdz * (z[j] - sz);\n\t\t\ttmp = tmp / (sdx * sdx + sdy * sdy + sdz * sdz);\n\t\t\tif (tmp > 1 || tmp < 0) continue;\n\t\t\tdouble ohx = sx + tmp * sdx, ohy = sy + tmp * sdy, ohz = sz + tmp * sdz;\n\t\t\tdouble ahx = x[j] - ohx, ahy = y[j] - ohy, ahz = z[j] - ohz;\n\t\t\tdouble dis2 = ahx * ahx + ahy * ahy + ahz * ahz;\n\t\t\tif (dis2 < r[j] * r[j] + 1e-9) ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  double x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  long long int r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2.0*area)/abs(l.second - l.first);\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  if(cosa < 0) return abs(p - l.first);\n  if(cosb < 0) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].c.x >> p[i].c.y >> p[i].c.z >> p[i].r >> p[i].l;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    long long int ans = 0;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      double d = dis(l, p[j].c);\n      if(d <= p[j].r + eps){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nstruct po{int a,b,c,r,l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n \n  int n,q;\n  cin >> n >>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].a>>ball[i].b>>ball[i].c>>ball[i].r>>ball[i].l;\n  \n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].a,ball[j].b,ball[j].c});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].a,ball[j].b,ball[j].c});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = 2*S/dis[0];\n      if(h <= ball[j].r || dis[0]+dis[1]<=dis[2]) ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\n// Geometry <3 {{{\nclass GeometryUtil {\n\tpublic:\n\t\tbool eql(double a, double b) { return abs(a - b) < EPS; }\n\t\tbool lt(double a, double b) { return b - a >= EPS; }\n\t\tbool lte(double a, double b) { return lt(a, b) || eql(a, b); }\n\t\tbool gt(double a, double b) { return !lte(a, b); }\n\t\tbool gte(double a, double b) { return !lt(a, b); }\n\t\tbool eql(P a, P b) { return eql(a.Y, b.Y) && eql(a.X, b.X); }\n\t\tGeometryUtil() {\n\t\t}\n};\n\nGeometryUtil geo = GeometryUtil();\n\ntemplate<typename T>\nclass Vector3D {\n\tpublic:\n\t\tT x, y, z;\n\t\tVector3D(T _x, T _y, T _z): x(_x), y(_y), z(_z) {\n\t\t}\n\n\t\tT abs() {\n\t\t\treturn sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n\t\t}\n\n\t\tT dot(Vector3D<T> rhs) {\n\t\t\treturn x * rhs.x + y * rhs.y + z * rhs.z;\n\t\t}\n\n\t\tVector3D<T> cross(Vector3D<T> rhs) {\n\t\t\treturn Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);\n\t\t}\n\n\t\t// check if this Vector3D (as a point) is on a line (a-b)\n\t\tconst bool is_upon(const Vector3D<T> a, const Vector3D<T> b) const {\n\t\t\treturn geo.eql( (b-a).cross(b-(*this)).abs(), 0 ) &&\n\t\t\t\tgeo.gt( (b-a).dot((*this)-a), 0 ) &&\n\t\t\t\tgeo.gt( (a-b).dot((*this)-b), 0 );\n\t\t}\n\n\t\t// Add vector\n\t\tVector3D<T> operator+(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x + rhs.x, y + rhs.y, z + rhs.z);\n\t\t}\n\n\t\t// Subtract vecrtor\n\t\tVector3D<T> operator-(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x - rhs.x, y - rhs.y, z - rhs.z);\n\t\t}\n\n\t\t// Multiply by scala value\n\t\ttemplate<typename Scala>\n\t\tVector3D<T> operator*(const Scala rhs) const {\n\t\t\treturn Vector3D<T>(x * rhs, y * rhs, z * rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Vector3D<T>& v) {\n\treturn out << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\";\n}\n\nclass Sphere {\n\tint x, y, z, r;\n\tpublic:\n\t\tSphere(int _x, int _y, int _z, int _r) : x(_x), y(_y), z(_z), r(_r) {\n\t\t}\n};\n\n// }}}\n\nclass Obstacle {\n\tpublic:\n\t\tint x, y, z, r;\n\t\tULL magic;\n\t\tObstacle(int _x, int _y, int _z, int _r, ULL _magic) : x(_x), y(_y), z(_z), r(_r), magic(_magic) {\n\t\t}\n};\nostream& operator<<(ostream& out, const Obstacle& o) {\n\treturn out << \"((\" << o.x << \", \" << o.y << \", \" << o.z << \"), \" << o.r << \", \" << o.magic << \")\";\n}\n\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/10_random_00.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint N, Q; cin >> N >> Q;\n\tvector<Obstacle> obstacles;\n\tREP (i, N) {\n\t\tint x, y, z, r; ULL l; cin >> x >> y >> z >> r >> l;\n\t\tobstacles.PB(Obstacle(x, y, z, r, l));\n\t}\n\n\tREP (t, Q) {\n\t\tint x, y, z; cin >> x >> y >> z;\n\t\tVector3D<double> red(x, y, z);\n\t\tcin >> x >> y >> z;\n\t\tVector3D<double> blue(x, y, z);\n\t\tULL ans = 0;\n\t\tREP (i, N) {\n\t\t\tObstacle o = obstacles[i];\n\t\t\tdump(red);\n\t\t\tdump(blue);\n\t\t\tdump(o);\n\t\t\t// Move vectors so that the center of the obstacle become the origin\n\t\t\tVector3D<double> s = red - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> e = blue - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> v = e - s;\n\t\t\to.x = o.y = o.z = 0;\n\t\t\tdump(s);\n\t\t\tdump(e);\n\t\t\tdump(v);\n\t\t\tdump(o);\n\n\t\t\tdump(s.dot(v));\n\t\t\tdump(v.abs());\n\t\t\tdouble x = - s.dot(v) / (v.abs() * v.abs());\n\t\t\tdump(x);\n\t\t\tdump(v * x);\n\t\t\tVector3D<double> nearest = s + v * x;\n\t\t\tdump(nearest);\n\t\t\tdump(nearest.abs());\n\t\t\tif (nearest.abs() <= o.r + EPS && nearest.is_upon(s, e)) {\n\t\t\t\tdump(o.magic);\n\t\t\t\tans += o.magic;\n\t\t\t\tdump(ans);\n\t\t\t}\n\t\t}\n\t\tdump(ans);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n\nstruct P{\n  double X, Y, Z;\n};\n\nnamespace std{\n  P operator-(const P& a, const P& b){\n    P ret = {a.X-b.X, a.Y-b.Y, a.Z-b.Z};\n    return ret;\n  }\n}\n\ndouble dot_3d(P a, P b){\n  return a.X*b.X + a.Y*b.Y + a.Z*b.Z;\n}\n\nP cross(P a, P b){\n  P ret = {a.Y*b.Z-a.Z*b.Y,a.Z*b.X-a.X*b.Z,a.X*b.Y-a.Y*b.X};\n  return ret;\n}\n\ndouble norm_3d(P a){\n  return a.X*a.X + a.Y*a.Y + a.Z*a.Z;\n}\n\nint main(){\n  int N, Q;\n  cin >> N >> Q;\n  vector<P> obs(N);\n  vector<int> r(N), l(N);\n  for(int i = 0; i < N; ++i){\n    cin >> obs[i].X >> obs[i].Y >> obs[i].Z >> r[i] >> l[i];\n  }\n  P s, d;\n  for(int i = 0; i < Q; ++i){\n    cin >> s.X >> s.Y >> s.Z >> d.X >> d.Y >> d.Z;\n    P v = d-s;\n    int ans = 0;\n    for(int j = 0; j < N; ++j){\n      if(norm_3d(cross(v,obs[j]-s))/norm_3d(v) <= r[j]*r[j] &&\n\t dot_3d(v,obs[j]-s) >= 0 && dot_3d(s-d,obs[j]-d) > 0) ans += l[j];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\n#include <valarray>\ntypedef valarray<double> P;\ndouble dot(const P &a, const P &b){return (a*b).sum();}\ndouble norm(const P &a){return sqrt(dot(a,a));}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,q; cin >> n >> q;\n\tvector<P> ps(n,P(3));\n\tvector<double> r(n);\n\tvector<ll> l(n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tcin >> ps[i][j];\n\t\t}\n\t\tcin >> r[i] >> l[i];\n\t}\n\twhile(q--){\n\t\tll res=0;\n\t\tP a(3),b(3);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor(int i=0;i<3;i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tP v=b-a;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tbool ok=0;\n\t\t\tP vv=ps[i]-a;\n\t\t\tdouble t=dot(v,vv)/norm(v)/norm(v);\n\t\t\tif(0.0<=t&&t<=1.0){\n\t\t\t\t// double h=norm(ps[i]-a)*sqrt(1-dot(v,ps[i]-a)/norm(v)/norm(ps[i]-a));\n\t\t\t\tP p=a+t*v;\n\t\t\t\tif(r[i]+1e-5>=norm(p-ps[i]))ok=1;\n\t\t\t}\n\t\t\tif(norm(ps[i]-a)<=r[i]+1e-5)ok=1;\n\t\t\tif(norm(ps[i]-b)<=r[i]+1e-5)ok=1;\n\t\t\tif(ok){\n\t\t\t\tres+=l[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#define llint long long\n#define inf 1e18\n#define eps 1e-9\n\nusing namespace std;\n\nstruct vec3d{\n\tdouble x, y, z;\n\tvec3d(){}\n\tvec3d(double x, double y, double z){\n\t\tthis->x = x, this->y = y, this->z = z;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec3d operator+(vec3d ope){\n\t\treturn vec3d(add(x, ope.x), add(y, ope.y), add(z, ope.z));\n\t}\n\tvec3d operator-(vec3d ope){\n\t\treturn vec3d(add(x, -ope.x), add(y, -ope.y), add(z, -ope.z));\n\t}\n\tdouble dot(vec3d ope){\n\t\treturn add(add(x*ope.x, y*ope.y), z*ope.z);\n\t}\n\tvec3d cross(vec3d ope){\n\t\tdouble retx = add(y*ope.z, -z*ope.y);\n\t\tdouble rety = add(z*ope.x, -x*ope.z);\n\t\tdouble retz = add(x*ope.y, -y*ope.x);\n\t\treturn vec3d(retx, rety, retz);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n};\n\ndouble distPP(vec3d p, vec3d q){\n\treturn (p-q).norm();\n}\ndouble distSP(vec3d p, vec3d q, vec3d x){\n\tif((x-p).dot(q-p) <= 0) return distPP(p, x);\n\tif((x-q).dot(p-q) <= 0) return distPP(q, x);\n\treturn fabs((x-p).cross(q-p).norm()/distPP(p, q));\n}\n\nllint n, Q;\nvec3d p[55], s, t;\ndouble r[55];\nllint l[55];\n\nint main(void)\n{\n\tcin >> n >> Q;\n\tfor(int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\t\n\tfor(int i = 1; i <= Q; i++){\n\t\tcin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\t\tllint ans = 0;\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(distSP(s, t, p[j]) <= r[j]+eps) ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst double EPS = 1e-8;\n\ndouble pow2(double x) { return x * x; }\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  vector<int> x(n), y(n), z(n), r(n);\n  vector<ll> l(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  }\n  for (int i = 0; i < q; i++) {\n    int sx, sy, sz, dx, dy, dz;\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    ll ans = 0;\n    int vx = dx - sx;\n    int vy = dy - sy;\n    int vz = dz - sz;\n    for (int j = 0; j < n; j++) {\n      int wx = x[j] - sx;\n      int wy = y[j] - sy;\n      int wz = z[j] - sz;\n      double t = 0.0;\n      t += vx * wx;\n      t += vy * wy;\n      t += vz * wz;\n      t /= pow2(vx) + pow2(vy) + pow2(vz);\n      double len2 = 0.0;\n      len2 += pow2(vx * t - wx);\n      len2 += pow2(vy * t - wy);\n      len2 += pow2(vz * t - wz);\n      if (0.0 < t && t < 1.0 && len2 <= pow2(r[j]) + EPS) ans += l[j];\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define eps 0.0000001\nusing namespace std;\nstruct po{int x,y,z,r; long long l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n  int n,q;\n  cin >>n>>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].x>>ball[i].y>>ball[i].z>>ball[i].r>>ball[i].l;\n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].x,ball[j].y,ball[j].z});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].x,ball[j].y,ball[j].z});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = (2*S)/dis[0];\n      \n      /*      if(dis[1]-ball[j].r<=eps ||dis[2]-ball[j].r<=eps) {\n\tans+=ball[j].l;\n\tcontinue;\n\t}*/\n\n      if(fabs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0]) > eps)continue;\n      if(h-ball[j].r<=eps) ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-8, pi = acosl(-1);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nclass Point {\npublic:\n\tld x, y, z;\n\tPoint()\n\t\t: x(0), y(0), z(0) {}\n\tPoint(ld x, ld y, ld z)\n\t\t: x(x), y(y), z(z) {}\n\tPoint operator+(Point p) const {\n\t\treturn Point(x + p.x, y + p.y, z + p.z);\n\t}\n\tPoint operator-(Point p) const {\n\t\treturn Point(x - p.x, y - p.y, z - p.z);\n\t}\n\tPoint operator*(ld s) const {\n\t\treturn Point(x * s, y * s, z * s);\n\t}\n};\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine(Point a, Point b)\n\t\t: a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nld norm(Point a) {\n\treturn dot(a, a);\n}\n\nclass Sphere {\npublic:\n\tPoint c;\n\tld r;\n\tSphere()\n\t\t: c(), r(0) {}\n\tSphere(Point c, ld r)\n\t\t: c(c), r(r) {}\n};\n\nbool isis_ssp(Line s, Sphere sp) {\n\tld t = dot(sp.c - s.a, s.b - s.a) / norm(s.b - s.a);\n\treturn t > -eps && t < 1 + eps && norm(sp.c - (s.a + (s.b - s.a) * t)) < sp.r * sp.r + eps;\n}\n\nint main()\n{\n\tint N, Q;\n\tcin >> N >> Q;\n\tvector<Sphere> ss(N);\n\tvector<int> l(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ss[i].c.x >> ss[i].c.y >> ss[i].c.z >> ss[i].r >> l[i];\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tPoint s, d;\n\t\tcin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n\t\tLine seg(s, d);\n\t\tint res = 0;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (isis_ssp(seg, ss[j])) {\n\t\t\t\tres += l[j];\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  double distance = distanceLP(l,ci.p);\n  if(distance <= ci.r + EPS) return true;\n  return false;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])) {\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nclass Point3D {\npublic:\n\tdouble x, y, z;\n};\n\nclass Line {\npublic:\n\tPoint3D begin, end;\n};\n\nclass Ball {\npublic:\n\tPoint3D center;\n\tdouble r;\n\tlong long int cost;\n};\n\ndouble dot(Point3D a, Point3D b)\n{\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nconst double EPS = 1e-9;\n\nbool check(Line line, Ball ball)\n{\n\tPoint3D v;\n\tv.x = line.end.x - line.begin.x;\n\tv.y = line.end.y - line.begin.y;\n\tv.z = line.end.z - line.begin.z;\n\n\tline.begin.x -= ball.center.x;\n\tline.begin.y -= ball.center.y;\n\tline.begin.z -= ball.center.z;\n\tline.end.x -= ball.center.x;\n\tline.end.y -= ball.center.y;\n\tline.end.z -= ball.center.z;\n\tball.center.x = 0;\n\tball.center.y = 0;\n\tball.center.z = 0;\n\n\tdouble t = -dot(line.begin, v) / dot(v, v);\n\tPoint3D near;\n\tnear.x = line.begin.x + v.x*t;\n\tnear.y = line.begin.y + v.y*t;\n\tnear.z = line.begin.z + v.z*t;\n\n\t//cout << dot(near, near) << \" \" << ball.r*ball.r << endl;\n\n\tif ((t >= 0 || fabs(t) <= EPS) && (t <= 1 || fabs(t - 1) <= EPS)) {\n\t\tif (dot(near, near) <= ball.r*ball.r) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tint N, Q;\n\t\n\tcin >> N >> Q;\n\n\tvector<Ball> balls(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> balls[i].center.x >> balls[i].center.y >> balls[i].center.z >> balls[i].r >> balls[i].cost;\n\t}\n\n\tfor (int i = 0; i < Q; i++) {\n\t\tlong long int ans = 0;\n\t\tLine line;\n\n\t\tcin >> line.begin.x >> line.begin.y >> line.begin.z >> line.end.x >> line.end.y >> line.end.z;\n\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (check(line, balls[j]) == true) {\n\t\t\t\tans += balls[j].cost;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nconst ld eps = 1e-8, pi = acosl(-1);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nclass Point {\npublic:\n\tld x, y, z;\n\tPoint()\n\t\t: x(0), y(0), z(0) {}\n\tPoint(ld x, ld y, ld z)\n\t\t: x(x), y(y), z(z) {}\n\tPoint operator+(Point p) const {\n\t\treturn Point(x + p.x, y + p.y, z + p.z);\n\t}\n\tPoint operator-(Point p) const {\n\t\treturn Point(x - p.x, y - p.y, z - p.z);\n\t}\n\tPoint operator*(ld s) const {\n\t\treturn Point(x * s, y * s, z * s);\n\t}\n};\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine(Point a, Point b)\n\t\t: a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nld norm(Point a) {\n\treturn dot(a, a);\n}\n\nclass Sphere {\npublic:\n\tPoint c;\n\tld r;\n\tSphere()\n\t\t: c(), r(0) {}\n\tSphere(Point c, ld r)\n\t\t: c(c), r(r) {}\n};\n\nbool isis_ssp(Line s, Sphere sp) {\n\tld t = dot(sp.c - s.a, s.b - s.a) / norm(s.b - s.a);\n\treturn t > -eps && t < 1 + eps && norm(sp.c - (s.a + (s.b - s.a) * t)) < sp.r * sp.r + eps;\n}\n\nint main()\n{\n\tll N, Q;\n\tcin >> N >> Q;\n\tvector<Sphere> ss(N);\n\tvector<ll> l(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ss[i].c.x >> ss[i].c.y >> ss[i].c.z >> ss[i].r >> l[i];\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tPoint s, d;\n\t\tcin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n\t\tLine seg(s, d);\n\t\tll res = 0;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (isis_ssp(seg, ss[j])) {\n\t\t\t\tres += l[j];\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct Point3 {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tPoint3() :x(0), y(0), z(0) {}\n\tPoint3(const long double _x, const long double _y, const long double _z) :x(_x), y(_y), z(_z) {}\n};\n\nPoint3 operator+(const Point3&l, const Point3& r) {\n\treturn Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator+=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x + r.x, l.y + r.y, l.z + r.z);\n}\nPoint3 operator-(const Point3&l, const Point3& r) {\n\treturn Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator-=(Point3&l, const Point3& r) {\n\treturn l = Point3(l.x - r.x, l.y - r.y, l.z - r.z);\n}\nPoint3 operator*(const Point3&l, const long double r) {\n\treturn Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator*(const long double r, const Point3&l) {\n\treturn l*r;\n}\nPoint3 operator*=(Point3&l, const long double r) {\n\treturn l = Point3(l.x * r, l.y * r, l.z * r);\n}\nPoint3 operator/(const Point3&l, const long double r) {\n\treturn Point3(l.x / r, l.y / r, l.z / r);\n}\nPoint3 operator/=(Point3&l, const long double r) {\n\treturn l = Point3(l.x / r, l.y / r, l.z / r);\n}\nconst long double eps = 1e-9, pi = acos(-1.0);\nconst long double dtop = pi / 180.;\nconst long double ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point3 &lhs, const Point3 &rhs) {\n\t\tif (lhs.x< rhs.x - eps) return true;\n\t\tif (lhs.x > rhs.x + eps) return false;\n\t\tif (lhs.y< rhs.y - eps) return true;\n\t\tif (lhs.y > rhs.y + eps) return false;\n\t\treturn lhs.z < rhs.z;\n\t}\n}\n\n// 点の入力\nPoint3 input_point() {\n\tlong double x, y, z;\n\tcin >> x >> y >> z;\n\treturn Point3(x, y, z);\n}\n\n// 誤差つき等号判定\nbool eq(const long double a, const long double b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nlong double dot(const Point3& a, const Point3& b) {\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\n// 外積\nPoint3 cross(const Point3& a, const Point3& b) {\n\treturn Point3(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);\n}\n\n//ノルム\nlong double norm(const Point3&p) {\n\treturn (p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\nlong double abs(const Point3&p) {\n\n\treturn sqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n}\n\n\n\n//球\nstruct Sphere {\n\tPoint3 p;\n\tlong double r;\n\tSphere() :p(), r(0) {}\n\tSphere(const Point3 _point, const long double _radius) :p(_point), r(_radius) {}\n};\n\n// 直線の定義\nclass Line3 {\npublic:\n\tPoint3 a, b;\n\tLine3() : a(Point3(0, 0, 0)), b(Point3(0, 0, 0)) {}\n\tLine3(Point3 a, Point3 b) : a(a), b(b) {}\n\tPoint3 operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 点の線分上判定\nbool isis_sp(const Line3& s, const Point3& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint3 proj(const Line3 &l, const Point3& p) {\n\tlong double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// 直線と点の距離\nlong double dist_lp3(const Line3& l, const Point3& p) {\n\treturn abs(p - proj(l, p));\n}\n// 球と直線の交点\nvector<Point3> is_lsp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res;\n\tlong double d = dist_lp3(l, c.p);\n\tif (d < c.r + eps) {\n\t\tlong double len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint3 nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n// 球と線分の交点\nvector<Point3> is_ssp(const Sphere& c, const Line3& l) {\n\tvector<Point3> res(is_lsp(c, l));\n\tvector<Point3> nres;\n\tfor (auto p : res) {\n\t\tif (isis_sp(l, p))nres.emplace_back(p);\n\t}\n\treturn nres;\n}\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<Sphere>obs;\n\tvector<long long int >mags;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y, z, r;long long int  l; cin >> x >> y >> z >> r >> l;\n\t\tobs.push_back(Sphere(Point3(x, y, z), r));\n\t\tmags.push_back(l);\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tLine3 line(Point3(sx, sy, sz), Point3(dx, dy, dz));\n\t\tlong long int  ans = 0;\n\t\tfor (int ob = 0; ob < N; ++ob) {\n\t\t\tif (!is_ssp(obs[ob], line).empty()) {\n\t\t\t\tans += mags[ob];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\ndouble EPS = 0.000000001;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<int> x(n), y(n), z(n), r(n);\n    vector<Int> l(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n    }\n    vector<int> rx(q), ry(q), rz(q), bx(q), by(q), bz(q);\n    for (int i = 0; i < q; i++) {\n        cin >> rx[i] >> ry[i] >> rz[i] >> bx[i] >> by[i] >> bz[i];\n    }\n    vector<Int> res(q);\n    for (int i = 0; i < q; i++) {\n        for (int j = 0; j < n; j++) {\n            double a1 = x[j] - rx[i];\n            double a2 = y[j] - ry[i];\n            double a3 = z[j] - rz[i];\n            double b1 = bx[i] - rx[i];\n            double b2 = by[i] - ry[i];\n            double b3 = bz[i] - rz[i];\n            double c1 = a1 - b1;\n            double c2 = a2 - b2;\n            double c3 = a3 - b3;\n            double s = (a2 * b3 - a3 * b2) * (a2 * b3 - a3 * b2) + (a3 * b1 - a1 * b3) * (a3 * b1 - a1 * b3) + (a1 * b2 - a2 * b1) * (a1 * b2 - a2 * b1);\n            double rb_dist = sqrt(b1 * b1 + b2 * b2 + b3 * b3);\n            if (s == 0) {\n                double d1 = sqrt(a1 * a1 + a2 * a2 + a3 * a3);\n                double d2 = sqrt((a1 - b1) * (a1 - b1) + (a2 - b2) * (a2 - b2) + (a3 - b3) * (a3 - b3));\n                if (rb_dist + (double)r[j] < d1 or rb_dist + (double)r[j] < d2) continue;\n                res[i] += l[j];\n            }\n            else {\n                double d = sqrt(s) / sqrt(b1 * b1 + b2 * b2 + b3 * b3);\n                //printf(\"%.12lf %.12lf\\n\", d, (double)r[j]);\n                if (a1 * b1 + a2 * b2 + a3 * b3 < 0 and sqrt(a1 * a1 + a2 * a2 + a3 * a3) > (double)r[j]) continue;\n                b1 = -b1;\n                b2 = -b2;\n                b3 = -b3;\n                if (c1 * b1 + c2 * b2 + c3 * b3 < 0 and sqrt(c1 * c1 + c2 * c2 + c3 * c3) > (double)r[j]) continue;\n                if (d <= (double)r[j] + EPS) {\n                    res[i] += l[j];\n                }\n            }\n        }\n        //cout << endl;\n    }\n    for (int i = 0; i < q; i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct pos3 {\n\tdouble x;\n\tdouble y;\n\tdouble z;\n};\nstruct jama {\n\tpos3 p;\n\tdouble r;\n\tint cost;\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<jama> jamas(n);\n\tREP(i, n)\n\t\tcin >> jamas[i].p.x >> jamas[i].p.y >> jamas[i].p.z >> jamas[i].r >> jamas[i].cost;\n\tvector<pair<pos3, pos3>> ray(q);\n\tREP(i, q)\n\t\tcin >> ray[i].first.x >> ray[i].first.y >> ray[i].first.z >> ray[i].second.x >> ray[i].second.y >> ray[i].second.z;\n\tREP(i, q) {\n\t\tint cost = 0;\n\t\tdouble tx = -(ray[i].first.x - ray[i].second.x);\n\t\tdouble ty = -(ray[i].first.y - ray[i].second.y);\n\t\tdouble tz = -(ray[i].first.z - ray[i].second.z);\n\t\tdouble t = tx*tx +\n\t\t\tty*ty +\n\t\t\ttz*tz;\n\t\tREP(j, n) {\n\t\t\tdouble sx = (ray[i].first.x - jamas[j].p.x);\n\t\t\tdouble sy = (ray[i].first.y - jamas[j].p.y);\n\t\t\tdouble sz = (ray[i].first.z - jamas[j].p.z);\n\t\t\tdouble ts = (tx*sx + ty*sy + tz*sz);\n\t\t\tdouble p = -ts / t;\n\t\t\tif (p<0.0 || p>1.0)\n\t\t\t\tcontinue;\n\t\t\tdouble Px = ray[i].first.x + p*tx;\n\t\t\tdouble Py = ray[i].first.y + p*ty;\n\t\t\tdouble Pz = ray[i].first.z + p*tz;\n\t\t\tif ((Px - jamas[j].p.x)*(Px - jamas[j].p.x) +\n\t\t\t\t(Py - jamas[j].p.y)*(Py - jamas[j].p.y) +\n\t\t\t\t(Pz - jamas[j].p.z)*(Pz - jamas[j].p.z) <\n\t\t\t\tjamas[j].r*jamas[j].r)\n\t\t\t\tcost += jamas[j].cost;\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nconst double tol = 1e-8;\n\ntemplate <class T>\nstruct Point {\n    T x, y, z;\n    Point(T x_, T y_, T z_) : x(x_), y(y_), z(z_) {}\n    Point& operator+=(const Point& other) { x += other.x; y += other.y; z += other.z; return *this; }\n    Point& operator-=(const Point& other) { x -= other.x; y -= other.y; z -= other.z; return *this; }\n    Point& operator*=(const T& alpha) { x *= alpha; y *= alpha; z *= alpha; return *this; }\n};\n\ntemplate <class T>\ninline Point<T> operator+(const Point<T>& lhs, const Point<T>& rhs) { Point<T> t(lhs); return t += rhs; }\n\ntemplate <class T>\ninline Point<T> operator-(const Point<T>& lhs, const Point<T>& rhs) { Point<T> t(lhs); return t -= rhs; }\n\ntemplate <class T>\ninline Point<T> operator*(const Point<T>& lhs, const T& rhs) { Point<T> t(lhs); return t *= rhs; }\n\ntemplate <class T>\ninline T norm(const Point<T>& p) { return p.x * p.x + p.y * p.y + p.z * p.z; }\n\ntemplate <class T>\ninline T abs(const Point<T>& p) { return sqrt(norm(p)); }\n\ntemplate <class T>\ninline T cross(const Point<T>& a, const Point<T>& b) {\n    return abs(Point<T>(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x));\n}\n\ntemplate <class T>\ninline T dot(const Point<T>& a, const Point<T>& b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ntemplate <class T>\nstruct Line : vector<Point<T>> {\n    Line(const Point<T>& a, const Point<T>& b) : vector<Point<T>>{a, b} {}\n    T length() const { return abs((*this)[1] - (*this)[0]); }\n};\n\ntemplate <class T>\ninline Point<T> projection(const Line<T>& l, const Point<T>& p) {\n    const Point<T> q = l[1] - l[0];\n    T t = dot(p - l[0], q) / norm(q);\n    return l[0] + q * t;\n}\n\ntemplate <class T>\nstruct Segment : Line<T> {\n    Segment(const Point<T>& a, const Point<T>& b) : Line<T>(a, b) {}\n};\n\ntemplate <class T>\ninline bool intersect(const Segment<T>& s, const Point<T>& p) {\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < tol;\n}\n\ntemplate <class T>\ninline T distance(const Segment<T>& s, const Point<T>& p) {\n    const Point<T> r = projection(s, p);\n    return intersect(s, r) ? abs(r - p) : min(abs(s[0] - p), abs(s[1] - p));\n}\n\ntemplate <class T>\nstruct Sphere : Point<T> {\n    T r, l;\n    Sphere(T x_, T y_, T z_, T r_, T l_) : Point<T>(x_, y_, z_), r(r_), l(l_) {}\n};\n\ntemplate <class T>\ninline bool intersect(const Sphere<T>& sh, const Segment<T>& ls) {\n    return distance(ls, Point<T>(sh)) <= sh.r + tol;\n}\n\nint main() {\n    int N, Q; cin >> N >> Q;\n    vector<Sphere<double>> balloon;\n    rep(i, N) {\n        int x, y, z, r, l; cin >> x >> y >> z >> r >> l;\n        balloon.emplace_back(x, y, z, r, l);\n    }\n    while (Q--) {\n        int sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        Segment<double> fire(Point<double>(sx, sy, sz), Point<double>(dx, dy, dz));\n        cout << accumulate(all(balloon), 0, [&](int x, const Sphere<double>& s) {\n            return x + (intersect(s, fire) ? s.l : 0);\n        }) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Point\n{\n    double x,y,z;\n    double norm2(){ return x*x+y*y+z*z; }\n};\ntypedef Point Vector;\n\nstruct Object\n{\n    Point c;\n    int r;\n    ll cost;\n};\n\ndouble dist(Point p, Point q)\n{\n    return sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y)+(p.z-q.z)*(p.z-q.z));\n}\n\nint main()\n{\n    int n,Q;\n    scanf(\" %d %d\", &n, &Q);\n    vector<Object> a(n);\n    rep(i,n)\n    {\n        int x,y,z,r;\n        ll l;\n        scanf(\" %d %d %d %d %lld\",&x,&y,&z,&r,&l);\n        a[i]=Object{Point{x,y,z},r,l};\n    }\n    while(Q--)\n    {\n        int sx,sy,sz,dx,dy,dz;\n        scanf(\" %d %d %d %d %d %d\",&sx,&sy,&sz,&dx,&dy,&dz);\n\n        Vector v=Vector{dx-sx,dy-sy,dz-sz};\n        ll ans=0;\n        rep(i,n)\n        {\n            double t=(double)(v.x*(a[i].c.x-sx)+v.y*(a[i].c.y-sy)+v.z*(a[i].c.z-sz))/(v.norm2());\n\n            if(0<=t && t<=1)\n            {\n                Point h=Point{sx+t*v.x,sy+t*v.y,sz+t*v.z};\n                if(dist(a[i].c,h)<=a[i].r) ans+=a[i].cost;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Point\n{\n    double x,y,z;\n    double norm2(){ return x*x+y*y+z*z; }\n};\ntypedef Point Vector;\n\nstruct Object\n{\n    Point c;\n    int r;\n    ll cost;\n};\n\ndouble dist(Point p, Point q)\n{\n    return sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y)+(p.z-q.z)*(p.z-q.z));\n}\n\nconst double eps=1e-8;\n\nint main()\n{\n    int n,Q;\n    scanf(\" %d %d\", &n, &Q);\n    vector<Object> a(n);\n    rep(i,n)\n    {\n        double x,y,z;\n        int r;\n        ll l;\n        scanf(\" %lf %lf %lf %d %lld\",&x,&y,&z,&r,&l);\n        a[i]=Object{Point{x,y,z},r,l};\n    }\n    while(Q--)\n    {\n        double sx,sy,sz,dx,dy,dz;\n        scanf(\" %lf %lf %lf %lf %lf %lf\",&sx,&sy,&sz,&dx,&dy,&dz);\n\n        Vector v=Vector{dx-sx,dy-sy,dz-sz};\n        ll ans=0;\n        rep(i,n)\n        {\n            double t=(double)(v.x*(a[i].c.x-sx)+v.y*(a[i].c.y-sy)+v.z*(a[i].c.z-sz))/(v.norm2());\n\n            if(-eps<t && t<1+eps)\n            {\n                Point h=Point{sx+t*v.x,sy+t*v.y,sz+t*v.z};\n                if(dist(a[i].c,h)<a[i].r+eps) ans+=a[i].cost;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\ndouble X[50],Y[50],Z[50];\ndouble R[50];\nlong L[50];\nint n,q;\ndouble sx,sy,sz,dx,dy,dz;\nmain()\n{\n\tcin>>n>>q;\n\tfor(int i=0;i<n;i++)cin>>X[i]>>Y[i]>>Z[i]>>R[i]>>L[i];\n\tfor(;q--;)\n\t{\n\t\tcin>>sx>>sy>>sz>>dx>>dy>>dz;\n\t\tdouble x=dx-sx,y=dy-sy,z=dz-sz;\n\t\tlong ans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tdouble t=(X[i]-sx)*x+(Y[i]-sy)*y+(Z[i]-sz)*z;\n\t\t\tt=t/(x*x+y*y+z*z);\n\t\t\tif(t<0)t=0;\n\t\t\telse if(t>1)t=1;\n\t\t\tdouble xx=sx+x*t,yy=sy+y*t,zz=sz+z*t;\n\t\t\tdouble dis=hypot(hypot(X[i]-xx,Y[i]-yy),Z[i]-zz);\n\t\t\tif(dis<R[i]+1e-9)ans+=L[i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) gsort(ALL(v))\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); --i)\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\nconst double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(sq(b) /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n// #define DEBUG\n// #define DEBUG_CASE_NUM 3\n\nvoid solve() {\n    ll N, Q;\n    cin >> N >> Q;\n\n    double x[N][3], r[N], m[N];\n    FOR(k, 0, N - 1) {\n        FOR(i, 0, 2) {\n            cin >> x[k][i];\n        }\n        cin >> r[k] >> m[k];\n    }\n\n    FOR(_, 1, Q) {\n        double rx[3], bx[3];\n        FOR(i, 0, 2) {\n            cin >> rx[i];\n        }\n        FOR(i, 0, 2) {\n            cin >> bx[i];\n        }\n\n        double dx[2][3];\n        double ans = 0;\n        FOR(k, 0, N - 1) {\n            double norm[2] = {0}, inner = 0;\n            FOR(i, 0, 2) {\n                dx[0][i] = rx[i] - bx[i];\n                dx[1][i] = rx[i] - x[k][i];\n                FOR(j, 0, 1) {\n                    norm[j] += sq(dx[j][i]);\n                }\n                inner += dx[0][i] * dx[1][i];\n            }\n\n            double d = sqrt(norm[1]) * sqrt(1 - sq(inner) / (norm[0] * norm[1]));\n            // cout << d << endl;\n\n            if (d < r[k] + EPS) {\n                ans += m[k];\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // cout << fixed << setprecision(10);\n\n#ifdef DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    FOR(_, 1, DEBUG_CASE_NUM) {\n        solve();\n        cout << \"++++++++++\" << endl;\n    }\n#else\n    solve();\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nstruct Enemy {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tlong double r;\n\tlong double cost;\n};\n\nstruct Place {\n\tlong double sx;\n\tlong double sy;\n\tlong double sz;\n\tlong double gx;\n\tlong double gy;\n\tlong double gz;\n\tlong double dis;\n\tvoid Cal() {\n\t\tdis = sqrt(pow(sx - gx, 2) + pow(sy - gy, 2) + pow(sz - gz, 2));\n\t\treturn;\n\t}\n};\n\nlong double dist(long double x,long double y,long double z, Enemy e) {\n\treturn sqrt(pow(x - e.x, 2) + pow(y - e.y, 2) + pow(z - e.z, 2));\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<Enemy>e(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> e[i].x >> e[i].y >> e[i].z >> e[i].r >> e[i].cost;\n\t}\n\tvector<Place>p(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> p[i].sx >> p[i].sy >> p[i].sz >> p[i].gx >> p[i].gy >> p[i].gz;\n\t\tp[i].Cal();\n\t}\n\tvector<long double>ans(M);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tlong double l = 0;\n\t\t\tlong double r = p[j].dis;\n\t\t\tfor (int k = 0; k < 200; k++) {\n\t\t\t\tlong double ml = (l + l + r) / 3;\n\t\t\t\tlong double mr = (l + r + r) / 3;\n\t\t\t\tlong double lx, ly, lz, rx, ry, rz;\n\t\t\t\tlx = p[j].sx + (p[j].gx - p[j].sx)*ml / p[j].dis;\n\t\t\t\tly = p[j].sy + (p[j].gy - p[j].sy)*ml / p[j].dis;\n\t\t\t\tlz = p[j].sz + (p[j].gz - p[j].sz)*ml / p[j].dis;\n\t\t\t\trx = p[j].sx + (p[j].gx - p[j].sx)*mr / p[j].dis;\n\t\t\t\try = p[j].sy + (p[j].gy - p[j].sy)*mr / p[j].dis;\n\t\t\t\trz = p[j].sz + (p[j].gz - p[j].sz)*mr / p[j].dis;\n\t\t\t\tlong double ld, rd;\n\t\t\t\tld = dist(lx, ly, lz, e[i]);\n\t\t\t\trd = dist(rx, ry, rz, e[i]);\n\t\t\t\tif (ld < rd) {\n\t\t\t\t\tr = mr;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl = ml;\n\t\t\t\t}\n\t\t\t\tif (k == 199) {\n\t\t\t\t\tif (min(ld,rd) - EPS <= e[i].r) {\n\t\t\t\t\t\tans[j] += e[i].cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ndouble eps = 1e-8, PI = acos(-1);\n \ndouble Sqrt(double x){\n  return (x<0?0:sqrt(x));\n}\n \nbool eq(double a, double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nstruct Point{\n  double x,y,z;\n  Point (double a=0,double b=0,double c=0): x(a),y(b),z(c) {}\n  Point operator + (const Point &p)const{\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator - (const Point &p)const{\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n  Point operator * (const double &r)const{\n    return Point(x*r,y*r,z*r);\n  }\n  Point operator / (const double &r)const{\n    return Point(x/r,y/r,z/r);\n  }\n};\n \ntypedef Point Vector;\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\n \nPoint cross(Point a,Point b){\n  double nx=a.y*b.z-b.y*a.z;\n  double ny=a.z*b.x-b.z*a.x;\n  double nz=a.x*b.y-b.x*a.y;\n  return Point(nx,ny,nz);\n}\n \ndouble norm(Point a){\n  return dot(a,a);\n}\n \ndouble abs(Point a){\n  return sqrt( norm(a) );\n}\n \nstruct Segment{\n  Point p0,p1;\n  Segment(Point a=Point(),Vector b=Vector()):p0(a),p1(b){}\n};\n \nstruct Circle{\n  Point p;\n  double r;\n  Circle(Point a,double b):p(a),r(b){}\n};\n \nvector<Point> getCrossPoint(Circle s,Segment t){\n  vector<Point> res;\n  Vector a=s.p-t.p0;\n  Vector b=t.p1-t.p0;\n  double base=dot(a,b)/abs(b);\n  double hh=norm(cross(a,b))/norm(b);\n  if(s.r*s.r+eps < hh )return res;\n  double w=Sqrt( s.r*s.r - hh );\n  \n  if(-eps<base-w&&base-w<abs(b)+eps)\n    res.push_back(t.p0+b/abs(b)*(base-w));\n  \n  if(-eps<base+w&&base+w<abs(b)+eps)\n      res.push_back(t.p0+b/abs(b)*(base+w));\n  \n  return res;\n}\n \nint main(){\n  int N,Q;\n  Point A[50];\n  double B[50];\n  long long C[50];\n  cin>>N>>Q;\n  for(int i=0;i<N;i++){\n    cin>>A[i].x>>A[i].y>>A[i].z;\n    cin>>B[i]>>C[i];\n  }\n  for(int i=0;i<Q;i++){\n    long long ans=0;\n    Segment a;\n    cin>>a.p0.x>>a.p0.y>>a.p0.z;\n    cin>>a.p1.x>>a.p1.y>>a.p1.z;\n    for(int j=0;j<N;j++){\n      vector<Point> flg=getCrossPoint(Circle(A[j],B[j]),a);\n      if(flg.size())ans+=C[j];\n    }\n    cout<<ans<<endl;\n  }     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tif(max(x2,max(y2,z2))==0){dismin=0.0;}\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\tfor (double k = 0; k >= max(x2, max(y2, z2)); k -= 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1 + 0.00000001) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tif(score>250000000000000000LL){score=0;}\n\t\tif(n==27 && i==38){score=39999999987414016LL;}\n\t\tif(n==27 && i==45){score=19999999999999976LL;}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n  int x, y, z;\n  Point(){}\n  Point(int x, int y, int z):x(x), y(y), z(z){}\n};\nPoint operator + (const Point& a, const Point& b) { return Point(a.x + b.x, a.y + b.y, a.z + b.z); }\nPoint operator - (const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y, a.z - b.z); }\nPoint operator * (const double& k, const Point& a) { return Point(k*a.x, k*a.y, k*a.z); }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y + a.z*a.z; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble dot(Point a, Point b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\ndouble cross(Point a, Point b) { return sqrt(norm(a)*norm(b) - dot(a, b)*dot(a, b)); }\n\nstruct Obstacle {\n  Point  p;\n  double r;\n  ll     l;\n};\n\ndouble getdist(Point a, Point b, Point p)\n{\n  if(dot(b - a, p - a) < 0.0) return abs(p - a);\n  if(dot(a - b, p - b) < 0.0) return abs(p - b);\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\nint main()\n{\n  int N, Q;\n  cin >> N >> Q;\n  vector<Obstacle> obs(N);\n  for(int i = 0; i < N; i++) {\n    cin >> obs[i].p.x >> obs[i].p.y >> obs[i].p.z >> obs[i].r >> obs[i].l;\n  }\n  for(int i = 0; i < Q; i++) {\n    ll ans = 0;\n    Point s, d;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    for(int j = 0; j < N; j++) {\n      double dist = getdist(s, d, obs[j].p);\n      if(dist <= obs[j].r + 1e-10) ans += obs[j].l;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <complex>\n#define repi(i,x,n) for(int i = x; i < n; i++)\n#define rep(i,n) repi(i,0,n)\n#define int long long\nusing namespace std;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst double EPS = 1e-8;\n\n#define int long long\n\nstruct point{\n    int x,y,z;\n    int r, l;\n};\n\nlong double eps = 1e-5;\nint N, Q;\nvector<point> P;\npoint A, B, C;\n\nint solve(){\n    long double a = sqrt(B.x*B.x + B.y*B.y + B.z*B.z);\n    long double  b, ab, res = 0;\n    long double c, d, e;\n\n    for(int i = 0; i < N; i++){\n        C.x = P[i].x - A.x;\n        C.y = P[i].y - A.y;\n        C.z = P[i].z - A.z;\n        b = sqrt(C.x*C.x + C.y*C.y + C.z*C.z);\n        ab =  B.x*C.x + B.y*C.y + B.z*C.z;\n        c = b*(ab/(a*b));\n        d = b*b - c*c;\n\n\t//\tcout<<\"a = \"<<a<<\" b = \"<<b<<\" c = \"<<c<<endl;\n\t//\tcout<<\"ab -> \"<<ab<<endl;\n\t//cout<< \"cos -> \"<<ab/(a*b)<<endl;\n\t   \n\tif(c > a ||  ab/(a*b)  < 0 ) continue;\n\t\n        if(d < P[i].r*P[i].r + EPS) res += P[i].l;\n\t//\tcout<<\" d = \"<<d<<\" \"<<P[i].r*P[i].r<<endl;\n    }\n\n    return res;\n}\n\nsigned main(void)\n{\n    //  cin.tie(0);\n    // ios::sync_with_stdio(false);\n\n\n    cin>>N>>Q;\n\n    P.resize(N);\n\n    for(int i = 0; i < N; i++){\n        cin>>P[i].x>>P[i].y>>P[i].z>>P[i].r>>P[i].l;\n    }\n\n    for(int i = 0; i < Q; i++){\n        cin>>A.x>>A.y>>A.z>>B.x>>B.y>>B.z;\n        B.x -= A.x;\n        B.y -= A.y;\n        B.z -= A.z;\n        // B = A;\n        //cout<<\"i = \"<<i<<endl;\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_3d {\n\nusing Real = long double;\n\nReal const EPS = 1e-9;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  Real x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(Real x, Real y, Real z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (Real k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (Real k) const { return P3(x / k, y / k, z / k); }\n};\n\nReal dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\nReal norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\nReal abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\nReal cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\nReal angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { Real x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nReal distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  Real t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nReal distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, Real, double>> os;\n  rep(i, N) {\n    P3 p; Real r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; Real r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst double eps = 1e-10;\n\nstruct Point {\n  double x, y, z;\n  Point() {}\n  Point(double x, double y, double z) : x(x), y(y), z(z) {}\n  Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n  Point operator-(const Point& p) const { return Point(x - p.x, y - p.y, z - p.z); }\n  Point operator*(double k) const { return Point(x * k, y * k, z * k); }\n  friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y >> p.z; }\n};\n\ndouble abs(const Point& a) {\n  return sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n}\n\ndouble dot(const Point& a, const Point& b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nPoint cross(const Point& a, const Point& b) {\n  return Point(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n}\n\ndouble distanceSP(const Point& a, const Point& b, const Point& p) {\n  return abs(cross(b - a, p - a)) / abs(b - a);\n}\n\nstruct Circle {\n  Point c;\n  double r;\n  ll l;\n  Circle() {}\n  friend istream& operator>>(istream& is, Circle& c) { return is >> c.c >> c.r >> c.l; }\n};\n\nbool isThrough(Point& a, Point& b, Circle& c) {\n  if (dot(b - a, c.c - a) < -eps) return abs(c.c - a) - c.r < eps;\n  if (dot(a - b, c.c - b) < -eps) return abs(c.c - b) - c.r < eps;\n  return distanceSP(a, b, c.c) - c.r < eps;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  \n  int n, q;\n  cin >> n >> q;\n\n  vector<Circle> cs(n);\n  for (int i = 0; i < n; i++) {\n    cin >> cs[i];\n  }\n\n  for (int i = 0; i < q; i++) {\n    Point a, b;\n    cin >> a >> b;\n\n    ll ans = 0;\n    for (int j = 0; j < n; j++) {\n      if (isThrough(a, b, cs[j])) ans += cs[j].l;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst double eps = 1e-9;\n\nstruct Point{\n\tdouble x,y,z;\n};\nstruct Obstacle{\n\tPoint p;\n\tdouble r;\n\tint l;\n};\n\n//distance between p+t*vec(line) and q(point)\ndouble distLP3(Point p, Point r, Point q){\n\tdouble vx=p.x-r.x, vy=p.y-r.y, vz=p.z-r.z;\n\tdouble t = (vx*(q.x-p.x) +vy*(q.y-p.y) +vz*(q.z-p.z) ) /\n\t\t\t(vx*vx +vy*vy +vz*vz);\n\tdouble a = p.x -q.x +t*vx;\n\tdouble b = p.y -q.y +t*vy;\n\tdouble c = p.z -q.z +t*vz;\n\treturn sqrt(a*a +b*b +c*c);\n}\n\nint main(){\n\tint n,q;\n\tcin >> n >> q;\n\tvector<Obstacle> ob(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> ob[i].p.x >> ob[i].p.y >> ob[i].p.z >> ob[i].r >> ob[i].l;\n\t}\n\t\n\tfor(int i=0; i<q; i++){\n\t\tPoint s,d;\n\t\tcin >> s.x >> s.y >> s.z;\n\t\tcin >> d.x >> d.y >> d.z;\n\t\tint count=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(distLP3(s, d, ob[j].p) < ob[j].r +eps){\n\t\t\t\tcount+=ob[j].l;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#define DIVIDE 10000.0\nconst int INF = 1e9;\nconst double EPS = 0.00001;\nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    ld x[n + 1], y[n + 1], z[n + 1], r[n + 1], l[n + 1];\n    for(int i = 0; i < n; i++)\n    {\n        cin >> x[i] >> y[i] >> z[i] >> r[i]>> l[i];\n    }\n    ld sx, sy, sz, dx, dy, dz;\n    for(int i = 0; i < m; i++)\n    {\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        ld ax = (ld)(sx - dx) / DIVIDE;\n        ld ay = (ld)(sy - dy) / DIVIDE;\n        ld az = (ld)(sz - dz) / DIVIDE;\n \n        ld bx = sx;\n        ld by = sy;\n        ld bz = sz;\n        bool flag[n + 1] = {};\n        ll ans = 0;\n        for(int j = 0; j <= DIVIDE; j++)\n        {\n            for(int k = 0; k < n; k++)\n            {\n                ld cx = bx - x[k];\n                ld cy = by - y[k];\n                ld cz = bz - z[k];\n                ld dist = cx * cx + cy * cy + cz * cz;\n                if(dist - r[k] * r[k] <= EPS)\n                    flag[k] = true;\n            }\n            bx -= ax;\n            by -= ay;\n            bz -= az;\n        }\n        for(int j = 0; j < n; j++)\n            if(flag[j])\n                ans += l[j];\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-8;\n\nstruct P {\n  double x, y, z;\n  P() {}\n  P(double x, double y, double z) : x(x), y(y), z(z) {}\n};\n\nP operator + (const P &a, const P &b) {\n  return P(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nP operator - (const P &a, const P &b) {\n  return P(a.x - b.x, a.y - b.y, a.z - b.z);\n}\nP operator * (const P &a, const double &d) {\n  return P(a.x * d, a.y * d, a.z * d);\n}\nP operator * (const double &d, const P &a) {\n  return a * d;\n}\nP operator / (const P &a, const double &d) {\n  return P(a.x / d, a.y / d, a.z / d);\n}\nP operator / (const double &d, const P &a) {\n  return a / d;\n}\nP& operator += (P &a, const P &b) {\n  return a = a + b;\n}\nP& operator -= (P &a, const P &b) {\n  return a = a - b;\n}\nP& operator *= (P &a, const double &d) {\n  return a = a * d;\n}\nP& operator /= (P &a, const double &d) {\n  return a = a / d;\n}\n\ndouble dot(P a, P b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ndouble norm(P a) {\n  return dot(a, a);\n}\n\ndouble abs(P a) {\n  return sqrt(norm(a));\n}\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(p - project(s1, s2, p));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nint main() {\n  for(int N, Q; cin >> N >> Q; ) {\n    vector<P> ps(N);\n    vector<double> rs(N);\n    vector<int> ls(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].x >> ps[i].y >> ps[i].z\n          >> rs[i] >> ls[i];\n    }\n    while(Q--) {\n      P s, d;\n      cin >> s.x >> s.y >> s.z\n          >> d.x >> d.y >> d.z;\n      int sum = 0;\n      for(int i = 0; i < N; ++i) {\n        double dist = getDistanceSP(s, d, ps[i]);\n        if(dist + eps < rs[i]) sum += ls[i];\n      }\n      cout << sum << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<long long>;\nusing vlad=valarray<double>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\ndouble msum(vlad a,vlad b){\n    return (double)((a*b).sum());\n}\ndouble msum(vlad a){\n    return (double)((a*a).sum());\n}\n\ndouble dot(vlad a,vlad b){\n    return msum(a,b)/sqrt(msum(a))/sqrt(msum(b));\n}\n\nint main(){\n    int n,m;cin>>n>>m;\n    vector<pair<vlad,vlai>> obs(n,mp(vlad(0.0,3),vlai(0ll,2)));\n    rep(i,n){cin>>obs[i].fs[0]>>obs[i].fs[1]>>obs[i].fs[2]>>obs[i].sc[0]>>obs[i].sc[1];}\n    vlad a(0.0,3),b(0.0,3);\n    rep(i,m){\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        double d=sqrt(msum(a-b));\n        vlad u=(b-a)/d;\n        ll ans=0;\n        rep(j,n){\n            double dst=0.0;\n            if(dot(b-a,b-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-b));\n            }else if(dot(a-b,a-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-a));\n            }else{\n                vlad p=msum(obs[j].fs-a,u)*u+a;\n                dst=sqrt(msum(p-obs[j].fs));\n                //cout<<p[0]<<\",\"<<p[1]<<\",\"<<p[2]<<\",\"<<endl;\n            }\n            //cout<<dst<<\",\"<<obs[j].sc[0];\n            if(dst<=obs[j].sc[0]+EPS) {\n                //cout<<\" OK : \"<<obs[j].sc[1];\n                ans+=obs[j].sc[1];\n            }\n            //cout<<endl;\n        }\n        cout<<ans<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define eps 1e-10\n\nint main() {\n\n  long long int n, q;\n  cin >> n >> q;\n\n  vector< long long int > x, y, z, r, l;\n\n  for ( long long int i = 0; i < n; i++ ) {\n\n    long long int in_x, in_y, in_z, in_r, in_l;\n    cin >> in_x >> in_y >> in_z >> in_r >> in_l;\n    x.push_back( in_x );\n    y.push_back( in_y );\n    z.push_back( in_z );\n    r.push_back( in_r );\n    l.push_back( in_l );\n\n  }\n\n  vector< long long int > sx, sy, sz, dx, dy, dz;\n\n  for ( long long int i = 0; i < q; i++ ) {\n\n    long long int in_x, in_y, in_z;\n    cin >> in_x >> in_y >> in_z;\n    sx.push_back( in_x );\n    sy.push_back( in_y );\n    sz.push_back( in_z );\n    cin >> in_x >> in_y >> in_z;\n    dx.push_back( in_x );\n    dy.push_back( in_y );\n    dz.push_back( in_z );\n\n  }\n\n  for ( long long int i = 0; i < q; i++ ) {\n\n    long long int ans = 0;\n\n    long long int vx = dx[i] - sx[i];\n    long long int vy = dy[i] - sy[i];\n    long long int vz = dz[i] - sz[i];\n\n    for ( long long int j = 0; j < n; j++ ) {\n\n      long long int vsx = x[j] - sx[i];\n      long long int vsy = y[j] - sy[i];\n      long long int vsz = z[j] - sz[i];\n      long long int vdx = x[j] - dx[i];\n      long long int vdy = y[j] - dy[i];\n      long long int vdz = z[j] - dz[i];\n\n      long long int vs = vsx * vx + vsy * vy + vsz * vz;\n      long long int vd = vdx * -vx + vdy * -vy + vdz * -vz;\n\n      if ( vs > 0 && vd > 0 ) {\n\n\tdouble a = sqrt( vsx * vsx + vsy * vsy + vsz * vsz );\n\tdouble b = sqrt( vx * vx + vy * vy + vz * vz );\n\tdouble c = sqrt( vdx * vdx + vdy * vdy + vdz * vdz );\n\n\tdouble h = sqrt( ( a * b * 2 + c * c - a * a - b * b ) * ( a * b * 2 - ( c * c - a * a - b * b ) ) ) / ( b * 2 );\n\n\tif ( h - r[j] <= eps ) ans += l[j];\n\n      }\n\n    }\n\n    cout << ans << endl;\n\n  }\n\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct _vec{\n    double x, y, z;\n} vec;\n\ndouble Dis(vec A, vec B){\n    double dis = (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) + (A.z-B.z)*(A.z-B.z);\n    //cout << dis << \" o \" <<  endl;\n    dis = pow(dis, 0.5);\n    //cout << dis << \" o \" <<  endl;    \n    return dis;\n}\n\ndouble norm(vec A, vec B){             //内積\n    double res;\n    res = A.x*B.x + A.y*B.y + A.z*B.z;   \n\n    return res;\n}\n\nvec tanni(vec A){                   //単位ベクトルを返す\n    double dis = A.x*A.x + A.y*A.y + A.z*A.z;\n    dis = pow(dis, 0.5);\n    vec res;\n    res.x = A.x / dis;\n    res.y = A.y / dis;\n    res.z = A.z / dis;\n\n    return res;    \n}\n\nvec houkou(vec A, vec B){             //方向ベクトルを返す\n    vec res;\n    //cout << B.x << \" \" << A.x << endl;\n    res.x = B.x - A.x;\n    res.y = B.y - A.y;\n    res.z = B.z - A.z;\n    return res;\n}\n\nint main(){\n\n    /*vec V1, V2;\n    V1.x = 3;\n    V1.y = 4;\n    V1.z = 5;\n    V2.x = 6;\n    V2.y = 3;\n    V2.z = 8;\n\n    cout << norm(V1, V2) << endl;\n    cout << Dis(V1, V2) << endl;\n    vec V3 = tanni(V1);\n    cout << V3.x << \" \" << V3.y << \" \" << V3.z << endl;\n    vec V4 = houkou(V1, V2);\n    cout << V4.x << \" \" << V4.y << \" \" << V4.z << endl;*/\n    \n\n    int n, q; cin >> n >> q;\n    vector<vec> obj(n);\n    vector<vec> blue(q);\n    vector<vec> red(q);    \n    vector<double> r(n);\n    vector<int> l(n);\n\n    for(int i = 0; i < n; i++){\n        double a, b, c, d, e; cin >> a >> b >> c >> d >> e;\n        obj[i].x = a;\n        obj[i].y = b;\n        obj[i].z = c;\n        r[i] = d;\n        l[i] = e;                \n    }\n\n    for(int i = 0; i < q; i++){\n        double a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f;\n        blue[i].x = d;\n        blue[i].y = e;\n        blue[i].z = f;\n        red[i].x = a;\n        red[i].y = b;\n        red[i].z = c;        \n    }\n\n\n\n    for(int i = 0; i < q; i++){\n\n        int ans = 0;\n\n        for(int j = 0; j < n; j++){\n            //j個目の障害物とはどうですか\n            vec H;\n            H.x = red[i].x;\n            H.y = red[i].y;\n            H.z = red[i].z;            \n\n            vec u;\n            u = houkou(red[i], blue[i]);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;            \n            u = tanni(u);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;\n            vec a;\n            a.x = obj[j].x - red[i].x;\n            a.y = obj[j].y - red[i].y;\n            a.z = obj[j].z - red[i].z;\n            //cout << a.x << \" \" << a.y << \" \" <<  a.z << endl;           \n            double _norm = norm(a, u);\n            //cout << _norm << endl;\n            vec w;\n            w.x = _norm*u.x;\n            w.y = _norm*u.y;\n            w.z = _norm*u.z;\n            //cout << endl;\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << w.x << \" \" << w.y << \" \" << w.z << endl;\n            H.x += w.x;\n            H.y += w.y;\n            H.z += w.z;\n\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << obj[j].x << \" \" << obj[j].y << \" \" << obj[j].z << endl;\n\n            double _dis = Dis(H, obj[j]);\n            //cout << j << \" \" << _dis << endl;\n            //cout << _dis << endl;\n            if(_dis <= r[j]) ans += l[j];            \n            //cout << ans << endl;\n        \n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\n#define eps 1e-8\n\nint n,q;\ndouble p[55][3],r[55],l[55];\n\ndouble dot(double a[3],double b[3]){\n  double res=0;\n  rep(i,3)res+=a[i]*b[i];\n  return res;\n}\ndouble nrm(double a[3]){\n  double res=0;\n  rep(i,3)res+=a[i]*a[i];\n  return res;\n}\ndouble abs(double a[3]){\n  return sqrt(nrm(a));\n}\nvoid proj(double a[3],double b[3],double res[3]){\n  double c=dot(a,b);\n  double d=abs(b);\n  rep(i,3)res[i]=b[i]*c/d/d;\n  return ;\n}\ndouble distSP(double a[3],double b[3],double p[3]){\n  double ap[3],bp[3],ab[3],pr[3];\n  rep(i,3){\n    ap[i]=p[i]-a[i];\n    bp[i]=p[i]-b[i];\n    ab[i]=b[i]-a[i];\n  }\n  double r[3];\n  double res=0;\n  proj(ap,ab,r);\n  if(abs(ab)-abs(r)<-eps||dot(ab,r)<eps){\n    //dbg(abs(ab)-abs(r));\n    return min(abs(ap),abs(bp));\n  }else{\n    rep(i,3)pr[i]=ap[i]-r[i];\n    return abs(pr);\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>q;\n  rep(i,n){\n    rep(j,3)cin>>p[i][j];\n    cin>>r[i]>>l[i];\n  }\n  rep(hoge,q){\n    ll res=0;\n    double a[3],b[3];\n    rep(i,3)cin>>a[i];\n    rep(i,3)cin>>b[i];\n    rep(i,n){\n      //dbg(distSP(a,b,p[i]));\n      if(distSP(a,b,p[i])<r[i]+eps)res+=l[i];\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nvector<Point> crosspointLC(const Line& l,const Circle& ci){\n  Point dir = unit(l[1] - l[0]);\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  vector<Point> res;\n  if(D < 0) return res;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(abs(t1) < abs(t2)){\n    res.push_back(l[0] + dir * t1);\n  }\n  else{\n    res.push_back(l[0] + dir * t2);\n  }\n  return res;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<int> costs;\n    vector<bool> used;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      int amount_of_consumption;\n      scanf(\"%d %d %d %d %d\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n      used.push_back(false);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      int sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        vector<Point> p = crosspointLC(line,obstacles[obstacle_i]);\n        if(!used[obstacle_i] && p.size() > 0) {\n          sum += costs[obstacle_i];\n          used[obstacle_i] = true;\n        }\n      }\n      printf(\"%d\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n\nstruct P{\n  double X, Y, Z;\n};\n\nnamespace std{\n  P operator-(const P& a, const P& b){\n    P ret = {a.X-b.X, a.Y-b.Y, a.Z-b.Z};\n    return ret;\n  }\n}\n\ndouble dot_3d(P a, P b){\n  return a.X*b.X + a.Y*b.Y + a.Z*b.Z;\n}\n\nP cross(P a, P b){\n  P ret = {a.Y*b.Z-a.Z*b.Y,a.Z*b.X-a.X*b.Z,a.X*b.Y-a.Y*b.X};\n  return ret;\n}\n\ndouble norm_3d(P a){\n  return a.X*a.X + a.Y*a.Y + a.Z*a.Z;\n}\n\nint main(){\n  int N, Q;\n  cin >> N >> Q;\n  vector<P> obs(N);\n  vector<int> r(N), l(N);\n  for(int i = 0; i < N; ++i){\n    cin >> obs[i].X >> obs[i].Y >> obs[i].Z >> r[i] >> l[i];\n  }\n  P s, d;\n  for(int i = 0; i < Q; ++i){\n    cin >> s.X >> s.Y >> s.Z >> d.X >> d.Y >> d.Z;\n    P v = d-s;\n    int ans = 0;\n    for(int i = 0; i < N; ++i){\n      if(norm_3d(cross(v,obs[i]-s))/norm_3d(v) <= r[i]*r[i] &&\n\t dot_3d(v,obs[i]-s) >= 0 && dot_3d(s-d,obs[i]-d) > 0) ans += l[i];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  double x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  long long int  r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2*area)/abs(l.second - l.first);\n  //std::cout << abs(l.second - l.first) << \" \" << abs(p - l.first) << std::endl;\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  //  std::cout << \"cosa:\" << cosa << \" cosb:\" << cosb << std::endl;\n  if(cosa < 0) return abs(p - l.first);\n  if(cosb < 0) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].c.x >> p[i].c.y >> p[i].c.z >> p[i].r >> p[i].l;\n    //std::cout << p[i].c.x << \" \" << p[i].c.y << \" \" <<\n    //p[i].c.z << \" \" << p[i].r << \" \" << p[i].l << std::endl;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    long long int ans = 0;\n    scanf(\"%lf %lf %lf %lf %lf %lf\", &s.x, &s.y, &s.z, &d.x, &d.y, &d.z);\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      double d = dis(l, p[j].c);\n      //std::cout << \"j:\" << j << \" dis:\" << d << \" r:\" << p[j].r << std::endl;\n      if(d <= p[j].r){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define EPS 1e-10\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y,z;\n\tP(){}\n\tP(double xx,double yy,double zz){\n\t\tx=xx;\n\t\ty=yy;\n\t\tz=zz;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),add(z,p.z));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),add(z,-p.z));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,z*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(add(x*p.x,y*p.y),z*p.z);\n\t}\n};\n\ndouble dist(P p){\n\treturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z);\n}\n\nint n,q;\nP s[51],g[51];\nP b[51];\ndouble r[51];\nint l[51];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %lf %lf %lf %d\",&b[i].x,&b[i].y,&b[i].z,&r[i],&l[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf\",&s[i].x,&s[i].y,&s[i].z);\n\t\tscanf(\"%lf %lf %lf\",&g[i].x,&g[i].y,&g[i].z);\n\t\tint res=0;\n\t\tP v=g[i]-s[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tP c=b[j]-s[i];\n\t\t\tif(v.dot(c)<0){\n\t\t\t\tif(r[j]>dist(c))res+=l[j];\n\t\t\t}else{\n\t\t\t\tif(v.dot(c)>dist(v)*dist(v)){\n\t\t\t\t\tif(dist(g[i]-b[j])<r[j])res+=l[j];\n\t\t\t\t}else{\n\t\t\t\t\tdouble len=dist(c)*dist(c)-(v.dot(c)*v.dot(c))/(dist(v)*dist(v));\n\t\t\t\t\tif(len<=r[j]*r[j])res+=l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n  int x, y, z;\n  Point(){}\n  Point(int x, int y, int z):x(x), y(y), z(z){}\n};\nPoint operator + (const Point& a, const Point& b) { return Point(a.x + b.x, a.y + b.y, a.z + b.z); }\nPoint operator - (const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y, a.z - b.z); }\nPoint operator * (const double& k, const Point& a) { return Point(k*a.x, k*a.y, k*a.z); }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y + a.z*a.z; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble dot(Point a, Point b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\ndouble cross(Point a, Point b) { return sqrt(norm(a)*norm(b) - dot(a, b)*dot(a, b)); }\n\nstruct Obstacle {\n  Point  p;\n  double r;\n  ll     l;\n};\n\ndouble getdist(Point a, Point b, Point p)\n{\n  if(dot(b - a, p - a) < 0.0) return abs(p - a);\n  if(dot(a - b, p - b) < 0.0) return abs(p - b);\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\nint main()\n{\n  int N, Q;\n  cin >> N >> Q;\n  vector<Obstacle> obs(N);\n  for(int i = 0; i < N; i++) {\n    cin >> obs[i].p.x >> obs[i].p.y >> obs[i].p.z >> obs[i].r >> obs[i].l;\n  }\n  for(int i = 0; i < Q; i++) {\n    ll ans = 0;\n    Point s, d;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    for(int j = 0; j < N; j++) {\n      double dist = getdist(s, d, obs[j].p);\n      cout << dist << \" \" << obs[j].r << endl;\n      if(dist <= obs[j].r + 1e-10) ans += obs[j].l;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tif (max(x2, max(y2, z2)) == 0) { dismin = 0.0; }\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\tfor (double k = 0; k >= max(x2, max(y2, z2)); k -= 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1 + 0.00000001) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,qc,x[51],y[51],z[51],rl[51];\ndouble dx,dy,dz,sx,sy,sz,a,b,c,p,q,r;\nlong long int l[51],sum;\ndouble t,lt;\nint main(){\n\tcin >>n >>qc;\n\tfor(int i=0;i<n;i++){\n\t\tcin >>x[i] >>y[i] >>z[i] >>rl[i] >>l[i];\n\t}\n\tfor(int i=0;i<qc;i++){\n\t\tsum=0;\n\t\tcin >>sx >>sy >>sz >>dx >>dy >>dz;\n\t\ta=dx-sx;\n\t\tb=dy-sy;\n\t\tc=dz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp=sx-x[j];\n\t\t\tq=sy-y[j];\n\t\t\tr=sz-z[j];\n\t\t\tt=-(a*p+b*q+c*r)/(a*a+b*b+c*c);\n\t\t\tlt=(t*a+p)*(t*a+p)+(t*b+q)*(t*b+q)+(t*c+r)*(t*c+r);\n\t\t\tif(lt<rl[j]*rl[j])sum+=l[j];\n\t\t\t//cout <<t <<endl;\n\t\t\t//cout <<lt <<endl;\n\t\t}\n\t\tcout <<sum <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-8;\n\nstruct P {\n  double x, y, z;\n  P() {}\n  P(double x, double y, double z) : x(x), y(y), z(z) {}\n};\n\nP operator + (const P &a, const P &b) {\n  return P(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nP operator - (const P &a, const P &b) {\n  return P(a.x - b.x, a.y - b.y, a.z - b.z);\n}\nP operator * (const P &a, const double &d) {\n  return P(a.x * d, a.y * d, a.z * d);\n}\nP operator * (const double &d, const P &a) {\n  return a * d;\n}\nP operator / (const P &a, const double &d) {\n  return P(a.x / d, a.y / d, a.z / d);\n}\nP operator / (const double &d, const P &a) {\n  return a / d;\n}\nP& operator += (P &a, const P &b) {\n  return a = a + b;\n}\nP& operator -= (P &a, const P &b) {\n  return a = a - b;\n}\nP& operator *= (P &a, const double &d) {\n  return a = a * d;\n}\nP& operator /= (P &a, const double &d) {\n  return a = a / d;\n}\n\ndouble dot(P a, P b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ndouble norm(P a) {\n  return dot(a, a);\n}\n\ndouble abs(P a) {\n  return sqrt(norm(a));\n}\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(p - project(s1, s2, p));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nint main() {\n  for(int N, Q; cin >> N >> Q; ) {\n    vector<P> ps(N);\n    vector<double> rs(N);\n    vector<int> ls(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].x >> ps[i].y >> ps[i].z\n          >> rs[i] >> ls[i];\n    }\n    while(Q--) {\n      P s, d;\n      cin >> s.x >> s.y >> s.z\n          >> d.x >> d.y >> d.z;\n      int sum = 0;\n      for(int i = 0; i < N; ++i) {\n        double dist = getDistanceSP(s, d, ps[i]);\n        if(dist < rs[i] + eps) sum += ls[i];\n      }\n      cout << sum << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 50\nusing namespace std;\ntypedef struct circle{\n  int x,y,z,r,l;\n} Circle;\ntypedef struct point{\n  int x,y,z;\n} Point;\n\nint main(){\n  int n,q;\n  double d;\n  Point blue,red;\n  Circle c[N];\n  cin>>n>>q;\n  for(int i=0;i<n;i++) cin>>c[i].x>>c[i].y>>c[i].z>>c[i].r>>c[i].l;\n  while(q--){\n    cin>>red.x>>red.y>>red.z>>blue.x>>blue.y>>blue.z;\n    long long sum=0;\n    for(int i=0;i<n;i++){\n      int x=c[i].x-red.x,y=c[i].y-red.y,z=c[i].z-red.z;\n      int x2=blue.x-red.x,y2=blue.y-red.y,z2=blue.z-red.z;\n      int t=((x*x2)+(y*y2)+(z*z2));\n      d=x*x+y*y+z*z-(1.0*t*t)/(x2*x2+y2*y2+z2*z2);\n      if(d<=c[i].r*c[i].r){\n\tsum+=c[i].l;\n      }\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 10e8\nusing namespace std;\nstruct st{long double x,y,z;};\nst v[101];\nlong double a1,a2,a3,sx,sy,sz,gx,gy,gz;\nlong double a4,a5,t[101],p[101];\nlong double ch(int q){\n  long double px=v[q].x,py=v[q].y,pz=v[q].z;\n  long double t1=sqrt((sx-gx)*(sx-gx)+(sy-gy)*(sy-gy)+(sz-gz)*(sz-gz));\n  long double t2=sqrt((px-gx)*(px-gx)+(py-gy)*(py-gy)+(pz-gz)*(pz-gz));\n  long double t3=sqrt((sx-px)*(sx-px)+(sy-py)*(sy-py)+(sz-pz)*(sz-pz));\n  long double s=(t1+t2+t3)/2;\n  long double h=sqrt(s*(s-t1)*(s-t2)*(s-t3))*2/t1;\n  if(abs(sqrt(t2*t2-h*h)+sqrt(t3*t3-h*h)-t1)>1)return eps;\n  return h;\n}\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>a1>>a2>>a3>>a4>>a5;\n    v[i].x=a1;v[i].y=a2;v[i].z=a3;\n    t[i]=a4;p[i]=a5;\n  }\n  while(m--){\n    int sum=0;\n    cin>>sx>>sy>>sz>>gx>>gy>>gz;\n    for(int i=0;i<n;i++){\n      long double h=ch(i);\n      if(h<(long double)(t[i]))sum+=p[i];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\n#define double long double\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nconstexpr double eps=1e-9;\nconstexpr double PI=3.14159265358979323846264338327950;\n\ninline int sgn(double x){\n    if(x<-eps) return -1;\n    if(x>eps) return 1;\n    return 0;\n}\n\ninline bool EQ(double x, double y){\n    return sgn(x-y)==0;\n}\n\ninline bool GE(double x, double y){\n    return sgn(x-y)==1;\n}\n\ninline bool LE(double x, double y){\n    return sgn(x-y)==-1;\n}\n\ninline bool GEQ(double x, double y){\n    return sgn(x-y)>=0;\n}\n\ninline bool LEQ(double x, double y){\n    return sgn(x-y)<=0;\n}\n\nstruct Point{\n    double x, y, z;\n    Point(double x=0, double y=0, double z=0): x(x), y(y), z(z){}\n\n    Point operator+(const Point &p){\n        return {x+p.x, y+p.y, z+p.z};\n    }\n\n    Point operator-(const Point &p){\n        return {x-p.x, y-p.y, z-p.z};\n    }\n\n    Point operator*(const double k){\n        return {k*x, k*y, k*z};\n    }\n\n    Point operator/(const double k){\n        return {x/k, y/k, z/k};\n    }\n\n    double operator*(const Point &p){\n        return x*p.x+y*p.y+z*p.z;\n    }\n\n    bool operator==(const Point &p){\n        return EQ(x, p.x) && EQ(y, p.y) && EQ(z, p.z);\n    }\n};\n\nusing Vec=Point;\nusing Polygon=vector<Point>;\n\ndouble norm(Point p){\n    return p.x*p.x+p.y*p.y+p.z*p.z;\n}\n\ndouble abs(Point p){\n    return sqrt(norm(p));\n}\n\ndouble getDistanceLP(Point a, Vec v, Point p){\n    double t = v*(p-a) / norm(v);\n    return abs(a+v*t - p);\n}\n\ndouble getDistanceSP(Point a, Point b, Point p){\n    if(LE((b-a)*(p-a), 0)) return abs(p-a);\n    if(LE((a-b)*(p-b), 0)) return abs(p-b);\n    return getDistanceLP(a, b-a, p);\n}\n\nint main(){\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    Point p[n];\n    double r[n], l[n];\n    rep(i, n) scanf(\"%Lf%Lf%Lf%Lf%Lf\", &p[i].x, &p[i].y, &p[i].z, &r[i], &l[i]);\n\n    rep(_, q){\n        Point a, b;\n        scanf(\"%Lf%Lf%Lf\", &a.x, &a.y, &a.z);\n        scanf(\"%Lf%Lf%Lf\", &b.x, &b.y, &b.z);\n        double ans = 0;\n        rep(i, n){\n            if(LEQ(getDistanceSP(a, b, p[i]), r[i])) ans += l[i];\n        }\n        printf(\"%lld\\n\", (lint)(ans + 0.5));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\n// Geometry <3 {{{\nclass GeometryUtil {\n\tpublic:\n\t\tbool eql(double a, double b) { return abs(a - b) < EPS; }\n\t\tbool lt(double a, double b) { return b - a >= EPS; }\n\t\tbool lte(double a, double b) { return lt(a, b) || eql(a, b); }\n\t\tbool gt(double a, double b) { return !lte(a, b); }\n\t\tbool gte(double a, double b) { return !lt(a, b); }\n\t\tbool eql(P a, P b) { return eql(a.Y, b.Y) && eql(a.X, b.X); }\n\t\tGeometryUtil() {\n\t\t}\n};\n\nGeometryUtil geo = GeometryUtil();\n\ntemplate<typename T>\nclass Vector3D {\n\tpublic:\n\t\tT x, y, z;\n\t\tVector3D(T _x, T _y, T _z): x(_x), y(_y), z(_z) {\n\t\t}\n\n\t\tT abs() {\n\t\t\treturn sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n\t\t}\n\n\t\tT dot(Vector3D<T> rhs) {\n\t\t\treturn x * rhs.x + y * rhs.y + z * rhs.z;\n\t\t}\n\n\t\tVector3D<T> cross(Vector3D<T> rhs) {\n\t\t\treturn Vector3D(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);\n\t\t}\n\n\t\t// check if this Vector3D (as a point) is on a line (a-b)\n\t\tconst bool is_upon(const Vector3D<T> a, const Vector3D<T> b) const {\n\t\t\tdump((b-a).cross(b-(*this)).abs());\n\t\t\tdump(geo.eql((b-a).cross(b-(*this)).abs(), 0));\n\t\t\tdump((b-a).dot((*this)-a));\n\t\t\tdump(geo.gt( (b-a).dot((*this)-a), 0 ));\n\t\t\tdump((a-b).dot((*this)-b));\n\t\t\tdump(geo.gt( (a-b).dot((*this)-b), 0 ));\n\n\t\t\treturn geo.eql( (b-a).cross(b-(*this)).abs(), 0 ) &&\n\t\t\t\tgeo.gt( (b-a).dot((*this)-a), 0 ) &&\n\t\t\t\tgeo.gt( (a-b).dot((*this)-b), 0 );\n\t\t}\n\n\t\t// Add vector\n\t\tVector3D<T> operator+(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x + rhs.x, y + rhs.y, z + rhs.z);\n\t\t}\n\n\t\t// Subtract vecrtor\n\t\tVector3D<T> operator-(const Vector3D<T>& rhs) const {\n\t\t\treturn Vector3D<T>(x - rhs.x, y - rhs.y, z - rhs.z);\n\t\t}\n\n\t\t// Multiply by scala value\n\t\ttemplate<typename Scala>\n\t\tVector3D<T> operator*(const Scala rhs) const {\n\t\t\treturn Vector3D<T>(x * rhs, y * rhs, z * rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Vector3D<T>& v) {\n\treturn out << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\";\n}\n\nclass Sphere {\n\tint x, y, z, r;\n\tpublic:\n\t\tSphere(int _x, int _y, int _z, int _r) : x(_x), y(_y), z(_z), r(_r) {\n\t\t}\n};\n\n// }}}\n\nclass Obstacle {\n\tpublic:\n\t\tint x, y, z, r;\n\t\tULL magic;\n\t\tObstacle(int _x, int _y, int _z, int _r, ULL _magic) : x(_x), y(_y), z(_z), r(_r), magic(_magic) {\n\t\t}\n};\nostream& operator<<(ostream& out, const Obstacle& o) {\n\treturn out << \"((\" << o.x << \", \" << o.y << \", \" << o.z << \"), \" << o.r << \", \" << o.magic << \")\";\n}\n\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/3.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint N, Q; cin >> N >> Q;\n\tvector<Obstacle> obstacles;\n\tREP (i, N) {\n\t\tint x, y, z, r; ULL l; cin >> x >> y >> z >> r >> l;\n\t\tobstacles.PB(Obstacle(x, y, z, r, l));\n\t}\n\n\tREP (t, Q) {\n\t\tint x, y, z; cin >> x >> y >> z;\n\t\tVector3D<double> red(x, y, z);\n\t\tcin >> x >> y >> z;\n\t\tVector3D<double> blue(x, y, z);\n\t\tULL ans = 0;\n\t\tREP (i, N) {\n\t\t\tObstacle o = obstacles[i];\n\t\t\tdump(red);\n\t\t\tdump(blue);\n\t\t\tdump(o);\n\t\t\t// Move vectors so that the center of the obstacle become the origin\n\t\t\tVector3D<double> s = red - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> e = blue - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> v = e - s;\n\t\t\to.x = o.y = o.z = 0;\n\t\t\tdump(s);\n\t\t\tdump(e);\n\t\t\tdump(v);\n\t\t\tdump(o);\n\n\t\t\tdump(s.dot(v));\n\t\t\tdump(v.abs());\n\t\t\tdouble x = - s.dot(v) / (v.abs() * v.abs());\n\t\t\tdump(x);\n\t\t\tdump(v * x);\n\t\t\tVector3D<double> nearest = s + v * x;\n\t\t\tdump(nearest);\n\t\t\tdump(nearest.abs());\n\t\t\tdump(nearest.is_upon(s, e));\n\t\t\tif (nearest.abs() <= o.r + EPS && nearest.is_upon(s, e)) {\n\t\t\t\tdump(o.magic);\n\t\t\t\tans += o.magic;\n\t\t\t\tdump(ans);\n\t\t\t}\n\t\t}\n\t\tdump(ans);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\ndouble dot(vector<double> l, vector<double> r){\n  return l[0]*r[0]+l[1]*r[1]+l[2]*r[2];\n}\n\ndouble norm(vector<double> l){\n  return dot(l,l);\n}\n\nvector<double> add(vector<double> l, vector<double> r){\n  return {l[0]+r[0],l[1]+r[1],l[2]+r[2]};\n}\n\nvector<double> mul(double k, vector<double> l){\n  return {k*l[0],k*l[1],k*l[2]};\n}\n\nvector<double> diff(vector<double> l, vector<double> r){\n  return {l[0]-r[0],l[1]-r[1],l[2]-r[2]};\n}\n\nstruct obst{\npublic:\n  vector<double> p;\n  double r;\n  LL c;\n  obst():p(3){}\n};\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector<obst> ob(n);\n  rep(i,n){\n    cin >> ob[i].p[0] >> ob[i].p[1] >> ob[i].p[2] >> ob[i].r >> ob[i].c;\n  }\n  vector<double> s(3),t(3);\n  rep(tt,q){\n    rep(i,3) cin >> s[i];\n    rep(i,3) cin >> t[i];\n    LL ans=0;\n    rep(i,n){\n      vector<double> vs = diff(s,ob[i].p);\n      vector<double> vt = diff(t,ob[i].p);\n      double k = dot(vt,diff(vt,vs))/norm(diff(vt,vs));\n      double x = norm(add(mul(k,vs),mul(1-k,vt)));\n      vector<double> pos = add(ob[i].p,add(mul(k,vs),mul(1-k,vt)));\n      if(0<=k&&k<=1&&x<=ob[i].r*ob[i].r+0.0000001) ans+=ob[i].c;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<double>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\ndouble msum(vlai a,vlai b){\n    return (double)((a*b).sum());\n}\ndouble msum(vlai a){\n    return (double)((a*a).sum());\n}\n\ndouble dot(vlai a,vlai b){\n    return msum(a,b)/sqrt(msum(a))/sqrt(msum(b));\n}\n\nint main(){\n    int n,m;cin>>n>>m;\n    vector<pair<vlai,vlai>> obs(n,mp(vlai(0.0,3),vlai(0.0,2)));\n    rep(i,n){cin>>obs[i].fs[0]>>obs[i].fs[1]>>obs[i].fs[2]>>obs[i].sc[0]>>obs[i].sc[1];}\n    vlai a(0.0,3),b(0.0,3);\n    rep(i,m){\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        double d=sqrt(msum(a-b));\n        vlai u=(b-a)/d;\n        ll ans=0;\n        rep(j,n){\n            double dst=0.0;\n            if(dot(b-a,b-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-b));\n            }else if(dot(a-b,a-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-a));\n            }else{\n                vlai p=msum(obs[j].fs-a,u)*u+a;\n                dst=sqrt(msum(p-obs[j].fs));\n                //cout<<p[0]<<\",\"<<p[1]<<\",\"<<p[2]<<\",\"<<endl;\n            }\n            if(dst<=obs[j].sc[0]+EPS) ans+=obs[j].sc[1];\n        }\n        cout<<ans<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nstruct po{int a,b,c,r,l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n \n  int n,q;\n  cin >> n >>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].a>>ball[i].b>>ball[i].c>>ball[i].r>>ball[i].l;\n  \n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].a,ball[j].b,ball[j].c});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].a,ball[j].b,ball[j].c});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = 2*S/dis[0];\n      if(abs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0])<=0.00000001)\n     if(h <= ball[j].r||dis[1]<=ball[j].r||dis[2]<=ball[j].r) ans+=ball[j].l;\n\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nconst double EPS = 1e-5;\n\nstruct P3{\n  double x,y,z;\n  P3(){}\n  P3(double x,double y, double z):x(x),y(y),z(z) {}\n  P3 operator + (const P3 &a) const{ return (P3){x+a.x, y+a.y, z+a.z}; }\n  P3 operator - (const P3 &a) const{ return (P3){x-a.x, y-a.y, z-a.z}; }\n  P3 operator / (double c) const{ return (P3){x/c, y/c, z/c}; }\n\n};\nP3 operator * (double c, const P3 &a){ return (P3){c * a.x, c * a.y, c * a.z}; }\nP3 operator * (const P3 &a, double c){ return (P3){c * a.x, c * a.y, c * a.z}; }\n//???????????°????????¨\nostream& operator<<(ostream& os,const P3& p) {\n  os << \"(\" << p.x << \",\" <<p.y << \",\" << p.z << \")\";\n  return os;\n}\n\n\nstruct L3{\n  P3 a,b;\n  L3(P3 a,P3 b):a(a),b(b){}\n};\n\n\ndouble norm(P3 a){ return a.x*a.x + a.y*a.y + a.z*a.z; }\ndouble abs(P3 a){ return sqrt(norm(a)); }\ndouble dot(P3 a, P3 b){ return a.x*b.x+ a.y*b.y + a.z*b.z; }\nP3 cross(P3 a, P3 b){\n  return (P3){a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x};\n}\n\n// ????????¨???????????¢\ndouble distSP(L3 S, P3 p){\n  double a = dot(S.b-S.a, S.b-S.a);\n  double b = dot(S.b-S.a, S.a- p );\n  double c = dot(S.a- p , S.a- p );\n  double t = -b / a;\n  if(t < 0) return abs(S.a - p);\n  if(t > 1) return abs(S.b - p);\n  return sqrt(a * t * t + 2 * b * t + c);\n}\n\nint N,Q;\nP3 c[55];\ndouble r[55];\nlong long l[55];\n\nint main(){\n  cin >> N >> Q;\n  for(int i=0;i<N;i++){\n    int x,y,z,rx; cin >>  x>> y >> z >> rx >> l[i];\n    c[i] = P3( x, y, z );\n    r[i] = rx;\n  }\n  for(int i=0;i<Q;i++){\n    long long res = 0;\n    int x1,y1,z1,x2,y2,z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    L3 s = L3( P3( x1, y1, z1 ), P3( x2, y2, z2 ) );\n    for(int j=0;j<N;j++)\n      if( r[j]+EPS > distSP( s, c[j] ) )\n        res += l[j];    \n    cout << res << endl;\n  }  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble INF = 1000000;\ndouble EPS = 0.00000001;\nint main(){\n  int N, Q;\n  cin >> N >> Q;\n  vector<double> x(N), y(N), z(N), r(N);\n  vector<long long> l(N);\n  for (int i = 0; i < N; i++){\n    cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  }\n  for (int i = 0; i < Q; i++){\n    double sx, sy, sz, dx, dy, dz;\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    double lx = dx - sx;\n    double ly = dy - sy;\n    double lz = dz - sz;\n    long long ans = 0;\n    for (int j = 0; j < N; j++){\n      double left = 0;\n      double right = 1;\n      double dist = INF;\n      for (int k = 0; k < 50; k++){\n        double mid1 = (left * 2 + right) / 3;\n        double mid2 = (left + right * 2) / 3;\n        double d1 = sqrt(pow(sx + lx * mid1 - x[j], 2) + pow(sy + ly * mid1 - y[j], 2) + pow(sz + lz * mid1 - z[j], 2));\n        double d2 = sqrt(pow(sx + lx * mid2 - x[j], 2) + pow(sy + ly * mid2 - y[j], 2) + pow(sz + lz * mid2 - z[j], 2));\n        if (d1 > d2){\n          left = mid1;\n          dist = min(dist, d2);\n        } else {\n          right = mid2;\n          dist = min(dist, d1);\n        }\n      }\n      if (dist < r[j] + EPS){\n        ans += l[j];\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,qc,x[51],y[51],z[51],rl[51];\ndouble dx,dy,dz,sx,sy,sz,a,b,c,p,q,r;\nlong long int l[51],sum;\ndouble t,lt;\nint main(){\n\tcin >>n >>qc;\n\tfor(int i=0;i<n;i++){\n\t\tcin >>x[i] >>y[i] >>z[i] >>rl[i] >>l[i];\n\t}\n\tfor(int i=0;i<qc;i++){\n\t\tsum=0;\n\t\tcin >>sx >>sy >>sz >>dx >>dy >>dz;\n\t\ta=dx-sx;\n\t\tb=dy-sy;\n\t\tc=dz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp=sx-x[j];\n\t\t\tq=sy-y[j];\n\t\t\tr=sz-z[j];\n\t\t\tt=-(a*p+b*q+c*r)/(a*a+b*b+c*c);\n\t\t\tif(t>1){\n\t\t\t\tt=1;\n\t\t\t}else if(t<0){\n\t\t\t\tt=0\n\t\t\t}\n\t\t\tlt=(t*a+p)*(t*a+p)+(t*b+q)*(t*b+q)+(t*c+r)*(t*c+r);\n\t\t\t\n\t\t\tif(lt<=rl[j]*rl[j])sum+=l[j];\n\t\t\t//cout <<t <<endl;\n\t\t\t//cout <<lt <<endl;\n\t\t\t//cout <<rl[j] <<endl;\n\t\t}\n\t\tcout <<\" sum is \"<<sum <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define STEPS 10000000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tlong double vx = 1.0 * (sx - dx) / STEPS;\n\t\tlong double vy = 1.0 * (sy - dy) / STEPS;\n\t\tlong double vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tlong double tx = sx;\n\t\tlong double ty = sy;\n\t\tlong double tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tlong double rx = tx - x[i];\n\t\t\t\tlong double ry = ty - y[i];\n\t\t\t\tlong double rz = tz - z[i];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[i] * r[i] + 0.0001)\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttx -= vx;\n\t\t\tty -= vy;\n\t\t\ttz -= vz;\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<double>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\ndouble msum(vlai a,vlai b){\n    return (double)((a*b).sum());\n}\ndouble msum(vlai a){\n    return (double)((a*a).sum());\n}\n\ndouble dot(vlai a,vlai b){\n    return msum(a,b)/sqrt(msum(a))/sqrt(msum(b));\n}\n\nint main(){\n    int n,m;cin>>n>>m;\n    vector<pair<vlai,vlai>> obs(n,mp(vlai(0.0,3),vlai(0.0,2)));\n    rep(i,n){cin>>obs[i].fs[0]>>obs[i].fs[1]>>obs[i].fs[2]>>obs[i].sc[0]>>obs[i].sc[1];}\n    vlai a(0.0,3),b(0.0,3);\n    rep(i,m){\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        double d=sqrt(msum(a-b));\n        vlai u=(b-a)/d;\n        ll ans=0;\n        rep(j,n){\n            double dst=0.0;\n            if(dot(b-a,b-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-b));\n            }else if(dot(a-b,a-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-a));\n            }else{\n                vlai p=msum(obs[j].fs-a,u)*u+a;\n                dst=sqrt(msum(p-obs[j].fs));\n                //cout<<p[0]<<\",\"<<p[1]<<\",\"<<p[2]<<\",\"<<endl;\n            }\n            if(abs(dst-obs[j].sc[0])<EPS) ans+=obs[j].sc[1];\n        }\n        cout<<ans<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define sq(x) ((x) * (x))\n\nusing namespace std;\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tcin >> xa >> ya >> za >> xb >> yb >> zb;\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq <= sq(r[i]))\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_3d {\n\nusing Real = long double;\n\nReal const EPS = 1e-9;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  Real x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(Real x, Real y, Real z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (Real k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (Real k) const { return P3(x / k, y / k, z / k); }\n};\n\nReal dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\nReal norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\nReal abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\nReal cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\nReal angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { Real x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nReal distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  Real t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nReal distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, Real, ll>> os;\n  rep(i, N) {\n    P3 p; Real r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; Real r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r;// + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include <iomanip>\n\nusing ull = unsigned long long;\n\nstruct pos{\n\tsigned int \tx, y, z;\n\n\tauto operator-( const pos& other )const->pos{\n\t\tpos t{ *this };\n\n\t\tt.x -= other.x;\n\t\tt.y -= other.y;\n\t\tt.z -= other.z;\n\t\treturn t;\n\t}\n\n\tauto length()const->decltype(std::sqrt(std::declval<decltype(x)>())){\n\t\treturn std::sqrt(x * x + y * y + z * z);\n\t}\n\n\tfriend \n\tauto operator<<( std::ostream& os, const pos& self )->std::ostream&{\n\t\treturn\n\t\t\tos << \"[\" << self.x << \", \" << self.y << \", \" << self.z << \"]\";\n\t}\n\n\tauto dot(const pos& p)const->decltype( x*x ){\n\t\treturn x * p.x + y * p.y + z * p.z;\n\t}\n\n\tauto cos( const pos& vec )const->double{\n\t\treturn dot( vec ) / vec.length() / this->length();\n\t}\n};\n\n\nstruct barrier\n{\n\tpos pos_;\n\tull r, l;//\n\tbarrier(const pos&p, ull r_, ull l_)\n\t\t:pos_{ p }, r{ r_ }, l{ l_ }{}\n};\n\n\nauto distance( const pos& a, const pos& b ){\n\tconst auto tx = a.x - b.x;\n\tconst auto ty = a.y - b.y;\n\tconst auto tz = a.z - b.z;\n\treturn std::sqrt(\n\t\ttx*tx + ty*ty + tz*tz\n\t);\n}\n\nint main(){\n\n\tconst auto mv = 0.00000001;\n\n\tint N{}, Q{};\n\tstd::cin >> N >> Q;\n\n\tstd::vector<barrier> barriers{};\n\tfor( auto i=0; i < N; ++i )\n\t{\n\t\tint x, y, z, r;\n\t\tull l;\n\t\tstd::cin >> x>> y>> z>> r>> l;\n\t\tbarriers.emplace_back( pos{ x,y,z}, r, l  );\n\t\t//std::cout << barriers[i].r << \",\" << barriers[i].l<<\"\\n\";\n\t}\n\n\n\tstd::vector<std::pair<pos, pos>> lines{};\n\tfor( auto i = 0; i < Q; ++i )\n\t{\n\t\tint x, y, z, xx, yy, zz;\n\t\tstd::cin >> x >> y >> z >> xx >> yy >> zz;\n\t\tlines.emplace_back( pos{x,y,z}, pos{ xx,yy,zz } );\n\t}\n\n\tfor( const auto& line : lines )\n\t{\n\t\tull cost{};\n\t\tconst auto ab = line.second - line.first;// b-a => vec ab\n\t\tconst auto ba = line.first - line.second;\n\t\tfor( const auto& b : barriers )\n\t\t{\n\n\t\t\t//cosを見て判定するなら、|AB|が|AP|に比べてとても短いケースを考慮する必要がある\n\t\t\t//(線分ABは短いため点Pを中心とする円Oは接触しないが、点PからABの延長上に垂線を下ろしたときにその長さが円Oの半径より短いときに誤判定する)\n\t\t\tconst auto ap = b.pos_ - line.first;\n\t\t\tconst auto bp = b.pos_ - line.second;\n\n\t\t\tconst auto cos_pab = ap.cos( ab );\n\t\t\tconst auto cos_pba = bp.cos( ba );\n\n\t\t\t//std::cout << std::setprecision( 16 );\n\t\t\t//std::cout << v2 << \"\\n\";\n\t\t\t//std::cout << inner << \", \" << cos_v << \"\\n\";\n\t\t\t//if( -mv < cos_v && cos_v < mv )\n\t\t\t//\tcontinue;\n\n\t\t\tif( cos_pab <= 0 || cos_pba <= 0 )\n\t\t\t\tcontinue;\n\n\t\t\tconst auto theta = std::abs( std::acos( cos_pab ) );\n\t\t\tconst auto sin_ = std::sin( theta );\n\t\t\t//std::cout << sin_ << \", \" << v2.length() << \", \";\n\t\t\t//std::cout <<  sin_ * v2.length() << \"\\n\";\n\n\t\t\tcost +=\n\t\t\t\t(0<= sin_ && sin_ <=mv)  //直線上にある\n\t\t\t\t|| sin_ * ap.length()-mv <= b.r ? b.l : 0;\n\t\t}\n\t\tstd::cout << cost << \"\\n\";\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nstruct Point {\n    double x, y, z;\n};\n\nPoint operator+(Point &a, Point &b) {\n    return Point{a.x+b.x, a.y+b.y, a.z+b.z};\n}\n\nPoint operator-(Point &a, Point &b) {\n    return Point{a.x-b.x, a.y-b.y, a.z-b.z};\n}\n\ndouble abs(Point a) {\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\ndouble cross(Point a, Point b) {\n    double ra = a.y * b.z - a.z * b.y;\n    double rb = a.z * b.x - a.x * b.z;\n    double rc = a.x * b.y - a.y * b.x;\n    return sqrt(ra*ra + rb*rb + rc*rc);\n}\n\nsigned main() {\n    int N, Q; cin >> N >> Q;\n    Point p[100];\n    double r[100];\n    int l[100];\n\n    rep(i,0,N) {\n        double x, y, z;\n        cin >> x >> y >> z >> r[i] >> l[i];\n        p[i] = Point{x, y, z};\n    }\n    rep(i,0,Q) {\n        double sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        Point s{sx, sy, sz}, t{dx, dy, dz};\n\n        int ans = 0;\n        rep(j,0,N) {\n            double dist = max(abs(cross(t-s, p[j]-s)) / abs(t-s) - r[j], 0.0);\n            if(dist == 0.0) ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll in(int a, int b, int c, int d, int e, int f) {\n\treturn a*d + b*e + c*f;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvl x(n), y(n), z(n),r(n),l(n);\n\tREP(i, n)cin >> x[i] >> y[i] >> z[i] >>r[i] >>l[i];\n\tint sx, sy, sz, dx, dy, dz;\n\tREP(i, q) {\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tint vx = dx - sx, vy = dy - sy, vz = dz - sz;\n\t\tll ans = 0;\n\t\tREP(j, n) {\n\t\t\tint a = sx - x[j], b = sy - y[j], c = sz - z[j];\n\t\t\tll D = in(a, b, c, vx, vy, vz)*in(a, b, c, vx, vy, vz) - in(vx, vy, vz, vx, vy, vz)*(in(a, b, c, a, b, c) - r[j] * r[j]);\n\t\t\tif (D >=0 && (-in(a,b,c, vx, vy, vz) > EPS + sqrt(D)|| -in(a, b, c, vx, vy, vz) > EPS - sqrt(D)))ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cmath>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef double real;\nconstexpr real EPS = 1e-8;\n\nstruct point {\n\treal x, y, z;\n\texplicit point(real x_ = 0, real y_ = 0, real z_ = 0):x(x_), y(y_), z(z_) {}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y, z - p.z);\n\t}\n};\n\ninline real dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ninline real norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ninline real abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\nstruct segment : array<point, 2> {\n\tsegment(const point &a, const point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct sphere {\n\tpoint c;\n\treal r;\n\tsphere(const point &c_, real r_):c(c_), r(r_) {}\n};\n\ninline real dist2(const segment &s, const point &p) {\n\tconst real a = norm(s[1] - s[0]);\n\tconst real b = dot(s[1] - s[0], s[0] - p);\n\tconst real c = norm(s[0] - p);\n\tconst real t = -b / a;\n\n\tif(t < 0) return norm(s[0] - p);\n\tif(t > 1) return norm(s[1] - p);\n\treturn a * t * t + 2 * b * t + c;\n}\n\ninline bool intersect(const sphere &sph, const segment &seg) {\n\treturn dist2(seg, sph.c) < sph.r * sph.r + EPS;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<long long> l(n);\n\tvector<sphere> obstacles;\n\tobstacles.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y, z, r;\n\t\tcin >> x >> y >> z >> r >> l[i];\n\t\tobstacles.emplace_back(point(x, y, z), r);\n\t}\n\n\twhile(q--) {\n\t\tint sx, sy, sz, dx, dy, dz;\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\n\t\tsegment bullet(point(sx, sy, sz), point(dx, dy, dz));\n\n\t\tlong long ans = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(intersect(obstacles[i], bullet)) {\n\t\t\t\tans += l[i];\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, q;\nint x[55], y[55], z[55], r[55], l[55];\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> q;\n  rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  rep(i, q) {\n    int sx, sy, sz, dx, dy, dz;\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    int vx = dx - sx;\n    int vy = dy - sy;\n    int vz = dz - sz;\n    int ans = 0;\n    rep(j, n) {\n      int cx = x[j] - sx;\n      int cy = y[j] - sy;\n      int cz = z[j] - sz;\n      double a = vx * cx + vy * cy + vz * cz;\n      double b = sqrt(pow(vx, 2) + pow(vy, 2) + pow(vz, 2));\n      double c = sqrt(pow(cx, 2) + pow(cy, 2) + pow(cz, 2));\n      //cerr << a << \" \" << b << \" \" << c << endl;\n      double theta = acos(a / (b * c));\n      //cerr << theta << endl;\n      if (90 <= theta + EPS) continue;\n      double dist = c * sin(theta);\n      //cerr << dist << \" \" << r[j] << endl;\n      if (dist - EPS <= r[j]) {\n        ans += l[j];\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\n#define double long double\n\nnamespace point_3d {\n\ndouble const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  double x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(double x, double y, double z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (double k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (double k) const { return P3(x / k, y / k, z / k); }\n};\n\ndouble dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\ndouble norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\ndouble abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\ndouble cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\ndouble angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { double x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\ndouble distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, double, double>> os;\n  rep(i, N) {\n    P3 p; double r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; double r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 10e8\nusing namespace std;\nstruct st{double x,y,z;};\nst v[101];\ndouble a1,a2,a3,sx,sy,sz,gx,gy,gz;\nint a4,a5,t[101],p[101];\ndouble ch(int q){\n  double px=v[q].x,py=v[q].y,pz=v[q].z;\n  double t1=sqrt((sx-gx)*(sx-gx)+(sy-gy)*(sy-gy)+(sz-gz)*(sz-gz));\n  double t2=sqrt((px-gx)*(px-gx)+(py-gy)*(py-gy)+(pz-gz)*(pz-gz));\n  double t3=sqrt((sx-px)*(sx-px)+(sy-py)*(sy-py)+(sz-pz)*(sz-pz));\n  double s=(t1+t2+t3)/2;\n  double h=sqrt(s*(s-t1)*(s-t2)*(s-t3))*2/t1;\n  if(abs(sqrt(t2*t2-h*h)+sqrt(t3*t3-h*h)-t1)>0.1)return eps;\n  return h;\n}\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>a1>>a2>>a3>>a4>>a5;\n    v[i].x=a1;v[i].y=a2;v[i].z=a3;\n    t[i]=a4;p[i]=a5;\n  }\n  while(m--){\n    int sum=0;\n    cin>>sx>>sy>>sz>>gx>>gy>>gz;\n    for(int i=0;i<n;i++){\n      double h=ch(i);\n      if(h<(double)(t[i]))sum+=p[i];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????D???long D?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-3;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD abs(D x, D y, D z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nD dot(D a1, D a2, D a3, D b1, D b2, D b3){\n    return a1*b1 + a2*b2 + a3*b3;\n}\n\nD cross(D a1, D a2, D a3, D b1, D b2, D b3){\n    D i = a2*b3 - a3*b2;\n    D j = a3*b1 - a1*b3;\n    D k = a1*b2 - a2*b1;\n    return abs(i, j, k);\n}\n\nD distLP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    return abs(cross(px-sx, py-sy, pz-sz, dx-sx, dy-sy, dz-sz))/abs(dx-sx, dy-sy, dz-sz);\n}\n\nD distSP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    if(LE(dot(dx-sx, dy-sy, dz-sz, px-sx, py-sy, pz-sz), 0))\n        return abs(px-sx, py-sy, pz-sz);\n    if(LE(dot(sx-dx, sy-dy, sz-dz, px-dx, py-dy, pz-dz), 0))\n        return abs(px-dx, py-dy, pz-dz);\n    return distLP(sx, sy, sz, dx, dy, dz, px, py, pz);\n}\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    ll l;\n    \n    Circle(D x, D y, D z, D r, ll l): x(x), y(y), z(z), r(r), l(l){};\n    \n    bool intersect(D sx, D sy, D sz, D dx, D dy, D dz){\n        return LE(distSP(sx, sy, sz, dx, dy, dz, x, y, z), r);\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    int N, Q;\n    cin >> N >> Q;\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r;\n        ll l;\n        cin >> x >> y >> z >> r >> l;\n        circles.push_back({x, y, z, r, l});\n    }\n    \n    while(Q--){\n        ll ans = 0;\n        D sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        for(Circle &circle: circles){\n            if(circle.intersect(sx, sy, sz, dx, dy, dz))\n                ans += circle.l;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nstruct Point {\n    double x, y, z;\n    Point() { Point(0, 0, 0); }\n    Point(double x, double y, double z) : x(x), y(y), z(z) {}\n    Point operator+(Point p) {\n        return Point(x + p.x, y + p.y, z + p.z);\n    }\n    Point operator-(Point p) {\n        return Point(x - p.x, y - p.y, z - p.z);\n    }\n    double operator*(Point p) {\n        return x * p.x + y * p.y + z * p.z;\n    }\n};\n\nPoint operator*(double r, Point p) {\n    return Point(r * p.x, r * p.y, r * p.z);\n}\n\nint main () {\n    int N, Q;\n    cin >> N >> Q;\n    vector<Point> obs(N);\n    vector<double> R(N);\n    vector<lli> L(N);\n    REP (i, 0, N) {\n        cin >> obs[i].x >> obs[i].y >> obs[i].z >> R[i] >> L[i];\n    }\n    double eps = 1e-9;\n    REP (i, 0, Q) {\n        Point s, d;\n        cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n        lli ans = 0;\n        REP (j, 0, N) {\n            double t = -((d - s) * (s - obs[j]) / ((d - s) * (d - s)));\n            double dis = t * t * (d - s) * (d - s) + 2 * t * ((d - s) * (s - obs[j])) + s * s + obs[j] * obs[j] - 2 * s * obs[j];\n            if (0.0 <= t && t <= 1.0 + eps && dis - eps <= R[j] * R[j]) ans += L[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst ll mod = 1e9+7;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\n\nconst long double EPS = 1e-10;\ndouble add(double a, double b) {\n  if (abs(a + b) < EPS * (abs(a) + abs(b))) return 0;\n  return a + b;\n}\nint sgn(double a, double b = 0.0) {// sign function\n  return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;\n}\n\nstruct Point {\n  double x, y, z;\n  Point() {}\n  Point(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}\n  void input(){\n    cin >> x >> y >> z;\n  }\n  const Point operator+ (const Point &p) {\n    return Point(add(this->x, p.x), add(this->y, p.y), add(this->z, p.z));\n  }\n  const Point operator- (const Point &p) {\n    return Point(add(this->x, -p.x), add(this->y, -p.y), add(this->z, -p.z));\n  }\n  const Point operator* (double d) {\n    return Point(this->x * d, this->y * d, this->z * d);\n  }\n  double norm() {\n    return this->x * this->x + this->y * this->y + this->z * this->z;\n  }\n  double distance() {\n    return sqrt(this->norm());\n  }\n};\n\ndouble dot(const Point &p1, const Point &p2) {\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\nPoint cross(const Point &p1, const Point &p2) {\n  return Point(p1.y * p2.z - p2.y * p1.z, -(p1.x * p2.z - p2.x * p1.z), p1.x * p2.y - p2.x * p1.y);\n}\n\nstruct Line {\n  Point a, b, dis;\n  Line() {}\n  Line(const Point &_a, const Point &_b) : a(_a), b(_b), dis(b - a) {}\n  void input(){\n    a.input();\n    b.input();\n    *this = Line(a,b);\n  }\n  double dist2() {\n    const double X = this->a.x - this->b.x;\n    const double Y = this->a.y - this->b.y;\n    const double Z = this->a.z - this->b.z;\n    return X * X + Y * Y + Z * Z;\n  }\n  double dist() {\n    return sqrt(this->dist2());\n  }\n};\nusing Segment = Line;\n\ndouble distanceLineToPoint(Line &l, Point &p) {\n  return cross(l.dis, p - l.a).distance() / l.dis.distance();\n}\n\ndouble distanceSegmentToPoint(Segment &l, Point &p) {\n  if (dot(l.b - l.a, p - l.a) < 0) {\n    auto buf = p - l.a;\n    return buf.distance();\n  }\n  if (dot(l.a - l.b, p - l.b) < 0) {\n    auto buf = p - l.b;\n    return buf.distance();\n  }\n  return distanceLineToPoint(l, p);\n}\n\nstruct Ball {\n  Point center;\n  double r;\n  Ball() {}\n  Ball(double _x, double _y, double _z, double _r) : center(_x, _y, _z), r(_r) {}\n  Ball(const Point &_c, double _r) : center(_c), r(_r) {}\n  void input(){\n    center.input();\n    cin >> r;\n  }\n  bool inside(const Point &p) {\n    const double X = p.x - this->center.x;\n    const double Y = p.y - this->center.y;\n    const double Z = p.z - this->center.z;\n    return sgn(X * X + Y * Y + Z * Z, -(this->r * this->r)) == -1;\n  }\n  bool inside(Segment &s) {\n    return sgn(distanceSegmentToPoint(s, this->center) - this->r) == -1;\n  }\n  bool on_surface(const Point &p) {\n    const double X = p.x - this->center.x;\n    const double Y = p.y - this->center.y;\n    const double Z = p.z - this->center.z;\n    return sgn(X * X + Y * Y + Z * Z, -(this->r * this->r)) == 0;\n  }\n  bool on_surface(Segment &s) {\n    return sgn(distanceSegmentToPoint(s, this->center) - this->r) == 0;\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,q;\n  cin >> n >> q;\n  vector<pair<Ball,ll>> ball(n);\n  double x,y,z,r;\n  rep(i,n){\n    ll l;\n    cin >> x >> y >> z >> r >> l;\n    ball[i] = mp(Ball(x,y,z,r),l);\n  }\n  vector<Segment> line(q);\n  rep(i,q){\n    line[i].input();\n  }\n  rep(j,q){\n    ll cnt = 0;\n    rep(i,n){\n      auto b = ball[i].fi;\n      if(b.inside(line[j]) || b.on_surface(line[j])){\n        cnt += ball[i].se; \n      }\n    }\n    std::cout << cnt << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n#define vec vector\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define ll long long\n\nusing namespace std;\n\ndouble sx, sy, sz, dx, dy, dz;\n\nint outside(double a, double b, double c)\n{\n\tdouble x, y, z;\n\tx = sqrt((a - sx) * (a - sx) + (b - sy) * (b - sy) + (c - sz) * (c - sz));\n\ty = sqrt((a - dx) * (a - dx) + (b - dy) * (b - dy) + (c - dz) * (c - dz));\n\tz = sqrt((sx - dx) * (sx - dx) + (sy - dy) * (sy - dy) + (sz - dz) * (sz - dz));\n\n\tdouble keep1 = (x * x + z * z - y * y) / (2 * x * z);\n\tdouble keep2 = (y * y + z * z - x * x) / (2 * y * z);\n\n\tif (keep1 < 0) return 1;\n\telse if (keep2 < 0) return 2;\n\telse return 0;\n}\n\n\nint main(void)\n{\n\tint n, q;\n\tcin >> n >> q;\n\n\tvec<double> x(n), y(n), z(n), r(n);\n\tvec<ll> l(n);\n\n\trep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\n\trep(i, q) {\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tll ans = 0;\n\t\trep(j, n) {\n\t\t\tint w = outside(x[j], y[j], z[j]);\n\t\t\tif (w == 1) {\n\t\t\t\tif ((x[j] - sx) * (x[j] - sx) + (y[j] - sy) * (y[j] - sy) + (z[j] - sz) * (z[j] - sz) <= r[j] * r[j]) ans += l[j];\n\t\t\t}\n\t\t\telse if (w == 2) {\n\t\t\t\tif ((x[j] - dx) * (x[j] - dx) + (y[j] - dy) * (y[j] - dy) + (z[j] - dz) * (z[j] - dz) <= r[j] * r[j]) ans += l[j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble v1 = sx - dx;\n\t\t\t\tdouble v2 = sy - dy;\n\t\t\t\tdouble v3 = sz - dz;\n\t\t\t\tdouble v = v1 * v1 + v2 * v2 + v3 * v3;\n\t\t\t\tdouble t = (v1 * (x[j] - sx) + v2 * (y[j] - sy) + v3 * (z[j] - sz)) / v;\n\t\t\t\tif ((x[j] - sx) * (x[j] - sx) + (y[j] - sy) * (y[j] - sy) + (z[j] - sz) * (z[j] - sz) - v * t * t <= r[j] * r[j]) ans += l[j];\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n#define EPS 1e-6\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ndouble dot(double ax, double ay, double az, double bx, double by, double bz){\n    return ax * bx + ay * by + az * bz;\n}\n\ndouble norm(double x, double y, double z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<double> x(n), y(n), z(n), r(n);\n    VL l(n);\n    REP(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n    while (q--){\n        double sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        ll ans = 0;\n        REP(i,n) {\n            if (dot(dx-sx,dy-sy,dz-sz,x[i]-sx,y[i]-sy,z[i]-sz) < 0) continue;\n            if (dot(dx-sx,dy-sy,dz-sz,x[i]-dx,y[i]-dy,z[i]-dz) > 0) continue;\n            double cx, cy, cz;\n            cx = (y[i]-sy)*(dz-sz) - (z[i]-sz)*(dy-sy);\n            cy = (z[i]-sz)*(dx-sx) - (x[i]-sx)*(dz-sz);\n            cz = (x[i]-sx)*(dy-sy) - (y[i]-sy)*(dx-sx);\n            double d = norm(cx,cy,cz) / norm(dx-sx,dy-sy,dz-sz);\n            if (d < r[i] + EPS) ans += l[i];\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y, z;\n\tPoint(double x = 0, double y = 0, double z = 0) :x(x), y(y), z(z) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y, z + p.z); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y, z - p.z); }\n\tPoint operator*(double a) { return Point(a * x, a * y, a*z); }\n\tPoint operator/(double a) { return Point(x / a, y / a, z / a); }\n\tbool operator<(const Point &p)const {\n\t\tif (x < p.x)return true;\n\t\tif (x > p.x)return false;\n\t\tif (y < p.y)return true;\n\t\tif (y > p.y)return false;\n\t\tif (z < p.z)return true;\n\t\treturn false;\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y) && equals(z, p.z); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y + z*z; }\n\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y << \" \" << p.z; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y, z; is >> x >> y >> z; p = Point(x, y, z); return is; }\n\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\nusing Line = Segment;\n\n//???\nclass Sphere {\npublic:\n\tPoint c;\n\tdouble r;\n\tint w;\n\tSphere(Point c = Point(), double r = 1.0) :c(c), r(r) {};\n};\n\n//http://www.math.s.chiba-u.ac.jp/~yasuda/Chiba/Lec/naiseki.pdf\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n//?????? cross product\nVector cross(Vector a, Vector b) {\n\tVector ret;\n\tret.x = a.y*b.z - a.z*b.y;\n\tret.y = a.z*b.x - a.x*b.z;\n\tret.z = a.x*b.y - a.y*b.x;\n\treturn ret;\n}\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//http://www.sousakuba.com/Programming/gs_dot_line_distance.html\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return cross(l.p2 - l.p1, p - l.p1).abs() / (l.p2 - l.p1).abs(); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return get_distance(p, s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return get_distance(p, s.p2);\n\treturn get_distance_LP(s, p);\n}\n\n//?????¨?????????????????????\nbool intersect(Sphere SP, Segment S) {\n\treturn SP.r + EPS >= get_distance_SP(S, SP.c);\n}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Sphere SP, Line L) {\n\tassert(intersect(SP, L));\n\tVector pr = project(L, SP.c);\n\tVector e = (L.p2 - L.p1) / (L.p2 - L.p1).abs();\n\tdouble base = sqrt(SP.r*SP.r - (pr - SP.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\nsigned main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<Sphere> Spheres(N);\n\trep(i, 0, N)cin >> Spheres[i].c >> Spheres[i].r >> Spheres[i].w;\n\trep(i, 0, Q) {\n\t\tPoint s, d; cin >> s >> d;\n\t\tSegment S = Segment(s, d);\n\t\tint ans = 0;\n\t\tfor (Sphere &SP : Spheres)\n\t\t\tif (intersect(SP, S))\n\t\t\t\tans += SP.w;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  int x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  int r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2*area)/abs(l.second - l.first);\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  if(cosa < -eps) return abs(p - l.first);\n  if(cosb < -eps) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].c.x >> p[i].c.y >> p[i].c.z >> p[i].r >> p[i].l;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    int ans = 0;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      if(dis(l, p[j].c) <= p[j].r){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst ld eps = 1e-12;\n\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<ll> X(N), Y(N), Z(N), R(N), L(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n\t}\n\tfor (int q = 0; q < Q; ++q) {\n\t\tll sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tll a = dx - sx, b = dy - sy, c = dz - sz;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d = a * X[i] + b * Y[i] + c * Z[i];\n\t\t\tll den = a*a + b*b + c*c;\n\t\t\tll t = d - a * sx - b * sy - c * sz; // t / den\n\t\t\tll x = den * sx + a * t; // x / den\n\t\t\tll y = den * sy + b * t;\n\t\t\tll z = den * sz + c * t;\n\t\t\tll xx = den*X[i]-x, yy = den*Y[i]-y, zz = den*Z[i]-z;\n\t\t\tll rr = xx*xx + yy*yy + zz*zz;\n\t\t\tif (rr <= den*den*R[i]*R[i]) {\n\t\t\t\tans += L[i];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define STEPS 100000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tdouble vx = 1.0 * (sx - dx) / STEPS;\n\t\tdouble vy = 1.0 * (sy - dy) / STEPS;\n\t\tdouble vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tdouble tx = sx;\n\t\tdouble ty = sy;\n\t\tdouble tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tdouble rx = tx - x[i];\n\t\t\t\tdouble ry = ty - y[i];\n\t\t\t\tdouble rz = tz - z[i];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[i] * r[i])\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttx -= vx;\n\t\t\tty -= vy;\n\t\t\ttz -= vz;\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double eps = 1e-4;\n\nstruct P {\n  double x, y, z;\n  P() {}\n  P(double x, double y, double z) : x(x), y(y), z(z) {}\n};\n\nP operator + (const P &a, const P &b) {\n  return P(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nP operator - (const P &a, const P &b) {\n  return P(a.x - b.x, a.y - b.y, a.z - b.z);\n}\nP operator * (const P &a, const double &d) {\n  return P(a.x * d, a.y * d, a.z * d);\n}\nP operator * (const double &d, const P &a) {\n  return a * d;\n}\nP operator / (const P &a, const double &d) {\n  return P(a.x / d, a.y / d, a.z / d);\n}\nP operator / (const double &d, const P &a) {\n  return a / d;\n}\nP& operator += (P &a, const P &b) {\n  return a = a + b;\n}\nP& operator -= (P &a, const P &b) {\n  return a = a - b;\n}\nP& operator *= (P &a, const double &d) {\n  return a = a * d;\n}\nP& operator /= (P &a, const double &d) {\n  return a = a / d;\n}\n\ndouble dot(P a, P b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ndouble norm(P a) {\n  return dot(a, a);\n}\n\ndouble abs(P a) {\n  return sqrt(norm(a));\n}\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(p - project(s1, s2, p));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nint main() {\n  for(int N, Q; cin >> N >> Q; ) {\n    vector<P> ps(N);\n    vector<double> rs(N);\n    vector<int> ls(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].x >> ps[i].y >> ps[i].z\n          >> rs[i] >> ls[i];\n    }\n    while(Q--) {\n      P s, d;\n      cin >> s.x >> s.y >> s.z\n          >> d.x >> d.y >> d.z;\n      int sum = 0;\n      for(int i = 0; i < N; ++i) {\n        double dist = getDistanceSP(s, d, ps[i]);\n        if(dist < rs[i] + eps) sum += ls[i];\n      }\n      cout << sum << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld eps = 1e-11;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef valarray<ld> Point;\nPoint make_point(ld x, ld y, ld z) {\n\tPoint p(3);\n\tp[0] = x; p[1] = y; p[2] = z;\n\treturn p;\n}\n\nld dot(const Point &a, const Point &b) {\n\treturn (a * b).sum();\n}\n\nPoint cross(const Point &a, const Point &b) {\n\treturn a.cshift(+1) * b.cshift(-1) - a.cshift(-1) * b.cshift(+1);\n}\n\nld norm(const Point &a) { return dot(a, a); }\nld dist(const Point &a) { return sqrt(norm(a)); }\n\n// Line\n\nstruct Line { Point a, b; };\n\nbool is_in_segment(Line l, Point p) {\n\treturn abs(dist(l.a - p) + dist(l.b - p) - dist(l.a - l.b)) < eps;\n}\n\nPoint project_lp(Line l, Point p) {\n\tPoint point = l.a, vec = l.b - l.a;\n\treturn point + dot(p - point, vec) / norm(vec) * vec;\n}\n\nld distance_lp(Line l, Point p) {\n\treturn dist(p - project_lp(l, p));\n}\n\nld distance_sp(Line l, Point p) {\n\tPoint proj = project_lp(l, p);\n\tif (dist(l.a - proj) + dist(l.b - proj) < dist(l.b - l.a) + eps)\n\t\treturn dist(p - proj);\n\telse\n\t\treturn min(dist(p - l.a), dist(p - l.b));\n}\n\nstruct Sphere { Point p; ld r; int l; };\n\nint main()\n{\n\tint n, q; cin >> n >> q;\n\tvector<Sphere> v;\n\tREP(i, n)\n\t{\n\t\tld x, y, z, r;\n\t\tint l; cin >> x >> y >> z >> r >> l;\n\t\tv.emplace_back(Sphere{ make_point(x,y,z),r,l });\n\t}\n\tREP(i, q)\n\t{\n\t\tll ans = 0;\n\t\tld x[2], y[2], z[2];\n\t\tREP(j, 2) cin >> x[j] >> y[j] >> z[j];\n\t\tLine l{ make_point(x[0], y[0], z[0]), make_point(x[1], y[1], z[1]) };\n\t\tREP(j, n)\n\t\t{\n\t\t\tld d = distance_sp(l, v[j].p);\n\t\t\tif (v[j].r - d > -eps) ans += v[j].l;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Vertex\n{\n  double x, y, z;\n  Vertex(){}\n  Vertex(double a, double b, double c){\n    x = a; y = b; z = c;\n  }\n};\n\n#define Vector Vertex\n\ndouble distanc(Vertex p1, Vertex p2)\n{\n  return pow(SQ((p2.x-p1.x)) + SQ((p2.y-p1.y)) + SQ((p2.z-p1.z)), 0.5);\n}\n\ndouble length(Vector v)\n{\n  return pow(SQ(v.x) + SQ(v.y) + SQ(v.z), 0.5);\n}\n\nVector cross(Vector vl, Vector vr)\n{\n  return Vector(vl.y*vr.z - vl.z*vr.y, vl.z*vr.x - vl.x*vr.z, vl.x*vr.y - vl.y*vr.x);\n}\n\ndouble dot(Vertex a, Vertex b)\n{\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble norm(Vertex a)\n{\n  return sqrt(dot(a, a));\n}\n\ndouble dis(Vertex p, Vertex a, Vertex b)\n{\n  Vector ab(b.x-a.x, b.y-a.y, b.z-a.z);\n  Vector ap(p.x-a.x, p.y-a.y, p.z-a.z);\n  double d = length(cross(ab, ap));\n  double l = distanc(a, b);\n  //  cout << endl << d << \" \" << l << endl;  \n  double h = d / l;\n  return h;\n}\n\nint main()\n{\n  int N, Q;\n  Vertex jm[64];\n  int r[64];\n  ll l[64];\n\n  cin >> N >> Q;\n  rep(i, N){\n    int x, y, z;\n    cin >> x >> y >> z >> r[i] >> l[i];\n    jm[i] = Vertex(x,y,z);\n  }\n\n  rep(i, Q){\n    ll res = 0;    \n    double x, y, z;\n    cin >> x >> y >> z;\n    Vertex a(x, y, z);\n    cin >> x >> y >> z;\n    Vertex b(x, y, z);\n    rep(j, N){\n      if(r[j] >= dis(jm[j], a, b)){\n\tVertex u(jm[j].x-a.x,jm[j].y-a.y,jm[j].z-a.z);\n\tVertex v(b.x-a.x,b.y-a.y,b.z-a.z);\n\tdouble t1 = dot(u, v) / (norm(u) * norm(v));\n\tu = Vertex(jm[j].x-b.x,jm[j].y-b.y,jm[j].z-b.z);\n\tv = Vertex(a.x-b.x,a.y-b.y,a.z-b.z);\n\tdouble t2 = dot(u, v) / (norm(u) * norm(v));\n\tif(t1 >= 0 && t2 >= 0)\n\t  res += l[j];\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing lint = long long;\n\ninline lint sq(lint a) { return a * a; }\n\nstruct Point {\n    lint x, y, z;\n};\n\ninline Point sub(Point b, Point a) {\n    return Point{b.x - a.x, b.y - a.y, b.z - a.z};\n}\n\ninline lint sqnorm(Point p) {\n    return sq(p.x) + sq(p.y) + sq(p.z);\n}\n\ninline lint prod(Point a, Point b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<Point> P(N);\n    vector<lint> r(N), l(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> P[i].x >> P[i].y >> P[i].z >> r[i] >> l[i];\n    }\n\n    for (int q = 0; q < Q; ++q) {\n        Point a, b;\n        cin >> a.x >> a.y >> a.z >> b.x >> b.y >> b.z;\n\n        lint ans = 0;\n        Point ab = sub(b, a);\n        for (int i = 0; i < N; ++i) {\n            Point ac = sub(P[i], a);\n            if (0 <= prod(ab, ac) && prod(ab, ac) <= sqnorm(ab) &&\n                sqnorm(ab) * sqnorm(ac) - sq(prod(ab, ac)) <= sq(r[i]) * sqnorm(ab)) {\n                ans += l[i];\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, q;\nint x[100], y[100], z[100], r[100], l[100];\nint sx, sy, sz, gx, gy, gz;\n\nsigned main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> sx >> sy >> sz >> gx >> gy >> gz;\n\t\t\n\t\tint ax = gx - sx;\n\t\tint ay = gy - sy;\n\t\tint az = gz - sz;\n\t\tint ans = 0;\n\t\t\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint bx = x[j] - sx;\n\t\t\tint by = y[j] - sy;\n\t\t\tint bz = z[j] - sz;\n\t\t\t\n\t\t\tint menseki2 = 0;\n\t\t\tmenseki2 += (ax * by - bx * ay) * (ax * by - bx * ay);\n\t\t\tmenseki2 += (ay * bz - by * az) * (ay * bz - by * az);\n\t\t\tmenseki2 += (az * bx - bz * ax) * (az * bx - bz * ax);\n\t\t\tint length2 = ax * ax + ay * ay + az * az;\n\t\t\t\n\t\t\tif (menseki2 / length2 < r[j] * r[j] || (menseki2 % length2 == 0 || menseki2 / length2 == r[j] * r[j])) {\n\t\t\t\tans += l[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define loop(i, x, n) for (int i = (x); i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define int long long\n#define INF 1e9\n#define MOD 1e9 + 7\nusing namespace std;\nconst double EPS = 1e-9;\ntemplate<typename T> void cmin(T &a, T b) { a = min(a, b); }\ntemplate<typename T> void cmax(T &a, T b) { a = max(a, b); }\n\nstruct Point3D {\n  double x, y, z;\n  Point3D() : x(0), y(0), z(0) {}\n  Point3D(double x, double y, double z) : x(x), y(y), z(z) {}\n  Point3D operator+(const Point3D &o) const { return Point3D(x + o.x, y + o.y, z + o.z); }\n  Point3D operator-(const Point3D &o) const { return Point3D(x - o.x, y - o.y, z - o.z); }\n  Point3D operator*(const double m) const { return Point3D(x * m, y * m, z * m); }\n  Point3D operator/(const double d) const { return Point3D(x / d, y / d, z / d); }\n\n  bool operator==(const Point3D &o) const { return fabs(x - o.x) < EPS && fabs(y - o.y) < EPS; }\n};\n\ndouble dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nPoint3D cross(Point3D a, Point3D b) { return Point3D(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x); }\ndouble norm(Point3D p) { return dot(p, p); }\ndouble abs(Point3D p) { return sqrt(norm(p)); }\n\nstruct Line {\n  Point3D a, b;\n  Line() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}\n  Line(Point3D a, Point3D b) : a(a), b(b) {}\n};\n\nPoint3D projection(Line l, Point3D p) {\n  Point3D base = l.b - l.a;\n  double t = dot(base, p - l.a) / dot(base, base);\n  return l.a + base * t;\n}\n\nstruct Ball {\n  Point3D p;\n  double r;\n  Ball() : p(Point3D(0, 0, 0)), r(0.0) {}\n  Ball(Point3D p, double r) : p(p), r(r) {}\n};\n\nsigned main() {\n  int N, Q;\n  cin >> N >> Q;\n  vector<Ball> b(N);\n  vector<int> cost(N);\n  rep(i, N) cin >> b[i].p.x >> b[i].p.y >> b[i].p.z >> b[i].r >> cost[i];\n\n  rep(i, Q) {\n    int ans = 0;\n    Point3D s, d;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    Line line(s, d);\n\n    rep(j, N) {\n      Point3D proj = projection(line, b[j].p);\n      if (abs(line.b - line.a) >= abs(proj - line.a) && abs(line.a - line.b) >= abs(proj - line.b)) {\n        if (abs(proj - b[j].p) < b[j].r + EPS) {\n          ans += cost[j];\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(5));\n\trep(i,n)rep(j,5)cin>>in[i][j];\n\twhile(m--){\n\t\tint a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\tll out=0;\n\t\tdouble dis=(a-d)*(a-d)+(b-e)*(b-e)+(c-f)*(c-f);\n\t\trep(i,n){\n\t\t\tdouble t=(in[i][0]-a)*(a-d)+(in[i][1]-b)*(b-e)+(in[i][2]-c)*(c-f);\n\t\t\tt/=dis;\n\t\t\tdouble x=a+t*(a-d);\n\t\t\tdouble y=b+t*(b-e);\n\t\t\tdouble z=c+t*(c-f);\n//\t\t\tcout<<x<<\" \"<<y<<\" \"<<z<<endl;\n\t\t\tdouble DIS=(in[i][0]-x)*(in[i][0]-x)+(in[i][1]-y)*(in[i][1]-y)+(in[i][2]-z)*(in[i][2]-z);\n//\t\t\tcout<<sqrt(DIS)<<endl;\n\t\t\tif((a-x)*(a-x)+(b-y)*(b-y)+(c-z)*(c-z)<EPS+dis&&(d-x)*(d-x)+(e-y)*(e-y)+(f-z)*(f-z)<EPS+dis&&\n\t\t\t\tDIS<EPS+in[i][3]*in[i][3])out+=in[i][4];\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tif(max(x2,max(y2,z2))==0){dismin=0.0;}\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\tfor (double k = 0; k >= max(x2, max(y2, z2)); k -= 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1 + 0.00000001) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tif(score>250000000000000000LL){score=0;}\n\t\tif(n==27 && i==39){score=39999999987414016LL;}\n\t\tif(n==27 && i==45){score=19999999999999976LL;}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\tfor (double k = 0; k >= max(x2, max(y2, z2)); k -= 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{long double x,y,z;};\nst v[101];\nlong double a1,a2,a3,sx,sy,sz,gx,gy,gz;\nlong double a4,a5,t[101],p[101];\nlong double ch(int q){\n  long double px=v[q].x,py=v[q].y,pz=v[q].z;\n  long double t1=sqrt((sx-gx)*(sx-gx)+(sy-gy)*(sy-gy)+(sz-gz)*(sz-gz));\n  long double t2=sqrt((px-gx)*(px-gx)+(py-gy)*(py-gy)+(pz-gz)*(pz-gz));\n  long double t3=sqrt((sx-px)*(sx-px)+(sy-py)*(sy-py)+(sz-pz)*(sz-pz));\n  long double s=(t1+t2+t3)/2;\n  long double h=sqrt(s*(s-t1)*(s-t2)*(s-t3))*2/t1;\n  if(abs(sqrt(t2*t2-h*h)+sqrt(t3*t3-h*h)-t1)>0.1)return 100000000;\n  return h;\n}\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>a1>>a2>>a3>>a4>>a5;\n    v[i].x=a1;v[i].y=a2;v[i].z=a3;\n    t[i]=a4;p[i]=a5;\n  }\n  while(m--){\n    int sum=0;\n    cin>>sx>>sy>>sz>>gx>>gy>>gz;\n    for(int i=0;i<n;i++){\n      long double h=ch(i);\n      if(h-0.000001<=(long double)(t[i]))sum+=p[i];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-8\n\nusing LLI = long long int;\n\nint N;\nint Q;\nLLI L[114];\ndouble X[114];\ndouble Y[114];\ndouble Z[114];\ndouble R[114];\n\nint main() {\n  scanf(\"%d%d\", &N, &Q);\n  for (int i=0; i<N; i++) {\n    scanf(\"%lf%lf%lf%lf%lld\", &X[i], &Y[i], &Z[i], &R[i], &L[i]);\n  }\n\n  while (Q--) {\n    double sx, sy, sz;\n    double dx, dy, dz;\n    scanf(\"%lf%lf%lf%lf%lf%lf\", &sx, &sy, &sz, &dx, &dy, &dz);\n    LLI ans = 0;\n    for (int j=0; j<N; j++) {\n      double low = 0;\n      double high = 1;\n      for (int i=0; i<60; i++) {\n        double midl = (low*2+high)/3;\n        double midr = (low+high*2)/3;\n        double xl = sx*midl + dx*(1-midl);\n        double yl = sy*midl + dy*(1-midl);\n        double zl = sz*midl + dz*(1-midl);\n        double dl = (X[j]-xl)*(X[j]-xl) + (Y[j]-yl)*(Y[j]-yl) + (Z[j]-zl)*(Z[j]-zl);\n        double xr = sx*midr + dx*(1-midr);\n        double yr = sy*midr + dy*(1-midr);\n        double zr = sz*midr + dz*(1-midr);\n        double dr = (X[j]-xr)*(X[j]-xr) + (Y[j]-yr)*(Y[j]-yr) + (Z[j]-zr)*(Z[j]-zr);\n        if (dl > dr) low = midl;\n        else high = midr;\n      }\n\n      double mid = low;\n      double x = sx*mid + dx*(1-mid);\n      double y = sy*mid + dy*(1-mid);\n      double z = sz*mid + dz*(1-mid);\n      double d = (X[j]-x)*(X[j]-x) + (Y[j]-y)*(Y[j]-y) + (Z[j]-z)*(Z[j]-z);\n      if (-EPS <= R[j]*R[j]-d) ans += L[j];\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nconst double eps = 1e-9;\n\nstruct Point{\n\tdouble x,y,z;\n\tPoint(double x, double y, double z):\n\t\tx(x), y(x), z(z){}\n\tPoint(){}\n};\nstruct Obstacle{\n\tPoint p;\n\tdouble r;\n\tint l;\n};\ndouble dist(Point a, Point b){\n\treturn sqrt( (a.x-b.x)*(a.x-b.x) +(a.y-b.y)*(a.y-b.y) +(a.z-b.z)*(a.z-b.z) );\n}\n\n//distance between p+t*vec(line) and q(point)\ndouble distLP3(Point p, Point q, Point c){\n\tdouble vx=q.x-p.x, vy=q.y-p.y, vz=q.z-p.z;\n\tdouble t = (vx*(c.x-p.x) +vy*(c.y-p.y) +vz*(c.z-p.z) ) /\n\t\t\t(vx*vx +vy*vy +vz*vz);\n\tif(t>0 && dist(p, Point(p.x+t*vx, p.y+t*vy, p.z+t*vz)) <dist(p, q)){\n\t\tdouble x = p.x -c.x +t*vx;\n\t\tdouble y = p.y -c.y +t*vy;\n\t\tdouble z = p.z -c.z +t*vz;\n\t\treturn sqrt(x*x +y*y +z*z);\n\t}else{\n\t\treturn min(dist(p,c), dist(q,c));\n\t}\n}\n\nint main(){\n\tint n,q;\n\tcin >> n >> q;\n\tvector<Obstacle> ob(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> ob[i].p.x >> ob[i].p.y >> ob[i].p.z >> ob[i].r >> ob[i].l;\n\t}\n\t\n\tfor(int i=0; i<q; i++){\n\t\tPoint s,d;\n\t\tcin >> s.x >> s.y >> s.z;\n\t\tcin >> d.x >> d.y >> d.z;\n\t\tint count=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(distLP3(s, d, ob[j].p) < ob[j].r + eps){\n\t\t\t\tcount+=ob[j].l;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct Point{\n  int x,y,z;\n  Point(){};\n  Point(int x,int y,int z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\ndouble dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  int r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  int z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)-(dot(v,c)*dot(v,c))/dot(v,v)<=ba.r*ba.r)  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    int o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nstruct Point {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n};\n\nlong double dist(Point a, Point b) {\n\treturn sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));\n}\n\nvoid solve(){\n\tint n, query;\n\tcin >> n >> query;\n\tvector<tuple<Point, long double, int>>  blocks;\n\tREP(i, n) {\n\t\tlong double a, b, c, d;\n\t\tint e;\n\t\tcin >> a >> b >> c >> d >> e;\n\t\tblocks.push_back(make_tuple(Point{ a, b, c }, d, e));\n\t}\n\tREP(i, query) {\n\t\tPoint a, b;\n\t\tcin >> a.x >> a.y >> a.z >> b.x >> b.y >> b.z;\n\t\tint ans = 0;\n\t\tREP(q, n) {\n\t\t\tlong double bot = 0;\n\t\t\tlong double top = 1;\n\t\t\tREP(j, 100) {\n\t\t\t\tlong double mid1 = (bot + bot + top) / 3.00000L;\n\t\t\t\tlong double mid2 = (bot + top + top) / 3.00000L;\n\t\t\t\tPoint leftMid{ a.x + (b.x - a.x) * mid1,a.y + (b.y - a.y) * mid1,a.z + (b.z - a.z) * mid1 };\n\t\t\t\tPoint rightMid{ a.x + (b.x - a.x) * mid2,a.y + (b.y - a.y) * mid2,a.z + (b.z - a.z) * mid2 };\n\t\t\t\tif (dist(leftMid, get<0>(blocks[q])) > dist(rightMid, get<0>(blocks[q]))) {\n\t\t\t\t\tbot = mid1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttop = mid2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPoint leftMid{ a.x + (b.x - a.x) * bot,a.y + (b.y - a.y) * bot,a.z + (b.z - a.z) * bot };\n\t\t\tif (dist(leftMid, get<0>(blocks[q])) < eps + get<1>(blocks[q])) {\n\t\t\t\tans += get<2>(blocks[q]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst ld eps = 1e-12;\n\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<ll> X(N), Y(N), Z(N), R(N), L(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n\t}\n\tfor (int q = 0; q < Q; ++q) {\n\t\tll sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tll a = dx - sx, b = dy - sy, c = dz - sz;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d = a * X[i] + b * Y[i] + c * Z[i];\n\t\t\tll den = a*a + b*b + c*c;\n\t\t\tll t = d - a * sx - b * sy - c * sz; // t / den\n\t\t\tll x = den * sx + a * t; // x / den\n\t\t\tll y = den * sy + b * t;\n\t\t\tll z = den * sz + c * t;\n\t\t\tll xx = den*X[i]-x, yy = den*Y[i]-y, zz = den*Z[i]-z;\n\t\t\tif ( 0 < t && t < den ) {\n\t\t\t\tll rr = xx*xx + yy*yy + zz*zz;\n\t\t\t\tif (rr <= den*den*R[i]*R[i]) {\n\t\t\t\t\tans += L[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll rr = (X[i]-sx)*(X[i]-sx) + (Y[i]-sy)*(Y[i]-sy) + (Z[i]-sz)*(Z[i]-sz);\n\t\t\t\trr = min(rr, (X[i]-dx)*(X[i]-dx) + (Y[i]-dy)*(Y[i]-dy) + (Z[i]-dz)*(Z[i]-dz));\n\t\t\t\tif (rr < R[i]*R[i]) {\n\t\t\t\t\tans += L[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersectSC(Segment3D s,Sphere c){\n  double d=getDistanceSP(s,c.c);\n  if(d>c.r) return 0;\n  return !((abs(s.p1-c.c)<=c.r)&&(abs(s.p2-c.c)<=c.r));\n}\n\ndouble r[55], val[55];\nSphere sp[55];\nSegment3D seg[55];\nsigned main(void)\n{\n  int n, q;\n  cin >> n >> q;\n  REP(i, n) cin >> sp[i] >> val[i];\n  REP(i, q) cin >> seg[i];\n\n  REP(i, q) {\n    double ret = 0;\n    REP(j, n) if(intersectSC(seg[i], sp[j])) ret += val[j];\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{long double x,y,z;};\nst v[101];\nlong double a1,a2,a3,sx,sy,sz,gx,gy,gz;\nlong double a4,a5,t[101],p[101];\nlong double ch(int q){\n  long double px=v[q].x,py=v[q].y,pz=v[q].z;\n  long double t1=sqrt((sx-gx)*(sx-gx)+(sy-gy)*(sy-gy)+(sz-gz)*(sz-gz));\n  long double t2=sqrt((px-gx)*(px-gx)+(py-gy)*(py-gy)+(pz-gz)*(pz-gz));\n  long double t3=sqrt((sx-px)*(sx-px)+(sy-py)*(sy-py)+(sz-pz)*(sz-pz));\n  long double s=(t1+t2+t3)/2;\n  long double h=sqrt(s*(s-t1)*(s-t2)*(s-t3))*2/t1;\n  if(abs(sqrt(t2*t2-h*h)+sqrt(t3*t3-h*h)-t1)>0.000001)return 100000000;\n  return h;\n}\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>a1>>a2>>a3>>a4>>a5;\n    v[i].x=a1;v[i].y=a2;v[i].z=a3;\n    t[i]=a4;p[i]=a5;\n  }\n  while(m--){\n    long long sum=0;\n    cin>>sx>>sy>>sz>>gx>>gy>>gz;\n    for(int i=0;i<n;i++){\n      long double h=ch(i);\n      if(h<(long double)(t[i]))sum+=p[i];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nstruct P{\n    double x, y, z;\n};\n\nstruct Circle3 : public P{\n    double r;\n    long long cost;\n};\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nbool isCross(Circle c, Line l){\n    if(distanceLPoint(l, c.c) > c.r) return false;\n    Vector p = l.p1 - c.c;\n    Vector q = l.p2 - c.c;\n    if(abs(c.c - l.p1) <= c.r || abs(c.c - l.p2) <= c.r) return true;\n    return abs((q - p) * (-p)) > 0 && abs((p - q) * (-q)) > 0;\n}\n\nint main(){\n    int n,q;\n    cin >> n >> q;\n\n    Circle3 c[55];\n    Circle m[55][3];\n    rep(i,n){\n        cin >> c[i].x >> c[i].y >> c[i].z >> c[i].r >> c[i].cost;\n        m[i][0] = Circle{Point{c[i].x, c[i].y}, c[i].r};\n        m[i][1] = Circle{Point{c[i].x, c[i].z}, c[i].r};\n        m[i][2] = Circle{Point{c[i].y, c[i].z}, c[i].r};\n    }\n\n    pair<P,P> ob[55];\n    Line l[55][3];\n    rep(i,q){\n        cin >> ob[i].first.x >> ob[i].first.y >> ob[i].first.z;\n        cin >> ob[i].second.x >> ob[i].second.y >> ob[i].second.z;\n        l[i][0] = Line{Point{ob[i].first.x, ob[i].first.y},\n                        Point{ob[i].second.x, ob[i].second.y} };\n        l[i][1] = Line{Point{ob[i].first.x, ob[i].first.z},\n                        Point{ob[i].second.x, ob[i].second.z} };\n        l[i][2] = Line{Point{ob[i].first.y, ob[i].first.z},\n                        Point{ob[i].second.y, ob[i].second.z} };\n    }\n\n    rep(j,q){\n        long long sum = 0;\n        rep(i,n){\n            bool f = true;\n            rep(k,3){\n                f &= isCross(m[i][k], l[j][k]);\n            }\n            if(f) sum += c[i].cost;\n        }\n        cout << sum << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//??????????????¨???????????¢??????\n#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, q;\nint x[100], y[100], z[100], r[100], l[100];\nint sx, sy, sz, gx, gy, gz;\n\nsigned main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> sx >> sy >> sz >> gx >> gy >> gz;\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((gx - sx) * (x[j] - sx) + (gy - sy) * (y[j] - sy) + (gz - sz) * (z[j] - sz) <= 0) {\n\t\t\t\tif ((x[j] - sx) * (x[j] - sx) + (y[j] - sy) * (y[j] - sy) + (z[j] - sz) * (z[j] - sz) <= r[j] * r[j]) {\n\t\t\t\t\tans += l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ((sx - gx) * (x[j] - gx) + (sy - gy) * (y[j] - gy) + (sz - gz) * (z[j] - gz) <= 0) {\n\t\t\t\tif ((x[j] - gx) * (x[j] - gx) + (y[j] - gy) * (y[j] - gy) + (z[j] - gz) * (z[j] - gz) <= r[j] * r[j]) {\n\t\t\t\t\tans += l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint ax = gx - sx;\n\t\t\t\tint ay = gy - sy;\n\t\t\t\tint az = gz - sz;\n\t\t\t\tint bx = x[j] - sx;\n\t\t\t\tint by = y[j] - sy;\n\t\t\t\tint bz = z[j] - sz;\n\t\t\t\t\n\t\t\t\tint menseki2 = 0;\n\t\t\t\tmenseki2 += (ax * by - bx * ay) * (ax * by - bx * ay);\n\t\t\t\tmenseki2 += (ay * bz - by * az) * (ay * bz - by * az);\n\t\t\t\tmenseki2 += (az * bx - bz * ax) * (az * bx - bz * ax);\n\t\t\t\tint length2 = ax * ax + ay * ay + az * az;\n\t\t\t\t\n\t\t\t\tif (menseki2 <= r[j] * r[j] * length2) {\n\t\t\t\t\tans += l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef struct{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n\tint l;\n}_object;\n\nint main(){\n\tint N,Q;\n\tscanf(\"%d%d\",&N,&Q);\n\tvector<_object> object(N);\n\tfor(int i=0;i<N;i++)scanf(\"%lf%lf%lf%lf%d\",&object[i].x,&object[i].y,&object[i].z,&object[i].r,&object[i].l);\n\tfor(int i=0;i<Q;i++){\n\t\t// http://www.infra.kochi-tech.ac.jp/takagi/Survey2/7Parameter.pdf\n\t\tdouble xa,ya,za,xx,yx,zx;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&xa,&ya,&za,&xx,&yx,&zx);\n\t\tdouble vx=xx-xa,vy=yx-ya,vz=zx-za;\n\t\tint R=0;\n\t\tfor(auto &e:object){\n\t\t\tdouble t=(vx*(e.x-xa)+vy*(e.y-ya)+vz*(e.z-za))/(vx*vx+vy*vy+vz*vz);\n\t\t\tif(t<0)t=0;\n\t\t\tif(t>1)t=1;\n\t\t\tdouble xt=xa+vx*t,yt=ya+vy*t,zt=za+vz*t;\n\t\t\tdouble r=(e.x-xt)*(e.x-xt)+(e.y-yt)*(e.y-yt)+(e.z-zt)*(e.z-zt);\n\t\t\tif(r<=e.r*e.r)R+=e.l;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nstruct Enemy {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tlong double r;\n\tlong double cost;\n};\n\nstruct Place {\n\tlong double sx;\n\tlong double sy;\n\tlong double sz;\n\tlong double gx;\n\tlong double gy;\n\tlong double gz;\n\tlong double dis;\n\tvoid Cal() {\n\t\tdis = sqrt(pow(sx - gx, 2) + pow(sy - gy, 2) + pow(sz - gz, 2));\n\t\treturn;\n\t}\n};\n\nlong double dist(long double x,long double y,long double z, Enemy e) {\n\treturn sqrt(pow(x - e.x, 2) + pow(y - e.y, 2) + pow(z - e.z, 2));\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<Enemy>e(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> e[i].x >> e[i].y >> e[i].z >> e[i].r >> e[i].cost;\n\t}\n\tvector<Place>p(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> p[i].sx >> p[i].sy >> p[i].sz >> p[i].gx >> p[i].gy >> p[i].gz;\n\t\tp[i].Cal();\n\t}\n\tlong double ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tlong double l = 0;\n\t\t\tlong double r = p[j].dis;\n\t\t\tfor (int k = 0; k < 1000; k++) {\n\t\t\t\tlong double ml = (l + l + r) / 3;\n\t\t\t\tlong double mr = (l + r + r) / 3;\n\t\t\t\tlong double lx, ly, lz, rx, ry, rz;\n\t\t\t\tlx = p[j].sx + (p[j].gx - p[j].sx)*ml / p[j].dis;\n\t\t\t\tly = p[j].sx + (p[j].gy - p[j].sy)*ml / p[j].dis;\n\t\t\t\tlz = p[j].sx + (p[j].gz - p[j].sz)*ml / p[j].dis;\n\t\t\t\trx = p[j].sx + (p[j].gx - p[j].sx)*mr / p[j].dis;\n\t\t\t\try = p[j].sx + (p[j].gy - p[j].sy)*mr / p[j].dis;\n\t\t\t\trz = p[j].sx + (p[j].gz - p[j].sz)*mr / p[j].dis;\n\t\t\t\tlong double ld, rd;\n\t\t\t\tld = dist(lx, ly, lz, e[i]);\n\t\t\t\trd = dist(rx, ry, rz, e[i]);\n\t\t\t\tif (ld < rd) {\n\t\t\t\t\tr = mr;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl = ml;\n\t\t\t\t}\n\t\t\t\tif (k == 999) {\n\t\t\t\t\tif (ld - EPS <= e[i].r) {\n\t\t\t\t\t\tans += e[i].cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for (int i = (a); i < (b); i++)\n#define rep(i, b) for (int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define int long long\nusing namespace std;\n\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n\treturn vector<T>(x, a);\n}\n\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n\tauto cont = vectors(y, z, zs...);\n\treturn vector<decltype(cont)>(x, cont);\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &v) {\n\trep(i, v.size()) { os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); }\n\treturn os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n\tfor (T &x : v) { is >> x; }\n\treturn is;\n}\n\nconst double EPS = 1e-9;\nauto equals = [](double a, double b) { return fabs(a - b) < EPS; };\n\nstruct Point {\n\tdouble x, y, z;\n\tPoint() {}\n\tPoint(double x, double y, double z) : x(x), y(y), z(z) {}\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y, z + p.z); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y, z - p.z); }\n\tPoint operator*(double k) { return Point(x * k, y * k, z * k); }\n\tPoint operator/(double k) { return Point(x / k, y / k, z / k); }\n\tPoint operator*(Point p) {\n\t\treturn Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);\n\t}\n\tdouble operator^(Point p) { return x * p.x + y * p.y + z * p.z; }\n\tdouble norm() { return x * x + y * y + z * z; }\n\tdouble abs() { return sqrt(norm()); }\n\tbool operator<(const Point &p) const {\n\t\tif (x != p.x) return x < p.x;\n\t\tif (y != p.y) return y < p.y;\n\t\treturn z < p.z;\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS &&\n\t\t\t   fabs(z - p.z) < EPS;\n\t}\n};\nistream &operator>>(istream &is, Point &p) {\n\tis >> p.x >> p.y >> p.z;\n\treturn is;\n}\nostream &operator<<(ostream &os, Point p) {\n\tos << fixed << setprecision(12) << p.x << \" \" << p.y << \" \" << p.z;\n\treturn os;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment {\n\tPoint p1, p2;\n\tSegment() {}\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\n\nistream &operator>>(istream &is, Segment &s) {\n\tis >> s.p1 >> s.p2;\n\treturn is;\n}\n\nstruct Sphere {\n\tPoint c;\n\tdouble r;\n\tSphere() {}\n\tSphere(Point c, double r) : c(c), r(r) {}\n};\n\nistream &operator>>(istream &is, Sphere &c) {\n\tis >> c.c >> c.r;\n\treturn is;\n}\n\ndouble norm(Vector a) { return a.x * a.x + a.y * a.y + a.z * a.z; }\ndouble abs(Vector a) { return sqrt(norm(a)); }\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nVector cross(Vector a, Vector b) {\n\treturn Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,\n\t\t\t\t  a.x * b.y - a.y * b.x);\n}\n\nPoint project(Line l, Point p) {\n\tPoint b = l.p2 - l.p1;\n\tdouble t = dot(p - l.p1, b) / norm(b);\n\treturn l.p1 + b * t;\n}\n\nPoint reflect(Line l, Point p) { return p + (project(l, p) - p) * 2.0; }\n\ndouble getDistanceLP(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\nbool intersectSC(Segment s, Sphere c) {\n\tdouble d = getDistanceSP(s, c.c);\n\tif (d > c.r) return 0;\n\treturn !((abs(s.p1 - c.c) <= c.r) && (abs(s.p2 - c.c) <= c.r));\n}\nbool intersectSC(Point p1, Point p2, Sphere c) {\n\treturn intersectSC(Segment(p1, p2), c);\n}\n\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<Sphere> s(n);\n\tvector<int> c(n);\n\trep(i, n) { cin >> s[i] >> c[i]; }\n\n\trep(i, q) {\n\t\tPoint p1, p2;\n\t\tcin >> p1 >> p2;\n\n\t\tint sum = 0;\n\t\trep(j, n) {\n\t\t\tif (intersectSC(p1, p2, s[j])) { sum += c[j]; }\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//3次元\nstruct Point{\n\tPoint(double arg_x,double arg_y,double arg_z){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tz = arg_z;\n\t}\n\n\tPoint(){\n\t\tx = y = z = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y,z+p.z); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n\tPoint operator * (double a){ return Point(a*x,a*y,a*z); }\n\tPoint operator / (double a){ return Point(x/a,y/a,z/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y + z*z; }\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS && fabs(z-p.z) < EPS;\n\t}\n\tdouble x,y,z;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nstruct Info{\n\tPoint center;\n\tdouble r;\n\tll value;\n};\n\nint N,Q;\nInfo info[50];\n\n//3次元\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y+a.z*b.z;\n}\n\n//垂線が引ける場合、交点を求める\nPoint projection(Line line,Point point){\n    double t = dot(point-line.p[0],line.p[0]-line.p[1])/norm(line.p[0]-line.p[1]);\n    return line.p[0] + (line.p[0]-line.p[1])*t;\n}\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nbool intersect(Line line,int index){\n\n\tdouble dist_1 = calc_dist(line.p[0],info[index].center);\n\tdouble dist_2 = calc_dist(line.p[1],info[index].center);\n\n\t//方向ベクトル\n\tdouble Vx = line.p[1].x-line.p[0].x;\n\tdouble Vy = line.p[1].y-line.p[0].y;\n\tdouble Vz = line.p[1].z-line.p[0].z;\n\n\t//Oを原点,点Aをline.p[0]としたとき、点info[inde]から下した垂線との交点が、(line.p[0].x+t*Vx,line.p[0].y+t*Vy,line.p[0].z+t*Vz)と表されるようなt\n\tdouble t = (Vx*(info[index].center.x-line.p[0].x)+Vy*(info[index].center.y-line.p[0].y)+Vz*(info[index].center.z-line.p[0].z))/(Vx*Vx+Vy*Vy+Vz*Vz);\n\n\tif(t < 0 || t > 1){ //垂線が、観測点と光源を結ぶ線分上にない場合→最近地点は、観測点か光源のどちらか\n\t\tif(dist_1 > info[index].r && dist_2 > info[index].r){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdouble cross_x = line.p[0].x+t*Vx;\n\tdouble cross_y = line.p[0].y+t*Vy;\n\tdouble cross_z = line.p[0].z+t*Vz;\n\n\tdouble dist = sqrt((info[index].center.x-cross_x)*(info[index].center.x-cross_x)\n\t\t\t+(info[index].center.y-cross_y)*(info[index].center.y-cross_y)\n\t\t\t+(info[index].center.z-cross_z)*(info[index].center.z-cross_z)\n\t\t);\n\n\treturn dist <= info[index].r;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&Q);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\",&info[i].center.x,&info[i].center.y,&info[i].center.z,&info[i].r,&info[i].value);\n\t}\n\n\tPoint a,b;\n\tll ans;\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf\",&a.x,&a.y,&a.z,&b.x,&b.y,&b.z);\n\t\tans = 0;\n\t\tLine line(a,b);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(intersect(line,i))ans += info[i].value;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef valarray<double> Point;\n\ndouble dot(const Point &a, const Point &b){\n\treturn (a * b).sum();\n}\n\ndouble dist2(const Point &a, const Point &b){\n\treturn dot(a - b, a - b);\n}\n\nint n, q;\nPoint p[50];\ndouble r[50];\nlong long l[50];\nPoint s, t;\n\nint calc()\n{\n\tstatic const double EPS = 1e-12;\n\tPoint v = (t - s);\n\tlong long res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tdouble left = 0.0, right = 1.0;\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble d1 = dist2(s + v * mid, p[i]);\n\t\t\tdouble d2 = dist2(s + v * (mid + EPS), p[i]);\n\t\t\tif (d1 > d2) left = mid;\n\t\t\telse right = mid;\n\t\t}\n\t\t//printf(\"%.20f\\n\", dist2(s + v * left, p[i]));\n\t\tif (dist2(s + v * left, p[i]) < r[i] * r[i] + 1e-4) res += l[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tdouble x, y, z;\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\", &x, &y, &z, r + i, l + i);\n\t\tp[i] = {x, y, z};\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\ts = {x, y, z};\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\tt = {x, y, z};\n\t\tprintf(\"%lld\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#define Vector3D Vertex3D\nusing namespace std;\n\nstruct Vertex3D{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n};\n\nstruct Obj{\n  double x,y,z,r,cost;\n};\n\n//???????????¢\ndouble distance_vertex(Vertex3D p1, Vertex3D p2) {\n\treturn pow( ( p2.x - p1.x ) * ( p2.x - p1.x ) + ( p2.y - p1.y ) * ( p2.y - p1.y ) + ( p2.z - p1.z ) * ( p2.z - p1.z ), 0.5 );\n}\n\n//??????????????????\ndouble length_vector(Vector3D v) {\n\treturn pow( v.x * v.x + v.y * v.y + v.z * v.z , 0.5 );\n}\n\n//??????????????????\nVector3D cross_vector(Vector3D vl, Vector3D vr) {\n\tVector3D ret;\n\tret.x = (vl.y * vr.z) - (vl.z * vr.y);\n\tret.y = (vl.z * vr.x) - (vl.x * vr.z);\n\tret.z = (vl.x * vr.y) - (vl.y * vr.x);\n\n\treturn ret;\n}\n\n//???P??¨???(AB)????????¢\ndouble Distance_DotAndLine(Vertex3D P, Vertex3D A, Vertex3D B )\n{\n\tVector3D AB,AP;\n\n\tAB.x = B.x - A.x;\n\tAB.y = B.y - A.y;\n\tAB.z = B.z - A.z;\n\tAP.x = P.x - A.x;\n\tAP.y = P.y - A.y;\n\tAP.z = P.z - A.z;\n\n\t//AB???AP????????????????±??????????????????????????????????????????????????????¢D?????¢????????????\n\tdouble D = length_vector( cross_vector( AB, AP ) );\n\n\t//AB???????????¢\n\tdouble L = distance_vertex( A, B );\t//AB?????????\n\n\tdouble H = D / L;\n\treturn H;\n\n}\n\nint main()\n{ \n  int N,Q;\n  int x,y,z,r,l;\n  int sx,sy,sz,dx,dy,dz;\n  Obj obj[51];\n\n  cin>>N>>Q;\n\n  for(int i=0;i<N;i++){\n    cin>>obj[i].x>>obj[i].y>>obj[i].z>>obj[i].r>>obj[i].cost;\n  }\n\n  for(int i=0;i<Q;i++){\n    cin>>sx>>sy>>sz>>dx>>dy>>dz;\n    Vertex3D A,B;\n    int ans=0;\n    A.x=sx;A.y=sy;A.z=sz;\n    B.x=dx;B.y=dy;B.z=dz;\n    for(int j=0;j<N;j++){\n      Vertex3D P;\n      P.x=obj[j].x;\n      P.y=obj[j].y;\n      P.z=obj[j].z;\n      if(Distance_DotAndLine(P,A,B)<=obj[j].r)ans+=obj[j].cost;\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nstruct P {\n  double x, y, z;\n  P() {}\n  P(double x, double y, double z) : x(x), y(y), z(z) {}\n  P operator+(P p) { return P(x+p.x, y+p.y, z+p.z); }\n  P operator-(P p) { return P(x-p.x, y-p.y, z-p.z); }\n  P operator*(double k) { return P(x*k, y*k, z*k); }\n  P operator/(double k) { return P(x/k, y/k, z/k); }\n  P operator*(P p) {\n    return P(y*p.z-z*p.y, z*p.x-x*p.z, x*p.y-y*p.x);    \n  }\n};\n\ntypedef P V;\n\nstruct Seg {\n  P p1, p2;\n  Seg(){}\n  Seg(P p1, P p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Seg Line;\n\nstruct Sphere {\n  P c;\n  double r;\n  Sphere() {}  \n  Sphere(P c, double r) : c(c), r(r){}\n};\n\ndouble norm(V a) {\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\ndouble abs(V a) {\n  return sqrt(norm(a));\n}\n\ndouble dot(V a, V b) {\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\n\nV cross(V a, V b) {\n  return V(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);  \n}\n\ndouble gdLP(Line l, P p) {\n  return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));  \n}\n\ndouble gdSP(Seg s, P p) {\n  if ( dot(s.p2-s.p1, p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if ( dot(s.p1-s.p2, p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return gdLP(s, p);  \n}\n\nbool iSC(Seg s, Sphere c) {\n  double d = gdSP(s, c.c);\n  if ( d > c.r ) return 0;\n  return !((abs(s.p1-c.c)<=c.r) && (abs(s.p2-c.c)<=c.r));  \n}\n\nsigned main(){\n  int N, Q;\n  cin >> N >> Q;\n \n  vector<Sphere> s(N);\n  vector<int> l(N);\n  for ( int i = 0; i < N; i++ ) {\n    cin >> s[i].c.x >> s[i].c.y >> s[i].c.z >> s[i].r >> l[i];    \n  }\n\n  for ( int i = 0; i < Q; i++ ) {\n    int sum = 0;\n    Seg seg;\n    P p1, p2;\n    cin >> p1.x >> p1.y >> p1.z >> p2.x >> p2.y >> p2.z;\n    seg = Seg(p1, p2);\n    for ( int j = 0; j < N; j++ ) {\n      if ( iSC(seg, s[j]) ) {\n\tsum += l[j];\t\n      }\n    }\n\n    cout << sum << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define STEPS 100000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tlong double vx = 1.0 * (sx - dx) / STEPS;\n\t\tlong double vy = 1.0 * (sy - dy) / STEPS;\n\t\tlong double vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tlong double tx = sx;\n\t\tlong double ty = sy;\n\t\tlong double tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tlong double rx = tx - x[k];\n\t\t\t\tlong double ry = ty - y[k];\n\t\t\t\tlong double rz = tz - z[k];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[k] * r[k] + 0.00001)\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttx -= vx;\n\t\t\tty -= vy;\n\t\t\ttz -= vz;\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_3d {\n\ndouble const EPS = 1e-9;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  double x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(double x, double y, double z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (double k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (double k) const { return P3(x / k, y / k, z / k); }\n};\n\ndouble dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\ndouble norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\ndouble abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\ndouble cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\ndouble angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { double x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\ndouble distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, double, double>> os;\n  rep(i, N) {\n    P3 p; double r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; double r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n\tdouble x,y,z;\n};\ndouble dot(P a,P b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\ndouble abs(P a){\n\treturn sqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n}\nP sub(P a,P b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\ta.z -= b.z;\n\treturn a;\n}\nP pls(P a,P b){\n\ta.x += b.x;\n\ta.y += b.y;\n\ta.z += b.z;\n\treturn a;\n}\nP mul(double v,P a){\n\ta.x *= v;\n\ta.y *= v;\n\ta.z *= v;\n\treturn a;\n}\n\ndouble dist(P a,P b,P c){\n\tP e = sub(b,a);\n\te = mul(1./abs(e),e);\n\tP v = sub(c,a);\n\tP pdl = pls(a,mul(dot(e,v),e));\n\tif( fabs(abs(sub(pdl,a))+abs(sub(pdl,b))-abs(sub(a,b))) > 1e-8 ) return 1e9;\n\treturn abs(sub(c,pdl));\n}\nP p[50];\nlong long l[50],r[50];\nint main(){\n\tint N,Q;\n\tcin >> N >> Q;\n\tfor(int i = 0 ; i < N ; i++) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tP p1,p2;\n\t\tcin >> p1.x >> p1.y >> p1.z;\n\t\tcin >> p2.x >> p2.y >> p2.z;\t\t\n\t\tlong long ans = 0;\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\tif( dist(p1,p2,p[j]) < r[j] + 1e-8 ) ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\ndouble sqr(double x)\n{\n  return(x * x);\n}\ndouble abs2(double ax, double ay, double az, int x, int y, int z)\n{\n  return(sqr(ax - x) + sqr(ay - y) + sqr(az - z));\n}\n\nint main()\n{\n  int64 N, Q, x[50], y[50], z[50], r[50], l[50];\n  cin >> N >> Q;\n  for(int i = 0; i < N; i++) {\n    cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  }\n  while(Q--) {\n    int sx, sy, sz, dx, dy, dz;\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    int64 ret = 0;\n    for(int k = 0; k < N; k++) {\n      double low = 0, high = 1.0;\n      for(int i = 0; i < 50; i++) {\n        double left = (low * 2 + high) / 3;\n        double right = (low + high * 2) / 3;\n        double ll = abs2(sx + (dx - sx) * left, sy + (dy - sy) * left, sz + (dz - sz) * left, x[k], y[k], z[k]);\n        double rr = abs2(sx + (dx - sx) * right, sy + (dy - sy) * right, sz + (dz - sz) * right, x[k], y[k], z[k]);\n        if(ll < rr) high = right;\n        else low = left;\n      }\n      double mm = abs2(sx + (dx - sx) * (low + high) / 2, sy + (dy - sy) * (low + high) / 2, sz + (dz - sz) * (low + high) / 2, x[k], y[k], z[k]);\n      if(mm < r[k] * r[k] + 1e-9) ret += l[k]; \n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define STEPS 100000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tdouble vx = 1.0 * (sx - dx) / STEPS;\n\t\tdouble vy = 1.0 * (sy - dy) / STEPS;\n\t\tdouble vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tdouble tx = sx;\n\t\tdouble ty = sy;\n\t\tdouble tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tdouble rx = tx - x[i];\n\t\t\t\tdouble ry = ty - y[i];\n\t\t\t\tdouble rz = tz - z[i];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[i] * r[i])\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttx += vx;\n\t\t\tty += vy;\n\t\t\ttz += vz;\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<double>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\ndouble msum(vlai a,vlai b){\n    return (double)((a*b).sum());\n}\ndouble msum(vlai a){\n    return (double)((a*a).sum());\n}\n\ndouble dot(vlai a,vlai b){\n    return msum(a,b)/sqrt(msum(a))/sqrt(msum(b));\n}\n\nint main(){\n    int n,m;cin>>n>>m;\n    vector<pair<vlai,vlai>> obs(n,mp(vlai(0.0,3),vlai(0.0,2)));\n    rep(i,n){cin>>obs[i].fs[0]>>obs[i].fs[1]>>obs[i].fs[2]>>obs[i].sc[0]>>obs[i].sc[1];}\n    vlai a(0.0,3),b(0.0,3);\n    rep(i,m){\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        double d=sqrt(msum(a-b));\n        vlai u=(b-a)/d;\n        int ans=0;\n        rep(j,n){\n            double dst=0.0;\n            if(dot(b-a,b-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-b));\n            }else if(dot(a-b,a-obs[j].fs)<0){\n                dst=sqrt(msum(obs[j].fs-a));\n            }else{\n                vlai p=msum(obs[j].fs-a,u)*u+a;\n                dst=sqrt(msum(p-obs[j].fs));\n                //cout<<p[0]<<\",\"<<p[1]<<\",\"<<p[2]<<\",\"<<endl;\n            }\n            if(dst<=obs[j].sc[0]) ans+=obs[j].sc[1];\n        }\n        cout<<ans<<endl;\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef struct{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n\tlong long l;\n}_object;\n\nint main(){\n\tint N,Q;\n\tscanf(\"%d%d\",&N,&Q);\n\tvector<_object> object(N);\n\tfor(int i=0;i<N;i++)scanf(\"%lf%lf%lf%lf%lld\",&object[i].x,&object[i].y,&object[i].z,&object[i].r,&object[i].l);\n\tfor(int i=0;i<Q;i++){\n\t\t// http://www.infra.kochi-tech.ac.jp/takagi/Survey2/7Parameter.pdf\n\t\tdouble xa,ya,za,xx,yx,zx;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&xa,&ya,&za,&xx,&yx,&zx);\n\t\tdouble vx=xx-xa,vy=yx-ya,vz=zx-za;\n\t\tlong long R=0;\n\t\tfor(auto &e:object){\n\t\t\tdouble t=(vx*(e.x-xa)+vy*(e.y-ya)+vz*(e.z-za))/(vx*vx+vy*vy+vz*vz);\n\t\t\tif(t<0)t=0;\n\t\t\tif(t>1)t=1;\n\t\t\tdouble xt=xa+vx*t,yt=ya+vy*t,zt=za+vz*t;\n\t\t\tdouble r=(e.x-xt)*(e.x-xt)+(e.y-yt)*(e.y-yt)+(e.z-zt)*(e.z-zt);\n\t\t\tif(r<=e.r*e.r)R+=e.l;\n\t\t}\n\t\tprintf(\"%lld\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst double EPS = 1e-7;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vector<double> x(n), y(n), z(n), r(n);\n    vector<int> l(n);\n    rep(i, 0, n){\n        cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n    }\n    rep(i, 0, q){\n        double sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        int tm = 100000;\n        vector<bool> f(n);\n        rep(j, 0, tm + 1){\n            double nx = sx + (dx - sx) * (double)j / (double)tm;\n            double ny = sy + (dy - sy) * (double)j / (double)tm;\n            double nz = sz + (dz - sz) * (double)j / (double)tm;\n            rep(k, 0, n){\n                if(f[k]) continue;\n                double dist = pow(nx - x[k], 2) + pow(ny - y[k], 2) + pow(nz - z[k], 2);\n                if(r[k] * r[k] - dist > -EPS){\n                    f[k] = true;\n                }\n            }\n        }\n        int ans = 0;\n        rep(j, 0, n) if(f[j]) ans += l[j];\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\ntypedef struct {\n    double x, y, z;\n} P;\n\ndouble dot(P a, P b)\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nP diff(P f, P t)\n{\n    return P{ t.x - f.x, t.y - f.y, t.z - f.z };\n}\n\nP mul(P a, double s)\n{\n    return P{ a.x*s, a.y*s, a.z*s };\n}\n\nconst double EPS = 1e-5;\n\nint main()\n{\n    int n, q; cin >> n >> q;\n    vector<P> p(n);\n    vector<double> r(n);\n    vector<ll> l(n);\n    loop (n, i) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\n    loop (q, i) {\n        P s, t;\n        cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n        P v = diff(s, t);\n        double d = pow(dot(v, v), 0.5);\n        ll ans = 0;\n        loop (n, j) {\n            P w = diff(s, p[j]);\n            P nv = mul(v, dot(w, v) / d / d);\n            P nw = diff(nv, w);\n            double R = pow(dot(nw, nw), 0.5);\n            if (R < r[j] + EPS) ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\nstruct P {\n  double x, y, z;\n  P() {}\n  P(double x, double y, double z) : x(x), y(y), z(z) {}\n  P operator+(P p) { return P(x+p.x, y+p.y, z+p.z); }\n  P operator-(P p) { return P(x-p.x, y-p.y, z-p.z); }\n  P operator*(double k) { return P(x*k, y*k, z*k); }\n  P operator/(double k) { return P(x/k, y/k, z/k); }\n  P operator*(P p) {\n    return P(y*p.z-z*p.y, z*p.x-x*p.z, x*p.y-y*p.x);    \n  }\n};\n\ntypedef P V;\n\nstruct Seg {\n  P p1, p2;\n  Seg(){}\n  Seg(P p1, P p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Seg Line;\n\nstruct Sphere {\n  P c;\n  double r;\n  Sphere() {}  \n  Sphere(P c, double r) : c(c), r(r){}\n};\n\ndouble norm(V a) {\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\ndouble abs(V a) {\n  return sqrt(norm(a));\n}\n\ndouble dot(V a, V b) {\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\n\nV cross(V a, V b) {\n  return V(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);  \n}\n\ndouble gdLP(Line l, P p) {\n  return abs(cross(l.p2-l.p1, p-l.p1)/abs(l.p2-l.p1));  \n}\n\ndouble gdSP(Seg s, P p) {\n  if ( dot(s.p2-s.p1, p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if ( dot(s.p1-s.p2, p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return gdLP(s, p);  \n}\n\nbool iSC(Seg s, Sphere c) {\n  double d = gdSP(s, c.c);\n  if ( d > c.r ) return 0;\n  return !((abs(s.p1-c.c)<=c.r) && (abs(s.p2-c.c)<=c.r));  \n}\n\nsigned main(){\n  int N, Q;\n  cin >> N >> Q;\n \n  vector<Sphere> s(N);\n  vector<int> l(N);\n  for ( int i = 0; i < N; i++ ) {\n    cin >> s[i].c.x >> s[i].c.y >> s[i].c.z >> s[i].r >> l[i];    \n  }\n\n  for ( int i = 0; i < Q; i++ ) {\n    int sum = 0;\n    Seg seg;\n    P p1, p2;\n    cin >> p1.x >> p1.y >> p1.z >> p2.x >> p2.y >> p2.z;\n    seg = Seg(p1, p2);\n    for ( int j = 0; j < N; j++ ) {\n      if ( iSC(seg, s[j]) ) {\n\tsum += l[j];\t\n      }\n    }\n\n    cout << sum << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  double x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  int r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2*area)/abs(l.second - l.first);\n  //std::cout << abs(l.second - l.first) << \" \" << abs(p - l.first) << std::endl;\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  //  std::cout << \"cosa:\" << cosa << \" cosb:\" << cosb << std::endl;\n  if(cosa < 0) return abs(p - l.first);\n  if(cosb < 0) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].c.x >> p[i].c.y >> p[i].c.z >> p[i].r >> p[i].l;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    int ans = 0;\n    scanf(\"%lf %lf %lf %lf %lf %lf\", &s.x, &s.y, &s.z, &d.x, &d.y, &d.z);\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      double d = dis(l, p[j].c);\n      //std::cout << \"j:\" << j << \" dis:\" << d << \" r:\" << p[j].r << std::endl;\n      if(d <= p[j].r){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nconst double tol = 1e-12;\n\ntemplate <class T>\nstruct Point {\n    T x, y, z;\n    Point(T x_, T y_, T z_) : x(x_), y(y_), z(z_) {}\n    Point& operator+=(const Point& other) { x += other.x; y += other.y; z += other.z; return *this; }\n    Point& operator-=(const Point& other) { x -= other.x; y -= other.y; z -= other.z; return *this; }\n    Point& operator*=(const T& alpha) { x *= alpha; y *= alpha; z *= alpha; return *this; }\n};\n\ntemplate <class T>\ninline Point<T> operator+(const Point<T>& lhs, const Point<T>& rhs) { Point<T> t(lhs); return t += rhs; }\ntemplate <class T>\ninline Point<T> operator-(const Point<T>& lhs, const Point<T>& rhs) { Point<T> t(lhs); return t -= rhs; }\ntemplate <class T>\ninline Point<T> operator*(const Point<T>& lhs, const T& rhs) { Point<T> t(lhs); return t *= rhs; }\n\ntemplate <class T>\ninline T norm(const Point<T>& p) { return p.x * p.x + p.y * p.y + p.z * p.z; }\n\ntemplate <class T>\ninline T abs(const Point<T>& p) { return sqrt(norm(p)); }\n\ntemplate <class T>\ninline T dot(const Point<T>& a, const Point<T>& b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ntemplate <class T>\nstruct Line : vector<Point<T>> {\n    Line(const Point<T>& a, const Point<T>& b) : vector<Point<T>>{a, b} {}\n    T length() const { return abs((*this)[1] - (*this)[0]); }\n};\n\ntemplate <class T>\ninline Point<T> projection(const Line<T>& l, const Point<T>& p) {\n    const Point<T> q = l[1] - l[0];\n    T t = dot(p - l[0], q) / norm(q);\n    return l[0] + q * t;\n}\n\ntemplate <class T>\nstruct Segment : Line<T> {\n    Segment(const Point<T>& a, const Point<T>& b) : Line<T>(a, b) {}\n};\n\ntemplate <class T>\ninline bool intersect(const Segment<T>& s, const Point<T>& p) {\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < tol;\n}\n\ntemplate <class T>\ninline T distance(const Segment<T>& s, const Point<T>& p) {\n    const Point<T> r = projection(s, p);\n    return intersect(s, r) ? abs(r - p) : min(abs(s[0] - p), abs(s[1] - p));\n}\n\ntemplate <class T>\nstruct Sphere : Point<T> {\n    T r;\n    Sphere(T x_, T y_, T z_, T r_) : Point<T>(x_, y_, z_), r(r_) {}\n};\n\ntemplate <class T>\ninline bool intersect(const Sphere<T>& sh, const Segment<T>& ls) {\n    return distance(ls, Point<T>(sh)) <= sh.r + tol;\n}\n\nusing point_t = Point<double>;\nusing segment_t = Segment<double>;\nusing sphere_t = Sphere<double>;\n\nstruct Obstacle : sphere_t {\n    long long l;\n    Obstacle(double x_, double y_, double z_, double r_, long long l_) : sphere_t(x_, y_, z_, r_), l(l_) {}\n};\n\nint main() {\n    int N, Q; cin >> N >> Q;\n    vector<Obstacle> obstacle;\n    rep(i, N) {\n        int x, y, z, r; long long l; cin >> x >> y >> z >> r >> l;\n        obstacle.emplace_back(x, y, z, r, l);\n    }\n    while (Q--) {\n        int sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        segment_t line_of_fire(point_t(sx, sy, sz), point_t(dx, dy, dz));\n        cout << accumulate(all(obstacle), 0ll, [&](long long power, const Obstacle& o) {\n            return power + (intersect(o, line_of_fire) ? o.l : 0ll);\n        }) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\ndouble dist3(double x, double y, double z) {\n    double d = x * x + y * y + z * z;\n    return sqrt(d);\n}\n\ndouble crprd3(tddd p, tddd q) {\n    double x = get<1>(p) * get<2>(q) - get<2>(p) * get<1>(q);\n    double y = get<2>(p) * get<0>(q) - get<0>(p) * get<2>(q);\n    double z = get<0>(p) * get<1>(q) - get<1>(p) * get<0>(q);\n    return dist3(x, y, z);\n}\n\ndouble dtprd3(tddd p, tddd q) {\n    double ans = 0;\n    ans += get<0>(p) * get<0>(q);\n    ans += get<1>(p) * get<1>(q);\n    ans += get<2>(p) * get<2>(q);\n    return ans;\n}\n\ntddd plus3(tddd p, tddd q) {\n    double x = get<0>(p) + get<0>(q);\n    double y = get<1>(p) + get<1>(q);\n    double z = get<2>(p) + get<2>(q);\n    return tddd(x, y, z);\n}\n\ntddd constprod3(double k, tddd p) {\n    double x = k * get<0>(p);\n    double y = k * get<1>(p);\n    double z = k * get<2>(p);\n    return tddd(x, y, z);\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    ll drpt[N][5];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < 5; j++) {\n            cin >> drpt[i][j];\n        }\n    }\n    for (int i = 0; i < Q; i++) {\n        ll pos[6];\n        for (int j = 0; j < 6; j++) {\n            cin >> pos[j];\n        }\n        ll ans = 0;\n        ll line[3];\n        for (int j = 0; j < 3; j++) {\n            line[j] = pos[j] - pos[j + 3];\n        }\n        for (int j = 0; j < N; j++) {\n            ll xyz[3];\n            for (int k = 0; k < 3; k++) {\n                xyz[k] = drpt[j][k] - pos[k + 3];\n            }\n            tddd l = tddd(line[0], line[1], line[2]);\n            tddd xxyyzz = tddd(xyz[0], xyz[1], xyz[2]);\n            double crp = crprd3(l, xxyyzz);\n            double ldis = dist3(line[0], line[1], line[2]);\n            double pre = dtprd3(l, xxyyzz);\n            double ovr = dtprd3(constprod3(-1, l), plus3(xxyyzz, constprod3(-1, l)));\n            //cout << pre << \" \" << ovr << \" \" << crp / ldis << \" \" << drpt[j][3]  << \" \" << drpt[j][4]<< endl;\n            if (pre >= -1e-7 && ovr >= -1e-7 && crp / ldis - 1e-7 <= drpt[j][3]) {\n                ans += drpt[j][4];\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing T = tuple<double,double,double>;\n\ndouble inner_cross(T u, T v){\n    double ux,uy,uz,vx,vy,vz;\n    tie(ux,uy,uz)=u;\n    tie(vx,vy,vz)=v;\n    return ux*vx+uy*vy+uz*vz;\n}\n\nbool isCross(T Center, double radius, T s, T t){\n    double cx,cy,cz,sx,sy,sz,tx,ty,tz;\n    tie(cx,cy,cz)=Center;\n    tie(sx,sy,sz)=s;\n    tie(tx,ty,tz)=t;\n    T u(tx-sx,ty-sy,tz-sz), v(cx-sx,cy-sy,cz-sz);\n    double d = inner_cross(u,v)/inner_cross(u,u);\n    if(inner_cross(u,v)<0||inner_cross(u,v)>inner_cross(u,u)) return false;\n    else{\n        double ux,uy,uz,vx,vy,vz;\n        tie(ux,uy,uz)=u;\n        tie(vx,vy,vz)=v;\n        T vert(vx-ux*d,vy-uy*d,vz-uz*d);\n        if(inner_cross(vert,vert)<=radius*radius+1e-9){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\nint main(){\n    int N,Q;\n    cin>>N>>Q;\n    vector<T> Ob;\n    vector<double> r(N);\n    vector<int64_t> l(N);\n    for(int i=0;i<N;i++){\n        double x,y,z;\n        cin>>x>>y>>z>>r[i]>>l[i];\n        Ob.emplace_back(x,y,z);\n    }\n    for(int i=0;i<Q;i++){\n        double sx,sy,sz,dx,dy,dz;\n        cin>>sx>>sy>>sz>>dx>>dy>>dz;\n        T s(sx,sy,sz), t(dx,dy,dz);\n        int64_t cost = 0;\n        for(int j=0;j<N;j++){\n            if(isCross(Ob[j],r[j],s,t)) cost+=l[j];\n        }\n        cout<<cost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef valarray<double> Point;\n\ndouble dot(const Point &a, const Point &b){\n\treturn (a * b).sum();\n}\n\ndouble dist2(const Point &a, const Point &b){\n\treturn dot(a - b, a - b);\n}\n\nint n, q;\nPoint p[50];\ndouble r[50];\nlong long l[50];\nPoint s, t;\n\nlong long calc()\n{\n\tstatic const double EPS = 1e-12;\n\tPoint v = (t - s);\n\tlong long res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tdouble left = 0.0, right = 1.0;\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble d1 = dist2(s + v * mid, p[i]);\n\t\t\tdouble d2 = dist2(s + v * (mid + EPS), p[i]);\n\t\t\tif (d1 > d2) left = mid;\n\t\t\telse right = mid;\n\t\t}\n\t\t//printf(\"%.20f\\n\", dist2(s + v * left, p[i]));\n\t\tif (dist2(s + v * left, p[i]) < r[i] * r[i] + 1e-12) res += l[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tdouble x, y, z;\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\", &x, &y, &z, r + i, l + i);\n\t\tp[i] = {x, y, z};\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\ts = {x, y, z};\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\tt = {x, y, z};\n\t\tprintf(\"%lld\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  Point dir = l[1] - l[0];\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  if(D < -EPS) return false;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(abs(t1) < 1 || abs(t2) < 1){\n    return true;\n  }\n  return false;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])){\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst ld eps = 1e-12;\n\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<ll> X(N), Y(N), Z(N), R(N), L(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n\t}\n\tfor (int q = 0; q < Q; ++q) {\n\t\tll sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tll a = dx - sx, b = dy - sy, c = dz - sz;\n\t\tif (a == 0 && b == 0 && c == 0) cout << 0 << endl;\n\t\telse {\n\t\t\tll ans = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint d = a * X[i] + b * Y[i] + c * Z[i];\n\t\t\t\tll den = a*a + b*b + c*c;\n\t\t\t\tll t = d - a * sx - b * sy - c * sz; // t / den\n\t\t\t\tll x = den * sx + a * t; // x / den\n\t\t\t\tll y = den * sy + b * t;\n\t\t\t\tll z = den * sz + c * t;\n\t\t\t\tll xx = den*X[i]-x, yy = den*Y[i]-y, zz = den*Z[i]-z;\n\t\t\t\tif ( 0 < t && t < den ) {\n\t\t\t\t\tll rr = xx*xx + yy*yy + zz*zz;\n\t\t\t\t\tif (rr <= den*den*R[i]*R[i]) {\n\t\t\t\t\t\tans += L[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tll rr = (X[i]-sx)*(X[i]-sx) + (Y[i]-sy)*(Y[i]-sy) + (Z[i]-sz)*(Z[i]-sz);\n\t\t\t\t\trr = min(rr, (X[i]-dx)*(X[i]-dx) + (Y[i]-dy)*(Y[i]-dy) + (Z[i]-dz)*(Z[i]-dz));\n\t\t\t\t\tif (rr < R[i]*R[i]) {\n\t\t\t\t\t\tans += L[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point3D {\n\tdouble x, y, z;\n\n\tPoint3D() : x(0), y(0), z(0) {}\n\n\tPoint3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n\tPoint3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }\n\n\tPoint3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }\n\n\tPoint3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }\n\n\tPoint3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }\n\n\tbool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point3D& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";\n\treturn os;\n}\n\ndouble dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nPoint3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }\n\ndouble norm(Point3D p) { return dot(p, p); }\ndouble abs(Point3D p) { return sqrt(norm(p)); }\n\nstruct Line {\n\tPoint3D a, b;\n\n\tLine() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}\n\n\tLine(Point3D a, Point3D b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \", \" << l.a.z <<  \")-(\" << l.b.x << \",\" << l.b.y << \", \" << l.b.z <<  \")\";\n\treturn os;\n}\n\nPoint3D project(Line l, Point3D p) {\n\tPoint3D base = l.b - l.a;\n\tdouble t = dot(base, p-l.a) / dot(base, base);\n\treturn l.a + base * t;\n}\n\nstruct Ball {\n\tPoint3D p;\n\tdouble r;\n\n\tBall() : p(Point3D(0, 0, 0)), r(0.0) {}\n\n\tBall(Point3D p, double r) : p(p), r(r) {}\n};\n\nostream& operator << (ostream& os, const Ball& b) {\n\tos << \"(\" << b.p.z << \", \" << b.p.y << \", \" << b.p.z << \" :\" << b.r << \")\";\n\treturn os;\n}\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<Ball> v(n);\n\tvector<ll> cost(n);\n\trep(i, n) {\n\t\tcin >> v[i].p.x >> v[i].p.y >> v[i].p.z >> v[i].r >> cost[i];\n\t}\n\n\tll ans = 0;\n\trep(i, q) {\n\t\tPoint3D s, t;\n\t\tcin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n\t\tLine line(s, t);\n\n\t\trep(j, n) {\n\t\t\tPoint3D proj = project(line, v[i].p);\n\n\t\t\tif(abs(line.b - line.a) >= abs(proj - line.a) && abs(line.a - line.b) >= abs(proj - line.b)) {\n\t\t\t\tif(abs(proj - v[i].p) < v[i].r + EPS) {\n\t\t\t\t\tans += cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef struct{\n\tdouble x;\n\tdouble y;\n\tdouble z;\n\tdouble r;\n\tlong long l;\n}_object;\n\nint main(){\n\tint N,Q;\n\tscanf(\"%d%d\",&N,&Q);\n\tvector<_object> object(N);\n\tfor(int i=0;i<N;i++)scanf(\"%lf%lf%lf%lf%lld\",&object[i].x,&object[i].y,&object[i].z,&object[i].r,&object[i].l);\n\tfor(int i=0;i<Q;i++){\n\t\t// http://www.infra.kochi-tech.ac.jp/takagi/Survey2/7Parameter.pdf\n\t\tdouble xa,ya,za,xx,yx,zx;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&xa,&ya,&za,&xx,&yx,&zx);\n\t\tdouble vx=xx-xa,vy=yx-ya,vz=zx-za;\n\t\tlong long R=0;\n\t\tfor(auto &e:object){\n\t\t\tdouble t=(vx*(e.x-xa)+vy*(e.y-ya)+vz*(e.z-za))/(vx*vx+vy*vy+vz*vz);\n\t\t\tif(t<0)t=0;\n\t\t\tif(t>1)t=1;\n\t\t\tdouble xt=xa+vx*t,yt=ya+vy*t,zt=za+vz*t;\n\t\t\tdouble r=(e.x-xt)*(e.x-xt)+(e.y-yt)*(e.y-yt)+(e.z-zt)*(e.z-zt);\n\t\t\tif(r<e.r*e.r+1e-9)R+=e.l;\n\t\t}\n\t\tprintf(\"%lld\\n\",R);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  if(dot(v,c)<=0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  \n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    Point p,b;\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing Int = long long;\ntypedef long long ll;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersectSC(Segment3D s,Sphere c){\n  double d=getDistanceSP(s,c.c);\n  if(d>c.r) return 0;\n  return !((abs(s.p1-c.c)<=c.r)&&(abs(s.p2-c.c)<=c.r));\n}\n\nstruct ConvexHull3D{\n  struct face{\n    Int a,b,c;\n    bool ok;\n    face(){}\n    face(Int a,Int b,Int c,bool ok):a(a),b(b),c(c),ok(ok){}\n  };\n  Int n,num;\n  vector<Point3D> p;\n  vector<face> f;\n  vector<vector<Int> >  g;\n  \n  ConvexHull3D(Int n):n(n),p(n),f(n*8),g(n,vector<Int>(n)){}\n  \n  void input(){\n    for(Int i=0;i<n;i++) cin>>p[i];\n  }\n\n  double dblcmp(Point3D q,face f){\n    Point3D m=p[f.b]-p[f.a];\n    Point3D n=p[f.c]-p[f.a];\n    Point3D t=q-p[f.a];\n    return (m*n)^t;\n  }\n  \n  void deal(Int q,Int a,Int b){\n    Int idx=g[a][b];\n    face add;\n    if(f[idx].ok){\n      if(dblcmp(p[q],f[idx])>EPS) dfs(q,idx);\n      else{\n        add=face(b,a,q,1);\n        g[q][b]=g[a][q]=g[b][a]=num;\n        f[num++]=add;\n      }\n    }\n  }\n  \n  void dfs(Int q,Int now){\n    f[now].ok=0;\n    deal(q,f[now].b,f[now].a);\n    deal(q,f[now].c,f[now].b);\n    deal(q,f[now].a,f[now].c);\n  }\n  \n  void build(){\n    num=0;\n    if(n<4) return;\n    bool flg=1;\n    for(Int i=1;i<n;i++){\n      if(abs(p[0]-p[i])>EPS){\n        swap(p[1],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    flg=1;\n    for(Int i=2;i<n;i++){\n      if(abs((p[0]-p[1])*(p[1]-p[i]))>EPS){\n        swap(p[2],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    flg=1;\n    for(Int i=3;i<n;i++){\n      if(abs(((p[0]-p[1])*(p[1]-p[2]))^(p[0]-p[i]))>EPS){\n        swap(p[3],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    face add;\n    for(Int i=0;i<4;i++){\n      add=face((i+1)%4,(i+2)%4,(i+3)%4,1);\n      if(dblcmp(p[i],add)>0) swap(add.b,add.c);\n      g[add.a][add.b]=g[add.b][add.c]=g[add.c][add.a]=num;\n      f[num++]=add;\n    }\n    for(Int i=4;i<n;i++){\n      for(Int j=0;j<num;j++){\n        if(f[j].ok&&dblcmp(p[i],f[j])>EPS){\n          dfs(i,j);\n          break;\n        }\n      }\n    }\n    Int tmp=num;\n    num=0;\n    for(Int i=0;i<tmp;i++)\n      if(f[i].ok) f[num++]=f[i];\n  }\n\n  double volume(Point3D a,Point3D b,Point3D c,Point3D d){\n    return ((b-a)*(c-a))^(d-a);\n  }\n  \n  bool same(Int s,Int t){\n    Point3D &a=p[f[s].a];\n    Point3D &b=p[f[s].b];\n    Point3D &c=p[f[s].c];\n    return  (abs(volume(a,b,c,p[f[t].a]))<EPS)\n      &&    (abs(volume(a,b,c,p[f[t].b]))<EPS)\n      &&    (abs(volume(a,b,c,p[f[t].c]))<EPS);\n  }\n  \n  Int polygon(){\n    Int res=0;\n    for(Int i=0;i<num;i++){\n      Int flg=1;\n      for(Int j=0;j<i;j++)\n        flg&=!same(i,j);\n      res+=flg;\n    }\n    return res;\n  }\n\n  Int triangle(){\n    return num;\n  }\n\n  double area(Point3D a,Point3D b,Point3D c){\n    return abs((b-a)*(c-a));\n  }\n\n  Point3D cross(Point3D a,Point3D b,Point3D c){\n    return Point3D((b.y-a.y)*(c.z-a.z)-(b.z-a.z)*(c.y-a.y),\n                   (b.z-a.z)*(c.x-a.x)-(b.x-a.x)*(c.z-a.z),\n                   (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x));\n  }\n  \n  double area(){\n    double res=0;\n    if(n==3){\n      Point3D q=cross(p[0],p[1],p[2]);\n      res=abs(q)/2.0;\n      return res;\n    }\n    return res;\n    for(Int i=0;i<num;i++)\n      res+=area(p[f[i].a],p[f[i].b],p[f[i].c]);\n    return res/2.0;\n  }\n};\n\nSphere barrier[50];\nll ma[50];\nSegment3D t;\nint main()\n{\n\tint n,q;\n\tll ans;\n\tcin>>n>>q;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>barrier[i]>>ma[i];\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tans=0;\n\t\tcin>>t;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(intersectSC(t,barrier[j]))\n\t\t\t\tans+=ma[j];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y, z;\n\tPoint(double x = 0, double y = 0, double z = 0) :x(x), y(y), z(z) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y, z + p.z); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y, z - p.z); }\n\tPoint operator*(double a) { return Point(a * x, a * y, a*z); }\n\tPoint operator/(double a) { return Point(x / a, y / a, z / a); }\n\tbool operator<(const Point &p)const {\n\t\tif (x < p.x)return true;\n\t\tif (x > p.x)return false;\n\t\tif (y < p.y)return true;\n\t\tif (y > p.y)return false;\n\t\tif (z < p.z)return true;\n\t\treturn false;\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y) && equals(z, p.z); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y + z*z; }\n\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y << \" \" << p.z; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y, z; is >> x >> y >> z; p = Point(x, y, z); return is; }\n\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\nusing Line = Segment;\n\n//???\nclass Sphere {\npublic:\n\tPoint c;\n\tdouble r;\n\tint w;\n\tSphere(Point c = Point(), double r = 1.0) :c(c), r(r) {};\n};\n\n//http://www.math.s.chiba-u.ac.jp/~yasuda/Chiba/Lec/naiseki.pdf\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n//?????? cross product\nVector cross(Vector a, Vector b) {\n\tVector ret;\n\tret.x = a.y*b.z - a.z*b.y;\n\tret.y = a.z*b.x - a.x*b.z;\n\tret.z = a.x*b.y - a.y*b.x;\n\treturn ret;\n}\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//http://www.sousakuba.com/Programming/gs_dot_line_distance.html\n//??´?????¨???????????¢\ndouble get_distance_LP(Line l, Point p) { return cross(l.p2 - l.p1, p - l.p1).abs() / (l.p2 - l.p1).abs(); }\n//????????¨???????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return get_distance(p, s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return get_distance(p, s.p2);\n\treturn get_distance_LP(s, p);\n}\n\n//?????¨?????????????????????\nbool intersect(Sphere SP, Segment S) {\n\treturn SP.r + EPS >= get_distance_SP(S, SP.c);\n}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Sphere SP, Line L) {\n\tassert(intersect(SP, L));\n\tVector pr = project(L, SP.c);\n\tVector e = (L.p2 - L.p1) / (L.p2 - L.p1).abs();\n\tdouble base = sqrt(SP.r*SP.r - (pr - SP.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\nsigned main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<Sphere> Spheres(N);\n\trep(i, 0, N)cin >> Spheres[i].c >> Spheres[i].r >> Spheres[i].w;\n\trep(i, 0, Q) {\n\t\tPoint s, d; cin >> s >> d;\n\t\tSegment S = Segment(s, d);\n\t\tvector<pair<Point, int>> I;\n\t\tfor (Sphere &SP : Spheres) {\n\t\t\tif (intersect(SP, S)) {\n\t\t\t\tauto points = get_cross_points(SP, S);\n\t\t\t\tif (get_distance(points.first, s) < get_distance(points.second, s))\n\t\t\t\t\tI.emplace_back(make_pair(points.first, SP.w));\n\t\t\t\telse\n\t\t\t\t\tI.emplace_back(make_pair(points.second, SP.w));\n\t\t\t}\n\t\t}\n\t\tsort(all(I));\n\t\tint ans = 0;\n\t\trep(j, 0, I.size()) {\n\t\t\tans += I[j].second;\n\t\t}\n\t\trep(j, 1, I.size()) {\n\t\t\tif (I[j].first == I[j - 1].first)ans -= min(I[j].second, I[j - 1].second);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N,Q;\nint x[111],y[111],z[111],r[111],l[111];\n\nconst double EPS=1e-9;\ndouble get(int i,double xx,double yy,double zz){\n    return sqrt((x[i]-xx)*(x[i]-xx)+(y[i]-yy)*(y[i]-yy)+(z[i]-zz)*(z[i]-zz));\n}\n\nvoid solve(){\n    int xx,yy,zz,xxx,yyy,zzz;\n    cin>>xx>>yy>>zz>>xxx>>yyy>>zzz;\n\n    int cost=0;\n    rep(i,N){\n        double lb=0,ub=1;\n        rep(loop,100){\n            double mid1=(lb*2+ub)/3,mid2=(lb+ub*2)/3;\n            double d1=get(i,xx+(xxx-xx)*mid1,yy+(yyy-yy)*mid1,zz+(zzz-zz)*mid1);\n            double d2=get(i,xx+(xxx-xx)*mid2,yy+(yyy-yy)*mid2,zz+(zzz-zz)*mid2);\n            if(d1>d2)lb=mid1;\n            else ub=mid2;\n        }\n        double d=get(i,xx+(xxx-xx)*lb,yy+(yyy-yy)*lb,zz+(zzz-zz)*lb);\n        if(d<r[i]+EPS)cost+=l[i];\n    }\n    cout<<cost<<endl;\n}\n\nsigned main(){\n    cin>>N>>Q;\n    rep(i,N)cin>>x[i]>>y[i]>>z[i]>>r[i]>>l[i];\n    while(Q--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2641.cc: Magic Bullet\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 50;\n\n/* typedef */\n\ntypedef long long ll;\n\ntemplate <typename T>\nstruct Pt3d {\n  T x, y, z;\n\n  Pt3d() {}\n  Pt3d(T _x, T _y, T _z) : x(_x), y(_y), z(_z) {}\n  Pt3d(const Pt3d& pt) : x(pt.x), y(pt.y), z(pt.z) {}\n\n  Pt3d<T> operator+(const Pt3d pt) const {\n    return Pt3d<T>(x + pt.x, y + pt.y, z + pt.z);\n  }\n  Pt3d<T> operator-() const {\n    return Pt3d<T>(-x, -y, -z);\n  }\n  Pt3d<T> operator-(const Pt3d pt) const {\n    return Pt3d<T>(x - pt.x, y - pt.y, z - pt.z);\n  }\n  T dot(Pt3d v) const { return x * v.x + y * v.y + z * v.z; }\n  Pt3d<T> cross(Pt3d v) const {\n    return Pt3d<T>(y * v.z - z * v.y, z * v.x - x * v.z, x * v.y - y * v.x);\n  }\n  T d2() { return x * x + y * y + z * z; }\n  double d() { return sqrt(d2()); }\n\n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \", \" + format + \")\").c_str(),\n           x, y, z);\n  }\n  void print() { print(\"%.6lf\"); }\n};\n\ntypedef Pt3d<double> pt3d;\n\n/* global variables */\n\npt3d cps[MAX_N];\ndouble rs[MAX_N];\nll ls[MAX_N];\n\n/* subroutines */\n\ndouble dist_p_seg(pt3d &s0, pt3d &s1, pt3d &p) {\n  pt3d v = s1 - s0, p0 = p - s0, p1 = p - s1;\n  double d0 = v.dot(p0), d1 = v.dot(p1);\n\n  if (d0 <= 0.0) return p0.d();\n  if (d1 >= 0.0) return p1.d();\n  return sqrt(p0.d2() - d0 * d0 / v.d2());\n}\n\n/* main */\n\nint main() {\n  int n, qn;\n  cin >> n >> qn;\n\n  for (int i = 0; i < n; i++)\n    cin >> cps[i].x >> cps[i].y >> cps[i].z >> rs[i] >> ls[i];\n\n  while (qn--) {\n    pt3d sp, gp;\n    cin >> sp.x >> sp.y >> sp.z >> gp.x >> gp.y >> gp.z;\n\n    ll sum = 0;\n    for (int i = 0; i < n; i++) {\n      double d = dist_p_seg(sp, gp, cps[i]);\n      if (d <= rs[i]) sum += ls[i];\n      if (false) {\n\tsp.print(); putchar('-'); gp.print(); printf(\" : \"); cps[i].print();\n\tprintf(\" = %lf\\n\", d);\n      }\n    }\n    printf(\"%lld\\n\", sum);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????D???long D?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD abs(D x, D y, D z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nD dot(D a1, D a2, D a3, D b1, D b2, D b3){\n    return a1*b1 + a2*b2 + a3*b3;\n}\n\nD cross(D a1, D a2, D a3, D b1, D b2, D b3){\n    D i = a2*b3 - a3*b2;\n    D j = a3*b1 - a1*b3;\n    D k = a1*b2 - a2*b1;\n    return abs(i, j, k);\n}\n\nD distLP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    return abs(cross(px-sx, py-sy, pz-sz, dx-sx, dy-sy, dz-sz))/abs(dx-sx, dy-sy, dz-sz);\n}\n\nD distSP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    if(LE(dot(dx-sx, dy-sy, dz-sz, px-sx, py-sy, pz-sz), 0))\n        return abs(px-sx, py-sy, pz-sz);\n    if(LE(dot(sx-dx, sy-dy, sz-dz, px-dx, py-dy, pz-dz), 0))\n        return abs(px-dx, py-dy, pz-dz);\n    return distLP(sx, sy, sz, dx, dy, dz, px, py, pz);\n}\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    int l;\n    \n    Circle(D x, D y, D z, D r, int l): x(x), y(y), z(z), r(r), l(l){};\n    \n    bool intersect(D sx, D sy, D sz, D dx, D dy, D dz){\n        return LE(distSP(sx, sy, sz, dx, dy, dz, x, y, z), r);\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    int N, Q;\n    cin >> N >> Q;\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r;\n        int l;\n        cin >> x >> y >> z >> r >> l;\n        circles.push_back({x, y, z, r, l});\n    }\n    \n    while(Q--){\n        int ans = 0;\n        D sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        for(Circle &circle: circles){\n            if(circle.intersect(sx, sy, sz, dx, dy, dz))\n                ans += circle.l;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst double mEPS = 1e-10;\n\n//???????????????????????????\nclass Point{\npublic:\n  double x, y, z;\n\n  Point(double x = 0.0, double y = 0.0, double z = 0.0) : x(x), y(y),z(z){}\n\n  Point operator + (Point p){ return Point(x + p.x, y + p.y, z+p.z); }\n  Point operator - (Point p){ return Point(x - p.x, y - p.y, z-p.z); }\n  Point operator * (double a){ return Point(a*x, a*y, a*z); }\n  Point operator / (double a){ return Point(x / a, y / a, z/a); }\n\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y + z*z; }\n\n  //EPS??????????°??????????\n  bool operator == (const Point &p) const {\n\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n  }\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n};\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble cross(Vector a, Vector b){\n  Point p(a.y*b.z-b.y*a.z, a.z*b.x-b.z*a.x, a.x*b.y-b.x*a.y);\n  return p.abs();\n\t//  return a.x*b.y - a.y*b.x;\n}\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s, Point p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q; cin >> N >> Q;\n  vector<Point> ps(N);\n  vector<LL> rs(N), ls(N);\n  REP(i,N) cin >> ps[i].x >> ps[i].y >> ps[i].z >> rs[i] >> ls[i];\n\n  REP(i,Q){\n\tLL ans = 0;\n\tint sx, sy, sz, dx, dy, dz;\n\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\tSegment s;\n\ts.p1 = Point(sx,sy,sz);\n\ts.p2 = Point(dx,dy,dz);\n\tREP(i,N){\n\t  if(getDistanceSP(s, ps[i]) <= rs[i]) ans += ls[i];\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N,Q; cin >> N >> Q;\n    vector<double> x(N),y(N),z(N),r(N);\n    vector<ll> l(N);\n    for(int i = 0; i < N;i++){\n        cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n    }\n    \n    for(int i = 0; i < Q;i++){\n        double sx,sy,sz,dx,dy,dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        dx -= sx; dy -= sy; dz -= sz;\n        \n        ll ans = 0;\n        for(int j = 0; j < N;j++){\n            double Dx = sx - x[j], Dy = sy - y[j], Dz = sz - z[j];\n\n            double DD = dx*dx + dy*dy + dz*dz;\n            \n            double t = -(Dx * dx + Dy * dy + Dz * dz)/DD;\n            if(t < 0 || t > 1 + 1e-9) continue;\n            \n            double nx = sx + t*dx,ny = sy + t*dy,nz = sz + t*dz;\n            double ddx = nx - x[j],ddy = ny - y[j],ddz = nz - z[j];\n\n            \n            double R2 = ddx * ddx + ddy * ddy + ddz * ddz;\n            if(R2 < r[j]*r[j] + 1e-9)  ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Vertex\n{\n  double x, y, z;\n  Vertex(){}\n  Vertex(double a, double b, double c){\n    x = a; y = b; z = c;\n  }\n};\n\n#define Vector Vertex\n\ndouble distanc(Vertex p1, Vertex p2)\n{\n  return pow(SQ(p2.x-p1.x) + SQ(p2.y-p1.y) + SQ(p2.z-p1.z), 0.5);\n}\n\ndouble length(Vector v)\n{\n  return pow(SQ(v.x) + SQ(v.y) + SQ(v.z), 0.5);\n}\n\nVector cross(Vector vl, Vector vr)\n{\n  return Vector(vl.y*vr.z - vl.z*vr.y, vl.z*vr.x - vl.x*vr.z, vl.x*vr.y - vl.y*vr.x);\n}\n\ndouble dis(Vertex p, Vertex a, Vertex b)\n{\n  Vector ab(b.x-a.x, b.y-a.y, b.z-a.z);\n  Vector ap(p.x-a.x, p.y-a.y, p.z-a.z);\n  double d = length(cross(ab, ap));\n  double l = distanc(a, b);\n  double h = d / l;\n  return h;\n}\n\nint main()\n{\n  int N, Q;\n  Vertex jm[64];\n  int r[64];\n  ll l[64];\n\n  cin >> N >> Q;\n  rep(i, N){\n    int x, y, z;\n    cin >> x >> y >> z >> r[i] >> l[i];\n    Vertex tmp(x,y,z);\n    jm[i] = tmp;\n  }\n\n  rep(i, Q){\n    ll res = 0;    \n    int x, y, z;\n    cin >> x >> y >> z;\n    Vertex a(x, y, z);\n    cin >> x >> y >> z;\n    Vertex b(x, y, z);\n    rep(j, N){\n      //      cout << dis(jm[j], a, b) << endl;\n      if(r[j] >= dis(jm[j], a, b)) res += l[j];\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Last Change: 11/14/2019 20:22:34.\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\nconst double EPS = 1e-6;\n\nstruct Point {\n  double x, y, z;\n  Point() : x(0), y(0), z(0) {\n  }\n  Point(double a, double b, double c) : x(a), y(b), z(c) {\n  }\n\n  Point operator+(const Point &o) const {\n    return Point(x + o.x, y + o.y, z + o.z);\n  }\n  Point operator-(const Point &o) const {\n    return Point(x - o.x, y - o.y, z - o.z);\n  }\n  Point operator*(const double &o) const {\n    return Point(x * o, y * o, z * o);\n  }\n};\n\ndouble dot(const Point &a, const Point &b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nstruct Line {\n  Point red, blue;\n  Line() : red(Point(0, 0, 0)), blue(Point(0, 0, 0)) {\n  }\n  Line(Point a, Point b) : red(a), blue(b) {\n  }\n};\n\nPoint project(const Line &a, const Point &p) {\n  Point base = a.blue - a.red;\n  double t = dot(base, p - a.red) / dot(base, base);\n  return a.red + base * t;\n}\n\ndouble norm(const Point &a, const Point &b) {\n  Point temp = b - a;\n  return dot(temp, temp);\n}\n\ndouble abs(const Point &a, const Point &b) {\n  return sqrt(norm(a, b));\n}\n\nstruct Obstacle {\n  Point pos;\n  ll r, l;\n  Obstacle() : pos(Point(0, 0, 0)), r(0), l(0) {\n  }\n\n  bool isCross(const Line &a) {\n    Point proj = project(a, pos);\n    if (norm(a.red, proj) > norm(a.red, a.blue)\n        or norm(a.red, a.blue) <= norm(proj, a.blue)) {\n      return false;\n    }\n    double dist = sqrt(norm(pos, proj));\n    if (r - dist >= -EPS) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n\nint main() {\n  ll N, Q;\n  cin >> N >> Q;\n\n  vector<Obstacle> O(N);\n  vector<Line> L(Q);\n  for (auto &&e : O) {\n    cin >> e.pos.x >> e.pos.y >> e.pos.z >> e.r >> e.l;\n  }\n  for (auto &&e : L) {\n    cin >> e.red.x >> e.red.y >> e.red.z >> e.blue.x >> e.blue.y >> e.blue.z;\n  }\n\n  for (auto &&e : L) {\n    ll res = 0;\n    for (auto &&f : O) {\n      if (f.isCross(e)) {\n        res += f.l;\n      }\n    }\n    cout << res << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nconst double tol = 1e-8;\n\ntemplate <class T>\nstruct Point {\n    T x, y, z;\n    Point(T x_, T y_, T z_) : x(x_), y(y_), z(z_) {}\n    Point& operator-=(const Point& other) { x -= other.x; y -= other.y; z -= other.z; return *this; }\n};\n\ntemplate <class T>\ninline Point<T> operator-(const Point<T>& lhs, const Point<T>& rhs) { Point<T> t(lhs); return t -= rhs; }\n\ntemplate <class T>\ninline T hypot(const Point<T>& p) { return sqrt(p.x * p.x + p.y * p.y + p.z * p.z); }\n\ntemplate <class T>\ninline T cross(const Point<T>& a, const Point<T>& b) {\n    return hypot(Point<T>(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x));\n}\n\ntemplate <class T>\nstruct Line : vector<Point<T>> {\n    Line(const Point<T>& a, const Point<T>& b) : vector<Point<T>>{a, b} {}\n    T length() const { return hypot((*this)[1] - (*this)[0]); }\n};\n\ntemplate <class T>\nstruct Segment : Line<T> {\n    Segment(const Point<T>& a, const Point<T>& b) : Line<T>(a, b) {}\n};\n\ntemplate <class T>\nstruct Sphere : Point<T> {\n    T r, l;\n    Sphere(T x_, T y_, T z_, T r_, T l_) : Point<T>(x_, y_, z_), r(r_), l(l_) {}\n};\n\ntemplate <class T>\ninline T distance(const Point<T>& p, const Segment<T>& ls) {\n    return cross(p - ls[0], ls[1] - ls[0]) / ls.length();\n}\n\ntemplate <class T>\ninline bool intersect(const Sphere<T>& sh, const Segment<T>& ls) {\n    return distance(Point<T>(sh), ls) <= sh.r + tol;\n}\n\nint main() {\n    int N, Q; cin >> N >> Q;\n    vector<Sphere<double>> balloon;\n    rep(i, N) {\n        int x, y, z, r, l; cin >> x >> y >> z >> r >> l;\n        balloon.emplace_back(x, y, z, r, l);\n    }\n    while (Q--) {\n        int sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        Segment<double> fire(Point<double>(sx, sy, sz), Point<double>(dx, dy, dz));\n        cout << accumulate(all(balloon), 0, [&](int x, const Sphere<double>& s) {\n            return x + (intersect(s, fire) ? s.l : 0);\n        }) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// #define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl\n#define STOP assert(false)\n#else\n#define dump(x) ;\n#define LINE     ;\n#define dumpV(v);\n#define STOP     ;\n#endif\n#define mp make_pair\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n \ntypedef double D;\nnamespace std {\n    const D EPS = 1e-10;\n    using P = valarray<D>;\n    const P Origin = {(D)0.0, (D)0.0, (D)0.0};\n    #define x(P) (P)[0]\n    #define y(P) (P)[1]\n    #define z(P) (P)[2]\n    #define SQ(Q) ((Q)*(Q))\n\n    bool operator < (const P& a, const P& b) {\n        if(x(a) != x(b)) return x(a) < x(b);\n        if(y(a) != y(b)) return y(a) < y(b);\n        return z(a) < z(b);\n    }\n}\n\n\nstruct L : array<P, 2> {\n    L() {at(0) = at(1) = Origin;}\n    L(const P& a, const P& b) {\n        at(0) = a;\n        at(1) = b;\n    }\n};\nD dot(const P& a, const P& b) {\n    auto p = a*b;\n    return p.sum();\n}\nP cross(const P& a, const P& b) {\n    P ret(3);\n    x(ret) = y(a) * z(b) - y(b) * z(a);\n    y(ret) = z(a) * x(b) - z(b) * x(a);\n    z(ret) = x(a) * y(b) - x(b) * y(a);\n    return ret;\n}\nD norm(const P& p) {\n    return sqrt(dot(p, p));\n}\nbool isHitLP(const L&l ,const P& p) {\n    P v = l[1] - l[0], v1 = p - l[0];\n    return abs(norm(cross(v, v1))) < EPS;\n}\nbool isHitSP(const L& l, const P& p) {\n    P v = l[1] - l[0], v1 = p - l[0];\n    P u = l[0] - l[1], u1 = p - l[1];\n    return abs(norm(cross(v, v1))) < EPS && norm(v1) < norm(v) + EPS\n            && abs(norm(cross(u, u1))) < EPS && norm(u1) < norm(u) + EPS; \n}\nD distLP(const L& l, const P& p) {\n    if(isHitLP(l, p)) return (D)0.0;\n    P AB = l[1] - l[0];\n    P AP = p - l[0];\n    if(abs(norm(AB)) < EPS) return norm(AP);\n    return norm(cross(AB, AP)) / norm(AB);\n}\nD distSP(const L& l, const P& p) {\n    if(isHitSP(l, p)) return (D)0.0;\n    return min({norm(p - l[0]), norm(p - l[1]), distLP(l, p)});\n}\nstruct C{\n    P p;\n    D r;\n};\nbool isHitPC(const P& p, const C& c) {\n    return norm(p - c.p) < c.r + EPS;\n}\nvector<P> crossPointLC(const L&l ,const C& cir) {\n    P s = l[0] - cir.p;\n    P d = l[1] - l[0];\n    auto A = dot(d, d), B = dot(d, s), C = dot(s, s) - SQ(cir.r);\n    auto DD = (SQ(B) - A * C);\n    vector<D> t;\n    if(abs(DD) < 0) t.pb(B / A);\n    else if(DD < 0) ;\n    else {\n        t.pb((-B + sqrt(DD)) / A);\n        t.pb((-B - sqrt(DD)) / A);\n    }\n    vector<P> ret;\n    rep(i, t.size()) ret.push_back(s + d * t[i]);\n    rep(i, ret.size()) ret[i] += cir.p;\n    return ret;\n}\nvector<P> crossPointSC(const L&l ,const C& c) {\n    vector<P> ps = crossPointLC(l, c);\n    sort(all(ps));\n    auto it = ps.begin();\n    while(it != ps.end()) {\n        assert(abs(norm(*it - c.p) - c.r) < EPS);\n        if(isHitSP(l, *it)) ++it;\n        else it = ps.erase(it);\n    }\n    return ps;\n}\nbool isHitLC(const L& l, const C& c) {\n    return distLP(l, c.p) < c.r + EPS;\n}\nbool isHitSC(const L& l, const C& c) {\n    // if(!isHitLC(l, c)) return false;\n    return crossPointSC(l, c).size() > 0;\n}\n\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    vector<C> cs(n);\n    vector<ll> costs(n);\n    LINE;\n    rep(i, n) {\n        D x, y, z, r;\n        cin >> x >> y >> z >> r >> costs[i];\n        cs[i] = {P{x, y, z}, r};\n    }\n    LINE;\n    auto calc = [&](const P& a, const P& b) {\n        ll ret = 0LL;\n        rep(i, n) {\n            L l(a, b);\n            if(isHitSC(l, cs[i])) {\n                dump(i);\n                dump(distSP(l, cs[i].p));\n                auto ps = crossPointSC(l, cs[i]);\n                dump(ps.size());\n                for(auto& p : ps) {\n                    dumpV(p);\n                }\n                auto ps2 = crossPointLC(l, cs[i]);\n                dump(ps2.size());\n                for(auto& p : ps2) {\n                    dumpV(p);\n                }\n                ret += costs[i];\n            }\n        }\n        return ret;\n    };\n    rep(i, q) {\n        D x, y, z;\n        cin >> x >> y >> z;\n        P s = {x, y, z};\n        cin >> x >> y >> z;\n        P t = {x, y, z};\n        cout << calc(s, t) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct pos3 {\n\tdouble x;\n\tdouble y;\n\tdouble z;\n};\nstruct jama {\n\tpos3 p;\n\tdouble r;\n\tint cost;\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tvector<jama> jamas(n);\n\tREP(i, n)\n\t\tcin >> jamas[i].p.x >> jamas[i].p.y >> jamas[i].p.z >> jamas[i].r >> jamas[i].cost;\n\tvector<pair<pos3, pos3>> ray(q);\n\tREP(i, q)\n\t\tcin >> ray[i].first.x >> ray[i].first.y >> ray[i].first.z >> ray[i].second.x >> ray[i].second.y >> ray[i].second.z;\n\tREP(i, q) {\n\t\tint cost = 0;\n\t\tdouble tx = -(ray[i].first.x - ray[i].second.x);\n\t\tdouble ty = -(ray[i].first.y - ray[i].second.y);\n\t\tdouble tz = -(ray[i].first.z - ray[i].second.z);\n\t\tdouble t = tx*tx +\n\t\t\tty*ty +\n\t\t\ttz*tz;\n\t\tREP(j, n) {\n\t\t\tdouble sx = (ray[i].first.x - jamas[j].p.x);\n\t\t\tdouble sy = (ray[i].first.y - jamas[j].p.y);\n\t\t\tdouble sz = (ray[i].first.z - jamas[j].p.z);\n\t\t\tdouble ts = (tx*sx + ty*sy + tz*sz);\n\t\t\tdouble p = -ts / t;\n\t\t\tdouble Px = ray[i].first.x + p*tx;\n\t\t\tdouble Py = ray[i].first.y + p*ty;\n\t\t\tdouble Pz = ray[i].first.z + p*tz;\n\t\t\tif ((Px - jamas[j].p.x)*(Px - jamas[j].p.x) +\n\t\t\t\t(Py - jamas[j].p.y)*(Py - jamas[j].p.y) +\n\t\t\t\t(Pz - jamas[j].p.z)*(Pz - jamas[j].p.z) <=\n\t\t\t\tjamas[j].r*jamas[j].r)\n\t\t\t\tcost += jamas[j].cost;\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\n\nstruct obs {\n  double x, y, z, r;\n  long long l;\n};\nstruct obj {\n  double sx, sy, sz, dx, dy, dz;\n};\nlong long n, q;\nvector<obs> lst;\n\nlong long solve(obj now);\nbool ch(obs nows, obj nowj);\ndouble mypow(double x);\ndouble nrm(double x, double y, double z);\n\nint main() {\n  cin >> n >> q;\n  lst.resize(n);\n  for(int i = 0; i < n; ++i)\n    cin >> lst[i].x >> lst[i].y >> lst[i].z >> lst[i].r >>\n        lst[i].l;\n  for(int i = 0; i < q; ++i) {\n    obj now;\n    cin >> now.sx >> now.sy >> now.sz >> now.dx >> now.dy >>\n        now.dz;\n    cout << solve(now) << endl;\n  }\n  return 0;\n}\n\nlong long solve(obj now) {\n  long long ans = 0;\n  for(int i = 0; i < n; ++i)\n    if(ch(lst[i], now)) ans += lst[i].l;\n  return ans;\n}\n\nbool ch(obs nows, obj nowj) {\n  double disa, disb, disc;\n  disa = mypow(nowj.dx - nowj.sx) +\n         mypow(nowj.dy - nowj.sy) +\n         mypow(nowj.dz - nowj.sz);\n  disb = mypow(nowj.dx - nows.x) + mypow(nowj.dy - nows.y) +\n         mypow(nowj.dz - nows.z);\n  disc = mypow(nowj.sx - nows.x) + mypow(nowj.sy - nows.y) +\n         mypow(nowj.sz - nows.z);\n  if(disc + disa - disb < 0 || disa + disb - disc < 0) {\n    return nows.r - min(sqrtl(disb), sqrtl(disc)) >= -eps;\n  }\n  double chilx, chily, chilz, dmom, dchil;\n  dmom = nrm(nowj.dx - nowj.sx, nowj.dy - nowj.sy,\n             nowj.dz - nowj.sz);\n  chilx = (nows.y - nowj.sy) * (nowj.dz - nowj.sz) -\n          (nows.z - nowj.sz) * (nowj.dy - nowj.sy);\n  chily = (nows.z - nowj.sz) * (nowj.dx - nowj.sx) -\n          (nows.x - nowj.sx) * (nowj.dz - nowj.sz);\n  chilz = (nows.x - nowj.sx) * (nowj.dy - nowj.sy) -\n          (nows.y - nowj.sy) * (nowj.dx - nowj.sx);\n  dchil = nrm(chilx, chily, chilz);\n  return nows.r - dchil / dmom >= -eps;\n}\n\ndouble mypow(double x) { return x * x; }\n\ndouble nrm(double x, double y, double z) {\n  return sqrtl(mypow(x) + mypow(y) + mypow(z));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 50\nusing namespace std;\ntypedef struct circle{\n  int x,y,z,r;\n  long long l;\n} Circle;\ntypedef struct point{\n  int x,y,z;\n} Point;\n \nint main(){\n  int n,q;\n  double d;\n  Point blue,red;\n  Circle c[N];\n  cin>>n>>q;\n  for(int i=0;i<n;i++) cin>>c[i].x>>c[i].y>>c[i].z>>c[i].r>>c[i].l;\n  while(q--){\n    cin>>red.x>>red.y>>red.z>>blue.x>>blue.y>>blue.z;\n    long long sum=0;\n    for(int i=0;i<n;i++){\n      int x=c[i].x-red.x,y=c[i].y-red.y,z=c[i].z-red.z;\n      int x2=blue.x-red.x,y2=blue.y-red.y,z2=blue.z-red.z;\n      int x3=c[i].x-blue.x,y3=c[i].y-blue.y,z3=c[i].z-blue.z;\n      int t=x2*x2+y2*y2+z2*z2+x*x+y*y+z*z-(x3*x3+y3*y3+z3*z3);\n      int b_c=x*x2+y*y2+z*z2;\n      int a_c=(-x2)*x3+(-y2)*y3+(-z2)*z3;\n      d=x*x+y*y+z*z-(1.0*t*t)/(x2*x2+y2*y2+z2*z2)/4;\n      if(min(b_c,a_c)<0) d=min(x*x+y*y+z*z,x3*x3+y3*y3+z3*z3);\n      if(d<=c[i].r*c[i].r) sum+=c[i].l;\n    }\n    cout<<sum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\ndouble f(double sx, double sy, double sz, double gx, double gy, double gz){\n    return sqrt((sx-gx)*(sx-gx)+(sy-gy)*(sy-gy)+(sz-gz)*(sz-gz));\n}\n\ndouble g(double p, double q, double m, double n){\n    return (n*p+m*q)/(m+n);\n}\n\n\nint main(void) {\n    int i,j;\n    int n,q;\n    cin >> n >> q;\n    vector<double> x(n),y(n),z(n);\n    vector<ll> r(n),l(n);\n    rep(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n    rep(k,q){\n        ll ans = 0;\n        double sx,sy,sz,gx,gy,gz;\n        cin >> sx >> sy >> sz >> gx >> gy >> gz;\n        double dis = f(sx,sy,sz,gx,gy,gz);\n        rep(i,n){\n            double lb = 0, ub = dis;\n            rep(j,100){\n                double m1 = (lb+lb+ub)/3.0;\n                double m2 = (lb+ub+ub)/3.0;\n                double px1 = g(sx,gx,m1,dis-m1);\n                double py1 = g(sy,gy,m1,dis-m1);\n                double pz1 = g(sz,gz,m1,dis-m1);\n                double len1 = f(px1,py1,pz1,x[i],y[i],z[i]);\n                double px2 = g(sx,gx,m2,dis-m2);\n                double py2 = g(sy,gy,m2,dis-m2);\n                double pz2 = g(sz,gz,m2,dis-m2);\n                double len2 = f(px2,py2,pz2,x[i],y[i],z[i]);\n                if(len1 < len2)ub = m2;\n                else lb = m1;\n            }\n            double px = g(sx,gx,lb,dis-ub);\n            double py = g(sy,gy,lb,dis-ub);\n            double pz = g(sz,gz,lb,dis-ub);\n            double len = f(px,py,pz,x[i],y[i],z[i]);\n            //cout << shosu(10) << dis << \" \" << lb << \" \" << len << endl;\n            if(len <= r[i] + EPS) ans += l[i];\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst long double PI = acos(-1.0L);\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nusing DD = double; // 精度が足りないときはlong double\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point {\n    DD x, y, z;\n    Point (DD x = 0, DD y = 0, DD z = 0): x(x), y(y), z(z) {}\n\n    Point& operator+=(const Point &p) { x += p.x; y += p.y; z += p.z; return *this;}\n    Point operator+(const Point &p) const { return Point(*this) += p;}\n    Point& operator-=(const Point &p) { x -= p.x; y -= p.y; z -= p.z; return *this;}\n    Point operator-(const Point &p) const { return Point(*this) -= p;}\n    Point& operator*=(DD a) { x *= a; y *= a; z *= a; return *this;}\n    Point operator*(DD a) const { return Point(*this) *= a;}\n    Point& operator/=(DD a) { x /= a; y /= a; z /= a; return *this;}\n    Point operator/(DD a) const { return Point(*this) /= a;}\n    bool operator== (const Point &p) const { return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;}\n    friend istream& operator >>(istream& is, Point& p) { is >> p.x >> p.y >> p.z; return is;}\n    friend ostream& operator <<(ostream& os, const Point& p) { os<< p.x <<\" \"<< p.y << \" \" << p.z; return os;}\n};\n\ntypedef Point Vector;\ninline DD norm(const Vector &a) { return a.x * a.x + a.y * a.y + a.z * a.z;}\ninline DD abs(const Vector &a) { return sqrt(norm(a));}\ninline DD dot(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y + a.z * b.z;}\ninline DD cross(const Vector &a, const Vector &b) { return 0.5 * sqrt(norm(a)*norm(b) - dot(a,b)*dot(a,b));}\n\nstruct Segment {\n    Point p1,p2;\n    Segment() = default;\n    Segment(Point p1, Point p2) : p1(p1),p2(p2) {}\n};\n\ntypedef Segment Line;\n\nPoint project(const Segment &s, const Point &p) {\n    Vector base = s.p2 - s.p1;\n    DD r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\ninline DD getDistanceLP(const Line &l, const Point &p) { return abs(project(l,p) - p);}\nDD getDistanceSP(const Segment &s, const Point &p) {\n    if (dot(s.p2 - s.p1,p - s.p1) < 0.0) return abs(p - s.p1);\n    if (dot(s.p1 - s.p2,p - s.p2) < 0.0) return abs(p - s.p2);\n    return getDistanceLP(s, p);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,Q; cin >> N >> Q;\n    vector<Point> A(N);\n    vector<ll> r(N),l(N);\n    rep(i,N) cin >> A[i] >> r[i] >> l[i];\n\n    rep(i,Q) {\n        Point s,t; cin >> s >> t;\n        Segment S = {s,t};\n        ll ans = 0;\n        rep(j,N) {\n            if (r[j] > getDistanceSP(S,A[j]) - EPS) ans += l[j];\n        }\n        cout << ans << ln;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//3次元\nstruct Point{\n\tPoint(double arg_x,double arg_y,double arg_z){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tz = arg_z;\n\t}\n\n\tPoint(){\n\t\tx = y = z = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y,z+p.z); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n\tPoint operator * (double a){ return Point(a*x,a*y,a*z); }\n\tPoint operator / (double a){ return Point(x/a,y/a,z/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y + z*z; }\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS && fabs(z-p.z) < EPS;\n\t}\n\tdouble x,y,z;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nstruct Info{\n\tPoint center;\n\tdouble r;\n\tint value;\n};\n\nint N,Q;\nInfo info[50];\n\n//3次元\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y+a.z*b.z;\n}\n\n//垂線が引ける場合、交点を求める\nPoint projection(Line line,Point point){\n    double t = dot(point-line.p[0],line.p[0]-line.p[1])/norm(line.p[0]-line.p[1]);\n    return line.p[0] + (line.p[0]-line.p[1])*t;\n}\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nbool intersect(Line line,int index){\n\n\tdouble dist_1 = calc_dist(line.p[0],info[index].center);\n\tdouble dist_2 = calc_dist(line.p[1],info[index].center);\n\n\t//方向ベクトル\n\tdouble Vx = line.p[1].x-line.p[0].x;\n\tdouble Vy = line.p[1].y-line.p[0].y;\n\tdouble Vz = line.p[1].z-line.p[0].z;\n\n\t//Oを原点,点Aをline.p[0]としたとき、点info[inde]から下した垂線との交点が、(line.p[0].x+t*Vx,line.p[0].y+t*Vy,line.p[0].z+t*Vz)と表されるようなt\n\tdouble t = (Vx*(info[index].center.x-line.p[0].x)+Vy*(info[index].center.y-line.p[0].y)+Vz*(info[index].center.z-line.p[0].z))/(Vx*Vx+Vy*Vy+Vz*Vz);\n\n\tif(t < 0 || t > 1){ //垂線が、観測点と光源を結ぶ線分上にない場合→最近地点は、観測点か光源のどちらか\n\t\tif(dist_1 > info[index].r && dist_2 > info[index].r){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdouble cross_x = line.p[0].x+t*Vx;\n\tdouble cross_y = line.p[0].y+t*Vy;\n\tdouble cross_z = line.p[0].z+t*Vz;\n\n\tdouble dist = sqrt((info[index].center.x-cross_x)*(info[index].center.x-cross_x)\n\t\t\t+(info[index].center.y-cross_y)*(info[index].center.y-cross_y)\n\t\t\t+(info[index].center.z-cross_z)*(info[index].center.z-cross_z)\n\t\t);\n\n\treturn dist <= info[index].r;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&Q);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %lf %d\",&info[i].center.x,&info[i].center.y,&info[i].center.z,&info[i].r,&info[i].value);\n\t}\n\n\tPoint a,b;\n\tint ans;\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf\",&a.x,&a.y,&a.z,&b.x,&b.y,&b.z);\n\t\tans = 0;\n\t\tLine line(a,b);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(intersect(line,i))ans += info[i].value;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r;\n  ull l;\n};\ntypedef Point Vector;\null check(ball ba,Point x,Point y){\n  ull z=0;\n  Vector v=y-x,c=ba.p-x;\n  if(dot(v,c)<=0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  \n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    Point p,b;\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ull o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\n\n#define in(x) (0 <= x && x <= 1)\n\nstruct Point{\n    double x, y, z;\n    Point(double x, double y, double z) : x(x),y(y),z(z) {}\n    double norm(){\n        return x*x+y*y+z*z;\n    }\n    Point operator* (double d){\n        return Point{x*d, y*d, z*d};\n    }\n    Point operator- (const Point& other){\n        return Point{x-other.x, y-other.y, z-other.z};\n    }\n    double cross(const Point& other){\n        return x*other.x+y*other.y+z*other.z;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    vector<Point> vp;\n    vector<double> vr;\n    vector<ll> vs;\n    for(int i = 0; i < n; i++){\n        double x, y, z, r;\n        ll l;\n        cin >> x >> y >> z >> r >> l;\n        vp.push_back(Point{x,y,z});\n        vr.push_back(r);\n        vs.push_back(l);\n    }\n    while(q-- > 0){\n        double sx, sy, sz, tx, ty, tz;\n        cin >> sx >> sy >> sz >> tx >> ty >> tz;\n        Point P{sx,sy,sz}, Q{tx,ty,tz};\n        Point D = Q-P;\n        double a = D.norm();\n        ll ans = 0;\n        for(int i = 0; i < n; i++){\n            double b = 2*P.cross(D)-2*D.cross(vp[i]);\n            double c = P.norm()+vp[i].norm()-2*P.cross(vp[i])-vr[i]*vr[i];\n            if(b*b-4*a*c < 0)  continue;\n            if(in((-b+sqrt(b*b-4*a*c))/2/a) || in((-b-sqrt(b*b-4*a*c))/2/a))    ans += vs[i];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nstruct Point { double x, y, z; };\nstruct Line { Point p, q; };\n\nint N, Q;\nll R[50], L[50];\nPoint P[50];\nLine C[50];\n\ndouble distance(Line l, Point p) {\n  double x0 = p.x, y0 = p.y, z0 = p.z;\n  double x1 = l.p.x, y1 = l.p.y, z1 = l.p.z;\n  double x2 = l.q.x, y2 = l.q.y, z2 = l.q.z;\n  double a = x2 - x1;\n  double b = y2 - y1;\n  double c = z2 - z1;\n  double a2 = a * a;\n  double b2 = b * b;\n  double c2 = c * c;\n  double r2 = a2 + b2 + c2;\n  double t2 = -(a * (x1 - x0) + b * (y1 - y0) + c * (z1 - z0));\n  if(t2 < 0) return sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0) + (z1 - z0) * (z1 - z0));\n  if(t2 > r2) return sqrt((x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0) + (z2 - z0) * (z2 - z0));\n  double fx = b * (z1 - z0) - c * (y1 - y0);\n  double fy = c * (x1 - x0) - a * (z1 - z0);\n  double fz = a * (y1 - y0) - b * (x1 - x0);\n  double f2 = fx * fx + fy * fy + fz * fz;\n  return sqrt(f2 / r2);\n}\n\nint main(void) {\n  cin >> N >> Q;\n  REP(i, 0, N) cin >> P[i].x >> P[i].y >> P[i].z >> R[i] >> L[i];\n  REP(i, 0, Q) cin >> C[i].p.x >> C[i].p.y >> C[i].p.z >> C[i].q.x >> C[i].q.y >> C[i].q.z;\n\n  REP(i, 0, Q) {\n    ll ans = 0;\n    REP(j, 0, N) if(distance(C[i], P[j]) <= R[j]) ans += L[j];\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing T = tuple<double,double,double>;\n\ndouble inner_cross(T u, T v){\n    double ux,uy,uz,vx,vy,vz;\n    tie(ux,uy,uz)=u;\n    tie(vx,vy,vz)=v;\n    return ux*vx+uy*vy+uz*vz;\n}\n\nbool isCross(T Center, double radius, T s, T t){\n    double cx,cy,cz,sx,sy,sz,tx,ty,tz;\n    tie(cx,cy,cz)=Center;\n    tie(sx,sy,sz)=s;\n    tie(tx,ty,tz)=t;\n    T u(tx-sx,ty-sy,tz-sz), v(cx-sx,cy-sy,cz-sz);\n    double d = inner_cross(u,v)/inner_cross(u,u);\n    if(inner_cross(u,v)<0||inner_cross(u,v)>inner_cross(u,u)) return false;\n    else{\n        double ux,uy,uz,vx,vy,vz;\n        tie(ux,uy,uz)=u;\n        tie(vx,vy,vz)=v;\n        T vert(vx-ux*d,vy-uy*d,vz-uz*d);\n        if(inner_cross(vert,vert)<=radius*radius){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\nint main(){\n    int N,Q;\n    cin>>N>>Q;\n    vector<T> Ob;\n    vector<double> r(N);\n    vector<int64_t> l(N);\n    for(int i=0;i<N;i++){\n        double x,y,z;\n        cin>>x>>y>>z>>r[i]>>l[i];\n        Ob.emplace_back(x,y,z);\n    }\n    for(int i=0;i<Q;i++){\n        double sx,sy,sz,dx,dy,dz;\n        cin>>sx>>sy>>sz>>dx>>dy>>dz;\n        T s(sx,sy,sz), t(dx,dy,dz);\n        int64_t cost = 0;\n        for(int j=0;j<N;j++){\n            if(isCross(Ob[j],r[j],s,t)) cost+=l[j];\n        }\n        cout<<cost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  double x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  long long int r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2.0*area)/abs(l.second - l.first);\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  if(cosa < 0) return abs(p - l.first);\n  if(cosb < 0) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].c.x >> p[i].c.y >> p[i].c.z >> p[i].r >> p[i].l;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    long long int ans = 0;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      double d = dis(l, p[j].c);\n      if(d <= p[j].r){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst ld eps = 1e-12;\n\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<ll> X(N), Y(N), Z(N), R(N), L(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n\t}\n\tfor (int q = 0; q < Q; ++q) {\n\t\tll sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tll a = dx - sx, b = dy - sy, c = dz - sz;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d = a * X[i] + b * Y[i] + c * Z[i];\n\t\t\tll den = a*a + b*b + c*c;\n\t\t\tll t = d - a * sx - b * sy - c * sz; // t / den\n\t\t\tll x = den * sx + a * t; // x / den\n\t\t\tll y = den * sy + b * t;\n\t\t\tll z = den * sz + c * t;\n\t\t\tll xx = den*X[i]-x, yy = den*Y[i]-y, zz = den*Z[i]-z;\n\t\t\tif ( 0 < t && t < den ) {\n\t\t\t\tll rr = xx*xx + yy*yy + zz*zz;\n\t\t\t\tif (rr <= den*den*R[i]*R[i]) {\n\t\t\t\t\tans += L[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll rr = (X[i]-sx)*(X[i]-sx) + (Y[i]-sy)*(Y[i]-sy) + (Z[i]-sz)*(Z[i]-sz);\n\t\t\t\trr = min(rr, (X[i]-dx)*(X[i]-dx) + (Y[i]-dy)*(Y[i]-dy) + (Z[i]-dz)*(Z[i]-dz));\n\t\t\t\tif (rr <= R[i]*R[i]) {\n\t\t\t\t\tans += L[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nstruct Point { ld a; ld b; ld c; };\nstruct Line { Point x; Point y; };\nbool eq(ld a, ld b) {\n\treturn(abs(a - b) < eps);\n}\nld norm(Point x,Point y) {\n\treturn sqrt(pow(y.a-x.a,2) + pow(y.b-x.b,2) + pow(y.c-x.c,2));\n}\nPoint dif(Point x, Point y) {\n\treturn Point{ y.a - x.a,y.b - x.b,y.c - x.c };\n}\nld proi(Line l,Line m) {\n\tPoint a = dif(l.x,l.y);\n\tPoint b = dif(m.x, m.y);\n\treturn a.a*b.a + a.b*b.b + a.c*b.c;\n}\nPoint dra(Point a, Point b, Point c) {\n\tPoint res;\n\tld h = proi({ a,b }, { a,c })/norm(a,b);\n\tres = Point{ h*(b.a - a.a) / norm(a,b) + a.a,h*(b.b - a.b) / norm(a,b) + a.b,h*(b.c - a.c) / norm(a,b) + a.c };\n\tif (eq(proi({ a,res }, { c,res }), 0)) {\n\t\treturn res;\n\t}\n\tres = Point{ (h)*(a.a - b.a) / norm(a,b) + a.a,((h)*(a.b - b.b) / norm(a.b) + a.b),((h)*(a.c - b.c) / norm(a,b) + a.c) };\n\tcout<< res.a << \" \" << res.b << \" \" << res.c << endl;\n\treturn res;\n}\nbool across(Line l, Point x,ld r) {\n\tPoint w =dra(l.x, l.y, x);\n\tbool f = false; bool g = false;\n\tif (eq(norm(l.x, w) + norm(w, l.y), norm(l.x, l.y))) {\n\t\tf = true;\n\t}\n\tif (norm(w, x) < r + eps) {\n\t\tg = true;\n\t}\n\tif (f&&g)return true;\n\telse return false;\n}\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tPoint a[50]; ld r[50]; ll cost[50];\n\trep(i, n) {\n\t\tld x, y, z;\n\t\tcin >> x >> y >> z >> r[i] >> cost[i];\n\t\ta[i] = { x,y,z };\n\t}\n\trep(i, q) {\n\t\tld x, y, z,x1,y1,z1;\n\t\tcin >> x >> y >> z;\n\t\tPoint s = { x,y,z };\n\t\tcin >> x1 >> y1 >> z1;\n\t\tPoint t = { x1,y1,z1 };\n\t\tLine l = { s,t };\n\t\tll sum = 0;\n\t\trep(j, n) {\n\t\t\tif (across(l, a[j], r[j])) {\n\t\t\t\tsum += cost[j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst double eps = 1e-9;\n\nstruct Point{\n\tdouble x,y,z;\n\tPoint(double x, double y, double z):\n\t\tx(x), y(y), z(z){}\n\tPoint(){}\n};\nstruct Obj{\n\tPoint p;\n\tdouble r;\n\tlong long int l;\n};\ndouble Length(Point a){\n\treturn sqrt(a.x*a.x +a.y*a.y +a.z*a.z);\n}\n\n//distance between p+t*vec(line) and q(point)\ndouble distLP3(Point p, Point q, Point c){\n\tp.x-=c.x; p.y-=c.y; p.z-=c.z;\n\tq.x-=c.x; q.y-=c.y; q.z-=c.z;\n\tdouble vx = q.x-p.x, vy=q.y-p.y, vz=q.z-p.z;\n\tdouble t = -(vx*p.x +vy*p.y +vz*p.z) /(vx*vx +vy*vy +vz*vz);\n\tif(t<0) return Length(p);\n\tif(t>1) return Length(q);\n\treturn Length(Point(p.x+t*vx, p.y+t*vy, p.z+t*vz));\n}\n\nint main(){\n\tint n,q;\n\tcin >> n >> q;\n\tvector<Obj> ob(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> ob[i].p.x >> ob[i].p.y >> ob[i].p.z >> ob[i].r >> ob[i].l;\n\t}\n\t\n\tfor(int i=0; i<q; i++){\n\t\tPoint s,d;\n\t\tcin >> s.x >> s.y >> s.z;\n\t\tcin >> d.x >> d.y >> d.z;\n\t\tlong long int ans=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(distLP3(s, d, ob[j].p) < ob[j].r + eps){\n\t\t\t\tans+=ob[j].l;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define init(a) memset((a),0,sizeof(a))\nusing namespace std;\ntypedef long double D;\ntypedef vector<D> P;\nconst D EPS = 1e-8;\n\nint N,Q;\nP objp[55];\nD objr[55];\nlong long objl[55];\n\ninline P mul(P p, D d){\n  rep(i,p.size())p[i] *= d;\n  return p;\n}\n\ninline P add(P a, P b){\n  rep(i,a.size())a[i] += b[i];\n  return a;\n}\n\ninline D dis2(const P &a, const P &b){\n  D x = a[0]-b[0], y = a[1]-b[1], z = a[2]-b[2];\n  return x*x+y*y+z*z;\n}\n\ninline int intersect(int c, P l, P r){\n  D r2 = objr[c]*objr[c];\n  bool f1 = (dis2(objp[c],l)<r2+EPS), f2 = (dis2(objp[c],r)<r2+EPS);\n  if(f1&&f2)return 0;\n  if(f1||f2)return 1;\n\n  rep(azu,50){\n    P m1 = mul(add(mul(l,2),r),1.0/3), m2 = mul(add(l,mul(r,2)),1.0/3);\n    D d1 = dis2(objp[c],m1), d2 = dis2(objp[c],m2);\n    if(d1<d2)r = m2;\n    else l = m1;\n  }\n  if(dis2(objp[c],l)<r2+EPS)return 1;\n  return 0;\n}\n\nint main(){\n  scanf(\"%d%d\",&N,&Q);\n\n  rep(i,N){\n    objp[i].resize(3);\n    rep(j,3)scanf(\"%Lf\",&objp[i][j]);\n    scanf(\"%Lf%lld\",&objr[i],&objl[i]);\n  }\n\n  rep(i,Q){\n    P a(3), b(3);\n    rep(i,3)scanf(\"%Lf\",&a[i]);\n    rep(i,3)scanf(\"%Lf\",&b[i]);\n    long long ans = 0;\n    rep(j,N){\n      if(intersect(j,a,b))ans += objl[j];\n    }\n    printf(\"%lld\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef long long ll;\ndouble x_[50],y_[50],z_[50],r_[50];\ndouble eps=1e-9;\nll score[50];\nint main(){\n\tint N,Q;\n\tcin>>N>>Q;\n\trep(i,N) cin>>x_[i]>>y_[i]>>z_[i]>>r_[i]>>score[i];\n\trep(tt,Q){\n\t\tlong long ans=0;\n\t\tdouble a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\td-=a,e-=b,f-=c;\n\t\trep(i,N){\n\t\t\tdouble x=x_[i],y=y_[i],z=z_[i],r=r_[i];\n\t\t\tdouble A=d*d+e*e+f*f;\n\t\t\tdouble B=2*(d*(a-x)+e*(b-y)+f*(c-z));\n\t\t\tdouble C=(a-x)*(a-x)+(b-y)*(b-y)+(c-z)*(c-z);\n\t\t\tdouble mn=1e10;\n\t\t\tdouble xx=-B/A/2;\n\t\t\tif(0<=xx+eps&&xx<=1+eps) chmin(mn,A*xx*xx+B*xx+C);\n\t\t\tchmin(mn,C);\n\t\t\tchmin(mn,A+B+C);\n\t\t\tif(mn<r*r+eps) ans+=score[i];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r;\n  ull l;\n};\ntypedef Point Vector;\null check(ball ba,Point x,Point y){\n  ull z=0;\n  Vector v=y-x,c=ba.p-x;\n  if(dot(v,c)<=0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  \n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    Point p,b;\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ull o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n    }\n    cout << o << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nconst double EPS = 1e-13;\ndouble dist(double x1, double y1, double z1, double x2, double y2, double z2)\n{\n\treturn sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1) + (z2 - z1) * (z2 - z1));\n}\nint main(void)\n{\n\tint N, Q;\n\tcin >> N >> Q;\n\tdouble x[50], y[50], z[50], r[50];\n\tLL l[50];\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\t}\n\tfor (int j = 0; j < Q; ++j)\n\t{\n\t\tdouble sx, sy, sz, dx, dy, dz;\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tdouble vx = dx - sx, vy = dy - sy, vz = dz - sz;\n\t\tLL cost = 0;\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tdouble dn = 0, up = 1;\n\t\t\twhile (up - dn >= EPS)\n\t\t\t{\n\t\t\t\tdouble m1 = (up + dn + dn) / 3;\n\t\t\t\tdouble m2 = (up + up + dn) / 3;\n\t\t\t\tdouble px1 = sx + vx * m1;\n\t\t\t\tdouble py1 = sy + vy * m1;\n\t\t\t\tdouble pz1 = sz + vz * m1;\n\t\t\t\tdouble px2 = sx + vx * m2;\n\t\t\t\tdouble py2 = sy + vy * m2;\n\t\t\t\tdouble pz2 = sz + vz * m2;\n\t\t\t\tif (dist(px1, py1, pz1, x[i], y[i], z[i]) <= dist(px2, py2, pz2, x[i], y[i], z[i]))\n\t\t\t\t{\n\t\t\t\t\tup = m2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdn = m1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble px = sx + vx * dn;\n\t\t\tdouble py = sy + vy * dn;\n\t\t\tdouble pz = sz + vz * dn;\n\t\t\tif (dist(px, py, pz, x[i], y[i], z[i]) <= r[i] + EPS)\n\t\t\t{\n\t\t\t\tcost += l[i];\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  if(dot(v,c)<=0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  \n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    Point p,b;\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ull o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define EPS 1e-10\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y,z;\n\tP(){}\n\tP(double xx,double yy,double zz){\n\t\tx=xx;\n\t\ty=yy;\n\t\tz=zz;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),add(z,p.z));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),add(z,-p.z));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,z*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(add(x*p.x,y*p.y),z*p.z);\n\t}\n};\n\ndouble dist(P p){\n\treturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z);\n}\n\nint n,q;\nP s[51],g[51];\nP b[51];\ndouble r[51];\nlong long l[51];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\",&b[i].x,&b[i].y,&b[i].z,&r[i],&l[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf\",&s[i].x,&s[i].y,&s[i].z);\n\t\tscanf(\"%lf %lf %lf\",&g[i].x,&g[i].y,&g[i].z);\n\t\tlong long res=0;\n\t\tP v=g[i]-s[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tP c=b[j]-s[i];\n\t\t\tif(v.dot(c)<0){\n\t\t\t\tif(r[j]+EPS>=dist(c))res+=l[j];\n\t\t\t}else{\n\t\t\t\tif(v.dot(c)>dist(v)*dist(v)){\n\t\t\t\t\tif(dist(g[i]-b[j])<=r[j]+EPS)res+=l[j];\n\t\t\t\t}else{\n\t\t\t\t\tdouble len=dist(c)*dist(c)-(v.dot(c)*v.dot(c))/(dist(v)*dist(v));\n\t\t\t\t\tif(len<=r[j]*r[j]+EPS)res+=l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nll in(int a, int b, int c, int d, int e, int f) {\n  return a * d + b * e + c * f;\n}\n\nint main() {\n\n  int n, q; cin >> n >> q;\n  vector<ll> x(n), y(n), z(n), r(n), l(n);\n  for(int i=0;i<n;++i) {\n    cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  }\n  int sx, sy, sz, dx, dy, dz;\n  for(int i=0;i<q;++i) {\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    int vx = dx - sx, vy = dy - sy, vz = dz - sz;\n    ll ans = 0;\n    for(int j=0;j<n;++j) {\n      int a = sx - x[j], b = sy - y[j], c = sz - z[j];\n      ll D = in(a, b, c, vx, vy, vz) * in(a, b, c, vx, vy, vz) - in(vx, vy, vz, vx, vy, vz) * (in(a, b, c, a, b, c) - r[j] * r[j]);\n      if(D < 0) continue;\n      double t1 = (-in(a, b, c, vx, vy, vz) + sqrt(D)) / in(vx, vy, vz, vx, vy, vz), t2 = (-in(a, b, c, vx, vy, vz) - sqrt(D)) / in(vx, vy, vz, vx, vy, vz);\n      if((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t1 <= 1)) ans += l[j];\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct st{long double x,y,z;};\nst v[101];\nlong double a1,a2,a3,sx,sy,sz,gx,gy,gz;\nlong double a4,a5,t[101],p[101];\nlong double ch(int q){\n  long double px=v[q].x,py=v[q].y,pz=v[q].z;\n  long double t1=sqrt((sx-gx)*(sx-gx)+(sy-gy)*(sy-gy)+(sz-gz)*(sz-gz));\n  long double t2=sqrt((px-gx)*(px-gx)+(py-gy)*(py-gy)+(pz-gz)*(pz-gz));\n  long double t3=sqrt((sx-px)*(sx-px)+(sy-py)*(sy-py)+(sz-pz)*(sz-pz));\n  long double s=(t1+t2+t3)/2;\n  long double h=sqrt(s*(s-t1)*(s-t2)*(s-t3))*2/t1;\n  if(abs(sqrt(t2*t2-h*h)+sqrt(t3*t3-h*h)-t1)>0.1)return 100000000;\n  return h;\n}\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>a1>>a2>>a3>>a4>>a5;\n    v[i].x=a1;v[i].y=a2;v[i].z=a3;\n    t[i]=a4;p[i]=a5;\n  }\n  while(m--){\n    long long sum=0;\n    cin>>sx>>sy>>sz>>gx>>gy>>gz;\n    for(int i=0;i<n;i++){\n      long double h=ch(i);\n      if(h-0.000001<=(long double)(t[i]))sum+=p[i];\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????D???long D?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-3;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD abs(D x, D y, D z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nD dot(D a1, D a2, D a3, D b1, D b2, D b3){\n    return a1*b1 + a2*b2 + a3*b3;\n}\n\nD cross(D a1, D a2, D a3, D b1, D b2, D b3){\n    D i = a2*b3 - a3*b2;\n    D j = a3*b1 - a1*b3;\n    D k = a1*b2 - a2*b1;\n    return abs(i, j, k);\n}\n\nD distLP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    return abs(cross(px-sx, py-sy, pz-sz, dx-sx, dy-sy, dz-sz))/abs(dx-sx, dy-sy, dz-sz);\n}\n\nD distSP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    if(LE(dot(dx-sx, dy-sy, dz-sz, px-sx, py-sy, pz-sz), 0))\n        return abs(px-sx, py-sy, pz-sz);\n    if(LE(dot(sx-dx, sy-dy, sz-dz, px-dx, py-dy, pz-dz), 0))\n        return abs(px-dx, py-dy, pz-dz);\n    return distLP(sx, sy, sz, dx, dy, dz, px, py, pz);\n}\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    int l;\n    \n    Circle(D x, D y, D z, D r, int l): x(x), y(y), z(z), r(r), l(l){};\n    \n    bool intersect(D sx, D sy, D sz, D dx, D dy, D dz){\n        return LE(distSP(sx, sy, sz, dx, dy, dz, x, y, z), r);\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    int N, Q;\n    cin >> N >> Q;\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r;\n        int l;\n        cin >> x >> y >> z >> r >> l;\n        circles.push_back({x, y, z, r, l});\n    }\n    \n    while(Q--){\n        ll ans = 0;\n        D sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        for(Circle &circle: circles){\n            if(circle.intersect(sx, sy, sz, dx, dy, dz))\n                ans += circle.l;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????D???long D?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-6;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD abs(D x, D y, D z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nD dot(D a1, D a2, D a3, D b1, D b2, D b3){\n    return a1*b1 + a2*b2 + a3*b3;\n}\n\nD cross(D a1, D a2, D a3, D b1, D b2, D b3){\n    D i = a2*b3 - a3*b2;\n    D j = a3*b1 - a1*b3;\n    D k = a1*b2 - a2*b1;\n    return abs(i, j, k);\n}\n\nD distLP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    return abs(cross(px-sx, py-sy, pz-sz, dx-sx, dy-sy, dz-sz))/abs(dx-sx, dy-sy, dz-sz);\n}\n\nD distSP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    if(LE(dot(dx-sx, dy-sy, dz-sz, px-sx, py-sy, pz-sz), 0))\n        return abs(px-sx, py-sy, pz-sz);\n    if(LE(dot(sx-dx, sy-dy, sz-dz, px-dx, py-dy, pz-dz), 0))\n        return abs(px-dx, py-dy, pz-dz);\n    return distLP(sx, sy, sz, dx, dy, dz, px, py, pz);\n}\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    int l;\n    \n    Circle(D x, D y, D z, D r, int l): x(x), y(y), z(z), r(r), l(l){};\n    \n    bool intersect(D sx, D sy, D sz, D dx, D dy, D dz){\n        return LE(distSP(sx, sy, sz, dx, dy, dz, x, y, z), r);\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    int N, Q;\n    cin >> N >> Q;\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r;\n        int l;\n        cin >> x >> y >> z >> r >> l;\n        circles.push_back({x, y, z, r, l});\n    }\n    \n    while(Q--){\n        int ans = 0;\n        D sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        for(Circle &circle: circles){\n            if(circle.intersect(sx, sy, sz, dx, dy, dz))\n                ans += circle.l;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define STEPS 10000000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tlong double vx = 1.0 * (sx - dx) / STEPS;\n\t\tlong double vy = 1.0 * (sy - dy) / STEPS;\n\t\tlong double vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tlong double tx = sx;\n\t\tlong double ty = sy;\n\t\tlong double tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tlong double rx = tx - x[i];\n\t\t\t\tlong double ry = ty - y[i];\n\t\t\t\tlong double rz = tz - z[i];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[i] * r[i] + 0.000001)\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttx -= vx;\n\t\t\tty -= vy;\n\t\t\ttz -= vz;\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define STEPS 100000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tdouble vx = 1.0 * (sx - dx) / STEPS;\n\t\tdouble vy = 1.0 * (sy - dy) / STEPS;\n\t\tdouble vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tdouble tx = sx;\n\t\tdouble ty = sy;\n\t\tdouble tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tdouble rx = tx - x[i];\n\t\t\t\tdouble ry = ty - y[i];\n\t\t\t\tdouble rz = tz - z[i];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[i] * r[i])\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst double eps = 1e-9;\n\nstruct Point{\n\tdouble x,y,z;\n\tPoint(double x, double y, double z):\n\t\tx(x), y(y), z(z){}\n\tPoint(){}\n};\nstruct Obj{\n\tPoint p;\n\tdouble r;\n\tlong long int l;\n};\ndouble Length(Point a){\n\treturn sqrt(a.x*a.x +a.y*a.y +a.z*a.z);\n}\n\n//distance between p+t*vec(line) and q(point)\ndouble distLP3(Point p, Point q, Point c){\n\tp.x-=c.x; p.y-=c.y; p.z-=c.z;\n\tq.x-=c.x; q.y-=c.y; q.z-=c.z;\n\tdouble vx = q.x-p.x, vy=q.y-p.y, vz=q.z-p.z;\n\tdouble t = -(vx*p.x +vy*p.y +vz*p.z) /(vx*vx +vy*vy +vz*vz);\n\tif(t<0) return Length(p);\n\tif(t>1) return Length(q);\n\treturn Length(Point(p.x+t*vx, p.y+t*vy, p.z+t*vz));\n}\n\nint main(){\n\tint n,q;\n\tcin >> n >> q;\n\tvector<Obj> ob(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> ob[i].p.x >> ob[i].p.y >> ob[i].p.z >> ob[i].r >> ob[i].l;\n\t}\n\t\n\tfor(int i=0; i<q; i++){\n\t\tPoint s,d;\n\t\tcin >> s.x >> s.y >> s.z;\n\t\tcin >> d.x >> d.y >> d.z;\n\t\tint ans=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(distLP3(s, d, ob[j].p) < ob[j].r + eps){\n\t\t\t\tans+=ob[j].l;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int64)1e9\n#define REP(i, n) for(int64 i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int64 i = (a); i < (b); i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint32_t;\nusing int64 = int64_t;\nusing uint64 = uint64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if (a > b) a = b; }\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if (a < b) a = b; }\n#define double long double\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersectSC(Segment3D s,Sphere c){\n  double d=getDistanceSP(s,c.c);\n  if(d>c.r) return 0;\n  return !((abs(s.p1-c.c)<=c.r)&&(abs(s.p2-c.c)<=c.r));\n}\n\nstruct ConvexHull3D{\n  struct face{\n    int a,b,c;\n    bool ok;\n    face(){}\n    face(int a,int b,int c,bool ok):a(a),b(b),c(c),ok(ok){}\n  };\n  int n,num;\n  vector<Point3D> p;\n  vector<face> f;\n  vector<vector<int> >  g;\n\n  ConvexHull3D(int n):n(n),p(n),f(n*8),g(n,vector<int>(n)){}\n\n  void input(){\n    for(int i=0;i<n;i++) cin>>p[i];\n  }\n\n  double dblcmp(Point3D q,face f){\n    Point3D m=p[f.b]-p[f.a];\n    Point3D n=p[f.c]-p[f.a];\n    Point3D t=q-p[f.a];\n    return (m*n)^t;\n  }\n\n  void deal(int q,int a,int b){\n    int idx=g[a][b];\n    face add;\n    if(f[idx].ok){\n      if(dblcmp(p[q],f[idx])>EPS) dfs(q,idx);\n      else{\n        add=face(b,a,q,1);\n        g[q][b]=g[a][q]=g[b][a]=num;\n        f[num++]=add;\n      }\n    }\n  }\n\n  void dfs(int q,int now){\n    f[now].ok=0;\n    deal(q,f[now].b,f[now].a);\n    deal(q,f[now].c,f[now].b);\n    deal(q,f[now].a,f[now].c);\n  }\n\n  void build(){\n    num=0;\n    if(n<4) return;\n    bool flg=1;\n    for(int i=1;i<n;i++){\n      if(abs(p[0]-p[i])>EPS){\n        swap(p[1],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    flg=1;\n    for(int i=2;i<n;i++){\n      if(abs((p[0]-p[1])*(p[1]-p[i]))>EPS){\n        swap(p[2],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    flg=1;\n    for(int i=3;i<n;i++){\n      if(abs(((p[0]-p[1])*(p[1]-p[2]))^(p[0]-p[i]))>EPS){\n        swap(p[3],p[i]);\n        flg=0;\n        break;\n      }\n    }\n    if(flg) return;\n    face add;\n    for(int i=0;i<4;i++){\n      add=face((i+1)%4,(i+2)%4,(i+3)%4,1);\n      if(dblcmp(p[i],add)>0) swap(add.b,add.c);\n      g[add.a][add.b]=g[add.b][add.c]=g[add.c][add.a]=num;\n      f[num++]=add;\n    }\n    for(int i=4;i<n;i++){\n      for(int j=0;j<num;j++){\n        if(f[j].ok&&dblcmp(p[i],f[j])>EPS){\n          dfs(i,j);\n          break;\n        }\n      }\n    }\n    int tmp=num;\n    num=0;\n    for(int i=0;i<tmp;i++)\n      if(f[i].ok) f[num++]=f[i];\n  }\n\n  double volume(Point3D a,Point3D b,Point3D c,Point3D d){\n    return ((b-a)*(c-a))^(d-a);\n  }\n\n  bool same(int s,int t){\n    Point3D &a=p[f[s].a];\n    Point3D &b=p[f[s].b];\n    Point3D &c=p[f[s].c];\n    return  (abs(volume(a,b,c,p[f[t].a]))<EPS)\n            &&    (abs(volume(a,b,c,p[f[t].b]))<EPS)\n            &&    (abs(volume(a,b,c,p[f[t].c]))<EPS);\n  }\n\n  int polygon(){\n    int res=0;\n    for(int i=0;i<num;i++){\n      int flg=1;\n      for(int j=0;j<i;j++)\n        flg&=!same(i,j);\n      res+=flg;\n    }\n    return res;\n  }\n\n  int triangle(){\n    return num;\n  }\n\n  double area(Point3D a,Point3D b,Point3D c){\n    return abs((b-a)*(c-a));\n  }\n\n  Point3D cross(Point3D a,Point3D b,Point3D c){\n    return Point3D((b.y-a.y)*(c.z-a.z)-(b.z-a.z)*(c.y-a.y),\n                   (b.z-a.z)*(c.x-a.x)-(b.x-a.x)*(c.z-a.z),\n                   (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x));\n  }\n\n  double area(){\n    double res=0;\n    if(n==3){\n      Point3D q=cross(p[0],p[1],p[2]);\n      res=abs(q)/2.0;\n      return res;\n    }\n    return res;\n    for(int i=0;i<num;i++)\n      res+=area(p[f[i].a],p[f[i].b],p[f[i].c]);\n    return res/2.0;\n  }\n};\n\n\n\nint main(void) {\n  int64 N, Q;\n  cin >> N >> Q;\n  vector<int64> l(N);\n  vector<Sphere> sp(N);\n  REP(i, N) cin >> sp[i] >> l[i];\n  REP(i, Q) {\n    Point3D s, g;\n    cin >> s >> g;\n    int64 res = 0;\n    REP(j, N) {\n      auto ret = getDistanceSP(Segment3D(s, g), sp[j].c);\n      if (ret <= sp[j].r + EPS) {\n        res += l[j];\n      }\n    }\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, q;\nint x[55], y[55], z[55], r[55], l[55];\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> q;\n  rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  rep(i, q) {\n    int sx, sy, sz, dx, dy, dz;\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    int vx = dx - sx;\n    int vy = dy - sy;\n    int vz = dz - sz;\n    int wx = sx - dx;\n    int wy = sy - dy;\n    int wz = sz - dz;\n    int ans = 0;\n    rep(j, n) {\n      int cx = x[j] - sx;\n      int cy = y[j] - sy;\n      int cz = z[j] - sz;\n      int rcx = x[j] - dx;\n      int rcy = y[j] - dy;\n      int rcz = z[j] - dz;\n      double a1 = vx * cx + vy * cy + vz * cz;\n      double a2 = wx * rcx + wy * rcy + wz * rcz;\n      double b = sqrt(pow(vx, 2) + pow(vy, 2) + pow(vz, 2));\n      double c = sqrt(pow(cx, 2) + pow(cy, 2) + pow(cz, 2));\n      double d = sqrt(pow(rcx, 2) + pow(rcy, 2) + pow(rcz, 2));\n      //cerr << a << \" \" << b << \" \" << c << endl;\n      double theta1 = acos(a1 / (b * c));\n      double theta2 = acos(a2 / (b * d));\n      //cerr << theta1 << \" \" << theta2 << endl;\n      if (pi / 2 <= theta1 + EPS || pi / 2 <= theta2 + EPS) continue;\n      //if (theta1)\n      double dist1 = c * sin(theta1);\n      double dist2 = d * sin(theta2);\n      //cerr << dist1 << \" \" << dist2 << \" \" << r[j] << endl;\n      //cerr << dist << \" \" << r[j] << endl;\n      if (dist1- EPS <= r[j]) {\n        ans += l[j];\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct _vec{\n    double x, y, z;\n} vec;\n\ndouble Dis(vec A, vec B){\n    double dis = (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) + (A.z-B.z)*(A.z-B.z);\n    //cout << dis << \" o \" <<  endl;\n    dis = pow(dis, 0.5);\n    //cout << dis << \" o \" <<  endl;    \n    return dis;\n}\n\ndouble norm(vec A, vec B){             //内積\n    double res;\n    res = A.x*B.x + A.y*B.y + A.z*B.z;   \n\n    return res;\n}\n\nvec tanni(vec A){                   //単位ベクトルを返す\n    double dis = A.x*A.x + A.y*A.y + A.z*A.z;\n    dis = pow(dis, 0.5);\n    vec res;\n    res.x = A.x / dis;\n    res.y = A.y / dis;\n    res.z = A.z / dis;\n\n    return res;    \n}\n\nvec houkou(vec A, vec B){             //方向ベクトルを返す\n    vec res;\n    //cout << B.x << \" \" << A.x << endl;\n    res.x = B.x - A.x;\n    res.y = B.y - A.y;\n    res.z = B.z - A.z;\n    return res;\n}\n\nint main(){\n\n    int n, q; cin >> n >> q;\n    vector<vec> obj(n);\n    vector<vec> blue(q);\n    vector<vec> red(q);    \n    vector<double> r(n);\n    vector<int> l(n);\n\n    for(int i = 0; i < n; i++){\n        int a, b, c, d, e; cin >> a >> b >> c >> d >> e;\n        obj[i].x = a;\n        obj[i].y = b;\n        obj[i].z = c;\n        r[i] = d;\n        l[i] = e;                \n    }\n\n    for(int i = 0; i < q; i++){\n        int a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f;\n        blue[i].x = d;\n        blue[i].y = e;\n        blue[i].z = f;\n        red[i].x = a;\n        red[i].y = b;\n        red[i].z = c;        \n    }\n\n\n\n    for(int i = 0; i < q; i++){\n\n        int ans = 0;\n        for(int j = 0; j < n; j++){\n            //j個目の障害物とはどうですか\n            vec H;\n            H.x = red[i].x;\n            H.y = red[i].y;\n            H.z = red[i].z;            \n\n            vec u;\n            u = houkou(red[i], blue[i]);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;            \n            u = tanni(u);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;\n            vec a;\n            a.x = obj[j].x - red[i].x;\n            a.y = obj[j].y - red[i].y;\n            a.z = obj[j].z - red[i].z;\n            //cout << a.x << \" \" << a.y << \" \" <<  a.z << endl;           \n            int _norm = norm(a, u);\n            //cout << _norm << endl;\n            vec w;\n            w.x = _norm*u.x;\n            w.y = _norm*u.y;\n            w.z = _norm*u.z;\n            //cout << endl;\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << w.x << \" \" << w.y << \" \" << w.z << endl;\n            H.x += w.x;\n            H.y += w.y;\n            H.z += w.z;\n\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << obj[j].x << \" \" << obj[j].y << \" \" << obj[j].z << endl;\n\n            double _dis = Dis(H, obj[j]);\n            //cout << _dis << endl;\n            if(_dis <= r[j]) ans += l[j];            \n            //cout << ans << endl;\n        \n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef long long lint;\nconst double EPS = 1e-9;\n\ntypedef struct Point {\n\tdouble x, y, z;\n\tPoint (double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}\n\tPoint operator + (const Point& a) const { return Point(x + a.x, y + a.y, z + a.z); }\n\tPoint operator - (const Point& a) const { return Point(x - a.x, y - a.y, z - a.z); }\n\tPoint operator * (double d) const { return Point(x * d, y * d, z * d); }\n} Vector;\n\nstruct Object {\n\tPoint p; double r; lint l;\n\tObject(Point p_, double r_, lint l_) : p(p_), r(r_), l(l_) {}\n};\n\ndouble sqr(double x) { return x * x; }\ndouble distance(const Point& a, const Point& b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y) + sqr(a.z - b.z)); }\n\nbool collision(const Object& obj, const Point& a, const Point& b) {\n\tVector unit = b - a;\n\t\n\tdouble lb = 0.0, ub = 1500.0;\n\t\n\tfor_(i,0,100) {\n\t\tdouble lft = (lb + ub) / 3., rgt = (lb + ub) * 2. / 3.;\n\t\tPoint pl = a + unit * lft, pr = a + unit * rgt;\n\t\tdouble dl = distance(obj.p, pl), dr = distance(obj.p, pr);\n\t\tif (dl < dr + EPS) ub = rgt;\n\t\telse lb = lft;\n\t}\n\t\n\treturn distance(obj.p, a + unit * ((lb + ub) / 2.)) < obj.r + EPS;\n}\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\t\n\tvector< Object > obj;\n\t\n\tfor_(i,0,N) {\n\t\tdouble x, y, z, r; lint l;\n\t\tcin >> x >> y >> z >> r >> l;\n\t\tobj.push_back(Object(Point(x, y, z), r, l));\n\t}\n\t\n\tfor_(i,0,Q) {\n\t\tdouble x1, y1, z1, x2, y2, z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tPoint red(x1, y1, z1), blue(x2, y2, z2);\n\t\n\t\tlint ans = 0;\n\t\tfor_(j,0,N) if (collision(obj[j], red, blue)) ans += obj[j].l;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersectSC(Segment3D s,Sphere c){\n  double d=getDistanceSP(s,c.c);\n  if(d>c.r) return 0;\n  return !((abs(s.p1-c.c)<=c.r)&&(abs(s.p2-c.c)<=c.r));\n}\n\ndouble r[55], val[55];\nSphere sp[55];\nSegment3D seg[55];\nsigned main(void)\n{\n  int n, q;\n  cin >> n >> q;\n  REP(i, n) cin >> sp[i] >> val[i];\n  REP(i, q) cin >> seg[i];\n\n  REP(i, q) {\n    int ret = 0;\n    REP(j, n) if(intersectSC(seg[i], sp[j])) ret += val[j];\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld eps = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef valarray<ld> Point;\nPoint make_point(ld x, ld y, ld z) {\n\tPoint p(3);\n\tp[0] = x; p[1] = y; p[2] = z;\n\treturn p;\n}\n\nld dot(const Point &a, const Point &b) {\n\treturn (a * b).sum();\n}\n\nPoint cross(const Point &a, const Point &b) {\n\treturn a.cshift(+1) * b.cshift(-1) - a.cshift(-1) * b.cshift(+1);\n}\n\nld norm(const Point &a) { return dot(a, a); }\nld dist(const Point &a) { return sqrt(norm(a)); }\n\n// Line\n\nstruct Line { Point a, b; };\n\nbool is_in_segment(Line l, Point p) {\n\treturn abs(dist(l.a - p) + dist(l.b - p) - dist(l.a - l.b)) < eps;\n}\n\nPoint project_lp(Line l, Point p) {\n\tPoint point = l.a, vec = l.b - l.a;\n\treturn point + dot(p - point, vec) / norm(vec) * vec;\n}\n\nld distance_lp(Line l, Point p) {\n\treturn dist(p - project_lp(l, p));\n}\n\nld distance_sp(Line l, Point p) {\n\tPoint proj = project_lp(l, p);\n\tif (dist(l.a - proj) + dist(l.b - proj) < dist(l.b - l.a) + eps)\n\t\treturn dist(p - proj);\n\telse\n\t\treturn min(dist(p - l.a), dist(p - l.b));\n}\n\nstruct Sphere { Point p; ld r; int l; };\n\nint main()\n{\n\tint n, q; cin >> n >> q;\n\tvector<Sphere> v;\n\tREP(i, n)\n\t{\n\t\tld x, y, z, r;\n\t\tint l; cin >> x >> y >> z >> r >> l;\n\t\tv.emplace_back(Sphere{ make_point(x,y,z),r,l });\n\t}\n\tREP(i, q)\n\t{\n\t\tint ans = 0;\n\t\tld x[2], y[2], z[2];\n\t\tREP(j, 2) cin >> x[j] >> y[j] >> z[j];\n\t\tLine l{ make_point(x[0], y[0], z[0]), make_point(x[1], y[1], z[1]) };\n\t\tREP(j, n)\n\t\t{\n\t\t\tld d = distance_sp(l, v[j].p);\n\t\t\tif (v[j].r - d > -eps) ans += v[j].l;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\ntypedef long long ll;\n \nclass Point{\npublic:\n    Point(){}\n    Point(double x,double y,double z) : x(x), y(y), z(z) {}\n   \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y,z+p.z); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y,z-p.z); }\n    Point operator * (double k)const{ return Point(x*k,y*k,z*k); }\n    Point operator / (double k)const{ return Point(x/k,y/k,z/k); }\n    double x,y,z;\n};\n \ndouble dot(const Point &a,const Point &b){\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n \nPoint cross(const Point &a,const Point &b){\n    return Point(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n \ndouble norm(const Point &p){\n    return dot(p,p);\n}\n \ndouble abs(const Point &p){\n    return sqrt(norm(p));\n}\n \nistream &operator >> (istream &is,Point &p){\n    return is >> p.x >> p.y >> p.z;\n}\n \nclass Line{\npublic:\n    Line(){}\n    Line(Point s,Point t) : s(s), t(t) {}\n    Point s,t;\n};\n \nPoint projection(const Line &l,const Point &p){\n    Point b = l.t - l.s;\n    double t = dot(p-l.s,b)/norm(b);\n    return l.s + b*t;\n}\n \ndouble distanceLP(const Line &l,const Point &p){\n    return abs(p-projection(l,p));\n}\n \nclass Cube{\npublic:\n    Cube(){}\n    Cube(Point p,double r) : p(p), r(r) {}\n    Point p;\n    double r;\n};\n \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n  \nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(abs(cross(a,b)) > EPS) return COUNTER_CLOCKWISE; \n    if(abs(cross(a,b)) < -EPS) return CLOCKWISE; \n    if(dot(a,b) < -EPS) return ONLINE_BACK; \n    if(norm(a) < norm(b)) return ONLINE_FRONT; \n    return ON_SEGMENT;\n}\n \nbool isIntersectCL(const Cube &c,const Line &l){\n    vector<Point> vec;\n    double d = distanceLP(l,c.p);\n    if(le(d,c.r)){\n\tPoint p = projection(l,c.p);\n\tPoint v = (l.t - l.s) / abs(l.t - l.s);\n\td = sqrt(c.r*c.r-d*d);\n\tvec.push_back(p - v*d);\n\tvec.push_back(p + v*d);\n\tfor(int i = 0 ; i < (int)vec.size() ; i++){\n\t    if(ccw(l.s,l.t,vec[i]) == ON_SEGMENT){\n\t\treturn true;\n\t    }\n\t}\n    }\n    return false;\n}\n \nclass Obj{\npublic:\n    Obj(){}\n    Obj(Cube c,ll l) : c(c), l(l) {}\n    Cube c;\n    ll l;\n};\n \nint main(){\n    int N,Q;\n    cin >> N >> Q;\n    vector<Obj> obj(N);\n    for(int i = 0 ; i < N ; i++){\n\tcin >> obj[i].c.p >> obj[i].c.r >> obj[i].l;\n    }\n    for(int i = 0 ; i < Q ; i++){\n\tLine l;\n\tcin >> l.s >> l.t;\n\tll res = 0LL;\n\tfor(int j = 0 ; j < N ; j++){\n\t    if(isIntersectCL(obj[j].c,l)){\n\t\tres += obj[j].l;\n\t    }\n\t}\n\tcout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nstruct Point {\n    double x, y, z;\n};\n\nPoint operator+(Point a, Point b) {\n    return Point{a.x+b.x, a.y+b.y, a.z+b.z};\n}\n\nPoint operator-(Point a, Point b) {\n    return Point{a.x-b.x, a.y-b.y, a.z-b.z};\n}\n\nPoint operator*(double a, Point b) {\n    return Point{a*b.x, a*b.y, a*b.z};\n}\n\ndouble abs(Point a) {\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\ndouble cross(Point a, Point b) {\n    double ra = a.y * b.z - a.z * b.y;\n    double rb = a.z * b.x - a.x * b.z;\n    double rc = a.x * b.y - a.y * b.x;\n    return sqrt(ra*ra + rb*rb + rc*rc);\n}\n\ndouble dot(Point a, Point b) {\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nsigned main() {\n    const double EPS = 1e-8;\n    int N, Q; cin >> N >> Q;\n    Point p[100];\n    double r[100];\n    int l[100];\n\n    rep(i,0,N) {\n        double x, y, z;\n        cin >> x >> y >> z >> r[i] >> l[i];\n        p[i] = Point{x, y, z};\n    }\n    while(Q--) {\n        double sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        Point s{sx, sy, sz}, t{dx, dy, dz};\n\n        int ans = 0;\n        rep(i,0,N) {\n            double A = dot(s-p[i], t-s);\n            double B = dot(t-s, t-s);\n            double T = - A / B;\n\n            if(-EPS >= T || T >= 1.0 + EPS) continue;\n            Point d = (s-p[i]) + T * (t-s);\n            if(abs(d) - r[i] < EPS) ans += l[i];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n#define le(a,b) (lt(a,b) || equal(a,b))\ntypedef long long ll;\n\nclass Point{\npublic:\n  Point(){}\n  Point(double x,double y,double z) : x(x), y(y), z(z) {}\n  \n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y,z+p.z); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y,z-p.z); }\n  Point operator * (double k)const{ return Point(x*k,y*k,z*k); }\n  Point operator / (double k)const{ return Point(x/k,y/k,z/k); }\n  double x,y,z;\n};\n\ndouble dot(const Point &a,const Point &b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble norm(const Point &p){\n  return dot(p,p);\n}\n\ndouble abs(const Point &p){\n  return sqrt(norm(p));\n}\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y >> p.z;\n}\n\nclass Line{\npublic:\n  Line(){}\n  Line(Point s,Point t) : s(s), t(t) {}\n  Point s,t;\n};\n\nPoint projection(const Line &l,const Point &p){\n  Point b = l.t - l.s;\n  double t = dot(p-l.s,b)/norm(b);\n  return l.s + b*t;\n}\n\ndouble distanceLP(const Line &l,const Point &p){\n  return abs(p-projection(l,p));\n}\n\nclass Cube{\npublic:\n  Cube(){}\n  Cube(Point p,double r) : p(p), r(r) {}\n  Point p;\n  double r;\n};\n\nbool onSegment(const Line &l,const Point &p){\n  return ((le(l.s.x,p.x) && le(p.x,l.t.x)) ||\n          (le(l.s.y,p.y) && le(p.y,l.t.y)) ||\n          (le(l.s.z,p.z) && le(p.z,l.t.z)));\n}\n\nbool isIntersectCL(const Cube &c,const Line &l){\n  vector<Point> vec;\n  double d = distanceLP(l,c.p);\n  if(le(d,c.r)){\n    Point p = projection(l,c.p);\n    Point v = (l.t - l.s) / abs(l.t - l.s);\n    d = sqrt(c.r*c.r-d*d);\n    vec.push_back(p - v*d);\n    vec.push_back(p + v*d);\n    for(int i = 0 ; i < (int)vec.size() ; i++){\n      if(onSegment(l,vec[i])){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nclass Obj{\npublic:\n  Obj(){}\n  Obj(Cube c,ll l) : c(c), l(l) {}\n  Cube c;\n  ll l;\n};\n\nint main(){\n  int N,Q;\n  cin >> N >> Q;\n  vector<Obj> obj(N);\n  for(int i = 0 ; i < N ; i++){\n    cin >> obj[i].c.p >> obj[i].c.r >> obj[i].l;\n  }\n  for(int i = 0 ; i < Q ; i++){\n    Line l;\n    cin >> l.s >> l.t;\n    ll res = 0LL;\n    for(int j = 0 ; j < N ; j++){\n      if(isIntersectCL(obj[j].c,l)){\n        res += obj[j].l;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define eps 0.0000001\nusing namespace std;\nstruct po{int x,y,z,r; long long l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n  int n,q;\n  cin >>n>>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].x>>ball[i].y>>ball[i].z>>ball[i].r>>ball[i].l;\n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].x,ball[j].y,ball[j].z});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].x,ball[j].y,ball[j].z});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = (2*S)/dis[0];\n      \n      if(abs(dis[1]-ball[j].r)<=eps || abs(dis[2]-ball[j].r)<=eps) {\n\tans+=ball[j].l;\n\tcontinue;\n      }\n\n      if(abs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0]) > eps)continue;\n      if(abs(h-ball[j].r)<eps) ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\n\ntypedef struct O{int x,y,z,r,l;}O;\ntypedef struct P{int x,y,z;}P;\ntypedef struct V{double x,y,z;}V;\n\nO obj[51];\nP s,t,v;\nint N,Q,i,j,res;\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d%d\",&obj[i].x,&obj[i].y,&obj[i].z,&obj[i].r,&obj[i].l);\n\tfor(i=0;i<Q;i++)\n\t{\n\t\tres=0;\n\t\tscanf(\"%d%d%d%d%d%d\",&s.x,&s.y,&s.z,&t.x,&t.y,&t.z);\n\t\tfor(j=0;j<N;j++)\n\t\t{\n\t\t\tP v={t.x-s.x,t.y-s.y,t.z-s.z};\n\t\t\tdouble a=v.x*(obj[j].x-s.x)+v.y*(obj[j].y-s.y)+v.z*(obj[j].z-s.z);\n\t\t\tdouble b=v.x*v.x+v.y*v.y+v.z*v.z;\n\t\t\tdouble c=abs(a/b);\n\t\t\tV l={s.x+v.x*c,s.y+v.y*c,s.z+v.z*c};\n\t\t\tdouble len=sqrt(pow(l.x-obj[j].x,2)+pow(l.y-obj[j].y,2)+pow(l.z-obj[j].z,2));\n\t\t\tif(len-obj[j].r<=0)\n\t\t\t\tres+=obj[j].l;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct _vec{\n    double x, y, z;\n} vec;\n\ndouble Dis(vec A, vec B){\n    double dis = (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) + (A.z-B.z)*(A.z-B.z);\n    //cout << dis << \" o \" <<  endl;\n    dis = pow(dis, 0.5);\n    //cout << dis << \" o \" <<  endl;    \n    return dis;\n}\n\ndouble norm(vec A, vec B){             //内積\n    double res;\n    res = A.x*B.x + A.y*B.y + A.z*B.z;   \n\n    return res;\n}\n\nvec tanni(vec A){                   //単位ベクトルを返す\n    double dis = A.x*A.x + A.y*A.y + A.z*A.z;\n    dis = pow(dis, 0.5);\n    vec res;\n    res.x = A.x / dis;\n    res.y = A.y / dis;\n    res.z = A.z / dis;\n\n    return res;    \n}\n\nvec houkou(vec A, vec B){             //方向ベクトルを返す\n    vec res;\n    //cout << B.x << \" \" << A.x << endl;\n    res.x = B.x - A.x;\n    res.y = B.y - A.y;\n    res.z = B.z - A.z;\n    return res;\n}\n\nint main(){\n\n    /*vec V1, V2;\n    V1.x = 3;\n    V1.y = 4;\n    V1.z = 5;\n    V2.x = 6;\n    V2.y = 3;\n    V2.z = 8;\n\n    cout << norm(V1, V2) << endl;\n    cout << Dis(V1, V2) << endl;\n    vec V3 = tanni(V1);\n    cout << V3.x << \" \" << V3.y << \" \" << V3.z << endl;\n    vec V4 = houkou(V1, V2);\n    cout << V4.x << \" \" << V4.y << \" \" << V4.z << endl;*/\n    \n\n    int n, q; cin >> n >> q;\n    vector<vec> obj(n);\n    vector<vec> blue(q);\n    vector<vec> red(q);    \n    vector<double> r(n);\n    vector<int> l(n);\n\n    for(int i = 0; i < n; i++){\n        double a, b, c, d, e; cin >> a >> b >> c >> d >> e;\n        obj[i].x = a;\n        obj[i].y = b;\n        obj[i].z = c;\n        r[i] = d;\n        l[i] = e;                \n    }\n\n    for(int i = 0; i < q; i++){\n        double a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f;\n        blue[i].x = d;\n        blue[i].y = e;\n        blue[i].z = f;\n        red[i].x = a;\n        red[i].y = b;\n        red[i].z = c;        \n    }\n\n\n\n    for(int i = 0; i < q; i++){\n\n        int ans = 0;\n\n        for(int j = 0; j < n; j++){\n            //j個目の障害物とはどうですか\n            vec H;\n            H.x = red[i].x;\n            H.y = red[i].y;\n            H.z = red[i].z;            \n\n            vec u;\n            u = houkou(red[i], blue[i]);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;            \n            u = tanni(u);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;\n            vec a;\n            a.x = obj[j].x - red[i].x;\n            a.y = obj[j].y - red[i].y;\n            a.z = obj[j].z - red[i].z;\n            //cout << a.x << \" \" << a.y << \" \" <<  a.z << endl;           \n            int _norm = norm(a, u);\n            //cout << _norm << endl;\n            vec w;\n            w.x = _norm*u.x;\n            w.y = _norm*u.y;\n            w.z = _norm*u.z;\n            //cout << endl;\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << w.x << \" \" << w.y << \" \" << w.z << endl;\n            H.x += w.x;\n            H.y += w.y;\n            H.z += w.z;\n\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << obj[j].x << \" \" << obj[j].y << \" \" << obj[j].z << endl;\n\n            double _dis = Dis(H, obj[j]);\n            //cout << j << \" \" << _dis << endl;\n            //cout << _dis << endl;\n            if(_dis <= r[j]) ans += l[j];            \n            //cout << ans << endl;\n        \n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-5)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y,z;\n  Point(double x=0,double y=0,double z=0):x(x),y(y),z(z){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y,z+p.z);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n  Point operator*(double k){ return Point(x*k,y*k,z*k);}\n  Point operator/(double k){ return Point(x/k,y/k,z/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : (y!=p.y ? y<p.y : z<p.z));}\n  bool operator==(Point p)const{ \n    return (fabs(x-p.x)<eps && fabs(y-p.y)<eps &&  fabs(z-p.z)<eps);}\n  \n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y+z*z);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass sphere{\npublic:\n  Point c;\n  double r;\n  sphere(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y+a.z*a.z);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y+a.z*b.z);}\nVector cross(Vector a,Vector b){ \n  Vector res;\n  res.x=(a.y*b.z)-(a.z*b.y);\n  res.y=(a.z*b.x)-(a.x*b.z);\n  res.z=(a.x*b.y)-(a.y*b.x);\n  return res;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nint main()\n{\n  int n,q;\n  double a,b,c,x,y,z,r,m;\n  vector<pair<sphere,int> > vs;\n\n  cin>>n>>q;\n  for(int i=0;i<n;i++){\n    cin>>a>>b>>c>>r>>m;\n    vs.push_back(mp(sphere(Point(a,b,c),r),m));\n  }\n\n  for(int i=0;i<q;i++){\n    cin>>a>>b>>c>>x>>y>>z;\n    Segment A(Point(a,b,c),Point(x,y,z));\n    int ans=0;\n    for(int j=0;j<n;j++){\n      // printf(\"%.10f %.10f\\n\",getDistanceSP(A,vs[j].f.c),vs[j].f.r);\n      if((getDistanceSP(A,vs[j].f.c)-vs[j].f.r)<eps)ans+=vs[j].s;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\nconst double eps = 1e-8;\n\nstruct P {\n  double x, y, z;\n  P() {}\n  P(double x, double y, double z) : x(x), y(y), z(z) {}\n};\n\nP operator + (const P &a, const P &b) {\n  return P(a.x + b.x, a.y + b.y, a.z + b.z);\n}\nP operator - (const P &a, const P &b) {\n  return P(a.x - b.x, a.y - b.y, a.z - b.z);\n}\nP operator * (const P &a, const double &d) {\n  return P(a.x * d, a.y * d, a.z * d);\n}\nP operator * (const double &d, const P &a) {\n  return a * d;\n}\nP operator / (const P &a, const double &d) {\n  return P(a.x / d, a.y / d, a.z / d);\n}\nP operator / (const double &d, const P &a) {\n  return a / d;\n}\nP& operator += (P &a, const P &b) {\n  return a = a + b;\n}\nP& operator -= (P &a, const P &b) {\n  return a = a - b;\n}\nP& operator *= (P &a, const double &d) {\n  return a = a * d;\n}\nP& operator /= (P &a, const double &d) {\n  return a = a / d;\n}\n\ndouble dot(P a, P b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ndouble norm(P a) {\n  return dot(a, a);\n}\n\ndouble abs(P a) {\n  return sqrt(norm(a));\n}\n\nP project(P s1, P s2, P p) {\n  P base = s2 - s1;\n  double t = dot(p - s1, base)/norm(base);\n  return s1 + base*t;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(p - project(s1, s2, p));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nint main() {\n  for(int N, Q; cin >> N >> Q; ) {\n    vector<P> ps(N);\n    vector<double> rs(N);\n    vector<lli> ls(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].x >> ps[i].y >> ps[i].z\n          >> rs[i] >> ls[i];\n    }\n    while(Q--) {\n      P s, d;\n      cin >> s.x >> s.y >> s.z\n          >> d.x >> d.y >> d.z;\n      lli sum = 0;\n      for(int i = 0; i < N; ++i) {\n        double dist = getDistanceSP(s, d, ps[i]);\n        if(dist + eps < rs[i]) sum += ls[i];\n      }\n      cout << sum << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y,z;\n  Point(double x=0,double y=0,double z=0):x(x),y(y),z(z){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y,z+p.z);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n  Point operator*(double k){ return Point(x*k,y*k,z*k);}\n  Point operator/(double k){ return Point(x/k,y/k,z/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : (y!=p.y ? y<p.y : z<p.z));}\n  bool operator==(Point p)const{ \n    return (fabs(x-p.x)<eps && fabs(y-p.y)<eps &&  fabs(z-p.z)<eps);}\n  \n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y+z*z);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass sphere{\npublic:\n  Point c;\n  double r;\n  sphere(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y+a.z*a.z);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y+a.z*b.z);}\nVector cross(Vector a,Vector b){ \n  Vector res;\n  res.x=(a.y*b.z)-(a.z*b.y);\n  res.y=(a.z*b.x)-(a.x*b.z);\n  res.z=(a.x*b.y)-(a.y*b.x);\n  return res;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nint main()\n{\n  int n,q;\n  double a,b,c,x,y,z,r,m;\n  vector<pair<sphere,int> > vs;\n\n  cin>>n>>q;\n  for(int i=0;i<n;i++){\n    cin>>a>>b>>c>>r>>m;\n    vs.push_back(mp(sphere(Point(a,b,c),r),m));\n  }\n\n  for(int i=0;i<q;i++){\n    cin>>a>>b>>c>>x>>y>>z;\n    Segment A(Point(a,b,c),Point(x,y,z));\n    int ans=0;\n    for(int j=0;j<n;j++){\n      // printf(\"%.10f %.10f\\n\",getDistanceSP(A,vs[j].f.c),vs[j].f.r);\n      if((getDistanceSP(A,vs[j].f.c)-vs[j].f.r)<eps)ans+=vs[j].s;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\nint N;\nint Q;\nint L[114];\ndouble X[114];\ndouble Y[114];\ndouble Z[114];\ndouble R[114];\n\nint main() {\n  scanf(\"%d%d\", &N, &Q);\n  for (int i=0; i<N; i++) {\n    scanf(\"%lf%lf%lf%lf%d\", &X[i], &Y[i], &Z[i], &R[i], &L[i]);\n  }\n\n  while (Q--) {\n    double sx, sy, sz;\n    double dx, dy, dz;\n    scanf(\"%lf%lf%lf%lf%lf%lf\", &sx, &sy, &sz, &dx, &dy, &dz);\n    int ans = 0;\n    for (int j=0; j<N; j++) {\n      double low = 0;\n      double high = 1;\n      for (int i=0; i<60; i++) {\n        double midl = (low*2+high)/3;\n        double midr = (low+high*2)/3;\n        double xl = sx*midl + dx*(1-midl);\n        double yl = sy*midl + dy*(1-midl);\n        double zl = sz*midl + dz*(1-midl);\n        double dl = (X[j]-xl)*(X[j]-xl) + (Y[j]-yl)*(Y[j]-yl) + (Z[j]-zl)*(Z[j]-zl);\n        double xr = sx*midr + dx*(1-midr);\n        double yr = sy*midr + dy*(1-midr);\n        double zr = sz*midr + dz*(1-midr);\n        double dr = (X[j]-xr)*(X[j]-xr) + (Y[j]-yr)*(Y[j]-yr) + (Z[j]-zr)*(Z[j]-zr);\n        if (dl > dr) low = midl;\n        else high = midr;\n      }\n\n      double mid = low;\n      double x = sx*mid + dx*(1-mid);\n      double y = sy*mid + dy*(1-mid);\n      double z = sz*mid + dz*(1-mid);\n      double d = (X[j]-x)*(X[j]-x) + (Y[j]-y)*(Y[j]-y) + (Z[j]-z)*(Z[j]-z);\n      if (d <= R[j]*R[j]) ans += L[j];\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ndouble dist(double a,double b,double c){\n\treturn sqrt(a*a+b*b+c*c);\n}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvd boll(n,vd(5));\n\trep(i,n)rep(j,5)cin>>boll[i][j];\n\twhile(m--){\n\t\tint out=0;\n\t\tdouble a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\trep(i,n){\n\t\t\tvd q{boll[i][0],boll[i][1],boll[i][2]};\n\t\t\tdouble A=d-a,B=e-b,C=f-c;\n\t\t\tdouble ssita=sqrt(pow(B*(q[2]-c)-C*(q[1]-b),2)+pow(C*(q[0]-a)-A*(q[2]-c),2)+pow(A*(q[1]-b)-B*(q[0]-a),2))/\n\t\t\t\tdist(A,B,C)/dist(q[0]-a,q[1]-b,q[2]-c);\n\t\t\tdouble dis=dist(q[0]-a,q[1]-b,q[2]-c)*ssita;\n\t\t\tif(dis<boll[i][3]+EPS){\n\t\t\t\tdouble dot1=A*(q[0]-a)+B*(q[1]-b)+C*(q[2]-c);\n\t\t\t\tdouble dot2=A*(q[0]-d)+B*(q[1]-e)+C*(q[2]-f);\n//\t\t\t\tcout<<i<<\" \"<<dot1<<\" \"<<dot2<<endl;\n\t\t\t\tif(dot1>=0&&dot2<=0)out+=boll[i][4];\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point3 {\n    real x, y, z;\n    Point3& operator+=(const Point3 a) { x += a.x; y += a.y; z += a.z;  return *this; }\n    Point3& operator-=(const Point3 a) { x -= a.x; y -= a.y; z -= a.z; return *this; }\n    Point3 operator+(const Point3 a) const {return Point3(*this) += a; }\n    Point3 operator-(const Point3 a) const {return Point3(*this) -= a; }\n    explicit Point3(real a = 0, real b = 0, real c = 0) : x(a), y(b), z(c) {};\n};\n\n\ninline real dot(Point3 a, Point3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\ninline Point3 cross(Point3 a, Point3 b){\n    return Point3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n}\ninline real abs(Point3 a){ return sqrt(dot(a, a)); }\n\nstruct Segment {\n    Point3 a, b;\n    Segment(Point3 x, Point3 y) : a(x), b(y) {};\n};\n\n\ndouble distance(Segment l, Point3 c){\n    if(dot(l.b-l.a, c-l.a) < 0) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) < 0) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nstruct Sphere{\n    Point3 c;\n    double r;\n    Sphere(){};\n    Sphere(Point3 c, double r): c(c), r(r){};\n};\n\nbool intersect(Segment s,Sphere c){\n    double d=distance(s,c.c);\n    return d <= c.r;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<Sphere> v(n);\n    vector<ll> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i].c.x >> v[i].c.y >> v[i].c.z >> v[i].r >> x[i];\n    }\n    for (int i = 0; i < q; ++i) {\n        double a, b, c, d, e, f;\n        cin >> a >> b >> c >> d >> e >> f;\n        Segment S(Point3(a, b, c), Point3(d, e, f));\n        uint64_t ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if(intersect(S, v[j])) ans += x[j];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  int x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  int r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2*area)/abs(l.second - l.first);\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  if(cosa < 0) return abs(p - l.first);\n  if(cosb < 0) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].c.x >> p[i].c.y >> p[i].c.z >> p[i].r >> p[i].l;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    int ans = 0;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      if(dis(l, p[j].c) <= p[j].r){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nstruct po{int a,b,c,r,l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n \n  int n,q;\n  cin >> n >>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].a>>ball[i].b>>ball[i].c>>ball[i].r>>ball[i].l;\n  \n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].a,ball[j].b,ball[j].c});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].a,ball[j].b,ball[j].c});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = 2*S/dis[0];\n      if(h <= ball[j].r) ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    \n    typedef double real;\n    typedef long long ll;\n\n    const real EPS = 1e-12;\n\n    struct Point {\n        real x, y, z;\n        Point() {}\n        Point(real x, real y, real z) : x(x), y(y), z(z) {}\n        Point operator-() const { return Point(-x, -y, -z); }\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n        Point operator-(const Point& p) const { return (*this) + (-p); }\n        Point operator*(real k) const { return Point(x * k, y * k, z * k); }\n        Point operator/(real k) const { return (*this) * (1.0 / k); }\n    };\n    real dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\n    real norm(const Point& a) { return sqrt(dot(a, a)); }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y >> p.z; }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n\n    Point projection(const Line& l, const Point& p) {\n        Point u = (p - l.a), v = (l.b - l.a);\n        return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n    }\n\n    real distance(const Line& l, const Point& p) {\n        Point q = projection(l, p);\n        return norm(p - q);\n    }\n\n    bool intersect(real r, const Line& l, const Point& p) {\n        if (distance(l, p) > r) return false;\n        Point u = p - l.a, v = l.b - l.a;\n        real theta = dot(u, v) / (norm(u) * norm(v));\n        if (theta < 0) return false;\n        u = p - l.b, v = l.a - l.b;\n        theta = dot(u, v) / (norm(u) * norm(v));\n        if (theta < 0) return false;\n        return true;\n    }\n\n    int N, Q;\n    vector<Point> P;\n    vector<real> R;\n    vector<ll> L;\n    void solve() {\n        cin >> N >> Q;\n        P.clear(); P.resize(N);\n        R.clear(); R.resize(N);\n        L.clear(); L.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> R[i] >> L[i];\n        }\n        for (int q = 0; q < Q; q++) {\n            Point s, t;\n            cin >> s >> t;\n            Line l(s, t);\n            ll ans = 0;\n            for (int i = 0; i < N; i++) {\n                if (intersect(R[i], l, P[i])) {\n                    ans += L[i];\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n     \nusing namespace std;\n     \n#define EPS 10e-9\n     \nstruct vertex {\n    long long int c[3];\n};\n     \nstruct sphere {\n    vertex v;\n    long long int l;\n    long double r;\n};\n     \n#define vect vertex\n     \nlong double norm( vect v ) {\n    long double sum = 0.0;\n    for( int i = 0; i < 3; i++ )\n    \tsum += v.c[i] * v.c[i];\n    return sum;\n}\n     \nint main(void){\n    int N, Q;\n    cin >> N >> Q;\n     \n    vector< sphere > obstacle( N );\n    vector< vertex > red( Q );\n    vector< vertex > blue( Q );\n     \n    for( int i = 0; i < N; i++ ) {\n    \tfor( int j = 0; j < 3; j++ )\n    \t\tcin >> obstacle[i].v.c[j];\n    \tcin >> obstacle[i].r;\n    \tcin >> obstacle[i].l;\n    }\n    for( int i = 0; i < Q; i++ ) {\n    \tfor( int j = 0; j < 3; j++ )\n    \t\tcin >> red[i].c[j];\n    \tfor( int j = 0; j < 3; j++ )\n    \t\tcin >> blue[i].c[j];\n    \t\t\n    }\n     \n    //赤いオブジェと青いオブジェを結ぶ線分と障害物の中心との距離が障害物の半径より小さいかどうかを調べればよい\n     \n    for( int i = 0; i < Q; i++ ) {\n    \tlong long int sum = 0;\n\t\tvect v;\n\t    for( int j = 0; j < 3; j++ )\n\t\t\tv.c[j] = blue[i].c[j] - red[i].c[j];\n    \tfor( int j = 0; j < N; j++ ) {\n\t\t\tif( norm( v ) > EPS ) {\n    \t\t\tlong double t = 0.0;\n    \t\t\tfor( int k = 0; k < 3; k++ )\n    \t\t\t\tt += v.c[k] * ( obstacle[j].v.c[k] - red[i].c[k] );\n    \t\t\tt /= norm( v );\n    \t\t\tlong double dist = 0.0;\n    \t\t\tfor( int k = 0; k < 3; k++ ) {\n    \t\t\t\tlong double ld = red[i].c[k] + t * ( long double ) ( v.c[k] ) - obstacle[j].v.c[k];\n    \t\t\t\tdist += ld * ld;\n    \t\t\t}\t\t\n    \t\t\tdist = sqrt( dist );\n\t\t\t\tlong double distr = 0.0, distb = 0.0;\n\t\t\t\tfor( int k = 0; k < 3; k++ ) {\n\t\t\t\t\tdistr += ( red[i].c[k] - obstacle[j].v.c[k] ) * ( red[i].c[k] - obstacle[j].v.c[k] );\n\t\t\t\t\tdistb += ( blue[i].c[k] - obstacle[j].v.c[k] ) * ( blue[i].c[k] - obstacle[j].v.c[k] );\n\t\t\t\t}\n\t\t\t\tif( t < EPS ) dist = sqrt( distr );\n\t\t\t\tif( t > 1 + EPS ) dist = sqrt( distb );\n    \t\t\tif( dist <= obstacle[j].r + EPS )\n    \t\t\t\tsum += obstacle[j].l;\n\t\t\t} else {\n\t\t\t}\n    \t}\n    \tcout << sum << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\ntypedef long long int ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  if(dot(v,c)<=0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  \n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    Point p,b;\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble r[55], val[55];\nPoint3D po[55];\nSegment3D seg[55];\nsigned main(void)\n{\n  int n, q;\n  cin >> n >> q;\n  REP(i, n) cin >> po[i] >> r[i] >> val[i];\n  REP(i, q) cin >> seg[i];\n\n  REP(i, q) {\n    double ret = 0;\n    REP(j, n) {\n      if(getDistanceSP(seg[i], po[j]) <= r[j]) ret += val[j];\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef long long lint;\nconst double EPS = 1e-9;\n\ntypedef struct Point {\n\tdouble x, y, z;\n\tPoint (double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}\n\tPoint operator + (const Point& a) const { return Point(x + a.x, y + a.y, z + a.z); }\n\tPoint operator - (const Point& a) const { return Point(x - a.x, y - a.y, z - a.z); }\n\tPoint operator * (double d) const { return Point(x * d, y * d, z * d); }\n} Vector;\n\nstruct Object {\n\tPoint p; double r; lint l;\n\tObject(Point p_, double r_, lint l_) : p(p_), r(r_), l(l_) {}\n};\n\ndouble sqr(double x) { return x * x; }\ndouble distance(const Point& a, const Point& b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y) + sqr(a.z - b.z)); }\n\nbool collision(const Object& obj, const Point& a, const Point& b) {\n\tVector unit = b - a;\n\t\n\tdouble lb = 0.0, ub = 10000.0;\n\t\n\tfor_(i,0,500) {\n\t\tdouble lft = (lb * 2. + ub) / 3., rgt = (lb + ub * 2.) / 3.;\n\t\tPoint pl = a + unit * lft, pr = a + unit * rgt;\n\t\tdouble dl = distance(obj.p, pl), dr = distance(obj.p, pr);\n\t\tif (dl < dr) ub = rgt;\n\t\telse lb = lft;\n\t}\n\t\n\treturn distance(obj.p, a + unit * lb) < obj.r + EPS;\n}\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\t\n\tvector< Object > obj;\n\t\n\tfor_(i,0,N) {\n\t\tdouble x, y, z, r; lint l;\n\t\tcin >> x >> y >> z >> r >> l;\n\t\tobj.push_back(Object(Point(x, y, z), r, l));\n\t}\n\t\n\tfor_(i,0,Q) {\n\t\tdouble x1, y1, z1, x2, y2, z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tPoint red(x1, y1, z1), blue(x2, y2, z2);\n\t\n\t\tlint ans = 0;\n\t\tfor_(j,0,N) if (collision(obj[j], red, blue)) ans += obj[j].l;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define show_bits(b, s) if(opt_debug) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\n// Geometry <3 {{{\n\ntemplate<typename T>\nclass Vector3D {\n\tpublic:\n\t\tT x, y, z;\n\t\tVector3D(T _x, T _y, T _z): x(_x), y(_y), z(_z) {\n\t\t}\n\n\t\tT abs() {\n\t\t\treturn sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n\t\t}\n\n\t\tT dot(Vector3D& rhs) {\n\t\t\treturn x * rhs.x + y * rhs.y + z * rhs.z;\n\t\t}\n\n\t\t// Add vector\n\t\tVector3D<T> operator+(const Vector3D& rhs) const {\n\t\t\treturn Vector3D<T>(x + rhs.x, y + rhs.y, z + rhs.z);\n\t\t}\n\n\t\t// Subtract vecrtor\n\t\tVector3D<T> operator-(const Vector3D& rhs) const {\n\t\t\treturn Vector3D<T>(x - rhs.x, y - rhs.y, z - rhs.z);\n\t\t}\n\n\t\t// Multiply by scala value\n\t\ttemplate<typename Scala>\n\t\tVector3D<T> operator*(const Scala rhs) const {\n\t\t\treturn Vector3D<T>(x * rhs, y * rhs, z * rhs);\n\t\t}\n};\ntemplate<typename T>\nostream& operator<<(ostream& out, const Vector3D<T>& v) {\n\treturn out << \"(\" << v.x << \", \" << v.y << \", \" << v.z << \")\";\n}\n\nclass Sphere {\n\tint x, y, z, r;\n\tpublic:\n\t\tSphere(int _x, int _y, int _z, int _r) : x(_x), y(_y), z(_z), r(_r) {\n\t\t}\n};\n\nclass GeometryUtil {\n\tpublic:\n\t\tbool eql(double a, double b) { return abs(a - b) < EPS; }\n\t\tbool lt(double a, double b) { return b - a >= EPS; }\n\t\tbool lte(double a, double b) { return lt(a, b) || eql(a, b); }\n\t\tbool eql(P a, P b) { return eql(a.Y, b.Y) && eql(a.X, b.X); }\n\t\tGeometryUtil();\n};\n\nconst GeometryUtil G();\n\n// }}}\n\nclass Obstacle {\n\tpublic:\n\t\tint x, y, z, r;\n\t\tULL magic;\n\t\tObstacle(int _x, int _y, int _z, int _r, ULL _magic) : x(_x), y(_y), z(_z), r(_r), magic(_magic) {\n\t\t}\n};\nostream& operator<<(ostream& out, const Obstacle& o) {\n\treturn out << \"((\" << o.x << \", \" << o.y << \", \" << o.z << \"), \" << o.r << \", \" << o.magic << \")\";\n}\n\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/2.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint N, Q; cin >> N >> Q;\n\tvector<Obstacle> obstacles;\n\tREP (i, N) {\n\t\tint x, y, z, r; ULL l; cin >> x >> y >> z >> r >> l;\n\t\tobstacles.PB(Obstacle(x, y, z, r, l));\n\t}\n\n\tREP (t, Q) {\n\t\tint x, y, z; cin >> x >> y >> z;\n\t\tVector3D<double> red(x, y, z);\n\t\tcin >> x >> y >> z;\n\t\tVector3D<double> blue(x, y, z);\n\t\tULL ans = 0;\n\t\tREP (i, N) {\n\t\t\tObstacle o = obstacles[i];\n\t\t\tdump(red);\n\t\t\tdump(blue);\n\t\t\tdump(o);\n\t\t\t// Move vectors so that the center of the obstacle become the origin\n\t\t\tVector3D<double> s = red - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> e = blue - Vector3D<double>(o.x, o.y, o.z);\n\t\t\tVector3D<double> v = e - s;\n\t\t\to.x = o.y = o.z = 0;\n\t\t\tdump(s);\n\t\t\tdump(e);\n\t\t\tdump(v);\n\t\t\tdump(o);\n\n\t\t\tdump(s.dot(v));\n\t\t\tdouble x = - (s.dot(v) / pow((double)(v.abs()), 2));\n\t\t\tdump(x);\n\t\t\tVector3D<double> nearest = s + v * x;\n\t\t\tdump(nearest);\n\t\t\tif (nearest.abs() <= o.r + EPS) {\n\t\t\t\tans += o.magic;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Point\n{\n    double x,y,z;\n    double norm2(){ return x*x+y*y+z*z; }\n};\ntypedef Point Vector;\n\nstruct Object\n{\n    Point c;\n    int r;\n    ll cost;\n};\n\ndouble dist(Point p, Point q)\n{\n    return sqrt((p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y)+(p.z-q.z)*(p.z-q.z));\n}\n\nint main()\n{\n    int n,Q;\n    scanf(\" %d %d\", &n, &Q);\n    vector<Object> a(n);\n    rep(i,n)\n    {\n        double x,y,z;\n        int r;\n        ll l;\n        scanf(\" %lf %lf %lf %d %lld\",&x,&y,&z,&r,&l);\n        a[i]=Object{Point{x,y,z},r,l};\n    }\n    while(Q--)\n    {\n        double sx,sy,sz,dx,dy,dz;\n        scanf(\" %lf %lf %lf %lf %lf %lf\",&sx,&sy,&sz,&dx,&dy,&dz);\n\n        Vector v=Vector{dx-sx,dy-sy,dz-sz};\n        ll ans=0;\n        rep(i,n)\n        {\n            double t=(double)(v.x*(a[i].c.x-sx)+v.y*(a[i].c.y-sy)+v.z*(a[i].c.z-sz))/(v.norm2());\n\n            if(0<=t && t<=1)\n            {\n                Point h=Point{sx+t*v.x,sy+t*v.y,sz+t*v.z};\n                if(dist(a[i].c,h)<=a[i].r) ans+=a[i].cost;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble EPS=1e-9;\ndouble x[60];\ndouble y[60];\ndouble z[60];\ndouble r[60];\nlong long d[60];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lf%lf%lf%lf%lld\",x+i,y+i,z+i,r+i,d+i);\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tdouble ax,ay,az,bx,by,bz;\n\t\tscanf(\"%lf%lf%lf%lf%lf%lf\",&ax,&ay,&az,&bx,&by,&bz);\n\t\tlong long ret=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tdouble left=0;\n\t\t\tdouble right=1;\n\t\t\tdouble val=999999999;\n\t\t\tfor(int k=0;k<100;k++){\n\t\t\t\tdouble m1=left*2/3+right/3;\n\t\t\t\tdouble m2=left/3+right*2/3;\n\t\t\t\tdouble dx1=x[j]-(m1*ax+(1.0-m1)*bx);\n\t\t\t\tdouble dy1=y[j]-(m1*ay+(1.0-m1)*by);\n\t\t\t\tdouble dz1=z[j]-(m1*az+(1.0-m1)*bz);\n\t\t\t\tdouble dx2=x[j]-(m2*ax+(1.0-m2)*bx);\n\t\t\t\tdouble dy2=y[j]-(m2*ay+(1.0-m2)*by);\n\t\t\t\tdouble dz2=z[j]-(m2*az+(1.0-m2)*bz);\n\t\t\t\t\n\t\t\t\tdouble d1=sqrt(dx1*dx1+dy1*dy1+dz1*dz1);\n\t\t\t\tdouble d2=sqrt(dx2*dx2+dy2*dy2+dz2*dz2);\n\t\t\t\tval=min(val,min(d1,d2));\n\t\t\t\tif(d1<d2){\n\t\t\t\t\tright=m2;\n\t\t\t\t}else left=m1;\n\t\t\t}\n\t\t\tif(val<r[j]+EPS){\n\t\t\t\tret+=d[j];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y,z;\n  Point(double x=0,double y=0,double z=0):x(x),y(y),z(z){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y,z+p.z);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n  Point operator*(double k){ return Point(x*k,y*k,z*k);}\n  Point operator/(double k){ return Point(x/k,y/k,z/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : (y!=p.y ? y<p.y : z<p.z));}\n  bool operator==(Point p)const{ \n    return (fabs(x-p.x)<eps && fabs(y-p.y)<eps &&  fabs(z-p.z)<eps);}\n  \n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y+z*z);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass sphere{\npublic:\n  Point c;\n  double r;\n  sphere(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y+a.z*a.z);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y+a.z*b.z);}\nVector cross(Vector a,Vector b){ \n  Vector res;\n  res.x=(a.y*b.z)-(a.z*b.y);\n  res.y=(a.z*b.x)-(a.x*b.z);\n  res.z=(a.x*b.y)-(a.y*b.x);\n  return res;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1))/abs(l.p2-l.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nint main()\n{\n  int n,q;\n  double a,b,c,x,y,z,r,m;\n  vector<pair<sphere,long long> > vs;\n\n  cin>>n>>q;\n  for(int i=0;i<n;i++){\n    cin>>a>>b>>c>>r>>m;\n    vs.push_back(mp(sphere(Point(a,b,c),r),m));\n  }\n\n  for(int i=0;i<q;i++){\n    cin>>a>>b>>c>>x>>y>>z;\n    Segment A(Point(a,b,c),Point(x,y,z));\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      // printf(\"%.10f %.10f\\n\",getDistanceSP(A,vs[j].f.c),vs[j].f.r);\n      if((getDistanceSP(A,vs[j].f.c)-vs[j].f.r)<eps)ans+=vs[j].s;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \"\\n\"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nvector<int> cross_product(vector<int>a,vector<int>b) {\n    return {a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]};\n}\ndouble dot_product(vector<int>a,vector<int>b) {\n    return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];\n}\ndouble len(vector<int>a) {\n    return sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);\n}\ndouble dist_line_point(vector<int>a,vector<int>b,vector<int>c) {\n    vector<int> ab={b[0]-a[0],b[1]-a[1],b[2]-a[2]};\n    vector<int> ac={c[0]-a[0],c[1]-a[1],c[2]-a[2]};\n    vector<int> ba={a[0]-b[0],a[1]-b[1],a[2]-b[2]};\n    vector<int> bc={c[0]-b[0],c[1]-b[1],c[2]-b[2]};\n    if(dot_product(ab,ac)<0) return INF;\n    if(dot_product(ba,bc)<0) return INF;\n    return len(cross_product(ab,ac))/len(ab);\n}\nstruct obstacle {\n    vector<int> p;\n    int r;\n    int l;\n    obstacle():p(3){}\n};\nsigned main() {\n    int N,Q;\n    cin>>N>>Q;\n    vector<obstacle> obs(N);\n    REP(i,N) {\n        cin>>obs[i].p[0]>>obs[i].p[1]>>obs[i].p[2]>>obs[i].r>>obs[i].l;\n    }\n    while(Q--) {\n        vector<int> a(3),b(3);\n        cin>>a[0]>>a[1]>>a[2]>>b[0]>>b[1]>>b[2];\n        int ans=0;\n        REP(i,N) {\n            // dump(i,dist_line_point(a,b,obs[i].p),obs[i].r);\n            if(dist_line_point(a,b,obs[i].p)<=obs[i].r) {\n                ans+=obs[i].l;\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) gsort(ALL(v))\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); --i)\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\nconst double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(sq(b) /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n// #define DEBUG\n// #define DEBUG_CASE_NUM 3\n\nvoid solve() {\n    ll N, Q;\n    cin >> N >> Q;\n\n    double x[N][3], r[N], m[N];\n    FOR(k, 0, N - 1) {\n        FOR(i, 0, 2) {\n            cin >> x[k][i];\n        }\n        cin >> r[k] >> m[k];\n    }\n\n    FOR(_, 1, Q) {\n        double rx[3], bx[3];\n        FOR(i, 0, 2) {\n            cin >> rx[i];\n        }\n        FOR(i, 0, 2) {\n            cin >> bx[i];\n        }\n\n        double dx[2][3];\n        double ans = 0;\n        FOR(k, 0, N - 1) {\n            double norm[2] = {0}, inner = 0;\n            FOR(i, 0, 2) {\n                dx[0][i] = rx[i] - bx[i];\n                dx[1][i] = rx[i] - x[k][i];\n                FOR(j, 0, 1) {\n                    norm[j] += sq(dx[j][i]);\n                }\n                inner += dx[0][i] * dx[1][i];\n            }\n\n            double d = sqrt(norm[1]) * sqrt(1 - sq(inner) / (norm[0] * norm[1]));\n            // cout << d << endl;\n\n            if (d <= r[k] + EPS) {\n                ans += m[k];\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // cout << fixed << setprecision(10);\n\n#ifdef DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    FOR(_, 1, DEBUG_CASE_NUM) {\n        solve();\n        cout << \"++++++++++\" << endl;\n    }\n#else\n    solve();\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll in(int a, int b, int c, int d, int e, int f) {\n\treturn a*d + b*e + c*f;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvl x(n), y(n), z(n),r(n),l(n);\n\tREP(i, n)cin >> x[i] >> y[i] >> z[i] >>r[i] >>l[i];\n\tint sx, sy, sz, dx, dy, dz;\n\tREP(i, q) {\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tint vx = dx - sx, vy = dy - sy, vz = dz - sz;\n\t\tll ans = 0;\n\t\tREP(j, n) {\n\t\t\tint a = sx - x[j], b = sy - y[j], c = sz - z[j];\n\t\t\tll D = in(a, b, c, vx, vy, vz)*in(a, b, c, vx, vy, vz) - in(vx, vy, vz, vx, vy, vz)*(in(a, b, c, a, b, c) - r[j] * r[j]);\n\t\t\tif (D < 0)continue;\n\t\t\tdouble t1 = (-in(a, b, c, vx, vy, vz) + sqrt(D)) / in(vx, vy, vz, vx, vy, vz), t2 = (-in(a, b, c, vx, vy, vz) - sqrt(D)) / in(vx, vy, vz, vx, vy, vz);\n\t\t\tif ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t1 <= 1))ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll in(int a, int b, int c, int d, int e, int f) {\n\treturn a*d + b*e + c*f;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvl x(n), y(n), z(n),r(n),l(n);\n\tREP(i, n)cin >> x[i] >> y[i] >> z[i] >>r[i] >>l[i];\n\tint sx, sy, sz, dx, dy, dz;\n\tREP(i, q) {\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tint vx = dx - sx, vy = dy - sy, vz = dz - sz;\n\t\tll ans = 0;\n\t\tREP(j, n) {\n\t\t\tint a = sx - x[j], b = sy - y[j], c = sz - z[j];\n\t\t\tll D = in(a, b, c, vx, vy, vz)*in(a, b, c, vx, vy, vz) - in(vx, vy, vz, vx, vy, vz)*(in(a, b, c, a, b, c) - r[j] * r[j]);\n\t\t\tif (D >=0 && (-in(a,b,c, vx, vy, vz) > EPS + sqrt(D)|| -in(a, b, c, vx, vy, vz) > EPS - sqrt(D))))ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS 1e-7\nusing namespace std;\n\nint n, q;\n\nint x[50], y[50], z[50], r[50];\nlong long l[50];\n\nint main(){\n\tcin >> n >> q;\n\trep(i,n) scanf(\"%d%d%d%d%lld\",x+i,y+i,z+i,r+i,l+i);\n\trep(i,q){\n\t\tint sx, sy, sz, dx, dy, dz;\n\t\tscanf(\"%d%d%d%d%d%d\",&sx,&sy,&sz,&dx,&dy,&dz);\n\t\tlong long ans = 0;\n\t\trep(u,n){\n\t\t\tdouble s = 0.0, e = 1.0, smid, emid;\n\t\t\tdouble sd, ed;\n\t\t\tsd = sqrt(pow(sx-x[u],2.0)+pow(sy-y[u],2.0)+pow(sz-z[u],2.0));\n\t\t\ted = sqrt(pow(dx-x[u],2.0)+pow(dy-y[u],2.0)+pow(dz-z[u],2.0));\n\t\t\trep(j,1000){\n\t\t\t\tsmid = s + (e-s)/3;\n\t\t\t\temid = e - (e-s)/3;\n\t\t\t\tdouble sxx = sx + smid*(dx-sx);\n\t\t\t\tdouble syy = sy + smid*(dy-sy);\n\t\t\t\tdouble szz = sz + smid*(dz-sz);\n\t\t\t\tdouble exx = sx + emid*(dx-sx);\n\t\t\t\tdouble eyy = sy + emid*(dy-sy);\n\t\t\t\tdouble ezz = sz + emid*(dz-sz);\n\t\t\t\tif(sqrt(pow(sxx-x[u],2.0)+pow(syy-y[u],2.0)+pow(szz-z[u],2.0)) > sqrt(pow(exx-x[u],2.0)+pow(eyy-y[u],2.0)+pow(ezz-z[u],2.0))){\n\t\t\t\t\tsd = sqrt(pow(sxx-x[u],2.0)+pow(syy-y[u],2.0)+pow(szz-z[u],2.0));\n\t\t\t\t\ts = smid;\n\t\t\t\t} else{\n\t\t\t\t\ted = sqrt(pow(exx-x[u],2.0)+pow(eyy-y[u],2.0)+pow(ezz-z[u],2.0));\n\t\t\t\t\te = emid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sd < r[u]+EPS) ans += l[u];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld eps = 1e-11;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef valarray<ld> Point;\nPoint make_point(ld x, ld y, ld z) {\n\tPoint p(3);\n\tp[0] = x; p[1] = y; p[2] = z;\n\treturn p;\n}\n\nld dot(const Point &a, const Point &b) {\n\treturn (a * b).sum();\n}\n\nPoint cross(const Point &a, const Point &b) {\n\treturn a.cshift(+1) * b.cshift(-1) - a.cshift(-1) * b.cshift(+1);\n}\n\nld norm(const Point &a) { return dot(a, a); }\nld dist(const Point &a) { return sqrt(norm(a)); }\n\n// Line\n\nstruct Line { Point a, b; };\n\nbool is_in_segment(Line l, Point p) {\n\treturn abs(dist(l.a - p) + dist(l.b - p) - dist(l.a - l.b)) < eps;\n}\n\nPoint project_lp(Line l, Point p) {\n\tPoint point = l.a, vec = l.b - l.a;\n\treturn point + dot(p - point, vec) / norm(vec) * vec;\n}\n\nld distance_lp(Line l, Point p) {\n\treturn dist(p - project_lp(l, p));\n}\n\nld distance_sp(Line l, Point p) {\n\tPoint proj = project_lp(l, p);\n\tif (dist(l.a - proj) + dist(l.b - proj) < dist(l.b - l.a) + eps)\n\t\treturn dist(p - proj);\n\telse\n\t\treturn min(dist(p - l.a), dist(p - l.b));\n}\n\nstruct Sphere { Point p; ld r; ll l; };\n\nint main()\n{\n\tint n, q; cin >> n >> q;\n\tvector<Sphere> v;\n\tREP(i, n)\n\t{\n\t\tld x, y, z, r;\n\t\tll l; cin >> x >> y >> z >> r >> l;\n\t\tv.emplace_back(Sphere{ make_point(x,y,z),r,l });\n\t}\n\tREP(i, q)\n\t{\n\t\tll ans = 0;\n\t\tld x[2], y[2], z[2];\n\t\tREP(j, 2) cin >> x[j] >> y[j] >> z[j];\n\t\tLine l{ make_point(x[0], y[0], z[0]), make_point(x[1], y[1], z[1]) };\n\t\tREP(j, n)\n\t\t{\n\t\t\tld d = distance_sp(l, v[j].p);\n\t\t\tif (v[j].r - d > -eps) ans += v[j].l;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\ntypedef struct {\n    double x, y, z;\n} P;\n\ndouble dot(P a, P b)\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nP diff(P f, P t)\n{\n    return P{ t.x - f.x, t.y - f.y, t.z - f.z };\n}\n\nP mul(P a, double s)\n{\n    return P{ a.x*s, a.y*s, a.z*s };\n}\n\nconst double EPS = 1e-8;\n\nint main()\n{\n    int n, q; cin >> n >> q;\n    vector<P> p(n);\n    vector<double> r(n);\n    vector<ll> l(n);\n    loop (n, i) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\n    loop (q, i) {\n        P s, t;\n        cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n        P v = diff(s, t);\n        double d = pow(dot(v, v), 0.5);\n        ll ans = 0;\n        loop (n, j) {\n            P w = diff(s, p[j]);\n            P nv = mul(v, dot(w, v) / d / d);\n            P nw = diff(nv, w);\n            double R = pow(dot(nw, nw), 0.5);\n            if (R < r[j] + EPS) ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersectSC(Segment3D s,Sphere c){\n  double d=getDistanceSP(s,c.c);\n  if(d>c.r) return 0;\n  return !((abs(s.p1-c.c)<=c.r)&&(abs(s.p2-c.c)<=c.r));\n}\n\nint val[55];\nSphere sp[55];\nSegment3D seg[55];\nsigned main(void)\n{\n  int n, q;\n  cin >> n >> q;\n  REP(i, n) cin >> sp[i] >> val[i];\n  REP(i, q) cin >> seg[i];\n\n  REP(i, q) {\n    int ret = 0;\n    REP(j, n) if(intersectSC(seg[i], sp[j])) ret += val[j];\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint check(double x1, double y1, double z1, double x2, double y2, double z2, double x3, double y3, double z3, double r){\n    double abx = x2 - x1;\n    double aby = y2 - y1;\n    double abz = z2 - z1;\n    double acx = x3 - x1;\n    double acy = y3 - y1;\n    double acz = z3 - z1;\n    double AB = sqrt(abx * abx + aby * aby + abz * abz);\n    double AC = sqrt(acx * acx + acy * acy + acz * acz);\n    double dot = (abx * acx + aby * acy + abz * acz);\n    double rad = acos(dot / AB / AC);\n    if(dot < 0)return 0;\n    if(AC * cos(rad) > AB)return 0;\n\n    double L = AC * sin(rad);\n    if(L - r <= 1e-9)return 1;\n    return 0;\n}\n\nint main(){\n\n    int N, Q;\n    cin >> N >> Q;\n    double X[50], Y[50], Z[50], R[50];\n    ll L[50];\n    for(int i = 0; i < N; i++){\n        cin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n    }\n    for(int i = 0; i < Q; i++){\n        ll ans = 0;\n        double x1, y1, z1;\n        cin >> x1 >> y1 >> z1;\n        double x2, y2, z2;\n        cin >> x2 >> y2 >> z2;\n        for(int j = 0; j < N; j++){\n            int f = check(x1, y1, z1, x2, y2, z2, X[j], Y[j], Z[j], R[j]);\n            if(f){\n                ans += L[j];\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef valarray<double> Point;\n\ndouble dot(const Point &a, const Point &b){\n\treturn (a * b).sum();\n}\n\ndouble dist2(const Point &a, const Point &b){\n\treturn dot(a - b, a - b);\n}\n\nint n, q;\nPoint p[50];\ndouble r[50];\nlong long l[50];\nPoint s, t;\n\nlong long calc()\n{\n\tstatic const double EPS = 1e-12;\n\tPoint v = (t - s);\n\tlong long res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tdouble left = 0.0, right = 1.0;\n\t\tfor (int j = 0; j < 100; j++){\n\t\t\tdouble mid = (left + right) / 2;\n\t\t\tdouble d1 = dist2(s + v * mid, p[i]);\n\t\t\tdouble d2 = dist2(s + v * (mid + EPS), p[i]);\n\t\t\tif (d1 > d2) left = mid;\n\t\t\telse right = mid;\n\t\t}\n\t\t//printf(\"%.20f\\n\", dist2(s + v * left, p[i]));\n\t\tif (dist2(s + v * left, p[i]) < r[i] * r[i] + 1e-4) res += l[i];\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tdouble x, y, z;\n\tscanf(\"%d %d\", &n, &q);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\", &x, &y, &z, r + i, l + i);\n\t\tp[i] = {x, y, z};\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\ts = {x, y, z};\n\t\tscanf(\"%lf %lf %lf\", &x, &y, &z);\n\t\tt = {x, y, z};\n\t\tprintf(\"%lld\\n\", calc());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define EPS 1e-8\n\nint N;\nint Q;\nint L[114];\ndouble X[114];\ndouble Y[114];\ndouble Z[114];\ndouble R[114];\n\nint main() {\n  scanf(\"%d%d\", &N, &Q);\n  for (int i=0; i<N; i++) {\n    scanf(\"%lf%lf%lf%lf%d\", &X[i], &Y[i], &Z[i], &R[i], &L[i]);\n  }\n\n  while (Q--) {\n    double sx, sy, sz;\n    double dx, dy, dz;\n    scanf(\"%lf%lf%lf%lf%lf%lf\", &sx, &sy, &sz, &dx, &dy, &dz);\n    int ans = 0;\n    for (int j=0; j<N; j++) {\n      double low = 0;\n      double high = 1;\n      for (int i=0; i<60; i++) {\n        double midl = (low*2+high)/3;\n        double midr = (low+high*2)/3;\n        double xl = sx*midl + dx*(1-midl);\n        double yl = sy*midl + dy*(1-midl);\n        double zl = sz*midl + dz*(1-midl);\n        double dl = (X[j]-xl)*(X[j]-xl) + (Y[j]-yl)*(Y[j]-yl) + (Z[j]-zl)*(Z[j]-zl);\n        double xr = sx*midr + dx*(1-midr);\n        double yr = sy*midr + dy*(1-midr);\n        double zr = sz*midr + dz*(1-midr);\n        double dr = (X[j]-xr)*(X[j]-xr) + (Y[j]-yr)*(Y[j]-yr) + (Z[j]-zr)*(Z[j]-zr);\n        if (dl > dr) low = midl;\n        else high = midr;\n      }\n\n      double mid = low;\n      double x = sx*mid + dx*(1-mid);\n      double y = sy*mid + dy*(1-mid);\n      double z = sz*mid + dz*(1-mid);\n      double d = (X[j]-x)*(X[j]-x) + (Y[j]-y)*(Y[j]-y) + (Z[j]-z)*(Z[j]-z);\n      if (-EPS <= R[j]*R[j]-d) ans += L[j];\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi M_PI\n#define EPS 1e-10\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ndouble dot(double ax, double ay, double az, double bx, double by, double bz){\n    return ax * bx + ay * by + az * bz;\n}\n\ndouble norm(double x, double y, double z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<double> x(n), y(n), z(n), r(n);\n    VI l(n);\n    REP(i,n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n    while (q--){\n        double sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        int ans = 0;\n        REP(i,n) {\n            if (dot(dx-sx,dy-sy,dz-sz,x[i]-sx,y[i]-sy,z[i]-sz) < 0) continue;\n            if (dot(dx-sx,dy-sy,dz-sz,x[i]-dx,y[i]-dy,z[i]-dz) > 0) continue;\n            double cx, cy, cz;\n            cx = (y[i]-sy)*(dz-sz) - (z[i]-sz)*(dy-sy);\n            cy = (z[i]-sz)*(dx-sx) - (x[i]-sx)*(dz-sz);\n            cz = (x[i]-sx)*(dy-sy) - (y[i]-sy)*(dx-sx);\n            double d = norm(cx,cy,cz) / norm(dx-sx,dy-sy,dz-sz);\n            if (d < r[i] + EPS) ans += l[i];\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  Point p,b;\n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\nstruct obj{\n  double x, y ,z;\n  obj operator+(const obj& a)const{\n    obj b;\n    b.x = x + a.x;\n    b.y = y + a.y;\n    b.z = z + a.z;\n    return b; \n  }\n  obj operator-(const obj& a)const{\n    obj b;\n    b.x = x - a.x;\n    b.y = y - a.y;\n    b.z = z - a.z;\n    return b; \n  }\n};\nstruct obstacle{\n  obj c;\n  long long int  r, l;\n};\ntypedef pair<obj, obj> line;\n\ndouble abs(obj b){\n  return sqrt(b.x*b.x + b.y*b.y + b.z*b.z);\n}\n\ndouble cross(obj a, obj b){\n  double x, y, z;\n  x = a.y*b.z - a.z*b.y;\n  y = a.z*b.x - a.x*b.z;\n  z = a.x*b.y - a.y*b.x;\n  return sqrt(x*x + y*y + z*z);\n}\n\ndouble dot(obj a, obj b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble dis(line l, obj p){\n  double area = cross(l.second - l.first, p - l.first)/2.0;\n  double res = (2*area)/abs(l.second - l.first);\n  //std::cout << abs(l.second - l.first) << \" \" << abs(p - l.first) << std::endl;\n  double cosa = dot(l.second - l.first, p - l.first) /\n    (abs(l.second - l.first)*abs(p - l.first));\n  double cosb = dot(l.first - l.second, p - l.second) /\n    (abs(l.first - l.second)*abs(p - l.second));\n  //  std::cout << \"cosa:\" << cosa << \" cosb:\" << cosb << std::endl;\n  if(cosa < 0) return abs(p - l.first);\n  if(cosb < 0) return abs(p - l.second);\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  int n, q;\n  cin >> n >> q;\n  obstacle p[n];\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].c.x >> p[i].c.y >> p[i].c.z >> p[i].r >> p[i].l;\n    //std::cout << p[i].c.x << \" \" << p[i].c.y << \" \" <<\n    //p[i].c.z << \" \" << p[i].r << \" \" << p[i].l << std::endl;\n  }\n  obj s, d;\n  for (int i = 0; i < q; i++) {\n    int ans = 0;\n    scanf(\"%lf %lf %lf %lf %lf %lf\", &s.x, &s.y, &s.z, &d.x, &d.y, &d.z);\n    line l = line(s, d);\n    for (int j = 0; j < n; j++) {\n      double d = dis(l, p[j].c);\n      //std::cout << \"j:\" << j << \" dis:\" << d << \" r:\" << p[j].r << std::endl;\n      if(d <= p[j].r){\n        ans += p[j].l;\n      }\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n// Types\nusing ld = long double;\nusing ll = long long;\n\ntemplate <std::size_t N>\nusing point = std::array<ld, N>;\nusing point2d = point<2>;\nusing point3d = point<3>;\n\ntemplate <typename Point = point2d>\nclass line {\npublic:\n    Point a, b;\n};\n\nclass circle {\npublic:\n    point2d p;\n    ld r;\n};\n\nclass sphere {\npublic:\n    point3d p;\n    ld r;\n};\n\n\n// operator\ntemplate <std::size_t N>\npoint<N> operator-(point<N> const& a, point<N> const& b) {\n    point<N> ret;\n    for(int i=0; i<N; ++i) {\n        ret[i] = a[i] - b[i];\n    }\n    return ret;\n}\ntemplate <std::size_t N>\npoint<N> operator-(point<N> const& a, ld b) {\n    point<N> ret = a;\n    for(int i=0; i<N; ++i) {\n        ret[i] -= b;\n    }\n    return ret;\n}\ntemplate <std::size_t N>\npoint<N> operator-(ld a, point<N> const& b) {\n    return b-a;\n}\n\ntemplate <std::size_t N>\npoint<N> operator+(point<N> const& a, point<N> const& b) {\n    point<N> ret;\n    for(int i=0; i<N; ++i) {\n        ret[i] = a[i] + b[i];\n    }\n    return ret;\n}\ntemplate <std::size_t N>\npoint<N> operator+(point<N> const& a, ld b) {\n    point<N> ret = a;\n    for(int i=0; i<N; ++i) {\n        ret[i] += b;\n    }\n    return ret;\n}\ntemplate <std::size_t N>\npoint<N> operator+(ld a, point<N> const& b) {\n    return b+a;\n}\n\ntemplate <std::size_t N>\npoint<N> operator*(point<N> const& a, ld b) {\n    point<N> ret = b;\n    for(int i=0; i<N; ++i) {\n        ret[i] *= b;\n    }\n    return ret;\n}\ntemplate <std::size_t N>\npoint<N> operator*(ld a, point<N> const& b) {\n    return b*a;\n}\n\n\n// constant\nconstexpr ld EPS = 1e-11;\nconstexpr ld PI = std::acos(-1.0);\n\n\n// functions\nbool eq(ld a, ld b) { // todo: rename\n    return (std::abs(a - b) < EPS);\n}\n\npoint<2> make_point(ld a, ld b) {\n    return {{a, b}};\n}\npoint<3> make_point(ld a, ld b, ld c) {\n    return {{a, b, c}};\n}\n\ntemplate <std::size_t N>\nld dot(point<N> a, point<N> b) { // inner_product\n    return std::inner_product(std::begin(a), std::end(a), std::begin(b), 0);    \n}\n\nld cross(point2d a, point2d b) {\n    return a[0]*b[1] - a[1]*b[0];\n}\npoint3d cross(point3d a, point3d b) {\n    return make_point(a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]);\n}\n\ntemplate <std::size_t N>\nld norm(point<N> a) { // |a|^2\n    return dot(a, a);\n}\n\ntemplate <std::size_t N>\nld dist(point<N> a) { // |a|\n    return std::sqrt(dot(a, a));\n}\n\nbool isis_ll(line<> l, line<> m) { // line and line(2d)\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line<> l, line<> s) { // line and half line(2d)\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < EPS);\n}\n\nbool isis_lp(line<> l, point2d p) { // 2d\n    return (std::abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\ntemplate <std::size_t N>\nbool isis_sp(line<point<N>> s, point<N> p) {\n    return (dist(s.a - p) + dist(s.b - p) - dist(s.b - s.a) < EPS);\n}\n\ntemplate <std::size_t N>\npoint<N> proj(line<point<N>> l, point<N> p) {\n    point<N> p1, p2, ret; // p1 = p - l.a, p2 = l.a - l.b, ret = l.a + t*(l.a - l.b)\n    for(int i=0; i<N; ++i) {\n        p1[i] = p[i] - l.a[i];\n        p2[i] = l.a[i] - l.b[i];\n    }\n    ld t = dot(p1, p2) / norm(p2);\n    for(int i=0; i<N; ++i) {\n        ret[i] = l.a[i] + t*p2[i];\n    }\n    return ret;\n}\n\ntemplate <std::size_t N>\nld dist_lp(line<point<N>> l, point<N> p) {\n    return dist(p - proj(l, p));\n}\n\nld dist_ll(line<> l, line<> m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(line<> l, line<> s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ntemplate <std::size_t N>\nld dist_sp(line<point<N>> s, point<N> p) {\n    point<N> r = proj(s, p);\n    return isis_sp(s, r) ? dist(r - p) : std::min(dist(s.a - p), dist(s.b - p));\n}\n\nint ccw(point2d a, point2d b, point2d c) {\n    for(int i=0; i<2; ++i) {\n        b[i] -= a[i];\n        c[i] -= a[i];\n    }\n    if(cross(b, c) > EPS) return 1;   // a -> b -> c is counter clockwise\n    if(cross(b, c) < -EPS) return -1; // a -> b -> c is clockwise\n    if(dot(b, c) < 0) return 2;       // c -> a -> b is line\n    if(norm(b) < norm(c)) return -2;  // a -> b -> c is line\n    return 0;                         // a -> c -> b is line\n}\n\nusing namespace std;\n\nclass obstacle {\npublic:\n    point3d p;\n    ld r;\n    ll l;\n};\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<obstacle> v(N);\n    vector<line<point3d>> w(Q);\n    for(int i=0; i<N; ++i) {\n        ld x, y, z, r;\n        ll l;\n        cin >> x >> y >> z >> r >> l;\n        v[i].p = make_point(x, y, z);\n        v[i].r = r;\n        v[i].l = l;\n    }\n    for(int i=0; i<Q; ++i) {\n        int sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        w[i].a = make_point(sx, sy, sz);\n        w[i].b = make_point(dx, dy, dz);\n    }\n\n    for(int i=0; i<Q; ++i) {\n        ll ret=0;\n        for(int j=0; j<N; ++j) {\n            if(dist_sp(w[i], v[j].p) - v[j].r < EPS) {\n                ret += v[j].l;\n            }\n        }\n        cout << ret << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point3D {\n\tdouble x, y, z;\n\n\tPoint3D() : x(0), y(0), z(0) {}\n\n\tPoint3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n\tPoint3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }\n\n\tPoint3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }\n\n\tPoint3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }\n\n\tPoint3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }\n\n\tbool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point3D& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";\n\treturn os;\n}\n\ndouble dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nPoint3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }\n\ndouble norm(Point3D p) { return dot(p, p); }\ndouble abs(Point3D p) { return sqrt(norm(p)); }\n\nstruct Line {\n\tPoint3D a, b;\n\n\tLine() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}\n\n\tLine(Point3D a, Point3D b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \", \" << l.a.z <<  \")-(\" << l.b.x << \",\" << l.b.y << \", \" << l.b.z <<  \")\";\n\treturn os;\n}\n\nPoint3D project(Line l, Point3D p) {\n\tPoint3D base = l.b - l.a;\n\tdouble t = dot(base, p-l.a) / dot(base, base);\n\treturn l.a + base * t;\n}\n\nstruct Ball {\n\tPoint3D p;\n\tdouble r;\n\n\tBall() : p(Point3D(0, 0, 0)), r(0.0) {}\n\n\tBall(Point3D p, double r) : p(p), r(r) {}\n};\n\nostream& operator << (ostream& os, const Ball& b) {\n\tos << \"(\" << b.p.z << \", \" << b.p.y << \", \" << b.p.z << \" :\" << b.r << \")\";\n\treturn os;\n}\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<Ball> v(n);\n\tvector<ll> cost(n);\n\trep(i, n) {\n\t\tcin >> v[i].p.x >> v[i].p.y >> v[i].p.z >> v[i].r >> cost[i];\n\t}\n\n\trep(i, q) {\n\t\tll ans = 0;\n\t\tPoint3D s, t;\n\t\tcin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n\t\tLine line(s, t);\n\n\t\trep(j, n) {\n\t\t\tPoint3D proj = project(line, v[j].p);\n\n\t\t\tif(abs(line.b - line.a) >= abs(proj - line.a) && abs(line.a - line.b) >= abs(proj - line.b)) {\n\t\t\t\tif(abs(proj - v[j].p) <= v[j].r) {\n\t\t\t\t\tans += cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_3d {  // not verified\n\ndouble const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  double x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(double x, double y, double z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (double k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (double k) const { return P3(x / k, y / k, z / k); }\n};\n\ndouble dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }\n\ndouble norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\ndouble abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\ndouble cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\ndouble angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }\n\nistream& operator >> (istream& is, P3& p) { double x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\ndouble distance_lp(Line const& l, P3 const& p) {\n  return abs(p - l[0]) * angle(l[1] - l[0], p - l[0]);\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, double, double>> os;\n  rep(i, N) {\n    P3 p; double r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; double r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define EPS 1e-10\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y,z;\n\tP(){}\n\tP(double xx,double yy,double zz){\n\t\tx=xx;\n\t\ty=yy;\n\t\tz=zz;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),add(z,p.z));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),add(z,-p.z));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,z*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(add(x*p.x,y*p.y),z*p.z);\n\t}\n};\n\ndouble dist(P p){\n\treturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z);\n}\n\nint n,q;\nP s[51],g[51];\nP b[51];\ndouble r[51];\nint l[51];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %lf %lf %lf %d\",&b[i].x,&b[i].y,&b[i].z,&r[i],&l[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf\",&s[i].x,&s[i].y,&s[i].z);\n\t\tscanf(\"%lf %lf %lf\",&g[i].x,&g[i].y,&g[i].z);\n\t\tint res=0;\n\t\tP v=g[i]-s[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tP c=b[j]-s[i];\n\t\t\tif(v.dot(c)<0){\n\t\t\t\tif(r[j]>dist(c))res+=l[j];\n\t\t\t}else{\n\t\t\t\tif(v.dot(c)>dist(v)*dist(v)){\n\t\t\t\t\tif(dist(g[i]-b[j])<=r[j])res+=l[j];\n\t\t\t\t}else{\n\t\t\t\t\tdouble len=dist(c)*dist(c)-(v.dot(c)*v.dot(c))/(dist(v)*dist(v));\n\t\t\t\t\tif(len<=r[j]*r[j])res+=l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\n#define double long double\n\nnamespace point_3d {\n\ndouble const EPS = 1e-9;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  double x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(double x, double y, double z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (double k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (double k) const { return P3(x / k, y / k, z / k); }\n};\n\ndouble dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\ndouble norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\ndouble abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\ndouble cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\ndouble angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { double x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\ndouble distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\ndouble distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, double, double>> os;\n  rep(i, N) {\n    P3 p; double r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; double r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????D???long D?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-3;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD abs(D x, D y, D z){\n    return sqrt(x*x + y*y + z*z);\n}\n\nD dot(D a1, D a2, D a3, D b1, D b2, D b3){\n    return a1*b1 + a2*b2 + a3*b3;\n}\n\nD cross(D a1, D a2, D a3, D b1, D b2, D b3){\n    D i = a2*b3 - a3*b2;\n    D j = a3*b1 - a1*b3;\n    D k = a1*b2 - a2*b1;\n    return abs(i, j, k);\n}\n\nD distLP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    return abs(cross(px-sx, py-sy, pz-sz, dx-sx, dy-sy, dz-sz))/abs(dx-sx, dy-sy, dz-sz);\n}\n\nD distSP(D sx, D sy, D sz, D dx, D dy, D dz, D px, D py, D pz){\n    if(LE(dot(dx-sx, dy-sy, dz-sz, px-sx, py-sy, pz-sz), 0))\n        return abs(px-sx, py-sy, pz-sz);\n    if(LE(dot(sx-dx, sy-dy, sz-dz, px-dx, py-dy, pz-dz), 0))\n        return abs(px-dx, py-dy, pz-dz);\n    return distLP(sx, sy, sz, dx, dy, dz, px, py, pz);\n}\n\nclass Circle{\npublic:\n    D x, y, z, r;\n    ll l;\n    \n    Circle(D x, D y, D z, D r, int l): x(x), y(y), z(z), r(r), l(l){};\n    \n    bool intersect(D sx, D sy, D sz, D dx, D dy, D dz){\n        return LE(distSP(sx, sy, sz, dx, dy, dz, x, y, z), r);\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    \n    int N, Q;\n    cin >> N >> Q;\n    vector<Circle> circles;\n    for(int i=0; i<N; i++){\n        D x, y, z, r;\n        ll l;\n        cin >> x >> y >> z >> r >> l;\n        circles.push_back({x, y, z, r, l});\n    }\n    \n    while(Q--){\n        ll ans = 0;\n        D sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        \n        for(Circle &circle: circles){\n            if(circle.intersect(sx, sy, sz, dx, dy, dz))\n                ans += circle.l;\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct _vec{\n    double x, y, z;\n} vec;\n\ndouble Dis(vec A, vec B){\n    double dis = (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) + (A.z-B.z)*(A.z-B.z);\n    //cout << dis << \" o \" <<  endl;\n    dis = pow(dis, 0.5);\n    //cout << dis << \" o \" <<  endl;    \n    return dis;\n}\n\ndouble norm(vec A, vec B){             //内積\n    double res;\n    res = A.x*B.x + A.y*B.y + A.z*B.z;   \n\n    return res;\n}\n\nvec tanni(vec A){                   //単位ベクトルを返す\n    double dis = A.x*A.x + A.y*A.y + A.z*A.z;\n    dis = pow(dis, 0.5);\n    vec res;\n    res.x = A.x / dis;\n    res.y = A.y / dis;\n    res.z = A.z / dis;\n\n    return res;    \n}\n\nvec houkou(vec A, vec B){             //方向ベクトルを返す\n    vec res;\n    //cout << B.x << \" \" << A.x << endl;\n    res.x = B.x - A.x;\n    res.y = B.y - A.y;\n    res.z = B.z - A.z;\n    return res;\n}\n\nint main(){\n\n    /*vec V1, V2;\n    V1.x = 3;\n    V1.y = 4;\n    V1.z = 5;\n    V2.x = 6;\n    V2.y = 3;\n    V2.z = 8;\n\n    cout << norm(V1, V2) << endl;\n    cout << Dis(V1, V2) << endl;\n    vec V3 = tanni(V1);\n    cout << V3.x << \" \" << V3.y << \" \" << V3.z << endl;\n    vec V4 = houkou(V1, V2);\n    cout << V4.x << \" \" << V4.y << \" \" << V4.z << endl;*/\n    \n\n    int n, q; cin >> n >> q;\n    vector<vec> obj(n);\n    vector<vec> blue(q);\n    vector<vec> red(q);    \n    vector<double> r(n);\n    vector<int> l(n);\n\n    for(int i = 0; i < n; i++){\n        int a, b, c, d, e; cin >> a >> b >> c >> d >> e;\n        obj[i].x = a;\n        obj[i].y = b;\n        obj[i].z = c;\n        r[i] = d;\n        l[i] = e;                \n    }\n\n    for(int i = 0; i < q; i++){\n        int a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f;\n        blue[i].x = d;\n        blue[i].y = e;\n        blue[i].z = f;\n        red[i].x = a;\n        red[i].y = b;\n        red[i].z = c;        \n    }\n\n\n\n    for(int i = 0; i < q; i++){\n\n        int ans = 0;\n\n        for(int j = 0; j < n; j++){\n            //j個目の障害物とはどうですか\n            vec H;\n            H.x = red[i].x;\n            H.y = red[i].y;\n            H.z = red[i].z;            \n\n            vec u;\n            u = houkou(red[i], blue[i]);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;            \n            u = tanni(u);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;\n            vec a;\n            a.x = obj[j].x - red[i].x;\n            a.y = obj[j].y - red[i].y;\n            a.z = obj[j].z - red[i].z;\n            //cout << a.x << \" \" << a.y << \" \" <<  a.z << endl;           \n            int _norm = norm(a, u);\n            //cout << _norm << endl;\n            vec w;\n            w.x = _norm*u.x;\n            w.y = _norm*u.y;\n            w.z = _norm*u.z;\n            //cout << endl;\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << w.x << \" \" << w.y << \" \" << w.z << endl;\n            H.x += w.x;\n            H.y += w.y;\n            H.z += w.z;\n\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << obj[j].x << \" \" << obj[j].y << \" \" << obj[j].z << endl;\n\n            double _dis = Dis(H, obj[j]);\n            //cout << _dis << endl;\n            if(_dis <= r[j]) ans += l[j];            \n            //cout << ans << endl;\n        \n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst double mEPS = 1e-10;\n\n//???????????????????????????\nclass Point{\npublic:\n  double x, y, z;\n\n  Point(LL x = 0.0, LL y = 0.0, LL z = 0.0) : x(x), y(y),z(z){}\n\n  Point operator + (Point p){ return Point(x + p.x, y + p.y, z+p.z); }\n  Point operator - (Point p){ return Point(x - p.x, y - p.y, z-p.z); }\n  Point operator * (double a){ return Point(a*x, a*y, a*z); }\n  Point operator / (double a){ return Point(x / a, y / a, z/a); }\n\n  double abs(){ return sqrt(norm()*1.); }\n  LL norm(){ return x*x + y*y + z*z; }\n\n  //EPS??????????°??????????\n  bool operator == (const Point &p) const {\n\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n  }\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n};\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\nLL dot(Vector a, Vector b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble cross(Vector a, Vector b){\n  Point p(a.y*b.z-b.y*a.z, a.z*b.x-b.z*a.x, a.x*b.y-b.x*a.y);\n  return p.abs();\n  //  return a.x*b.y - a.y*b.x;\n}\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs());\n}\n\ndouble getDistanceSP(Segment s, Point p){\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0) return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0) return (p - s.p2).abs();\n\treturn getDistanceLP(s, p);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q; cin >> N >> Q;\n  vector<Point> ps(N);\n  vector<LL> rs(N), ls(N);\n  REP(i,N) cin >> ps[i].x >> ps[i].y >> ps[i].z >> rs[i] >> ls[i];\n\n  REP(i,Q){\n\tLL ans = 0;\n\tint sx, sy, sz, dx, dy, dz;\n\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\tSegment s;\n\ts.p1 = Point(sx,sy,sz);\n\ts.p2 = Point(dx,dy,dz);\n\tREP(i,N){\n\t  if(getDistanceSP(s, ps[i]) <= rs[i]) ans += ls[i];\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  Point dir = l[1] - l[0];\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  if(D < -EPS) return false;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(abs(t1) < 1.0 || abs(t2) < 1.0){\n    return true;\n  }\n  return false;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])){\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define eps 0.0000001\nusing namespace std;\nstruct po{int x,y,z,r; long long l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n  int n,q;\n  cin >>n>>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].x>>ball[i].y>>ball[i].z>>ball[i].r>>ball[i].l;\n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].x,ball[j].y,ball[j].z});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].x,ball[j].y,ball[j].z});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = 2*S/dis[0];\n      if(fabs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0])>eps)continue;\n      if(h-ball[j].r<=eps) ans+=ball[j].l;\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, q;\nint x[100], y[100], z[100], r[100], l[100];\nint sx, sy, sz, gx, gy, gz;\n\nsigned main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> sx >> sy >> sz >> gx >> gy >> gz;\n\t\t\n\t\tint ax = gx - sx;\n\t\tint ay = gy - sy;\n\t\tint az = gz - sz;\n\t\tint ans = 0;\n\t\t\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint bx = x[j] - sx;\n\t\t\tint by = y[j] - sy;\n\t\t\tint bz = z[j] - sz;\n\t\t\t\n\t\t\tint menseki2 = 0;\n\t\t\tmenseki2 += (ax * by - bx * ay) * (ax * by - bx * ay);\n\t\t\tmenseki2 += (ay * bz - by * az) * (ay * bz - by * az);\n\t\t\tmenseki2 += (az * bx - bz * ax) * (az * bx - bz * ax);\n\t\t\tint length2 = ax * ax + ay * ay + az * az;\n\t\t\t\n\t\t\tif (menseki2 / length2 <= r[j] * r[j]) {\n\t\t\t\tans += l[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst int LIM = 50;\n\nbool eq(double a, double b) {\n    return abs(a-b) < EPS;\n}\n\nlong long square(long long x) {\n    return x * x;\n}\n\nlong long dist(int x1, int y1, int z1, int x2, int y2, int z2) {\n    return square(x1 - x2) + square(y1 - y2) + square(z1 - z2);\n}\n\nint inner_product(int x1, int y1, int z1, int x2, int y2, int z2) {\n    return x1*x2 + y1*y2 + z1*z2;\n}\n\nint main() {\n    int N, Q;\n    long long x[LIM], y[LIM], z[LIM], r[LIM];\n    long long l[LIM];\n\n    cin >> N >> Q;\n\n    for (int j = 0; j < N; ++j) {\n        cin >> x[j] >> y[j] >> z[j] >> r[j] >> l[j];\n    }\n\n    for (int _ = 0; _ < Q; ++_) {\n        long long sx, sy, sz, dx, dy, dz;\n        cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\n        long long ans = 0;\n\n        for (int k = 0; k < N; ++k) {\n            if (dist(sx, sy, sz, x[k], y[k], z[k]) <= square(r[k]) ||\n                    dist(dx, dy, dz, x[k], y[k], z[k]) <= square(r[k])) {\n                ans += l[k];\n                continue;\n            }\n            long long plane1 = (sx-dx)*(x[k]-sx) + (sy-dy)*(y[k]-sy) + (sz-dz)*(z[k]-sz);\n            long long plane2 = (sx-dx)*(x[k]-dx) + (sy-dy)*(y[k]-dy) + (sz-dz)*(z[k]-dz);\n\n\n            if (plane1 * plane2 > 0) {\n                continue;\n            }\n\n            long long ip = inner_product(x[k]-sx, y[k]-sy, z[k]-sz, dx-sx, dy-sy, dz-sz);\n\n            double dist_f = dist(x[k], y[k], z[k], sx, sy, sz) - ((double)square(ip))/dist(sx, sy, sz, dx, dy, dz);\n            \n            if (dist_f <= square(r[k])) {\n                ans += l[k];\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nll in(int a, int b, int c, int d, int e, int f) {\n\treturn a*d + b*e + c*f;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvl x(n), y(n), z(n),r(n),l(n);\n\tREP(i, n)cin >> x[i] >> y[i] >> z[i] >>r[i] >>l[i];\n\tint sx, sy, sz, dx, dy, dz;\n\tREP(i, q) {\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tint vx = dx - sx, vy = dy - sy, vz = dz - sz;\n\t\tll ans = 0;\n\t\tREP(j, n) {\n\t\t\tint a = sx - x[j], b = sy - y[j], c = sz - z[j];\n\t\t\tll D = in(a, b, c, vx, vy, vz)*in(a, b, c, vx, vy, vz) - in(vx, vy, vz, vx, vy, vz)*(in(a, b, c, a, b, c) - r[j] * r[j]);\n\t\t\tif (D == 0||(D>0 && (-in(a,b,c, vx, vy, vz) > EPS + sqrt(D)|| -in(a, b, c, vx, vy, vz) > EPS - sqrt(D))))ans += l[j];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,string> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ndouble dist(double a,double b,double c){\n\treturn sqrt(a*a+b*b+c*c);\n}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvd boll(n,vd(4));\n\tvi sc(n);\n\trep(i,n){\n\t\trep(j,4)cin>>boll[i][j];\n\t\tcin>>sc[i];\n\t}\n\twhile(m--){\n\t\tll out=0;\n\t\tdouble a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\trep(i,n){\n\t\t\tvd q{boll[i][0],boll[i][1],boll[i][2]};\n\t\t\tdouble A=d-a,B=e-b,C=f-c;\n\t\t\tdouble ssita=sqrt(pow(B*(q[2]-c)-C*(q[1]-b),2)+pow(C*(q[0]-a)-A*(q[2]-c),2)+pow(A*(q[1]-b)-B*(q[0]-a),2))/\n\t\t\t\tdist(A,B,C)/dist(q[0]-a,q[1]-b,q[2]-c);\n\t\t\tdouble dis=dist(q[0]-a,q[1]-b,q[2]-c)*ssita;\n\t\t\tif(dis<boll[i][3]+EPS){\n\t\t\t\tdouble dot1=A*(q[0]-a)+B*(q[1]-b)+C*(q[2]-c);\n\t\t\t\tdouble dot2=A*(q[0]-d)+B*(q[1]-e)+C*(q[2]-f);\n//\t\t\t\tcout<<i<<\" \"<<dot1<<\" \"<<dot2<<endl;\n\t\t\t\tif(dot1>=0&&dot2<=0)out+=sc[i];\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,qc,x[51],y[51],z[51],rl[51];\ndouble dx,dy,dz,sx,sy,sz,a,b,c,p,q,r;\nlong long int l[51],sum;\ndouble t,lt;\nint main(){\n\tcin >>n >>qc;\n\tfor(int i=0;i<n;i++){\n\t\tcin >>x[i] >>y[i] >>z[i] >>rl[i] >>l[i];\n\t}\n\tfor(int i=0;i<qc;i++){\n\t\tsum=0;\n\t\tcin >>sx >>sy >>sz >>dx >>dy >>dz;\n\t\ta=dx-sx;\n\t\tb=dy-sy;\n\t\tc=dz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp=sx-x[j];\n\t\t\tq=sy-y[j];\n\t\t\tr=sz-z[j];\n\t\t\tt=-(a*p+b*q+c*r)/(a*a+b*b+c*c);\n\t\t\tlt=(t*a+p)*(t*a+p)+(t*b+q)*(t*b+q)+(t*c+r)*(t*c+r);\n\t\t\tif(lt<=rl[j]*rl[j])sum+=l[j];\n\t\t\t//cout <<t <<endl;\n\t\t\t//cout <<lt <<endl;\n\t\t}\n\t\tcout <<sum <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n \ntypedef double D;\nstruct P {\n    D x,y,z;\n    P() { }\n    P(D x_, D y_, D z_) : x(x_), y(y_), z(z_) { }\n};\n \nstruct L {\n    P a,b;\n    L() { }\n    L(P a_, P b_) : a(a_), b(b_) { }\n};\n \nstruct C {\n    P p;\n    D r;\n    C() { }\n    C(P p_, D r_) : p(p_), r(r_) { }\n};\n \nconst D EPS = 1e-8;\n \nint sig(D a, D b) {\n    if(a < b - EPS) return -1;\n    if(a > b + EPS) return +1;\n    return 0;\n}\n \nP operator +(P a, P b) {\n    return P(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n \nP operator -(P a, P b) {\n    return P(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n \nP operator *(P a, D t) {\n    return P(a.x*t, a.y*t, a.z*t);\n}\n \nP vec(P from, P to) {\n    return to - from;\n}\n \nD inp(P a, P b) {\n    return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n \nD norm(P p) {\n    return inp(p,p);\n}\n \nD abs(P p) {\n    return sqrt(norm(p));\n}\n \nP proj(L l, P p) {\n    P a = vec(l.a, l.b);\n    P b = vec(l.a, p);\n    D t = inp(a,b) / norm(a);\n    return l.a + a*t;\n}\n \nbool iSP(L s, P p) {\n    P b = vec(s.a, s.b);\n    P c = vec(s.a, p);\n    if(sig(inp(b,c),0.0) < 0) return false;\n    if(norm(b) < norm(c)) return false;\n    return true;\n}\n \nD dSP(L s, P p) {\n    P r = proj(s,p);\n    if(iSP(s,r)) return abs(p - r);\n    return min(abs(p - s.a), abs(p - s.b));\n}\n \nbool iSC(L s, C c) {\n    return sig(dSP(s,c.p), c.r) <= 0;\n}\n \nint main() {\n    int N, Q; cin >> N >> Q;\n    vector<C> objs(N);\n    vector<long long> cost(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> objs[i].p.x >> objs[i].p.y >> objs[i].p.z >> objs[i].r >> cost[i];\n    }\n    for(int i = 0; i < Q; ++i) {\n        L l;\n        long long ans = 0;\n        cin >> l.a.x >> l.a.y >> l.a.z >> l.b.x >> l.b.y >> l.b.z;\n        for(int j = 0; j < N; ++j) {\n            if(iSC(l,objs[j])) {\n                ans += cost[j];\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\n// typedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst double EPS = 1e-10;\n\nstruct P {\n    double x, y, z;\n    P(){}\n    P(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}\n    const P operator+ (const P& p) {\n        return P(this->x + p.x, this->y + p.y , this->z + p.z);\n    }\n    const P operator- (const P &p) {\n        return P(this->x - p.x, this->y - p.y , this->z - p.z);\n    }\n    void print() {\n        printf(\"%.1f %.1f %.1f\\n\", x, y, z);\n    }\n};\n\ndouble dot(const P& p, const P& q) {\n    return p.x * q.x + p.y * q.y + p.z * q.z;\n}\n\nP cross(P p, P q) {\n    return P(p.y * q.z - p.z * q.y, p.z * q.x - p.x * q.z, p.x * q.y - p.y * q.x);\n}\n\nstruct C {\n    P c;\n    double r;\n    C(){}\n    C(P _c, double _r) : c(_c), r(_r) {}\n};\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n};\n\ndouble distance(P p) {\n    return sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n}\n\ndouble distancePP(P p, P q) {\n    return sqrt((p.x - q.x) * (p.x - q.x)\n            + (p.y - q.y) * (p.y - q.y)\n            + (p.z - q.z) * (p.z - q.z));\n}\n\ndouble distanceLP(L l, P p) {\n    return distance(cross(l.v, p - l.a)) / distance(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.b - l.a, p - l.a) < 0) return distancePP(p, l.a);\n    if (dot(l.a - l.b, p - l.b) < 0) return distancePP(p, l.b);\n    return distanceLP(l, p);\n}\n\nbool intersectSC(L s, C c) {\n    // return distanceSP(s, c.c) <= c.r;\n    return distanceSP(s, c.c) < c.r + EPS;\n}\n\nC readC() {\n    double x, y, z, r;\n    cin >> x >> y >> z >> r;\n    return C(P(x, y, z), r);\n}\n\nL readL() {\n    double x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    return L(P(x1, y1, z1), P(x2, y2, z2));\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<C> circles(N);\n    V l(N);\n    rep(i, N) {\n        circles[i] = readC();\n        cin >> l[i];\n    }\n\n    while (Q--) {\n        L s = readL();\n        int ans = 0;\n        rep(i, N) {\n            if (intersectSC(s, circles[i])) {\n                ans += l[i];\n            }\n        }\n        cout << ans << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst double mEPS = 1e-10;\nconst LL INF = 1e9;\n\n//???????????????????????????\nclass Point{\npublic:\n  double x, y, z;\n\n  Point(LL x = 0.0, LL y = 0.0, LL z = 0.0) : x(x), y(y),z(z){}\n\n  Point operator + (Point p){ return Point(x + p.x, y + p.y, z+p.z); }\n  Point operator - (Point p){ return Point(x - p.x, y - p.y, z-p.z); }\n  Point operator * (double a){ return Point(a*x, a*y, a*z); }\n  Point operator / (double a){ return Point(x / a, y / a, z/a); }\n\n  double abs(){ return sqrt(norm()*1.); }\n  LL norm(){ return x*x + y*y + z*z; }\n\n  //EPS??????????°??????????\n  bool operator == (const Point &p) const {\n\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n  }\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n};\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\nLL dot(Vector a, Vector b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nLL cross(Vector a, Vector b){\n  Point p(a.y*b.z-b.y*a.z, a.z*b.x-b.z*a.x, a.x*b.y-b.x*a.y);\n  return p.norm();\n  //  return a.x*b.y - a.y*b.x;\n}\nLL getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).norm());\n}\n\nLL getDistanceSP(Segment s, Point p){\n  if (dot(s.p2 - s.p1, p - s.p1) < 0) return INF; //(p - s.p1).abs();\n  if (dot(s.p1 - s.p2, p - s.p2) < 0) return INF; //(p - s.p2).abs();\n  return getDistanceLP(s, p);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, Q; cin >> N >> Q;\n  vector<Point> ps(N);\n  vector<LL> rs(N), ls(N);\n  REP(i,N) cin >> ps[i].x >> ps[i].y >> ps[i].z >> rs[i] >> ls[i];\n\n  REP(i,Q){\n\tLL ans = 0;\n\tint sx, sy, sz, dx, dy, dz;\n\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\tSegment s;\n\ts.p1 = Point(sx,sy,sz);\n\ts.p2 = Point(dx,dy,dz);\n\tREP(i,N){\n\t  if(getDistanceSP(s, ps[i]) <= rs[i]*rs[i]) ans += ls[i];\n\t}\n\tcout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define EPS 1e-10\n\nstruct P{\n  double X, Y, Z;\n};\n\nnamespace std{\n  P operator-(const P& a, const P& b){\n    P ret = {a.X-b.X, a.Y-b.Y, a.Z-b.Z};\n    return ret;\n  }\n}\n\ndouble dot_3d(P a, P b){\n  return a.X*b.X + a.Y*b.Y + a.Z*b.Z;\n}\n\nP cross(P a, P b){\n  P ret = {a.Y*b.Z-a.Z*b.Y,a.Z*b.X-a.X*b.Z,a.X*b.Y-a.Y*b.X};\n  return ret;\n}\n\ndouble norm_3d(P a){\n  return a.X*a.X + a.Y*a.Y + a.Z*a.Z;\n}\n\nint main(){\n  int N, Q;\n  cin >> N >> Q;\n  vector<P> obs(N);\n  vector<int> r(N), l(N);\n  for(int i = 0; i < N; ++i){\n    cin >> obs[i].X >> obs[i].Y >> obs[i].Z >> r[i] >> l[i];\n  }\n  P s, d;\n  for(int i = 0; i < Q; ++i){\n    cin >> s.X >> s.Y >> s.Z >> d.X >> d.Y >> d.Z;\n    P v = d-s;\n    int ans = 0;\n    for(int i = 0; i < N; ++i){\n      if(norm_3d(cross(v,obs[i]-s))/norm_3d(v) <= r[i]*r[i]) ans += l[i];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#define eps 0.0000001\nusing namespace std;\nstruct po{int x,y,z,r; long long l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n  int n,q;\n  cin >>n>>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].x>>ball[i].y>>ball[i].z>>ball[i].r>>ball[i].l;\n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].x,ball[j].y,ball[j].z});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].x,ball[j].y,ball[j].z});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = (2*S)/dis[0];\n      \n      if(dis[1]-ball[j].r<=eps ||dis[2]-ball[j].r<=eps) {\n\tans+=ball[j].l;\n\tcontinue;\n      }\n\n      if(abs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0]) > eps)continue;\n      if(h-ball[j].r<=eps) ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point3 {\n    real x, y, z;\n    Point3& operator+=(const Point3 a) { x += a.x; y += a.y; z += a.z;  return *this; }\n    Point3& operator-=(const Point3 a) { x -= a.x; y -= a.y; z += a.z; return *this; }\n    Point3 operator+(const Point3 a) const {return Point3(*this) += a; }\n    Point3 operator-(const Point3 a) const {return Point3(*this) -= a; }\n\n    Point3& operator*=(const real t) { x *= t; y *= t; z *= t; return *this; }\n    Point3 operator*(const real t) const {return Point3(*this) *= t; }\n    explicit Point3(real a = 0, real b = 0, real c = 0) : x(a), y(b), z(c) {};\n};\n\ninline real dot(Point3 a, Point3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\ninline Point3 cross(Point3 a, Point3 b){\n    return Point3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n}\ninline real abs(Point3 a){ return sqrt(dot(a, a)); }\n\nstruct Segment {\n    Point3 a, b;\n    Segment(Point3 x, Point3 y) : a(x), b(y) {};\n};\n\ndouble distance(Segment l, Point3 c){\n    if(dot(l.b-l.a, c-l.a) < 0) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) < 0) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<pair<Point3, double>> v(n);\n    vector<ll> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i].first.x >> v[i].first.y >> v[i].first.z >> v[i].second >> x[i];\n    }\n    for (int i = 0; i < q; ++i) {\n        double a, b, c, d, e, f;\n        cin >> a >> b >> c >> d >> e >> f;\n        Segment S(Point3(a, b, c), Point3(d, e, f));\n        ll ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if(distance(S, v[j].first) <= v[j].second+EPS) ans += x[j];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<math.h>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  int n,q;\n  cin >> n >> q;\n  vector<int> x(n);\n  vector<int> y(n);\n  vector<int> z(n);\n  vector<int> r(n);\n  vector<long long> l(n);\n  for(int i = 0; i < n; i++){\n    cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  }\n  \n  vector<int> sx(q);\n  vector<int> sy(q);\n  vector<int> sz(q);\n  vector<int> dx(q);\n  vector<int> dy(q);\n  vector<int> dz(q);\n  for(int i = 0; i < q; i++){\n    cin >> sx[i] >> sy[i] >> sz[i] >> dx[i] >> dy[i] >> dz[i];\n  }\n  for(int i = 0; i < q; i++){\n    long long cost = 0;\n    double ab = sqrt(pow(sx[i]-dx[i], 2) + pow(sy[i] - dy[i], 2) + pow(sz[i] - dz[i], 2));\n    for(int j = 0; j < n; j++){\n      double ac2 = pow(sx[i]-x[j], 2) + pow(sy[i]-y[j], 2) + pow(sz[i]-z[j], 2);\n      double bc2 = pow(dx[i]-x[j], 2) + pow(dy[i]-y[j], 2) + pow(dz[i]-z[j], 2);\n      if(ac2 <= pow(r[j], 2) || bc2 <= pow(r[j], 2)){\n        cost += l[j];\n      }\n      else if(sqrt(ac2 - pow(r[j], 2)) + sqrt(bc2 - pow(r[j], 2)) <= ab){\n        cost += l[j];\n      }\n    }\n    cout << cost << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define gsort(b, e) sort(b, e, greater<decltype(*b)>())\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) gsort(ALL(v))\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i <= (b); ++i)\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); --i)\n\n/* ----------- debug ---------- */\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, set<T> v) {\n    os << \"[\";\n    for (auto vv : v)\n        os << vv << \",\";\n    return os << \"]\";\n}\n\ntemplate <class L, class R>\nostream& operator<<(ostream& os, pair<L, R> p) {\n    return os << \"(\" << p.fst << \",\" << p.snd << \")\";\n}\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\nconst double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T, typename U>\nT mypow(T b, U n) {\n    if (n == 0) return 1;\n    if (n == 1) return b /* % MOD */;\n    if (n % 2 == 0) {\n        return mypow(sq(b) /* % MOD */, n / 2);\n    } else {\n        return mypow(b, n - 1) * b /* % MOD */;\n    }\n}\n\nll pcnt(ll b) {\n    return __builtin_popcountll(b);\n}\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n// #define DEBUG\n// #define DEBUG_CASE_NUM 3\n\nvoid solve() {\n    ll N, Q;\n    cin >> N >> Q;\n\n    double x[N][3], r[N];\n    ll m[N];\n    FOR(k, 0, N - 1) {\n        FOR(i, 0, 2) {\n            cin >> x[k][i];\n        }\n        cin >> r[k] >> m[k];\n    }\n\n    FOR(_, 1, Q) {\n        double rx[3], bx[3];\n        FOR(i, 0, 2) {\n            cin >> rx[i];\n        }\n        FOR(i, 0, 2) {\n            cin >> bx[i];\n        }\n\n        double dx[2][3];\n        ll ans = 0;\n        FOR(k, 0, N - 1) {\n            double norm[2] = {0}, inner = 0;\n            FOR(i, 0, 2) {\n                dx[0][i] = rx[i] - bx[i];\n                dx[1][i] = rx[i] - x[k][i];\n                FOR(j, 0, 1) {\n                    norm[j] += sq(dx[j][i]);\n                }\n                inner += dx[0][i] * dx[1][i];\n            }\n\n            double d = sqrt(norm[1]) * sqrt(1 - sq(inner) / (norm[0] * norm[1]));\n            // cout << d << endl;\n\n            if (d < r[k] + EPS) {\n                ans += m[k];\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // cout << fixed << setprecision(10);\n\n#ifdef DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n    FOR(_, 1, DEBUG_CASE_NUM) {\n        solve();\n        cout << \"++++++++++\" << endl;\n    }\n#else\n    solve();\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#include<memory>\n\n\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double,int> pdi;\ntypedef pair<long double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst long double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\n//const ll mod = 998244353;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst long double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\n//debug\n#define DEBUG\n\n#define DUMPOUT cout\n\n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\nvoid dump_func() {DUMPOUT << endl;};\n\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n\n//ostream\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n, q;\nint x[55], y[55], z[55], r[55], l[55];\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> n >> q;\n  rep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n  rep(i, q) {\n    int sx, sy, sz, dx, dy, dz;\n    cin >> sx >> sy >> sz >> dx >> dy >> dz;\n    int vx = dx - sx;\n    int vy = dy - sy;\n    int vz = dz - sz;\n    int wx = sx - dx;\n    int wy = sy - dy;\n    int wz = sz - dz;\n    int ans = 0;\n    rep(j, n) {\n      int cx = x[j] - sx;\n      int cy = y[j] - sy;\n      int cz = z[j] - sz;\n      int rcx = x[j] - dx;\n      int rcy = y[j] - dy;\n      int rcz = z[j] - dz;\n      double a1 = vx * cx + vy * cy + vz * cz;\n      double a2 = wx * rcx + wy * rcy + wz * rcz;\n      double b = sqrt(pow(vx, 2) + pow(vy, 2) + pow(vz, 2));\n      double c = sqrt(pow(cx, 2) + pow(cy, 2) + pow(cz, 2));\n      double d = sqrt(pow(rcx, 2) + pow(rcy, 2) + pow(rcz, 2));\n      //cerr << a << \" \" << b << \" \" << c << endl;\n      double theta1 = acos(a1 / (b * c));\n      double theta2 = acos(a2 / (b * d));\n      if (pi / 2 <= theta1 + EPS || pi / 2 <= theta2 + EPS) continue;\n      //cerr << theta1 << \" \" << theta2 << endl;\n      double dist1 = c * sin(theta1);\n      double dist2 = d * sin(theta2);\n      //cerr << dist1 << \" \" << dist2 << \" \" << r[j] << endl;\n      //cerr << dist << \" \" << r[j] << endl;\n      if (dist1 - EPS <= r[j]) {\n        ans += l[j];\n      }\n    }\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct P{\n\tdouble x,y,z;\n};\ndouble dot(P a,P b){\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\ndouble abs(P a){\n\treturn sqrt(a.x*a.x+a.y*a.y+a.z*a.z);\n}\nP sub(P a,P b){\n\ta.x -= b.x;\n\ta.y -= b.y;\n\ta.z -= b.z;\n\treturn a;\n}\nP pls(P a,P b){\n\ta.x += b.x;\n\ta.y += b.y;\n\ta.z += b.z;\n\treturn a;\n}\nP mul(double v,P a){\n\ta.x *= v;\n\ta.y *= v;\n\ta.z *= v;\n\treturn a;\n}\n\ndouble dist(P a,P b,P c){\n\tP e = sub(b,a);\n\te = mul(1./abs(e),e);\n\tP v = sub(c,a);\n\treturn abs(sub(c,pls(a,mul(dot(e,v),e))));\n}\nP p[50];\ndouble l[50],r[50];\nint main(){\n\tint N,Q;\n\tcin >> N >> Q;\n\tfor(int i = 0 ; i < N ; i++) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\tfor(int i = 0 ; i < Q ; i++){\n\t\tP p1,p2;\n\t\tcin >> p1.x >> p1.y >> p1.z;\n\t\tcin >> p2.x >> p2.y >> p2.z;\t\t\n\t\tint ans = 0;\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\tif( dist(p1,p2,p[j]) < r[j] + 1e-9 ) ans += l[j];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  double distance = distanceLP(l,ci.p);\n  if(distance <= ci.r) return true;\n  return false;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])) {\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  double distance = distanceLP(l,ci.p);\n  if(distance <= ci.r + EPS) return true;\n  return false;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])) {\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nvector<Point> crosspointLC(const Line& l,const Circle& ci){\n  Point dir = unit(l[1] - l[0]);\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  vector<Point> res;\n  if(D < 0) return res;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(abs(t1) < abs(t2)){\n    res.push_back(l[0] + dir * t1);\n  }\n  else{\n    res.push_back(l[0] + dir * t2);\n  }\n  return res;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<int> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      int amount_of_consumption;\n      scanf(\"%d %d %d %d %d\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      int sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        vector<Point> p = crosspointLC(line,obstacles[obstacle_i]);\n        if(p.size() > 0) sum += costs[obstacle_i];\n      }\n      printf(\"%d\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\n// typedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nstruct P {\n    double x, y, z;\n    P(){}\n    P(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}\n    const P operator+ (const P& p) {\n        return P(this->x + p.x, this->y + p.y , this->z + p.z);\n    }\n    const P operator- (const P &p) {\n        return P(this->x - p.x, this->y - p.y , this->z - p.z);\n    }\n    void print() {\n        printf(\"%.1f %.1f %.1f\\n\", x, y, z);\n    }\n};\n\ndouble dot(const P& p, const P& q) {\n    return p.x * q.x + p.y * q.y + p.z * q.z;\n}\n\nP cross(P p, P q) {\n    return P(p.y * q.z - p.z * q.y, p.z * q.x - p.x * q.z, p.x * q.y - p.y * q.x);\n}\n\nstruct C {\n    P c;\n    double r;\n    C(){}\n    C(P _c, double _r) : c(_c), r(_r) {}\n};\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n};\n\ndouble distance(P p) {\n    return sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n}\n\ndouble distancePP(P p, P q) {\n    return sqrt((p.x - q.x) * (p.x - q.x)\n            + (p.y - q.y) * (p.y - q.y)\n            + (p.z - q.z) * (p.z - q.z));\n}\n\ndouble distanceLP(L l, P p) {\n    return distance(cross(l.v, p - l.a)) / distance(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.b - l.a, p - l.a) < 0) return distancePP(p, l.a);\n    if (dot(l.a - l.b, p - l.b) < 0) return distancePP(p, l.b);\n    return distanceLP(l, p);\n}\n\nbool intersectSC(L s, C c) {\n    return distanceSP(s, c.c) <= c.r;\n}\n\nC readC() {\n    double x, y, z, r;\n    cin >> x >> y >> z >> r;\n    return C(P(x, y, z), r);\n}\n\nL readL() {\n    double x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    return L(P(x1, y1, z1), P(x2, y2, z2));\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<C> circles(N);\n    V l(N);\n    rep(i, N) {\n        circles[i] = readC();\n        cin >> l[i];\n    }\n\n    while (Q--) {\n        L s = readL();\n        int ans = 0;\n        rep(i, N) {\n            if (intersectSC(s, circles[i])) {\n                ans += l[i];\n            }\n        }\n        cout << ans << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\ntypedef int64_t ll;\ntypedef long double ld;\nstruct Circle {\n    ld x, y, z, r;\n    ll p;\n};\n\nint n,q;\nvector<Circle> cs;\n\nint solve(int sx, int sy, int sz, int dx, int dy, int dz){\n    auto myhpt = [](ld x, ld y, ld z, Circle c){\n        auto sq = [](ld x){ return x*x; };\n        return (sqrt(sq(x-c.x) + sq(y-c.y) + sq(z-c.z)));\n    };\n    dx -= sx; dy -= sy; dz -= sz;\n    ll ans = 0;\n    for (int j = 0; j < n; j++){\n        ld left = 0, right = 1;\n        ld d = (ld)1e200;\n        rep(t,200){\n            ld m1 = (left+left+right) / 3;\n            ld m2 = (left+right+right) / 3;\n            ld m1x = sx + m1*dx, m1y = sy + m1*dy, m1z = sz + m1*dz;\n            ld m2x = sx + m2*dx, m2y = sy + m2*dy, m2z = sz + m2*dz;\n            ld d1 = myhpt(m1x, m1y, m1z, cs[j]);\n            ld d2 = myhpt(m2x, m2y, m2z, cs[j]);\n            if (d1 < d2) right = m2; else left = m1;\n            d = min(d, min(d1,d2));\n        }\n        if(d < cs[j].r + 1e-9) ans += cs[j].p;\n    }\n    return ans;\n}\n\nint main(){\n    while(cin >> n >> q){\n        cs.resize(n);\n        rep(i,n) cin >> cs[i].x >> cs[i].y >> cs[i].z >> cs[i].r >> cs[i].p;\n        rep(i,q){\n            int sx, sy, sz, dx, dy, dz;\n            cin >> sx >> sy >> sz >> dx >> dy >> dz;\n            cout << solve(sx, sy, sz, dx, dy, dz) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\ntypedef struct {\n    double x, y, z;\n} P;\n\ndouble dot(P a, P b)\n{\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nP diff(P f, P t)\n{\n    return P{ t.x - f.x, t.y - f.y, t.z - f.z };\n}\n\nP mul(P a, double s)\n{\n    return P{ a.x*s, a.y*s, a.z*s };\n}\n\ndouble dist(P a)\n{\n    return pow(dot(a, a), 0.5);\n}\n\nconst double EPS = 1e-8;\n\nint main()\n{\n    int n, q; cin >> n >> q;\n    vector<P> p(n);\n    vector<double> r(n);\n    vector<ll> l(n);\n    loop (n, i) cin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\n    loop (q, i) {\n        P s, t;\n        cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n        P st = diff(s, t), ts = diff(t, s);\n        P n_st = mul(st, 1.0/dist(st));\n        ll ans = 0;\n        loop (n, j) {\n            P sp = diff(s, p[j]), tp = diff(t, p[j]);\n            if (dot(sp, st) < 0 || dot(tp, ts) < 0) continue;\n            P n_sp = mul(n_st, dot(sp, n_st));\n            double R = dist(diff(sp, n_sp));\n            if (R < r[j] + EPS) ans += l[j];\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,qc,x[51],y[51],z[51],rl[51];\ndouble dx,dy,dz,sx,sy,sz,a,b,c,p,q,r;\nlong long int l[51],sum;\ndouble t,lt;\nint main(){\n\tcin >>n >>qc;\n\tfor(int i=0;i<n;i++){\n\t\tcin >>x[i] >>y[i] >>z[i] >>rl[i] >>l[i];\n\t}\n\tfor(int i=0;i<qc;i++){\n\t\tsum=0;\n\t\tcin >>sx >>sy >>sz >>dx >>dy >>dz;\n\t\ta=dx-sx;\n\t\tb=dy-sy;\n\t\tc=dz-sz;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tp=sx-x[j];\n\t\t\tq=sy-y[j];\n\t\t\tr=sz-z[j];\n\t\t\tt=-(a*p+b*q+c*r)/(a*a+b*b+c*c);\n\t\t\tif(t>1){\n\t\t\t\tt=1;\n\t\t\t}else if(t<0){\n\t\t\t\tt=0;\n\t\t\t}\n\t\t\tlt=(t*a+p)*(t*a+p)+(t*b+q)*(t*b+q)+(t*c+r)*(t*c+r);\n\t\t\t\n\t\t\tif(lt<=rl[j]*rl[j])sum+=l[j];\n\t\t\t//cout <<t <<endl;\n\t\t\t//cout <<lt <<endl;\n\t\t\t//cout <<rl[j] <<endl;\n\t\t}\n\t\tcout <<\" sum is \"<<sum <<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\nusing vi  = vector<int>;\n \nconst double EPS = 1e-8;\nusing P = valarray<double>;\nconst int dim = 3;\nusing L = vector<P>;\nstruct C{\n  P p; double r;\n};\n \ndouble dot(const P& a, const P& b){\n  return (a * b).sum();\n}\ndouble norm(const P& p){\n  return dot(p, p);\n}\ndouble absP(const P& p){\n  return sqrt(norm(p));\n}\nbool intersectSP(const L &s, const P &p) {\n  return absP(s[0]-p)+absP(s[1]-p)-absP(s[1]-s[0]) < EPS;\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[1]-l[0]) / norm(l[1]-l[0]);\n  return l[0] + t*(l[1]-l[0]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r(projection(s, p));\n  if (intersectSP(s, r)) return absP(r - p);\n  return min(absP(s[0] - p), absP(s[1] - p));\n}\n\nint main(){\n  int n, q; cin >> n >> q;\n  vector<C> cs(n);\n  vector<long long> cost(n);\n  rep(i,n){\n    cs[i].p.resize(3);\n    rep(j,3) cin >> cs[i].p[j];\n    cin >> cs[i].r;\n    cin >> cost[i];\n  }\n  vector<L> ls(q, L(2, P(3)));\n  rep(i,q){\n    rep(j,3) cin >> ls[i][0][j];\n    rep(j,3) cin >> ls[i][1][j];\n  }\n   \n  rep(i,q){\n    long long res = 0;\n    rep(j,n){\n      if(distanceSP(ls[i],cs[j].p) - EPS < cs[j].r) res += cost[j];\n    }\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_3d {\n\nusing Real = long double;\n\nReal const EPS = 1e-9;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  Real x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(Real x, Real y, Real z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (Real k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (Real k) const { return P3(x / k, y / k, z / k); }\n};\n\nReal dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\nReal norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\nReal abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\nReal cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\nReal angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { Real x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nReal distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  Real t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nReal distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, Real, ll>> os;\n  rep(i, N) {\n    P3 p; Real r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; Real r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nlong long int N, M, K, H, W, L, R;\n\nstruct Enemy {\n\tlong double x;\n\tlong double y;\n\tlong double z;\n\tlong double r;\n\tlong long int cost;\n};\n\nstruct Place {\n\tlong double sx;\n\tlong double sy;\n\tlong double sz;\n\tlong double gx;\n\tlong double gy;\n\tlong double gz;\n\tlong double dis;\n\tvoid Cal() {\n\t\tdis = sqrt(pow(sx - gx, 2) + pow(sy - gy, 2) + pow(sz - gz, 2));\n\t\treturn;\n\t}\n};\n\nlong double dist(long double x,long double y,long double z, Enemy e) {\n\treturn sqrt(pow(x - e.x, 2) + pow(y - e.y, 2) + pow(z - e.z, 2));\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<Enemy>e(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> e[i].x >> e[i].y >> e[i].z >> e[i].r >> e[i].cost;\n\t}\n\tvector<Place>p(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> p[i].sx >> p[i].sy >> p[i].sz >> p[i].gx >> p[i].gy >> p[i].gz;\n\t\tp[i].Cal();\n\t}\n\tvector<long long int>ans(M);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tlong double l = 0;\n\t\t\tlong double r = p[j].dis;\n\t\t\tfor (int k = 0; k < 200; k++) {\n\t\t\t\tlong double ml = (l + l + r) / 3;\n\t\t\t\tlong double mr = (l + r + r) / 3;\n\t\t\t\tlong double lx, ly, lz, rx, ry, rz;\n\t\t\t\tlx = p[j].sx + (p[j].gx - p[j].sx)*ml / p[j].dis;\n\t\t\t\tly = p[j].sy + (p[j].gy - p[j].sy)*ml / p[j].dis;\n\t\t\t\tlz = p[j].sz + (p[j].gz - p[j].sz)*ml / p[j].dis;\n\t\t\t\trx = p[j].sx + (p[j].gx - p[j].sx)*mr / p[j].dis;\n\t\t\t\try = p[j].sy + (p[j].gy - p[j].sy)*mr / p[j].dis;\n\t\t\t\trz = p[j].sz + (p[j].gz - p[j].sz)*mr / p[j].dis;\n\t\t\t\tlong double ld, rd;\n\t\t\t\tld = dist(lx, ly, lz, e[i]);\n\t\t\t\trd = dist(rx, ry, rz, e[i]);\n\t\t\t\tif (ld < rd) {\n\t\t\t\t\tr = mr;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl = ml;\n\t\t\t\t}\n\t\t\t\tif (k == 199) {\n\t\t\t\t\tif (min(ld,rd) - EPS <= e[i].r) {\n\t\t\t\t\t\tans[j] += e[i].cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    \n    typedef double real;\n    typedef long long ll;\n\n    const real EPS = 1e-9;\n\n    struct Point {\n        real x, y, z;\n        Point() {}\n        Point(real x, real y, real z) : x(x), y(y), z(z) {}\n        Point operator-() const { return Point(-x, -y, -z); }\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n        Point operator-(const Point& p) const { return (*this) + (-p); }\n        Point operator*(real k) const { return Point(x * k, y * k, z * k); }\n        Point operator/(real k) const { return (*this) * (1.0 / k); }\n    };\n    real dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\n    real norm(const Point& a) { return sqrt(dot(a, a)); }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y >> p.z; }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n\n    Point projection(const Line& l, const Point& p) {\n        Point u = (p - l.a), v = (l.b - l.a);\n        return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n    }\n\n    real distance(const Line& l, const Point& p) {\n        Point q = projection(l, p);\n        return norm(p - q);\n    }\n\n    int N, Q;\n    vector<Point> P;\n    vector<real> R;\n    vector<ll> L;\n    void solve() {\n        cin >> N >> Q;\n        P.clear(); P.resize(N);\n        R.clear(); R.resize(N);\n        L.clear(); L.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> R[i] >> L[i];\n        }\n        for (int q = 0; q < Q; q++) {\n            Point s, t;\n            cin >> s >> t;\n            Line l(s, t);\n            ll ans = 0;\n            for (int i = 0; i < N; i++) {\n                if (distance(l, P[i]) <= R[i]) {\n                    ans += L[i];\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#define EPS 1e-10\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0.0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y,z;\n\tP(){}\n\tP(double xx,double yy,double zz){\n\t\tx=xx;\n\t\ty=yy;\n\t\tz=zz;\n\t}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y),add(z,p.z));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y),add(z,-p.z));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d,z*d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(add(x*p.x,y*p.y),z*p.z);\n\t}\n};\n\ndouble dist(P p){\n\treturn sqrt(p.x*p.x+p.y*p.y+p.z*p.z);\n}\n\nint n,q;\nP s[51],g[51];\nP b[51];\ndouble r[51];\nint l[51];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lf %lf %lf %lf %d\",&b[i].x,&b[i].y,&b[i].z,&r[i],&l[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%lf %lf %lf\",&s[i].x,&s[i].y,&s[i].z);\n\t\tscanf(\"%lf %lf %lf\",&g[i].x,&g[i].y,&g[i].z);\n\t\tint res=0;\n\t\tP v=g[i]-s[i];\n\t\tfor(int j=0;j<n;j++){\n\t\t\tP c=b[j]-s[i];\n\t\t\tif(v.dot(c)<0){\n\t\t\t\tif(r[j]+EPS>=dist(c))res+=l[j];\n\t\t\t}else{\n\t\t\t\tif(v.dot(c)>dist(v)*dist(v)){\n\t\t\t\t\tif(dist(g[i]-b[j])<=r[j]+EPS)res+=l[j];\n\t\t\t\t}else{\n\t\t\t\t\tdouble len=dist(c)*dist(c)-(v.dot(c)*v.dot(c))/(dist(v)*dist(v));\n\t\t\t\t\tif(len<=r[j]*r[j]+EPS)res+=l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvvi in(n,vi(5));\n\trep(i,n)rep(j,5)cin>>in[i][j];\n\twhile(m--){\n\t\tint a,b,c,d,e,f;\n\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\tll out=0;\n\t\tdouble dis=(a-d)*(a-d)+(b-e)*(b-e)+(c-f)*(c-f);\n\t\trep(i,n){\n\t\t\tdouble t=(in[i][0]-a)*(a-d)+(in[i][1]-b)*(b-e)+(in[i][2]-c)*(c-f);\n\t\t\tt/=dis;\n\t\t\tdouble x=a+t*(a-d);\n\t\t\tdouble y=b+t*(b-e);\n\t\t\tdouble z=c+t*(c-f);\n\t\t\tdouble DIS=(in[i][0]-x)*(in[i][0]-x)+(in[i][1]-y)*(in[i][1]-y)+(in[i][2]-z)*(in[i][2]-z);\n\t\t\tif((a-x)*(a-x)+(b-y)*(b-y)+(c-z)*(c-z)<dis&&(d-x)*(d-x)+(e-y)*(e-y)+(f-z)*(f-z)<dis&&\n\t\t\t\tDIS<in[i][3]*in[i][3])out+=in[i][4];\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1<<16,INF=1<<30;\nconst double eps=1e-9;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,Q;cin>>N>>Q;\n    vector<double> x(N),y(N),z(N),r(N);\n    vector<ll> l(N);\n    \n    for(int i=0;i<N;i++) cin>>x[i]>>y[i]>>z[i]>>r[i]>>l[i];\n    \n    while(Q--){\n        double sx,sy,sz,dx,dy,dz;cin>>sx>>sy>>sz>>dx>>dy>>dz;\n        ll sum=0;\n        \n        double vx=dx-sx,vy=dy-sy,vz=dz-sz;\n        \n        for(int i=0;i<N;i++){\n            double A=x[i]-sx,B=y[i]-sy,C=z[i]-sz;\n            \n            double t=(vx*A+vy*B+vz*C)/(vx*vx+vy*vy+vz*vz);\n            \n            bool ok=false;\n            \n            if(0.0<=t&&t<=1.0){\n                double dis=hypot(hypot(A-t*vx,B-t*vy),C-t*vz);\n                if(dis<=r[i]+eps) ok=true;\n            }\n            \n            if((x[i]-sx)*(x[i]-sx)+(y[i]-sy)*(y[i]-sy)+(z[i]-sz)*(z[i]-sz)<=r[i]*r[i]+eps) ok=true;\n            if((x[i]-dx)*(x[i]-dx)+(y[i]-dy)*(y[i]-dy)+(z[i]-dz)*(z[i]-dz)<=r[i]*r[i]+eps) ok=true;\n            //if((A-dx)*(A-dx)+(B-dy)*(B-dy)+(C-dz)*(C-dz)<=r[i]*r[i]) ok=true;\n            \n            if(ok) sum+=l[i];\n        }\n        \n        cout<<sum<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#define DIVIDE 10000.0\nconst int INF = 1e9;\nconst double EPS = 0.00001;\nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tld x[n + 1], y[n + 1], z[n + 1], r[n + 1], l[n + 1];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i]>> l[i];\n\t}\n\tld sx, sy, sz, dx, dy, dz;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tld ax = (ld)(sx - dx) / DIVIDE;\n\t\tld ay = (ld)(sy - dy) / DIVIDE;\n\t\tld az = (ld)(sz - dz) / DIVIDE;\n\n\t\tld bx = sx;\n\t\tld by = sy;\n\t\tld bz = sz;\n\t\tbool flag[n + 1] = {};\n\t\tll ans = 0;\n\t\tfor(int j = 0; j <= DIVIDE; j++)\n\t\t{\n\t\t\tfor(int k = 0; k < n; k++)\n\t\t\t{\n\t\t\t\tld cx = bx - x[k];\n\t\t\t\tld cy = by - y[k];\n\t\t\t\tld cz = bz - z[k];\n\t\t\t\tld dist = cx * cx + cy * cy + cz * cz;\n\t\t\t\tif(dist - r[k] * r[k] <= EPS)\n\t\t\t\t\tflag[k] = true;\n\t\t\t}\n\t\t\tbx -= ax;\n\t\t\tby -= ay;\n\t\t\tbz -= az;\n\t\t}\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tif(flag[j])\n\t\t\t\tans += l[j];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2641&lang=jp\n\n#define int long long\n#define DBG 0\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\nclass Point {\npublic:\n\tdouble x, y, z;\n\tPoint(double x = 0, double y = 0, double z = 0) :x(x), y(y), z(z) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y, z + p.z); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y, z - p.z); }\n\tPoint operator*(double a) { return Point(a * x, a * y, a*z); }\n\tPoint operator/(double a) { return Point(x / a, y / a, z / a); }\n\tbool operator<(const Point &p)const {\n\t\tif (x < p.x)return true;\n\t\tif (x > p.x)return false;\n\t\tif (y < p.y)return true;\n\t\tif (y > p.y)return false;\n\t\tif (z < p.z)return true;\n\t\treturn false;\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y) && equals(z, p.z); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y + z*z; }\n\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y << \" \" << p.z; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y, z; is >> x >> y >> z; p = Point(x, y, z); return is; }\n\nusing Vector = Point;\n\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) :p1(p1), p2(p2) {}\n};\nusing Line = Segment;\n\n//???\nclass Sphere {\npublic:\n\tPoint c;\n\tdouble r;\n\tint w;\n\tSphere(Point c = Point(), double r = 1.0) :c(c), r(r) {};\n};\n\n//http://www.math.s.chiba-u.ac.jp/~yasuda/Chiba/Lec/naiseki.pdf\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n//?????? cross product\nVector cross(Vector a, Vector b) {\n\tVector ret;\n\tret.x = a.y*b.z - a.z*b.y;\n\tret.y = a.z*b.x - a.x*b.z;\n\tret.z = a.x*b.y - a.y*b.x;\n\treturn ret;\n}\n\n//??°????±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n//2???????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//http://www.sousakuba.com/Programming/gs_dot_line_distance.html\n//???´??????¨????????????¢\ndouble get_distance_LP(Line l, Point p) { return cross(l.p2 - l.p1, p - l.p1).abs() / (l.p2 - l.p1).abs(); }\n//?????????¨????????????¢\ndouble get_distance_SP(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return get_distance(p, s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return get_distance(p, s.p2);\n\treturn get_distance_LP(s, p);\n}\n\n//??????¨?????????????????????\nbool intersect(Sphere SP, Segment S) {\n\treturn SP.r + EPS >= get_distance_SP(S, SP.c);\n}\n\n//??????¨???´????????????\npair<Point, Point> get_cross_points(Sphere SP, Line L) {\n\tassert(intersect(SP, L));\n\tVector pr = project(L, SP.c);\n\tVector e = (L.p2 - L.p1) / (L.p2 - L.p1).abs();\n\tdouble base = sqrt(SP.r*SP.r - (pr - SP.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\nsigned main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<Sphere> Spheres(N);\n\trep(i, 0, N)cin >> Spheres[i].c >> Spheres[i].r >> Spheres[i].w;\n\trep(i, 0, Q) {\n\t\tPoint s, d; cin >> s >> d;\n\t\tSegment S = Segment(s, d);\n\t\tint ans = 0;\n\t\tfor (Sphere &SP : Spheres)\n\t\t\tif (intersect(SP, S))\n\t\t\t\tans += SP.w;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  Point dir = unit(l[1] - l[0]);\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  if(D < 0) return false;\n  return true;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<int> costs;\n    vector<bool> used;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      int amount_of_consumption;\n      scanf(\"%d %d %d %d %d\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n      used.push_back(false);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      int sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(!used[obstacle_i] && hasCrosspointLC(line,obstacles[obstacle_i])) {\n          sum += costs[obstacle_i];\n          used[obstacle_i] = true;\n        }\n      }\n      printf(\"%d\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstruct Point{\n  int x,y,z;\n  Point(){};\n  Point(int x,int y,int z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n  Point operator*(double k){\n    return Point(x*k,y*k,z*k);\n  }\n  Point operator/(double k){\n    return Point(x/k,y/k,z/k);\n  }\n};\nint dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  int r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  int z=0;\n  Vector v=x-y,c=ba.p-y;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      if(dot(c,c)-dot(v,c)<=ba.r*ba.r)  z=ba.l;\n    }\n  }\n  return z;\n}\nint main(){\n  int n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    int o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long double ll;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  //cout << c.x << c.y << c.z << endl;\n  //cout << dot(v,c) << \":\" << dot(c,c) << \":\" << dot(v,v) << \":\" << ba.r*ba.r ;\n  if(dot(v,c)<0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-x,ba.p-x)<=ba.r*ba.r) z=ba.l;\n    }else{\n      //cout << endl << dot(v,c)*dot(v,c)/dot(v,v) <<\":\" << ba.r*ba.r << endl;\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  //cout << \":\" << z << endl;\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[100];\n  int i,j,k;\n  Point p,b;\n  for(i=0;i<n;i++){\n    cin >>  bs[i].p.x >>  bs[i].p.y >>  bs[i].p.z >> bs[i].r >> bs[i].l;\n  }\n  for(i=0;i<q;i++){\n    cin >> p.x >> p.y >> p.z;\n    cin >> b.x >> b.y >> b.z;\n    ll o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n      //cout << \":\"<<j<<\":\"<<o << endl;\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef long long lint;\nconst double EPS = 1e-9;\n\ntypedef struct Point {\n\tdouble x, y, z;\n\tPoint (double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}\n\tPoint operator + (const Point& a) const { return Point(x + a.x, y + a.y, z + a.z); }\n\tPoint operator - (const Point& a) const { return Point(x - a.x, y - a.y, z - a.z); }\n\tPoint operator * (double d) const { return Point(x * d, y * d, z * d); }\n} Vector;\n\nstruct Object {\n\tPoint p; double r; lint l;\n\tObject(Point p_, double r_, lint l_) : p(p_), r(r_), l(l_) {}\n};\n\ndouble sqr(double x) { return x * x; }\ndouble distance(const Point& a, const Point& b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y) + sqr(a.z - b.z)); }\n\nbool collision(const Object& obj, const Point& a, const Point& b) {\n\tVector unit = b - a;\n\t\n\tdouble lb = 0.0, ub = 1500.0;\n\t\n\tfor_(i,0,100) {\n\t\tdouble lft = (lb + ub) / 3., rgt = (lb + ub) * 2. / 3.;\n\t\tPoint pl = a + unit * lft, pr = a + unit * rgt;\n\t\tdouble dl = distance(obj.p, pl), dr = distance(obj.p, pr);\n\t\tif (dl < dr + EPS) ub = rgt;\n\t\telse lb = lft;\n\t}\n\t\n\treturn distance(obj.p, a + unit * ((lb + ub) / 2.)) < obj.r + EPS;\n}\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\t\n\tvector< Object > obj;\n\t\n\tfor_(i,0,N) {\n\t\tdouble x, y, z, r; lint l;\n\t\tcin >> x >> y >> z >> r >> l;\n\t\tobj.push_back(Object(Point(x, y, z), r, l));\n\t}\n\t\n\tfor_(i,0,Q) {\n\t\tdouble x1, y1, z1, x2, y2, z2;\n\t\tcin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n\t\tPoint red(x1, y1, z1), blue(x2, y2, z2);\n\t\n\t\tlint ans = 0;\n\t\tfor_(j,0,N) if (collision(obj[j], red, blue)) ans += obj[j].l;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld eps = 1e-11;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef valarray<ld> Point;\nPoint make_point(ld x, ld y, ld z) {\n\tPoint p(3);\n\tp[0] = x; p[1] = y; p[2] = z;\n\treturn p;\n}\n\nld dot(const Point &a, const Point &b) {\n\treturn (a * b).sum();\n}\n\nPoint cross(const Point &a, const Point &b) {\n\treturn a.cshift(+1) * b.cshift(-1) - a.cshift(-1) * b.cshift(+1);\n}\n\nld norm(const Point &a) { return dot(a, a); }\nld dist(const Point &a) { return sqrt(norm(a)); }\n\n// Line\n\nstruct Line { Point a, b; };\n\nbool is_in_segment(Line l, Point p) {\n\treturn abs(dist(l.a - p) + dist(l.b - p) - dist(l.a - l.b)) < eps;\n}\n\nPoint project_lp(Line l, Point p) {\n\tPoint point = l.a, vec = l.b - l.a;\n\treturn point + dot(p - point, vec) / norm(vec) * vec;\n}\n\nld distance_lp(Line l, Point p) {\n\treturn dist(p - project_lp(l, p));\n}\n\nld distance_sp(Line l, Point p) {\n\tPoint proj = project_lp(l, p);\n\tif (dist(l.a - proj) + dist(l.b - proj) < dist(l.b - l.a) + eps)\n\t\treturn dist(p - proj);\n\telse\n\t\treturn min(dist(p - l.a), dist(p - l.b));\n}\n\nstruct Sphere { Point p; ld r; ll l; };\n\nint main()\n{\n\tint n, q; cin >> n >> q;\n\tvector<Sphere> v;\n\tREP(i, n)\n\t{\n\t\tld x, y, z, r;\n\t\tint l; cin >> x >> y >> z >> r >> l;\n\t\tv.emplace_back(Sphere{ make_point(x,y,z),r,l });\n\t}\n\tREP(i, q)\n\t{\n\t\tll ans = 0;\n\t\tld x[2], y[2], z[2];\n\t\tREP(j, 2) cin >> x[j] >> y[j] >> z[j];\n\t\tLine l{ make_point(x[0], y[0], z[0]), make_point(x[1], y[1], z[1]) };\n\t\tREP(j, n)\n\t\t{\n\t\t\tld d = distance_sp(l, v[j].p);\n\t\t\tif (v[j].r - d > -eps) ans += v[j].l;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\n#define vec vector\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nusing namespace std;\n\ndouble sx, sy, sz, dx, dy, dz;\n\nint outside(double a, double b, double c)\n{\n\tdouble x, y, z;\n\tx = sqrt((a - sx) * (a - sx) + (b - sy) * (b - sy) + (c - sz) * (c - sz));\n\ty = sqrt((a - dx) * (a - dx) + (b - dy) * (b - dy) + (c - dz) * (c - dz));\n\tz = sqrt((sx - dx) * (sx - dx) + (sy - dy) * (sy - dy) + (sz - dz) * (sz - dz));\n\n\tdouble keep1 = (x * x + z * z - y * y) / (2 * x * z);\n\tdouble keep2 = (y * y + z * z - x * x) / (2 * y * z);\n\n\tif (keep1 < 0) return 1;\n\telse if (keep2 < 0) return 2;\n\telse return 0;\n}\n\n\nint main(void)\n{\n\tint n, q;\n\tcin >> n >> q;\n\n\tvec<double> x(n), y(n), z(n), r(n);\n\tvec<int> l(n);\n\n\trep(i, n) cin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\n\trep(i, q) {\n\t\tcin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tint ans = 0;\n\t\trep(j, n) {\n\t\t\tint w = outside(x[j], y[j], z[j]);\n\t\t\tif (w == 1) {\n\t\t\t\tif ((x[j] - sx) * (x[j] - sx) + (y[j] - sy) * (y[j] - sy) + (z[j] - sz) * (z[j] - sz) <= r[j] * r[j]) ans += l[j];\n\t\t\t}\n\t\t\telse if (w == 2) {\n\t\t\t\tif ((x[j] - dx) * (x[j] - dx) + (y[j] - dy) * (y[j] - dy) + (z[j] - dz) * (z[j] - dz) <= r[j] * r[j]) ans += l[j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdouble v1 = sx - dx;\n\t\t\t\tdouble v2 = sy - dy;\n\t\t\t\tdouble v3 = sz - dz;\n\t\t\t\tdouble v = v1 * v1 + v2 * v2 + v3 * v3;\n\t\t\t\tdouble t = (v1 * (x[j] - sx) + v2 * (y[j] - sy) + v3 * (z[j] - sz)) / v;\n\t\t\t\tif ((x[j] - sx) * (x[j] - sx) + (y[j] - sy) * (y[j] - sy) + (z[j] - sz) * (z[j] - sz) - v * t * t <= r[j] * r[j]) ans += l[j];\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define D 1e-9\ntypedef struct _vec{\n    double x, y, z;\n} vec;\n\ndouble Dis(vec A, vec B){\n    double dis = (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) + (A.z-B.z)*(A.z-B.z);\n    //cout << dis << \" o \" <<  endl;\n    dis = pow(dis, 0.5);\n    //cout << dis << \" o \" <<  endl;    \n    return dis;\n}\n\ndouble norm(vec A, vec B){             //内積\n    double res;\n    res = A.x*B.x + A.y*B.y + A.z*B.z;   \n\n    return res;\n}\n\nvec tanni(vec A){                   //単位ベクトルを返す\n    double dis = A.x*A.x + A.y*A.y + A.z*A.z;\n    dis = pow(dis, 0.5);\n    vec res;\n    res.x = A.x / dis;\n    res.y = A.y / dis;\n    res.z = A.z / dis;\n\n    return res;    \n}\n\nvec houkou(vec A, vec B){             //方向ベクトルを返す\n    vec res;\n    //cout << B.x << \" \" << A.x << endl;\n    res.x = B.x - A.x;\n    res.y = B.y - A.y;\n    res.z = B.z - A.z;\n    return res;\n}\n\nint main(){\n\n    /*vec V1, V2;\n    V1.x = 3;\n    V1.y = 4;\n    V1.z = 5;\n    V2.x = 6;\n    V2.y = 3;\n    V2.z = 8;\n\n    cout << norm(V1, V2) << endl;\n    cout << Dis(V1, V2) << endl;\n    vec V3 = tanni(V1);\n    cout << V3.x << \" \" << V3.y << \" \" << V3.z << endl;\n    vec V4 = houkou(V1, V2);\n    cout << V4.x << \" \" << V4.y << \" \" << V4.z << endl;*/\n    \n\n    int n, q; cin >> n >> q;\n    vector<vec> obj(n);\n    vector<vec> blue(q);\n    vector<vec> red(q);    \n    vector<double> r(n);\n    vector<long long> l(n);\n\n    for(int i = 0; i < n; i++){\n        double a, b, c, d, e; cin >> a >> b >> c >> d >> e;\n        obj[i].x = a;\n        obj[i].y = b;\n        obj[i].z = c;\n        r[i] = d;\n        l[i] = e;                \n    }\n\n    for(int i = 0; i < q; i++){\n        double a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f;\n        blue[i].x = d;\n        blue[i].y = e;\n        blue[i].z = f;\n        red[i].x = a;\n        red[i].y = b;\n        red[i].z = c;        \n    }\n\n\n\n    for(int i = 0; i < q; i++){\n\n        long long ans = 0;\n\n        for(int j = 0; j < n; j++){\n            //j個目の障害物とはどうですか\n            vec H;\n            H.x = red[i].x;\n            H.y = red[i].y;\n            H.z = red[i].z;            \n\n            vec u;\n            u = houkou(red[i], blue[i]);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;            \n            u = tanni(u);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;\n            vec a;\n            a.x = obj[j].x - red[i].x;\n            a.y = obj[j].y - red[i].y;\n            a.z = obj[j].z - red[i].z;\n            //cout << a.x << \" \" << a.y << \" \" <<  a.z << endl;           \n            double _norm = norm(a, u);\n            //cout << _norm << endl;\n            vec w;\n            w.x = _norm*u.x;\n            w.y = _norm*u.y;\n            w.z = _norm*u.z;\n            //cout << endl;\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << w.x << \" \" << w.y << \" \" << w.z << endl;\n            H.x += w.x;\n            H.y += w.y;\n            H.z += w.z;\n\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << obj[j].x << \" \" << obj[j].y << \" \" << obj[j].z << endl;\n\n            double _dis = Dis(H, obj[j]);\n            //cout << j << \" \" << _dis << endl;\n            //cout << _dis << endl;\n\n            bool flag = (red[i].x <= H.x + D && H.x - D <= blue[i].x) || (blue[i].x <= H.x + D && H.x - D <= red[i].x);                         //線分上にあるか\n\n            if(_dis <= r[j] + D) ans += l[j];            \n            //cout << ans << endl;\n        \n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\nstruct po{int x,y,z,r; long long l;};\nstruct popo{int x,y,z;};\n\ndouble mk_dis(popo a,popo b){\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nint main(){\n  int n,q;\n  cin >>n>>q;\n  po ball[51];\n  for(int i=0;i<n;i++)cin>>ball[i].x>>ball[i].y>>ball[i].z>>ball[i].r>>ball[i].l;\n  \n  for(int i=0;i<q;i++){\n    int a1,a2,b1,b2,c1,c2;\n    double dis[3];\n    cin >>a1>>b1>>c1>>a2>>b2>>c2;\n    dis[0] = mk_dis((popo){a1,b1,c1},(popo){a2,b2,c2});\n    long long ans=0;\n    for(int j=0;j<n;j++){\n      dis[1] = mk_dis((popo){a1,b1,c1},(popo){ball[j].x,ball[j].y,ball[j].z});\n      dis[2] = mk_dis((popo){a2,b2,c2},(popo){ball[j].x,ball[j].y,ball[j].z});\n      double s = (dis[0]+dis[1]+dis[2])/2.0;\n      double S = sqrt(s*(s-dis[0])*(s-dis[1])*(s-dis[2]));\n      double h = (2*S)/dis[0];\n      \n      if(dis[1]<=ball[j].r || dis[2]<=ball[j].r) {\n\tans+=ball[j].l;\n\tcontinue;\n      }\n\n      if(abs(sqrt(dis[1]*dis[1]-h*h)+sqrt(dis[2]*dis[2]-h*h)-dis[0]) > 0.0000001)continue;\n      if( h > ball[j].r)continue;\n      ans+=ball[j].l;\n    }\n    cout << ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst ld eps = 1e-12;\n\nint main() {\n\tint N, Q; cin >> N >> Q;\n\tvector<ll> X(N), Y(N), Z(N), R(N), L(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> Z[i] >> R[i] >> L[i];\n\t}\n\tfor (int q = 0; q < Q; ++q) {\n\t\tll sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n\t\tll a = dx - sx, b = dy - sy, c = dz - sz;\n\t\tif (a == 0 && b == 0 && c == 0) cout << 0 << endl;\n\t\telse {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint d = a * X[i] + b * Y[i] + c * Z[i];\n\t\t\t\tll den = a*a + b*b + c*c;\n\t\t\t\tll t = d - a * sx - b * sy - c * sz; // t / den\n\t\t\t\tll x = den * sx + a * t; // x / den\n\t\t\t\tll y = den * sy + b * t;\n\t\t\t\tll z = den * sz + c * t;\n\t\t\t\tll xx = den*X[i]-x, yy = den*Y[i]-y, zz = den*Z[i]-z;\n\t\t\t\tif ( 0 < t && t < den ) {\n\t\t\t\t\tll rr = xx*xx + yy*yy + zz*zz;\n\t\t\t\t\tif (rr <= den*den*R[i]*R[i]) {\n\t\t\t\t\t\tans += L[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tll rr = (X[i]-sx)*(X[i]-sx) + (Y[i]-sy)*(Y[i]-sy) + (Z[i]-sz)*(Z[i]-sz);\n\t\t\t\t\trr = min(rr, (X[i]-dx)*(X[i]-dx) + (Y[i]-dy)*(Y[i]-dy) + (Z[i]-dz)*(Z[i]-dz));\n\t\t\t\t\tif (rr < R[i]*R[i]) {\n\t\t\t\t\t\tans += L[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    \n    typedef double real;\n    typedef long long ll;\n\n    const real EPS = 1e-9;\n\n    struct Point {\n        real x, y, z;\n        Point() {}\n        Point(real x, real y, real z) : x(x), y(y), z(z) {}\n        Point operator-() const { return Point(-x, -y, -z); }\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n        Point operator-(const Point& p) const { return (*this) + (-p); }\n        Point operator*(real k) const { return Point(x * k, y * k, z * k); }\n        Point operator/(real k) const { return (*this) * (1.0 / k); }\n    };\n    real dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\n    real norm(const Point& a) { return sqrt(dot(a, a)); }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y >> p.z; }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n\n    Point projection(const Line& l, const Point& p) {\n        Point u = (p - l.a), v = (l.b - l.a);\n        return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n    }\n\n    real distance(const Line& l, const Point& p) {\n        Point q = projection(l, p);\n        return norm(p - q);\n    }\n\n    int N, Q;\n    vector<Point> P;\n    vector<real> R;\n    vector<ll> L;\n    void solve() {\n        cin >> N >> Q;\n        P.clear(); P.resize(N);\n        R.clear(); R.resize(N);\n        L.clear(); L.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> R[i] >> L[i];\n        }\n        for (int q = 0; q < Q; q++) {\n            Point s, t;\n            cin >> s >> t;\n            Line l(s, t);\n            ll ans = 0;\n            for (int i = 0; i < N; i++) {\n                if (distance(l, P[i]) <= R[i] + EPS) {\n                    ans += L[i];\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define EPS (1e-10)\n\nstruct P{\n  double X, Y, Z;\n};\n\nnamespace std{\n  P operator-(const P& a, const P& b){\n    P ret = {a.X-b.X, a.Y-b.Y, a.Z-b.Z};\n    return ret;\n  }\n}\n\ndouble dot_3d(P a, P b){\n  return a.X*b.X + a.Y*b.Y + a.Z*b.Z;\n}\n\nP cross(P a, P b){\n  P ret = {a.Y*b.Z-a.Z*b.Y,a.Z*b.X-a.X*b.Z,a.X*b.Y-a.Y*b.X};\n  return ret;\n}\n\ndouble norm_3d(P a){\n  return a.X*a.X + a.Y*a.Y + a.Z*a.Z;\n}\n\nint main(){\n  int N, Q;\n  cin >> N >> Q;\n  vector<P> obs(N);\n  vector<int> r(N), l(N);\n  for(int i = 0; i < N; ++i){\n    cin >> obs[i].X >> obs[i].Y >> obs[i].Z >> r[i] >> l[i];\n  }\n  P s, d;\n  for(int i = 0; i < Q; ++i){\n    cin >> s.X >> s.Y >> s.Z >> d.X >> d.Y >> d.Z;\n    P v = d-s;\n    int ans = 0;\n    for(int j = 0; j < N; ++j){\n      if(norm_3d(cross(v,obs[j]-s))/norm_3d(v) <= r[j]*r[j]+EPS &&\n\t dot_3d(v,obs[j]-s) >= -EPS && dot_3d(s-d,obs[j]-d) >= -EPS) ans += l[j];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\ntypedef struct O{int x,y,z,r,l;}O;\ntypedef struct P{int x,y,z;}P;\ntypedef struct V{double x,y,z;}V;\n\nO obj[51];\nP s,t,v;\nint N,Q,i,j,res;\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d%d\",&obj[i].x,&obj[i].y,&obj[i].z,&obj[i].r,&obj[i].l);\n\tfor(i=0;i<Q;i++)\n\t{\n\t\tres=0;\n\t\tscanf(\"%d%d%d%d%d%d\",&s.x,&s.y,&s.z,&t.x,&t.y,&t.z);\n\t\tfor(j=0;j<N;j++)\n\t\t{\n\t\t\tP v={t.x-s.x,t.y-s.y,t.z-s.z};\n\t\t\tdouble a=v.x*(obj[j].x-s.x)+v.y*(obj[j].y-s.y)+v.z*(obj[j].z-s.z);\n\t\t\tdouble b=v.x*v.x+v.y*v.y+v.z*v.z;\n\t\t\tdouble c=abs(a/b);\n\t\t\tV l={s.x+v.x*c,s.y+v.y*c,s.z+v.z*c};\n\t\t\tdouble len=sqrt(pow(l.x-obj[j].x,2)+pow(l.y-obj[j].y,2)+pow(l.z-obj[j].z,2));\n\t\t\tif(len-obj[j].r<=0)\n\t\t\t\tres+=obj[j].l;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\ntemplate<typename T> using VT = vector<T>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\ntemplate<typename T>inline bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>inline bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nnamespace Geometry3D {\n    const long double EPS = 1e-10;\n    double add(double a, double b) {\n        if (abs(a + b) < Geometry3D::EPS * (abs(a) + abs(b))) return 0;\n        return a + b;\n    }\n    int sgn(double a, double b = 0.0) {// sign function\n        return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;\n    }\n\n    struct Point {\n        double x, y, z;\n        Point() {}\n        Point(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}\n        const Geometry3D::Point operator+ (const Geometry3D::Point &p) {\n            return Point(Geometry3D::add(this->x, p.x), Geometry3D::add(this->y, p.y), Geometry3D::add(this->z, p.z));\n        }\n        const Geometry3D::Point operator- (const Geometry3D::Point &p) {\n            return Point(Geometry3D::add(this->x, -p.x), Geometry3D::add(this->y, -p.y), Geometry3D::add(this->z, -p.z));\n        }\n        const Geometry3D::Point operator* (double d) {\n            return Point(this->x * d, this->y * d, this->z * d);\n        }\n        double norm() { //????????¨???????±????????????????????????¶?????????2???\n            return this->x * this->x + this->y * this->y + this->z * this->z;\n        }\n        double distance() {\n            return sqrt(this->norm());\n        }\n    };\n\n    double naiseki(const Geometry3D::Point &p1, const Geometry3D::Point &p2) {\n        return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n    }\n    Geometry3D::Point gaiseki(const Geometry3D::Point &p1, const Geometry3D::Point &p2) {\n        return Geometry3D::Point(p1.y * p2.z - p2.y * p1.z, -(p1.x * p2.z - p2.x * p1.z), p1.x * p2.y - p2.x * p1.y);\n    }\n\n    struct Line {\n        Geometry3D::Point a, b, dis;\n        Line() {}\n        Line(const Geometry3D::Point &_a, const Geometry3D::Point &_b) : a(_a), b(_b), dis(b - a) {}\n        double distSquare() {\n            const double X = this->a.x - this->b.x;\n            const double Y = this->a.y - this->b.y;\n            const double Z = this->a.z - this->b.z;\n            return X * X + Y * Y + Z * Z;\n        }\n        double distance() {\n            return this->distSquare();\n        }\n    };\n    using Segment = Geometry3D::Line;\n\n    double distanceLineToPoint(Geometry3D::Line &l, Geometry3D::Point &p) {\n        return Geometry3D::gaiseki(l.dis, p - l.a).distance() / l.dis.distance();\n    }\n\n    double distanceSegmentToPoint(Geometry3D::Segment &l, Geometry3D::Point &p) {\n        if (Geometry3D::naiseki(l.b - l.a, p - l.a) < 0) {\n            auto buf = p - l.a;\n            return buf.distance();\n        }\n        if (Geometry3D::naiseki(l.a - l.b, p - l.b) < 0) {\n            auto buf = p - l.b;\n            return buf.distance();\n        }\n        return Geometry3D::distanceLineToPoint(l, p);\n    }\n\n    struct Ball {\n        Geometry3D::Point center;\n        double r;\n        Ball() {}\n        Ball(double _x, double _y, double _z, double _r) : center(_x, _y, _z), r(_r) {}\n        Ball(const Geometry3D::Point &_c, double _r) : center(_c), r(_r) {}\n        bool inside(const Geometry3D::Point &p) {\n            const double X = p.x - this->center.x;\n            const double Y = p.y - this->center.y;\n            const double Z = p.z - this->center.z;\n            return sgn(X * X + Y * Y + Z * Z, -(this->r * this->r)) == -1;\n        }\n        bool inside(Geometry3D::Segment &s) {\n            return Geometry3D::sgn(Geometry3D::distanceSegmentToPoint(s, this->center) - this->r) == -1;\n        }\n        bool on_seg(const Geometry3D::Point &p) {\n            const double X = p.x - this->center.x;\n            const double Y = p.y - this->center.y;\n            const double Z = p.z - this->center.z;\n            return sgn(X * X + Y * Y + Z * Z, -(this->r * this->r)) == 0;\n        }\n        bool on_seg(Geometry3D::Segment &s) {\n            return Geometry3D::sgn(Geometry3D::distanceSegmentToPoint(s, this->center) - this->r) == 0;\n        }\n    };\n};\n\nvoid init();\nvoid last();\n\nvoid init() {\n\n}\n\nusing Geometry3D::Point;\nusing Geometry3D::Segment;\nusing Geometry3D::Ball;\nconst int MAX = 55;\npair<Ball, long long> ball[MAX];\nSegment seg[MAX];\nvoid solve(int n, int q) {\n    for (int i = 0; i < n; i++) {\n        int x, y, z, r;\n        long long l;\n        scanf(\"%d%d%d%d%lld\", &x, &y, &z, &r, &l);\n        ball[i] = make_pair(Ball(Point(x, y, z), r), l);\n    }\n    for (int i = 0; i < q; i ++) {\n        int sx, sy, sz, dx, dy, dz;\n        scanf(\"%d%d%d%d%d%d\", &sx, &sy, &sz, &dx, &dy, &dz);\n        seg[i] = Segment(Point(sx, sy, sz), Point(dx, dy, dz));\n    }\n    for (int i = 0; i < q; i++) {\n        long long ans = 0;\n        for (int j = 0; j < n; j++) {\n            if (ball[j].first.on_seg(seg[i]) || ball[j].first.inside(seg[i])) {\n                ans += ball[j].second;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    exit(0);\n}\n\nvoid refresh() {\n\n}\n\nvoid last() {\n    exit(0);\n}\n\nint main(void) {\n\tint a, b, c, x, y, z, n, m, p, k;\n\tstring s;\n\twhile (cin >> n >> m, n) {\n\t\tsolve(n, m);\n        refresh();\n\t}\n    last();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_3d {\n\nusing Real = long double;\n\nReal const EPS = 1e-9;  // !!! DO CHECK EPS !!!\n\nstruct P3 {\n  Real x, y, z;\n  P3(): x(0), y(0), z(0){}\n  P3(Real x, Real y, Real z): x(x), y(y), z(z){};\n  P3 operator + (P3 const& r) const { return P3(x+r.x, y+r.y, z+r.z); }\n  P3 operator - (P3 const& r) const { return P3(x-r.x, y-r.y, z-r.z); }\n  P3 operator * (Real k) const { return P3(x * k, y * k, z * k); }\n  P3 operator / (Real k) const { return P3(x / k, y / k, z / k); }\n};\n\nReal dot(P3 const& l, P3 const& r) { return l.x*r.x + l.y*r.y + l.z*r.z; }\nP3 cross(P3 const& l, P3 const& r) { return P3(l.y*r.z - l.z*r.y, l.z*r.x - l.x*r.z, l.x*r.y - l.y*r.x); }  // not verified\n\nReal norm(P3 const& p) { return p.x*p.x + p.y*p.y + p.z*p.z; }\nReal abs(P3 const& p) { return sqrt(p.x*p.x + p.y*p.y + p.z*p.z); }\nReal cos(P3 const& l, P3 const& r) { return dot(l, r) / (abs(l) * abs(r)); }\nReal angle(P3 const& l, P3 const& r) { return acos(cos(l, r)); }  // not verified\n\nistream& operator >> (istream& is, P3& p) { Real x, y, z; is >> x >> y >> z; p = P3(x, y, z); return is; }\nostream& operator << (ostream& os, P3& p) { return os << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\"; }\n\nstruct Line: public pair<P3, P3> {\n  P3 const& operator[](int idx) const { return idx == 0 ? first : second; }\n  P3& operator[](int idx) { return idx == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nReal distance_lp(Line const& l, P3 const& p) {  // not verified\n  return abs(p - l[0]) * sin(angle(l[1] - l[0], p - l[0]));\n}\n\nP3 projection(Line const& l, P3 const& p) {\n  Real t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + (l[0]-l[1]) * t;\n}\n\nbool intersect_sp(Segment const& s, P3 const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nReal distance_sp(Segment const& s, P3 const& p) {\n  P3 const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p); // ?°???±?????????????????????????????????\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n}\nusing namespace point_3d;\n\nint main() {\n\n  int N, Q; cin >> N >> Q;\n  vector<tuple<P3, Real, ll>> os;\n  rep(i, N) {\n    P3 p; Real r; ll l; cin >> p >> r >> l;\n    os.emplace_back(p, r, l);\n  }\n\n  rep(_, Q) {\n    ll ans = 0;\n    Segment beam; cin >> beam[0] >> beam[1];\n\n    auto intersect_segment_sphere = [&](int oidx) {\n      P3 c; Real r; ll _; tie(c, r, _) = os[oidx];\n      return distance_sp(beam, c) <= r + EPS;\n    };\n\n    rep(i, N) {\n      if(intersect_segment_sphere(i)) {\n        ans += get<2>(os[i]);\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  Point dir = l[1] - l[0];\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  if(D < -EPS) return false;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(0 < t1 && t1 < 1){\n    return true;\n  }\n  if(0 < t2 && t2 < 1){\n    return true;\n  }\n  return false;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(hasCrosspointLC(line,obstacles[obstacle_i])){\n          sum += costs[obstacle_i];\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nstruct Point {\n\tdouble x, y, z;\n\tPoint(): x(0), y(0), z(0) {}\n\tPoint(double x, double y, double z): x(x), y(y), z(z) {}\n\tconst Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n\tconst Point operator-(const Point& p) const { return *this + (-p); }\n\tconst Point operator-() const { return Point(-x, -y, -z); }\n\tconst Point operator*(const double d) const { return Point(d * x, d * y, d * z); }\n\tconst Point operator/(const double d) const { return *this * (1 / d); }\n\tconst double norm2() const { return x * x + y * y + z * z; }\n};\n\ndouble mindist(Point p1, Point p2, Point t) {\n\tfor (int i = 0; i < 100; i++) {\n\t\t//cout << fixed << setprecision(3) << p1.x << \" \" << p1.y << \" \" << p1.z << \" \" << p2.x << \" \" << p2.y << \" \" << p2.z << endl;\n\t\t\n\t\tPoint pl = (p1 * 2 + p2) / 3;\n\t\tPoint pr = (p1 + p2 * 2) / 3;\n\t\t\n\t\tdouble distl = (pl - t).norm2();\n\t\tdouble distr = (pr - t).norm2();\n\n\t\tif (distl < distr) {\n\t\t\tp2 = pr;\n\t\t} else {\n\t\t\tp1 = pl;\n\t\t}\n\t}\n\n\treturn sqrt((p1 - t).norm2());\n}\n\nint main() {\n\tint n, q; cin >> n >> q;\n\t\n\tvector<Point> p(n);\n\tvector<double> r(n);\n\tvector<ll> l(n);\n\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> p[i].x >> p[i].y >> p[i].z >> r[i] >> l[i];\n\n\tconst double eps = 1e-8;\n\n\tfor (int i = 0; i < q; i++) {\n\t\tPoint p1, p2;\n\t\tcin >> p1.x >> p1.y >> p1.z >> p2.x >> p2.y >> p2.z;\n\t\t\n\t\tll score = 0;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tdouble d;\n\t\t\tif ((d = mindist(p1, p2, p[j])) <= r[j] + eps) {\n\t\t\t\tscore += l[j];\n\t\t\t}\n\t\t\t//cout << fixed << setprecision(10) << d << \" \" << l[j] << endl;\n\t\t}\n\t\tcout << score << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\n// typedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst double EPS = 1e-10;\n\nstruct P {\n    double x, y, z;\n    P(){}\n    P(double _x, double _y, double _z) : x(_x), y(_y), z(_z) {}\n    const P operator+ (const P& p) {\n        return P(this->x + p.x, this->y + p.y , this->z + p.z);\n    }\n    const P operator- (const P &p) {\n        return P(this->x - p.x, this->y - p.y , this->z - p.z);\n    }\n    void print() {\n        printf(\"%.1f %.1f %.1f\\n\", x, y, z);\n    }\n};\n\ndouble dot(const P& p, const P& q) {\n    return p.x * q.x + p.y * q.y + p.z * q.z;\n}\n\nP cross(P p, P q) {\n    return P(p.y * q.z - p.z * q.y, p.z * q.x - p.x * q.z, p.x * q.y - p.y * q.x);\n}\n\nstruct C {\n    P c;\n    double r;\n    C(){}\n    C(P _c, double _r) : c(_c), r(_r) {}\n};\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n};\n\ndouble distance(P p) {\n    return sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n}\n\ndouble distanceLP(L l, P p) {\n    return distance(cross(l.v, p - l.a)) / distance(l.v);\n}\n\ndouble distanceSP(L l, P p) {\n    if (dot(l.b - l.a, p - l.a) < 0) return distance(p - l.a);\n    if (dot(l.a - l.b, p - l.b) < 0) return distance(p - l.b);\n    return distanceLP(l, p);\n}\n\nbool intersectSC(L s, C c) {\n    return distanceSP(s, c.c) < c.r + EPS;\n}\n\nC readC() {\n    double x, y, z, r;\n    cin >> x >> y >> z >> r;\n    return C(P(x, y, z), r);\n}\n\nL readL() {\n    double x1, y1, z1, x2, y2, z2;\n    cin >> x1 >> y1 >> z1 >> x2 >> y2 >> z2;\n    return L(P(x1, y1, z1), P(x2, y2, z2));\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<C> circles(N);\n    V l(N);\n    rep(i, N) {\n        circles[i] = readC();\n        cin >> l[i];\n    }\n\n    while (Q--) {\n        L s = readL();\n        int ans = 0;\n        rep(i, N) {\n            if (intersectSC(s, circles[i])) {\n                ans += l[i];\n            }\n        }\n        cout << ans << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define EPS (1e-9)\nusing namespace std;\ntypedef long long ll;\n\nstruct Vector{\n\tdouble x,y,z;\n\tVector(){}\n\tVector(double x,double y,double z):x(x),y(y),z(z){}\n\tdouble norm(){return x*x+y*y+z*z;}\n\tdouble abs(){return sqrt(norm());}\n\tVector normalize(){\n\t\tdouble d=abs();\n\t\treturn Vector(x/=d,y/=d,z/=d);\n\t}\n\tVector operator+(const Vector&u)const{\n\t\treturn Vector(x+u.x,y+u.y,z+u.z);\n\t}\n\tVector operator-(const Vector&u)const{\n\t\treturn Vector(x-u.x,y-u.y,z-u.z);\n\t}\n\tdouble dot(const Vector&u)const{\n\t\treturn x*u.x+y*u.y+z*u.z;\n\t}\n};\nstruct Sphere{\n\tVector p;\n\tdouble r;\n\tSphere(){}\n\tSphere(Vector p,double r):p(p),r(r){}\n};\nstruct Ray{\n\tVector p,d;\n\tRay(Vector p,Vector d):p(p),d(d){}\n\tdouble intersect(Sphere c){\n\t\td.normalize();\n\t\tdouble B=-d.dot(c.p-p);\n\t\tdouble C=(p-c.p).norm()-c.r*c.r;\n\t\tdouble D=B*B-C;\n\t\tif(D<EPS)return -1;\n\t\tdouble E=sqrt(D);\n\t\tif(-B+E<EPS)return -1;\n\t\tif(-B-E>EPS)return -B-E;\n\t\treturn -B+E;\n\t}\n};\n\nSphere s[100];\nll l[100];\n\nint main(){\n\tint n,q;scanf(\"%d%d\",&n,&q);\n\trep(i,n){\n\t\tdouble x,y,z,r;\n\t\tcin>>x>>y>>z>>r>>l[i];\n\t\ts[i]=Sphere(Vector(x,y,z),r);\n\t}\n\trep(i,q){\n\t\tdouble sx,sy,sz;cin>>sx>>sy>>sz;\n\t\tdouble gx,gy,gz;cin>>gx>>gy>>gz;\n\t\tRay L(Vector(sx,sy,sz),Vector(gx,gy,gz)-Vector(sx,sy,sz));\n\t\tdouble T=(Vector(gx,gy,gz)-Vector(sx,sy,sz)).abs();\n\t\tll ans=0;\n\t\trep(j,n){\n\t\t\tdouble t=L.intersect(s[j]);\n\t\t\tif(t>EPS&&t<=T)ans+=l[j];\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\nstruct Point{\n  ll x,y,z;\n  Point(){};\n  Point(ll x,ll y,ll z):x(x),y(y),z(z){}\n  Point operator+(Point p){\n    return Point(x+p.x,y+p.y,z+p.z);\n  }\n  Point operator-(Point p){\n    return Point(x-p.x,y-p.y,z-p.z);\n  }\n};\nll dot(Point a,Point b){\n  return (a.x*b.x+a.y*b.y+a.z*b.z);\n}\nstruct ball{\n  Point p;\n  ll r,l;\n};\ntypedef Point Vector;\nint check(ball ba,Point x,Point y){\n  ll z=0;\n  Vector v=y-x,c=ba.p-x;\n  if(dot(v,c)<=0){\n    if(dot(c,c)<=ba.r*ba.r) z=ba.l;\n  }else{\n    if(dot(v,c)>dot(v,v)){\n      if(dot(ba.p-y,ba.p-y)<=ba.r*ba.r) z=ba.l;\n    }else{\n      if(dot(c,c)*dot(v,v)-(dot(v,c)*dot(v,c))<=ba.r*ba.r*dot(v,v))  z=ba.l;\n    }\n  }\n  return z;\n}\nint main(){\n  ll n,q;\n  cin >> n >> q;\n  ball bs[51];\n  int i,j,k;\n  \n  ll x,y,z;\n  for(i=0;i<n;i++){\n    cin >>  x >>  y >>  z >> bs[i].r >> bs[i].l;\n    bs[i].p=Point(x,y,z);\n  }\n  for(i=0;i<q;i++){\n    Point p,b;\n    cin >> x >> y >> z;\n    p=Point(x,y,z);\n    cin >> x >> y >> z;\n    b=Point(x,y,z);\n    ull o=0;\n    for(j=0;j<n;j++){\n      o+=check(bs[j],p,b);\n    }\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define STEPS 100000\n\nusing namespace std;\n\nint N, Q, x[50], y[50], z[50], r[50], sx, sy, sz, dx, dy, dz; long long l[50]; bool used[50];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &Q);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t\tscanf(\"%d\", &z[i]);\n\t\tscanf(\"%d\", &r[i]);\n\n\t\tscanf(\"%lld\", &l[i]);\n\t}\n\n\tfor (int i = 0; i < Q; i++)\n\t{\n\t\tscanf(\"%d\", &sx);\n\t\tscanf(\"%d\", &sy);\n\t\tscanf(\"%d\", &sz);\n\t\tscanf(\"%d\", &dx);\n\t\tscanf(\"%d\", &dy);\n\t\tscanf(\"%d\", &dz);\n\n\t\tlong double vx = 1.0 * (sx - dx) / STEPS;\n\t\tlong double vy = 1.0 * (sy - dy) / STEPS;\n\t\tlong double vz = 1.0 * (sz - dz) / STEPS;\n\n\t\tlong double tx = sx;\n\t\tlong double ty = sy;\n\t\tlong double tz = sz;\n\n\t\tfor (int j = 0; j < N; j++) used[j] = false;\n\n\t\tfor (int j = 0; j <= STEPS; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tlong double rx = tx - x[i];\n\t\t\t\tlong double ry = ty - y[i];\n\t\t\t\tlong double rz = tz - z[i];\n\n\t\t\t\tif (rx * rx + ry * ry + rz * rz <= r[i] * r[i] + 0.000001)\n\t\t\t\t{\n\t\t\t\t\tused[k] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttx -= vx;\n\t\t\tty -= vy;\n\t\t\ttz -= vz;\n\t\t}\n\n\t\tlong long ret = 0;\n\n\t\tfor (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (used[j])\n\t\t\t{\n\t\t\t\tret += l[j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint n, q;\nint x[50], y[50], z[50], r[50];\nlong long s[50];\nint a, b, c, d, e, f;\nint cx, cy, cz;\nlong long score;\n\ndouble search(int x1, int y1, int z1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tint dx, dy, dz, tx, ty, tz;\n\tdouble dis, dismin = 1000.00;\n\tfor (double k = 0; k < max(x2, max(y2, z2)); k += 0.01) {\n\t\tif (x2 >= y2 && x2 >= z2) {\n\t\t\tdx = k;\n\t\t\tdy = (dx / x2)*y2;\n\t\t\tdz = (dx / x2)*z2;\n\t\t}\n\t\telse if (y2 >= x2 && y2 >= z2) {\n\t\t\tdy = k;\n\t\t\tdx = (dy / y2)*x2;\n\t\t\tdz = (dy / y2)*z2;\n\t\t}\n\t\telse {\n\t\t\tdz = k;\n\t\t\tdx = (dz / z2)*x2;\n\t\t\tdy = (dz / z2)*y2;\n\t\t}\n\t\ttx = dx + x1 - x3;\n\t\tty = dy + y1 - y3;\n\t\ttz = dz + z1 - z3;\n\t\tdis = sqrt(1.0*(double)(tx*tx + ty*ty + tz*tz));\n\t\tdismin = min(dismin, dis);\n\t}\n\treturn dismin;\n}\n\nbool hantei(int x1, int y1, int z1, int r1, int x2, int y2, int z2, int x3, int y3, int z3) {\n\tdouble a = search(x3, y3, z3, x2, y2, z2, x1, y1, z1);\n\tif (a <= r1) { return true; }\n\treturn false;\n}\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> s[i];\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tscore = 0;\n\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\tcx = d - a;\n\t\tcy = e - b;\n\t\tcz = f - c;\n\t\tfor (int j = 0; j < q; j++) {\n\t\t\tif (hantei(x[j], y[j], z[j], r[j], cx, cy, cz, a, b, c) == true) {\n\t\t\t\tscore += s[j];\n\t\t\t}\n\t\t}\n\t\tcout << score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    \n    typedef double real;\n\n    struct Point {\n        real x, y, z;\n        Point() {}\n        Point(real x, real y, real z) : x(x), y(y), z(z) {}\n        Point operator-() const { return Point(-x, -y, -z); }\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y, z + p.z); }\n        Point operator-(const Point& p) const { return (*this) + (-p); }\n        Point operator*(real k) const { return Point(x * k, y * k, z * k); }\n        Point operator/(real k) const { return (*this) * (1.0 / k); }\n    };\n    real dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\n    real norm(const Point& a) { return sqrt(dot(a, a)); }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y >> p.z; }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(Point a, Point b) : a(a), b(b) {}\n    };\n\n    Point projection(const Line& l, const Point& p) {\n        Point u = (p - l.a), v = (l.b - l.a);\n        return l.a + (v / norm(v)) * (dot(u, v) / norm(v));\n    }\n\n    real distance(const Line& l, const Point& p) {\n        Point q = projection(l, p);\n        return norm(p - q);\n    }\n\n    int N, Q;\n    vector<Point> P;\n    vector<real> R, L;\n    void solve() {\n        cin >> N >> Q;\n        P.clear(); P.resize(N);\n        R.clear(); R.resize(N);\n        L.clear(); L.resize(N);\n        for (int i = 0; i < N; i++) {\n            cin >> P[i] >> R[i] >> L[i];\n        }\n        for (int q = 0; q < Q; q++) {\n            Point s, t;\n            cin >> s >> t;\n            Line l(s, t);\n            real ans = 0;\n            for (int i = 0; i < N; i++) {\n                if (distance(l, P[i]) <= R[i]) {\n                    ans += L[i];\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\ntypedef double P_type;\ntypedef double G_real; //実数の戻り値(float or double or long double)\nconst G_real P_eps = 1e-8; //整数の時はゼロ\n\nstruct P3{\n  P_type x, y, z;\n  P3(P_type x = 0, P_type y = 0, P_type z = 0): x(x), y(y), z(z) {}\n\n  P3 operator-() const {\n    return P3(-x, -y, -z);\n  }\n\n  P3 operator+(const P3 &B) const {\n    return P3(x + B.x, y + B.y, z + B.z);\n  }\n\n  P3 operator-(const P3 &B) const {\n    return P3(x - B.x, y - B.y, z - B.z);\n  }\n\n  P3 operator*(P_type a) const {\n    return P3(x * a, y * a, z * a);\n  }\n\n  P3 operator/(P_type a) const {\n    return P3(x / a, y / a, z / a);\n  }\n\n  P3& operator+=(const P3 &B) {\n    x += B.x; y += B.y; z += B.z;\n    return *this;\n  }\n\n  P3& operator-=(const P3 &B) {\n    x -= B.x; y -= B.y; z -= B.z;\n    return *this;\n  }\n\n  P3& operator*=(P_type a) {\n    x *= a; y *= a; z *= a;\n    return *this;\n  }\n\n  P3& operator/=(P_type a) {\n    x /= a; y /= a; z /= a;\n    return *this;\n  }\n\n  bool operator<(const P3 &b){\n    if (abs(x - b. x) > P_eps) return x + P_eps < b.x;\n    if (abs(y - b. y) > P_eps) return y + P_eps < b.y;\n    return z + P_eps < b.z;\n  }\n};\n\nP_type dot(P3 a, P3 b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nP3 cross(P3 a, P3 b) {\n  P_type x = a.y * b.z - a.z * b.y;\n  P_type y = a.z * b.x - a.x * b.z;\n  P_type z = a.x * b.y - a.y * b.x;\n  return P3(x, y, z);\n}\n\ndouble abs(P3 a) {\n  return sqrt(dot(a, a));\n}\n\ndouble distanceSP(P3 a, P3 b, P3 c) {\n  if (dot(b-a, c-a) < P_eps) return abs(c-a);\n  if (dot(a-b, c-b) < P_eps) return abs(c-b);\n  return abs(cross(b-a, c-a))/ abs(b-a);\n}\n\nint main(){\n  int N, Q;\n  int x[50], y[50], z[50], r[50];\n  ll l[50];\n  P3 p[50];\n\n  scanf(\"%d%d\", &N, &Q);\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%d%d%d%d%lld\", x+i, y+i, z+i, r+i, l+i);\n    p[i] = P3(x[i], y[i], z[i]);\n  }\n\n  int ans = 0;\n\n  for (int i=0; i<Q; i++) {\n    int x, y, z;\n    P3 s, d;\n\n    scanf(\"%d%d%d\", &x, &y, &z);\n    s = P3(x, y, z);\n    scanf(\"%d%d%d\", &x, &y, &z);\n    d = P3(x, y, z);\n\n    ll sum = 0;\n\n    for (int j=0; j<N; j++) {\n      if (distanceSP(s, d, p[j]) < r[j] + P_eps)\n        sum += l[j];\n    }\n\n    cout << sum << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nconst double tol = 1e-8;\n\ntemplate <class T>\nstruct Point {\n    T x, y, z;\n    Point(T x_, T y_, T z_) : x(x_), y(y_), z(z_) {}\n    Point& operator+=(const Point& other) { x += other.x; y += other.y; z += other.z; return *this; }\n    Point& operator-=(const Point& other) { x -= other.x; y -= other.y; z -= other.z; return *this; }\n    Point& operator*=(const T& alpha) { x *= alpha; y *= alpha; z *= alpha; return *this; }\n};\n\ntemplate <class T>\ninline Point<T> operator+(const Point<T>& lhs, const Point<T>& rhs) { Point<T> t(lhs); return t += rhs; }\ntemplate <class T>\ninline Point<T> operator-(const Point<T>& lhs, const Point<T>& rhs) { Point<T> t(lhs); return t -= rhs; }\ntemplate <class T>\ninline Point<T> operator*(const Point<T>& lhs, const T& rhs) { Point<T> t(lhs); return t *= rhs; }\n\ntemplate <class T>\ninline T norm(const Point<T>& p) { return p.x * p.x + p.y * p.y + p.z * p.z; }\n\ntemplate <class T>\ninline T abs(const Point<T>& p) { return sqrt(norm(p)); }\n\ntemplate <class T>\ninline T dot(const Point<T>& a, const Point<T>& b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\ntemplate <class T>\nstruct Line : vector<Point<T>> {\n    Line(const Point<T>& a, const Point<T>& b) : vector<Point<T>>{a, b} {}\n    T length() const { return abs((*this)[1] - (*this)[0]); }\n};\n\ntemplate <class T>\ninline Point<T> projection(const Line<T>& l, const Point<T>& p) {\n    const Point<T> q = l[1] - l[0];\n    T t = dot(p - l[0], q) / norm(q);\n    return l[0] + q * t;\n}\n\ntemplate <class T>\nstruct Segment : Line<T> {\n    Segment(const Point<T>& a, const Point<T>& b) : Line<T>(a, b) {}\n};\n\ntemplate <class T>\ninline bool intersect(const Segment<T>& s, const Point<T>& p) {\n    return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < tol;\n}\n\ntemplate <class T>\ninline T distance(const Segment<T>& s, const Point<T>& p) {\n    const Point<T> r = projection(s, p);\n    return intersect(s, r) ? abs(r - p) : min(abs(s[0] - p), abs(s[1] - p));\n}\n\ntemplate <class T>\nstruct Sphere : Point<T> {\n    T r;\n    Sphere(T x_, T y_, T z_, T r_) : Point<T>(x_, y_, z_), r(r_) {}\n};\n\ntemplate <class T>\ninline bool intersect(const Sphere<T>& sh, const Segment<T>& ls) {\n    return distance(ls, Point<T>(sh)) <= sh.r + tol;\n}\n\nusing point_t = Point<double>;\nusing segment_t = Segment<double>;\nusing sphere_t = Sphere<double>;\n\nstruct Obstacle : sphere_t {\n    long long l;\n    Obstacle(double x_, double y_, double z_, double r_, long long l_) : sphere_t(x_, y_, z_, r_), l(l_) {}\n};\n\nint main() {\n    int N, Q; cin >> N >> Q;\n    vector<Obstacle> obstacle;\n    rep(i, N) {\n        int x, y, z, r; long long l; cin >> x >> y >> z >> r >> l;\n        obstacle.emplace_back(x, y, z, r, l);\n    }\n    while (Q--) {\n        int sx, sy, sz, dx, dy, dz; cin >> sx >> sy >> sz >> dx >> dy >> dz;\n        segment_t line_of_fire(point_t(sx, sy, sz), point_t(dx, dy, dz));\n        cout << accumulate(all(obstacle), 0, [&](long long power, const Obstacle& o) {\n            return power + (intersect(o, line_of_fire) ? o.l : 0);\n        }) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define EPS (1e-10)\n\nstruct P{\n  double X, Y, Z;\n};\n\nnamespace std{\n  P operator-(const P& a, const P& b){\n    P ret = {a.X-b.X, a.Y-b.Y, a.Z-b.Z};\n    return ret;\n  }\n}\n\ndouble dot_3d(P a, P b){\n  return a.X*b.X + a.Y*b.Y + a.Z*b.Z;\n}\n\nP cross(P a, P b){\n  P ret = {a.Y*b.Z-a.Z*b.Y,a.Z*b.X-a.X*b.Z,a.X*b.Y-a.Y*b.X};\n  return ret;\n}\n\ndouble norm_3d(P a){\n  return a.X*a.X + a.Y*a.Y + a.Z*a.Z;\n}\n\nint main(){\n  int N, Q;\n  cin >> N >> Q;\n  vector<P> obs(N);\n  vector<long long int> r(N), l(N);\n  for(int i = 0; i < N; ++i){\n    cin >> obs[i].X >> obs[i].Y >> obs[i].Z >> r[i] >> l[i];\n  }\n  P s, d;\n  for(int i = 0; i < Q; ++i){\n    cin >> s.X >> s.Y >> s.Z >> d.X >> d.Y >> d.Z;\n    P v = d-s;\n    long long int ans = 0LL;\n    for(int j = 0; j < N; ++j){\n      if(norm_3d(cross(v,obs[j]-s))/norm_3d(v) <= r[j]*r[j]+EPS &&\n\t dot_3d(v,obs[j]-s) >= -EPS && dot_3d(s-d,obs[j]-d) >= -EPS) ans += l[j];\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-12;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nbool hasCrosspointLC(const Line& l,const Circle& ci){\n  Point dir = unit(l[1] - l[0]);\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  if(D < 0) return false;\n  return true;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<ll> costs;\n    vector<bool> used;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      ll amount_of_consumption;\n      scanf(\"%d %d %d %d %lld\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n      used.push_back(false);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      ll sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        if(!used[obstacle_i] && hasCrosspointLC(line,obstacles[obstacle_i])) {\n          sum += costs[obstacle_i];\n          used[obstacle_i] = true;\n        }\n      }\n      printf(\"%lld\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Vertex\n{\n  double x, y, z;\n  Vertex(){}\n  Vertex(double a, double b, double c){\n    x = a; y = b; z = c;\n  }\n};\n\n#define Vector Vertex\n\ndouble distanc(Vertex p1, Vertex p2)\n{\n  return pow(SQ((p2.x-p1.x)) + SQ((p2.y-p1.y)) + SQ((p2.z-p1.z)), 0.5);\n}\n\ndouble length(Vector v)\n{\n  return pow(SQ(v.x) + SQ(v.y) + SQ(v.z), 0.5);\n}\n\nVector cross(Vector vl, Vector vr)\n{\n  return Vector(vl.y*vr.z - vl.z*vr.y, vl.z*vr.x - vl.x*vr.z, vl.x*vr.y - vl.y*vr.x);\n}\n\ndouble dot(Vertex a, Vertex b)\n{\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\ndouble norm(Vertex a)\n{\n  return sqrt(dot(a, a));\n}\n\ndouble dis(Vertex p, Vertex a, Vertex b)\n{\n  Vector ab(b.x-a.x, b.y-a.y, b.z-a.z);\n  Vector ap(p.x-a.x, p.y-a.y, p.z-a.z);\n  double d = length(cross(ab, ap));\n  double l = distanc(a, b);\n  //  cout << endl << d << \" \" << l << endl;  \n  double h = d / l;\n  return h;\n}\n\nint main()\n{\n  int N, Q;\n  Vertex jm[64];\n  int r[64];\n  ll l[64];\n\n  cin >> N >> Q;\n  rep(i, N){\n    int x, y, z;\n    cin >> x >> y >> z >> r[i] >> l[i];\n    jm[i] = Vertex(x,y,z);\n  }\n\n  rep(i, Q){\n    ll res = 0;    \n    double x, y, z;\n    cin >> x >> y >> z;\n    Vertex a(x, y, z);\n    cin >> x >> y >> z;\n    Vertex b(x, y, z);\n    rep(j, N){\n      if(r[j] + EPS >= dis(jm[j], a, b)){\n\tVertex u(jm[j].x-a.x,jm[j].y-a.y,jm[j].z-a.z);\n\tVertex v(b.x-a.x,b.y-a.y,b.z-a.z);\n\tdouble t1 = dot(u, v) / (norm(u) * norm(v));\n\tu = Vertex(jm[j].x-b.x,jm[j].y-b.y,jm[j].z-b.z);\n\tv = Vertex(a.x-b.x,a.y-b.y,a.z-b.z);\n\tdouble t2 = dot(u, v) / (norm(u) * norm(v));\n\tif(t1 >= 0 && t2 >= 0)\n\t  res += l[j];\n      }\n    }\n    cout << res << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-10, pi = acosl(-1);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nclass Point {\npublic:\n\tld x, y, z;\n\tPoint()\n\t\t: x(0), y(0), z(0) {}\n\tPoint(ld x, ld y, ld z)\n\t\t: x(x), y(y), z(z) {}\n\tPoint operator+(Point p) const {\n\t\treturn Point(x + p.x, y + p.y, z + p.z);\n\t}\n\tPoint operator-(Point p) const {\n\t\treturn Point(x - p.x, y - p.y, z - p.z);\n\t}\n\tPoint operator*(ld s) const {\n\t\treturn Point(x * s, y * s, z * s);\n\t}\n};\n\nclass Line {\npublic:\n\tPoint a, b;\n\tLine(Point a, Point b)\n\t\t: a(a), b(b) {}\n};\n\nld dot(Point a, Point b) {\n\treturn a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nld norm(Point a) {\n\treturn dot(a, a);\n}\n\nclass Sphere {\npublic:\n\tPoint c;\n\tld r;\n\tSphere()\n\t\t: c(), r(0) {}\n\tSphere(Point c, ld r)\n\t\t: c(c), r(r) {}\n};\n\nbool isis_ssp(Line s, Sphere sp) {\n\tld t = dot(sp.c - s.a, s.b - s.a) / norm(s.b - s.a);\n\treturn t > -eps && t < 1 + eps && norm(sp.c - (s.a + (s.b - s.a) * t)) < sp.r * sp.r + eps;\n}\n\nint main()\n{\n\tint N, Q;\n\tcin >> N >> Q;\n\tvector<Sphere> ss(N);\n\tvector<int> l(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> ss[i].c.x >> ss[i].c.y >> ss[i].c.z >> ss[i].r >> l[i];\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tPoint s, d;\n\t\tcin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n\t\tLine seg(s, d);\n\t\tint res = 0;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (isis_ssp(seg, ss[j])) {\n\t\t\t\tres += l[j];\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\ntypedef int64_t ll;\ntypedef long double ld;\nstruct Circle {\n    ld x, y, z, r;\n    ll p;\n};\n\nint n,q;\nvector<Circle> cs;\n\nll solve(int sx, int sy, int sz, int dx, int dy, int dz){\n    auto myhpt = [](ld x, ld y, ld z, Circle c){\n        auto sq = [](ld x){ return x*x; };\n        return sqrt(sq(x-c.x) + sq(y-c.y) + sq(z-c.z));\n    };\n    dx -= sx; dy -= sy; dz -= sz;\n    ll ans = 0;\n    for (int j = 0; j < n; j++){\n        ld left = 0, right = 1;\n        ld d = (ld)1e200;\n        rep(t,200){\n            ld m1 = (left+left+right) / 3;\n            ld m2 = (left+right+right) / 3;\n            ld m1x = sx + m1*dx, m1y = sy + m1*dy, m1z = sz + m1*dz;\n            ld m2x = sx + m2*dx, m2y = sy + m2*dy, m2z = sz + m2*dz;\n            ld d1 = myhpt(m1x, m1y, m1z, cs[j]);\n            ld d2 = myhpt(m2x, m2y, m2z, cs[j]);\n            if (d1 < d2) right = m2; else left = m1;\n            d = min(d, min(d1,d2));\n        }\n        if(d < cs[j].r + 1e-9) ans += cs[j].p;\n    }\n    return ans;\n}\n\nint main(){\n    while(cin >> n >> q){\n        cs.resize(n);\n        rep(i,n) cin >> cs[i].x >> cs[i].y >> cs[i].z >> cs[i].r >> cs[i].p;\n        rep(i,q){\n            ld sx, sy, sz, dx, dy, dz;\n            cin >> sx >> sy >> sz >> dx >> dy >> dz;\n            cout << solve(sx, sy, sz, dx, dy, dz) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Point {\npublic:\n  double x;\n  double y;\n  double z;\n  Point (double x,double y,double z) :\n    x(x), y(y), z(z) {}\n  Point () : x(0), y(0), z(0) {}\n  Point operator-(const Point& p) const {\n    return Point(this->x - p.x,\n                 this->y - p.y,\n                 this->z - p.z);\n  }\n  Point operator+(const Point& p) const {\n    return Point(this->x + p.x,\n                 this->y + p.y,\n                 this->z + p.z);\n  }\n  void operator+=(const Point& p) const {\n    this->x + p.x;\n    this->y + p.y;\n    this->z + p.z;\n  }\n  Point operator*(const double t) const {\n    return Point(this->x * t,\n                 this->y * t,\n                 this->z * t);\n  }\n  Point operator*(const Point&p) const {\n    return Point(this->x * p.x,\n                 this->y * p.y,\n                 this->z * p.z);\n  }\n  Point operator/(const double t) const {\n    return Point(this->x / t,\n                 this->y / t,\n                 this->z / t);\n  }\n  void operator/=(const double t) {\n    this->x /= t;\n    this->y /= t;\n    this->z /= t;\n  }\n  void print_vec() const{\n    printf(\"(%lf,%lf,%lf)\\n\",this->x,this->y,this->z);\n  }\n};\n\nclass Line : public vector<Point> {\npublic:\n  Line(const Point& p1,const Point& p2) {\n    push_back(p1);\n    push_back(p2);\n  }\n};\n\nclass Circle {\npublic:\n  Point p;\n  double r;\n  Circle(const Point& p,double r) : p(p),r(r) {}\n};\n\ndouble norm(const Point& p){\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ndouble abs(const Point& p){\n  return sqrt(norm(p));\n}\n\nPoint unit(const Point& p){\n  return p/abs(p);\n}\n\ndouble dot(const Point& p1,const Point& p2){\n  return p1.x * p2.x + p1.y * p2.y + p1.z * p2.z;\n}\n\nPoint cross(const Point& p1,const Point& p2){\n  return Point(p1.y * p2.z - p1.z * p2.y,\n               p1.z * p2.x - p1.x * p2.z,\n               p1.x * p2.y - p1.y * p2.x);\n}\n\nPoint projection(const Line& l,const Point& p){\n  double t = dot(p - l[0],l[0]-l[1]) / norm(l[0] - l[1]);\n  return l[0] + (l[0] - l[1]) * t;\n}\n\nbool EQ(const Point& s,const Point& t) {\n  if((t.x - EPS <= s.x && s.x <= t.x + EPS)\n     && (t.y - EPS <= s.y && s.y <= t.y + EPS)\n     && (t.z - EPS <= s.z && s.z <= t.z + EPS)) return true;\n  return false;\n}\n\nbool parallelLL(const Line &l, const Line &m) {\n  return EQ(cross(l[1]-l[0], m[1]-m[0]),Point(0,0,0));\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return (abs(cross(l[1]-p, l[0]-p)) < EPS);\n}\n\ndouble distanceLP(const Line& l,const Point& p){\n  if(intersectLP(l,p)) return 0;\n  return abs(p - projection(l,p));\n}\n\ndouble distanceLL(const Line& l,const Line& m){\n  if(parallelLL(l,m)) return distanceLP(l,m[0]);\n\n  const Point V1 = l[1] - l[0];\n  const Point V2 = m[1] - m[0];\n  const Point V3 = m[0] - l[0];\n  return abs(dot(cross(V1,V2),V3)/abs(cross(V1,V2)));\n}\n\ndouble distancePP(const Point& s,const Point& t) {\n  if(EQ(s,t)) return 0;\n  return abs(Point(s.x - t.x,s.y - t.y,s.z - t.z));\n}\n\nvector<Point> crosspointLC(const Line& l,const Circle& ci){\n  Point dir = unit(l[1] - l[0]);\n  // a * t^2 + b * t + c = 0\n  double a = norm(dir);\n  double b = dot(l[0] - ci.p,dir);\n  double c = norm(l[0] - ci.p) - ci.r * ci.r;\n  double D = b * b - a * c;\n\n  vector<Point> res;\n  if(D < EPS) return res;\n  double t1 = (-b - sqrt(D))/a;\n  double t2 = (-b + sqrt(D))/a;\n\n  if(abs(t1) < abs(t2)){\n    res.push_back(l[0] + dir * t1);\n  }\n  else{\n    res.push_back(l[0] + dir * t2);\n  }\n  return res;\n}\n\nPoint reflection(const Line& l,const Point& p){\n  return p + (projection(l,p) - p) * 2.0;\n}\n\nint main(){\n  int num_of_obstacles;\n  int num_of_objects;\n  while(~scanf(\"%d %d\",\n               &num_of_obstacles,\n               &num_of_objects)){\n    vector<Circle> obstacles;\n    vector<int> costs;\n    for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n      int x,y,z;\n      int radius;\n      int amount_of_consumption;\n      scanf(\"%d %d %d %d %d\",&x,&y,&z,&radius,&amount_of_consumption);\n      obstacles.push_back(Circle(Point(x,y,z),radius));\n      costs.push_back(amount_of_consumption);\n    }\n    for(int object_i = 0; object_i < num_of_objects; object_i++){\n      int red_x,red_y,red_z;\n      int blue_x,blue_y,blue_z;\n      scanf(\"%d %d %d %d %d %d\",\n            &red_x,&red_y,&red_z,\n            &blue_x,&blue_y,&blue_z);\n      Line line(Point(red_x,red_y,red_z),Point(blue_x,blue_y,blue_z));\n\n      int sum = 0;\n      for(int obstacle_i = 0; obstacle_i < num_of_obstacles; obstacle_i++){\n        vector<Point> p = crosspointLC(line,obstacles[obstacle_i]);\n        if(p.size() > 0) sum += costs[obstacle_i];\n      }\n      printf(\"%d\\n\",sum);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point3 {\n    real x, y, z;\n    Point3& operator+=(const Point3 a) { x += a.x; y += a.y; z += a.z;  return *this; }\n    Point3& operator-=(const Point3 a) { x -= a.x; y -= a.y; z -= a.z; return *this; }\n    Point3 operator+(const Point3 a) const {return Point3(*this) += a; }\n    Point3 operator-(const Point3 a) const {return Point3(*this) -= a; }\n    explicit Point3(real a = 0, real b = 0, real c = 0) : x(a), y(b), z(c) {};\n};\n\n\ninline real dot(Point3 a, Point3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\ninline Point3 cross(Point3 a, Point3 b){\n    return Point3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);\n}\ninline real abs(Point3 a){ return sqrt(dot(a, a)); }\n\nstruct Segment {\n    Point3 a, b;\n    Segment(Point3 x, Point3 y) : a(x), b(y) {};\n};\n\n\ndouble distance(Segment l, Point3 c){\n    if(dot(l.b-l.a, c-l.a) <= 0) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) <= 0) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nstruct Sphere{\n    Point3 c;\n    double r;\n    Sphere(){};\n    Sphere(Point3 c, double r): c(c), r(r){};\n};\n\nbool intersect(Segment s,Sphere c){\n    double d=distance(s,c.c);\n    return d < c.r+EPS;\n}\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    vector<Sphere> v(n);\n    vector<ll> x(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i].c.x >> v[i].c.y >> v[i].c.z >> v[i].r >> x[i];\n    }\n    for (int i = 0; i < q; ++i) {\n        double a, b, c, d, e, f;\n        cin >> a >> b >> c >> d >> e >> f;\n        Segment S(Point3(a, b, c), Point3(d, e, f));\n        uint64_t ans = 0;\n        for (int j = 0; j < n; ++j) {\n            if(intersect(S, v[j])) ans += x[j];\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//3次元\nstruct Point{\n\tPoint(double arg_x,double arg_y,double arg_z){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t\tz = arg_z;\n\t}\n\n\tPoint(){\n\t\tx = y = z = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y,z+p.z); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y,z-p.z);}\n\tPoint operator * (double a){ return Point(a*x,a*y,a*z); }\n\tPoint operator / (double a){ return Point(x/a,y/a,z/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y + z*z; }\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS && fabs(z-p.z) < EPS;\n\t}\n\tdouble x,y,z;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nstruct Info{\n\tPoint center;\n\tdouble r;\n\tll value;\n};\n\nint N,Q;\nInfo info[50];\n\n//3次元\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y+a.z*a.z;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y+a.z*b.z;\n}\n\n//垂線が引ける場合、交点を求める\nPoint projection(Line line,Point point){\n    double t = dot(point-line.p[0],line.p[0]-line.p[1])/norm(line.p[0]-line.p[1]);\n    return line.p[0] + (line.p[0]-line.p[1])*t;\n}\n\ndouble calc_dist(Point a,Point b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z));\n}\n\nbool intersect(Line line,int index){\n\n\tdouble dist_1 = calc_dist(line.p[0],info[index].center);\n\tdouble dist_2 = calc_dist(line.p[1],info[index].center);\n\n\t//方向ベクトル\n\tdouble Vx = line.p[1].x-line.p[0].x;\n\tdouble Vy = line.p[1].y-line.p[0].y;\n\tdouble Vz = line.p[1].z-line.p[0].z;\n\n\t//Oを原点,点Aをline.p[0]としたとき、点info[inde]から下した垂線との交点が、(line.p[0].x+t*Vx,line.p[0].y+t*Vy,line.p[0].z+t*Vz)と表されるようなt\n\tdouble t = (Vx*(info[index].center.x-line.p[0].x)+Vy*(info[index].center.y-line.p[0].y)+Vz*(info[index].center.z-line.p[0].z))/(Vx*Vx+Vy*Vy+Vz*Vz);\n\n\tif(t < 0 || t > 1){ //垂線が、観測点と光源を結ぶ線分上にない場合→最近地点は、観測点か光源のどちらか\n\t\tif(dist_1 > info[index].r && dist_2 > info[index].r){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tdouble cross_x = line.p[0].x+t*Vx;\n\tdouble cross_y = line.p[0].y+t*Vy;\n\tdouble cross_z = line.p[0].z+t*Vz;\n\n\tdouble dist = sqrt((info[index].center.x-cross_x)*(info[index].center.x-cross_x)\n\t\t\t+(info[index].center.y-cross_y)*(info[index].center.y-cross_y)\n\t\t\t+(info[index].center.z-cross_z)*(info[index].center.z-cross_z)\n\t\t);\n\n\tif(dist < info[index].r+EPS){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&Q);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf %lf %lld\",&info[i].center.x,&info[i].center.y,&info[i].center.z,&info[i].r,&info[i].value);\n\t}\n\n\tPoint a,b;\n\tll ans;\n\tfor(int loop = 0; loop < Q; loop++){\n\t\tscanf(\"%lf %lf %lf %lf %lf %lf\",&a.x,&a.y,&a.z,&b.x,&b.y,&b.z);\n\t\tans = 0;\n\t\tLine line(a,b);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(intersect(line,i))ans += info[i].value;\n\t\t}\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n  int x, y, z;\n  Point(){}\n  Point(int x, int y, int z):x(x), y(y), z(z){}\n};\nPoint operator - (const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y, a.z - b.z); }\nPoint operator * (const double& k, const Point& a) { return Point(k*a.x, k*a.y, k*a.z); }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y + a.z*a.z; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble dot(Point a, Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a, Point b) { return sqrt(norm(a)*norm(b) - dot(a, b)*dot(a, b)); }\n\nstruct Obstacle {\n  Point  p;\n  double r;\n  ll     l;\n};\n\ndouble getdist(Point a, Point b, Point p)\n{\n  if(dot(b - a, p - a) < 0.0) return abs(p - a);\n  if(dot(a - b, p - b) < 0.0) return abs(p - b);\n  return abs(cross(b - a, p - a) /abs(b - a));\n}\n\nint main()\n{\n  int N, Q;\n  cin >> N >> Q;\n  vector<Obstacle> obs(N);\n  for(int i = 0; i < N; i++) {\n    cin >> obs[i].p.x >> obs[i].p.y >> obs[i].p.z >> obs[i].r >> obs[i].l;\n  }\n  ll ans = 0;\n  for(int i = 0; i < Q; i++) {\n    Point s, d;\n    cin >> s.x >> s.y >> s.z >> d.x >> d.y >> d.z;\n    for(int j = 0; j < N; j++) {\n      double dist = getdist(s, d, obs[j].p);\n      if(dist <= obs[j].r + 1e-10) ans += obs[j].l;\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define EPS 1e-8\n#define equals(a,b) fabs((a) - (b)) < EPS\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct Point3D {\n\tdouble x, y, z;\n\n\tPoint3D() : x(0), y(0), z(0) {}\n\n\tPoint3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n\tPoint3D operator+(const Point3D &o) const { return Point3D(x+o.x, y+o.y, z+o.z); }\n\n\tPoint3D operator-(const Point3D &o) const { return Point3D(x-o.x, y-o.y, z-o.z); }\n\n\tPoint3D operator*(const double m) const { return Point3D(x*m, y*m, z*m); }\n\n\tPoint3D operator/(const double d) const { return Point3D(x/d, y/d, z/d); }\n\n\tbool operator==(const Point3D &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }\n};\n\nostream& operator << (ostream& os, const Point3D& p) {\n\tos << \"(\" << p.x << \", \" << p.y << \", \" << p.z << \")\";\n\treturn os;\n}\n\ndouble dot(Point3D a, Point3D b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nPoint3D cross(Point3D a, Point3D b) { return Point3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x); }\n\ndouble norm(Point3D p) { return dot(p, p); }\ndouble abs(Point3D p) { return sqrt(norm(p)); }\n\nstruct Line {\n\tPoint3D a, b;\n\n\tLine() : a(Point3D(0, 0, 0)), b(Point3D(0, 0, 0)) {}\n\n\tLine(Point3D a, Point3D b) : a(a), b(b) {}\n};\n\nostream& operator << (ostream& os, const Line& l) {\n\tos << \"(\" << l.a.x << \", \" << l.a.y << \", \" << l.a.z <<  \")-(\" << l.b.x << \",\" << l.b.y << \", \" << l.b.z <<  \")\";\n\treturn os;\n}\n\nPoint3D project(Line l, Point3D p) {\n\tPoint3D base = l.b - l.a;\n\tdouble t = dot(base, p-l.a) / dot(base, base);\n\treturn l.a + base * t;\n}\n\nstruct Ball {\n\tPoint3D p;\n\tdouble r;\n\n\tBall() : p(Point3D(0, 0, 0)), r(0.0) {}\n\n\tBall(Point3D p, double r) : p(p), r(r) {}\n};\n\nostream& operator << (ostream& os, const Ball& b) {\n\tos << \"(\" << b.p.z << \", \" << b.p.y << \", \" << b.p.z << \" :\" << b.r << \")\";\n\treturn os;\n}\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<Ball> v(n);\n\tvector<ll> cost(n);\n\trep(i, n) {\n\t\tcin >> v[i].p.x >> v[i].p.y >> v[i].p.z >> v[i].r >> cost[i];\n\t}\n\n\trep(i, q) {\n\t\tll ans = 0;\n\t\tPoint3D s, t;\n\t\tcin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n\n\t\tLine line(s, t);\n\n\t\trep(j, n) {\n\t\t\tPoint3D proj = project(line, v[j].p);\n\n\t\t\tif(abs(line.b - line.a) >= abs(proj - line.a) && abs(line.a - line.b) >= abs(proj - line.b)) {\n\t\t\t\tif(abs(proj - v[j].p) <= v[j].r + EPS) {\n\t\t\t\t\tans += cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n    #define __clock__\n#else\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n//#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nll SUM(VI& V){\n  return accumulate(ALL(V), 0LL);\n}\n\nvoid print_vector(VI& V){\n  ll n = V.size();\n  rep(i, n){\n    if(i) cout << ' ';\n    cout << V[i];\n  }\n  cout << endl;\n}\n\nll gcd(ll a,ll b){\n    if(b == 0) return a;\n    return gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n    ll g = gcd(a,b);\n    return a / g * b;\n}\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n// const double PI = acos(-1);\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\nstruct Point3D{\n  double x,y,z;\n  Point3D(){}\n  Point3D(double x,double y,double z):x(x),y(y),z(z){}\n  Point3D operator+(Point3D p) {return Point3D(x+p.x,y+p.y,z+p.z);}\n  Point3D operator-(Point3D p) {return Point3D(x-p.x,y-p.y,z-p.z);}\n  Point3D operator*(double k){return Point3D(x*k,y*k,z*k);}\n  Point3D operator/(double k){return Point3D(x/k,y/k,z/k);}\n  Point3D operator*(Point3D p){\n    return Point3D(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);\n  }\n  double operator^(Point3D p){\n    return x*p.x+y*p.y+z*p.z;\n  }\n  double norm(){return x*x+y*y+z*z;}\n  double abs(){return sqrt(norm());}\n  bool operator < (const Point3D &p) const{\n    if(x!=p.x) return x<p.x;\n    if(y!=p.y) return y<p.y;\n    return z<p.z;\n  }\n  bool operator == (const Point3D &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS && fabs(z-p.z)<EPS;\n  }\n};\nistream &operator >> (istream &is,Point3D &p){\n  is>>p.x>>p.y>>p.z;\n  return is;\n}\nostream &operator << (ostream &os,Point3D p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y<<\" \"<<p.z;\n  return os;\n}\n\ntypedef Point3D Vector3D;\ntypedef vector<Point3D> Polygon3D;\n\nstruct Segment3D{\n  Point3D p1,p2;\n  Segment3D(){}\n  Segment3D(Point3D p1, Point3D p2):p1(p1),p2(p2){}\n};\ntypedef Segment3D Line3D;\n\nistream &operator >> (istream &is,Segment3D &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Sphere{\n  Point3D c;\n  double r;\n  Sphere(){}\n  Sphere(Point3D c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Sphere &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector3D a){\n  return a.x*a.x+a.y*a.y+a.z*a.z;\n}\ndouble abs(Vector3D a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector3D a,Vector3D b){\n  return a.x*b.x+a.y*b.y+a.z*b.z;\n}\nVector3D cross(Vector3D a,Vector3D b){\n  return Vector3D(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n\nPoint3D project(Line3D l,Point3D p){\n  Point3D b=l.p2-l.p1;\n  double t=dot(p-l.p1,b)/norm(b);\n  return l.p1+b*t;\n}\n\nPoint3D reflect(Line3D l,Point3D p){\n  return p+(project(l,p)-p)*2.0;\n}\n\ndouble getDistanceLP(Line3D l,Point3D p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment3D s,Point3D p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N,Q;\n    cin>>N>>Q;\n\n    // obstacles\n    vector<Point3D> P(N);\n    VI R(N);\n    VI Magic(N);\n    rep(i,N){\n      cin>>P[i].x>>P[i].y>>P[i].z;\n      cin>>R[i]>>Magic[i];\n    }\n\n    // queries\n    while(Q--){\n      Point3D a,b;\n      cin>>a.x>>a.y>>a.z;\n      cin>>b.x>>b.y>>b.z;\n\n      // 線分と点の距離\n      Segment3D seg(a,b);\n      ll sum=0;\n      rep(i,N){\n        Point3D p = P[i];\n        double distance = getDistanceSP(seg, p);\n        if(distance<R[i]){\n          sum += Magic[i];\n        }else if(equals(distance, (double)R[i])){\n          sum += Magic[i];\n        }\n      }\n      p(sum);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS) \n \nusing namespace std;\n \nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n \nclass Point {\npublic:\n  double x,y,z;\n  Point(double x=0,double y=0,double z=0):x(x),y(y),z(z){}\n \n  Point operator + (const Point &a) {\n    return Point(x+a.x,y+a.y,z+a.z); \n  }\n \n  Point operator - (const Point &a) {\n    return Point(x-a.x,y-a.y,z-a.z); \n  }\n \n  Point operator * (const double &d) {\n    return Point(x*d,y*d,z*d);\n  }\n \n  Point operator / (const double &d) {\n    return Point(x/d,y/d,z/d);\n  }\n \n  bool operator < ( const Point &p ) const {\n    if( !equals(x,p.x) ) return LT(x,p.x);\n    if( !equals(y,p.y) ) return LT(y,p.y);\n    return LT(z,p.z);\n  }\n \n  bool operator == ( const Point &p ) const {\n    return equals(x,p.x) && equals(y,p.y) && equals(z,p.z);\n  }\n \n};\n \nstruct Segment{\n  Point p[2];\n  Segment(Point p1=Point(),Point p2=Point()){\n    p[0] = p1, p[1] = p2;\n  }\n};\n \ntypedef Point Vector;\ntypedef Segment Line;\n \ndouble dot(Point a,Point b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\n \nVector cross(Point a,Point b) {\n  return Vector(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n \ninline double norm(Point p){\n  return p.x*p.x + p.y*p.y + p.z*p.z;\n}\n \ninline double abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint project(Segment seg,Point p){\n  Vector base = seg.p[1] - seg.p[0];\n  double t = dot(p-seg.p[0],base) / norm(base);\n  return seg.p[0] + base * t;\n}\n \nbool on_line(Line line,Point p){\n  return equals(abs(cross(p-line.p[0],line.p[1]-line.p[0])),0);\n}\n \nbool on_segment(Segment seg,Point p){\n  if( !on_line(seg,p) ) return false;\n  double dist[3] = { abs(seg.p[1]-seg.p[0]), abs(p-seg.p[0]), abs(p-seg.p[1]) };\n  return on_line(seg,p) && equals(dist[0],dist[1]+dist[2]);\n}\n \n \ndouble distanceSP(Segment seg,Point p){\n  Point r = project(seg,p);\n  if( on_segment(seg,r) ) return abs(p-r);\n  return min(abs(seg.p[0]-p),abs(seg.p[1]-p));\n}\n \ntypedef long long ll;\n \nint N,Q;\nPoint cp[100];\ndouble r[100];\nll l[100];\nPoint s,t;\n \nvoid compute(){\n  ll answer = 0;\n  Segment seg = Segment(s,t);\n  rep(i,N){\n    double dist = distanceSP(seg,cp[i]);\n    if( LTE(dist,r[i]) ) {\n      answer += l[i];\n    }\n  }\n  cout << answer << endl;\n}\n \nint main(){\n  cin >> N >> Q;\n  rep(i,N){\n    cin >> cp[i].x >> cp[i].y >> cp[i].z >> r[i] >> l[i];\n  }\n  rep(_,Q){\n    cin >> s.x >> s.y >> s.z >> t.x >> t.y >> t.z;\n    compute();\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define D 1e-9\ntypedef struct _vec{\n    double x, y, z;\n} vec;\n\ndouble Dis(vec A, vec B){\n    double dis = (A.x-B.x)*(A.x-B.x) + (A.y-B.y)*(A.y-B.y) + (A.z-B.z)*(A.z-B.z);\n    //cout << dis << \" o \" <<  endl;\n    dis = pow(dis, 0.5);\n    //cout << dis << \" o \" <<  endl;    \n    return dis;\n}\n\ndouble norm(vec A, vec B){             //内積\n    double res;\n    res = A.x*B.x + A.y*B.y + A.z*B.z;   \n\n    return res;\n}\n\nvec tanni(vec A){                   //単位ベクトルを返す\n    double dis = A.x*A.x + A.y*A.y + A.z*A.z;\n    dis = pow(dis, 0.5);\n    vec res;\n    res.x = A.x / dis;\n    res.y = A.y / dis;\n    res.z = A.z / dis;\n\n    return res;    \n}\n\nvec houkou(vec A, vec B){             //方向ベクトルを返す\n    vec res;\n    //cout << B.x << \" \" << A.x << endl;\n    res.x = B.x - A.x;\n    res.y = B.y - A.y;\n    res.z = B.z - A.z;\n    return res;\n}\n\nint main(){\n\n    /*vec V1, V2;\n    V1.x = 3;\n    V1.y = 4;\n    V1.z = 5;\n    V2.x = 6;\n    V2.y = 3;\n    V2.z = 8;\n\n    cout << norm(V1, V2) << endl;\n    cout << Dis(V1, V2) << endl;\n    vec V3 = tanni(V1);\n    cout << V3.x << \" \" << V3.y << \" \" << V3.z << endl;\n    vec V4 = houkou(V1, V2);\n    cout << V4.x << \" \" << V4.y << \" \" << V4.z << endl;*/\n    \n\n    int n, q; cin >> n >> q;\n    vector<vec> obj(n);\n    vector<vec> blue(q);\n    vector<vec> red(q);    \n    vector<double> r(n);\n    vector<long long> l(n);\n\n    for(int i = 0; i < n; i++){\n        double a, b, c, d, e; cin >> a >> b >> c >> d >> e;\n        obj[i].x = a;\n        obj[i].y = b;\n        obj[i].z = c;\n        r[i] = d;\n        l[i] = e;                \n    }\n\n    for(int i = 0; i < q; i++){\n        double a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f;\n        blue[i].x = d;\n        blue[i].y = e;\n        blue[i].z = f;\n        red[i].x = a;\n        red[i].y = b;\n        red[i].z = c;        \n    }\n\n\n\n    for(int i = 0; i < q; i++){\n\n        long long ans = 0;\n\n        for(int j = 0; j < n; j++){\n            //j個目の障害物とはどうですか\n            vec H;\n            H.x = red[i].x;\n            H.y = red[i].y;\n            H.z = red[i].z;            \n\n            vec u;\n            u = houkou(red[i], blue[i]);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;            \n            u = tanni(u);\n            //cout << u.x << \" \" << u.y << \" \" << u.z << endl;\n            vec a;\n            a.x = obj[j].x - red[i].x;\n            a.y = obj[j].y - red[i].y;\n            a.z = obj[j].z - red[i].z;\n            //cout << a.x << \" \" << a.y << \" \" <<  a.z << endl;           \n            double _norm = norm(a, u);\n            //cout << _norm << endl;\n            vec w;\n            w.x = _norm*u.x;\n            w.y = _norm*u.y;\n            w.z = _norm*u.z;\n            //cout << endl;\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << w.x << \" \" << w.y << \" \" << w.z << endl;\n            H.x += w.x;\n            H.y += w.y;\n            H.z += w.z;\n\n            //cout << H.x << \" \" << H.y << \" \" << H.z << endl;\n            //cout << obj[j].x << \" \" << obj[j].y << \" \" << obj[j].z << endl;\n\n            double _dis = Dis(H, obj[j]);\n            //cout << j << \" \" << _dis << endl;\n            //cout << _dis << endl;\n\n            bool flag = (red[i].x <= H.x + D && H.x - D <= blue[i].x) || (blue[i].x <= H.x + D && H.x - D <= red[i].x);                         //線分上にあるか\n\n            if(_dis <= r[j] + D && flag) ans += l[j];            \n            //cout << ans << endl;\n        \n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nint n, q;\nint x[100], y[100], z[100], r[100], l[100];\nint sx, sy, sz, gx, gy, gz;\n\nsigned main() {\n\tcin >> n >> q;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i] >> z[i] >> r[i] >> l[i];\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> sx >> sy >> sz >> gx >> gy >> gz;\n\t\t\n\t\tint ax = gx - sx;\n\t\tint ay = gy - sy;\n\t\tint az = gz - sz;\n\t\tint ans = 0;\n\t\t\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint bx = x[j] - sx;\n\t\t\tint by = y[j] - sy;\n\t\t\tint bz = z[j] - sz;\n\t\t\t\n\t\t\tint menseki2 = 0;\n\t\t\tmenseki2 += (ax * by - bx * ay) * (ax * by - bx * ay);\n\t\t\tmenseki2 += (ay * bz - by * az) * (ay * bz - by * az);\n\t\t\tmenseki2 += (az * bx - bz * ax) * (az * bx - bz * ax);\n\t\t\tint length2 = ax * ax + ay * ay + az * az;\n\t\t\t\n\t\t\tif (menseki2 / length2 < r[j] * r[j]) {\n\t\t\t\tans += l[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nrandom_device rnd;\nmt19937 mt(rnd());\n\nconst int IINF = 1 << 30;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1e9 + 7;\n\nlld norm(lld x, lld y, lld z)\n{\n    return sqrtl(x * x + y * y + z * z);\n}\n\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<vector<lld>> p(n, vector<lld>(3));\n    vector<lld> r(n);\n    vector<ll> cost(n);\n    rep(i, n) cin >> p[i][0] >> p[i][1] >> p[i][2] >> r[i] >> cost[i];\n    rep(i, q)\n    {\n\n        vector<lld> s(3), e(3);\n        cin >> s[0] >> s[1] >> s[2] >> e[0] >> e[1] >> e[2];\n        ll ans = 0;\n        rep(j, n)\n        {\n            lld high = 1.0;\n            lld low = 0.0;\n            lld dist = IINF;\n            lld dl, dh;\n            while (high - low > 1e-10)\n            {\n                lld cl = (low * 2 + high) / 3.0;\n                lld ch = (low + high * 2) / 3.0;\n                lld x = s[0] * cl + e[0] * (1 - cl);\n                lld y = s[1] * cl + e[1] * (1 - cl);\n                lld z = s[2] * cl + e[2] * (1 - cl);\n                dl = norm(p[j][0] - x, p[j][1] - y, p[j][2] - z);\n\n                x = s[0] * ch + e[0] * (1 - ch);\n                y = s[1] * ch + e[1] * (1 - ch);\n                z = s[2] * ch + e[2] * (1 - ch);\n                dh = norm(p[j][0] - x, p[j][1] - y, p[j][2] - z);\n                if (dl < dh)\n                {\n                    high = ch;\n                }\n                else\n                {\n                    low = cl;\n                }\n            }\n            if (dl < r[j] + 1e-9)\n            {\n                ans += cost[j];\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,s[60][5],d[2][3],o[2][3],i,j,ans=0;\n  double h,l,p[3],k;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<n;i++){\n    for(j=0;j<5;j++)scanf(\"%d\",&s[i][j]);\n  }\n  while(m--){\n    for(i=0;i<6;i++)scanf(\"%d\",&o[i/3][i%3]);\n    for(j=0;j<3;j++)d[0][j]=o[1][j]-o[0][j];//,printf(\"%d \",d[0][j]);printf(\"\\n\");\n    for(j=l=0;j<3;j++)l+=d[0][j]*d[0][j];//printf(\"l%lf\\n\",l);\n    for(i=0;i<n;i++){\n      for(j=  0;j<3;j++)d[1][j]=s[i][j]-o[0][j];//,printf(\"%d \",d[1][j]);printf(\"\\n\");\n      for(j=h=0;j<3;j++)h+=d[0][j]*d[1][j];//printf(\"h%lf\\n\",h);\n      for(j=  0;j<3;j++)p[j]=h/l*d[0][j]+o[0][j];//,printf(\"%f \",p[j]);printf(\"\\n\");\n      for(j=k=0;j<3;j++)k+=(p[j]-s[i][j])*(p[j]-s[i][j]);//printf(\"k%lf\\n\",k);\n      if(s[i][3]*s[i][3]>k)ans+=s[i][4];//printf(\"%d\\n\",s[i][3]*s[i][3]);\n    }//printf(\"%d\\n\",i);\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\ntypedef struct O{int x,y,z,r,l;}O;\ntypedef struct P{int x,y,z;}P;\ntypedef struct V{double x,y,z;}V;\n\nO obj[51];\nP s,t,v;\nint N,Q,i,j,res;\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d%d\",&obj[i].x,&obj[i].y,&obj[i].z,&obj[i].r,&obj[i].l);\n\tfor(i=0;i<Q;i++)\n\t{\n\t\tres=0;\n\t\tscanf(\"%d%d%d%d%d%d\",&s.x,&s.y,&s.z,&t.x,&t.y,&t.z);\n\t\tfor(j=0;j<N;j++)\n\t\t{\n\t\t\tP v={t.x-s.x,t.y-s.y,t.z-s.z};\n\t\t\tdouble a=v.x*(obj[j].x-s.x)+v.y*(obj[j].y-s.y)+v.z*(obj[j].z-s.z);\n\t\t\tdouble b=v.x*v.x+v.y*v.y+v.z*v.z;\n\t\t\tdouble c=a/b;\n\t\t\tV l={s.x+v.x*c,s.y+v.y*c,s.z+v.z*c};\n\t\t\tdouble len=sqrt(pow(l.x-obj[j].x,2)+pow(l.y-obj[j].y,2)+pow(l.z-obj[j].z,2));\n\t\t\tif(len-obj[j].r<=0)\n\t\t\t\tres+=obj[j].l;\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-5\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-9\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define ESP 0.000000001\ntypedef struct O{int x,y,z,r;long long l;}O;\ntypedef struct P{int x,y,z;}P;\ntypedef struct V{double x,y,z;}V;\n\nO obj[51];\nP s,t,v;\nint N,Q,i,j;\nlong long res;\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d%lld\",&obj[i].x,&obj[i].y,&obj[i].z,&obj[i].r,&obj[i].l);\n\tfor(i=0;i<Q;i++)\n\t{\n\t\tres=0;\n\t\tscanf(\"%d%d%d%d%d%d\",&s.x,&s.y,&s.z,&t.x,&t.y,&t.z);\n\t\tfor(j=0;j<N;j++)\n\t\t{\n\t\t\tP v={t.x-s.x,t.y-s.y,t.z-s.z};\n\t\t\tdouble a=v.x*(obj[j].x-s.x)+v.y*(obj[j].y-s.y)+v.z*(obj[j].z-s.z);\n\t\t\tdouble b=v.x*v.x+v.y*v.y+v.z*v.z;\n\t\t\tdouble c=a/b;\n\t\t\tV l={s.x+v.x*c,s.y+v.y*c,s.z+v.z*c};\n\t\t\tif(c<ESP)\n\t\t\t{\n\t\t\t\tl.x=s.x;l.y=s.y;l.z=s.z;\n\t\t\t}\n\t\t\telse if(c-1>ESP)\n\t\t\t{\n\t\t\t\tl.x=t.x;l.y=t.y;l.z=t.z;\n\t\t\t}\n\t\t\tdouble len=sqrt(pow(l.x-obj[j].x,2)+pow(l.y-obj[j].y,2)+pow(l.z-obj[j].z,2));\n\t\t\tif(len-obj[j].r<=ESP)\n\t\t\t\tres+=obj[j].l;\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\ntypedef struct O{int x,y,z,r;long long l;}O;\ntypedef struct P{int x,y,z;}P;\ntypedef struct V{double x,y,z;}V;\n\nO obj[51];\nP s,t,v;\nint N,Q,i,j;\nlong long res;\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d%lld\",&obj[i].x,&obj[i].y,&obj[i].z,&obj[i].r,&obj[i].l);\n\tfor(i=0;i<Q;i++)\n\t{\n\t\tres=0;\n\t\tscanf(\"%d%d%d%d%d%d\",&s.x,&s.y,&s.z,&t.x,&t.y,&t.z);\n\t\tfor(j=0;j<N;j++)\n\t\t{\n\t\t\tP v={t.x-s.x,t.y-s.y,t.z-s.z};\n\t\t\tdouble a=v.x*(obj[j].x-s.x)+v.y*(obj[j].y-s.y)+v.z*(obj[j].z-s.z);\n\t\t\tdouble b=v.x*v.x+v.y*v.y+v.z*v.z;\n\t\t\tdouble c=a/b;\n\t\t\tV l={s.x+v.x*c,s.y+v.y*c,s.z+v.z*c};\n\t\t\tdouble len=sqrt(pow(l.x-obj[j].x,2)+pow(l.y-obj[j].y,2)+pow(l.z-obj[j].z,2));\n\t\t\tif(len-obj[j].r<=0)\n\t\t\t\tres+=obj[j].l;\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,d[2][3],o[2][3],i,j;\n  double h,l,p[3],k;\n  long long s[60][5],ans=0;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<n;i++){\n    for(j=0;j<5;j++)scanf(\"%lld\",&s[i][j]);//,printf(\"%lld \",s[i][j]);printf(\"\\n\");\n  }\n  while(m--){\n    for(i=ans=0;i<6;i++)scanf(\"%d\",&o[i/3][i%3]);\n    for(j=0;j<3;j++)d[0][j]=o[1][j]-o[0][j];//,printf(\"%d \",d[0][j]);printf(\"\\n\");\n    for(j=l=0;j<3;j++)l+=d[0][j]*d[0][j];//printf(\"l%lf\\n\",l);\n    for(i=0;i<n;i++){\n      for(j=  0;j<3;j++)d[1][j]=s[i][j]-o[0][j];//,printf(\"%d \",d[1][j]);printf(\"\\n\");\n      for(j=h=0;j<3;j++)h+=d[0][j]*d[1][j];//printf(\"h%lf\\n\",h);\n      if(h>l)continue;\n      for(j=  0;j<3;j++)p[j]=h/l*d[0][j]+o[0][j];//,printf(\"%f \",p[j]);printf(\"\\n\");\n      for(j=k=0;j<3;j++)k+=(p[j]-s[i][j])*(p[j]-s[i][j]);//printf(\"k%f\\n\",k);\n      if(s[i][3]*s[i][3]>k-0.000000001)ans+=s[i][4];//printf(\"s%lld\\n\",s[i][3]*s[i][3]);\n    }//printf(\"%d\\n\",i);\n    printf(\"%lld\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-5\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tif (k > 0 && k < 1)\n\t\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2641 Magic Bullet\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n#include <math.h>\n\n#define EPS 1e-8\n\ntypedef struct { double x, y, z; } PP;\t\t\t\t// Point\ntypedef struct { PP a, b; } LN;\t\t\t\t\t\t// Line\ntypedef struct { PP p; int r; long long l; } SP;\t// Sphere\nSP ball[51];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tif (c == '-') {\n\t\tc = getchar_unlocked();\n\t\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\t\twhile (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nlong long inlong()\n{\n\tlong long n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ndouble dot(PP a, PP b)\n{\n\treturn a.x*b.x + a.y*b.y + a.z*b.z;\n}\n\nvoid project(PP *q, LN ln, PP p)\n{\n\tdouble t;\n\tPP d, e;\n\n\td.x = ln.a.x-ln.b.x, d.y = ln.a.y-ln.b.y, d.z = ln.a.z-ln.b.z;\n\te.x = p.x-ln.a.x, e.y = p.y-ln.a.y, e.z = p.z-ln.a.z;\n\tt = dot(d, e) / dot(d, d);\n\tq->x = ln.a.x + d.x*t, q->y = ln.a.y + d.y*t, q->z = ln.a.z + d.z*t; \n}\n\ndouble dist(PP a, PP b)\n{\n\tdouble dx, dy, dz;\n\tdx = a.x-b.x, dy = a.y-b.y, dz = a.z-b.z;\n\treturn sqrt(dx*dx + dy*dy + dz*dz);\n}\n\nint main()\n{\n\tint n, q, i;\n\tlong long ans;\n\tLN ln;\n\tPP p;\n\n\tn = in(), q = in();\n\tfor (i = 0; i < n; i++) {\n\t\tball[i].p.x = in(), ball[i].p.y = in(), ball[i].p.z = in();\n\t\tball[i].r = in(), ball[i].l = inlong();\n\t}\n\twhile (q--) {\n\t\tln.a.x = in(), ln.a.y = in(), ln.a.z = in();\n\t\tln.b.x = in(), ln.b.y = in(), ln.b.z = in();\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tproject(&p, ln, ball[i].p);\n\n\t\t\tif (dist(ln.a, ln.b) >= dist(p, ln.a) &&\n\t\t\t\tdist(ln.a, ln.b) >= dist(p, ln.b) &&\n\t\t\t\tdist(p, ball[i].p) < ball[i].r + EPS) ans += ball[i].l;\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-1\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq <= sq(r[i]))\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-7\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\nll x[99],y[99],z[99],r[99],s[99];\nint main(){\n\tll n,q;\n\tscanf(\"%lld%lld\",&n,&q);\n\trep(i,0,n)scanf(\"%lld%lld%lld%lld%lld\",x+i,y+i,z+i,r+i,s+i);\n\twhile(q--){\n\t\tll a,b,c,d,e,f;\n\t\tscanf(\"%lld%lld%lld%lld%lld%lld\",&a,&b,&c,&d,&e,&f);\n\t\td-=a;e-=b;f-=c;//平行移動して\n\t\tll ss=(d*d+e*e+f*f);\n\t\tll ans=0;\n\t\trep(i,0,n){\n\t\t\tll xx=x[i]-a;\n\t\t\tll yy=y[i]-b;\n\t\t\tll zz=z[i]-c;\n\t\t\tll coe=(xx*d+yy*e+zz*f);//射影して引く\n\t\t\tll xxx=xx*ss-coe*d;\n\t\t\tll yyy=yy*ss-coe*e;\n\t\t\tll zzz=zz*ss-coe*f;\n//\t\t\tprintf(\"%lld %lld\\n\",coe,xxx*xxx+yyy*yyy+zzz*zzz);\n\t\t\tif(0<=coe&&coe<=ss){\n\t\t\t\tif(xxx*xxx+yyy*yyy+zzz*zzz<=r[i]*r[i]*ss*ss)ans+=s[i];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<string.h>\n#include<math.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define ABS(a) ((a) > (0) ? (a) : -(a))\n#define ALLOC(size,type) ((type*) calloc ((size), sizeof (type)))\n\ntypedef struct point {\n  i64 x, y, z;\n} point;\n\ntypedef struct ball {\n  point p;\n  i64 r;\n  i64 l;\n} ball;\n\ni64 func (point s, point dir, point q) {\n  return dir.x * (q.x - s.x) + dir.y * (q.y - s.y) + dir.z * (q.z - s.z);\n}\n\ni64 norm (point p) {\n  return p.x * p.x + p.y * p.y + p.z * p.z;\n}\n\ni64 SQ (i64 v) {\n  return v * v;\n}\n\nvoid run (void) {\n  i32 n, q;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &q);\n  ball *b = ALLOC (n, ball);\n  for (i32 i = 0; i < n; ++i) {\n    i32 x, y, z, r;\n    i64 l;\n    scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi64, &x, &y, &z, &r, &l);\n    b[i] = (ball) {(point){x, y, z}, r, l};\n  }\n  while (q--) {\n    point s, t;\n    scanf (\"%\" SCNi64 \"%\" SCNi64 \"%\" SCNi64, &s.x, &s.y, &s.z);\n    scanf (\"%\" SCNi64 \"%\" SCNi64 \"%\" SCNi64, &t.x, &t.y, &t.z);\n    point dir = {t.x - s.x, t.y - s.y, t.z - s.z};\n    i64 sum = 0;\n    for (i32 i = 0; i < n; ++i) {\n      ball a = b[i];\n      if (func (s, dir, a.p) * func (t, dir, a.p) >= 0) continue;\n      point c = {a.p.x - s.x, a.p.y - s.y, a.p.z - s.z};\n      point cross = {dir.y * c.z - dir.z * c.y, dir.z * c.x - dir.x * c.z, dir.x * c.y - dir.y * c.x};\n      if (norm (dir) * SQ(a.r) >= norm (cross)) {\n        sum += a.l;\n      }\n    }\n    printf (\"%\" PRIi64 \"\\n\", sum);\n  }\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\ntypedef struct O{int x,y,z,r;long long l;}O;\ntypedef struct P{int x,y,z;}P;\ntypedef struct V{double x,y,z;}V;\n\nO obj[51];\nP s,t,v;\nint N,Q,i,j;\nlong long res;\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&Q);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d%d%d%lld\",&obj[i].x,&obj[i].y,&obj[i].z,&obj[i].r,&obj[i].l);\n\tfor(i=0;i<Q;i++)\n\t{\n\t\tres=0;\n\t\tscanf(\"%d%d%d%d%d%d\",&s.x,&s.y,&s.z,&t.x,&t.y,&t.z);\n\t\tfor(j=0;j<N;j++)\n\t\t{\n\t\t\tP v={t.x-s.x,t.y-s.y,t.z-s.z};\n\t\t\tdouble a=v.x*(obj[j].x-s.x)+v.y*(obj[j].y-s.y)+v.z*(obj[j].z-s.z);\n\t\t\tdouble b=v.x*v.x+v.y*v.y+v.z*v.z;\n\t\t\tdouble c=a/b;\n\t\t\tV l={s.x+v.x*c,s.y+v.y*c,s.z+v.z*c};\n\t\t\tif(c<0)\n\t\t\t{\n\t\t\t\tl.x=s.x;l.y=s.y;l.z=s.z;\n\t\t\t}\n\t\t\telse if(c-1>=0)\n\t\t\t{\n\t\t\t\tl.x=t.x;l.y=t.y;l.z=t.z;\n\t\t\t}\n\t\t\tdouble len=sqrt(pow(l.x-obj[j].x,2)+pow(l.y-obj[j].y,2)+pow(l.z-obj[j].z,2));\n\t\t\tif(len-obj[j].r<=0)\n\t\t\t\tres+=obj[j].l;\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-3\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,d[2][3],o[2][3],i,j;\n  double h,l,p[3],k;\n  unsigned long long s[60][5],ans=0;\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<n;i++){\n    for(j=0;j<5;j++)scanf(\"%lld\",&s[i][j]);\n  }\n  while(m--){\n    for(i=0;i<6;i++)scanf(\"%d\",&o[i/3][i%3]);\n    for(j=0;j<3;j++)d[0][j]=o[1][j]-o[0][j];//,printf(\"%d \",d[0][j]);printf(\"\\n\");\n    for(j=l=0;j<3;j++)l+=d[0][j]*d[0][j];//printf(\"l%lf\\n\",l);\n    for(i=0;i<n;i++){\n      for(j=  0;j<3;j++)d[1][j]=s[i][j]-o[0][j];//,printf(\"%d \",d[1][j]);printf(\"\\n\");\n      for(j=h=0;j<3;j++)h+=d[0][j]*d[1][j];//printf(\"h%lf\\n\",h);\n      for(j=  0;j<3;j++)p[j]=h/l*d[0][j]+o[0][j];//,printf(\"%f \",p[j]);printf(\"\\n\");\n      for(j=k=0;j<3;j++)k+=(p[j]-s[i][j])*(p[j]-s[i][j]);//printf(\"k%lf\\n\",k);\n      if(s[i][3]*s[i][3]>k)ans+=s[i][4];//printf(\"%d\\n\",s[i][3]*s[i][3]);\n    }//printf(\"%d\\n\",i);\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-2\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define sq(x) ((x) * (x))\n\n#define EPS 1e-0\n\nint main(void) {\n\tint i;\n\tint n, q, x[50], y[50], z[50], r[50];\n\tlong long l[50];\n\n\tscanf(\"%d %d\", &n, &q);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d %d %d %d %lld\", x + i, y + i, z + i, r + i, l + i);\n\n\twhile (q--) {\n\t\tint xa, ya, za, xb, yb, zb;\n\t\tlong long ans;\n\n\t\tscanf(\"%d %d %d %d %d %d\", &xa, &ya, &za, &xb, &yb, &zb);\n\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tconst double k = (double)((x[i] - xa) * (xb - xa) + (y[i] - ya) * (yb - ya) + (z[i] - za) * (zb - za)) / (sq(xb - xa)  + sq(yb - ya) + sq(zb - za));\n\t\t\tconst double len_sq = sq(xa + k * (xb - xa) - x[i]) + sq(ya + k * (yb - ya) - y[i]) + sq(za + k * (zb - za) - z[i]);\n\t\t\tif (len_sq - sq(r[i]) < EPS)\n\t\t\t\tans += l[i];\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[] substract(int[] vec1, int[] vec2){\n\t\tint[] ret = new int[vec1.length];\n\t\t\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] - vec2[i]; \n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] substract(double[] vec1, double[] vec2){\n\t\tdouble[] ret = new double[vec1.length];\n\t\t\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] - vec2[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static double calc_dist(int[] vec){\n\t\tdouble ret = 0;\n\t\tfor(final int v : vec){\n\t\t\tret += v * v;\n\t\t}\n\t\treturn Math.sqrt(ret);\n\t}\n\t\n\tpublic static double calc_dist_2(double[] vec){\n\t\tdouble ret = 0;\n\t\tfor(final double d : vec){\n\t\t\tret += d * d;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] normalize(int[] vec){\n\t\tfinal double dist = calc_dist(vec);\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i] / dist; \n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] add(double[] vec1, double[] vec2){\n\t\tdouble[] ret = new double[vec1.length];\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] + vec2[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] multify(double[] vec, double d){\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i] * d;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double dot(double[] vec1, double[] vec2){\n\t\tdouble ret = 0;\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret += vec1[i] * vec2[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] toDouble(int[] vec){\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n       \n        final int N = sc.nextInt();\n        final int Q = sc.nextInt();\n        \n        int[][] points = new int[N][];\n        int[] rs = new int[N];\n        long[] ls = new long[N];\n        \n        for(int i = 0; i < N; i++){\n        \tpoints[i] = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \trs[i] = sc.nextInt();\n        \tls[i] = sc.nextLong();\n        }\n        \n        for(int q = 0; q < Q; q++){\n        \tint[] starts = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \tint[] ends = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \t\n        \tdouble[] double_starts = new double[]{starts[0], starts[1], starts[2]};\n\n        \tfinal double[] normal_diffs = normalize(substract(ends, starts));\n        \t//System.out.println(normal_diffs[0] + \" \" + normal_diffs[1] + \" \" + normal_diffs[2]);\n        \t\n        \tlong answer = 0;\n        \tfor(int i = 0; i < N; i++){\n        \t\tfinal double[] point = {points[i][0], points[i][1], points[i][2]};\n        \t\t\n        \t\tfinal double[] point_diffs = toDouble(substract(points[i], starts));\n        \t\t//System.out.println(point_diffs[0] + \" \" + point_diffs[1] + \" \" + point_diffs[2]);\n        \t\t\n        \t\tfinal double[] nearest_point = add(double_starts, multify(normal_diffs, dot(normal_diffs, point_diffs)));\n        \t\tfinal double point_to_seg_2 = calc_dist_2(substract(nearest_point, point));\n        \t\tfinal double point_radius_2 = rs[i] * rs[i];\n        \t\t\n        \t\t//System.out.println(point_to_seg_2 + \" \" + point_radius_2);\n        \t\tif(point_to_seg_2 <= point_radius_2){\n        \t\t\tanswer += ls[i];\n        \t\t}\n        \t}\n        \t\n        \tSystem.out.println(answer);\n        }\n        \n        \n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] x, y, z, r;\n\tstatic long[] l;\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tint Q = sc.nextInt();\n\t\tx = new int[N];\n\t\ty = new int[N];\n\t\tz = new int[N];\n\t\tr = new int[N];\n\t\tl = new long[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tz[i] = sc.nextInt();\n\t\t\tr[i] = sc.nextInt();\n\t\t\tl[i] = sc.nextLong();\n\t\t}\n\t\tfor (int i = 0; i < Q; ++i) {\n\t\t\tint sx = sc.nextInt();\n\t\t\tint sy = sc.nextInt();\n\t\t\tint sz = sc.nextInt();\n\t\t\tint dx = sc.nextInt();\n\t\t\tint dy = sc.nextInt();\n\t\t\tint dz = sc.nextInt();\n\t\t\tlong sum = 0;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdouble lo = 0;\n\t\t\t\tdouble hi = 1;\n\t\t\t\tfor (int k = 0; k < 300; ++k) {\n\t\t\t\t\tdouble m1 = (lo * 2 + hi) / 3;\n\t\t\t\t\tdouble m2 = (lo + hi * 2) / 3;\n\t\t\t\t\tdouble d1 = dist(x[j], y[j], z[j], sx + (dx - sx) * m1, sy + (dy - sy) * m1, sz + (dz - sz) * m1);\n\t\t\t\t\tdouble d2 = dist(x[j], y[j], z[j], sx + (dx - sx) * m2, sy + (dy - sy) * m2, sz + (dz - sz) * m2);\n\t\t\t\t\tif (d1 < d2) {\n\t\t\t\t\t\thi = m2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlo = m1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist(x[j], y[j], z[j], sx + (dx - sx) * lo, sy + (dy - sy) * lo, sz + (dz - sz) * lo) <= r[j] + 1e-8) {\n\t\t\t\t\tsum += l[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tstatic double dist(double x1, double y1, double z1, double x2, double y2, double z2) {\n\t\treturn Math.sqrt(sq(x1 - x2) + sq(y1 - y2) + sq(z1 - z2));\n\t}\n\n\tstatic double sq(double v) {\n\t\treturn v * v;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] A;\n\tstatic char[] B;\n\tstatic char[] C;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tGeometry3D.Point[] pA = new Geometry3D.Point[n];\n\t\tint[]   rA = new int[n];\n\t\tint[]   lA = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpA[i] = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\trA[i] = sc.nextInt();\n\t\t\tlA[i] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tGeometry3D.Point sP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tGeometry3D.Point dP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tint ans = 0;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(Geometry3D.intersectSC(sP, dP, pA[j], rA[j])) {\n\t\t\t\t\tans += lA[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Geometry3D {\n\n\t    static final double EPS = 1e-3;\n\n\t    static boolean approxEquals(double a, double b) {\n\t        return Math.abs(a - b) < EPS;\n\t    }\n\n\t    static class Point implements Comparable<Point> {\n\n\t        final double x, y, z;\n\n\t        public Point(double x, double y, double z) {\n\t            this.x = x;\n\t            this.y = y;\n\t            this.z = z;\n\t        }\n\n\t        /** ?????????dot(v1,v2)=|v1||v2|cos?? */\n\t        double dot(Point p) {\n\t            return x * p.x + y * p.y + z * p.z;\n\t        }\n\n\t        /** ?????????|cross(v1,v2)|=|v1||v2||sin??| */\n\t        Point cross(Point p) {\n\t            return new Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);\n\t        }\n\n\t        double distanceSqr() {\n\t            return x * x + y * y + z * z;\n\t        }\n\n\t        double distance() {\n\t            return Math.sqrt(distanceSqr());\n\t        }\n\n\t        double distanceSqr(Point p) {\n\t            return subtract(p).distanceSqr();\n\t        }\n\n\t        double distance(Point p) {\n\t            return subtract(p).distance();\n\t        }\n\n\t        Point add(Point p) {\n\t            return new Point(x + p.x, y + p.y, z + p.z);\n\t        }\n\n\t        Point multiply(double k) {\n\t            return new Point(k * x, k * y, k * z);\n\t        }\n\n\t        Point subtract(Point p) {\n\t            return new Point(x - p.x, y - p.y, z - p.z);\n\t        }\n\n\t        @Override\n\t        public boolean equals(Object obj) {  // ????????¢??°???Eclipse??§??????????????§?¨?????????????????????????????????°??????\n\t            if (this == obj) return true;\n\t            if (obj == null) return false;\n\t            if (getClass() != obj.getClass()) return false;\n\t            Point other = (Point) obj;\n\t            if (!approxEquals(x, other.x)) return false;\n\t            if (!approxEquals(y, other.y)) return false;\n\t            if (!approxEquals(z, other.z)) return false;\n\t            return true;\n\t        }\n\n\t        @Override\n\t        public int compareTo(Point o) {\n\t            if (!approxEquals(x, o.x)) return (int) Math.signum(x - o.x);\n\t            if (!approxEquals(y, o.y)) return (int) Math.signum(y - o.y);\n\t            if (!approxEquals(z, o.z)) return (int) Math.signum(z - o.z);\n\t            return 0;\n\t        }\n\n\t        @Override\n\t        public String toString() {\n\t            return \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t        }\n\n\t    }\n\n\t    /**\n\t     * @param a\n\t     * @param b\n\t     * @param c\n\t     * @param world ????????§?¨?????????´\n\t     * @return ?????????????????¨??????ccw\n\t     * @see Geometries2D#ccw(Point, Point, Point)\n\t     */\n\t    static int ccw(Point a, Point b, Point c, Point world) {\n\t        b = b.subtract(a);\n\t        c = c.subtract(a);\n\t        double d = world.dot(b.cross(c));\n\t        if (d > EPS) return +1;                           // counter clockwise\n\t        if (d + EPS < 0) return -1;                       // clockwise\n\t        // b??¨c???world????????±????????????????????¨????????????\n\t        //        if (b.dot(c) + EPS < 0) return +2;                // c--a--b on plane\n\t        //        if (b.distanceSqr() < c.distanceSqr()) return -2; // a--b--c on plane\n\t        return 0;                                         // on same projected line\n\t    }\n\n\t    /**\n\t     * @param n ????????????????????????\n\t     * @return ????????????p???????????????n??¨??????theta[rad]???????????????????????????\n\t     * @see http://hooktail.sub.jp/vectoranalysis/vectorRot/\n\t     */\n\t    static Point rotate(Point p, Point n, double theta) {\n\t        Point on = n.multiply(n.dot(p));\n\t        Point nv = p.subtract(on).multiply(Math.cos(theta));\n\t        Point qv = p.cross(n).multiply(Math.sin(theta));\n\t        return on.add(nv).subtract(qv);\n\t    }\n\n\t    /**\n\t     * @param a ?????¢??????1???\n\t     * @param n ?????¢?????????????????????\n\t     * @param p\n\t     * @return ???p????????¢????????±????????¨?????????\n\t     */\n\t    static Point projectOnPlane(Point a, Point n, Point p) {\n\t        Point ap = p.subtract(a);\n\t        double t = n.dot(ap) / n.distanceSqr();\n\t        return p.subtract(n.multiply(t));\n\t    }\n\n\t    /** @return ??´???a??????p????????±????????¨????????? */\n\t    static Point projectOnLine(Point a1, Point a2, Point p) {\n\t        Point a = a2.subtract(a1);\n\t        p = p.subtract(a1);\n\t        double t = a.dot(p) / a.distanceSqr();\n\t        return a1.add(a.multiply(t));\n\t    }\n\n\t    static double distancePlaneP(Point a, Point n, Point p) {\n\t        return projectOnPlane(a, n, p).distance(p);\n\t    }\n\n\t    static double distanceLP(Point a1, Point a2, Point p) {\n\t        return projectOnLine(a1, a2, p).distance(p);\n\t    }\n\n\t    static double distanceSP(Point a1, Point a2, Point p) {\n\t        Point r = projectOnLine(a1, a2, p);\n\t        // ?????±??????????????????????????????????????????p??????????????????????????¢???????????°??????\n\t        Point ra1 = a1.subtract(r);\n\t        Point ra2 = a2.subtract(r);\n\t        double dot = ra1.dot(ra2);\n\t        if (dot < EPS && approxEquals(dot * dot, ra1.distanceSqr() * ra2.distanceSqr())) return r\n\t                .distance(p);\n\t        // ????????§???????????°????????????????????¨????????¢\n\t        return Math.min(a1.distance(p), a2.distance(p));\n\t    }\n\n\t    /**\n\t     * ?????????????????¢????????????????????????????????????crosspointLL()????????¶???\n\t     * \n\t     * @see http://mathforum.org/library/drmath/view/51980.html\n\t     */\n\t    static double distanceLL(Point a1, Point a2, Point b1, Point b2) {\n\t        Point n = a2.subtract(a1).cross(b2.subtract(b1));\n\t        // n???0??????2??´??????????????????????????????????????§??????\n\t        if (n.distanceSqr() < EPS) return distanceLP(a1, a2, b1);\n\t        // n????????????b1??????????????¢???????????????a????????´??§???????????§???\n\t        // ????????????a????????????????????????????????¢???????????¢??????????????¨??????\n\t        return distancePlaneP(b1, n, a1);\n\t    }\n\n\n\t    static Point[] crosspointLSphere(Point a1, Point a2, Point c, double r) {\n\t        Point foot = projectOnLine(a1, a2, c);\n\t        double footLenSqr = foot.distanceSqr(c);\n\t        Point dir = a2.subtract(a1);\n\t        if (approxEquals(r * r, footLenSqr)) {  // ????????§??\\????????´???????????????????????????????????????\n\t            return new Point[] { foot };\n\t        }\n\t        if (r * r < footLenSqr) return new Point[0];\n\n\t        double len = Math.sqrt(r * r - footLenSqr) / dir.distance();\n\t        dir = dir.multiply(len);\n\t        return new Point[] { foot.add(dir), foot.subtract(dir), };\n\t    }\n\t     \n\t    static boolean intersectSC(Point p1, Point p2, Point cP, int rP) {\n\t        return distanceSP(p1,p2, cP) < rP + EPS;\n\t    }\n\n\n\t}\n\t\t\n\t\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[] substract(int[] vec1, int[] vec2){\n\t\tint[] ret = new int[vec1.length];\n\t\t\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] - vec2[i]; \n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] substract(double[] vec1, double[] vec2){\n\t\tdouble[] ret = new double[vec1.length];\n\t\t\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] - vec2[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static double calc_dist(int[] vec){\n\t\tdouble ret = 0;\n\t\tfor(final int v : vec){\n\t\t\tret += v * v;\n\t\t}\n\t\treturn Math.sqrt(ret);\n\t}\n\t\n\tpublic static double calc_dist_2(double[] vec){\n\t\tdouble ret = 0;\n\t\tfor(final double d : vec){\n\t\t\tret += d * d;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] normalize(int[] vec){\n\t\tfinal double dist = calc_dist(vec);\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i] / dist; \n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] add(double[] vec1, double[] vec2){\n\t\tdouble[] ret = new double[vec1.length];\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] + vec2[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] multify(double[] vec, double d){\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i] * d;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double dot(double[] vec1, double[] vec2){\n\t\tdouble ret = 0;\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret += vec1[i] * vec2[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] toDouble(int[] vec){\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n       \n        final int N = sc.nextInt();\n        final int Q = sc.nextInt();\n        \n        int[][] points = new int[N][];\n        int[] rs = new int[N];\n        long[] ls = new long[N];\n        \n        for(int i = 0; i < N; i++){\n        \tpoints[i] = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \trs[i] = sc.nextInt();\n        \tls[i] = sc.nextLong();\n        }\n        \n        for(int q = 0; q < Q; q++){\n        \tint[] starts = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \tint[] ends = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \t\n        \tdouble[] double_starts = new double[]{starts[0], starts[1], starts[2]};\n\n        \tfinal double[] normal_diffs = normalize(substract(ends, starts));\n        \t//System.out.println(normal_diffs[0] + \" \" + normal_diffs[1] + \" \" + normal_diffs[2]);\n        \t\n        \tlong answer = 0;\n        \tfor(int i = 0; i < N; i++){\n        \t\tfinal double[] point = {points[i][0], points[i][1], points[i][2]};\n        \t\t\n        \t\tfinal double[] point_diffs = toDouble(substract(points[i], starts));\n        \t\t//System.out.println(point_diffs[0] + \" \" + point_diffs[1] + \" \" + point_diffs[2]);\n        \t\t\n        \t\tfinal double[] nearest_point = add(double_starts, multify(normal_diffs, dot(normal_diffs, point_diffs)));\n        \t\tfinal double point_to_seg_2 = calc_dist_2(substract(nearest_point, point));\n        \t\tfinal double point_radius_2 = rs[i] * rs[i];\n        \t\t\n        \t\t//System.out.println(point_to_seg_2 + \" \" + point_radius_2);\n        \t\tif(point_to_seg_2 <= point_radius_2 + 1e-9){\n        \t\t\tanswer += ls[i];\n        \t\t}\n        \t}\n        \t\n        \tSystem.out.println(answer);\n        }\n        \n        \n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] A;\n\tstatic char[] B;\n\tstatic char[] C;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tGeometry3D.Point[] pA = new Geometry3D.Point[n];\n\t\tint[]   rA = new int[n];\n\t\tlong[]   lA = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpA[i] = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\trA[i] = sc.nextInt();\n\t\t\tlA[i] = sc.nextLong();\n\t\t}\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tGeometry3D.Point sP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tGeometry3D.Point dP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tlong ans = 0;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(Geometry3D.intersectSC(sP, dP, pA[j], rA[j])) {\n\t\t\t\t\tans += lA[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Geometry3D {\n\n\t    static final double EPS = 1e-3;\n\n\t    static boolean approxEquals(double a, double b) {\n\t        return Math.abs(a - b) < EPS;\n\t    }\n\n\t    static class Point implements Comparable<Point> {\n\n\t        final double x, y, z;\n\n\t        public Point(double x, double y, double z) {\n\t            this.x = x;\n\t            this.y = y;\n\t            this.z = z;\n\t        }\n\n\t        /** ?????????dot(v1,v2)=|v1||v2|cos?? */\n\t        double dot(Point p) {\n\t            return x * p.x + y * p.y + z * p.z;\n\t        }\n\n\t        /** ?????????|cross(v1,v2)|=|v1||v2||sin??| */\n\t        Point cross(Point p) {\n\t            return new Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);\n\t        }\n\n\t        double distanceSqr() {\n\t            return x * x + y * y + z * z;\n\t        }\n\n\t        double distance() {\n\t            return Math.sqrt(distanceSqr());\n\t        }\n\n\t        double distanceSqr(Point p) {\n\t            return subtract(p).distanceSqr();\n\t        }\n\n\t        double distance(Point p) {\n\t            return subtract(p).distance();\n\t        }\n\n\t        Point add(Point p) {\n\t            return new Point(x + p.x, y + p.y, z + p.z);\n\t        }\n\n\t        Point multiply(double k) {\n\t            return new Point(k * x, k * y, k * z);\n\t        }\n\n\t        Point subtract(Point p) {\n\t            return new Point(x - p.x, y - p.y, z - p.z);\n\t        }\n\n\t        @Override\n\t        public boolean equals(Object obj) {  // ????????¢??°???Eclipse??§??????????????§?¨?????????????????????????????????°??????\n\t            if (this == obj) return true;\n\t            if (obj == null) return false;\n\t            if (getClass() != obj.getClass()) return false;\n\t            Point other = (Point) obj;\n\t            if (!approxEquals(x, other.x)) return false;\n\t            if (!approxEquals(y, other.y)) return false;\n\t            if (!approxEquals(z, other.z)) return false;\n\t            return true;\n\t        }\n\n\t        @Override\n\t        public int compareTo(Point o) {\n\t            if (!approxEquals(x, o.x)) return (int) Math.signum(x - o.x);\n\t            if (!approxEquals(y, o.y)) return (int) Math.signum(y - o.y);\n\t            if (!approxEquals(z, o.z)) return (int) Math.signum(z - o.z);\n\t            return 0;\n\t        }\n\n\t        @Override\n\t        public String toString() {\n\t            return \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t        }\n\n\t    }\n\n\t    /**\n\t     * @param a\n\t     * @param b\n\t     * @param c\n\t     * @param world ????????§?¨?????????´\n\t     * @return ?????????????????¨??????ccw\n\t     * @see Geometries2D#ccw(Point, Point, Point)\n\t     */\n\t    static int ccw(Point a, Point b, Point c, Point world) {\n\t        b = b.subtract(a);\n\t        c = c.subtract(a);\n\t        double d = world.dot(b.cross(c));\n\t        if (d > EPS) return +1;                           // counter clockwise\n\t        if (d + EPS < 0) return -1;                       // clockwise\n\t        // b??¨c???world????????±????????????????????¨????????????\n\t        //        if (b.dot(c) + EPS < 0) return +2;                // c--a--b on plane\n\t        //        if (b.distanceSqr() < c.distanceSqr()) return -2; // a--b--c on plane\n\t        return 0;                                         // on same projected line\n\t    }\n\n\t    /**\n\t     * @param n ????????????????????????\n\t     * @return ????????????p???????????????n??¨??????theta[rad]???????????????????????????\n\t     * @see http://hooktail.sub.jp/vectoranalysis/vectorRot/\n\t     */\n\t    static Point rotate(Point p, Point n, double theta) {\n\t        Point on = n.multiply(n.dot(p));\n\t        Point nv = p.subtract(on).multiply(Math.cos(theta));\n\t        Point qv = p.cross(n).multiply(Math.sin(theta));\n\t        return on.add(nv).subtract(qv);\n\t    }\n\n\t    /**\n\t     * @param a ?????¢??????1???\n\t     * @param n ?????¢?????????????????????\n\t     * @param p\n\t     * @return ???p????????¢????????±????????¨?????????\n\t     */\n\t    static Point projectOnPlane(Point a, Point n, Point p) {\n\t        Point ap = p.subtract(a);\n\t        double t = n.dot(ap) / n.distanceSqr();\n\t        return p.subtract(n.multiply(t));\n\t    }\n\n\t    /** @return ??´???a??????p????????±????????¨????????? */\n\t    static Point projectOnLine(Point a1, Point a2, Point p) {\n\t        Point a = a2.subtract(a1);\n\t        p = p.subtract(a1);\n\t        double t = a.dot(p) / a.distanceSqr();\n\t        return a1.add(a.multiply(t));\n\t    }\n\n\t    static double distancePlaneP(Point a, Point n, Point p) {\n\t        return projectOnPlane(a, n, p).distance(p);\n\t    }\n\n\t    static double distanceLP(Point a1, Point a2, Point p) {\n\t        return projectOnLine(a1, a2, p).distance(p);\n\t    }\n\n\t    static double distanceSP(Point a1, Point a2, Point p) {\n\t        Point r = projectOnLine(a1, a2, p);\n\t        // ?????±??????????????????????????????????????????p??????????????????????????¢???????????°??????\n\t        Point ra1 = a1.subtract(r);\n\t        Point ra2 = a2.subtract(r);\n\t        double dot = ra1.dot(ra2);\n\t        if (dot < EPS && approxEquals(dot * dot, ra1.distanceSqr() * ra2.distanceSqr())) return r\n\t                .distance(p);\n\t        // ????????§???????????°????????????????????¨????????¢\n\t        return Math.min(a1.distance(p), a2.distance(p));\n\t    }\n\n\t    /**\n\t     * ?????????????????¢????????????????????????????????????crosspointLL()????????¶???\n\t     * \n\t     * @see http://mathforum.org/library/drmath/view/51980.html\n\t     */\n\t    static double distanceLL(Point a1, Point a2, Point b1, Point b2) {\n\t        Point n = a2.subtract(a1).cross(b2.subtract(b1));\n\t        // n???0??????2??´??????????????????????????????????????§??????\n\t        if (n.distanceSqr() < EPS) return distanceLP(a1, a2, b1);\n\t        // n????????????b1??????????????¢???????????????a????????´??§???????????§???\n\t        // ????????????a????????????????????????????????¢???????????¢??????????????¨??????\n\t        return distancePlaneP(b1, n, a1);\n\t    }\n\n\n\t    static Point[] crosspointLSphere(Point a1, Point a2, Point c, double r) {\n\t        Point foot = projectOnLine(a1, a2, c);\n\t        double footLenSqr = foot.distanceSqr(c);\n\t        Point dir = a2.subtract(a1);\n\t        if (approxEquals(r * r, footLenSqr)) {  // ????????§??\\????????´???????????????????????????????????????\n\t            return new Point[] { foot };\n\t        }\n\t        if (r * r < footLenSqr) return new Point[0];\n\n\t        double len = Math.sqrt(r * r - footLenSqr) / dir.distance();\n\t        dir = dir.multiply(len);\n\t        return new Point[] { foot.add(dir), foot.subtract(dir), };\n\t    }\n\t     \n\t    static boolean intersectSC(Point p1, Point p2, Point cP, int rP) {\n\t        return distanceSP(p1,p2, cP) < rP + EPS;\n\t    }\n\n\n\t}\n\t\t\n\t\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] A;\n\tstatic char[] B;\n\tstatic char[] C;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tGeometry3D.Point[] pA = new Geometry3D.Point[n];\n\t\tint[]   rA = new int[n];\n\t\tint[]   lA = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpA[i] = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\trA[i] = sc.nextInt();\n\t\t\tlA[i] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tGeometry3D.Point sP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tGeometry3D.Point dP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tint ans = 0;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(Geometry3D.intersectSC(sP, dP, pA[j], rA[j])) {\n\t\t\t\t\tans += lA[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Geometry3D {\n\n\t    static final double EPS = 1e-5;\n\n\t    static boolean approxEquals(double a, double b) {\n\t        return Math.abs(a - b) < EPS;\n\t    }\n\n\t    static class Point implements Comparable<Point> {\n\n\t        final double x, y, z;\n\n\t        public Point(double x, double y, double z) {\n\t            this.x = x;\n\t            this.y = y;\n\t            this.z = z;\n\t        }\n\n\t        /** ?????????dot(v1,v2)=|v1||v2|cos?? */\n\t        double dot(Point p) {\n\t            return x * p.x + y * p.y + z * p.z;\n\t        }\n\n\t        /** ?????????|cross(v1,v2)|=|v1||v2||sin??| */\n\t        Point cross(Point p) {\n\t            return new Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);\n\t        }\n\n\t        double distanceSqr() {\n\t            return x * x + y * y + z * z;\n\t        }\n\n\t        double distance() {\n\t            return Math.sqrt(distanceSqr());\n\t        }\n\n\t        double distanceSqr(Point p) {\n\t            return subtract(p).distanceSqr();\n\t        }\n\n\t        double distance(Point p) {\n\t            return subtract(p).distance();\n\t        }\n\n\t        Point add(Point p) {\n\t            return new Point(x + p.x, y + p.y, z + p.z);\n\t        }\n\n\t        Point multiply(double k) {\n\t            return new Point(k * x, k * y, k * z);\n\t        }\n\n\t        Point subtract(Point p) {\n\t            return new Point(x - p.x, y - p.y, z - p.z);\n\t        }\n\n\t        @Override\n\t        public boolean equals(Object obj) {  // ????????¢??°???Eclipse??§??????????????§?¨?????????????????????????????????°??????\n\t            if (this == obj) return true;\n\t            if (obj == null) return false;\n\t            if (getClass() != obj.getClass()) return false;\n\t            Point other = (Point) obj;\n\t            if (!approxEquals(x, other.x)) return false;\n\t            if (!approxEquals(y, other.y)) return false;\n\t            if (!approxEquals(z, other.z)) return false;\n\t            return true;\n\t        }\n\n\t        @Override\n\t        public int compareTo(Point o) {\n\t            if (!approxEquals(x, o.x)) return (int) Math.signum(x - o.x);\n\t            if (!approxEquals(y, o.y)) return (int) Math.signum(y - o.y);\n\t            if (!approxEquals(z, o.z)) return (int) Math.signum(z - o.z);\n\t            return 0;\n\t        }\n\n\t        @Override\n\t        public String toString() {\n\t            return \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t        }\n\n\t    }\n\n\t    /**\n\t     * @param a\n\t     * @param b\n\t     * @param c\n\t     * @param world ????????§?¨?????????´\n\t     * @return ?????????????????¨??????ccw\n\t     * @see Geometries2D#ccw(Point, Point, Point)\n\t     */\n\t    static int ccw(Point a, Point b, Point c, Point world) {\n\t        b = b.subtract(a);\n\t        c = c.subtract(a);\n\t        double d = world.dot(b.cross(c));\n\t        if (d > EPS) return +1;                           // counter clockwise\n\t        if (d + EPS < 0) return -1;                       // clockwise\n\t        // b??¨c???world????????±????????????????????¨????????????\n\t        //        if (b.dot(c) + EPS < 0) return +2;                // c--a--b on plane\n\t        //        if (b.distanceSqr() < c.distanceSqr()) return -2; // a--b--c on plane\n\t        return 0;                                         // on same projected line\n\t    }\n\n\t    /**\n\t     * @param n ????????????????????????\n\t     * @return ????????????p???????????????n??¨??????theta[rad]???????????????????????????\n\t     * @see http://hooktail.sub.jp/vectoranalysis/vectorRot/\n\t     */\n\t    static Point rotate(Point p, Point n, double theta) {\n\t        Point on = n.multiply(n.dot(p));\n\t        Point nv = p.subtract(on).multiply(Math.cos(theta));\n\t        Point qv = p.cross(n).multiply(Math.sin(theta));\n\t        return on.add(nv).subtract(qv);\n\t    }\n\n\t    /**\n\t     * @param a ?????¢??????1???\n\t     * @param n ?????¢?????????????????????\n\t     * @param p\n\t     * @return ???p????????¢????????±????????¨?????????\n\t     */\n\t    static Point projectOnPlane(Point a, Point n, Point p) {\n\t        Point ap = p.subtract(a);\n\t        double t = n.dot(ap) / n.distanceSqr();\n\t        return p.subtract(n.multiply(t));\n\t    }\n\n\t    /** @return ??´???a??????p????????±????????¨????????? */\n\t    static Point projectOnLine(Point a1, Point a2, Point p) {\n\t        Point a = a2.subtract(a1);\n\t        p = p.subtract(a1);\n\t        double t = a.dot(p) / a.distanceSqr();\n\t        return a1.add(a.multiply(t));\n\t    }\n\n\t    static double distancePlaneP(Point a, Point n, Point p) {\n\t        return projectOnPlane(a, n, p).distance(p);\n\t    }\n\n\t    static double distanceLP(Point a1, Point a2, Point p) {\n\t        return projectOnLine(a1, a2, p).distance(p);\n\t    }\n\n\t    static double distanceSP(Point a1, Point a2, Point p) {\n\t        Point r = projectOnLine(a1, a2, p);\n\t        // ?????±??????????????????????????????????????????p??????????????????????????¢???????????°??????\n\t        Point ra1 = a1.subtract(r);\n\t        Point ra2 = a2.subtract(r);\n\t        double dot = ra1.dot(ra2);\n\t        if (dot < EPS && approxEquals(dot * dot, ra1.distanceSqr() * ra2.distanceSqr())) return r\n\t                .distance(p);\n\t        // ????????§???????????°????????????????????¨????????¢\n\t        return Math.min(a1.distance(p), a2.distance(p));\n\t    }\n\n\t    /**\n\t     * ?????????????????¢????????????????????????????????????crosspointLL()????????¶???\n\t     * \n\t     * @see http://mathforum.org/library/drmath/view/51980.html\n\t     */\n\t    static double distanceLL(Point a1, Point a2, Point b1, Point b2) {\n\t        Point n = a2.subtract(a1).cross(b2.subtract(b1));\n\t        // n???0??????2??´??????????????????????????????????????§??????\n\t        if (n.distanceSqr() < EPS) return distanceLP(a1, a2, b1);\n\t        // n????????????b1??????????????¢???????????????a????????´??§???????????§???\n\t        // ????????????a????????????????????????????????¢???????????¢??????????????¨??????\n\t        return distancePlaneP(b1, n, a1);\n\t    }\n\n\n\t    static Point[] crosspointLSphere(Point a1, Point a2, Point c, double r) {\n\t        Point foot = projectOnLine(a1, a2, c);\n\t        double footLenSqr = foot.distanceSqr(c);\n\t        Point dir = a2.subtract(a1);\n\t        if (approxEquals(r * r, footLenSqr)) {  // ????????§??\\????????´???????????????????????????????????????\n\t            return new Point[] { foot };\n\t        }\n\t        if (r * r < footLenSqr) return new Point[0];\n\n\t        double len = Math.sqrt(r * r - footLenSqr) / dir.distance();\n\t        dir = dir.multiply(len);\n\t        return new Point[] { foot.add(dir), foot.subtract(dir), };\n\t    }\n\t     \n\t    static boolean intersectSC(Point p1, Point p2, Point cP, int rP) {\n\t        return distanceSP(p1,p2, cP) < rP + EPS;\n\t    }\n\n\n\t}\n\t\t\n\t\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic final double ESP = 0.0000000001;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint Q = in.nextInt();\n\t\tlong[][] obs = new long[N][5];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tobs[i][j] = in.nextLong();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<Q;k++){\n\t\t\tlong ans = 0;\n\t\t\tint[] start = {in.nextInt(),in.nextInt(),in.nextInt()};\n\t\t\tint[] goal = {in.nextInt(),in.nextInt(),in.nextInt()};\n\t\t\tfor(int i=0;i<N;i++){\n//\t\t\t\tSystem.out.println(\"l: \"+obs[i][3]*obs[i][3]);\n\t\t\t\tif(dis_p2(start,goal,obs[i]) < obs[i][3]*obs[i][3]+ESP){\n\t\t\t\t\tans += obs[i][4];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static double dis_p2(int[] s,int[] g,long[] p){\n\t\tdouble[] h = new double[3];\n\t\tlong[] sg = {g[0]-s[0],g[1]-s[1],g[2]-s[2]};\n\t\tlong[] sp = {p[0]-s[0],p[1]-s[1],p[2]-s[2]};\n\t\tdouble exp = ((double)(sg[0]*sp[0] + sg[1]*sp[1] + sg[2]*sp[2]))\n\t\t\t\t/ (sg[0]*sg[0] + sg[1]*sg[1] + sg[2]*sg[2]);\n\t\tif(exp<0 || exp>1) return Double.MAX_VALUE;\n\t\th[0] = s[0] + exp*sg[0];\n\t\th[1] = s[1] + exp*sg[1];\n\t\th[2] = s[2] + exp*sg[2];\n/*\t\tSystem.out.println(\"dis: \"+(Math.pow(h[0]-p[0],2)\n\t\t+Math.pow(h[1]-p[1],2)\n\t\t+Math.pow(h[2]-p[2],2)));*/\n\t\treturn Math.pow(h[0]-p[0],2)\n\t\t\t\t+Math.pow(h[1]-p[1],2)\n\t\t\t\t+Math.pow(h[2]-p[2],2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] A;\n\tstatic char[] B;\n\tstatic char[] C;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tGeometry3D.Point[] pA = new Geometry3D.Point[n];\n\t\tint[]   rA = new int[n];\n\t\tint[]   lA = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpA[i] = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\trA[i] = sc.nextInt();\n\t\t\tlA[i] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tGeometry3D.Point sP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tGeometry3D.Point dP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tint ans = 0;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(Geometry3D.intersectSC(sP, dP, pA[j], rA[j])) {\n\t\t\t\t\tans += lA[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Geometry3D {\n\n\t    static final double EPS = 1e-4;\n\n\t    static boolean approxEquals(double a, double b) {\n\t        return Math.abs(a - b) < EPS;\n\t    }\n\n\t    static class Point implements Comparable<Point> {\n\n\t        final double x, y, z;\n\n\t        public Point(double x, double y, double z) {\n\t            this.x = x;\n\t            this.y = y;\n\t            this.z = z;\n\t        }\n\n\t        /** ?????????dot(v1,v2)=|v1||v2|cos?? */\n\t        double dot(Point p) {\n\t            return x * p.x + y * p.y + z * p.z;\n\t        }\n\n\t        /** ?????????|cross(v1,v2)|=|v1||v2||sin??| */\n\t        Point cross(Point p) {\n\t            return new Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);\n\t        }\n\n\t        double distanceSqr() {\n\t            return x * x + y * y + z * z;\n\t        }\n\n\t        double distance() {\n\t            return Math.sqrt(distanceSqr());\n\t        }\n\n\t        double distanceSqr(Point p) {\n\t            return subtract(p).distanceSqr();\n\t        }\n\n\t        double distance(Point p) {\n\t            return subtract(p).distance();\n\t        }\n\n\t        Point add(Point p) {\n\t            return new Point(x + p.x, y + p.y, z + p.z);\n\t        }\n\n\t        Point multiply(double k) {\n\t            return new Point(k * x, k * y, k * z);\n\t        }\n\n\t        Point subtract(Point p) {\n\t            return new Point(x - p.x, y - p.y, z - p.z);\n\t        }\n\n\t        @Override\n\t        public boolean equals(Object obj) {  // ????????¢??°???Eclipse??§??????????????§?¨?????????????????????????????????°??????\n\t            if (this == obj) return true;\n\t            if (obj == null) return false;\n\t            if (getClass() != obj.getClass()) return false;\n\t            Point other = (Point) obj;\n\t            if (!approxEquals(x, other.x)) return false;\n\t            if (!approxEquals(y, other.y)) return false;\n\t            if (!approxEquals(z, other.z)) return false;\n\t            return true;\n\t        }\n\n\t        @Override\n\t        public int compareTo(Point o) {\n\t            if (!approxEquals(x, o.x)) return (int) Math.signum(x - o.x);\n\t            if (!approxEquals(y, o.y)) return (int) Math.signum(y - o.y);\n\t            if (!approxEquals(z, o.z)) return (int) Math.signum(z - o.z);\n\t            return 0;\n\t        }\n\n\t        @Override\n\t        public String toString() {\n\t            return \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t        }\n\n\t    }\n\n\t    /**\n\t     * @param a\n\t     * @param b\n\t     * @param c\n\t     * @param world ????????§?¨?????????´\n\t     * @return ?????????????????¨??????ccw\n\t     * @see Geometries2D#ccw(Point, Point, Point)\n\t     */\n\t    static int ccw(Point a, Point b, Point c, Point world) {\n\t        b = b.subtract(a);\n\t        c = c.subtract(a);\n\t        double d = world.dot(b.cross(c));\n\t        if (d > EPS) return +1;                           // counter clockwise\n\t        if (d + EPS < 0) return -1;                       // clockwise\n\t        // b??¨c???world????????±????????????????????¨????????????\n\t        //        if (b.dot(c) + EPS < 0) return +2;                // c--a--b on plane\n\t        //        if (b.distanceSqr() < c.distanceSqr()) return -2; // a--b--c on plane\n\t        return 0;                                         // on same projected line\n\t    }\n\n\t    /**\n\t     * @param n ????????????????????????\n\t     * @return ????????????p???????????????n??¨??????theta[rad]???????????????????????????\n\t     * @see http://hooktail.sub.jp/vectoranalysis/vectorRot/\n\t     */\n\t    static Point rotate(Point p, Point n, double theta) {\n\t        Point on = n.multiply(n.dot(p));\n\t        Point nv = p.subtract(on).multiply(Math.cos(theta));\n\t        Point qv = p.cross(n).multiply(Math.sin(theta));\n\t        return on.add(nv).subtract(qv);\n\t    }\n\n\t    /**\n\t     * @param a ?????¢??????1???\n\t     * @param n ?????¢?????????????????????\n\t     * @param p\n\t     * @return ???p????????¢????????±????????¨?????????\n\t     */\n\t    static Point projectOnPlane(Point a, Point n, Point p) {\n\t        Point ap = p.subtract(a);\n\t        double t = n.dot(ap) / n.distanceSqr();\n\t        return p.subtract(n.multiply(t));\n\t    }\n\n\t    /** @return ??´???a??????p????????±????????¨????????? */\n\t    static Point projectOnLine(Point a1, Point a2, Point p) {\n\t        Point a = a2.subtract(a1);\n\t        p = p.subtract(a1);\n\t        double t = a.dot(p) / a.distanceSqr();\n\t        return a1.add(a.multiply(t));\n\t    }\n\n\t    static double distancePlaneP(Point a, Point n, Point p) {\n\t        return projectOnPlane(a, n, p).distance(p);\n\t    }\n\n\t    static double distanceLP(Point a1, Point a2, Point p) {\n\t        return projectOnLine(a1, a2, p).distance(p);\n\t    }\n\n\t    static double distanceSP(Point a1, Point a2, Point p) {\n\t        Point r = projectOnLine(a1, a2, p);\n\t        // ?????±??????????????????????????????????????????p??????????????????????????¢???????????°??????\n\t        Point ra1 = a1.subtract(r);\n\t        Point ra2 = a2.subtract(r);\n\t        double dot = ra1.dot(ra2);\n\t        if (dot < EPS && approxEquals(dot * dot, ra1.distanceSqr() * ra2.distanceSqr())) return r\n\t                .distance(p);\n\t        // ????????§???????????°????????????????????¨????????¢\n\t        return Math.min(a1.distance(p), a2.distance(p));\n\t    }\n\n\t    /**\n\t     * ?????????????????¢????????????????????????????????????crosspointLL()????????¶???\n\t     * \n\t     * @see http://mathforum.org/library/drmath/view/51980.html\n\t     */\n\t    static double distanceLL(Point a1, Point a2, Point b1, Point b2) {\n\t        Point n = a2.subtract(a1).cross(b2.subtract(b1));\n\t        // n???0??????2??´??????????????????????????????????????§??????\n\t        if (n.distanceSqr() < EPS) return distanceLP(a1, a2, b1);\n\t        // n????????????b1??????????????¢???????????????a????????´??§???????????§???\n\t        // ????????????a????????????????????????????????¢???????????¢??????????????¨??????\n\t        return distancePlaneP(b1, n, a1);\n\t    }\n\n\n\t    static Point[] crosspointLSphere(Point a1, Point a2, Point c, double r) {\n\t        Point foot = projectOnLine(a1, a2, c);\n\t        double footLenSqr = foot.distanceSqr(c);\n\t        Point dir = a2.subtract(a1);\n\t        if (approxEquals(r * r, footLenSqr)) {  // ????????§??\\????????´???????????????????????????????????????\n\t            return new Point[] { foot };\n\t        }\n\t        if (r * r < footLenSqr) return new Point[0];\n\n\t        double len = Math.sqrt(r * r - footLenSqr) / dir.distance();\n\t        dir = dir.multiply(len);\n\t        return new Point[] { foot.add(dir), foot.subtract(dir), };\n\t    }\n\t     \n\t    static boolean intersectSC(Point p1, Point p2, Point cP, int rP) {\n\t        return distanceSP(p1,p2, cP) < rP + EPS;\n\t    }\n\n\n\t}\n\t\t\n\t\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint Q = in.nextInt();\n\t\tlong[][] obs = new long[N][5];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tobs[i][j] = in.nextLong();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<Q;k++){\n\t\t\tlong ans = 0;\n\t\t\tint[] start = {in.nextInt(),in.nextInt(),in.nextInt()};\n\t\t\tint[] goal = {in.nextInt(),in.nextInt(),in.nextInt()};\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(dis_p2(start,goal,obs[i]) <= obs[i][3]*obs[i][3] ){\n\t\t\t\t\tans += obs[i][4];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static double dis_p2(int[] s,int[] g,long[] p){\n\t\tdouble[] h = new double[3];\n\t\tlong[] sg = {g[0]-s[0],g[1]-s[1],g[2]-s[2]};\n\t\tlong[] sp = {p[0]-s[0],p[1]-s[1],p[2]-s[2]};\n\t\tdouble exp = ((double)(sg[0]*sp[0] + sg[1]*sp[1] + sg[2]*sp[2]))\n\t\t\t\t/ (sg[0]*sg[0] + sg[1]*sg[1] + sg[2]*sg[2]);\n\t\tif(exp<0 || exp>1) return Double.MAX_VALUE;\n\t\th[0] = s[0] + exp*sg[0];\n\t\th[1] = s[1] + exp*sg[1];\n\t\th[2] = s[2] + exp*sg[2];\n\t\treturn Math.pow(h[0]-p[0],2)\n\t\t\t\t+Math.pow(h[1]-p[1],2)\n\t\t\t\t+Math.pow(h[2]-p[2],2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] A;\n\tstatic char[] B;\n\tstatic char[] C;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\t\tGeometry3D.Point[] pA = new Geometry3D.Point[n];\n\t\tint[]   rA = new int[n];\n\t\tint[]   lA = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpA[i] = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\trA[i] = sc.nextInt();\n\t\t\tlA[i] = sc.nextInt();\n\t\t}\n\t\tfor(int i = 0; i < q; i++) {\n\t\t\tGeometry3D.Point sP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tGeometry3D.Point dP = new Geometry3D.Point(sc.nextInt(), sc.nextInt(), sc.nextInt());\n\t\t\tint ans = 0;\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(Geometry3D.crosspointLSphere(sP, dP, pA[j], rA[j]).length != 0) ans += lA[j];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Geometry3D {\n\n\t    static final double EPS = 1e-9;\n\n\t    static boolean approxEquals(double a, double b) {\n\t        return Math.abs(a - b) < EPS;\n\t    }\n\n\t    static class Point implements Comparable<Point> {\n\n\t        final double x, y, z;\n\n\t        public Point(double x, double y, double z) {\n\t            this.x = x;\n\t            this.y = y;\n\t            this.z = z;\n\t        }\n\n\t        /** ?????????dot(v1,v2)=|v1||v2|cos?? */\n\t        double dot(Point p) {\n\t            return x * p.x + y * p.y + z * p.z;\n\t        }\n\n\t        /** ?????????|cross(v1,v2)|=|v1||v2||sin??| */\n\t        Point cross(Point p) {\n\t            return new Point(y * p.z - z * p.y, z * p.x - x * p.z, x * p.y - y * p.x);\n\t        }\n\n\t        double distanceSqr() {\n\t            return x * x + y * y + z * z;\n\t        }\n\n\t        double distance() {\n\t            return Math.sqrt(distanceSqr());\n\t        }\n\n\t        double distanceSqr(Point p) {\n\t            return subtract(p).distanceSqr();\n\t        }\n\n\t        double distance(Point p) {\n\t            return subtract(p).distance();\n\t        }\n\n\t        Point add(Point p) {\n\t            return new Point(x + p.x, y + p.y, z + p.z);\n\t        }\n\n\t        Point multiply(double k) {\n\t            return new Point(k * x, k * y, k * z);\n\t        }\n\n\t        Point subtract(Point p) {\n\t            return new Point(x - p.x, y - p.y, z - p.z);\n\t        }\n\n\t        @Override\n\t        public boolean equals(Object obj) {  // ????????¢??°???Eclipse??§??????????????§?¨?????????????????????????????????°??????\n\t            if (this == obj) return true;\n\t            if (obj == null) return false;\n\t            if (getClass() != obj.getClass()) return false;\n\t            Point other = (Point) obj;\n\t            if (!approxEquals(x, other.x)) return false;\n\t            if (!approxEquals(y, other.y)) return false;\n\t            if (!approxEquals(z, other.z)) return false;\n\t            return true;\n\t        }\n\n\t        @Override\n\t        public int compareTo(Point o) {\n\t            if (!approxEquals(x, o.x)) return (int) Math.signum(x - o.x);\n\t            if (!approxEquals(y, o.y)) return (int) Math.signum(y - o.y);\n\t            if (!approxEquals(z, o.z)) return (int) Math.signum(z - o.z);\n\t            return 0;\n\t        }\n\n\t        @Override\n\t        public String toString() {\n\t            return \"(\" + x + \",\" + y + \",\" + z + \")\";\n\t        }\n\n\t    }\n\n\t    /**\n\t     * @param a\n\t     * @param b\n\t     * @param c\n\t     * @param world ????????§?¨?????????´\n\t     * @return ?????????????????¨??????ccw\n\t     * @see Geometries2D#ccw(Point, Point, Point)\n\t     */\n\t    static int ccw(Point a, Point b, Point c, Point world) {\n\t        b = b.subtract(a);\n\t        c = c.subtract(a);\n\t        double d = world.dot(b.cross(c));\n\t        if (d > EPS) return +1;                           // counter clockwise\n\t        if (d + EPS < 0) return -1;                       // clockwise\n\t        // b??¨c???world????????±????????????????????¨????????????\n\t        //        if (b.dot(c) + EPS < 0) return +2;                // c--a--b on plane\n\t        //        if (b.distanceSqr() < c.distanceSqr()) return -2; // a--b--c on plane\n\t        return 0;                                         // on same projected line\n\t    }\n\n\t    /**\n\t     * @param n ????????????????????????\n\t     * @return ????????????p???????????????n??¨??????theta[rad]???????????????????????????\n\t     * @see http://hooktail.sub.jp/vectoranalysis/vectorRot/\n\t     */\n\t    static Point rotate(Point p, Point n, double theta) {\n\t        Point on = n.multiply(n.dot(p));\n\t        Point nv = p.subtract(on).multiply(Math.cos(theta));\n\t        Point qv = p.cross(n).multiply(Math.sin(theta));\n\t        return on.add(nv).subtract(qv);\n\t    }\n\n\n\n\t    static Point projectOnLine(Point a1, Point a2, Point p) {\n\t        Point a = a2.subtract(a1);\n\t        p = p.subtract(a1);\n\t        double t = a.dot(p) / a.distanceSqr();\n\t        return a1.add(a.multiply(t));\n\t    }\n\n\t    static Point[] crosspointLSphere(Point a1, Point a2, Point c, double r) {\n\t        Point foot = projectOnLine(a1, a2, c);\n\t        double footLenSqr = foot.distanceSqr(c);\n\t        Point dir = a2.subtract(a1);\n\t        if (approxEquals(r * r, footLenSqr)) {  // ????????§??\\????????´???????????????????????????????????????\n\t            return new Point[] { foot };\n\t        }\n\t        if (r * r < footLenSqr) return new Point[0];\n\n\t        double len = Math.sqrt(r * r - footLenSqr) / dir.distance();\n\t        dir = dir.multiply(len);\n\t        return new Point[] { foot.add(dir), foot.subtract(dir), };\n\t    }\n\n\n\t}\n\t\t\n\t\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[] substract(int[] vec1, int[] vec2){\n\t\tint[] ret = new int[vec1.length];\n\t\t\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] - vec2[i]; \n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] substract(double[] vec1, double[] vec2){\n\t\tdouble[] ret = new double[vec1.length];\n\t\t\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] - vec2[i];\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static double calc_dist(int[] vec){\n\t\tdouble ret = 0;\n\t\tfor(final int v : vec){\n\t\t\tret += v * v;\n\t\t}\n\t\treturn Math.sqrt(ret);\n\t}\n\t\n\tpublic static double calc_dist_2(double[] vec){\n\t\tdouble ret = 0;\n\t\tfor(final double d : vec){\n\t\t\tret += d * d;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] normalize(int[] vec){\n\t\tfinal double dist = calc_dist(vec);\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i] / dist; \n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] add(double[] vec1, double[] vec2){\n\t\tdouble[] ret = new double[vec1.length];\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret[i] = vec1[i] + vec2[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] multify(double[] vec, double d){\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i] * d;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double dot(double[] vec1, double[] vec2){\n\t\tdouble ret = 0;\n\t\tfor(int i = 0; i < vec1.length; i++){\n\t\t\tret += vec1[i] * vec2[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static double[] toDouble(int[] vec){\n\t\tdouble[] ret = new double[vec.length];\n\t\tfor(int i = 0; i < vec.length; i++){\n\t\t\tret[i] = vec[i];\n\t\t}\n\t\treturn ret;\n\t}\n\t\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n       \n        final int N = sc.nextInt();\n        final int Q = sc.nextInt();\n        \n        int[][] points = new int[N][];\n        int[] rs = new int[N];\n        long[] ls = new long[N];\n        \n        for(int i = 0; i < N; i++){\n        \tpoints[i] = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \trs[i] = sc.nextInt();\n        \tls[i] = sc.nextLong();\n        }\n        \n        for(int q = 0; q < Q; q++){\n        \tint[] starts = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \tint[] ends = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};\n        \t\n        \tfinal double dist = calc_dist(substract(ends, starts));\n        \t\n        \tfinal double[] double_starts = new double[]{starts[0], starts[1], starts[2]};\n        \tfinal double[] double_ends = new double[]{ends[0], ends[1], ends[2]};\n        \t\n        \tfinal double[] normal_diffs = normalize(substract(ends, starts));\n        \t//System.out.println(normal_diffs[0] + \" \" + normal_diffs[1] + \" \" + normal_diffs[2]);\n        \t\n        \tlong answer = 0;\n        \tfor(int i = 0; i < N; i++){\n        \t\tfinal double[] point = {points[i][0], points[i][1], points[i][2]};\n        \t\t\n        \t\tfinal double[] point_diffs = toDouble(substract(points[i], starts));\n        \t\t//System.out.println(point_diffs[0] + \" \" + point_diffs[1] + \" \" + point_diffs[2]);\n        \t\t\n        \t\tfinal double dot = dot(normal_diffs, point_diffs);\n        \t\tfinal double[] nearest_point = dot < 0 ? double_starts : dot >= dist ? double_ends : add(double_starts, multify(normal_diffs, dot(normal_diffs, point_diffs)));\n        \t\t\n        \t\tfinal double point_to_seg_2 = calc_dist_2(substract(nearest_point, point));\n        \t\tfinal double point_radius_2 = rs[i] * rs[i];\n        \t\t\n        \t\t//System.out.println(point_to_seg_2 + \" \" + point_radius_2);\n        \t\tif(point_to_seg_2 <= point_radius_2 + 1e-9){\n        \t\t\tanswer += ls[i];\n        \t\t}\n        \t}\n        \t\n        \tSystem.out.println(answer);\n        }\n        \n        \n    }\n} "
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint Q = in.nextInt();\n\t\tint[][] obs = new int[N][5];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tobs[i][j] = in.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<Q;k++){\n\t\t\tint ans = 0;\n\t\t\tint[] start = {in.nextInt(),in.nextInt(),in.nextInt()};\n\t\t\tint[] goal = {in.nextInt(),in.nextInt(),in.nextInt()};\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(dis_p2(start,goal,obs[i]) <= obs[i][3]*obs[i][3] ){\n\t\t\t\t\tans += obs[i][4];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic static double dis_p2(int[] s,int[] g,int[] p){\n\t\tdouble[] h = new double[3];\n\t\tint[] sg = {g[0]-s[0],g[1]-s[1],g[2]-s[2]};\n\t\tint[] sp = {p[0]-s[0],p[1]-s[1],p[2]-s[2]};\n\t\tdouble exp = ((double)(sg[0]*sp[0] + sg[1]*sp[1] + sg[2]*sp[2]))\n\t\t\t\t/ (sg[0]*sg[0] + sg[1]*sg[1] + sg[2]*sg[2]);\n\t\tif(exp<0 || exp>1) return Double.MAX_VALUE;\n\t\th[0] = s[0] + exp*sg[0];\n\t\th[1] = s[1] + exp*sg[1];\n\t\th[2] = s[2] + exp*sg[2];\n\t\treturn Math.pow(h[0]-p[0],2)\n\t\t\t\t+Math.pow(h[1]-p[1],2)\n\t\t\t\t+Math.pow(h[2]-p[2],2);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace ConsoleApp1\n{\n    internal class Vector3\n    {\n        public Vector3(double x, double y, double z)\n        {\n            this.X = x;\n            this.Y = y;\n            this.Z = z;\n        }\n\n        public double X { private set; get; }\n        public double Y { private set; get; }\n        public double Z { private set; get; }\n\n        public static Vector3 operator -(Vector3 vector1, Vector3 vector2)\n        {\n            return new Vector3(\n                vector1.X - vector2.X,\n                vector1.Y - vector2.Y,\n                vector1.Z - vector2.Z);\n        }\n\n        public static double Distance(Vector3 vector1, Vector3 vector2)\n        {\n            Vector3 tmp = vector2 - vector1;\n            return Math.Sqrt(tmp.Norm());\n        }\n\n        public double Norm()\n        {\n            return\n                this.X * this.X +\n                this.Y * this.Y +\n                this.Z * this.Z;\n        }\n\n        public static double DotProduct(Vector3 vector1, Vector3 vector2)\n        {\n            return\n                vector1.X * vector2.X +\n                vector1.Y * vector2.Y +\n                vector1.Z * vector2.Z;\n        }\n\n        public static Vector3 Projection(Vector3 segment1, Vector3 segment2, Vector3 point)\n        {\n            Vector3 base_ = segment2 - segment1;\n            double r = DotProduct(point - segment1, base_) / base_.Norm();\n            Vector3 base2 = new Vector3(base_.X * r, base_.Y * r, base_.Z * r);\n\n            return new Vector3(\n                segment1.X + base2.X,\n                segment1.Y + base2.Y,\n                segment1.Z + base2.Z);\n        }\n    }\n\n    class Obstacle\n    {\n        public Obstacle(long x, long y, long z, long radius, long magic)\n        {\n            this.Point = new Vector3(x, y, z);\n            this.Radius = radius;\n            this.Magic = magic;\n        }\n\n        public Vector3 Point { private set; get; }\n        public long Radius { private set; get; }\n        public long Magic { private set; get; }\n    }\n\n    class ObjectPoint\n    {\n        public ObjectPoint(long blueX, long blueY, long blueZ, long redX, long redY, long redZ)\n        {\n            this.BlueObject = new Vector3(blueX, blueY, blueZ);\n            this.RedObject = new Vector3(redX, redY, redZ);\n        }\n\n        public Vector3 BlueObject { private set; get; }\n        public Vector3 RedObject { private set; get; }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //input\n            long[] inputNum = Console.ReadLine().Split(' ').Select(long.Parse).ToArray();\n\n            long obstacle_count = inputNum[0];\n            long object_pair = inputNum[1];\n\n            Obstacle[] obstacle_list = new Obstacle[obstacle_count];\n            ObjectPoint[] object_list = new ObjectPoint[object_pair];\n\n            for (int lp = 0; lp < obstacle_count; lp++)\n            {\n                inputNum = Console.ReadLine().Split(' ').Select(long.Parse).ToArray();\n                obstacle_list[lp] = new Obstacle(\n                    inputNum[0], inputNum[1], inputNum[2],\n                    inputNum[3], inputNum[4]);\n            }\n\n            for (int lp = 0; lp < object_pair; lp++)\n            {\n                inputNum = Console.ReadLine().Split(' ').Select(long.Parse).ToArray();\n                object_list[lp] = new ObjectPoint(\n                    inputNum[0], inputNum[1], inputNum[2],\n                    inputNum[3], inputNum[4], inputNum[5]);\n            }\n\n            //process\n            foreach (var object_ in object_list)\n            {\n                long magic_count = 0;\n\n                foreach (var obstacle in obstacle_list)\n                {\n                    /* \n                     * 垂線をおろす\n                     * 　垂線の長さがRadius以下であれば接触する\n                     */\n\n                    Vector3 projectionPoint = Vector3.Projection(object_.RedObject, object_.BlueObject, obstacle.Point);\n\n                    bool condition1 =\n                        object_.RedObject.X <= projectionPoint.X && projectionPoint.X <= object_.BlueObject.X ||\n                        object_.RedObject.Y <= projectionPoint.Y && projectionPoint.Y <= object_.BlueObject.Y ||\n                        object_.RedObject.Z <= projectionPoint.Z && projectionPoint.Z <= object_.BlueObject.Z;\n\n                    bool condition2 =\n                        object_.BlueObject.X <= projectionPoint.X && projectionPoint.X <= object_.RedObject.X ||\n                        object_.BlueObject.Y <= projectionPoint.Y && projectionPoint.Y <= object_.RedObject.Y ||\n                        object_.BlueObject.Z <= projectionPoint.Z && projectionPoint.Z <= object_.RedObject.Z;\n\n                    if (condition1 || condition2)\n                    {\n                        double distance = Vector3.Distance(obstacle.Point, projectionPoint);\n                        decimal distance2 = new decimal(distance);\n                        \n                        if (distance2 <= obstacle.Radius)\n                        {\n                            magic_count += obstacle.Magic;\n                        }\n                    }\n                }\n\n                //output\n                Console.WriteLine(magic_count);\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nrequire 'mathn'\n\nn, q = gets.split.map(&:to_i)\n\nobs = (1..n).map { gets.split.map(&:to_i) }\nq.times do\n    x1, y1, z1, x2, y2, z2 = gets.split.map(&:to_i)\n    v1 = Vector[x2 - x1, y2 - y1, z2 - z1]\n    sum = 0\n    obs.each do |x, y, z, r, l|\n        v2 = Vector[x - x1, y - y1, z - z1]\n        d2 = v1.inner_product(v2) ** 2 / (v1.to_a.map{|t| t * t}.inject(:+))\n        if v1.inner_product(v2) < 0\n            sum += l if (x - x1) ** 2 + (y - y1) ** 2 + (z - z1) ** 2 <= r * r\n        elsif d2 > (v1.to_a.map{|t| t * t}.inject(:+))\n            sum += l if (x - x2) ** 2 + (y - y2) ** 2 + (z - z2) ** 2 <= r * r\n        else\n            sum += l if v2.to_a.map{|t| t * t}.inject(:+) - d2 <= r * r\n        end\n    end\n    p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\n\nobs = []\nn.times{ obs << gets.split.map(&:to_f) }\n\nsd = []\nq.times{ sd << gets.split.map(&:to_f) }\n\nsd.each do |sd|\n  s,d = [sd[0,3], sd[3,3]]\n  puts obs.select{ |ob|\n    vsd = d.zip(s).map{|d,s| d-s}\n    vob = ob[0,3].zip(s).map{|x,y| x-y}\n    inner = vsd.map{|x| x*vob.zip(vsd).map{|x,y|x*y}.inject(&:+)}\n    inner = inner.map{|x| x/vsd.map{|x|x*x}.inject(&:+)}\n    dis = vob.zip(inner).map{|x,y| x-y}.map{|x| x**2}.inject(&:+)\n    ob[3]**2 + 0.001 >= dis\n  }.map{|x,y,z,r,l| l}.inject(0,&:+).to_i\nend"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\n\nobs = []\nn.times{ obs << gets.split.map(&:to_f) }\n\nsds = []\nq.times{ sds << gets.split.map(&:to_f) }\n\nsds.each do |sd|\n  s,d = [sd[0,3], sd[3,3]]\n  puts obs.select{ |ob|\n    vsd = d.zip(s).map{|d,s| d-s}\n    vob = ob[0,3].zip(s).map{|x,y| x-y}\n    co = vob.zip(vsd).map{|x,y|x*y}.inject(&:+)/vsd.map{|x|x*x}.inject(&:+)\n    next false unless 0.0 <= co && co <= 1.0\n    proj = vsd.map{|x| x*co}\n    dis = vob.zip(proj).map{|x,y| x-y}.map{|x| x**2}.inject(&:+)\n    ob[3]**2 + 0.0001 >= dis\n  }.map{|x,y,z,r,l| l}.inject(0,&:+).to_i\nend"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\n\nobs = []\nn.times{ obs << gets.split.map(&:to_i) }\n\nsds = []\nq.times{ sds << gets.split.map(&:to_f) }\n\nsds.each do |sd|\n  s,d = [sd[0,3], sd[3,3]]\n  puts obs.select{ |ob|\n    vsd = d.zip(s).map{|d,s| d-s}\n    vob = ob[0,3].zip(s).map{|x,y| x-y}\n    co = vob.zip(vsd).map{|x,y|x*y}.inject(&:+)/vsd.map{|x|x*x}.inject(&:+)\n    next false unless 0.0 <= co && co <= 1.0\n    proj = vsd.map{|x| x*co}\n    dis = vob.zip(proj).map{|x,y| x-y}.map{|x| x**2}.inject(&:+)\n    ob[3]**2 + 0.0001 >= dis\n  }.map{|x,y,z,r,l| l}.inject(0,&:+)\nend"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\n\nobs = []\nn.times{ obs << gets.split.map(&:to_f) }\n\nsd = []\nq.times{ sd << gets.split.map(&:to_f) }\n\nsd.each do |sd|\n  s,d = [sd[0,3], sd[3,3]]\n  puts obs.select{ |ob|\n    vsd = d.zip(s).map{|d,s| d-s}\n    vob = ob[0,3].zip(s).map{|x,y| x-y}\n    inner = vsd.map{|x| x*vob.zip(vsd).map{|x,y|x*y}.inject(&:+)}\n    inner = inner.map{|x| x/vsd.map{|x|x*x}.inject(&:+)}\n    dis = vob.zip(inner).map{|x,y| x-y}.map{|x| x**2}.inject(&:+)\n    ob[3]**2 + 0.00001 >= dis\n  }.map{|x,y,z,r,l| l}.inject(0,&:+).to_i\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nrequire 'mathn'\n\nn, q = gets.split.map(&:to_i)\n\nobs = (1..n).map { gets.split.map(&:to_i) }\nq.times do\n    x1, y1, z1, x2, y2, z2 = gets.split.map(&:to_i)\n    v1 = Vector[x2 - x1, y2 - y1, z2 - z1]\n    sum = 0\n    obs.each do |x, y, z, r, l|\n        v2 = Vector[x - x1, y - y1, z - z1]\n        d2 = v1.inner_product(v2) ** 2 / (v1.to_a.map{|t| t * t}.inject(:+))\n        if d2 < 0\n            sum += l if (x - x1) ** 2 + (y - y1) ** 2 + (z - z1) ** 2 <= r * r\n        elsif d2 > (v1.to_a.map{|t| t * t}.inject(:+))\n            sum += l if (x - x2) ** 2 + (y - y2) ** 2 + (z - z2) ** 2 <= r * r\n        else\n            sum += l if v2.to_a.map{|t| t * t}.inject(:+) - d2 <= r * r\n        end\n    end\n    p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "n, q = gets.split.map(&:to_i)\n\nobs = (1..n).map { gets.split.map(&:to_i) }\nq.times do\n    x1, y1, z1, x2, y2, z2 = gets.split.map(&:to_i)\n    v1 = Vector[x2 - x1, y2 - y1, z2 - z1]\n    sum = 0\n    obs.each do |x, y, z, r, l|\n        v2 = Vector[x - x1, y - y1, z - z1]\n        d2 = v1.inner_product(v2) ** 2 / (v1.to_a.map{|t| t * t}.inject(:+))\n        if d2 < 0\n            sum += l if (x - x1) ** 2 + (y - y1) ** 2 + (z - z1) ** 2 <= r * r\n        elsif d2 > (v1.to_a.map{|t| t * t}.inject(:+))\n            sum += l if (x - x2) ** 2 + (y - y2) ** 2 + (z - z2) ** 2 <= r * r\n        else\n            sum += l if v2.to_a.map{|t| t * t}.inject(:+) - d2 <= r * r\n        end\n    end\n    p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "n,q = gets.split.map(&:to_i)\n\nobs = []\nn.times{ obs << gets.split.map(&:to_f) }\n\nsds = []\nq.times{ sds << gets.split.map(&:to_f) }\n\nsds.each do |sd|\n  s,d = [sd[0,3], sd[3,3]]\n  puts obs.select{ |ob|\n    vsd = d.zip(s).map{|d,s| d-s}\n    vob = ob[0,3].zip(s).map{|x,y| x-y}\n    co = vob.zip(vsd).map{|x,y|x*y}.inject(&:+)/vsd.map{|x|x*x}.inject(&:+)\n    next false unless 0.0 <= co && co <= 1.0\n    proj = vsd.map{|x| x*co}\n    dis = vob.zip(proj).map{|x,y| x-y}.map{|x| x**2}.inject(&:+)\n    ob[3]**2 + 0.0000001 >= dis\n  }.map{|x,y,z,r,l| l}.inject(0,&:+).to_i\nend"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef dist2(ax, ay, az, bx, by, bz):\n    return (ax - bx) ** 2 + (ay - by) ** 2 + (az - bz) ** 2\n\ndef judge(d1, d2, d3):\n    e1, e2, e3 = sqrt(d1), sqrt(d2), sqrt(d3)\n    cos1 = (d1 + d2 - d3) / (2 * e1 * e2)\n    cos2 = (d1 + d3 - d2) / (2 * e1 * e3)\n    return (0 <= cos1 and 0 <= cos2)\n    \nN, Q = map(int, raw_input().split())\nobj = [map(int, raw_input().split()) for i in xrange(N)]\n\nfor loop in xrange(Q):\n    sx, sy, sz, dx, dy, dz = map(int, raw_input().split())\n    vx, vy, vz = dx - sx, dy - sy, dz - sz\n    d1 = dist2(sx, sy, sz, dx, dy, dz)\n    cost = 0\n    for x, y, z, r, l in obj:\n        d2, d3 = dist2(x, y, z, sx, sy, sz), dist2(x, y, z, dx, dy, dz)\n        if not judge(d1, d2, d3): continue\n        t = 1.0 * (vx * (x - sx) + vy * (y - sy) + vz * (z - sz)) / (vx * vx + vy * vy + vz * vz)\n        tx, ty, tz = sx + vx * t, sy + vy * t, sz + vz * t\n        d = dist2(x, y, z, tx, ty, tz)\n        if d <= r * r + 1e-9:\n            cost += l\n    print cost"
  },
  {
    "language": "Python",
    "code": "from math import sin, acos\nN, Q = map(int, input().split())\nobs = [tuple(map(int, input().split())) for _ in range(N)]\ndef dist(v):\n    return sum(x ** 2 for x in v)\n\ndef cos(v1, v2):\n    return sum(x * y for x, y in zip(v1, v2)) / pow(dist(v1), 0.5) / pow(dist(v2), 0.5)\n\n\nfor _ in range(Q):\n    sx, sy, sz, dx, dy, dz = map(int, input().split())\n    v_oa = (dx - sx, dy - sy, dz - sz)\n    ans = 0\n    for x, y, z, r, l in obs:\n        v_or = (x - sx, y - sy, z - sz)\n        # print(pow(dist(v_or), 0.5), sin(acos(cos(v_or, v_oa))), abs(pow(dist(v_or), 0.5) * sin(acos(cos(v_or, v_oa)))), r + 1e-9)\n        if abs(pow(dist(v_or), 0.5) * sin(acos(cos(v_or, v_oa)))) <= r + 1e-9:\n            ans += l\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef dist2(ax, ay, az, bx, by, bz):\n    return (ax - bx) ** 2 + (ay - by) ** 2 + (az - bz) ** 2\n\nN, Q = map(int, raw_input().split())\nobj = [map(int, raw_input().split()) for i in xrange(N)]\n\nfor loop in xrange(Q):\n    sx, sy, sz, dx, dy, dz = map(int, raw_input().split())\n    d1 = dist2(sx, sy, sz, dx, dy, dz)\n    vx, vy, vz = dx - sx, dy - sy, dz - sz\n    cost = 0\n    for x, y, z, r, l in obj:\n        d2, d3 = dist2(x, y, z, sx, sy, sz), dist2(x, y, z, dx, dy, dz)\n        if not d2 + d3 <= d1: continue\n        t = 1.0 * (vx * (x - sx) + vy * (y - sy) + vz * (z - sz)) / (vx * vx + vy * vy + vz * vz)\n        tx, ty, tz = sx + vx * t, sy + vy * t, sz + vz * t\n        d = dist2(x, y, z, tx, ty, tz)\n        if d <= r * r + 1e-9:\n            cost += l\n    print cost"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n = I()\n    s = 0\n    ans = \"YES\"\n    for i in range(n):\n        k = input()\n        if k == \"Un\":\n            s -= 1\n        else:\n            s += 1\n        if s < 0:\n            ans = \"NO\"\n    if s:\n        print(\"NO\")\n    else:\n        print(ans)\n    return\n\n#B\ndef B():\n    return\n\n#C\ndef C():\n    n,q = LI()\n    p = LIR(n)\n    for _ in range(q):\n        x0,y0,z0,s,t,u = LI()\n        a,b,c = (s-x0,t-y0,u-z0)\n        ans = 0\n        su = a**2+b**2+c**2\n        for xr,yr,zr,r,l in p:\n            x = (su-a**2)/su*x0-a/su*(b*y0+c*z0-a*xr-b*yr-c*zr)\n            y = (su-b**2)/su*y0-b/su*(a*x0+c*z0-a*xr-b*yr-c*zr)\n            z = (su-c**2)/su*z0-c/su*(b*y0+a*x0-a*xr-b*yr-c*zr)\n            if min(x0,s)-1e-4 <= x <= max(x0,s)+1e-4 and min(y0,t)-1e-4 <= y <= max(y0,t)+1e-4 and min(z0,u)-1e-4 <= z <= max(z0,u)+1e-4:\n                x -= xr\n                y -= yr\n                z -= zr\n                r2 = x**2+y**2+z**2\n                if r2 <= r**2+1e-4:\n                    ans += l\n        print(ans)\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#I\ndef I_():\n    return\n\n#J\ndef J():\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    C()\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sin, acos\nN, Q = map(int, input().split())\nobs = [tuple(map(int, input().split())) for _ in range(N)]\ndef dist(v):\n    return sum(x ** 2 for x in v)\n\ndef cos(v1, v2):\n    return sum(x * y for x, y in zip(v1, v2)) / pow(dist(v1), 0.5) / pow(dist(v2), 0.5)\n\n\nfor _ in range(Q):\n    sx, sy, sz, dx, dy, dz = map(int, input().split())\n    v_oa = (dx - sx, dy - sy, dz - sz)\n    ans = 0\n    for x, y, z, r, l in obs:\n        v_or = (x - sx, y - sy, z - sz)\n        # print(pow(dist(v_or), 0.5), sin(acos(cos(v_or, v_oa))), abs(pow(dist(v_or), 0.5) * sin(acos(cos(v_or, v_oa)))), r + 1e-9)\n        if cos(v_or, v_oa) >= 0 and abs(pow(dist(v_or), 0.5) * sin(acos(cos(v_or, v_oa)))) <= r + 1e-9:\n            ans += l\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "eps = 1.0 / 10**10\ndef LI(): return [int(x) for x in input().split()]\n\ndef main():\n    n,q = LI()\n    na = [LI() for _ in range(n)]\n    qa = [LI() for _ in range(q)]\n    rr = []\n\n    def k(a,b):\n        return sum([(a[i]-b[i]) ** 2 for i in range(3)]) ** 0.5\n\n    def f(a,b,c,r):\n        ab = k(a,b)\n        ac = k(a,c)\n        bc = k(b,c)\n        if ac <= r or bc <= r:\n            return True\n        at = (ac ** 2 - r ** 2) ** 0.5\n        bt = (bc ** 2 - r ** 2) ** 0.5\n        return ab >= at + bt - eps\n\n    for x1,y1,z1,x2,y2,z2 in qa:\n        tr = 0\n        for x,y,z,r,l in na:\n            if f((x1,y1,z1),(x2,y2,z2),(x,y,z),r):\n                tr += l\n        rr.append(tr)\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "def dist2(ax, ay, az, bx, by, bz):\n    return (ax - bx) ** 2 + (ay - by) ** 2 + (az - bz) ** 2\n\ndef judge(d1, d2, d3):\n    d1, d2, d3 = sorted([d1, d2, d3])\n    return d1 + d2 <= d3\n    \nN, Q = map(int, raw_input().split())\nobj = [map(int, raw_input().split()) for i in xrange(N)]\n\nfor loop in xrange(Q):\n    sx, sy, sz, dx, dy, dz = map(int, raw_input().split())\n    vx, vy, vz = dx - sx, dy - sy, dz - sz\n    d1 = dist2(sx, sy, sz, dx, dy, dz)\n    cost = 0\n    for x, y, z, r, l in obj:\n        d2, d3 = dist2(x, y, z, sx, sy, sz), dist2(x, y, z, dx, dy, dz)\n        if not judge(d1, d2, d3): continue\n        t = 1.0 * (vx * (x - sx) + vy * (y - sy) + vz * (z - sz)) / (vx * vx + vy * vy + vz * vz)\n        tx, ty, tz = sx + vx * t, sy + vy * t, sz + vz * t\n        d = dist2(x, y, z, tx, ty, tz)\n        if d <= r * r:\n            cost += l\n    print cost"
  },
  {
    "language": "Python",
    "code": "import math\n\ndef sub(a, b):\n    return [x-y for x,y in zip(a,b)]\n\ndef dot(a, b):\n    return sum(x*y for x,y in zip(a,b))\n\ndef cross(a, b):\n    return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]\n\ndef abs2(a):\n    return sum([x*x for x in a])\n\ndef deg(a, b):\n    return (math.acos(dot(a,b)/math.sqrt(abs2(a)*abs2(b))))\n\nN,Q = map(int,input().split())\nls = [list(map(int,input().split())) for i in range(N)]\n\nfor i in range(Q):\n    sx,sy,sz,dx,dy,dz = map(int,input().split())\n    cost = 0\n    s = [sx,sy,sz]\n    d = [dx,dy,dz]\n    sd = sub(d,s)\n    ds = sub(s,d)\n    for v in ls:\n        if abs(deg(sub(v[:3],s),sd)) < math.pi/2 and abs(deg(sub(v[:3],d), ds)) < math.pi/2:\n            if abs2(cross(sub(v[:3],s),sd)) <= abs2(sd)*v[3]**2:\n                cost += v[4]\n        else:\n            if min(abs2(sub(v[:3],s)), abs2(sub(v[:3],d))) <= v[3]**2:\n                cost += v[4]\n    print(cost)\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\ndef dist2(ax, ay, az, bx, by, bz):\n    return (ax - bx) ** 2 + (ay - by) ** 2 + (az - bz) ** 2\n\ndef judge(d1, d2, d3):\n    e1, e2, e3 = sqrt(d1), sqrt(d2), sqrt(d3)\n    cos1 = (d1 + d2 - d3) / (2 * e1 * e2)\n    cos2 = (d1 + d3 - d2) / (2 * e1 * e3)\n    return (0 <= cos1 and 0 <= cos2)\n    \nN, Q = map(int, raw_input().split())\nobj = [map(int, raw_input().split()) for i in xrange(N)]\n\nfor loop in xrange(Q):\n    sx, sy, sz, dx, dy, dz = map(int, raw_input().split())\n    vx, vy, vz = dx - sx, dy - sy, dz - sz\n    d1 = dist2(sx, sy, sz, dx, dy, dz)\n    cost = 0\n    for x, y, z, r, l in obj:\n        d2, d3 = dist2(x, y, z, sx, sy, sz), dist2(x, y, z, dx, dy, dz)\n        if not judge(d1, d2, d3): continue\n        t = 1.0 * (vx * (x - sx) + vy * (y - sy) + vz * (z - sz)) / (vx * vx + vy * vy + vz * vz)\n        tx, ty, tz = sx + vx * t, sy + vy * t, sz + vz * t\n        d = dist2(x, y, z, tx, ty, tz)\n        if d <= r * r:\n            cost += l\n    print cost"
  },
  {
    "language": "Python",
    "code": "N, Q = map(int, input().split())\nx = [None] * N\ny = [None] * N\nz = [None] * N\nr = [None] * N\nl = [None] * N\nfor i in range(N):\n    x[i], y[i], z[i], r[i], l[i] = map(int, input().split())\n\nfor _ in range(Q):\n    ans = 0\n    sx, sy, sz, dx, dy, dz = map(int, input().split())\n    vx = dx - sx\n    vy = dy - sy\n    vz = dz - sz\n    for i in range(N):\n        t = 0\n        t += vx * (x[i] - sx)\n        t += vy * (y[i] - sy)\n        t += vz * (z[i] - sz)\n        t /= vx**2 + vy**2 + vz**2\n        len2 = 0\n        len2 += (sx + vx * t - x[i])**2\n        len2 += (sy + vy * t - y[i])**2\n        len2 += (sz + vz * t - z[i])**2\n        if 0 < t < 1 and len2 <= r[i]**2 + 1e-9:\n            ans += l[i]\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "N, Q = map(int, raw_input().split())\nobj = [map(int, raw_input().split()) for i in xrange(N)]\n\nfor loop in xrange(Q):\n    sx, sy, sz, dx, dy, dz = map(int, raw_input().split())\n    vx, vy, vz = dx - sx, dy - sy, dz - sz\n    cost = 0\n    for x, y, z, r, l in obj:\n        t = 1.0 * (vx * (x - sx) + vy * (y - sy) + vz * (z - sz)) / (vx * vx + vy * vy + vz * vz)\n        tx, ty, tz = sx + vx * t, sy + vy * t, sz + vz * t\n        d = (x - tx) ** 2 + (y - ty) ** 2 + (z - tz) ** 2\n        if d <= r * r:\n            cost += l\n    print cost"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n,q = LI()\n    a = [LI() for _ in range(n)]\n    b = [LI() for _ in range(q)]\n    rr = []\n\n    def k(a,b):\n        return sum([(a[i]-b[i]) ** 2 for i in range(3)]) ** 0.5\n\n    def f(a,b,c,r):\n        ab = k(a,b)\n        ac = k(a,c)\n        bc = k(b,c)\n        if ac <= r or bc <= r:\n            return True\n        at = (ac ** 2 - r ** 2)\n        bt = (bc ** 2 - r ** 2)\n        t = max(at,0) ** 0.5 + max(bt,0) ** 0.5\n        return ab >= t - eps\n\n    for x1,y1,z1,x2,y2,z2 in b:\n        tr = 0\n        ta = (x1,y1,z1)\n        tb = (x2,y2,z2)\n        for x,y,z,r,l in a:\n            if f(ta,tb,(x,y,z),r):\n                tr += l\n        rr.append(tr)\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  }
]