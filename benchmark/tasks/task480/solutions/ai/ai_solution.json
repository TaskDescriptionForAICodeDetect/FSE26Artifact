[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n#include <limits.h>\n\n#define MAX_OBJECTS 100\n#define MAX_OBSTACLES 50\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point start, end;\n    double energy_cost;\n} Obstacle;\n\ntypedef struct {\n    Point red, blue;\n} ObjectPair;\n\ndouble distance(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nint line_intersects_obstacle(Point start, Point end, Obstacle obstacle) {\n    // Line segment intersection check implementation\n    return 0;\n}\n\ndouble calculate_min_energy(ObjectPair pairs[], int pair_count, \n                             Obstacle obstacles[], int obstacle_count) {\n    double min_total_energy = DBL_MAX;\n\n    for (int i = 0; i < pair_count; i++) {\n        double current_energy = 0;\n        Point current_pos = pairs[i].red;\n        Point target = pairs[i].blue;\n\n        for (int j = 0; j < obstacle_count; j++) {\n            if (line_intersects_obstacle(current_pos, target, obstacles[j])) {\n                current_energy += obstacles[j].energy_cost;\n            }\n        }\n\n        min_total_energy = fmin(min_total_energy, current_energy);\n    }\n\n    return min_total_energy;\n}\n\nint main() {\n    int obstacle_count, pair_count;\n    Obstacle obstacles[MAX_OBSTACLES];\n    ObjectPair pairs[MAX_OBJECTS];\n\n    scanf(\"%d %d\", &obstacle_count, &pair_count);\n\n    for (int i = 0; i < obstacle_count; i++) {\n        scanf(\"%lf %lf %lf %lf %lf\", \n              &obstacles[i].start.x, &obstacles[i].start.y,\n              &obstacles[i].end.x, &obstacles[i].end.y,\n              &obstacles[i].energy_cost);\n    }\n\n    for (int i = 0; i < pair_count; i++) {\n        scanf(\"%lf %lf %lf %lf\", \n              &pairs[i].red.x, &pairs[i].red.y,\n              &pairs[i].blue.x, &pairs[i].blue.y);\n    }\n\n    double result = calculate_min_energy(pairs, pair_count, obstacles, obstacle_count);\n    printf(\"%.2lf\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y, z;\n    double r;\n} Obstacle;\n\ntypedef struct {\n    double x, y, z;\n} Point;\n\ndouble dot(Point a, Point b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nPoint subtract(Point a, Point b) {\n    Point result = {a.x - b.x, a.y - b.y, a.z - b.z};\n    return result;\n}\n\ndouble distance(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    double dz = a.z - b.z;\n    return sqrt(dx * dx + dy * dy + dz * dz);\n}\n\ndouble lineSphereIntersection(Point start, Point end, Obstacle sphere) {\n    Point d = subtract(end, start);\n    Point f = subtract(start, (Point){sphere.x, sphere.y, sphere.z});\n    double a = dot(d, d);\n    double b = 2 * dot(f, d);\n    double c = dot(f, f) - sphere.r * sphere.r;\n    double discriminant = b * b - 4 * a * c;\n    \n    if (discriminant < 0) {\n        return -1.0;\n    }\n    \n    discriminant = sqrt(discriminant);\n    double t1 = (-b - discriminant) / (2 * a);\n    double t2 = (-b + discriminant) / (2 * a);\n    \n    if (t1 >= 0 && t1 <= 1) return t1;\n    if (t2 >= 0 && t2 <= 1) return t2;\n    return -1.0;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    Obstacle *obstacles = malloc(N * sizeof(Obstacle));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf %lf\", &obstacles[i].x, &obstacles[i].y, &obstacles[i].z, &obstacles[i].r);\n    }\n    \n    Point *red = malloc(M * sizeof(Point));\n    Point *blue = malloc(M * sizeof(Point));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%lf %lf %lf\", &red[i].x, &red[i].y, &red[i].z);\n    }\n    for (int i = 0; i < M; i++) {\n        scanf(\"%lf %lf %lf\", &blue[i].x, &blue[i].y, &blue[i].z);\n    }\n    \n    double totalMagic = 0.0;\n    \n    for (int i = 0; i < M; i++) {\n        Point start = red[i];\n        Point end = blue[i];\n        double magic = 0.0;\n        \n        for (int j = 0; j < N; j++) {\n            double t = lineSphereIntersection(start, end, obstacles[j]);\n            if (t >= 0.0 && t <= 1.0) {\n                magic += 1.0;\n            }\n        }\n        totalMagic += magic;\n    }\n    \n    printf(\"%.0lf\\n\", totalMagic);\n    \n    free(obstacles);\n    free(red);\n    free(blue);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y, z;\n    Point(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {}\n};\n\nstruct Sphere {\n    Point center;\n    double radius;\n    double energy;\n    Sphere(double x = 0, double y = 0, double z = 0, double r = 0, double e = 0) : center(x, y, z), radius(r), energy(e) {}\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));\n}\n\nbool intersects(const Point& p1, const Point& p2, const Sphere& s) {\n    Point dir = {p2.x - p1.x, p2.y - p1.y, p2.z - p1.z};\n    double len = distance(p1, p2);\n    Point normalized_dir = {dir.x / len, dir.y / len, dir.z / len};\n    \n    Point diff = {p1.x - s.center.x, p1.y - s.center.y, p1.z - s.center.z};\n    double a = normalized_dir.x * normalized_dir.x + normalized_dir.y * normalized_dir.y + normalized_dir.z * normalized_dir.z;\n    double b = 2 * (diff.x * normalized_dir.x + diff.y * normalized_dir.y + diff.z * normalized_dir.z);\n    double c = (diff.x * diff.x + diff.y * diff.y + diff.z * diff.z) - s.radius * s.radius;\n    \n    double discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) return false;\n    \n    double t1 = (-b - sqrt(discriminant)) / (2 * a);\n    double t2 = (-b + sqrt(discriminant)) / (2 * a);\n    \n    if ((t1 >= 0 && t1 <= len) || (t2 >= 0 && t2 <= len)) return true;\n    return false;\n}\n\ndouble computeMinEnergy(const Point& red, const Point& blue, const vector<Sphere>& obstacles) {\n    double total_energy = 0;\n    for (const auto& sphere : obstacles) {\n        if (intersects(red, blue, sphere)) {\n            total_energy += sphere.energy;\n        }\n    }\n    return total_energy;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<Sphere> obstacles(N);\n    for (int i = 0; i < N; ++i) {\n        double x, y, z, r, e;\n        cin >> x >> y >> z >> r >> e;\n        obstacles[i] = Sphere(x, y, z, r, e);\n    }\n    \n    double total_min_energy = 0;\n    for (int i = 0; i < M; ++i) {\n        double rx, ry, rz, bx, by, bz;\n        cin >> rx >> ry >> rz >> bx >> by >> bz;\n        Point red(rx, ry, rz);\n        Point blue(bx, by, bz);\n        total_min_energy += computeMinEnergy(red, blue, obstacles);\n    }\n    \n    cout << total_min_energy << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    double x, y, z;\n    Point(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\nclass Obstacle {\n    Point center;\n    double radius;\n    int energy;\n    Obstacle(double x, double y, double z, double r, int e) {\n        this.center = new Point(x, y, z);\n        this.radius = r;\n        this.energy = e;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        Obstacle[] obstacles = new Obstacle[N];\n        for (int i = 0; i < N; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            double z = sc.nextDouble();\n            double r = sc.nextDouble();\n            int e = sc.nextInt();\n            obstacles[i] = new Obstacle(x, y, z, r, e);\n        }\n        Point[] reds = new Point[M];\n        Point[] blues = new Point[M];\n        for (int i = 0; i < M; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            double z = sc.nextDouble();\n            reds[i] = new Point(x, y, z);\n        }\n        for (int i = 0; i < M; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            double z = sc.nextDouble();\n            blues[i] = new Point(x, y, z);\n        }\n        sc.close();\n\n        int totalEnergy = 0;\n        for (int i = 0; i < M; i++) {\n            Point red = reds[i];\n            Point blue = blues[i];\n            List<Obstacle> intersected = new ArrayList<>();\n            for (Obstacle obs : obstacles) {\n                if (intersects(red, blue, obs)) {\n                    intersected.add(obs);\n                }\n            }\n            Collections.sort(intersected, (a, b) -> a.energy - b.energy);\n            int minEnergy = 0;\n            if (!intersected.isEmpty()) {\n                minEnergy = intersected.get(0).energy;\n            }\n            totalEnergy += minEnergy;\n        }\n        System.out.println(totalEnergy);\n    }\n\n    private static boolean intersects(Point a, Point b, Obstacle obs) {\n        Point center = obs.center;\n        double radius = obs.radius;\n        double dx = b.x - a.x;\n        double dy = b.y - a.y;\n        double dz = b.z - a.z;\n        double l = dx * dx + dy * dy + dz * dz;\n        double t = Math.max(0, Math.min(1, ((center.x - a.x) * dx + (center.y - a.y) * dy + (center.z - a.z) * dz) / l));\n        double closestX = a.x + t * dx;\n        double closestY = a.y + t * dy;\n        double closestZ = a.z + t * dz;\n        double distance = Math.sqrt((closestX - center.x) * (closestX - center.x) + \n                                   (closestY - center.y) * (closestY - center.y) + \n                                   (closestZ - center.z) * (closestZ - center.z));\n        return distance <= radius;\n    }\n}",
    "timestamp": "2025-08-05 21:53:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MageCompetition {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Obstacle {\n        Point start, end;\n        Obstacle(Point start, Point end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    static double dist(Point p1, Point p2) {\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    }\n\n    static boolean lineIntersectsObstacle(Point start, Point end, Obstacle obstacle) {\n        // Line segment intersection calculation\n        int o1 = orientation(start, end, obstacle.start);\n        int o2 = orientation(start, end, obstacle.end);\n        int o3 = orientation(obstacle.start, obstacle.end, start);\n        int o4 = orientation(obstacle.start, obstacle.end, end);\n\n        if (o1 != o2 && o3 != o4) return true;\n        return false;\n    }\n\n    static int orientation(Point p, Point q, Point r) {\n        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) return 0;\n        return (val > 0) ? 1 : 2;\n    }\n\n    static int minimumMagicEnergy(Point red, Point blue, List<Obstacle> obstacles) {\n        int magicEnergy = 0;\n        for (Obstacle obstacle : obstacles) {\n            if (lineIntersectsObstacle(red, blue, obstacle)) {\n                // Energy calculation based on obstacle properties\n                magicEnergy += calculateObstacleEnergyCost(obstacle);\n            }\n        }\n        return magicEnergy;\n    }\n\n    static int calculateObstacleEnergyCost(Obstacle obstacle) {\n        // Complex energy calculation based on obstacle characteristics\n        return (int) (dist(obstacle.start, obstacle.end) * 10);\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Point red = new Point(0, 0);\n        Point blue = new Point(10, 10);\n        List<Obstacle> obstacles = new ArrayList<>();\n        obstacles.add(new Obstacle(new Point(2, 2), new Point(4, 4)));\n        obstacles.add(new Obstacle(new Point(5, 5), new Point(7, 7)));\n\n        int energyRequired = minimumMagicEnergy(red, blue, obstacles);\n        System.out.println(\"Minimum Magic Energy Required: \" + energyRequired);\n    }\n}",
    "timestamp": "2025-08-05 21:53:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\nstruct Obstacle {\n    Point center;\n    int radius;\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nbool lineIntersectsCircle(const Point& start, const Point& end, const Obstacle& obstacle) {\n    double A = end.y - start.y;\n    double B = start.x - end.x;\n    double C = A * start.x + B * start.y;\n    \n    double dist = abs(A * obstacle.center.x + B * obstacle.center.y + C) / \n                  sqrt(A * A + B * B);\n    \n    return dist <= obstacle.radius;\n}\n\nint minimumMagicEnergy(int n, vector<Point>& redObjects, vector<Point>& blueObjects, \n                       vector<Obstacle>& obstacles) {\n    int minEnergy = numeric_limits<int>::max();\n    \n    for (int i = 0; i < redObjects.size(); ++i) {\n        for (int j = 0; j < blueObjects.size(); ++j) {\n            int currentEnergy = 0;\n            \n            for (const auto& obstacle : obstacles) {\n                if (lineIntersectsCircle(redObjects[i], blueObjects[j], obstacle)) {\n                    currentEnergy += obstacle.radius;\n                }\n            }\n            \n            minEnergy = min(minEnergy, currentEnergy);\n        }\n    }\n    \n    return minEnergy;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Point> redObjects(n);\n    vector<Point> blueObjects(n);\n    vector<Obstacle> obstacles(n);\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> redObjects[i].x >> redObjects[i].y;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> blueObjects[i].x >> blueObjects[i].y;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        cin >> obstacles[i].center.x >> obstacles[i].center.y >> obstacles[i].radius;\n    }\n    \n    int result = minimumMagicEnergy(n, redObjects, blueObjects, obstacles);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\nclass Obstacle:\n    def __init__(self, x, y, radius, energy_required):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.energy_required = energy_required\n\ndef dist(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\ndef min_magic_energy(obstacles, red_objects, blue_objects):\n    min_energy = 0\n    for red, blue in zip(red_objects, blue_objects):\n        rx, ry = red\n        bx, by = blue\n        line_dx = bx - rx\n        line_dy = by - ry\n        line_length = dist(rx, ry, bx, by)\n        closest_obstacles = []\n        \n        for obstacle in obstacles:\n            ox, oy, radius, energy = obstacle.x, obstacle.y, obstacle.radius, obstacle.energy_required\n            # Vector from red to obstacle center\n            oc_dx = ox - rx\n            oc_dy = oy - ry\n            # Projection vector\n            projection_length = (oc_dx * line_dx + oc_dy * line_dy) / line_length\n            px = rx + line_dx * projection_length / line_length\n            py = ry + line_dy * projection_length / line_length\n            if dist(ox, oy, px, py) <= radius:\n                heapq.heappush(closest_obstacles, (energy, obstacle))\n        \n        # Use magic energy for the closest obstacle\n        if closest_obstacles:\n            min_energy += heapq.heappop(closest_obstacles)[0]\n    \n    return min_energy\n\n# Example usage:\nobstacles = [\n    Obstacle(3, 4, 1, 5),\n    Obstacle(7, 8, 2, 10)\n]\n\nred_objects = [(1, 1), (5, 5)]\nblue_objects = [(9, 9), (6, 6)]\n\nprint(min_magic_energy(obstacles, red_objects, blue_objects))",
    "timestamp": "2025-08-13 07:50:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass MagicBulletSolution {\n\n    static class Position {\n        int x, y;\n        \n        Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Obstacle {\n        Position start, end;\n        int energyCost;\n\n        Obstacle(Position start, Position end, int energyCost) {\n            this.start = start;\n            this.end = end;\n            this.energyCost = energyCost;\n        }\n    }\n\n    public static int minimumMagicEnergy(List<Obstacle> obstacles, List<Position> redObjects, List<Position> blueObjects) {\n        int n = redObjects.size();\n        int[][] energyMatrix = new int[n][n];\n        final int INF = Integer.MAX_VALUE;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                energyMatrix[i][j] = calculateEnergy(redObjects.get(i), blueObjects.get(j), obstacles);\n            }\n        }\n\n        return findMinimumEnergyPairing(energyMatrix);\n    }\n\n    private static int calculateEnergy(Position red, Position blue, List<Obstacle> obstacles) {\n        int magicEnergy = 0;\n\n        for (Obstacle obstacle : obstacles) {\n            if (doesIntersect(red, blue, obstacle.start, obstacle.end)) {\n                magicEnergy += obstacle.energyCost;\n            }\n        }\n\n        return magicEnergy;\n    }\n\n    private static boolean doesIntersect(Position lineStart, Position lineEnd, Position segStart, Position segEnd) {\n        // Depending on geometry library or algorithm choice, implement line-segment intersection check.\n        // A simplified cross-product approach or other geometrical calculations can be used here.\n\n        return (\n            Math.min(lineStart.x, lineEnd.x) <= Math.max(segStart.x, segEnd.x) &&\n            Math.min(segStart.x, segEnd.x) <= Math.max(lineStart.x, lineEnd.x) &&\n            Math.min(lineStart.y, lineEnd.y) <= Math.max(segStart.y, segEnd.y) &&\n            Math.min(segStart.y, segEnd.y) <= Math.max(lineStart.y, lineEnd.y)\n        );\n    }\n\n    private static int findMinimumEnergyPairing(int[][] energyMatrix) {\n        int n = energyMatrix.length;\n        int[] dp = new int[1 << n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            int k = Integer.bitCount(mask);\n            if (k >= n) continue;\n            for (int j = 0; j < n; j++) {\n                if ((mask & (1 << j)) == 0) {\n                    dp[mask | (1 << j)] = Math.min(dp[mask | (1 << j)], dp[mask] + energyMatrix[k][j]);\n                }\n            }\n        }\n\n        return dp[(1 << n) - 1];\n    }\n\n    public static void main(String[] args) {\n        List<Obstacle> obstacles = Arrays.asList(\n            new Obstacle(new Position(1, 2), new Position(3, 4), 5),\n            new Obstacle(new Position(2, 3), new Position(5, 6), 2)\n        );\n\n        List<Position> redObjects = Arrays.asList(\n            new Position(0, 0),\n            new Position(1, 1)\n        );\n\n        List<Position> blueObjects = Arrays.asList(\n            new Position(4, 4),\n            new Position(6, 6)\n        );\n\n        System.out.println(minimumMagicEnergy(obstacles, redObjects, blueObjects));\n    }\n}",
    "timestamp": "2025-08-13 07:51:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 1000000000\n#define N 100\n\ntypedef struct {\n    int x, y, radius, energy;\n} Obstacle;\n\nint n, m;\nObstacle obstacles[N];\nint red[N][2], blue[N][2];\n\nint calculate_distance_squared(int x1, int y1, int x2, int y2) {\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n}\n\nint is_inside_obstacle(int x1, int y1, int x2, int y2, Obstacle *obstacle) {\n    int a = x2 - x1, b = y2 - y1;\n    int cx = 2 * (x1 - obstacle->x) * a;\n    int cy = 2 * (y1 - obstacle->y) * b;\n    int c = a * a + b * b;\n    \n    int det = cx * cx + cy * cy - 4 * (obstacle->radius * obstacle->radius * c - (a * (y1 - obstacle->y) - b * (x1 - obstacle->x)) * (a * (y1 - obstacle->y) - b * (x1 - obstacle->x)));\n    return det >= 0;\n}\n\nint calculate_magic_energy(int x1, int y1, int x2, int y2) {\n    int magic_energy = 0;\n    for (int i = 0; i < n; i++) {\n        if (is_inside_obstacle(x1, y1, x2, y2, &obstacles[i])) {\n            magic_energy += obstacles[i].energy;\n        }\n    }\n    return magic_energy;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d%d%d%d\", &obstacles[i].x, &obstacles[i].y, &obstacles[i].radius, &obstacles[i].energy);\n    }\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d%d%d%d\", &red[i][0], &red[i][1], &blue[i][0], &blue[i][1]);\n    }\n\n    int total_magic_energy = 0;\n    for (int i = 0; i < m; i++) {\n        int magic_energy = calculate_magic_energy(red[i][0], red[i][1], blue[i][0], blue[i][1]);\n        total_magic_energy += magic_energy;\n    }\n    \n    printf(\"%d\\n\", total_magic_energy);\n    return 0;\n}",
    "timestamp": "2025-08-13 07:51:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef calculate_min_magic_energy(obstacles, red_objects, blue_objects):\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    \n    def line_intersection(p1, p2, obs):\n        x1, y1 = p1\n        x2, y2 = p2\n        cx, cy, r = obs\n        \n        # Line segment vector\n        dx = x2 - x1\n        dy = y2 - y1\n        \n        # Vector from line start to circle center\n        cx_line = cx - x1\n        cy_line = cy - y1\n        \n        # Line segment length\n        line_length = math.sqrt(dx**2 + dy**2)\n        \n        # Projection of circle center onto line\n        t = (cx_line * dx + cy_line * dy) / (line_length**2)\n        \n        # Closest point on line to circle center\n        closest_x = x1 + t * dx\n        closest_y = y1 + t * dy\n        \n        # Distance between closest point and circle center\n        dist = distance((closest_x, closest_y), (cx, cy))\n        \n        return dist <= r\n    \n    min_magic_energy = float('inf')\n    \n    for red_pos in red_objects:\n        for blue_pos in blue_objects:\n            # Calculate direct distance\n            total_energy = 0\n            \n            # Check intersections with obstacles\n            for obs in obstacles:\n                if line_intersection(red_pos, blue_pos, obs):\n                    # Add magic energy needed to pass through this obstacle\n                    total_energy += obs[2]  # obstacle radius as magic energy\n            \n            # Update minimum magic energy\n            min_magic_energy = min(min_magic_energy, total_energy)\n    \n    return min_magic_energy if min_magic_energy != float('inf') else -1\n\n# Example usage\nobstacles = [(1, 2, 3), (4, 5, 2)]  # (x, y, radius)\nred_objects = [(0, 0), (3, 3)]\nblue_objects = [(6, 6), (7, 7)]\n\nresult = calculate_min_magic_energy(obstacles, red_objects, blue_objects)\nprint(result)",
    "timestamp": "2025-08-13 07:51:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    obstacles = []\n    for _ in range(N):\n        x, y, z, r = map(float, input[ptr:ptr+4])\n        ptr +=4\n        obstacles.append((x, y, z, r))\n    \n    M = int(input[ptr])\n    ptr +=1\n    total_energy = 0.0\n    \n    for _ in range(M):\n        rx, ry, rz = map(float, input[ptr:ptr+3])\n        ptr +=3\n        bx, by, bz = map(float, input[ptr:ptr+3])\n        ptr +=3\n        \n        dx = bx - rx\n        dy = by - ry\n        dz = bz - rz\n        length = math.sqrt(dx*dx + dy*dy + dz*dz)\n        if length == 0:\n            continue\n        \n        ux = dx / length\n        uy = dy / length\n        uz = dz / length\n        \n        energy = 0.0\n        \n        for (ox, oy, oz, r) in obstacles:\n            # Vector from obstacle center to red point\n            vx = rx - ox\n            vy = ry - oy\n            vz = rz - oz\n            \n            # Dot product of v and u\n            dot = vx * ux + vy * uy + vz * uz\n            \n            # Closest point on the line to the obstacle center\n            closest_x = rx - ux * dot\n            closest_y = ry - uy * dot\n            closest_z = rz - uz * dot\n            \n            # Distance from obstacle center to the line\n            dist_sq = (ox - closest_x)**2 + (oy - closest_y)**2 + (oz - closest_z)**2\n            \n            if dist_sq > r*r:\n                continue  # No intersection\n            \n            # Distance along the line where intersection starts and ends\n            delta = math.sqrt(r*r - dist_sq)\n            a = dot - delta\n            b = dot + delta\n            \n            # Check if the segment [0, length] intersects with [a, b]\n            start = max(0.0, a)\n            end = min(length, b)\n            \n            if start < end:\n                energy += (end - start)\n        \n        total_energy += energy\n    \n    print(\"{0:.3f}\".format(total_energy))\n\nsolve()",
    "timestamp": "2025-08-13 07:51:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nstruct Point {\n    int x, y;\n};\n\nstruct Obstacle {\n    Point center;\n    int energyRequired;\n    int radius;\n};\n\ndouble distance(const Point &a, const Point &b) {\n    return std::sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool touchesObstacle(const Point &a, const Point &b, const Obstacle &ob) {\n    double dist = distance(a, ob.center) + distance(ob.center, b);\n    double directDistance = distance(a, b);\n    return dist <= directDistance + ob.radius; \n}\n\nint calculateEnergy(const Point &red, const Point &blue, const std::vector<Obstacle> &obstacles) {\n    int magicEnergy = 0;\n    for (const auto &ob : obstacles) {\n        if (touchesObstacle(red, blue, ob)) {\n            magicEnergy += ob.energyRequired;\n        }\n    }\n    return magicEnergy;\n}\n\nint main() {\n    int numObstacles;\n    std::cin >> numObstacles;\n    \n    std::vector<Obstacle> obstacles(numObstacles);\n    for (int i = 0; i < numObstacles; ++i) {\n        std::cin >> obstacles[i].center.x >> obstacles[i].center.y >> obstacles[i].radius >> obstacles[i].energyRequired;\n    }\n    \n    int numPairs;\n    std::cin >> numPairs;\n    \n    std::vector<Point> redObjects(numPairs), blueObjects(numPairs);\n    for (int i = 0; i < numPairs; ++i) {\n        std::cin >> redObjects[i].x >> redObjects[i].y;\n        std::cin >> blueObjects[i].x >> blueObjects[i].y;\n    }\n    \n    int totalMinimumEnergy = 0;\n    for (int i = 0; i < numPairs; ++i) {\n        totalMinimumEnergy += calculateEnergy(redObjects[i], blueObjects[i], obstacles);\n    }\n    \n    std::cout << totalMinimumEnergy << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:41:08"
  }
]