[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char **elements;\n    int count;\n} ElementList;\n\nvoid countConcatenatedStrings(char *text, ElementList *elements, int *countMap) {\n    int textLen = strlen(text);\n    int maxElementLen = 0;\n    for (int i = 0; i < elements->count; i++) {\n        int len = strlen(elements->elements[i]);\n        if (len > maxElementLen) {\n            maxElementLen = len;\n        }\n    }\n\n    for (int i = 0; i < elements->count; i++) {\n        for (int j = 0; j < elements->count; j++) {\n            if (i == j) continue;\n            char *concat = malloc(strlen(elements->elements[i]) + strlen(elements->elements[j]) + 1);\n            strcpy(concat, elements->elements[i]);\n            strcat(concat, elements->elements[j]);\n            int concatLen = strlen(concat);\n\n            if (concatLen > textLen) {\n                free(concat);\n                continue;\n            }\n\n            for (int k = 0; k <= textLen - concatLen; k++) {\n                if (strncmp(text + k, concat, concatLen) == 0) {\n                    countMap[i * elements->count + j]++;\n                }\n            }\n            free(concat);\n        }\n    }\n}\n\nint main() {\n    char text[1000];\n    scanf(\"%999s\", text);\n\n    int n;\n    scanf(\"%d\", &n);\n\n    ElementList elements;\n    elements.elements = malloc(n * sizeof(char *));\n    elements.count = n;\n\n    for (int i = 0; i < n; i++) {\n        elements.elements[i] = malloc(100);\n        scanf(\"%99s\", elements.elements[i]);\n    }\n\n    int *countMap = calloc(n * n, sizeof(int));\n    countConcatenatedStrings(text, &elements, countMap);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            printf(\"%s%s: %d\\n\", elements.elements[i], elements.elements[j], countMap[i * n + j]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        free(elements.elements[i]);\n    }\n    free(elements.elements);\n    free(countMap);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:48:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvoid generateCombinations(const vector<string>& elements, unordered_set<string>& combinations, string current, vector<bool>& used) {\n    if (!current.empty()) {\n        combinations.insert(current);\n    }\n    for (int i = 0; i < elements.size(); ++i) {\n        if (!used[i]) {\n            used[i] = true;\n            generateCombinations(elements, combinations, current + elements[i], used);\n            used[i] = false;\n        }\n    }\n}\n\nunordered_set<string> getAllCombinations(const vector<string>& elements) {\n    unordered_set<string> combinations;\n    vector<bool> used(elements.size(), false);\n    generateCombinations(elements, combinations, \"\", used);\n    return combinations;\n}\n\nint countOccurrences(const string& text, const unordered_set<string>& patterns) {\n    int count = 0;\n    for (const auto& pattern : patterns) {\n        if (pattern.empty()) continue;\n        size_t pos = 0;\n        while ((pos = text.find(pattern, pos)) != string::npos) {\n            ++count;\n            ++pos;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> elements(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> elements[i];\n    }\n    string text;\n    cin >> text;\n\n    unordered_set<string> combinations = getAllCombinations(elements);\n    int result = countOccurrences(text, combinations);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConcatenatedStringCounter {\n    public static Map<String, Integer> countConcatenatedOccurrences(String[] elements, String text) {\n        Map<String, Integer> countMap = new HashMap<>();\n        Set<String> elementSet = new HashSet<>(Arrays.asList(elements));\n        Set<String> concatenatedSet = new HashSet<>();\n        \n        generateAllConcatenations(elements, \"\", concatenatedSet, new boolean[elements.length]);\n        \n        for (String concat : concatenatedSet) {\n            int count = countOccurrences(text, concat);\n            if (count > 0) {\n                countMap.put(concat, count);\n            }\n        }\n        \n        return countMap;\n    }\n    \n    private static void generateAllConcatenations(String[] elements, String current, Set<String> result, boolean[] used) {\n        if (current.length() > 0) {\n            result.add(current);\n        }\n        \n        for (int i = 0; i < elements.length; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                generateAllConcatenations(elements, current + elements[i], result, used);\n                used[i] = false;\n            }\n        }\n    }\n    \n    private static int countOccurrences(String text, String pattern) {\n        int count = 0;\n        int index = 0;\n        while (true) {\n            index = text.indexOf(pattern, index);\n            if (index == -1) {\n                break;\n            }\n            count++;\n            index += 1;\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 20:49:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public Map<String, Integer> countConcatenatedStrings(String[] elements, String text) {\n        Map<String, Integer> resultMap = new HashMap<>();\n        int n = elements.length;\n        \n        // Generate all possible permutations of elements\n        List<List<String>> permutations = generatePermutations(elements);\n        \n        // For each permutation, count its occurrences in the text\n        for (List<String> perm : permutations) {\n            String concatenated = String.join(\"\", perm);\n            int count = countOccurrences(text, concatenated);\n            \n            if (count > 0) {\n                resultMap.put(concatenated, count);\n            }\n        }\n        \n        return resultMap;\n    }\n    \n    private List<List<String>> generatePermutations(String[] elements) {\n        List<List<String>> result = new ArrayList<>();\n        backtrack(elements, new ArrayList<>(), new boolean[elements.length], result);\n        return result;\n    }\n    \n    private void backtrack(String[] elements, List<String> current, \n                           boolean[] used, List<List<String>> result) {\n        if (current.size() == elements.length) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int i = 0; i < elements.length; i++) {\n            if (used[i]) continue;\n            \n            current.add(elements[i]);\n            used[i] = true;\n            \n            backtrack(elements, current, used, result);\n            \n            current.remove(current.size() - 1);\n            used[i] = false;\n        }\n    }\n    \n    private int countOccurrences(String text, String pattern) {\n        int count = 0;\n        int index = 0;\n        \n        while ((index = text.indexOf(pattern, index)) != -1) {\n            count++;\n            index++;\n        }\n        \n        return count;\n    }\n}",
    "timestamp": "2025-08-05 20:49:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ELEMENTS 100\n#define MAX_TEXT_LENGTH 10000\n#define MAX_CONCAT_LENGTH 1000\n\nint generateConcatenations(char** elements, int numElements, char** concatenations) {\n    int totalConcatenations = 0;\n    int used[MAX_ELEMENTS] = {0};\n\n    void backtrack(char* current, int depth) {\n        if (depth == numElements) {\n            strcpy(concatenations[totalConcatenations++], current);\n            return;\n        }\n\n        for (int i = 0; i < numElements; i++) {\n            if (!used[i]) {\n                used[i] = 1;\n                strcat(current, elements[i]);\n                backtrack(current, depth + 1);\n                current[strlen(current) - strlen(elements[i])] = '\\0';\n                used[i] = 0;\n            }\n        }\n    }\n\n    char initial[MAX_CONCAT_LENGTH] = \"\";\n    backtrack(initial, 0);\n\n    return totalConcatenations;\n}\n\nint countOccurrences(char* text, char* pattern) {\n    int count = 0;\n    char* pos = text;\n    while ((pos = strstr(pos, pattern)) != NULL) {\n        count++;\n        pos++;\n    }\n    return count;\n}\n\nint main() {\n    int numElements;\n    char* elements[MAX_ELEMENTS];\n    char text[MAX_TEXT_LENGTH];\n    char* concatenations[MAX_ELEMENTS * MAX_ELEMENTS];\n\n    // Input elements\n    scanf(\"%d\", &numElements);\n    for (int i = 0; i < numElements; i++) {\n        elements[i] = malloc(MAX_CONCAT_LENGTH * sizeof(char));\n        scanf(\"%s\", elements[i]);\n    }\n\n    // Input text\n    scanf(\"%s\", text);\n\n    // Allocate memory for concatenations\n    for (int i = 0; i < MAX_ELEMENTS * MAX_ELEMENTS; i++) {\n        concatenations[i] = malloc(MAX_CONCAT_LENGTH * sizeof(char));\n    }\n\n    // Generate concatenations\n    int totalConcatenations = generateConcatenations(elements, numElements, concatenations);\n\n    // Count occurrences\n    int totalOccurrences = 0;\n    for (int i = 0; i < totalConcatenations; i++) {\n        totalOccurrences += countOccurrences(text, concatenations[i]);\n    }\n\n    printf(\"%d\\n\", totalOccurrences);\n\n    // Free memory\n    for (int i = 0; i < numElements; i++) {\n        free(elements[i]);\n    }\n    for (int i = 0; i < MAX_ELEMENTS * MAX_ELEMENTS; i++) {\n        free(concatenations[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nclass StringConcatenationCounter {\nprivate:\n    std::vector<std::string> elements;\n    std::unordered_map<std::string, int> occurrenceMap;\n\n    void generateConcatenations(std::vector<std::string>& current, int depth) {\n        if (depth == elements.size()) {\n            std::string concatenated;\n            for (const auto& str : current) {\n                concatenated += str;\n            }\n            occurrenceMap[concatenated]++;\n            return;\n        }\n\n        for (int i = 0; i < elements.size(); i++) {\n            if (std::find(current.begin(), current.end(), elements[i]) == current.end()) {\n                current.push_back(elements[i]);\n                generateConcatenations(current, depth + 1);\n                current.pop_back();\n            }\n        }\n    }\n\npublic:\n    StringConcatenationCounter(const std::vector<std::string>& input) : elements(input) {}\n\n    int countOccurrences(const std::string& text) {\n        occurrenceMap.clear();\n        std::vector<std::string> current;\n        generateConcatenations(current, 0);\n\n        int totalOccurrences = 0;\n        for (const auto& pair : occurrenceMap) {\n            size_t pos = 0;\n            int count = 0;\n            while ((pos = text.find(pair.first, pos)) != std::string::npos) {\n                count++;\n                pos++;\n            }\n            totalOccurrences += count * pair.second;\n        }\n\n        return totalOccurrences;\n    }\n};\n\nint main() {\n    std::vector<std::string> elements = {\"ab\", \"ba\"};\n    std::string text = \"abbaab\";\n\n    StringConcatenationCounter counter(elements);\n    int result = counter.countOccurrences(text);\n    std::cout << \"Total occurrences: \" << result << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\nimport re\nfrom collections import Counter\n\ndef count_concatenated_occurrences(element_strings, text):\n    # Generate all permutations of the element strings\n    all_permutations = set(permutations(element_strings))\n    \n    # Generate all possible concatenated strings\n    concatenated_strings = set(''.join(p) for p in all_permutations)\n    \n    # Function to find all overlapping occurrences of a substring\n    def find_all_occurrences(substring, text):\n        return [m.start() for m in re.finditer(f'(?={re.escape(substring)})', text)]\n    \n    # Count occurrences for each concatenated string\n    concatenated_occurrences = Counter()\n    for conc_str in concatenated_strings:\n        positions = find_all_occurrences(conc_str, text)\n        concatenated_occurrences[conc_str] = len(positions)\n    \n    return concatenated_occurrences\n\n# Example usage:\nelement_strings = ['ab', 'cd']\ntext = 'abcdabc'\nresult = count_concatenated_occurrences(element_strings, text)\nprint(result)  # Example output for understanding",
    "timestamp": "2025-08-13 03:36:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ConcatenatedStringOccurrences {\n\n    public static int countOccurrences(String[] elements, String text) {\n        int n = elements.length;\n        Set<String> concatenatedStrings = new HashSet<>();\n        permute(elements, 0, n - 1, concatenatedStrings);\n\n        int count = 0;\n        for (String str : concatenatedStrings) {\n            int fromIndex = 0;\n            while ((fromIndex = text.indexOf(str, fromIndex)) != -1) {\n                count++;\n                fromIndex++;\n            }\n        }\n        return count;\n    }\n\n    private static void permute(String[] elements, int l, int r, Set<String> concatenatedStrings) {\n        if (l == r) {\n            concatenatedStrings.add(String.join(\"\", elements));\n        } else {\n            for (int i = l; i <= r; i++) {\n                swap(elements, l, i);\n                permute(elements, l + 1, r, concatenatedStrings);\n                swap(elements, l, i); // backtrack\n            }\n        }\n    }\n\n    private static void swap(String[] elements, int i, int j) {\n        String temp = elements[i];\n        elements[i] = elements[j];\n        elements[j] = temp;\n    }\n\n    public static void main(String[] args) {\n        String[] elements = {\"a\", \"b\", \"a\"};\n        String text = \"abaa\";\n        int result = countOccurrences(elements, text);\n        System.out.println(\"Total occurrences: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 03:36:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint countOccurrences(char *text, char **elements, int numElements) {\n    int count = 0;\n    int textLength = strlen(text);\n    int *used = (int *)calloc(numElements, sizeof(int));\n\n    void findConcatenations(char *current, int *used, int depth) {\n        if (depth == numElements) {\n            int currentLength = strlen(current);\n            for (int i = 0; i <= textLength - currentLength; i++) {\n                if (strncmp(text + i, current, currentLength) == 0) {\n                    count++;\n                }\n            }\n        } else {\n            for (int i = 0; i < numElements; i++) {\n                if (!used[i]) {\n                    used[i] = 1;\n                    char *next = (char *)malloc(strlen(current) + strlen(elements[i]) + 1);\n                    strcpy(next, current);\n                    strcat(next, elements[i]);\n                    findConcatenations(next, used, depth + 1);\n                    free(next);\n                    used[i] = 0;\n                }\n            }\n        }\n    }\n\n    findConcatenations(\"\", used, 0);\n    free(used);\n    return count;\n}\n\nint main() {\n    char *text = \"abcde\";\n    char *elements[] = {\"a\", \"b\", \"c\", \"d\"};\n    int numElements = sizeof(elements) / sizeof(elements[0]);\n\n    printf(\"Total occurrences: %d\\n\", countOccurrences(text, elements, numElements));\n    return 0;\n}",
    "timestamp": "2025-08-13 03:36:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef count_concatenated_strings(elements, text):\n    def generate_all_concatenations(elements):\n        all_concatenations = set()\n        for perm in permutations(elements):\n            all_concatenations.add(''.join(perm))\n        return all_concatenations\n\n    concatenations = generate_all_concatenations(elements)\n    \n    count = 0\n    for concat in concatenations:\n        count += text.count(concat)\n    \n    return count",
    "timestamp": "2025-08-13 03:37:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef count_concatenated_occurrences(elements, text):\n    unique_concatenations = set()\n    for r in range(1, len(elements) + 1):\n        for perm in permutations(elements, r):\n            concat = ''.join(perm)\n            unique_concatenations.add(concat)\n    \n    count_dict = {}\n    for concat in unique_concatenations:\n        count = 0\n        start = 0\n        concat_len = len(concat)\n        text_len = len(text)\n        while start <= text_len - concat_len:\n            found_pos = text.find(concat, start)\n            if found_pos == -1:\n                break\n            count += 1\n            start = found_pos + 1\n        if count > 0:\n            count_dict[concat] = count\n    \n    return count_dict",
    "timestamp": "2025-08-13 03:37:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n\nvoid countConcatenatedStrings(const std::vector<std::string>& elements, const std::string& text) {\n    std::unordered_map<std::string, int> countMap;\n    std::unordered_set<std::string> visited;\n    int n = elements.size();\n\n    // Function to generate all permutations and count occurrences in the text\n    std::function<void(std::vector<std::string>&, int)> permutateAndCount = [&](std::vector<std::string>& arr, int index) {\n        if (index == n) {\n            std::string concatStr;\n            for (const auto& elem : arr) {\n                concatStr += elem;\n            }\n            if (!visited.count(concatStr)) {\n                visited.insert(concatStr);\n                size_t pos = 0;\n                while ((pos = text.find(concatStr, pos)) != std::string::npos) {\n                    ++countMap[concatStr];\n                    ++pos;\n                }\n            }\n            return;\n        }\n        for (int i = index; i < n; ++i) {\n            std::swap(arr[index], arr[i]);\n            permutateAndCount(arr, index + 1);\n            std::swap(arr[index], arr[i]);\n        }\n    };\n\n    std::vector<std::string> elementCopy = elements;\n    permutateAndCount(elementCopy, 0);\n\n    for (const auto& pair : countMap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n}\n\nint main() {\n    std::vector<std::string> elements = {\"el1\", \"el2\", \"el3\"};\n    std::string text = \"el1el2el3el2el1el3el3el2el1\";\n    countConcatenatedStrings(elements, text);\n    return 0;\n}",
    "timestamp": "2025-08-13 11:13:47"
  }
]