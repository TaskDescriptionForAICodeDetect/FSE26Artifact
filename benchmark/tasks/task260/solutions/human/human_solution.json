[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool pos[12][5010] = {};\nbool dp[5010][1<<12];\nbool dn[5010][1<<12];\nstring p[12];\nstring s;\n\nint n,m;\nbool dfs(int x,int bit){\n\tif( bit == 0 ) return 1;\n\tif( dn[x][bit] ) return dp[x][bit];\n\tbool ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit >> i & 1) && pos[i][x] ){\n\t\t\tans |= dfs(x+p[i].size(),bit^(1<<i));\n\t\t}\n\t}\n\tdn[x][bit] = true;\n\treturn dp[x][bit] = ans;\n}\n\nint main(){\n\twhile( cin >> n >> m && n ){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(dn,0,sizeof(dn));\n\t\tmemset(pos,0,sizeof(pos));\n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) cin >> p[i];\n\t\ts = \"\";\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring c; cin >> c;\n\t\t\ts += c;\n\t\t}\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tfor(int i = 0 ; i + p[j].size() <= s.size() ; i++){\n\t\t\t\tint f = 1;\n\t\t\t\tfor(int k = 0 ; k < p[j].size() ; k++)\n\t\t\t\t\tif( p[j][k] != s[i+k] ){ f = 0; break; }\n\t\t\t\tif(f) pos[j][i] = 1;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( dfs(i,(1<<n)-1) ){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int LLNF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct RollingHash{\n\tstring str;\n\tlong long int base,mod;\n\tvector<long long int> hash,pow; //hash[i]:=[0,i)のハッシュ\n\t\n\tRollingHash(string str,long long int base,long long int mod):str(str),base(base),mod(mod){\n\t\tint size=str.size();\n\t\thash=vector<long long int>(size+1);\n\t\tpow=vector<long long int>(size+1);\n\n\t\thash[0]=0;\n\t\tpow[0]=1;\n\t\tfor(int i=1; i<size+1; ++i){\n\t\t\tpow[i]=pow[i-1]*base%mod;\n\t\t\thash[i]=(hash[i-1]*base+str[i-1])%mod;\n\t\t}\n\t}\n\n\tinline long long int Hash(int l,int r){ //[l,r)\n\t\treturn (hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\n\t}\n};\n\ninline long long Hash(string str,long long int base,long long int mod){\n\tlong long int res=0;\n\tfor(int i=0; i<str.size(); ++i){\n\t\tres=(res*base+str[i])%mod;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint n,m;\n\t\tstring e[12],t;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\trep(i,0,n) cin >> e[i];\n\t\trep(i,0,m){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tt+=tmp;\n\t\t}\n\t\n\t\tconst int base=993,mod=15000017;\n\t\tRollingHash t_hash(t,base,mod);\n\t\tstatic int count[mod];\n\t\tfill_n((int*)count,mod,0);\n\t\trep(i,1,t.size()+1) for(int j=0; j+i<=t.size(); ++j) ++count[t_hash.Hash(j,j+i)];\n\t\t\n\t\tint ans=0;\n\t\tstatic bool done[mod];\n\t\tfill_n((int*)done,mod,0);\n\t\tvector<int> perm(n);\n\t\trep(i,0,n) perm[i]=i;\n\t\tdo{\n\t\t\tstring str; \n\t\t\trep(i,0,n) str+=e[perm[i]];\n\t\t\tll x=Hash(str,base,mod);\n\t\t\tif(done[x]) continue;\n\t\t\tdone[x]=true;\n\t\t\tans+=count[x];\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 1000000007;\null p[6000], thash[6000];\null shash[13];\n\nint n,m;\nint len;\nchar t[6000];\nchar ss[13][6000];\nint sslen[13];\n\nint solve(){\n    rep(i,n){\n        ull x = 0;\n        for(int j=0;ss[i][j];j++){\n            x = x*B + ss[i][j];\n        }\n        shash[i] = x;\n    }\n    p[0] = 1;\n    thash[0] = 0;\n    rep(i,len){\n        p[i+1] = p[i]*B;\n        thash[i+1] = thash[i]*B + t[i];\n    }\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+sslen[i] > len) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+sslen[i]] - thash[pos] * p[sslen[i]];\n                // if(h1 != h2) continue;\n                dp[pos+sslen[i]][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    while(scanf(\"%d%d\",&n,&m), n){\n        len = 0;\n        rep(i,n){\n            scanf(\"%s\",ss[i]);\n            sslen[i] = strlen(ss[i]);\n        }\n        rep(i,m){\n            static char buf[6000];\n            scanf(\"%s\",buf);\n            int l = strlen(buf);\n            rep(i,l) t[i+len] = buf[i];\n            len += l;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define N 10010\ntypedef long long ll;\nll p[N],q[N];\nclass RollingHash2{\nprivate:\n  ll aa[N];\n  ll bb[N];\n  ll P,Q;\npublic:\n  RollingHash2(){}\n  RollingHash2(string &s,ll _P,ll _Q){\n    int n=s.size();\n    aa[0]=bb[0]=0;\n    P=_P;\n    Q=_Q;\n    // hash値を計算\n    for(int i=1;i<=n;i++)aa[i]=aa[i-1]*P+s[i-1];\n    for(int i=1;i<=n;i++)bb[i]=bb[i-1]*Q+s[i-1];\n  }\n  pair<ll,ll> getHash(int x,int y){\n    return make_pair(aa[y+1]-aa[x]*p[y-x+1],\n\t\t     bb[y+1]-bb[x]*q[y-x+1]);\n  }\n};\nRollingHash2 fHash;\n\n// 格文字列のハッシュ値\npair<ll,ll> hashVal[12];\nll dp[1<<12][12];\nstring strs[12];\nstring fullTxt;\nint n,m;\nll dfs(int pos,int mask,int cur){\n  if(dp[mask][cur]>=0)return dp[mask][cur];\n  else if(mask==(1<<n)-1)return 1;\n  ll res=0;\n  for(int i=0;i<n;i++){\n    if((mask>>i)&1)continue;\n    // ハッシュ値が一致する場合\n    if(fHash.getHash(pos,pos+strs[i].size()-1)\n       ==hashVal[i]){\n      res+=dfs(pos+strs[i].size(),mask|(1<<i),i);\n    }\n  }\n  return dp[mask][cur]=res;\n}\n\nll fact[20];\nint main(){\n  const ll P=1000000007;\n  const ll Q=4300003200017LL;\n  fact[0]=1;\n  for(int i=1;i<20;i++)fact[i]=fact[i-1]*i;\n  // P**iを計算\n  p[0]=1;\n  for(int i=1;i<=10000;i++)p[i]=p[i-1]*P;\n  q[0]=1;\n  for(int i=1;i<=10000;i++)q[i]=q[i-1]*Q;\n  while(cin>>n>>m&&(n|m)){\n    fullTxt=\"\";\n    int sz=0;\n    map<string,int> scnt;\n    for(int i=0;i<n;i++){\n      cin>>strs[i];\n      scnt[strs[i]]++;\n      sz+=strs[i].size();\n      // ハッシュ値を計算しておく\n      RollingHash2 rh(strs[i],P,Q);\n      hashVal[i]=rh.getHash(0,strs[i].size()-1);\n    }\n    ll divNum=1;\n    for(map<string,int>::iterator it=scnt.begin();\n\tit!=scnt.end();it++){\n      divNum*=fact[it->second];\n    }\n    for(int i=0;i<m;i++){\n      string tmp;cin>>tmp;\n      fullTxt+=tmp;\n    }\n    // 計算済みの結果を登録しておく\n    map<pair<ll,ll>,ll> mem;\n    fHash=RollingHash2(fullTxt,P,Q);\n    ll res=0;\n    for(int i=0;i+sz<=fullTxt.size();i++){\n      pair<ll,ll> hv=fHash.getHash(i,i+sz-1);\n      // 計算済みであれば\n      if(mem.find(hv)!=mem.end())res+=mem[hv];\n      // まだ計算済みでない\n      else{\n\tmemset(dp,-1,sizeof(dp));\n\tll tmp=0;\n\tfor(int j=0;j<n;j++){\n\t  if(fHash.getHash(i,i+strs[j].size()-1)\n\t     ==hashVal[j])\n\t    tmp+=dfs(i+strs[j].size(),1<<j,j);\n\t  if(tmp>0){\n\t    tmp=1;\n\t    break;\n\t  }\n\t}\n\tmem[hv]=tmp;\n\tres+=tmp;\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint N,M;\nbool dp[5001][1<<12];\nstring a[12];\nint main(){\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>a[i];\n\t\tstring s;\n\t\trep(i,M){\n\t\t\tstring o;\n\t\t\tcin>>o;\n\t\t\ts+=o;\n\t\t}\n\t\tM=s.size();\n\t\trep(i,M+1) rep(j,1<<N) dp[i][j]=0;\n\t\trep(i,M+1) dp[i][0]=1;\n\t\trep(i,M){\n\t\t\trep(j,1<<N){\n\t\t\t\tif(!dp[i][j]) continue;\n\t\t\t\tbool is[12];\n\t\t\t\trep(k,N) is[k]=(j>>k)&1;\n\t\t\t\trep(k,N){\n\t\t\t\t\tif(is[k]) continue;\n\t\t\t\t\tif(i+a[k].size()>M) continue;\n\t\t\t\t\tif(s.substr(i,a[k].size())==a[k]) dp[i+a[k].size()][j+(1<<k)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,M+1) if(dp[i][(1<<N)-1]) ans++;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct RollingHash{\n  typedef unsigned long long ull;\n  string S;\n  ull B;\n  int len;\n  vector<ull> hash,p;\n  RollingHash(){}\n  RollingHash(string S_,ull B_=1000000007LL):\n    S(S_),B(B_),len(S.length()),hash(len+1),p(len+1){\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\nint n,m,dp[5004][1<<12];\nstring s[12],x;\n\nsigned main(){\n    while(cin>>n>>m,n){\n        r(i,n)cin>>s[i];\n        vector<RollingHash> re;\n        r(i,n){\n            RollingHash rer(s[i]);\n            re.push_back(rer);\n        }\n        int sum=0;\n        r(i,m){\n            string t;\n            cin>>t;\n            x+=t;\n        }\n        r(o,1){\n            //cin>>x;\n            RollingHash R(x);\n            memset(dp,0,sizeof(dp));\n            for(int i=0;i<x.size();i++){\n                dp[i][0]=1;\n                for(int j=0;j<n;j++){\n                    for(int k=0;k<(1<<n)-1;k++)if(!((1<<j)&k)){\n                        if(i+s[j].size()>x.size())continue;\n                        if(re[j].find(0,s[j].size())==R.find(i,i+s[j].size())){\n                            dp[i+s[j].size()][k|(1<<j)]+=dp[i][k];\n                            if(k==0)dp[i+s[j].size()][k|(1<<j)]++;\n                            dp[i+s[j].size()][k|(1<<j)]%=1000000007;\n                        }\n                    }\n                }\n            }\n            for(int i=0;i<x.size()+1;i++) sum+=(dp[i][(1<<n)-1]?1:0) , sum%=1000000007;\n        }\n        x=\"\";\n        cout<<sum<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nchar c[12][21];\nchar s[5001];\nint A[128],B[128];\nbool D[12];\n\n\nint check(){\n\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tscanf(\"%s\",c[i]);\n\t\t\tint L = strlen(c[i]);\n\t\t\tfor(int j = 0 ; j < L ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += L;\n\t\t}\n\t\tint ans = 0;\n\t\tint len = 0;\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tscanf(\"%s\",s+len);\n\t\t\tlen += strlen(s);\n\t\t}\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\nbool dp[4096][5001];\n\nvoid solve(int n,int m){\n\tstring e[12],T;\n\tint ans=0,mn=20;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t\tmn=min(mn,(int)e[i].size());\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\n\tfill(dp[0],dp[0]+T.size()+1,true);\n\tfor(int s=1;s<(1<<n);++s){\n\t\tfill(dp[s],dp[s]+T.size()+1,false);\n\t}\n\tfor(int s=0;s<(1<<n)-1;++s){\n\t\tfor(int j=0;j<=T.size()-mn;++j){\n\t\t\tif(dp[s][j]){\n\t\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\t\tif(!((s>>i)&1)&&T.substr(j,e[i].size())==e[i]){\n\t\t\t\t\t\tdp[s+(1<<i)][j+e[i].size()]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=1;j<=T.size();++j){\n\t\tans+=dp[(1<<n)-1][j];\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(n,m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define N 10010\ntypedef long long ll;\nll p[N],q[N];\nclass RollingHash2{\nprivate:\n  ll aa[N];\n  ll bb[N];\n  ll P,Q;\npublic:\n  RollingHash2(){}\n  RollingHash2(string &s,ll _P,ll _Q){\n    int n=s.size();\n    aa[0]=bb[0]=0;\n    P=_P;\n    Q=_Q;\n    // hash値を計算\n    for(int i=1;i<=n;i++)aa[i]=aa[i-1]*P+s[i-1];\n    for(int i=1;i<=n;i++)bb[i]=bb[i-1]*Q+s[i-1];\n  }\n  pair<ll,ll> getHash(int x,int y){\n    return make_pair(aa[y+1]-aa[x]*p[y-x+1],\n\t\t     bb[y+1]-bb[x]*q[y-x+1]);\n  }\n};\nRollingHash2 fHash;\n\n// 格文字列のハッシュ値\npair<ll,ll> hashVal[12];\nll dp[1<<12][12];\nstring strs[12];\nstring fullTxt;\n\nint n,m;\nll dfs(int pos,int mask,int cur){\n  if(dp[mask][cur]>=0)return dp[mask][cur];\n  else if(mask==(1<<n)-1)return 1;\n  ll res=0;\n  for(int i=0;i<n;i++){\n    if((mask>>i)&1)continue;\n    // ハッシュ値が一致する場合\n    if(fHash.getHash(pos,pos+strs[i].size()-1)\n       ==hashVal[i]){\n      res+=dfs(pos+strs[i].size(),mask|(1<<i),i);\n    }\n  }\n  return dp[mask][cur]=res;\n}\n\nll fact[20];\nint main(){\n  const ll P=1000000007;\n  const ll Q=4300003200017LL;\n  fact[0]=1;\n  for(int i=1;i<20;i++)fact[i]=fact[i-1]*i;\n  // P**iを計算\n  p[0]=1;\n  for(int i=1;i<=10000;i++)p[i]=p[i-1]*P;\n  q[0]=1;\n  for(int i=1;i<=10000;i++)q[i]=q[i-1]*Q;\n  while(cin>>n>>m&&(n|m)){\n    fullTxt=\"\";\n    int sz=0;\n    map<string,int> scnt;\n    for(int i=0;i<n;i++){\n      cin>>strs[i];\n      scnt[strs[i]]++;\n      sz+=strs[i].size();\n      // ハッシュ値を計算しておく\n      RollingHash2 rh(strs[i],P,Q);\n      hashVal[i]=rh.getHash(0,strs[i].size()-1);\n    }\n    ll divNum=1;\n    for(map<string,int>::iterator it=scnt.begin();\n\tit!=scnt.end();it++){\n      divNum*=fact[it->second];\n    }\n    for(int i=0;i<m;i++){\n      string tmp;cin>>tmp;\n      fullTxt+=tmp;\n    }\n    // 計算済みの結果を登録しておく\n    map<pair<ll,ll>,ll> mem;\n    fHash=RollingHash2(fullTxt,P,Q);\n    ll res=0;\n    for(int i=0;i+sz<=fullTxt.size();i++){\n      pair<ll,ll> hv=fHash.getHash(i,i+sz-1);\n      // 計算済みであれば\n      if(mem.find(hv)!=mem.end())res+=mem[hv];\n      // まだ計算済みでない\n      else{\n\tmemset(dp,-1,sizeof(dp));\n\tll tmp=0;\n\tfor(int j=0;j<n;j++){\n\t  if(fHash.getHash(i,i+strs[j].size()-1)\n\t     ==hashVal[j])\n\t    tmp+=dfs(i+strs[j].size(),1<<j,j);\n\t}\n\tmem[hv]=tmp;\n\tres+=tmp;\n      }\n    }\n    cout<<res/divNum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<string> e(n);\n    string ts;\n    rep(i,0,n) cin >> e[i];\n    rep(i,0,m){\n        string t;\n        cin >> t;\n        ts+=t;\n    }\n\n    vector<int> sum_len(1<<n);\n    rep(i,0,1<<n){\n        rep(j,0,n){\n            if(((i>>j)&1)==0) continue;\n            sum_len[i]+=e[j].size();\n        }\n    }\n\n    static bool p[5000][1<<12];\n    fill_n((bool*)p,5000*(1<<12),false);\n    vector<vector<int>> heads(ts.size());\n    rep(i,0,ts.size()) p[i][0]=true;\n    rep(i,0,ts.size()){\n        rep(j,0,n){\n            if(i+e[j].size()>ts.size() or e[j]!=ts.substr(i,e[j].size())) continue;\n            p[i][1<<j]=true;\n            heads[i].push_back(j);\n        }\n    }\n    int ans=0;\n    for(int i=ts.size()-1; i>=0; --i){\n        rep(j,1,1<<n){\n            if(p[i][j] or i+sum_len[j]>ts.size()) continue;\n            for(int k:heads[i]){\n                if(((j>>k)&1)==0) continue;\n                int i2=i+e[k].size();\n                if(p[i2][j&(~(1<<k))]){\n                    p[i][j]=true;\n                    break;\n                }\n            }\n        }\n        if(p[i][(1<<n)-1]) ++ans;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\n\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint n,m;\n\nll gha[6000];\nbool vis[1<<12][100];\nll po[1000];\n\nvoid solve(){\n  ll ha[n];\n  int len[n];\n  rep(i,n) {\n    char a[30];\n    scanf(\"%s\",a);\n    ll h =0 ;\n    len[i] = strlen(a);\n    rep(j,len[i])\n      h=h*31+a[j];\n    ha[i] =h;\n  }\n  \n  po[0] = 1;\n  rep(i,999) po[i+1] = po[i]*31;\n  int ans = 0;\n  char text[6000];\n  int tidx = 0;\n  rep(jjj,m) {\n    scanf(\"%s\",text+tidx);\n    while(text[tidx]) ++tidx;\n  }\n  \n  rep(i,tidx) gha[i+1] = gha[i]*31+text[i];\n  \n  bool vis[250][(1<<n)+3];\n  rep(i,250)rep(j,1<<n) vis[i][j]=0;\n  rep(i,250) vis[i][0]=1;\n  \n  rep(j,tidx+1){\n    int cur = j%250;\n    rep(k,n){\n      if(len[k]+j>tidx) continue;\n      if(ha[k] != gha[j+len[k]] - gha[j]*po[len[k]]) continue;\n      int ne = (j+len[k])%250;\n      rep(i,1<<n)\n        vis[ne][i|(1<<k)]|=vis[cur][i] & ((~i>>k)&1);\n    }\n    // rep(i,1<<n){\n    //   if(!vis[cur][i]) continue;\n    //   rep(k,n)\n    //     if((~i&(1<<k)) && len[k]+j<=tidx &&\n    //        ha[k] == gha[j+len[k]] - gha[j]*po[len[k]])\n    //       vis[(j+len[k])%250][i|(1<<k)]=1;\n    // }\n    ans += vis[cur][(1<<n)-1];\n    rep(i,1<<n) vis[cur][i] = 0;\n    vis[cur][0]=1;\n  }\n  printf(\"%d\\n\",ans);\n  //cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  \n  while(scanf(\"%d%d\",&n,&m) ,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<string> e(n);\n    string ts;\n    rep(i,0,n) cin >> e[i];\n    rep(i,0,m){\n        string t;\n        cin >> t;\n        ts+=t;\n    }\n\n    vector<int> sum_len(1<<n);\n    rep(i,0,1<<n){\n        rep(j,0,n){\n            if(((i>>j)&1)==0) continue;\n            sum_len[i]+=e[j].size();\n        }\n    }\n\n    static bool p[5000][1<<12];\n    fill_n((bool*)p,int64_t(5000)*(1<<12),false);\n    vector<vector<int>> heads(ts.size());\n    rep(i,0,ts.size()) p[i][0]=true;\n    rep(i,0,ts.size()){\n        rep(j,0,n){\n            if(i+e[j].size()>ts.size() or e[j]!=ts.substr(i,e[j].size())) continue;\n            p[i][1<<j]=true;\n            heads[i].push_back(j);\n        }\n    }\n    int ans=0;\n    for(int i=ts.size()-1; i>=0; --i){\n        rep(j,1,1<<n){\n            if(p[i][j] or i+sum_len[j]>ts.size()) continue;\n            for(int k:heads[i]){\n                if(((j>>k)&1)==0) continue;\n                int i2=i+e[k].size();\n                if(p[i2][j&(~(1<<k))]){\n                    p[i][j]=true;\n                    break;\n                }\n            }\n        }\n        if(p[i][(1<<n)-1]) ++ans;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, M;\n  while(cin >> N >> M && N){\n    static bool dp[5022][1 << 12] = {};\n    memset(dp, 0, sizeof(dp));\n    string word[12];\n    REP(i, N) cin >> word[i];\n    string s;\n    REP(i, M){\n      string t; cin >> t;\n      s += t;\n    }\n    int L = s.size();\n    bool match[5000][12] = {};\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j + word[i].size() <= L; j++){\n        if(word[i] == s.substr(j, word[i].size())) match[j][i] = true;\n      }\n    }\n    REP(i, L + 1) dp[i][0] = true;\n    REP(i, L){\n      REP(j, N) if(match[i][j]){\n        REP(S, 1 << N) if(0 == (S >> j & 1) && dp[i][S]){\n          dp[i + word[j].size()][S | (1 << j)] = true;\n        }\n      }\n    }\n    int ans = 0;\n    REP(i, L + 1) if(dp[i][(1 << N) - 1]) ans ++;\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef pair<int_t,int_t> hash_t;\n    int_t base1, base2;\n    int_t mod1, mod2;\n    vector<int_t> hash1, hash2;\n    vector<int_t> pow1, pow2;\n    RollingHash() : base1(1009), base2(1007), mod1(1000000007), mod2(1000000009) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1.assign(n+1,0);\n        hash2.assign(n+1,0);\n        pow1.assign(n+1,1);\n        pow2.assign(n+1,1);\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            hash2[i+1] = (hash2[i]+s[i]) * base2 % mod2;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n            pow2[i+1] = pow2[i] * base2 % mod2;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        int_t t2 = ((hash2[r] - hash2[l] * pow2[r-l]) % mod2 + mod2) % mod2;\n        return make_pair(t1, t2);\n    }\n    RollingHash::hash_t concat(hash_t h1, hash_t h2, int h2_len) {\n        return make_pair((h1.first*pow1[h2_len]+h2.first)%mod1, (h1.second*pow2[h2_len]+h2.second)%mod2);\n    }\n};\n\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<RollingHash::hash_t> hs(n);\n    RollingHash rh;\n    rep(i,n){\n        rh.init(ss[i]);\n        hs[i] = rh.get(0,ss[i].size());\n    }\n    rh.init(t);\n\n    memset(dp,false,sizeof(dp));\n    rep(i,5000) dp[i][0] = true;\n    rep(pos,len){\n        rep(i,n){\n            rep(mask,1<<n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    if(pos+ss[i].size() > t.size()) continue;\n                    if(rh.get(pos,pos+ss[i].size()) != hs[i]) continue;\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define N 10010\ntypedef long long ll;\nll p[N],q[N];\nclass RollingHash2{\nprivate:\n  ll aa[N];\n  ll bb[N];\n  ll P,Q;\npublic:\n  RollingHash2(){}\n  RollingHash2(string &s,ll _P,ll _Q){\n    int n=s.size();\n    aa[0]=bb[0]=0;\n    P=_P;\n    Q=_Q;\n    // hash値を計算\n    for(int i=1;i<=n;i++)aa[i]=aa[i-1]*P+s[i-1];\n    for(int i=1;i<=n;i++)bb[i]=bb[i-1]*Q+s[i-1];\n  }\n  pair<ll,ll> getHash(int x,int y){\n    return make_pair(aa[y+1]-aa[x]*p[y-x+1],\n\t\t     bb[y+1]-bb[x]*q[y-x+1]);\n  }\n};\nRollingHash2 fHash;\n\n// 格文字列のハッシュ値\npair<ll,ll> hashVal[12];\nstring strs[12];\nstring fullTxt;\nint n,m;\nint dp[1<<12][12];\nint dfs(int pos,int mask,int cur){\n  if(mask==(1<<n)-1)return true;\n  else if(dp[mask][cur]>=0)return dp[mask][cur];\n  bool res=false;\n  for(int i=0;i<n;i++){\n    if((mask>>i)&1)continue;\n    // ハッシュ値が一致する場合\n    if(fHash.getHash(pos,pos+strs[i].size()-1)\n       ==hashVal[i]){\n      res|=dfs(pos+strs[i].size(),mask|(1<<i),i);\n      if(res)return res;\n    }\n  }\n  return dp[mask][cur]=res;\n}\n\nll fact[20];\nint main(){\n  const ll P=1000000007;\n  const ll Q=4300003200017LL;\n  fact[0]=1;\n  for(int i=1;i<20;i++)fact[i]=fact[i-1]*i;\n  // P**iを計算\n  p[0]=1;\n  for(int i=1;i<=10000;i++)p[i]=p[i-1]*P;\n  q[0]=1;\n  for(int i=1;i<=10000;i++)q[i]=q[i-1]*Q;\n  while(cin>>n>>m&&(n|m)){\n    fullTxt=\"\";\n    int sz=0;\n    map<string,int> scnt;\n    for(int i=0;i<n;i++){\n      cin>>strs[i];\n      scnt[strs[i]]++;\n      sz+=strs[i].size();\n      // ハッシュ値を計算しておく\n      RollingHash2 rh(strs[i],P,Q);\n      hashVal[i]=rh.getHash(0,strs[i].size()-1);\n    }\n    ll divNum=1;\n    for(map<string,int>::iterator it=scnt.begin();\n\tit!=scnt.end();it++){\n      divNum*=fact[it->second];\n    }\n    for(int i=0;i<m;i++){\n      string tmp;cin>>tmp;\n      fullTxt+=tmp;\n    }\n    // 計算済みの結果を登録しておく\n    map<pair<ll,ll>,bool> mem;\n    fHash=RollingHash2(fullTxt,P,Q);\n    ll res=0;\n    for(int i=0;i+sz<=fullTxt.size();i++){\n      pair<ll,ll> hv=fHash.getHash(i,i+sz-1);\n      // 計算済みであれば\n      if(mem.find(hv)!=mem.end())res+=mem[hv];\n      // まだ計算済みでない\n      else{\n\tmemset(dp,-1,sizeof(dp));\n\tbool tmp=false;\n\tfor(int j=0;j<n;j++){\n\t  if(fHash.getHash(i,i+strs[j].size()-1)\n\t     ==hashVal[j]){\n\t    tmp|=dfs(i+strs[j].size(),1<<j,j);\n\t    if(tmp)break;\n\t  }\n\t}\n\tmem[hv]=tmp;\n\tres+=tmp;\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\n\null StoH(string a){\n  ull res=0;\n  for(int i=0;i<a.size();i++)res=res*B+a[i];\n  return res;\n}\n\nvector<bool> search(string &a,string &key){\n  vector<bool> res(a.size(),0);\n  ull klen=key.size(),h=StoH(a.substr(0,klen)),target=StoH(key),t=1;\n  for(int i=0;i<klen;i++) t*=B;\n  for(int i=klen;i<a.size();i++){\n    if(h==target) res[i-klen]=1;\n    h = h*B+a[i]-a[i-klen]*t;\n  }\n  if(h==target) res[a.size()-klen] = 1;\n  return res;\n}\n\nint n,m,len;\nstring e[12];\nvector<bool> es[12];\nbool used[12];\nbool check(int idx,int cnt){\n  if(cnt==n) return 1;\n  for(int i=0;i<n;i++){\n    if(used[i]||!es[i][idx])continue;\n    used[i]=1;\n    if(check(idx+e[i].size(),cnt+1)) return 1;\n    used[i]=0;\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    len=0;\n    for(int i=0;i<n;i++)cin>>e[i],len+=e[i].size();\n  \n    string mp;\n    for(int i=0;i<m;i++){\n      string tmp;\n      cin>>tmp;\n      mp+=tmp;\n    }\n    for(int i=0;i<n;i++)es[i]=search(mp,e[i]);\n  \n    int ans=0;\n    for(int i=0;i<mp.size()-len+1;i++){\n      memset(used,0,sizeof(used));\n      if(check(i,0)) ans++;\n    }\n    cout<<ans<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n\nll fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<string> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(s);\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].size();\n      }\n    }\n\n    string T;\n    rep(i, M) {\n      char s[5001]; cin >> s, T += s;\n    }\n\n    int TSize = T.size();\n \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(!T.compare(st + sizes[S], sizes[S|(1<<i)] - sizes[S], vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>//\"geometry.cpp\"\n#include<iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>//\"greater<T>\" Ex. sort(a,a+n,greater<int>());\n#include<cmath>//\"abs\", \"sqrt\"\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\nvoid solve(int n,int m){\n\tstring e[12],T;\n\tint ans=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\t\n\tfor(int j=0;j<T.size();++j){\n\t\tint x=j;\n\t\tbool f[12],g;\n\t\tfill(f,f+n,false);\n\t\tfor(int k=0;k<n;++k){\n\t\t\tg=false;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tif(f[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(T.substr(x,e[i].size())!=e[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx+=e[i].size();\n\t\t\t\tf[i]=true;\n\t\t\t\tg=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!g){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(g){\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(n,m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 1000000007;\n\nint solve(vector<string> & ss, string & t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<ull> shash(n);\n    rep(i,n){\n        ull x = 0;\n        rep(j,ss[i].size()){\n            x = x*B + ss[i][j];\n        }\n        shash[i] = x;\n    }\n    vector<ull> pow(len+1), thash(len+1);\n    pow[0] = 1;\n    thash[0] = 0;\n    rep(i,len){\n        pow[i+1] = pow[i]*B;\n        thash[i+1] = thash[i]*B + t[i];\n    }\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+ss[i].size() > t.size()) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+ss[i].size()] - thash[pos] * pow[ss[i].size()];\n                // if(h1 != h2) continue;\n                dp[pos+ss[i].size()][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n    memset(dp,false,sizeof(dp));\n    rep(i,5000) dp[i][0] = true;\n    rep(pos,len){\n        rep(i,n){\n            rep(mask,1<<n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\n\ninline long long to_int64(char x) {\n  return (long long)x;\n}\n   \nstruct RollingHash {\n     \n  const array<int, 2> mods = {{int(1e9+7), int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 2> Ks = {{1007, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n   \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n   \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n   \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n   \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n    \n  RollingHash(string const& s) {\n    S = s;\n    N = s.size();\n    construct();\n  }\n   \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n \n  bool same(int a_start, int a_end, int b_start, int b_end, RollingHash const& rh) const {\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh.get_hash(i, b_start, b_end)) return false;\n    }\n    return true;\n  }\n   \n};\n\nint sizes[1<<12];\n\nint main() {\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<RollingHash> vs;\n    rep(i, N) {\n      string s; cin >> s;\n      vs.push_back(RollingHash(s));\n    }\n \n    rep(i, 1<<N) sizes[i] = 0;\n\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      char s[5001];\n      scanf(\"%s\", s);\n      t += s;\n    }\n\n    int TSize = t.size();\n    RollingHash T(t);\n    \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i].N, vs[i])) {\n            dp[S|(1<<i)] = 1;\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint n, m;\nint bs;string b[12];\nstring in,s;\n\nqueue<int> q;\nbool used[1 << 12];\nint len[1 << 12];\nbool ok[12][5000];\n\nbool valid(int le) {\n\trep(i, (1 << n)) {\n\t\tused[i] = false;\n\t}\n\tq.push(0); used[0] = true;\n\twhile (!q.empty()) {\n\t\tint p = q.front(); q.pop();\n\t\trep(i, n) {\n\t\t\tif (p&(1 << i))continue;\n\t\t\tif (ok[i][le+len[p]]) {\n\t\t\t\tint np = p ^ (1 << i);\n\t\t\t\tif (!used[np]) {\n\t\t\t\t\tused[np] = true; q.push(np);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn used[(1<<n)-1];\n}\nvoid init() {\n\tbs = 0; s.clear();\n\trep(i, 1 << n) {\n\t\tlen[i] = 0;\n\t}\n}\nint main() {\n\twhile (cin >> n >> m,n) {\n\t\tinit();\n\t\trep(i, n) {\n\t\t\tcin >> in; bs += in.length(); b[i] = in;\n\t\t}\n\t\trep(i, (1 << n)) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i&(1 << j)) {\n\t\t\t\t\tlen[i] += b[j].length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tcin >> in; s += in;\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, s.length() - b[i].length() + 1) {\n\t\t\t\tok[i][j] = (b[i] == s.substr(j, b[i].length()));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, s.length() - bs + 1) {\n\t\t\tif (valid(i))ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nbool dp[1 << 12][5001];\nint main() {\n\twhile (1) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tvector<string>elems;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\telems.push_back(st);\n\t\t}\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (elems[i] == elems[j])uf.unionSet(i, j);\n\t\t\t}\n\t\t}\n\t\tlong long int waru = 1; \n\t\t{\n\t\t\tset<int>used;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (used.find(uf.root(i))==used.end()) {\n\t\t\t\t\tused.emplace(uf.root(i));\n\t\t\t\t\tint num=uf.size(i);\n\t\t\t\t\twhile (num >= 2)waru *= num--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t\tstring text;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\ttext += st;\n\t\t}\n\t\tvector<vector<int>>oks(n, vector<int>(text.size()));\n\t\tfor (int e = 0; e < elems.size(); ++e) {\n\t\t\tfor (int i = 0; i <= text.size()-elems[e].size(); ++i) {\n\t\t\t\tif (elems[e] == text.substr(i, elems[e].size())) {\n\t\t\t\t\toks[e][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp, false, sizeof(dp));\n\t\tfor (int i = 0; i < 5001; ++i) {\n\t\t\tdp[0][i] = true;\n\t\t}\n\t\tset<int>ans;\n\t\tfor (int j = 0; j < text.size(); ++j) {\n\t\t\t/*if (j % 100 == 0) {\n\t\t\t\tnum++;\n\t\t\t\tfor (int j = 0; j < 1 << 12; ++j) {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 1 << 12; ++j) {\n\t\t\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t\t\tdp[j][i] = dp[j][i + 100];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 100; i < 501; ++i) {\n\t\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t\t\tdp[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tfor (int i = 0; i < 1 << n; ++i) {\n\t\t\t\tbitset<12>uses(i);\n\t\t\t\tfor (int e = 0; e < n; ++e) {\n\t\t\t\t\tif (oks[e][j]&&!uses[e]&&dp[i][j]) {\n\t\t\t\t\t\tconst int next = j + elems[e].size();\n\t\t\t\t\t\tif (next <= text.size()) {\n\t\t\t\t\t\t\tuses[e] = true;\n\t\t\t\t\t\t\tif (uses.count() == n)ans.emplace(next);\n\t\t\t\t\t\t\tdp[uses.to_ulong()][next] = true;\n\t\t\t\t\t\t\tuses[e] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans.size() << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int LLNF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct RollingHash{\n\tstring str;\n\tlong long int base,mod;\n\tvector<long long int> hash,pow; //hash[i]:=[0,i)のハッシュ\n\t\n\tRollingHash(string str,long long int base,long long int mod):str(str),base(base),mod(mod){\n\t\tint size=str.size();\n\t\thash=vector<long long int>(size+1);\n\t\tpow=vector<long long int>(size+1);\n\n\t\thash[0]=0;\n\t\tpow[0]=1;\n\t\tfor(int i=1; i<size+1; ++i){\n\t\t\tpow[i]=pow[i-1]*base%mod;\n\t\t\thash[i]=(hash[i-1]*base+str[i-1])%mod;\n\t\t}\n\t}\n\n\tinline long long int Hash(int l,int r){ //[l,r)\n\t\treturn (hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\n\t}\n};\n\ninline long long Hash(string str,long long int base,long long int mod){\n\tlong long int res=0;\n\tfor(int i=0; i<str.size(); ++i){\n\t\tres=(res*base+str[i])%mod;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint n,m;\n\t\tstring e[12],t;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\trep(i,0,n) cin >> e[i];\n\t\trep(i,0,m){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tt+=tmp;\n\t\t}\n\t\n\t\tconst ll base=993,mod=1000000007LL;\n\t\tRollingHash t_hash(t,base,mod);\n\t\tunordered_map<ll,int> count;\n\t\trep(i,1,t.size()+1) for(int j=0; j+i<=t.size(); ++j) ++count[t_hash.Hash(j,j+i)];\n\t\t\n\t\tint ans=0;\n\t\tunordered_set<ll> done;\n\t\tvector<int> perm(n);\n\t\trep(i,0,n) perm[i]=i;\n\t\tdo{\n\t\t\tstring str; \n\t\t\trep(i,0,n) str+=e[perm[i]];\n\t\t\tll x=Hash(str,base,mod);\n\t\t\tif(done.find(x)!=done.end()) continue;\n\t\t\tdone.insert(x);\n\t\t\tans+=count[x];\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\n\nll fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<string> vs;\n    map<string, int> mp;\n    rep(i, N) {\n      string s; cin >> s;\n      mp[s] ++;\n      vs.push_back(s);\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].size();\n      }\n    }\n\n    string T;\n    rep(i, M) {\n      char s[5001]; cin >> s, T += s;\n    }\n\n    int TSize = T.size();\n    \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(!T.compare(st + sizes[S], sizes[S|(1<<i)] - sizes[S], vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      ll di = 1;\n      for(auto e: mp) {\n        di *= fact[e.second];\n      }\n      sum += dp[(1<<N)-1] / di;\n    }\n\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint n, m;\nll dp[5001][1<<12];\nmain(){\n\tint i,j;\n\twhile(cin >> n >> m, n){\n\t\tstring t;\n\t\tvector<string> s(n);\n\t\tREP(i, n) cin >> s[i];\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tt += s;\n\t\t}\n\t\tvector< vector<int> > g(t.size()+1);\n\t\tREP(i, t.size()){\n\t\t\tREP(j, n){\n\t\t\t\tif(i+s[j].size()-1 >= t.size()) continue;\n\t\t\t\tint f = 1;\n\t\t\t\tREP(k, s[j].size()) f &= t[i+k] == s[j][k];\n\t\t\t\tif(f) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tll ans = 0;\n\t\tREP(i, t.size()+1){\n\t\t\tdp[i][0] = 1;\n\t\t\tREP(j, 1 << n){\n\t\t\t\tFOR(k, g[i]){\n\t\t\t\t\tif(1&(j>>*k)) continue;\n\t\t\t\t\tdp[i+s[*k].size()][j|(1<<*k)] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += !!dp[i][(1<<n)-1];\n//\t\t\tprintf(\"%c ans[%d] = %lld\\n\", t[i], i, dp[i][(1<<n)-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring t;\nchar buf[114514];\nstring des[114514];\nbool dp[1 << 12][5001];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n    }\n\n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n\n    int lim = 1 << n;\n    fill(dp[0], dp[lim], false);\n    for (int i=0; i<t.size(); i++) {\n      for (int g=0; g<n; g++) {\n        int prev = i+1-des[g].size();\n        if (prev < 0) continue;\n        if (t.substr(prev, des[g].size()) != des[g]) continue;\n\n        for (int st=0; st<lim; st++) {\n          if (st >> g & 1) continue;\n          dp[st|(1<<g)][i+1] |= dp[st][prev];\n        }\n        dp[1<<g][i+1] = true;\n      }\n    }\n\n    int ans = 0;\n    for (int i=0; i<=t.size(); i++) {\n      if (dp[lim-1][i]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\nll dp[5001][1 << 12];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){ break; }\n\t\tvector<string> patterns(n);\n\t\tfor(int i = 0; i < n; ++i){ cin >> patterns[i]; }\n\t\tstring text;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\ttext += line;\n\t\t}\n\t\tconst int length = text.size();\n\t\tvector<int> match(length);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tconst int p = patterns[i].size();\n\t\t\tfor(int j = 0; j + p <= length; ++j){\n\t\t\t\tint flag = 1;\n\t\t\t\tfor(int k = 0; flag && k < p; ++k){\n\t\t\t\t\tif(text[j + k] != patterns[i][k]){ flag = 0; }\n\t\t\t\t}\n\t\t\t\tmatch[j] |= (flag << i);\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tll answer = 0;\n\t\tfor(int i = 0; i < length; ++i){\n\t\t\tdp[i][0] = 1;\n\t\t\tfor(int j = 0; j + 1 < (1 << n); ++j){\n\t\t\t\tint mask = match[i] & ~j;\n\t\t\t\twhile(mask != 0){\n\t\t\t\t\tconst int shift = __builtin_ctz(mask);\n\t\t\t\t\tmask &= mask - 1;\n\t\t\t\t\tconst int a = i + patterns[shift].size();\n\t\t\t\t\tconst int b = j | (1 << shift);\n\t\t\t\t\tdp[a][b] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[i + 1][(1 << n) - 1]){ ++answer; }\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 5001\ntypedef unsigned long long ull;\null B=9999973;\n\nint n,m;\nstring a[12];\null b[12];\n\nvector<int> G[MAX];\null dp[MAX][(1<<12)];\nstring s,tmp;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    for(int i=0;i<MAX;i++)G[i].clear();\n    memset(b,0,sizeof(b));\n    memset(dp,0,sizeof(dp));\n    s=\"\";\n    for(int i=0;i<n;i++){\n      cin>>a[i];\n      for(int j=0;j<(int)a[i].size();j++)\n        b[i]=b[i]*B+a[i][j];\n    }\n    for(int i=0;i<m;i++)cin>>tmp,s+=tmp;\n\n    for(int i=0;i<n;i++){\n      int size=a[i].size();\n      ull C=1,key=0;\n      for(int j=0;j<(int)s.size();j++){\n        key=key*B+s[j];\n        if(j-size>=0)key-=s[j-size]*C;\n        else C*=B;\n        if(key==b[i])G[j-size+1].push_back(i);\n      }\n    }\n\n    ull ans=0;\n    for(int i=0;i<(int)s.size();i++){\n      dp[i][0]=1;\n      for(int S=0;S<(1<<n);S++){\n        for(int j=0;j<(int)G[i].size();j++){\n          int id=G[i][j];\n          int size=a[id].size();\n          if(S>>id&1)continue;\n          dp[i+size][S|(1<<id)]+=dp[i][S];\n        }\n      }\n      ans+=(dp[i][(1<<n)-1]>0?1:0);\n    }\n    if(dp[s.size()][(1<<n)-1]>0)ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass AhoCorasick\n{\n    int n;\n    vector<vector<int> > next;\n    vector<bitset<64> > match;\n    vector<int> failure;\npublic:\n    AhoCorasick(const vector<string>& pattern){\n        next.assign(1, vector<int>(128, -1));\n        match.assign(1, 0);\n        for(unsigned i=0; i<pattern.size(); ++i){\n            int curr = 0;\n            for(unsigned j=0; j<pattern[i].size(); ++j){\n                if(next[curr][pattern[i][j]] == -1){\n                    next[curr][pattern[i][j]] = next.size();\n                    next.push_back(vector<int>(128, -1));\n                    match.push_back(0);\n                }\n                curr = next[curr][pattern[i][j]];\n            }\n            match[curr][i] = true;\n        }\n\n        n = next.size();\n        failure.resize(n, 0);\n        vector<int> node1(1, 0);\n        while(!node1.empty()){\n            vector<int> node2;\n            for(unsigned i=0; i<node1.size(); ++i){\n                for(int j=0; j<128; ++j){\n                    int s = node1[i];\n                    if(next[s][j] == -1)\n                        continue;\n                    node2.push_back(next[s][j]);\n                    int t = s;\n                    while(t != 0){\n                        if(next[failure[t]][j] != -1){\n                            failure[next[s][j]] = next[failure[t]][j];\n                            match[next[s][j]] |= match[next[failure[t]][j]];\n                            break;\n                        }\n                        t = failure[t];\n                    }\n                }\n            }\n            node1.swap(node2);\n        }\n    }\n    int size(){\n        return n;\n    }\n    int transition(int curr, char c){\n        if(next[curr][c] != -1)\n            return next[curr][c];\n        if(curr == 0)\n            return 0;\n        return transition(failure[curr], c);\n    }\n    bitset<64> checkMatch(int curr){\n        return match[curr];\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<string> element(n);\n        for(int i=0; i<n; ++i)\n            cin >> element[i];\n        AhoCorasick ac(element);\n\n        string s;\n        while(--m >= 0){\n            string t;\n            cin >> t;\n            s += t;\n        }\n        int len = s.size();\n\n        int ret = 0;\n        vector<vector<bool> > dp(1<<n, vector<bool>(len+1, false));\n        dp[0] = vector<bool>(len+1, true);\n\n        int curr = 0;\n        for(int i=0; i<len; ++i){\n            curr = ac.transition(curr, s[i]);\n            bitset<64> match = ac.checkMatch(curr);\n            for(int j=0; j<(1<<n); ++j){\n                bitset<64> bs(j);\n                for(int k=0; k<n; ++k){\n                    if(match[k] && !bs[k]){\n                        bs[k] = true;\n                        if(dp[j][i+1-element[k].size()])\n                            dp[bs.to_ulong()][i+1] = true;\n                        bs[k] = false;\n                    }\n                }\n            }\n            if(dp[(1<<n)-1][i+1])\n                ++ ret;\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<string> e(n);\n    string ts;\n    int concatenated_len=0;\n    rep(i,0,n){\n        cin >> e[i];\n        concatenated_len+=e[i].size();\n    }\n    rep(i,0,m){\n        string t;\n        cin >> t;\n        ts+=t;\n    }\n\n    vector<int> sum_len(1<<n);\n    rep(i,0,1<<n){\n        rep(j,0,n){\n            if(((i>>j)&1)==0) continue;\n            sum_len[i]+=e[j].size();\n        }\n    }\n\n    static bool p[5000][1<<12];\n    fill_n((bool*)p,5000*(1<<12),false);\n    vector<vector<int>> heads(ts.size());\n    rep(i,0,ts.size()) p[i][0]=true;\n    rep(i,0,ts.size()){\n        rep(j,0,n){\n            if(i+e[j].size()>ts.size() or e[j]!=ts.substr(i,e[j].size())) continue;\n            p[i][1<<j]=true;\n            heads[i].push_back(j);\n        }\n    }\n    int ans=0;\n    for(int i=ts.size()-1; i>=0; --i){\n        rep(j,1,1<<n){\n            if(p[i][j] or i+sum_len[j]>=ts.size()) continue;\n            for(int k:heads[i]){\n                if(((j>>k)&1)==0) continue;\n                int i2=i+e[k].size();\n                if(p[i2][j&(~(1<<k))]){\n                    p[i][j]=true;\n                    break;\n                }\n            }\n        }\n        if(p[i][(1<<n)-1]) ++ans;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    string e[n],t[m];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<m;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<m;i++) b+=t[i],t[i]=\"\";\n    int x=n/2,y=n-x;\n    map<int,map<ull,set<int> > > m;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(auto &a:m){\n\tint l=a.first;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tauto &p=a.second;\n\tif(!p.count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=p[u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 12, TT = 5000;\nbool dp[1<<N];\nint len[1<<N];\nbool match[N][TT];\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n){\n        vector<string> s(n);\n        rep(i,n) cin >>s[i];\n\n        string t=\"\";\n        while(m--){\n            string tmp;\n            cin >>tmp;\n            t += tmp;\n        }\n\n        vector<int> sz(n);\n        int S = 0;\n        rep(i,n){\n            sz[i] = s[i].size();\n            S += sz[i];\n        }\n        int T = t.size();\n        // S <= 240, T <= 5000\n\n        rep(mask,1<<n){\n            len[mask] = 0;\n            rep(i,n)if(mask>>i&1) len[mask] += sz[i];\n        }\n\n        fill(match[0], match[N], false);\n        rep(i,n){\n            rep(j,T-sz[i]+1){\n                match[i][j] = (s[i] == t.substr(j,sz[i]));\n            }\n        }\n\n        int ans = 0;\n        rep(i,T-S+1){\n            fill(dp,dp+(1<<N),false);\n            dp[0] = true;\n            rep(mask,1<<n)if(dp[mask]){\n                rep(j,n)if(!(mask>>j&1)){\n                    int nx = mask | (1<<j);\n                    if(match[j][i+len[mask]]) dp[nx] = true;\n                }\n            }\n\n            if(dp[(1<<n)-1]) ++ans;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tchar name[21];\n\tint length;\n};\n\n\nint POW[21];\nint N,num_line,TEXT_LENGTH;\nchar buf[101],TEXT[5001];\nbool is_match[5001];\nInfo info[20];\n\n\nvoid recursive(int start_loc,int loc,int state){\n\tif(is_match[start_loc])return; //すくなくとも1つがマッチしたならreturn\n\n\tif(state == POW[N]-1){ //全文字一致\n\t\tis_match[start_loc] = true;\n\t\treturn;\n\t}\n\n\tint next_state,next_loc;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tif(state & (1 << loop)){ //使用済\n\t\t\t//Do nothin\n\t\t}else{ //TEXT[loc]から、info[loop]との一致比較\n\t\t\tFLG = true;\n\t\t\tfor(int i = 0; i < info[loop].length; i++){\n\t\t\t\tif(TEXT[loc+i] != info[loop].name[i]){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tnext_state = state+POW[loop];\n\t\t\t\tnext_loc = loc+info[loop].length;\n\t\t\t\trecursive(start_loc,next_loc,next_state);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tint length,sum_length = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].name);\n\t\tfor(length = 0; info[i].name[length] != '\\0'; length++);\n\t\tinfo[i].length = length;\n\t\tsum_length += length;\n\t}\n\n\t//テキストの読み込み\n\tint index = 0;\n\tfor(int loop = 0; loop < num_line; loop++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int k = 0; buf[k] != '\\n' && buf[k] != '\\0'; k++){\n\t\t\tTEXT[index++] = buf[k];\n\t\t}\n\t}\n\tTEXT_LENGTH = index;\n\n\tfor(int i = 0; i < TEXT_LENGTH; i++)is_match[i] = false;\n\n\t//一致の先頭となりえる箇所を全探索\n\tfor(int start_loc = 0; start_loc <= TEXT_LENGTH-sum_length; start_loc++){\n\t\trecursive(start_loc,start_loc,0);\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < TEXT_LENGTH; i++){\n\t\tif(is_match[i])ans++;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 21; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&num_line);\n\t\tif(N == 0 && num_line == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nvector<string> elms;\nstring text;\nvector<vector<int>> cors;\n\nbool dfs(int si, int s, int l){\n    if(s == (1<<N)-1) return true;\n    \n    for(int i=0; i<N; i++) if((s>>i&1) == 0){\n        if(binary_search(cors[i].begin(), cors[i].end(), si))\n            if(dfs(si+(int)elms[i].size(), s|(1<<i), l+(int)elms[i].size()))\n                return true;\n    }\n    return false;\n}\n\nvoid solve(){\n    cors.clear(); cors.resize(N);\n    for(int i=0; i<N; i++){\n        string elm = elms[i];\n        for(int j=0; j<text.size(); j++){\n            if(text.substr(j, elm.size()) == elm)\n                cors[i].push_back(j);\n        }\n    }\n    int ans = 0;\n    for(int i=0; i<text.size(); i++){\n        ans += dfs(i, 0, 0);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>N>>M, N|M){\n        elms.resize(N);\n        for(auto &s: elms) cin >> s;\n        text = \"\";\n        for(int i=0; i<M; i++){\n            string t; cin >> t;\n            text += t;\n        }\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tstring text=\"\";\n\t\tvector<string> key(n);\n\t\tfor(auto &s:key)cin>>s;\n\t\ttext.reserve(5000);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring s;cin>>s;\n\t\t\ttext+=s;\n\t\t}\n\t\tm=text.size();\n\n\t\tvector<list<int>> mv(m);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0,sz=key[i].size();j<m+1-sz;j++){\n\t\t\t\tbool f=true;\n\t\t\t\tfor(int k=0;k<sz;k++)f&=(key[i][k]==text[j+k]);\n\t\t\t\tif(f)mv[j].push_back(i);\n\t\t\t}\n\n\t\tint res=0;\n\t\tvector<vector<bool>> dp(m+1,vector<bool>(1<<n,false));\n\t\tfor(int i=0;i<=m;i++)dp[i][0]=true;\n\t\tfor(int i=0,sz=1<<n;i<m;i++){\n\t\t\tfor(int b=0;b<sz;b++)\n\t\t\t\tif(dp[i][b])\n\t\t\t\t\tfor(auto &it:mv[i])\n\t\t\t\t\t\tif(((1<<it)&b)==0)\n\t\t\t\t\t\t\tdp[i+key[it].size()][b|(1<<it)]=true;\n\t\t\tif(dp[i+1][sz-1])res++;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nchar w[15][30];\nint len[15];\nchar str[5100];\nchar in[210];\nint m[5100][13];\nchar dp[5100][1<<12];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",w[i]);\n\t\tstring s=\"\";\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring tmp=in;\n\t\t\ts+=tmp;\n\t\t}\n\t\tfor(int i=0;i<a;i++)len[i]=strlen(w[i]);\n\t\t\n\t\tint n=s.size();\n\t\tfor(int i=0;i<n;i++)str[i]=s[i];\n\t\tstr[n]=0;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<a;j++)m[i][j]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i+len[j]>n)continue;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int k=0;w[j][k];k++)if(w[j][k]!=str[i+k])ok=false;\n\t\t\t\tif(ok)m[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=n;i++)for(int j=0;j<(1<<a);j++)dp[i][j]=0;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdp[i][0]=1;\n\t\t\tfor(int j=0;j<(1<<a);j++){\n\t\t\t\tif(!dp[i][j])continue;\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(j&(1<<k))continue;\n\t\t\t\t\tif(m[i][k])dp[i+len[k]][j+(1<<k)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<=n;i++)if(dp[i][(1<<a)-1])ret++;\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\n\n\nint main() {\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0)break;\n\t\tvs pat(N);\n\t\tstring text = \"\";\n\t\trep(i, N) {\n\t\t\tcin >> pat[i];\n\t\t}\n\t\trep(i, M) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext += str;\n\t\t}\n\t\tint L = text.size();\n\t\tvvb dp(1 << N, vb(L, false));\n\n\t\trep(j, N) {\n\t\t\trep(k, L - pat[j].size() + 1) {\n\t\t\t\tbool flag = true;\n\t\t\t\trep(l, pat[j].size()) {\n\t\t\t\t\tif (text[k + l] != pat[j][l]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tdp[1 << j][k + pat[j].size() - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trepl(i, 1, 1 << N) {\n\t\t\trep(j, N) {\n\t\t\t\tif ((i&(1 << j)) != 0) {\n\t\t\t\t\tif ((i ^ (1 << j)) == 0)continue;\n\n\t\t\t\t\trepl(k, 1, L - pat[j].size() + 1) {\n\t\t\t\t\t\tif (dp[(i ^ (1 << j))][k - 1]) {\n\t\t\t\t\t\t\tbool flag = true;\n\t\t\t\t\t\t\trep(l, pat[j].size()) {\n\t\t\t\t\t\t\t\tif (text[k + l] != pat[j][l]) {\n\t\t\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (flag) {\n\t\t\t\t\t\t\t\tdp[i][k + pat[j].size() - 1] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, L) {\n\t\t\tif (dp[(1 << N) - 1][i])ans++;\n\t\t}\n\t\t/*\n\t\trep(i, 1 << N) {\n\t\t\trep(j, L) {\n\t\t\t\tcout << \"xo\"[dp[i][j]];\n\t\t\t}\n\t\t\tcout << static_cast<std::bitset<3>>(i) << endl;\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n, m; cin >> n >> m, n;){\n        vector<string> elems(n), T(m);\n        for(auto& e : elems) cin >> e;\n        for(auto& e : T) cin >> e;\n\n        ll res = 0;\n        string t;\n        for(auto& e : T) t += e;\n        int len = t.size();\n        vector<set<int>> matched(len + 1);\n        rep(i, len){\n            rep(j, n){\n                string& e = elems[j];\n                if(t.substr(i, e.size()) == e){\n                    matched[i].insert(j);\n                }\n            }\n        }\n\n        vector<vector<bool>> dp(len + 1, vector<bool>(1 << n));\n        rep(i, len) dp[i][0] = true;\n        rep(i, len + 1){\n            rep(j, 1 << n){\n                if(not dp[i][j]) continue;\n                if(j == (1 << n) - 1){\n                    res++;\n                    continue;\n                }\n                for(auto& e : matched[i]){\n                    if((j >> e) & 1) continue;\n                    dp[i + elems[e].size()][j | (1 << e)] = true;\n                }\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nstring c[20];\nstring s;\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; j < c[i].size() ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; j < c[i].size() ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) A[i] = 0;\n\t\tfor(int i = 0 ; i < 20 ; i++) D[i] = 0;\n\t\tfor(int i = 0 ; i < 20 ; i++) c[i] = \"\";\n\t\t\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i];\n\t\t\tfor(int j = 0 ; j < c[i].size() ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += c[i].size();\n\t\t}\n\t\ts = \"\";\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < m ; i++){ \n\t\t\tstring t;cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint len = s.size();\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring t;\nint sum;\nint num_node;\nint myroot;\nchar buf[114514];\nstring des[114514];\nchar cs[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nint mynext[200000][256];\nbool dp[33000][5001];\nvector<int> matched[200000];\n\nbool Cmp(const string &a, const string &b) {\n  return a.size() > b.size();\n}\n\nint build_PMA(string *pats, int size) {\n  matched[num_node].resize(0);\n  for (int k=0; k<256; k++) mynext[num_node][k] = 0;\n  mynext[num_node][0] = num_node;\n  int root = num_node++;\n  for (int i=0; i<size; i++) {\n    int node = root;\n    for (int j=0; j<pats[i].size(); j++) {\n      char c = pats[i][j];\n      if (!mynext[node][c]) {\n        matched[num_node].resize(0);\n        for (int k=0; k<256; k++) mynext[num_node][k] = 0;\n        mynext[node][c] = num_node++;\n      }\n      node = mynext[node][c];\n    }\n    matched[node].push_back(i);\n  }\n\n  queue<int> q;\n  for (int i=0; i<52; i++) {\n    if (mynext[root][cs[i]]) {\n      mynext[mynext[root][cs[i]]][0] = root;\n      q.push(mynext[root][cs[i]]);\n    } else mynext[root][cs[i]] = root;\n  }\n\n  while (!q.empty()) {\n    int node = q.front(); q.pop();\n    for (int i=0; i<52; i++) {\n      if (mynext[node][cs[i]]) {\n        q.push(mynext[node][cs[i]]);\n        int failer = mynext[node][0];\n        while (!mynext[failer][cs[i]]) failer = mynext[failer][0];\n        mynext[mynext[node][cs[i]]][0] = mynext[failer][cs[i]];\n        if (mynext[node][cs[i]] != mynext[failer][cs[i]]) {\n          matched[mynext[node][cs[i]]].insert(matched[mynext[node][cs[i]]].end(), matched[mynext[failer][cs[i]]].begin(), matched[mynext[failer][cs[i]]].end());\n        }\n      }\n    }\n  }\n  return root;           \n}\n\n\nbool check(int idx) {\n  map<int, set<set<int> > > found;\n  int node = myroot;\n  found[idx] = set<set<int> >();\n  set<int> em;\n  found[idx].insert(em);\n  for (int i=idx; i<idx+sum; i++) {\n    while (!mynext[node][t[i]]) node = mynext[node][0];\n    node = mynext[node][t[i]];\n    if (!matched[node].empty()) {\n      for (int g : matched[node]) {\n        int prev = i+1-(int)des[g].size();\n        for (auto &st : found[prev]) {\n          //cout << \"st:\";\n          //for (auto a : st) cout << a << \" \";\n          //cout << \"\\n\";\n          if (!st.count(g)) {\n            //puts(\"pushed\");\n            set<int> nst(st);\n            nst.insert(g);\n            found[i+1].insert(nst);\n          }\n        }\n      }\n    }\n  }\n\n  return !found[idx+sum].empty();\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    sum = 0;\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n      sum += (int)des[i].size();\n    }\n    num_node = 1;\n    myroot = build_PMA(des, n);\n\n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n\n    int node = myroot;\n    int lim = 1 << n;\n    fill(dp[0], dp[lim], false);\n    for (int i=0; i<t.size(); i++) {\n      while (!mynext[node][t[i]]) node = mynext[node][0];\n      node = mynext[node][t[i]];\n      for (int g : matched[node]) {\n        for (int st=0; st<lim; st++) {\n          if (st >> g & 1) continue;\n          dp[st|(1<<g)][i+1] |= dp[st][i+1-des[g].size()];\n        }\n        dp[1<<g][i+1] = true;\n      }\n    }\n\n    int ans = 0;\n    for (int i=0; i<=t.size(); i++) {\n      if (dp[lim-1][i]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {+0,+1,+0,-1};//URDL\nint ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nbool dp[5500][1<<12];\n\nint main(){\n  int num_of_element_strings;\n  int num_of_lines;\n  while(~scanf(\"%d %d\",&num_of_element_strings,&num_of_lines)){\n    if(num_of_element_strings == 0 && num_of_lines == 0) break;\n\n    vector<string> elements;\n    for(int i = 0; i < num_of_element_strings; i++){\n      string tmp;\n      cin >> tmp;\n      elements.push_back(tmp);\n    }\n\n    string text;\n    for(int i = 0; i < num_of_lines; i++){\n      string tmp;\n      cin >> tmp;\n      text += tmp;\n    }\n\n    memset(dp,false,sizeof(dp));\n    for(int i = 0; i < elements.size(); i++){\n      int index = 0;\n      while(true){\n        int tmp = text.find_first_of(elements[i],index);\n        if(tmp == string::npos) break;\n        index = tmp + elements[i].size();\n        dp[index][1<<i] = true;\n      }\n    }\n\n    for(int text_i = 0; text_i < text.size(); text_i++){\n      for(int S = 0; S < (1<<elements.size()); S++){\n        for(int to = 0; to < elements.size(); to++){\n          if((S & (1<<to))) continue;\n          dp[text_i + elements[to].size()][S | (1<<to)]\n            |= (dp[text_i][S] && dp[text_i + elements[to].size()][1<<to]);\n            }\n      }\n    }\n    int res = 0;\n    for(int text_i = 0; text_i <= text.size(); text_i++){\n      res += dp[text_i][(1<<elements.size()) - 1];\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n\nll fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<string> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(s);\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].size();\n      }\n    }\n\n    string T;\n    rep(i, M) {\n      char s[5001]; cin >> s, T += s;\n    }\n\n    int TSize = T.size();\n \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(!T.compare(st + sizes[S], sizes[S|(1<<i)] - sizes[S], vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1] / (fact[vs.size()] / fact[se.size()]);\n    }\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\n\null StoH(string a){\n  ull res=0;\n  for(int i=0;i<a.size();i++)res=res*B+a[i];\n  return res;\n}\n\nvector<bool> search(string &a,string &key){\n  vector<bool> res(a.size(),0);\n  ull klen=key.size(),h=StoH(a.substr(0,klen)),target=StoH(key),t=1;\n  for(int i=0;i<klen;i++) t*=B;\n  for(int i=klen;i<a.size();i++){\n    if(h==target) res[i-klen]=1;\n    h = h*B+a[i]-a[i-klen]*t;\n  }\n  if(h==target) res[a.size()-klen] = 1;\n  return res;\n}\n\nint n,m,len;\nstring e[12];\nvector<bool> es[12];\nbool used[12],used2[12][5001];\n\nbool check(int idx,int cnt){\n  if(cnt==n) return 1;\n  if(used2[cnt][idx])return 0;\n  used2[cnt][idx]=1;\n\n  for(int i=0;i<n;i++){\n    if(used[i]||!es[i][idx])continue;\n    used[i]=1;\n    if(check(idx+e[i].size(),cnt+1)) return 1;\n    used[i]=0;\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n\n    if(!n&&!m)break;\n    len=0;\n    for(int i=0;i<n;i++)cin>>e[i],len+=e[i].size();\n  \n    string mp;\n    for(int i=0;i<m;i++){\n      string tmp;\n      cin>>tmp;\n      mp+=tmp;\n    }\n    for(int i=0;i<n;i++)es[i]=search(mp,e[i]);\n    int ans=0;\n    for(int i=0;i<mp.size()-len+1;i++){\n      memset(used,0,sizeof(used));\n      memset(used2,0,sizeof(used2));\n      if(check(i,0)) ans++;\n    }\n\n    cout<<ans<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \ninline long long to_int64(char x) {\n  return (long long)x;\n}\n  \nstruct RollingHash {\n    \n  const array<int, 2> mods = {{int(1e9+7), int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 2> Ks = {{1007, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n  \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n  \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n  \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n  \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n   \n  RollingHash(string const& s) {\n    S = s;\n    N = s.size();\n    construct();\n  }\n  \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n\n  bool same(int a_start, int a_end, int b_start, int b_end, RollingHash const& rh) const {\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh.get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n};\n \nint fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<RollingHash> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(RollingHash(s));\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      char s[5001]; cin >> s, t += s;\n    }\n\n    RollingHash T(t);\n    int TSize = t.size();\n \n    ll sum = 0;\n    rep(st, TSize) {\n      int dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i].N, vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nvector<string> elms;\nstring text;\nbool cors[51][5010];\nbool memo[5010][1<<12];\n\nbool dfs(int si, int s, int l){\n    if(s == (1<<N)-1) return true;\n    if(memo[si][s]) return false;\n    \n    for(int i=0; i<N; i++) if((s>>i&1) == 0){\n        if(cors[i][si] && dfs(si+(int)elms[i].size(), s|(1<<i), l+(int)elms[i].size()))\n            return true;\n    }\n    memo[si][s] = true;\n    return false;\n}\n\nvoid solve(){\n    memset(cors, 0, sizeof(cors));\n    memset(memo, 0, sizeof(memo));\n    for(int i=0; i<N; i++){\n        string elm = elms[i];\n        for(int j=0; j<text.size(); j++){\n            if(text.substr(j, elm.size()) == elm)\n                cors[i][j] = true;\n        }\n    }\n    int ans = 0;\n    for(int i=0; i<text.size(); i++){\n        ans += dfs(i, 0, 0);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>N>>M, N|M){\n        elms.resize(N);\n        for(auto &s: elms) cin >> s;\n        text = \"\";\n        for(int i=0; i<M; i++){\n            string t; cin >> t;\n            text += t;\n        }\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct KMP{\n\tstring pat;\n\tvi fail;\n\tKMP(const string& p):pat(p),fail(p.size()+1){\n\t\tfail[0]=-1;\n\t\tfor(int i=0,j=-1;i<pat.size();){\n\t\t\twhile(j>=0 && pat[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tfail[i]=j;\n\t\t}\n\t}\n\tint Match(const string& text){\n\t\tfor(int i=0,j=0;i<text.size();){\n\t\t\twhile(j>=0 && text[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tif(j==pat.size())\n\t\t\t\treturn i-j;\n\t\t}\n\t\treturn -1;\n\t}\n\tvi MatchAll(const string& text){\n\t\tvi res;\n\t\tfor(int i=0,j=0;i<text.size();){\n\t\t\twhile(j>=0 && text[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tif(j==pat.size()){\n\t\t\t\tres.push_back(i-j);\n\t\t\t\tj=fail[j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<vvb> vvvb;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvs ps(n);\n\t\trep(i,n) cin>>ps[i];\n\t\tstring t;\n\t\trep(i,m){\n\t\t\tstring x; cin>>x;\n\t\t\tt+=x;\n\t\t}\n\t\tvvi ms(n);\n\t\trep(i,n) ms[i]=KMP(ps[i]).MatchAll(t);\n\t\t\n\t\tm=t.size();\n\t\tvvvb dp(1<<n,vvb(n,vb(m+1)));\n\t\trep(i,n) rep(j,ms[i].size()) dp[1<<i][i][ms[i][j]+ps[i].size()]=1;\n\t\trep(i,1<<n) rep(j,n) if(i>>j&1) rep(k,n) if(!(i>>k&1)){\n\t\t\trep(l,ms[k].size()) if(dp[i][j][ms[k][l]])\n\t\t\t\tdp[i|1<<k][k][ms[k][l]+ps[k].size()]=1;\n\t\t}\n\t\t\n\t\tvi res(m+1);\n\t\trep(i,n) rep(j,m+1) res[j]|=dp.back()[i][j];\n\t\tcout<<accumulate(all(res),0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint edge[5001][13];\n\nbool same(string a,string b,int len,int v){\n\tif(a.size()<len || b.size()<len+v)return false;\n\ta=a.substr(0,v);\n\tb=b.substr(len,v);\n\treturn (a==b);\n}\n\nvoid KMP(string text,string pattern,int v){\n\tint textN=text.size();\n\tint patternN=pattern.size();\n\tvector<int> next(patternN+1,0);\n\tnext[0]=1;\n\tfor(int i=1;i<=patternN;i++){\n\t\tstring s=pattern.substr(0,i);\n\t\tint len=1;\n\t\twhile(i-len>0 && !same(s,pattern,len,i-len))len++;\n\t\tnext[i]=len;\n\t}\n\tint cnt=0;\n\tint tp=0,pp=0;\n\twhile(tp<textN){\n\t\tif(text[tp]==pattern[pp]){\n\t\t\ttp++;\n\t\t\tpp++;\n\t\t}else{\n\t\t\tpp-=next[pp];\n\t\t\tif(pp<0){\n\t\t\t\ttp++;\n\t\t\t\tpp++;\n\t\t\t}\n\t\t}\n\t\tif(pp==patternN){\n\t\t\tedge[tp-pattern.size()][v]=1;\n\t\t}\n\t}\n}\n\nint n,m;\nstring e[13];\nstring text;\nbool dp[5001][1<<12];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> e[i];\n\t\t}\n\t\ttext=\"\";\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext+=str;\n\t\t}\n\t\tmemset(edge,0,sizeof(edge));\n\t\tint len=text.size();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tKMP(text,e[i],i);\n\t\t}\n\t\tmemset(dp,false,sizeof(dp));\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tif(i==0)dp[j][i]=true;\n\t\t\t\tif(i==((1<<n)-1)){\n\t\t\t\t\tres+=dp[j][i]?1:0;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(edge[j][k]==1 && (!((i>>k) & 1))){\n\t\t\t\t\t\tdp[j+e[k].size()][i|(1<<k)]|=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    string e[n],t[m];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<m;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<m;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<int,map<ull,set<int> > > m;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==n){\n\tint k=__builtin_popcountll(c);\n\tif(k!=x&&k!=y) return;\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\treturn;\n      }\n      dfs(d+1,c,s);\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(auto &a:m){\n\tint l=a.first;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tauto &p=a.second;\n\tif(!p.count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=p[u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<ull,set<int> > m[400];\n    function<void(int,int,string&)> dfs=[&](int d,int c,string& s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tfor(int j=0;j<(int)e[i].size();j++)\n\t  s.push_back(e[i][j]);\n\tdfs(d+1,c+(1LL<<i),s);\n\tfor(int j=0;j<(int)e[i].size();j++)\n\t  s.pop_back();\n      }\n    };\n    string tmp=\"\";\n    dfs(0,0,tmp);\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!m[l].count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=m[l][u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 1000000007;\n\nint solve(vector<string> & ss, string & t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<ull> shash(n);\n    rep(i,n){\n        ull x = 0;\n        rep(j,ss[i].size()){\n            x = x*B + ss[i][j];\n        }\n        shash[i] = x;\n    }\n    vector<ull> pow(len+1), thash(len+1);\n    pow[0] = 1;\n    thash[0] = 0;\n    rep(i,len){\n        pow[i+1] = pow[i]*B;\n        thash[i+1] = thash[i]*B + t[i];\n    }\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+ss[i].size() > t.size()) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+ss[i].size()] - thash[pos] * pow[ss[i].size()];\n                if(h1 != h2) continue;\n                dp[pos+ss[i].size()][mask|1<<i] = t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef unsigned long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, l, len[12], s;\nchar a[12][30], in[5010];\nll pw[5010], h[5010], ha[12][30];\nbool v[1 << 12];\n\nbool rec(int pos, int bit, ll ch, int cl){\n\tif(v[bit]) return 0;\n\tv[bit] = 1;\n\tif(bit == (1 << n) - 1) return 1;\n\trep(i, n) if(!(bit & 1 << i)){\n\t\tll nh = ch + pw[cl] * ha[i][len[i]];\n\t\tint nl = cl + len[i];\n\t\tif(h[pos + nl] - h[pos] != nh * pw[pos]) continue;\n\t\tif(rec(pos, bit | 1 << i, nh, nl)) return 1;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tpw[0] = 1;\n\trep(i, 5009) pw[i + 1] = pw[i] * 29;\n\t\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\ts = 0;\n\t\trep(i, n){\n\t\t\tscanf(\"%s\", a + i);\n\t\t\ts += (len[i] = strlen(a[i]));\n\t\t\trep(j, len[i]) ha[i][j + 1] = ha[i][j] + (a[i][j] - 'a' + 1) * pw[j];\n\t\t}\n\t\tl = 0;\n\t\trep(i, m){\n\t\t\tscanf(\"%s\", in + l);\n\t\t\tl += strlen(in + l);\n\t\t}\n\t\trep(i, l) h[i + 1] = h[i] + (in[i] - 'a' + 1) * pw[i];\n\t\t\n\t\tint ans = 0;\n\t\trep(i, l - s + 1){\n\t\t\tmemset(v, 0, sizeof(v));\n\t\t\tif(rec(i, 0, 0, 0)) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef int_t hash_t;\n    int_t base1;\n    int_t mod1;\n    static int_t hash1[6000];\n    static int_t pow1[6000];\n    RollingHash() : base1(1009), mod1(1000000007) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1[0] = 0;\n        pow1[0] = 1;\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        return t1;\n    }\n};\nRollingHash::int_t RollingHash::hash1[6000];\nRollingHash::int_t RollingHash::pow1[6000];\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<RollingHash::hash_t> hs(n);\n    RollingHash rh;\n    rep(i,n){\n        rh.init(ss[i]);\n        hs[i] = rh.get(0,ss[i].size());\n    }\n    rh.init(t);\n\n    memset(dp,false,sizeof(dp));\n    rep(i,5000) dp[i][0] = true;\n    rep(pos,len){\n        rep(i,n){\n            rep(mask,1<<n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    if(pos+ss[i].size() > t.size()) continue;\n                    if(rh.get(pos,pos+ss[i].size()) != hs[i]) continue;\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct KMP {\n  int len;\n  string p;\n  vector<int> fail;\n  KMP() {}\n  KMP(string p_) : p(p_), len(p_.length()) {\n    fail.resize(len + 1, -1);\n    for(int i=1, j=-1; i<=len; i++) {\n      while(j >= 0 and p[j] != p[i-1]) j = fail[j];\n      fail[i] = ++j;\n    }\n\n    /*\n    fprintf(stderr, \"fail:\");\n    for(int i=0; i<len+1; i++) {\n      fprintf(stderr, \" %d\", fail[i]);\n    }\n    fprintf(stderr, \"\\n\");\n    */\n  }\n\n  vector<int> match(string s) {\n    int N = s.length();\n    vector<int> occur(N);\n    for(int i=0, k=0; i<N; i++) {\n      // fprintf(stderr, \"s = %s, i = %d, k = %d\\n\", s.c_str(), i, k);\n      while(k >= 0 and s[i] != p[k]) k = fail[k];\n      if(++k == len) {\n        // fprintf(stderr, \"occur: %d\\n\", i - len + 1);\n        occur[i-len+1] = true;\n      }\n    }\n    return occur;\n  }\n};\n\nint main() {\n  int N, M;\n  while(cin >> N >> M, N || M) {\n    vector<string> pat(N);\n    vector<KMP> kmps(N);\n    for(int i=0; i<N; i++) cin >> pat[i], kmps[i] = KMP(pat[i]);\n\n    string s = \"\";\n    for(int i=0; i<M; i++) {\n      string tmp; cin >> tmp;\n      s += tmp;\n    }\n    \n    // fprintf(stderr, \"before match\\n\");\n    int len = s.length();\n    vector< vector<int> > match(N);\n    for(int i=0; i<N; i++) match[i] = kmps[i].match(s);\n\n    /*\n    // for debug\n    for(int i=0; i<N; i++) {\n      for(int j=0; j<len; j++) {\n        fprintf(stderr, \"%d \", match[i][j]);\n      }\n      fprintf(stderr, \"\\n\");\n    }\n    */\n\n    vector<int> lens(1 << N);\n    for(int bit=0; bit<(1<<N); bit++) {\n      for(int i=0; i<N; i++) {\n        if(bit >> i & 1) lens[bit] += pat[i].length();\n      }\n    }\n\n    int whole_len = lens[(1 << N) - 1], ans = 0;\n    for(int i=0; i<len-whole_len+1; i++) {\n      vector<int> dp(1 << N);\n      dp[0] = true;\n      for(int bit=0; bit<(1<<N); bit++) {\n        int cur_idx = i + lens[bit];\n        for(int i=0; i<N; i++) {\n          if(bit >> i & 1) continue;\n          int nbit = bit | (1 << i);\n          if(match[i][cur_idx]) dp[nbit] |= dp[bit];\n        }\n      }\n\n      if(dp[(1 << N) - 1]) {\n        // fprintf(stderr, \"match %d\\n\", i);\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N) {\n    string S[12], T;\n    int sum = 0;\n    for(int i = 0; i < N; i++) cin >> S[i], sum += S[i].size();\n    for(int i = 0; i < M; i++) {\n      string q;\n      cin >> q;\n      T += q;\n    }\n\n    int pos[1 << 12] = {};\n    for(int i = 0; i < 1 << N; i++) {\n      for(int j = 0; j < N; j++) if((i >> j) & 1) pos[i] += S[j].size();\n    }\n\n    long long ret = 0LL;\n    for(int i = 0; i <= (int) T.size() - sum; i++) {\n      bool dp[1 << 12] = {};\n      dp[0] = true;\n      for(int j = 0; j < 1 << N; j++) {\n        if(!dp[j]) continue;\n        for(int k = 0; k < N; k++) {\n          if((j >> k) & 1) continue;\n          dp[j | (1 << k)] |= [&]()\n          {\n            for(int l = 0; l < S[k].size(); l++) {\n              if(S[k][l] != T[i + l + pos[j]]) return (false);\n            }\n            return (true);\n          }();\n        }\n      }\n      ret += dp[(1 << N) - 1];\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\nstring e[12],T;\nint n;\n\nbool dfs(int x,bool f[]){\n\tbool r=true;\n\tfor(int i=0;i<n;++i){\n\t\tif(!f[i]){\n\t\t\tr=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(r||x==T.size()){\n\t\treturn r;\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tif(f[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(T.substr(x,e[i].size())!=e[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tf[i]=true;\n\t\tif(dfs(x+e[i].size(),f)){\n\t\t\treturn true;\n\t\t}\n\t\tf[i]=false;\n\t}\n\treturn false;\n}\n\nvoid solve(int m){\n\tint ans=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t}\n\tT.clear();\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\t\n\tfor(int j=0;j<T.size();++j){\n\t\tbool f[12];\n\t\tfill(f,f+n,false);\n\t\tif(dfs(j,f)){\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nvector<string> elms;\nstring text;\nvector<vector<int>> cors;\nset<pair<int, int>> memo;\n\nbool dfs(int si, int s, int l){\n    if(s == (1<<N)-1) return true;\n    if(memo.count(make_pair(si, s))) return false;\n    \n    for(int i=0; i<N; i++) if((s>>i&1) == 0){\n        if(binary_search(cors[i].begin(), cors[i].end(), si))\n            if(dfs(si+(int)elms[i].size(), s|(1<<i), l+(int)elms[i].size()))\n                return true;\n    }\n    memo.insert(make_pair(si, s));\n    return false;\n}\n\nvoid solve(){\n    cors.clear(); cors.resize(N);\n    memo.clear();\n    for(int i=0; i<N; i++){\n        string elm = elms[i];\n        for(int j=0; j<text.size(); j++){\n            if(text.substr(j, elm.size()) == elm)\n                cors[i].push_back(j);\n        }\n    }\n    int ans = 0;\n    for(int i=0; i<text.size(); i++){\n        ans += dfs(i, 0, 0);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>N>>M, N|M){\n        elms.resize(N);\n        for(auto &s: elms) cin >> s;\n        text = \"\";\n        for(int i=0; i<M; i++){\n            string t; cin >> t;\n            text += t;\n        }\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nstring c[20];\nstring s;\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i];\n\t\t\tfor(int j = 0 ; j < c[i].size() ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += c[i].size();\n\t\t}\n\t\ts = \"\";\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring t;cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint len = s.size();\n\t\tif( len > 5000 ) assert(0);\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring e[12];\nint idx[5010];\nbool dp[5010][1 << 12];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tmap<string, int> sm;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> e[i];\n\t\t\tsm[e[i]]++;\n\t\t}\n\t\tstring s;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint L = s.size();\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tidx[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint len = e[i].length();\n\t\t\tfor(int j = 0; j + len <= L; j++){\n\t\t\t\tif(e[i] == s.substr(j, len)) idx[j] |= 1 << i;\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int i = 0; i < L + 1; i++){\n\t\t\tdp[i][0] = true;\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < 1 << n; j++){\n\t\t\t\tif(!dp[i][j]) continue;\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(idx[i] >> k & 1){\n\t\t\t\t\t\tif(j >> k & 1) continue;\n\t\t\t\t\t\tint len = e[k].length();\n\t\t\t\t\t\tdp[i + len][j | (1 << k)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i <= L; i++){\n\t\t\tans += dp[i][(1 << n) - 1];\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 1000000007;\n\nint solve(vector<string> & ss, string & t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<ull> shash(n);\n    rep(i,n){\n        ull x = 0;\n        rep(j,ss[i].size()){\n            x = x*B + ss[i][j];\n        }\n        shash[i] = x;\n    }\n    vector<ull> pow(len+1), thash(len+1);\n    pow[0] = 1;\n    thash[0] = 0;\n    rep(i,len){\n        pow[i+1] = pow[i]*B;\n        thash[i+1] = thash[i]*B + t[i];\n    }\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+ss[i].size() > t.size()) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+ss[i].size()] - thash[pos] * pow[ss[i].size()];\n                // if(h1 != h2) continue;\n                dp[pos+ss[i].size()][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int LLNF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct RollingHash{\n\tstring str;\n\tlong long int base,mod;\n\tvector<long long int> hash,pow; //hash[i]:=[0,i)のハッシュ\n\t\n\tRollingHash(string str,long long int base,long long int mod):str(str),base(base),mod(mod){\n\t\tint size=str.size();\n\t\thash=vector<long long int>(size+1);\n\t\tpow=vector<long long int>(size+1);\n\n\t\thash[0]=0;\n\t\tpow[0]=1;\n\t\tfor(int i=1; i<size+1; ++i){\n\t\t\tpow[i]=pow[i-1]*base%mod;\n\t\t\thash[i]=(hash[i-1]*base+str[i-1])%mod;\n\t\t}\n\t}\n\n\tinline long long int Hash(int l,int r){ //[l,r)\n\t\treturn (hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\n\t}\n};\n\ninline long long Hash(string str,long long int base,long long int mod){\n\tlong long int res=0;\n\tfor(int i=0; i<str.size(); ++i){\n\t\tres=(res*base+str[i])%mod;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint n,m;\n\t\tstring e[12],t;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\trep(i,0,n) cin >> e[i];\n\t\trep(i,0,m){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tt+=tmp;\n\t\t}\n\t\n\t\tconst int base=993,mod=20000003;\n\t\tRollingHash t_hash(t,base,mod);\n\t\tstatic int count[mod];\n\t\tfill_n((int*)count,mod,0);\n\t\trep(i,1,t.size()+1) for(int j=0; j+i<=t.size(); ++j) ++count[t_hash.Hash(j,j+i)];\n\t\t\n\t\tint ans=0;\n\t\tstatic bool done[mod];\n\t\tfill_n((int*)done,mod,0);\n\t\tvector<int> perm(n);\n\t\trep(i,0,n) perm[i]=i;\n\t\tdo{\n\t\t\tstring str; \n\t\t\trep(i,0,n) str+=e[perm[i]];\n\t\t\tll x=Hash(str,base,mod);\n\t\t\tif(done[x]) continue;\n\t\t\tdone[x]=true;\n\t\t\tans+=count[x];\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int LLNF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct RollingHash{\n\tstring str;\n\tlong long int base,mod;\n\tvector<long long int> hash,pow; //hash[i]:=[0,i)のハッシュ\n\t\n\tRollingHash(string str,long long int base,long long int mod):str(str),base(base),mod(mod){\n\t\tint size=str.size();\n\t\thash=vector<long long int>(size+1);\n\t\tpow=vector<long long int>(size+1);\n\n\t\thash[0]=0;\n\t\tpow[0]=1;\n\t\tfor(int i=1; i<size+1; ++i){\n\t\t\tpow[i]=pow[i-1]*base%mod;\n\t\t\thash[i]=(hash[i-1]*base+str[i-1])%mod;\n\t\t}\n\t}\n\n\tinline long long int Hash(int l,int r){ //[l,r)\n\t\treturn (hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\n\t}\n};\n\ninline long long Hash(string str,long long int base,long long int mod){\n\tlong long int res=0;\n\tfor(int i=0; i<str.size(); ++i){\n\t\tres=(res*base+str[i])%mod;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint n,m;\n\t\tstring e[12],t;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\trep(i,0,n) cin >> e[i];\n\t\trep(i,0,m){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tt+=tmp;\n\t\t}\n\t\n\t\tconst int base=9973,mod=12000017;\n\t\tRollingHash t_hash(t,base,mod);\n\t\tstatic int count[mod];\n\t\tfill_n((int*)count,mod,0);\n\t\trep(i,1,t.size()+1) for(int j=0; j+i<=t.size(); ++j) ++count[t_hash.Hash(j,j+i)];\n\t\t\n\t\tint ans=0;\n\t\tstatic bool done[mod];\n\t\tfill_n((bool*)done,mod,0);\n\t\tvector<int> perm(n);\n\t\trep(i,0,n) perm[i]=i;\n\t\tdo{\n\t\t\tstring str; \n\t\t\trep(i,0,n) str+=e[perm[i]];\n\t\t\tll x=Hash(str,base,mod);\n\t\t\tif(done[x]) continue;\n\t\t\tdone[x]=true;\n\t\t\tans+=count[x];\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <double,double> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {+0,+1,+0,-1};//URDL\nint ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nbool dp[5500][1<<12];\n\nint main(){\n  int num_of_element_strings;\n  int num_of_lines;\n  while(~scanf(\"%d %d\",&num_of_element_strings,&num_of_lines)){\n    if(num_of_element_strings == 0 && num_of_lines == 0) break;\n\n    vector<string> elements;\n    for(int i = 0; i < num_of_element_strings; i++){\n      string tmp;\n      cin >> tmp;\n      elements.push_back(tmp);\n    }\n\n    string text= \"\";\n    for(int i = 0; i < num_of_lines; i++){\n      string tmp;\n      cin >> tmp;\n      text += tmp;\n    }\n\n    memset(dp,false,sizeof(dp));\n    for(int i = 0; i < elements.size(); i++){\n      int next = 0;\n      while(true){\n        int current = text.find(elements[i],next);\n        if(current == string::npos) break;\n        dp[current + elements[i].size()][1<<i] = true;\n        next = current + 1;\n      }\n    }\n\n    for(int text_i = 0; text_i < text.size(); text_i++){\n      for(int S = 0; S < (1<<elements.size()); S++){\n        if(!dp[text_i][S]) continue;\n        for(int to = 0; to < elements.size(); to++){\n          if((S & (1<<to))) continue;\n          dp[text_i + elements[to].size()][S | (1<<to)] \n            |= dp[text_i + elements[to].size()][(1<<to)];\n            }\n      }\n    }\n    int res = 0;\n    for(int text_i = 0; text_i <= text.size(); text_i++){\n      if(dp[text_i][(1<<elements.size()) - 1]) res++;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint n, m;\nint bs;string b[12];\nstring in,s;\n\nqueue<int> q;\nbool used[1 << 12];\nint len[1 << 12];\nbool valid(int le) {\n\trep(i, (1 << n)) {\n\t\tused[i] = false;\n\t}\n\tq.push(0); used[0] = true;\n\twhile (!q.empty()) {\n\t\tint p = q.front(); q.pop();\n\t\trep(i, n) {\n\t\t\tif (p&(1 << i))continue;\n\t\t\tstring u = s.substr(le + len[p], b[i].length());\n\t\t\tif (u == b[i]) {\n\t\t\t\tint np = p ^ (1 << i);\n\t\t\t\tif (!used[np]) {\n\t\t\t\t\tused[np] = true; q.push(np);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn used[(1<<n)-1];\n}\nvoid init() {\n\tbs = 0; s.clear();\n\trep(i, 1 << n) {\n\t\tlen[i] = 0;\n\t}\n}\nint main() {\n\twhile (cin >> n >> m,n) {\n\t\tinit();\n\t\trep(i, n) {\n\t\t\tcin >> in; bs += in.length(); b[i] = in;\n\t\t}\n\t\trep(i, (1 << n)) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i&(1 << j)) {\n\t\t\t\t\tlen[i] += b[j].length();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, m) {\n\t\t\tcin >> in; s += in;\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, s.length() - bs + 1) {\n\t\t\tif (valid(i))ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n,m;\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<string> e(n);\n    for(int i=0;i<n;i++){\n      cin >> e[i];\n    }\n    string s,t=\"\";\n    for(int i=0;i<m;i++){\n      cin >> s;\n      t+=s;\n    }\n    m=t.length();\n    vector<vector<bool>> dp(m+1,vector<bool>(1<<n,false));\n    int ans=0;\n    for(int i=0;i<m;i++){\n      if(dp[i][(1<<n)-1]) ans++;\n      dp[i][0]=true;\n      for(int j=0;j<n;j++){\n        if(i+e[j].length()>m) continue;\n        for(int k=0;k<e[j].length();k++){\n          if(t[i+k]!=e[j][k]) goto next;\n        }\n        for(int k=0;k<(1<<n);k++){\n          if(!(k&(1<<j))){\n            if(dp[i][k]) dp[i+e[j].length()][k+(1<<j)]=true;\n          }\n        }\n        next:\n        continue;\n      }\n    }\n    if(dp[m][(1<<n)-1]) ans++;\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    int count=0;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tcount++;\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring e[12];\nvector<int> idx[5010];\nll dp[5010][1 << 12];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tmap<string, int> sm;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> e[i];\n\t\t\tsm[e[i]]++;\n\t\t}\n\t\tstring s;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint L = s.size();\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tidx[i].clear();\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint len = e[i].length();\n\t\t\tfor(int j = 0; j + len <= L; j++){\n\t\t\t\tif(e[i] == s.substr(j, len)) idx[j].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int i = 0; i < L + 1; i++){\n\t\t\tdp[i][0] = 1;\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < 1 << n; j++){\n\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\tfor(auto use : idx[i]){\n\t\t\t\t\tif(j >> use & 1) continue;\n\t\t\t\t\tint len = e[use].length();\n\t\t\t\t\tdp[i + len][j | (1 << use)] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i <= L; i++){\n\t\t\tans += dp[i][(1 << n) - 1];\n\t\t}\n\t\tfor(auto v : sm){\n\t\t\tif(v.second >= 2){\n\t\t\t\tfor(int i = 2; i <= v.second; i++){\n\t\t\t\t\tans /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n\nint n, m, L, len[12];\nstring e[12], T;\n\nbool match[12][5050], dp[5050][1<<12];\n\nvoid solve() {\n\tmemset(dp, 0, sizeof(dp));\n\t\n\tfor (int i=0; i<n; ++i) {\n\t\tfor (int j=0; j<=L-len[i]; ++j) {\n\t\t\tmatch[i][j] = true;\n\t\t\tfor (int x=0; x<len[i]; ++x) match[i][j] &= (e[i][x] == T[j+x]);\n\t\t\tdp[j+len[i]][1<<i] = match[i][j];\n\t\t}\n\t}\n\t\n\tfor (int i=0; i<L; ++i) for (int S=0; S<(1<<n); ++S) {\n\t\tif (!dp[i][S]) continue;\n\t\tfor (int j=0; j<n; ++j) {\n\t\t\tif ((S>>j) & 1) continue;\n\t\t\tif (match[j][i]) dp[i+len[j]][S | (1<<j)] = true;\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i=0; i<=L; ++i) if (dp[i][(1<<n)-1]) ++ans;\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m, n>0) {\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> e[i];\n\t\t\tlen[i] = e[i].size();\n\t\t}\n\t\t\n\t\tT = \"\";\n\t\tstring str;\n\t\tfor (int i=0; i<m; ++i) {\n\t\t\tcin >> str;\n\t\t\tT += str;\n\t\t}\n\t\tL = T.size();\n\t\t\t\t\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring t;\nchar buf[114514];\nstring des[114514];\nchar cs[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nbool dp[1 << 12][5001];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n    }\n\n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n\n    int lim = 1 << n;\n    fill(dp[0], dp[lim], false);\n    for (int i=0; i<t.size(); i++) {\n      for (int g=0; g<n; g++) {\n        int prev = i+1-des[g].size();\n        if (t.substr(prev, des[g].size()) != des[g]) continue;\n\n        for (int st=0; st<lim; st++) {\n          if (st >> g & 1) continue;\n          dp[st|(1<<g)][i+1] |= dp[st][prev];\n        }\n        dp[1<<g][i+1] = true;\n      }\n    }\n\n    int ans = 0;\n    for (int i=0; i<=t.size(); i++) {\n      if (dp[lim-1][i]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<ull,set<short> > m[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\t//assert(m[s.size()][rh.find(0,s.size())].size()==1);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!m[l].count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<short> &si=m[l][u];\n\tset<short> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  short k=(~j)&((1<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvoid KMP_build(const char *pttn,int *fail){\n\tint n=strlen(pttn);\n\tfail[0]=-1;\n\tfor(int i=1,j=-1;i<=n;i++){\n\t\twhile(j>=0 && pttn[j]!=pttn[i-1]) j=fail[j];\n\t\tfail[i]=++j;\n\t}\n}\n\nvoid KMP_search(const char *s,const char *pttn,const int *fail,bool *res){\n\tint m=strlen(s),n=strlen(pttn),j=0;\n\trep(i,m){\n\t\twhile(j>=0 && s[i]!=pttn[j]) j=fail[j];\n\t\tj++;\n\t\tif(j==n){\n\t\t\tres[i-n+1]=true;\n\t\t\tj=fail[j];\n\t\t}\n\t}\n}\n\nint L; // s の長さ\n\nint n,len[12];\nbool check[12][5000]; // check[i][j] := ( s[j..j+len[i]) == key[i] )\n\nchar dp[5000][1<<12]; // メモリ節約のため char\nbool dfs(int x,int S){\n\tif(S==(1<<n)-1) return true;\n\tif(x>=L) return false;\n\n\tif(dp[x][S]!=-1) return dp[x][S];\n\n\trep(i,n) if(check[i][x] && (S>>i&1)==0 && dfs(x+len[i],S|1<<i)) return dp[x][S]=true;\n\treturn dp[x][S]=false;\n}\n\nint main(){\n\tfor(int m;scanf(\"%d%d\",&n,&m),n;){\n\t\tchar key[12][32];\n\t\trep(i,n) scanf(\"%s\",key[i]), len[i]=strlen(key[i]);\n\n\t\tL=0;\n\t\tchar s[5001];\n\t\trep(i,m){\n\t\t\tscanf(\"%s\",s+L);\n\t\t\tL+=strlen(s+L);\n\t\t}\n\n\t\trep(i,n){\n\t\t\trep(x,L) check[i][x]=false;\n\t\t\tint fail[5001];\n\t\t\tKMP_build(key[i],fail);\n\t\t\tKMP_search(s,key[i],fail,check[i]);\n\t\t}\n\n\t\tint ans=0;\n\t\tmemset(dp,-1,sizeof dp);\n\t\trep(x,L) if(dfs(x,0)) ans++;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    string e[n],t[m];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<m;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<m;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<int,map<ull,set<int> > > m;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    /*\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(auto &a:m){\n\tint l=a.first;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tauto &p=a.second;\n\tif(!p.count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=p[u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 5001\ntypedef unsigned long long ull;\null B=9999973;\n\nint n,m;\nstring a[12];\null b[12];\n\nvector<int> G[MAX];\nbool dp[MAX][(1<<12)];\nstring s,tmp;\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)break;\n    for(int i=0;i<MAX;i++)G[i].clear();\n    memset(b,0,sizeof(b));\n    memset(dp,0,sizeof(dp));\n    s=\"\";\n    for(int i=0;i<n;i++){\n      cin>>a[i];\n      for(int j=0;j<(int)a[i].size();j++)\n        b[i]=b[i]*B+a[i][j];\n    }\n    for(int i=0;i<m;i++)cin>>tmp,s+=tmp;\n\n    for(int i=0;i<n;i++){\n      int size=a[i].size();\n      ull C=1,key=0;\n      for(int j=0;j<(int)s.size();j++){\n        key=key*B+s[j];\n        if(j-size>=0)key-=s[j-size]*C;\n        else C*=B;\n        if(key==b[i])G[j-size+1].push_back(i);\n      }\n    }\n\n    ull ans=0;\n    for(int i=0;i<(int)s.size();i++){\n      dp[i][0]=true;\n      for(int S=0;S<(1<<n);S++){\n        if(dp[i][S]==false)continue;\n        for(int j=0;j<(int)G[i].size();j++){\n          int id=G[i][j];\n          int size=a[id].size();\n          if(S>>id&1)continue;\n          dp[i+size][S|(1<<id)]=true;\n        }\n      }\n      ans+=dp[i][(1<<n)-1];\n    }\n    if(dp[s.size()][(1<<n)-1])ans++;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct RollingHash{\n    static const int MD = 3;\n    static const vector<ll> hash_base, hash_mod;\n\n    int n;\n    vector<ll> hs[MD], pw[MD];\n\n    RollingHash(){}\n    RollingHash(const string &s){\n        n = s.size();\n        rep(i,MD){\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            rep(j,n){\n                pw[i][j+1] = pw[i][j]*hash_base[i] % hash_mod[i];\n                hs[i][j+1] = (hs[i][j]*hash_base[i]+s[j]) % hash_mod[i];\n            }\n        }\n    }\n\n    // 1-index\n    ll hash_value(int l, int r, int i){\n        return ((hs[i][r] - hs[i][l]*pw[i][r-l])%hash_mod[i]+hash_mod[i])%hash_mod[i];\n    }\n\n    bool match(int l1, int r1, int l2, int r2){\n        bool ret = true;\n        rep(i,MD) ret &= (hash_value(l1-1,r1,i) == hash_value(l2-1,r2,i));\n        return ret;\n    }\n\n    vector<ll> calc(int l, int r){\n        vector<ll> ret(MD);\n        rep(i,MD) ret[i]=hash_value(l-1,r,i);\n        return ret;\n    }\n};\nconst vector<ll> RollingHash::hash_base{1009,1021,1013};\nconst vector<ll> RollingHash::hash_mod{1000000009,1000000007,1000000021};\n\nconst int N = 1<<12;\nbool dp[N];\nint len[N];\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n){\n        vector<string> s(n);\n        rep(i,n) cin >>s[i];\n\n        string t=\"\";\n        while(m--){\n            string tmp;\n            cin >>tmp;\n            t += tmp;\n        }\n\n        vector<int> sz(n);\n        int S = 0;\n        rep(i,n){\n            sz[i] = s[i].size();\n            S += sz[i];\n        }\n        int T = t.size();\n        // S <= 240, T <= 5000\n\n        vector<RollingHash> hs(n);\n        rep(i,n) hs[i] = RollingHash(s[i]);\n        RollingHash ht(t);\n\n        rep(mask,1<<n){\n            len[mask] = 0;\n            rep(i,n)if(mask>>i&1) len[mask] += s[i].size();\n        }\n\n        int ans = 0;\n        rep(i,T-S+1){\n            fill(dp,dp+N,false);\n            dp[0] = true;\n            rep(mask,1<<n)if(dp[mask]){\n                rep(j,n)if(!(mask>>j&1)){\n                    int nx = mask | (1<<j);\n                    if(hs[j].calc(1, sz[j]) == ht.calc(1+i+len[mask], 1+i+len[nx]-1)) dp[nx] = true;\n                }\n            }\n\n            if(dp[(1<<n)-1]) ++ans;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nstring S;\nstring ks[13];\n\nint sc[(1<<12)];\nbool dp[(1<<12)];\n\nbool solve(int id){\n  memset(dp,0,sizeof(dp));\n  dp[0] = 1;\n  int n = S.size();\n  if( n-id < sc[(1<<N)-1] ) return false;\n  for(int i=0;i<(1<<N);i++){\n    if( !dp[i] ) continue;\n    for(int j=0;j<N;j++){\n      if( i & (1<<j) ) continue;\n      if( S.compare(id+sc[i],ks[j].size(),ks[j]) == 0 ){\n\t//\tcout << S.substr(id+sc[i]) << \" \"<< ks[j] << \" \" << S.compare(id+sc[i],ks[j].size(),ks[j]) << endl;\n\tdp[i|(1<<j)] = 1;\t \t\n      }\n    }\n  }\n  return dp[(1<<N)-1];\n}\n\nint main(){\n  while( cin >> N >> M && (N||M) ){\n\n    memset(sc,0,sizeof(sc));\n\n    for(int i=0;i<N;i++){\n      cin >> ks[i];\n    }\n\n    for(int i=0;i<(1<<N);i++){\n      for(int j=0;j<N;j++){\n\tif( i & (1<<j) ) sc[i] += (int)ks[j].size();\n      }\n    }\n    \n    S.clear();\n    for(int j=0;j<M;j++){\n      string s;\n      cin >> s;\n      S+=s;\n    }\n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      if( solve(i) ) res++;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i],t[i]=\"\";\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \ninline long long to_int64(char x) {\n  return (long long)x;\n}\n  \ntemplate<class T> struct RollingHash {\n    \n  const array<int, 3> mods = {{int(1e9+7), int(1e9+9), int(1234567891)}};\n  const array<int, 3> Ks = {{1007, 1009, 1013}};\n  const int ModsSize = mods.size();\n  \n  vector<T> S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n  \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n  \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n  \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n   \n  RollingHash(vector<T> const& S) {\n    this->S = S;\n    construct();\n  }\n  \n  RollingHash(string const& S) {\n    int n = S.size();\n    rep(i, n) { this->S.push_back(S[i]); }\n    construct();\n  }\n  \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end) const { // not verified\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> const& rh) const {\n    if(rh == nullptr) { return same(a_start, a_end, b_start, b_end); }\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh->get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool compare(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> rh = nullptr) const {  // not verified\n    int a_len = a_end - a_start;\n    int b_len = b_end - b_start;\n  \n    int len = min(a_len, b_len);\n    int max_len = len + 1;\n    int min_len = 0;\n  \n    while(min_len + 1 < max_len) {\n      int next_len = (min_len + max_len) / 2;\n      if(same(a_start, a_start + next_len, b_start, b_start + next_len, rh)) {\n        min_len = next_len;\n      }\n      else {\n        max_len = next_len;\n      }\n    }\n  \n    if(a_start + min_len == a_end) {\n      if(b_start + min_len == b_end) { return 0; }\n      else { return -1; }\n    }\n    else {\n      if(b_start + min_len == b_end) { return 1; }\n      else { return S[a_start + min_len] == S[b_start + min_len]; }\n    }\n  \n  }\n  \n};\n \nint fact[13];\n \nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<shared_ptr<RollingHash<char>>> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(make_shared<RollingHash<char>>(RollingHash<char>(s)));\n    }\n    string t;\n    rep(i, M) {\n      string s; cin >> s, t += s;\n    }\n    RollingHash<char> T(t);\n    int TSize = t.size();\n \n    ll sum = 0;\n \n    rep(st, TSize) {\n      int dp[1<<N];\n      memset(dp, 0, sizeof dp);\n      rep(i, N)\n        if(T.same(st, st + vs[i]->S.size(), 0, vs[i]->S.size(), vs[i]))\n          dp[1<<i] = 1;\n\n      rep(S, 1<<N) {\n        int size = 0;\n        rep(i, N)\n          if(S >> i & 1)\n            size += vs[i]->S.size();\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + size, st + size + vs[i]->S.size(), 0, vs[i]->S.size(), vs[i])) {\n            dp[S | (1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>\n#include<algorithm>\n#include<set>\n#include<vector>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_E 13\n\nusing namespace std;\n\nint n,m;\nstring e[MAX_E];\nstring text;\nbool dp[5001][(1<<12)];\n\nint main()\n{\n  while(scanf(\"%d %d\",&n,&m),n|m)\n    {\n      rep(i,n)\n\t{\n\t  cin >> e[i];\n\t}\n      text = \"\";\n      rep(i,m)\n\t{\n\t  string content;\n\t  cin >> content;\n\t  text += content;\n\t}\n\n      int len = text.size();\n      rep(i,len+1)rep(j,(1<<n))dp[i][j] = false;\n      int ans = 0;\n\n      rep(i,len)\n\t{\n\t  rep(j,n)\n\t    {\n\t      int e_len = e[j].size();\n\t      if(i+e_len > text.size())continue;\n\t      if(text[i] != e[j][0])continue;\n\t      if(text.substr(i,e_len) == e[j])\n\t\t{\n\t\t  dp[i+e_len][(1<<j)] = true;\n\t\t}\n\t    }\n\t}\n\n      rep(cur,len+1)\n\t{\n\t  rep(state,(1<<n))\n\t    {\n\t      if(dp[cur][state] == false)continue;\n\t      rep(k,n)\n\t\t{\n\t\t  if((state>>k) & 1)continue;\n\t\t  int e_len = e[k].size();\n\t\t  if(e[k][0] != text[cur])continue;\n\t\t  if(text.size() < cur+e_len)continue;\n\t\t  if(text.substr(cur,e_len) == e[k])\n\t\t    {\n\t\t      dp[cur+e_len][state|(1<<k)] = true;\n\t\t    }\n\t\t}\n\t    }\n\t  if(dp[cur][(1<<n)-1])ans++;\n\n\t}\n      printf(\"%d\\n\",ans);\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    int count=0;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tcount++;\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint main() {\n  while(1) {\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    vector<string> vs(n);\n    REP(i,n) cin>>vs[i];\n    int sum = 0;\n    string tx;\n    REP(cnt,m) {\n      string line;\n      cin>>line;\n      tx += line;\n    }\n    int l = tx.size();\n    vector<vector<bool>> dp(1<<n, vector<bool>(l+1, false));\n    vector<vector<bool>> match(l+1, vector<bool>(n, false));\n    REP(i,l+1) dp[0][i] = true;\n    REP(i,l+1)REP(j,n) {\n      if (j+vs[j].size() > tx.size()) continue;\n      if (tx.substr(i, vs[j].size()) == vs[j]) match[i][j] = true;\n    }\n    REP(i,1<<n) REP(j,n) {\n      if ((i>>j)&1) continue;\n      int ls = vs[j].size();\n      REP(k,l+1-ls) {\n        if (dp[i][k] && match[k][j]) {\n          dp[i|(1<<j)][k+ls] = true;\n        }\n      }\n    }\n    REP(i,l+1) {\n      if (dp[(1<<n)-1][i]) ++sum;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\nbool dp[5001][(1 << 12)];\n\nint main(){\n    int n,m,LT,f[5000];\n    char P[12][21],LP[12];\n    char T[5001];\n    bool occ[5001][12];\n\n    while(true){\n        scanf(\"%d %d\",&n,&m);\n        if(n == 0) break;\n\n        for(int i = 0;i < n;++i){\n            scanf(\"%s\",P[i]);\n            LP[i] = strlen(P[i]);\n        }\n\n        LT = 0;\n\n        for(int i = 0;i < m;++i){\n            scanf(\"%s\",T + LT);\n            LT += strlen(T + LT);\n        }\n\n        f[0] = 0;\n\n        memset(occ,0,sizeof occ);\n\n        for(int i = 0;i < n;++i){\n            for(int j = 1,k = 0;j < LP[i];++j){\n                while(k > 0 && P[i][j] != P[i][k]) k = f[k - 1];\n                if(P[i][j] == P[i][k]) ++k;\n                f[j] = k;\n            }\n\n\n            for(int j = 0,k = 0;j < LT;++j){\n                while(k > 0 && T[j] != P[i][k]) k = f[k - 1];\n                if(T[j] == P[i][k]) ++k;\n\n                if(k == LP[i]){\n                    occ[j - k + 1][i] = true;\n                    k = f[k - 1];\n                }\n            }\n        }\n\n        memset(dp,0,sizeof dp);\n\n        int M = (1 << n) - 1;\n        dp[LT][0] = 1;\n\n        for(int i = LT - 1;i >= 0;--i){\n            dp[i][0] = 1;\n\n            for(int mask = 1;mask <= M;++mask){\n                int aux = mask;\n\n                while(aux && !dp[i][mask]){\n                    int j = __builtin_ctz(aux);\n                    aux ^= (1 << j);\n\n                    if(occ[i][j]) dp[i][mask] = dp[i][mask] || dp[i + LP[j]][mask ^ (1 << j)];\n                }\n            }\n        }\n\n        int ans = 0;\n\n        for(int i = 0;i < LT;++i)\n            if(dp[i][M]) ++ans;\n\n        printf(\"%d\\n\",ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<string> e(n);\n    string ts;\n    int concatenated_len=0;\n    rep(i,0,n){\n        cin >> e[i];\n        concatenated_len+=e[i].size();\n    }\n    rep(i,0,m){\n        string t;\n        cin >> t;\n        ts+=t;\n    }\n\n    vector<int> sum_len(1<<n);\n    rep(i,0,1<<n){\n        rep(j,0,n){\n            if(((i>>j)&1)==0) continue;\n            sum_len[i]+=e[j].size();\n        }\n    }\n\n    static bool p[5000][1<<12];\n    fill_n((bool*)p,5000*(1<<12),false);\n    vector<vector<int>> heads(ts.size());\n    rep(i,0,ts.size()) p[i][0]=true;\n    rep(i,0,ts.size()){\n        rep(j,0,n){\n            if(i+e[j].size()>ts.size() or e[j]!=ts.substr(i,e[j].size())) continue;\n            p[i][1<<j]=true;\n            heads[i].push_back(j);\n        }\n    }\n    int ans=0;\n    for(int i=ts.size()-1; i>=0; --i){\n        rep(j,1,1<<n){\n            if(p[i][j] or i+sum_len[j]>ts.size()) continue;\n            for(int k:heads[i]){\n                if(((j>>k)&1)==0) continue;\n                int i2=i+e[k].size();\n                if(p[i2][j&(~(1<<k))]){\n                    p[i][j]=true;\n                    break;\n                }\n            }\n        }\n        if(p[i][(1<<n)-1]) ++ans;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring t;\nint sum;\nint num_node;\nint myroot;\nchar buf[114514];\nstring des[114514];\nchar cs[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nint mynext[200000][256];\nvector<int> matched[200000];\n\nbool Cmp(const string &a, const string &b) {\n  return a.size() > b.size();\n}\n\nint build_PMA(string *pats, int size) {\n  matched[num_node].resize(0);\n  for (int k=0; k<256; k++) mynext[num_node][k] = 0;\n  mynext[num_node][0] = num_node;\n  int root = num_node++;\n  for (int i=0; i<size; i++) {\n    int node = root;\n    for (int j=0; j<pats[i].size(); j++) {\n      char c = pats[i][j];\n      if (!mynext[node][c]) {\n        matched[num_node].resize(0);\n        for (int k=0; k<256; k++) mynext[num_node][k] = 0;\n        mynext[node][c] = num_node++;\n      }\n      node = mynext[node][c];\n    }\n    matched[node].push_back(i);\n  }\n\n  queue<int> q;\n  for (int i=0; i<52; i++) {\n    if (mynext[root][cs[i]]) {\n      mynext[mynext[root][cs[i]]][0] = root;\n      q.push(mynext[root][cs[i]]);\n    } else mynext[root][cs[i]] = root;\n  }\n\n  while (!q.empty()) {\n    int node = q.front(); q.pop();\n    for (int i=0; i<52; i++) {\n      if (mynext[node][cs[i]]) {\n        q.push(mynext[node][cs[i]]);\n        int failer = mynext[node][0];\n        while (!mynext[failer][cs[i]]) failer = mynext[failer][0];\n        mynext[mynext[node][cs[i]]][0] = mynext[failer][cs[i]];\n        if (mynext[node][cs[i]] != mynext[failer][cs[i]]) {\n          matched[mynext[node][cs[i]]].insert(matched[mynext[node][cs[i]]].end(), matched[mynext[failer][cs[i]]].begin(), matched[mynext[failer][cs[i]]].end());\n        }\n      }\n    }\n  }\n  return root;           \n}\n\n\nbool check(int idx) {\n  map<int, set<set<int> > > found;\n  int node = myroot;\n  found[idx] = set<set<int> >();\n  set<int> em;\n  found[idx].insert(em);\n  for (int i=idx; i<idx+sum; i++) {\n    while (!mynext[node][t[i]]) node = mynext[node][0];\n    node = mynext[node][t[i]];\n    if (!matched[node].empty()) {\n      for (int g : matched[node]) {\n        int prev = i+1-(int)des[g].size();\n        for (auto &st : found[prev]) {\n          //cout << \"st:\";\n          //for (auto a : st) cout << a << \" \";\n          //cout << \"\\n\";\n          if (!st.count(g)) {\n            //puts(\"pushed\");\n            set<int> nst(st);\n            nst.insert(g);\n            found[i+1].insert(nst);\n          }\n        }\n      }\n    }\n  }\n\n  return !found[idx+sum].empty();\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    sum = 0;\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n      sum += (int)des[i].size();\n    }\n    num_node = 1;\n    myroot = build_PMA(des, n);\n\n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n\n    int node = myroot;\n    int lim = 1 << n;\n    map<pair<int, int>, bool> dp;\n    for (int i=0; i<t.size(); i++) {\n      while (!mynext[node][t[i]]) node = mynext[node][0];\n      node = mynext[node][t[i]];\n      for (int g : matched[node]) {\n        for (int st=0; st<lim; st++) {\n          if (st >> g & 1) continue;\n          int prev = i+1-des[g].size();\n          if (dp.count(make_pair(st, prev))) {\n            dp[make_pair(st|(1<<g), i+1)] = true;\n          }\n        }\n        dp[make_pair(1<<g, i+1)] = true;\n      }\n    }\n\n    int ans = 0;\n    for (int i=0; i<=t.size(); i++) {\n      if (dp.count(make_pair(lim-1, i))) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\nstruct node {\n\tmap<char, node> next;\n\tset<int> state;\n};\n\nbool dp[5002][(1 << 12) + 2];\nint len_pat[13];\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\twhile (N != 0 && M != 0) {\n\t\tnode top;\n\n\t\tstring pat;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> pat;\n\t\t\tlen_pat[i] = pat.size();\n\n\t\t\tnode* current = &top;\n\t\t\tfor (int k = 0; k < pat.length(); k++) {\n\t\t\t\tauto res = current->next.insert({ pat[k], node() });\n\t\t\t\tcurrent = &res.first->second;\n\t\t\t}\n\t\t\tcurrent->state.insert(i);\n\t\t}\n\n\t\tstring s;\n\t\tstring temp;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> temp;\n\t\t\ts += temp;\n\t\t}\n\n\t\tvector<set<int>> occ(s.length());\n\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tnode* current = &top;\n\t\t\tfor (int k = i; k < s.length() + 1; k++) {\n\t\t\t\tfor (auto item : current->state) {\n\t\t\t\t\tocc[i].insert(item);\n\t\t\t\t}\n\n\t\t\t\tif (k == s.length())\n\t\t\t\t\tbreak;\n\n\t\t\t\tauto res = current->next.find(s[k]);\n\t\t\t\tif (res == current->next.end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcurrent = &res->second;\n\t\t\t}\n\n\n\t\t}\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tdp[i][0] = true;\n\t\t\tfor(int bit = 0; bit < (1 << N); bit++)\n\t\t\t{\n\t\t\t\tif (!dp[i][bit]) continue;\n\t\t\t\tfor(int p : occ[i])\n\t\t\t\t{\n\t\t\t\t\tif ((bit >> p) & 1) continue;\n\t\t\t\t\tif(i + len_pat[p] <= s.length())\n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i + len_pat[p]][bit | (1 << p)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i=0;i<=s.length();i++)\n\t\t{\n\t\t\tif(dp[i][(1 << N) - 1])\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\n\t\tcin >> N >> M;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i = 0; i < (int)(N); i++)\nbool dp[32][1 << 12];\n\nint main() {\n\tfor(int N, M; cin >> N >> M, (N || M); ) {\n\t\tstring str;\n\t\tstring word[12];\n\t\tREP(i, N) cin >> word[i];\n\t\tREP(i, M) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstr += s;\n\t\t}\n\t\tint len = str.size();\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(j, 32) dp[j][0] = true;\n\t\t\n\t\tint mask = (1 << N) - 1;\n\t\tint sum = 0;\n\t\tREP(pos, len + 1) {\n\t\t\tint j = pos & 31;\n\t\t\tREP(i, N) if( word[i] == str.substr(pos, word[i].size()) ) {\n\t\t\t\tint am = (pos + word[i].size()) & 31;\n\t\t\t\tint a = mask - (1 << i);\n\t\t\t\tdp[am][1 << i] |= dp[j][0];\n\t\t\t\tfor(int state = a; state != 0; state = (state-1)&a){\n\t\t\t\t\tdp[am][state | (1 << i)] |= dp[j][state];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dp[j][mask];\n\t\t\tfor(int state = 1; state < 1 << N; state++)\n\t\t\t\tdp[j][state] = 0; \n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\n\nll fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<string> vs;\n    map<string, int> mp;\n    rep(i, N) {\n      string s; cin >> s;\n      mp[s] ++;\n      vs.push_back(s);\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].size();\n      }\n    }\n\n    string T;\n    rep(i, M) {\n      char s[5001]; cin >> s, T += s;\n    }\n\n    int TSize = T.size();\n    \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(!T.compare(st + sizes[S], sizes[S|(1<<i)] - sizes[S], vs[i])) {\n            dp[S|(1<<i)] = 1;\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring t;\nchar buf[114514];\nstring des[114514];\nchar cs[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nbool dp[1 << 12][5001];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    sum = 0;\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n    }\n\n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n\n    int lim = 1 << n;\n    fill(dp[0], dp[lim], false);\n    for (int i=0; i<t.size(); i++) {\n      for (int g=0; g<n; g++) {\n        int prev = i+1-des[g].size();\n        if (t.substr(prev, des[g].size()) != des[g]) continue;\n\n        for (int st=0; st<lim; st++) {\n          if (st >> g & 1) continue;\n          dp[st|(1<<g)][i+1] |= dp[st][prev];\n        }\n        dp[1<<g][i+1] = true;\n      }\n    }\n\n    int ans = 0;\n    for (int i=0; i<=t.size(); i++) {\n      if (dp[lim-1][i]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef int_t hash_t;\n    int_t base1;\n    int_t mod1;\n    vector<int_t> hash1;\n    vector<int_t> pow1;\n    RollingHash() : base1(1009), mod1(1000000007) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1.assign(n+1,0);\n        pow1.assign(n+1,1);\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        return t1;\n    }\n};\n\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<RollingHash::hash_t> hs(n);\n    RollingHash rh;\n    rep(i,n){\n        rh.init(ss[i]);\n        hs[i] = rh.get(0,ss[i].size());\n    }\n    rh.init(t);\n\n    memset(dp,false,sizeof(dp));\n    rep(i,5000) dp[i][0] = true;\n    rep(pos,len){\n        rep(i,n){\n            rep(mask,1<<n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    // if(pos+ss[i].size() > t.size()) continue;\n                    // if(rh.get(pos,pos+ss[i].size()) != hs[i]) continue;\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint main() {\n  while(1) {\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    vector<string> vs(n);\n    REP(i,n) cin>>vs[i];\n    int sum = 0;\n    string tx;\n    REP(cnt,m) {\n      string line;\n      cin>>line;\n      tx += line;\n    }\n    int l = tx.size();\n    vector<vector<bool>> dp(1<<n, vector<bool>(l+1, false));\n    REP(i,l+1) dp[0][i] = true;\n    REP(i,1<<n) REP(j,n) {\n      if ((i>>j)&1) continue;\n      int ls = vs[j].size();\n      REP(k,l+1-ls) {\n        if (dp[i][k] && tx.substr(k, ls) == vs[j]) {\n          dp[i|(1<<j)][k+ls] = true;\n        }\n      }\n    }\n    REP(i,l+1) {\n      if (dp[(1<<n)-1][i]) ++sum;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\n\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint n,m;\n\nll gha[6000];\nbool vis[1<<12][100];\nll po[1000];\nvoid solve(){\n  ll ha[n];\n  int len[n];\n  rep(i,n) {\n    string a;\n    cin >> a;\n    ll h =0 ;\n    len[i] = SZ(a);\n    FOR(it,a)\n      h=h*31+*it;\n    ha[i] =h;\n  }\n  po[0] = 1;\n  rep(i,999) po[i+1] = po[i]*31;\n  int ans = 0;\n  string text;\n  rep(jjj,m) {\n    string a;\n    cin >> a;\n    text += a;\n  }\n\n  rep(i,SZ(text)) gha[i+1] = gha[i]*31+text[i];\n\n  bool vis[250][1<<n];\n  rep(i,250)rep(j,1<<n) vis[i][j]=0;\n  rep(i,250) vis[i][0]=1;\n\n  rep(j,SZ(text)+1){\n    int cur = j%250;\n    rep(i,1<<n){\n      if(!vis[cur][i]) continue;\n      rep(k,n)\n        if((~i&(1<<k)) && len[k]+j<=SZ(text) &&\n           ha[k] == gha[j+len[k]] - gha[j]*po[len[k]])\n          vis[(j+len[k])%250][i|(1<<k)]=1;\n    }\n    ans += vis[cur][(1<<n)-1];\n    rep(i,1<<n) vis[cur][i] = 0;\n    vis[cur][0]=1;\n  }\n  cout << ans << endl;\n  return ;\n  \n  rep(jjj,m){\n    string a;\n    cin >> a;\n    rep(i,SZ(a)) gha[i+1] = gha[i]*31+a[i];\n    \n    rep(i,1<<n)rep(j,SZ(a)+1) vis[i][j]=0;\n    queue<PI> q;\n    rep(i,n) rep(j,SZ(a)-len[i]+1){\n      ll t = gha[j+len[i]]-gha[j]*po[len[i]];\n      if(t == ha[i]) q.push(mp(1<<i,j+len[i]));\n    }\n    \n    while(!q.empty()){\n      int cst  = q.front().F;\n      int cp = q.front().S;\n      q.pop();\n      if(vis[cst][cp]) continue;\n      //cout << cst << \" \" << cp << endl;\n      vis[cst][cp] = 1;\n      ans += cst == (1<<n)-1;\n      rep(i,n){\n        //cout << ha[i] << \" \" << gha[cp+len[i]]-gha[cp]*po[len[i]] << endl;\n        if(((~cst)&(1<<i)) &&\n           ha[i] == gha[cp+len[i]]-gha[cp]*po[len[i]])\n          q.push(mp(cst|(1<<i),cp+len[i]));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n >> m ,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\n#define MAXSTACK 300000\n#define MAXSIZE 5010\n#define MAXN 12\n\nstruct obj {\n   short int p, m;\n} tmpobj, s[MAXSTACK];\n\nbool starts[MAXSIZE][MAXN], ins[MAXSIZE][1<<MAXN];\n\nint main() {\n\nint N, M, i, j, k, l[MAXN], RES, FULL, E;\nstring n[MAXN], input, tmp;\n\ncin >> N; FULL = (1<<N)-1;\ncin >> M;\n\ndo {\n\nfor (i=0; i<N; i++) {cin >> n[i]; l[i] = n[i].size();}\n\ninput = \"\";\nfor (i=0; i<M; i++) {cin >> tmp; input += tmp;}\n\nmemset(starts, false, sizeof(starts));\nfor (i=0; i<input.size(); i++) {\n   for (j=1; j<=20; j++) {\n\t\ttmp = input.substr(i, j);\n\t\tfor (k=0; k<N; k++) {\n\t\t\tif (tmp == n[k]) starts[i][k] = true;\n\t\t}\n\t}\n}\n\nmemset(ins, false, sizeof(ins)); E = 0;\nfor (i=0; i<input.size(); i++) {\n\ttmpobj.p = i;\n\ttmpobj.m = 0;\n\ts[E++] = tmpobj;\n\tins[i][0] = true;\n}\n\nRES = 0;\nwhile (E > 0) {\n\ttmpobj = s[--E];\n\tif (tmpobj.m == FULL) RES++;\n\telse {\n      for (i=0; i<N; i++) if (starts[tmpobj.p][i] == true && ((tmpobj.m>>i)&1) == 0 && ins[tmpobj.p+l[i]][tmpobj.m^(1<<i)] == false) {\n   \t\ts[E].p = tmpobj.p+l[i];\n   \t\ts[E].m = tmpobj.m^(1<<i);\n\t   \tins[s[E].p][s[E].m] = true;\n\t\t\tE++;\n\t\t\tif (E == MAXSTACK) E = 0;\n   \t}\n\t}\n}\n\ncout << RES << endl;\n\ncin >> N; FULL = (1<<N)-1;\ncin >> M;\n\n} while (N!=0 || M!=0);\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int LLNF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct RollingHash{\n\tstring str;\n\tlong long int base,mod;\n\tvector<long long int> hash,pow; //hash[i]:=[0,i)のハッシュ\n\t\n\tRollingHash(string str,long long int base,long long int mod):str(str),base(base),mod(mod){\n\t\tint size=str.size();\n\t\thash=vector<long long int>(size+1);\n\t\tpow=vector<long long int>(size+1);\n\n\t\thash[0]=0;\n\t\tpow[0]=1;\n\t\tfor(int i=1; i<size+1; ++i){\n\t\t\tpow[i]=pow[i-1]*base%mod;\n\t\t\thash[i]=(hash[i-1]*base+str[i-1])%mod;\n\t\t}\n\t}\n\n\tinline long long int Hash(int l,int r){ //[l,r)\n\t\treturn (hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\n\t}\n};\n\ninline long long Hash(string str,long long int base,long long int mod){\n\tlong long int res=0;\n\tfor(int i=0; i<str.size(); ++i){\n\t\tres=(res*base+str[i])%mod;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint n,m;\n\t\tstring e[12],t;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\trep(i,0,n) cin >> e[i];\n\t\trep(i,0,m){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tt+=tmp;\n\t\t}\n\t\n\t\tconst int base=993,mod=12000017;\n\t\tRollingHash t_hash(t,base,mod);\n\t\tstatic int count[mod];\n\t\tfill_n((int*)count,mod,0);\n\t\trep(i,1,t.size()+1) for(int j=0; j+i<=t.size(); ++j) ++count[t_hash.Hash(j,j+i)];\n\t\t\n\t\tint ans=0;\n\t\tstatic bool done[mod];\n\t\tfill_n((int*)done,mod,0);\n\t\tvector<int> perm(n);\n\t\trep(i,0,n) perm[i]=i;\n\t\tdo{\n\t\t\tstring str; \n\t\t\trep(i,0,n) str+=e[perm[i]];\n\t\t\tll x=Hash(str,base,mod);\n\t\t\tif(done[x]) continue;\n\t\t\tdone[x]=true;\n\t\t\tans+=count[x];\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint N,M;\nbool dp[5001][1<<12];\nbool b[5001][12];\nstring a[12];\nint main(){\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\trep(i,N) cin>>a[i];\n\t\tstring s;\n\t\trep(i,M){\n\t\t\tstring o;\n\t\t\tcin>>o;\n\t\t\ts+=o;\n\t\t}\n\t\tM=s.size();\n\t\trep(i,M+1) rep(j,1<<N) dp[i][j]=0;\n\t\trep(i,M+1) dp[i][0]=1;\n\t\trep(i,M+1) rep(j,N){\n\t\t\tb[i][j]=0;\n\t\t\tif(i+a[j].size()<=M&&s.substr(i,a[j].size())==a[j]) b[i][j]=1;\n\t\t}\n\t\trep(i,M){\n\t\t\trep(j,1<<N){\n\t\t\t\tif(!dp[i][j]) continue;\n\t\t\t\tbool is[12];\n\t\t\t\trep(k,N){\n\t\t\t\t\tif((j>>k)&1) continue;\n\t\t\t\t\tif(b[i][k]) dp[i+a[k].size()][j+(1<<k)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,M+1) if(dp[i][(1<<N)-1]) ans++;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 12\n#define S 5005\n#define M 1777771\nusing namespace std;\ntypedef unsigned long long ull;\n\nbool dp[(1<<N)][S];\nint n, m;\nstring s[N],t;\n\null d1[N],d2[S],A[30];\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    for(int i=0;i<n;i++) cin>>s[i];\n\n    t=\"\";\n    \n    for(int i=0;i<m;i++){\n      string tmp;\n      cin>>tmp;\n      t+=tmp;\n    }\n\n    for(int i=0;i<n;i++){\n      ull hash=s[i][0];\n      for(int j=1;j<s[i].size();j++)\n\thash=hash*M+s[i][j];\n      d1[i]=hash;\n    }\n    \n    d2[0]=t[0];\n    for(int i=1;i<t.size();i++)\n      d2[i]=d2[i-1]*M+t[i];\n\n    memset(dp,0,sizeof(dp));\n\n    for(int i=0;i<t.size();i++) dp[0][i]=true;\n    \n    A[0]=1;\n    for(int i=1;i<30;i++) A[i]=A[i-1]*M;\n\n    for(int i=0;i<(1<<n);i++){\n\n      for(int j=0;j<t.size();j++){\n\n\tif(!dp[i][j]) continue;\n\t\n\tfor(int k=0;k<n;k++){\n\n\t  if(i&(1<<k)) continue;\n\n\t  int slen=s[k].size();\n\t  \n\t  if(t.size()<j+slen) continue;\n\t  \n\t  ull x=d2[j+slen-1];\n\t  if(j) x-=d2[j-1]*A[slen];\n\t  \n\t  if(d1[k]!=x) continue;\n\t  \n\t  dp[i|(1<<k)][j+slen]=true;\n\t  \n\t}\n\t\n      }\n      \n    }\n\n    int ans=0;\n    \n    for(int i=0;i<=t.size();i++)\n      ans+=dp[(1<<n)-1][i];\n\n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring t;\nchar buf[114514];\nstring des[114514];\n\nbool Cmp(const string &a, const string &b) {\n  return a.size() > b.size();\n}\n\nbool check(int idx) {\n  vector<string> es(des, des+n);\n  while (idx < t.size() && !es.empty()) {\n    bool found = false;\n    for (auto itr=es.begin(); itr!=es.end(); itr++) {\n      const string &pat = *itr;\n      if (t.size() < pat.size()+idx) continue;\n      if (t.substr(idx, pat.size()) == pat) {\n        found = true;\n        idx += pat.size();\n        es.erase(itr);\n        break;\n      }\n    }\n    if (!found) return false;\n  }\n\n  if (!es.empty()) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n    }\n    sort(des, des+n, Cmp);\n\n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n\n    int ans = 0;\n    for (int i=0; i<t.size(); i++) {\n      if (check(i)) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n// KMP 法 (Knuth-Morris-Pratt Algorithm)\nstruct KMP {\n    string p; int len;\n    vector<int> fail;\n    KMP() {}\n    KMP(string p_) : p(p_), len(p_.length()) {\n        // 文字列 p[0:i-1] の接頭辞と接尾辞は最大何文字一致する？\n        // ただし、|p[0:i-1]| 文字未満のみ考慮\n        // MP 法に比べ、失敗時の遷移が log 回に改善されている\n        // see also: http://www-igm.univ-mlv.fr/~lecroq/string/node8.html\n        fail.resize(len + 1, -1);\n        for(int i=1, j=-1; i<=len; i++) {\n            // その時点で一致しなければ fail[j] 文字以下の一致となる\n            // j を fail[j] に変更\n            int step = 0;\n            while(j >= 0 and p[j] != p[i-1]) j = fail[j], step++;\n            fail[i] = (p[i] == p[++j] ? fail[j] : j);\n        }\n    }\n\n    // 文字列 s における p の出現位置 (開始位置) のリスト\n    vector<int> match(string s) {\n        int N = s.length();\n        vector<int> occur(N);\n        for(int i=0, k=0; i<N; i++) {\n            while(k >= 0 and s[i] != p[k]) k = fail[k];\n            if(++k == len) {\n                occur[i-len+1] = true;\n                k = fail[k];\n            }\n        }\n        return occur;\n    }\n};\n\n\nint main() {\n  int N, M;\n  while(cin >> N >> M, N || M) {\n    vector<string> pat(N);\n    vector<KMP> kmps(N);\n    for(int i=0; i<N; i++) cin >> pat[i], kmps[i] = KMP(pat[i]);\n\n    string s = \"\";\n    for(int i=0; i<M; i++) {\n      string tmp; cin >> tmp;\n      s += tmp;\n    }\n    \n    // fprintf(stderr, \"before match\\n\");\n    int len = s.length();\n    vector< vector<int> > match(N);\n    for(int i=0; i<N; i++) match[i] = kmps[i].match(s);\n\n    /*\n    // for debug\n    for(int i=0; i<N; i++) {\n      for(int j=0; j<len; j++) {\n        fprintf(stderr, \"%d \", match[i][j]);\n      }\n      fprintf(stderr, \"\\n\");\n    }\n    */\n\n    vector<int> lens(1 << N);\n    for(int bit=0; bit<(1<<N); bit++) {\n      for(int i=0; i<N; i++) {\n        if(bit >> i & 1) lens[bit] += pat[i].length();\n      }\n    }\n\n    int whole_len = lens[(1 << N) - 1], ans = 0;\n    for(int i=0; i<len-whole_len+1; i++) {\n      vector<int> dp(1 << N);\n      dp[0] = true;\n      for(int bit=0; bit<(1<<N); bit++) {\n        int cur_idx = i + lens[bit];\n        for(int i=0; i<N; i++) {\n          if(bit >> i & 1) continue;\n          int nbit = bit | (1 << i);\n          if(match[i][cur_idx]) dp[nbit] |= dp[bit];\n        }\n      }\n\n      if(dp[(1 << N) - 1]) {\n        // fprintf(stderr, \"match %d\\n\", i);\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 2008ツアツジツアツ地ツ凝ヲツ予ツ選G : Search of Concatenated Strings\n#include <iostream>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint main(){\n\tint n, m;\n\tstatic bool dp[4096][5001];\n\tstatic bool occ[12][5000];\n\twhile(cin >> n >> m, n){\n\t\tstring s, t, p[12];\n\t\tfor(int i=0;i<n;i++) cin >> p[i];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> t; \n\t\t\ts += t;\n\t\t}\n\t\tmemset(dp, false, sizeof(dp));\n\t\tfor(int i=0;i<s.size();i++) dp[0][i] = true;\n\t\tmemset(occ, false, sizeof(occ));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint idx = s.find(p[i]);\n\t\t\twhile(idx!=-1){\n\t\t\t\tocc[i][idx] = true;\n\t\t\t\tidx = s.find(p[i],idx+1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<s.size();i++){\n\t\t\tfor(int S=0;S<(1<<n);S++){\n\t\t\t\tif(!dp[S][i]) continue;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(!occ[k][i]||(S&(1<<k))) continue;\n\t\t\t\t\tdp[S|(1<<k)][i+p[k].size()] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i=0;i<s.size();i++)\n\t\t\tans += dp[(1<<n)-1][i+1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef int_t hash_t;\n    int_t base1;\n    int_t mod1;\n    static int_t hash1[6000];\n    static int_t pow1[6000];\n    RollingHash() : base1(1009), mod1(1000000007) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1[0] = 0;\n        pow1[0] = 1;\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        return t1;\n    }\n};\nRollingHash::int_t RollingHash::hash1[6000];\nRollingHash::int_t RollingHash::pow1[6000];\n\nint solve(vector<string> & ss, string & t){\n    int n = ss.size();\n    int len = t.size();\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(!dp[pos][mask]) continue;\n                if(pos+ss[i].size() > t.size()) continue;\n                if(t.substr(pos,ss[i].size()) == ss[i]){\n                    dp[pos+ss[i].size()][mask|1<<i] = true;\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        vector<string> elm(n);\n        for (int i = 0; i < n; i++)\n            cin >> elm[i];\n        string s = \"\";\n        for (int i = 0; i < m; i++)\n        {\n            string a;\n            cin >> a;\n            s += a;\n        }\n        int m = s.size();\n        // ok[i][j] := elm[i] が s[j] で受理されるか\n        vector<vector<bool>> ok(n, vector<bool>(m, false));\n        // dp[i][j] := s[i] までで j(mask) が受理されるか\n        vector<vector<bool>> dp(m, vector<bool>(1 << n, false));\n        for (int i = 0; i < n; i++)\n        {\n            int sz = elm[i].size();\n            for (int j = 0; j <= m - sz; j++)\n            {\n                if (elm[i] == s.substr(j, sz))\n                {\n                    ok[i][j + sz - 1] = true;\n                    dp[j + sz - 1][1 << i] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 1; j < (1 << n); j++)\n            {\n                for (int k = 0; k < n; k++)\n                {\n                    if (((j >> k) & 1) == 0)\n                        continue;\n                    if ((j ^ (1 << k)) == 0)\n                        continue;\n                    int sz = elm[k].size();\n                    if (i - sz < 0)\n                        continue;\n                    if (dp[i - sz][j ^ (1 << k)] && ok[k][i])\n                        dp[i][j] = true;\n                }\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < m; i++)\n            if (dp[i][(1 << n) - 1])\n                ret++;\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define pi M_PI\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\nstruct RH {\n  vector<unsigned long long> p,hash;\n  void init(const string s) {\n    unsigned long long m=1000000007,q=1,n=s.size();\n    p.resize(n+1);hash.resize(n+1);p[0]=q;hash[0]=0;\n    rep(i,n){p[i+1]=p[i]*m;hash[i+1]=s[i]+hash[i]*m;}\n  }\n  unsigned long long h(int i)const{return hash[i];}\n  unsigned long long h(int i,int j)const{return h(j)-h(i)*p[j-i];}\n};\nint n,m;\nstring s[12];\nbool u[1<<12];\nRH r[12],e;\n\nll dfs(ll t,ll k) {\n  if(t==(1<<n)-1) return 1;\n  if(u[t]) return 0;\n  u[t]=1;\n  rep(i,n) {\n    if(t&(1<<i)) continue;\n    if(r[i].h(s[i].size())==e.h(k,k+s[i].size())&&dfs(t|(1<<i),k+s[i].size())) return 1;\n  }\n  return 0;\n}\n\nvoid Main() {\n  while(cin >> n >> m && n) {\n    ll c=0;\n    rep(i,n) {\n      R s[i];\n      r[i].init(s[i]);\n      c+=s[i].size();\n    }\n    ll ans=0;\n    string t=\"\";\n    rep(i,m) {\n      string z;\n      R z;\n      t+=z;\n    }\n    e.init(t);\n    rep(i,t.size()-c+1) {\n      mem(u);\n      ans+=dfs(0,i);\n    }\n    pr(ans);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct RollingHash{\n    static const int MD = 2;\n    static const vector<ll> hash_base, hash_mod;\n\n    int n;\n    vector<ll> hs[MD], pw[MD];\n\n    RollingHash(){}\n    RollingHash(const string &s){\n        n = s.size();\n        rep(i,MD){\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            rep(j,n){\n                pw[i][j+1] = pw[i][j]*hash_base[i] % hash_mod[i];\n                hs[i][j+1] = (hs[i][j]*hash_base[i]+s[j]) % hash_mod[i];\n            }\n        }\n    }\n\n    // 1-index\n    ll hash_value(int l, int r, int i){\n        return ((hs[i][r] - hs[i][l]*pw[i][r-l])%hash_mod[i]+hash_mod[i])%hash_mod[i];\n    }\n\n    bool match(int l1, int r1, int l2, int r2){\n        bool ret = true;\n        rep(i,MD) ret &= (hash_value(l1-1,r1,i) == hash_value(l2-1,r2,i));\n        return ret;\n    }\n\n    vector<ll> calc(int l, int r){\n        vector<ll> ret(MD);\n        rep(i,MD) ret[i]=hash_value(l-1,r,i);\n        return ret;\n    }\n};\nconst vector<ll> RollingHash::hash_base{1009,1021,1013};\nconst vector<ll> RollingHash::hash_mod{1000000009,1000000007,1000000021};\n\nconst int N = 1<<12;\nbool dp[N];\nint len[N];\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n){\n        vector<string> s(n);\n        rep(i,n) cin >>s[i];\n\n        string t=\"\";\n        while(m--){\n            string tmp;\n            cin >>tmp;\n            t += tmp;\n        }\n\n        vector<int> sz(n);\n        int S = 0;\n        rep(i,n){\n            sz[i] = s[i].size();\n            S += sz[i];\n        }\n        int T = t.size();\n        // S <= 240, T <= 5000\n\n        vector<RollingHash> hs(n);\n        rep(i,n) hs[i] = RollingHash(s[i]);\n        RollingHash ht(t);\n\n        rep(mask,1<<n){\n            len[mask] = 0;\n            rep(i,n)if(mask>>i&1) len[mask] += s[i].size();\n        }\n\n        int ans = 0;\n        rep(i,T-S+1){\n            fill(dp,dp+N,false);\n            dp[0] = true;\n            rep(mask,1<<n)if(dp[mask]){\n                rep(j,n)if(!(mask>>j&1)){\n                    int nx = mask | (1<<j);\n\n                    bool flg = true;\n                    rep(k,2){\n                        flg &= (hs[j].hash_value(1, sz[j], k) == ht.hash_value(1+i+len[mask], 1+i+len[nx]-1, k));\n                    }\n\n                    dp[nx] |= flg;\n                }\n            }\n\n            if(dp[(1<<n)-1]) ++ans;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int LLNF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct RollingHash{\n\tstring str;\n\tlong long int base,mod;\n\tvector<long long int> hash,pow; //hash[i]:=[0,i)のハッシュ\n\t\n\tRollingHash(string str,long long int base,long long int mod):str(str),base(base),mod(mod){\n\t\tint size=str.size();\n\t\thash=vector<long long int>(size+1);\n\t\tpow=vector<long long int>(size+1);\n\n\t\thash[0]=0;\n\t\tpow[0]=1;\n\t\tfor(int i=1; i<size+1; ++i){\n\t\t\tpow[i]=pow[i-1]*base%mod;\n\t\t\thash[i]=(hash[i-1]*base+str[i-1])%mod;\n\t\t}\n\t}\n\n\tinline long long int Hash(int l,int r){ //[l,r)\n\t\treturn (hash[r]-hash[l]*pow[r-l]%mod+mod)%mod;\n\t}\n};\n\ninline long long Hash(string str,long long int base,long long int mod){\n\tlong long int res=0;\n\tfor(int i=0; i<str.size(); ++i){\n\t\tres=(res*base+str[i])%mod;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint n,m;\n\t\tstring e[12],t;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\trep(i,0,n) cin >> e[i];\n\t\trep(i,0,m){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tt+=tmp;\n\t\t}\n\t\n\t\tconst int base=9973,mod=12000017;\n\t\tRollingHash t_hash(t,base,mod);\n\t\tstatic int count[mod];\n\t\tfill_n((int*)count,mod,0);\n\t\trep(i,1,t.size()+1) for(int j=0; j+i<=t.size(); ++j) ++count[t_hash.Hash(j,j+i)];\n\t\t\n\t\tint ans=0;\n\t\tstatic bool done[mod];\n\t\tfill_n((int*)done,mod,0);\n\t\tvector<int> perm(n);\n\t\trep(i,0,n) perm[i]=i;\n\t\tdo{\n\t\t\tstring str; \n\t\t\trep(i,0,n) str+=e[perm[i]];\n\t\t\tll x=Hash(str,base,mod);\n\t\t\tif(done[x]) continue;\n\t\t\tdone[x]=true;\n\t\t\tans+=count[x];\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\nstruct RollingHash {\n    const int base = 9973;\n    const int mod[2] = {999999937, 1000000007};\n    vector<int> s;\n    vector<ll> hash[2], pow[2];\n\n    template<class S>\n    RollingHash(const S &s) {\n        int n = s.size();\n        for (int id = 0; id < 2; ++id) {\n            hash[id].assign(n+1, 0);\n            pow[id].assign(n+1, 1);\n            for (int i = 0; i < n; ++i) {\n                hash[id][i+1] = (hash[id][i] * base + s[i]) % mod[id];\n                pow[id][i+1] = pow[id][i] * base % mod[id];\n            }\n        }\n    }\n\n    // get hash of s[l:r)\n    pair<ll,ll> get(int l, int r) {\n        ll ret[2];\n        for (int id = 0; id < 2; ++id) {\n            ret[id] = hash[id][r] - hash[id][l] * pow[id][r - l] % mod[id];\n            if (ret[id] < 0) ret[id] += mod[id];\n        }\n        return { ret[0], ret[1] };\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n, m; cin >> n >> m;\n        if (n == 0) break;\n\n        vector<string> e(n);\n        vector<pair<ll,ll>> ehash(n);\n        REP(i, n) {\n            cin >> e[i];\n            ehash[i] = RollingHash(e[i]).get(0, e[i].size());\n        }\n\n        string t;\n        REP(i, m) {\n            string s; cin >> s;\n            t += s;\n        }\n        RollingHash thash(t);\n\n        vvi valid(t.size(), vi(n));\n        REP(i, t.size()) {\n            REP(j, n) {\n                valid[i][j] = i + e[j].size() <= t.size() and\n                    thash.get(i, i+e[j].size()) == ehash[j];\n            }\n        }\n\n        vvi dp(t.size()+1, vi(1<<n));\n        REP(i, t.size()) dp[i][0] = 1;\n        REP(i, t.size()) {\n            REP(s, 1<<n) {\n                if (dp[i][s] == 0) continue;\n                REP(j, n) {\n                    if (s >> j & 1) continue;\n                    if (i + e[j].size() <= t.size()) {\n                        dp[i + e[j].size()][s | 1<<j] |= valid[i][j];\n                    }\n                }\n            }\n        }\n\n        ll ans = 0;\n        REP(i, t.size()) {\n            if (dp[i+1][(1<<n)-1]) ++ans;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\n\nll fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<string> vs;\n    map<string, int> mp;\n    rep(i, N) {\n      string s; cin >> s;\n      mp[s] ++;\n      vs.push_back(s);\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].size();\n      }\n    }\n\n    string T;\n    rep(i, M) {\n      char s[5001]; cin >> s, T += s;\n    }\n\n    int TSize = T.size();\n    \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(!T.compare(st + sizes[S], sizes[S|(1<<i)] - sizes[S], vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n\n    for(auto e: mp) {\n      sum /= fact[e.second];\n    }\n\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[5000][1<<13];\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n    memset(dp,false,sizeof(dp));\n    rep(i,5000) dp[i][0] = true;\n    rep(pos,len){\n        rep(i,n){\n            rep(mask,1<<n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst ll mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<ll> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tll hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\nint n, m;\nshort dp[1 << 12][5555];\nvs v;\n//vector<set<int>> match;\nvector<vi> match;\n\nint solve(int bit, int p)\n{\n\tif (bit == (1 << n) - 1) return 1;\n\tif (dp[bit][p] >= 0) return dp[bit][p];\n\tint res = 0;\n\tREP(i, match[p].size())\n\t{\n\t\tif ((bit >> match[p][i]) & 1) continue;\n\t\tchmax(res, solve(bit | (1 << match[p][i]), p + v[match[p][i]].size()));\n\t}\n\treturn dp[bit][p] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n >> m, n)\n\t{\n\t\tMS(dp, -1);\n\t\tv.clear(), match.clear();\n\t\tv.resize(n);\n\t\tstring s;\n\t\tREP(i, n) cin >> v[i];\n\t\tREP(i, m)\n\t\t{\n\t\t\tstring t; cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tRollingHash hs(s);\n\t\tmatch.resize(s.size());\n\t\tREP(i, n)\n\t\t{\n\t\t\tRollingHash pat(v[i]);\n\t\t\tll pat1 = pat.hash(0, v[i].size(), 0);\n\t\t\tll pat2 = pat.hash(0, v[i].size(), 1);\n\t\t\tREP(j, (int)s.size() - (int)v[i].size() + 1)\n\t\t\t{\n\t\t\t\tll hs1 = hs.hash(j, j + v[i].size(), 0);\n\t\t\t\tll hs2 = hs.hash(j, j + v[i].size(), 1);\n\t\t\t\tif (pat1 == hs1 && pat2 == hs2) match[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint len = 0;\n\t\tfor (auto i : v) len += i.size();\n\t\tll ans = 0;\n\t\tREP(i, (int)s.size() - len + 1)\n\t\t{\n\t\t\tans += solve(0, i);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>\n#include<algorithm>\n#include<set>\n#include<vector>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_E 13\n\nusing namespace std;\n\nint n,m;\nstring e[MAX_E];\nstring text;\nbool dp[5001][(1<<12)];\nbool isAble[5001][12];\n\nint main()\n{\n  int tmp;\n  while(tmp = scanf(\"%d %d\",&n,&m),n|m)\n    {\n      rep(i,n)\n\t{\n\t  cin >> e[i];\n\t}\n      text = \"\";\n      rep(i,m)\n\t{\n\t  string content;\n\t  cin >> content;\n\t  text += content;\n\t}\n\n      int len = text.size();\n     rep(i,len+1)rep(j,(1<<n))dp[i][j] = false;\n      int ans = 0;\n\n      rep(i,len)\n\t{\n\t  rep(j,n)\n\t    {\n\t      isAble[i][j] = false;\n\t      int e_len = e[j].size();\n\t      if(i+e_len > text.size())continue;\n\t      if(text[i] != e[j][0])continue;\n\t      if(text.substr(i,e_len) == e[j])\n\t\t{\n\t\t  isAble[i][j] = true;\n\t\t  dp[i+e_len][(1<<j)] = true;\n\t\t}\n\t    }\n\t}\n\n      rep(cur,len+1)\n\t{\n\t  rep(state,(1<<n))\n\t    {\n\t      if(dp[cur][state] == false)continue;\n\t      rep(k,n)\n\t\t{\n\t\t  if((state>>k) & 1)continue;\n\t\t  if(!isAble[cur][k])continue;\n\t\t  int e_len = e[k].size();\n\t\t  if(e[k][0] != text[cur])continue;\n\t\t  if(text.size() < cur+e_len)continue;\n\t\t  //if(text.substr(cur,e_len) == e[k])\n\t\t  //{\n\t\t      dp[cur+e_len][state|(1<<k)] = true;\n\t\t      //}\n\t\t}\n\t    }\n\t  if(dp[cur][(1<<n)-1])ans++;\n\n\t}\n      printf(\"%d\\n\",ans);\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tchar name[21];\n\tint length;\n};\n\n\nint POW[21];\nint N,num_line,TEXT_LENGTH;\nchar buf[101],TEXT[5001];\nbool is_match[5001],pattern_match[5001][20];\nInfo info[20];\nmap<int,bool> MAP;\n\n\nvoid recursive(int start_loc,int loc,int state){\n\tif(is_match[start_loc])return; //すくなくとも1つがマッチしたならreturn\n\n\tif(state == POW[N]-1){ //全文字一致\n\t\tis_match[start_loc] = true;\n\t\treturn;\n\t}\n\n\tint next_state,next_loc;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tif(state & (1 << loop)){ //使用済\n\t\t\t//Do nothin\n\t\t}else{ //TEXT[loc]から、info[loop]との一致比較\n\t\t\tif(pattern_match[loc][loop]){\n\t\t\t\tnext_state = state+POW[loop];\n\t\t\t\tauto at = MAP.find(next_state);\n\t\t\t\tif(at != MAP.end())continue;\n\t\t\t\tMAP[next_state] = true;\n\t\t\t\tnext_loc = loc+info[loop].length;\n\t\t\t\trecursive(start_loc,next_loc,next_state);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tint length,sum_length = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].name);\n\t\tfor(length = 0; info[i].name[length] != '\\0'; length++);\n\t\tinfo[i].length = length;\n\t\tsum_length += length;\n\t}\n\n\t//テキストの読み込み\n\tint index = 0;\n\tfor(int loop = 0; loop < num_line; loop++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int k = 0; buf[k] != '\\n' && buf[k] != '\\0'; k++){\n\t\t\tTEXT[index++] = buf[k];\n\t\t}\n\t}\n\tTEXT_LENGTH = index;\n\n\tfor(int i = 0; i < TEXT_LENGTH; i++)is_match[i] = false;\n\n\tbool FLG;\n\t//場所と文字の一致を先に計算しておく\n\tfor(int loc = 0; loc < TEXT_LENGTH; loc++){\n\t\tfor(int i = 0; i < N; i++)pattern_match[loc][i] = false;\n\t}\n\n\tfor(int loc = 0; loc < TEXT_LENGTH; loc++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(loc+info[i].length > TEXT_LENGTH)continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; k < info[i].length; k++){\n\t\t\t\tif(TEXT[loc+k] != info[i].name[k]){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)pattern_match[loc][i] = true;\n\t\t}\n\t}\n\n\n\n\t//一致の先頭となりえる箇所を全探索\n\tfor(int start_loc = 0; start_loc <= TEXT_LENGTH-sum_length; start_loc++){\n\t\tMAP.clear();\n\t\trecursive(start_loc,start_loc,0);\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < TEXT_LENGTH; i++){\n\t\tif(is_match[i])ans++;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 21; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&num_line);\n\t\tif(N == 0 && num_line == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007LL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    string e[n],t[m];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<m;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<m;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<int,map<ull,set<int> > > m;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(auto &a:m){\n\tint l=a.first;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tauto &p=a.second;\n\tif(!p.count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=p[u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n// ok[i][j] := elm[i] が s[j] で受理されるか\nbool ok[12][5000];\n// dp[i][j] := s[i] までで j(mask) が受理されるか\nbool dp[5000][1 << 12];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        vector<string> elm(n);\n        for (int i = 0; i < n; i++)\n            cin >> elm[i];\n        string s = \"\";\n        for (int i = 0; i < m; i++)\n        {\n            string a;\n            cin >> a;\n            s += a;\n        }\n        int m = s.size();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                ok[i][j] = false;\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < (1 << n); j++)\n                dp[i][j] = false;\n        for (int i = 0; i < n; i++)\n        {\n            int sz = elm[i].size();\n            for (int j = 0; j <= m - sz; j++)\n            {\n                if (elm[i] == s.substr(j, sz))\n                {\n                    ok[i][j + sz - 1] = true;\n                    dp[j + sz - 1][1 << i] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 1; j < (1 << n); j++)\n            {\n                if (!dp[i][j])\n                    continue;\n                for (int k = 0; k < n; k++)\n                {\n                    int sz = elm[k].size();\n                    if (i + sz >= m)\n                        continue;\n                    if ((j >> k) & 1)\n                        continue;\n                    if (!ok[k][i + sz])\n                        continue;\n                    dp[i + sz][j ^ (1 << k)] = true;\n                }\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < m; i++)\n            if (dp[i][(1 << n) - 1])\n                ret++;\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 1e18+10 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nint dp[55][55][2][1333];\nint bef[1030][55][55];\nsigned main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tstring text=\"\";\n\t\trep(i,m){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\ttext+=s;\n\t\t}\n\t\tint sum=0;\n\t\trep(i,n)sum+=in[i].size();\n\t\tm=text.size();\n\t\tvvi isok(m,vi(n));\n\t\trep(i,m)rep(j,n){\n\t\t\tif(text.substr(i,in[j].size())==in[j])isok[i][j]=1;\n\t\t}\n\t\tint co=0;\n\t\trep(i,m){\n\t\t\tif(i+sum>m)continue;\n\t\t\tvi dp(1<<n);\n\t\t\tdp[0]=1;\n\t\t\trep(j,1<<n)if(dp[j]){\n\t\t\t\tint c=0;\n\t\t\t\trep(k,n)if(j&1<<k)c+=in[k].size();\n\t\t\t\trep(k,n)if((j&1<<k)==0){\n\t\t\t\t\tif(isok[i+c][k])dp[j|1<<k]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[(1<<n)-1]){\n//\t\t\t\tcout<<i<<endl;\n\t\t\t\tco++;\n\t\t\t}\n\t\t}\n\t\tcout<<co<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N) {\n    string S[12], T;\n    int sum = 0;\n    for(int i = 0; i < N; i++) cin >> S[i], sum += S[i].size();\n    for(int i = 0; i < M; i++) {\n      string q;\n      cin >> q;\n      T += q;\n    }\n\n    vector< int > pos(1 << N, N);\n    for(int i = 0; i < 1 << N; i++) {\n      for(int j = 0; j < N; j++) if((i >> j) & 1) pos[i] += S[j].size();\n    }\n\n    long long ret = 0LL;\n    for(int i = 0; i <= (int) T.size() - sum; i++) {\n      bool dp[1 << 12] = {};\n      dp[0] = true;\n      for(int j = 0; j < 1 << N; j++) {\n        if(!dp[j]) continue;\n        for(int k = 0; k < N; k++) {\n          if((j >> k) & 1) continue;\n          if(dp[j | (1 << k)]) continue;\n          dp[j | (1 << k)] |= [&]()\n          {\n            for(int l = 0; l < S[k].size(); l++) {\n              if(S[k][l] != T[i + l + pos[j]]) return (false);\n            }\n            return (true);\n          }();\n        }\n      }\n      ret += dp[(1 << N) - 1];\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<ull,set<int> > m[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tauto& a=m[l];\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!a.count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=a[u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst ll mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<ll> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tll hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\nint n, m;\nint dp[1 << 12][5555];\nvs v;\n//vector<set<int>> match;\nvector<vi> match;\n\nint solve(int bit, int p)\n{\n\tif (bit == (1 << n) - 1) return 1;\n\tif (dp[bit][p] >= 0) return dp[bit][p];\n\tint res = 0;\n\tREP(i, match[p].size())\n\t{\n\t\tif ((bit >> match[p][i]) & 1) continue;\n\t\tchmax(res, solve(bit | (1 << match[p][i]), p + v[match[p][i]].size()));\n\t}\n\treturn dp[bit][p] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n >> m, n)\n\t{\n\t\tMS(dp, -1);\n\t\tv.clear(), match.clear();\n\t\tv.resize(n);\n\t\tstring s;\n\t\tREP(i, n) cin >> v[i];\n\t\tREP(i, m)\n\t\t{\n\t\t\tstring t; cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tRollingHash hs(s);\n\t\tmatch.resize(s.size());\n\t\tREP(i, n)\n\t\t{\n\t\t\tRollingHash pat(v[i]);\n\t\t\tll pat1 = pat.hash(0, v[i].size(), 0);\n\t\t\tll pat2 = pat.hash(0, v[i].size(), 1);\n\t\t\tREP(j, (int)s.size() - (int)v[i].size() + 1)\n\t\t\t{\n\t\t\t\tll hs1 = hs.hash(j, j + v[i].size(), 0);\n\t\t\t\tll hs2 = hs.hash(j, j + v[i].size(), 1);\n\t\t\t\tif (pat1 == hs1 && pat2 == hs2) match[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tint len = 0;\n\t\tfor (auto i : v) len += i.size();\n\t\tll ans = 0;\n\t\tREP(i, (int)s.size() - len + 1)\n\t\t{\n\t\t\tans += solve(0, i);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[1<<12][5000];\n\nint main(){\n  for(int i=0;i<(1<<12);i++){\n    for(int j=0;j<5000;j++) dp[i][j]=1;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool dp[5001][1<<12],mat[5000][12];\n\nint main()\n{\n\tint N,M;\n\twhile(cin >> N >> M, (N||M))\n\t{\n\t\tint cnt=0;\n\t\tstring str[12], text;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(mat, 0, sizeof(mat));\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> str[i];\n\t\t\t\n\t\twhile(M--)\n\t\t{\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\ttext+=t;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<=text.size()-str[i].size(); j++)\n\t\t{\n\t\t\tbool g=true;\n\t\t\tfor(int k=0; k<str[i].size(); k++)\n\t\t\t{\n\t\t\t\tif(text[j+k]!=str[i][k])\n\t\t\t\t{\n\t\t\t\t\tg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmat[j][i]=g;\n\t\t}\n\t\t\n\n\t\tfor(int i=0; i<text.size(); i++)\n\t\tfor(int j=0; j<(1<<N); j++)\n\t\t{\n\t\t\tfor(int k=0; k<N; k++)\n\t\t\t{\n\t\t\t\tif(mat[i][k])\n\t\t\t\t{\n\t\t\t\t\tif(j==(1<<k)) \n\t\t\t\t\t{\n\t\t\t\t\t\tdp[i+str[k].size()][j]=1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(j&(1<<k)) continue;\n\t\t\t\t\t\tif(dp[i][j]) dp[i+str[k].size()][j+(1<<k)]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<=text.size(); i++)\n\t\t\tif(dp[i][(1<<N)-1]) cnt++;\n\t\t\t\n\t\t\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    function<void(int,int,string&)> dfs=[&](int d,int c,string& s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tfor(int j=0;j<(int)e[i].size();j++)\n\t  s.push_back(e[i][j]);\n\tdfs(d+1,c+(1LL<<i),s);\n\tfor(int j=0;j<(int)e[i].size();j++)\n\t  s.pop_back();\n      }\n    };\n      string tmp;\n    dfs(0,0,tmp);\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint n, m;\nchar dp[5001][1<<12];\nmain(){\n\tint i,j;\n\twhile(cin >> n >> m, n){\n\t\tstring t;\n\t\tvector<string> s(n);\n\t\tREP(i, n) cin >> s[i];\n\t\tREP(i, m){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tt += s;\n\t\t}\n\t\tvector< vector<int> > g(t.size()+1);\n\t\tREP(i, t.size()){\n\t\t\tREP(j, n){\n\t\t\t\tif(i+s[j].size()-1 >= t.size()) continue;\n\t\t\t\tint f = 1;\n\t\t\t\tREP(k, s[j].size()) f &= t[i+k] == s[j][k];\n\t\t\t\tif(f) g[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tll ans = 0;\n\t\tREP(i, t.size()+1){\n\t\t\tdp[i][0] = 1;\n\t\t\tREP(j, 1 << n){\n\t\t\t\tif(dp[i][j]) FOR(k, g[i]){\n\t\t\t\t\tif(1&(j>>*k)) continue;\n\t\t\t\t\tdp[i+s[*k].size()][j|(1<<*k)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += dp[i][(1<<n)-1];\n//\t\t\tprintf(\"%c ans[%d] = %lld\\n\", t[i], i, dp[i][(1<<n)-1]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<short> ln[400];\n    int count=0;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tcount++;\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(short j:ln[l]){\n\t  short k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\nstruct Edge {\n\tint from, to, cost;\n\tbool operator<(Edge e) {\n\t\treturn cost < e.cost;\n\t}\n};\n\n\nint main() {\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0)break;\n\t\tvs pat(N);\n\t\tstring text = \"\";\n\t\trep(i, N) {\n\t\t\tcin >> pat[i];\n\t\t}\n\t\trep(i, M) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext += str;\n\t\t}\n\t\tint L = text.size();\n\t\tvvb dp(1 << N, vb(L, false));\n\n\t\trep(j, N) {\n\t\t\trep(k, L - pat[j].size() + 1) {\n\t\t\t\tbool flag = true;\n\t\t\t\trep(l, pat[j].size()) {\n\t\t\t\t\tif (text[k + l] != pat[j][l]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tdp[1 << j][k + pat[j].size() - 1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trepl(i, 1, 1 << N) {\n\t\t\trep(j, N) {\n\t\t\t\tif ((i&(1 << j)) != 0) {\n\t\t\t\t\tif ((i ^ (1 << j)) == 0)continue;\n\n\t\t\t\t\trepl(k, 1, L - pat[j].size() + 1) {\n\t\t\t\t\t\tif (dp[(i ^ (1 << j))][k - 1]) {\n\t\t\t\t\t\t\tif (dp[1 << j][k + pat[j].size() - 1]) {\n\t\t\t\t\t\t\t\tdp[i][k + pat[j].size() - 1] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, L) {\n\t\t\tif (dp[(1 << N) - 1][i])ans++;\n\t\t}\n\t\t/*\n\t\trep(i, 1 << N) {\n\t\t\trep(j, L) {\n\t\t\t\tcout << \"xo\"[dp[i][j]];\n\t\t\t}\n\t\t\tcout << static_cast<std::bitset<3>>(i) << endl;\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<string> e(n);\n    string ts;\n    int concatenated_len=0;\n    rep(i,0,n){\n        cin >> e[i];\n        concatenated_len+=e[i].size();\n    }\n    rep(i,0,m){\n        string t;\n        cin >> t;\n        ts+=t;\n    }\n\n    static bool p[5000][1<<12];\n    fill_n((bool*)p,500*(1<<12),false);\n    vector<vector<int>> heads(ts.size());\n    rep(i,0,ts.size()) p[i][0]=true;\n    rep(i,0,ts.size()){\n        rep(j,0,n){\n            if(i+e[j].size()>ts.size() or e[j]!=ts.substr(i,e[j].size())) continue;\n            p[i][1<<j]=true;\n            heads[i].push_back(j);\n        }\n    }\n    int ans=0;\n    for(int i=ts.size()-1; i>=0; --i){\n        rep(j,1,1<<n){\n            for(int k:heads[i]){\n                if(((j>>k)&1)==0) continue;\n                int i2=i+e[k].size();\n                if(p[i2][j&(~(1<<k))]){\n                    p[i][j]=true;\n                    break;\n                }\n            }\n        }\n        if(p[i][(1<<n)-1]) ++ans;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef int_t hash_t;\n    int_t base1;\n    int_t mod1;\n    static int_t hash1[6000];\n    static int_t pow1[6000];\n    RollingHash() : base1(1009), mod1(1000000007) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1[0] = 0;\n        pow1[0] = 1;\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        return t1;\n    }\n};\nRollingHash::int_t RollingHash::hash1[6000];\nRollingHash::int_t RollingHash::pow1[6000];\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<RollingHash::hash_t> hs(n);\n    RollingHash rh;\n    rep(i,n){\n        rh.init(ss[i]);\n        hs[i] = rh.get(0,ss[i].size());\n    }\n    rh.init(t);\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            rep(i,n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    if(pos+ss[i].size() > t.size()) continue;\n                    if(rh.get(pos,pos+ss[i].size()) != hs[i]) continue;\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nstring c[20];\nstring s;\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i];\n\t\t\tfor(int j = 0 ; j < c[i].size() ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += c[i].size();\n\t\t}\n\t\ts = \"\";\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring t;cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint len = s.size();\n\t\tif( len > 5000 ) assert(0);\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring e[12];\nint idx[5010];\nbool dp[5010][1 << 12];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tmap<string, int> sm;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> e[i];\n\t\t\tsm[e[i]]++;\n\t\t}\n\t\tstring s;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint L = s.size();\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tidx[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint len = e[i].length();\n\t\t\tfor(int j = 0; j + len <= L; j++){\n\t\t\t\tif(e[i] == s.substr(j, len)) idx[j] |= 1 << i;\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int i = 0; i < L + 1; i++){\n\t\t\tdp[i][0] = 1;\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < 1 << n; j++){\n\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(idx[i] >> k & 1){\n\t\t\t\t\t\tif(j >> k & 1) continue;\n\t\t\t\t\t\tint len = e[k].length();\n\t\t\t\t\t\tdp[i + len][j | (1 << k)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i <= L; i++){\n\t\t\tans += dp[i][(1 << n) - 1];\n\t\t}\n\t\t/*for(auto v : sm){\n\t\t\tif(v.second >= 2){\n\t\t\t\tfor(int i = 2; i <= v.second; i++){\n\t\t\t\t\tans /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n];\n    for(int i=0;i<n;i++) cin>>e[i];\n    string b,t;\n    for(int i=0;i<M;i++){\n      cin>>t;\n      b+=t;\n    }\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\t//sa.insert(rh.find(0,s.size()));\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\t//if(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \ninline long long to_int64(char x) {\n  return (long long)x;\n}\n  \nstruct RollingHash {\n    \n  const array<int, 2> mods = {{int(1e9+7), int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 2> Ks = {{1007, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n  \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n  \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n  \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n  \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n   \n  RollingHash(string const& s) {\n    S = s;\n    N = s.size();\n    construct();\n  }\n  \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n\n  bool same(int a_start, int a_end, int b_start, int b_end, RollingHash const& rh) const {\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh.get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n};\n \nint fact[13];\nint DP[5010][1<<12];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<RollingHash> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(RollingHash(s));\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      char s[5001]; cin >> s, t += s;\n    }\n\n    RollingHash T(t);\n    int TSize = t.size();\n \n    ll sum = 0;\n    rep(i, TSize + 10) rep(j, 1<<N) DP[i][j] = 0;\n    \n    rep(st, TSize) {\n      int* dp = DP[st];\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i].N, vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint N,M;\nstring S;\nstring ks[13];\n \nint sc[(1<<12)];\nbool dp[(1<<12)];\n \nbool solve(int id){\n  memset(dp,0,sizeof(dp));\n  dp[0] = 1;\n  int n = S.size();\n  if( n-id < sc[(1<<N)-1] ) return false;\n  for(int i=0;i<(1<<N);i++){\n    if( !dp[i] ) continue;\n    for(int j=0;j<N;j++){\n      if( i & (1<<j) ) continue;\n      if( S.compare(id+sc[i],ks[j].size(),ks[j]) == 0 ){\n    //  cout << S.substr(id+sc[i]) << \" \"<< ks[j] << \" \" << S.compare(id+sc[i],ks[j].size(),ks[j]) << endl;\n    dp[i|(1<<j)] = 1;     \n      }\n    }\n  }\n  return dp[(1<<N)-1];\n}\n \nint main(){\n  while( cin >> N >> M && (N||M) ){\n \n    memset(sc,0,sizeof(sc));\n \n    for(int i=0;i<N;i++){\n      cin >> ks[i];\n    }\n \n    for(int i=0;i<(1<<N);i++){\n      for(int j=0;j<N;j++){\n    if( i & (1<<j) ) sc[i] += (int)ks[j].size();\n      }\n    }\n     \n    S.clear();\n    for(int j=0;j<M;j++){\n      string s;\n      cin >> s;\n      S+=s;\n    }\n    int res = 0;\n    for(int i=0;i<(int)S.size();i++){\n      if( solve(i) ) res++;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\ninline long long to_int64(char x) {\n  return (long long)x;\n}\n \ntemplate<class T> struct RollingHash {\n   \n  const array<int, 3> mods = {{int(1e9+7), int(1e9+9), int(1234567891)}};\n  const array<int, 3> Ks = {{1007, 1009, 1013}};\n  const int ModsSize = mods.size();\n \n  vector<T> S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n  \n  RollingHash(vector<T> const& S) {\n    this->S = S;\n    construct();\n  }\n \n  RollingHash(string const& S) {\n    int n = S.size();\n    rep(i, n) { this->S.push_back(S[i]); }\n    construct();\n  }\n \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n \n  // テ」ツδ湘」ツδε」ツつキテ」ツδ・テ・ツ?、テ」ツ?古・ツ?ィテ」ツ?ヲテ」ツ?ョMODテ」ツ?ァテ、ツクツ?ィツ?エテ」ツ?凖」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津・ツ按、テ・ツョツ堙」ツ?凖」ツつ?\n  bool same(int a_start, int a_end, int b_start, int b_end) const { // not verified\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n \n  // テ、ツサツ姪」ツ?ョテヲツ鳴?・ツュツ療・ツ按療」ツ?ョテゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ィテ」ツ?ョテ、ツクツ?ィツ?エテ・ツ按、テ・ツョツ堙」ツつ津」ツ?凖」ツつ?\n  bool same(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> const& rh) const {\n    if(rh == nullptr) { return same(a_start, a_end, b_start, b_end); }\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh->get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n \n  // ティツセツ榲ヲツ崢クテゥツ??・ツ、ツァテ・ツーツ湘・ツ按、テ・ツョツ?\n  bool compare(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> rh = nullptr) const {  // not verified\n    int a_len = a_end - a_start;\n    int b_len = b_end - b_start;\n \n    int len = min(a_len, b_len);\n    int max_len = len + 1;\n    int min_len = 0;\n \n    // テ」ツ?ゥテ」ツ?禿」ツ?セテ」ツ?ァテ、ツクツ?ィツ?エテ」ツ?凖」ツつ凝」ツ?凝」ツつ津、ツコツ古・ツ按?ヲツ篠「テァツエツ「テ」ツ?ァティツェツソテ」ツ?ケテ」ツつ?\n    while(min_len + 1 < max_len) {\n      int next_len = (min_len + max_len) / 2;\n      if(same(a_start, a_start + next_len, b_start, b_start + next_len, rh)) {\n        min_len = next_len;\n      }\n      else {\n        max_len = next_len;\n      }\n    }\n \n    if(a_start + min_len == a_end) {\n      if(b_start + min_len == b_end) { return 0; }\n      else { return -1; }\n    }\n    else {\n      if(b_start + min_len == b_end) { return 1; }\n      else { return S[a_start + min_len] == S[b_start + min_len]; }\n    }\n \n  }\n \n};\n\nint fact[13];\n\nint main() {\n\n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<shared_ptr<RollingHash<char>>> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(make_shared<RollingHash<char>>(RollingHash<char>(s)));\n    }\n    string t;\n    rep(i, M) {\n      string s; cin >> s, t += s;\n    }\n    RollingHash<char> T(t);\n    int TSize = t.size();\n\n    ll sum = 0;\n\n    rep(st, TSize) {\n      int dp[1<<N][N];\n      memset(dp, 0, sizeof dp);\n      rep(i, N) {\n        if(T.same(st, st + vs[i]->S.size(), 0, vs[i]->S.size(), vs[i])) {\n          dp[1<<i][i] = 1;\n        }\n      }\n\n      rep(S, 1<<N) {\n        int size = 0;\n        rep(i, N)\n          if(S >> i & 1)\n            size += vs[i]->S.size();\n        rep(u, N) {\n          if(!(S >> u & 1)) continue;\n          rep(i, N) {\n            if(S >> i & 1) continue;\n            if(T.same(st + size, st + size + vs[i]->S.size(), 0, vs[i]->S.size(), vs[i])) {\n              dp[S | (1<<i)][i] += dp[S][u];\n            }\n          }\n        }\n      }\n\n      rep(i, N) {\n        sum += dp[(1<<N)-1][i];\n      }\n    }\n\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 1000000007;\null p[6000], thash[6000];\null shash[13];\n\nint n,m;\nint len;\nchar t[6000];\nchar ss[13][6000];\nint sslen[13];\n\nint solve(){\n    rep(i,n){\n        ull x = 0;\n        for(int j=0;ss[i][j];j++) x = x*B + ss[i][j];\n        shash[i] = x;\n    }\n    p[0] = 1;\n    thash[0] = 0;\n    rep(i,len) thash[i+1] = thash[i]*B + t[i];\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+sslen[i] > len) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+sslen[i]] - thash[pos] * p[sslen[i]];\n                // if(h1 != h2) continue;\n                dp[pos+sslen[i]][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    p[0] = 1;\n    rep(i,5001) p[i+1] = p[i]*B;\n\n    while(scanf(\"%d%d\",&n,&m), n){\n        len = 0;\n        rep(i,n){\n            scanf(\"%s\",ss[i]);\n            sslen[i] = strlen(ss[i]);\n        }\n        rep(i,m){\n            static char buf[6000];\n            scanf(\"%s\",buf);\n            int l;\n            for(l=0; buf[l]; l++) t[l+len] = buf[l];\n            len += l;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\nusing namespace std;\n\nvoid solve(int n,int m){\n\tstring e[12],T;\n\tint ans=0,s=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t\ts+=e[i].size();\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\t\n\tfor(int j=0;j<=T.size()-s;++j){\n\t\tint x=j;\n\t\tbool f[12],g;\n\t\tfill(f,f+n,false);\n\t\tfor(int k=0;k<n;++k){\n\t\t\tg=false;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tif(f[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(T.substr(x,e[i].size())!=e[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx+=e[i].size();\n\t\t\t\tf[i]=true;\n\t\t\t\tg=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!g){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(g){\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(n,m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<ll, ll> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nconst ll mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<ll> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tll hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\n\nint n, m, k;\nvs v;\nvector<pii> vrh;\nshort dp[5001][1 << 12];\t\nstring s;\nRollingHash rh;\n\nint is_match(int p, int i)\n{\n\tif (pii(rh.hash(p, p + v[i].size(), 0), rh.hash(p, p + v[i].size(), 1)) == vrh[i]) return 1;\n\telse return 0;\n}\n\nint solve(int p, int used)\n{\n\tif (used == (1 << n) - 1) return 1;\n\tif (dp[p][used] >= 0) return dp[p][used];\n\tint res = 0;\n\tREP(i, n)\n\t{\n\t\tif ((used >> i) & 1) continue;\n\t\tif (is_match(p, i))\n\t\t{\n\t\t\tchmax(res, solve(p + v[i].size(), used | (1 << i)));\n\t\t}\n\t}\n\treturn dp[p][used] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n >> m, n)\n\t{\n\t\tMS(dp, -1);\n\t\tv.clear();\n\t\ts.clear();\n\t\tvrh.clear();\n\t\tk = 0;\n\t\tv.resize(n); cin >> v;\n\t\tfor (auto &i : v)\n\t\t{\n\t\t\tk += i.size();\n\t\t\tRollingHash rh(i);\n\t\t\tvrh.emplace_back(rh.hash(0, i.size(), 0), rh.hash(0, i.size(), 1));\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tstring a; cin >> a;\n\t\t\ts += a;\n\t\t}\n\t\trh = RollingHash(s);\n\t\tint ans = 0;\n\t\tREP(i, s.size() - k + 1)\n\t\t{\n\t\t\tstring t = s.substr(i, k);\n\t\t\tans += solve(i, 0);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef int_t hash_t;\n    int_t base1;\n    int_t mod1;\n    static int_t hash1[6000];\n    static int_t pow1[6000];\n    RollingHash() : base1(1009), mod1(1000000007) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1[0] = 0;\n        pow1[0] = 1;\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        return t1;\n    }\n};\nRollingHash::int_t RollingHash::hash1[6000];\nRollingHash::int_t RollingHash::pow1[6000];\n\nint solve(vector<string> & ss, string & t){\n    int n = ss.size();\n    int len = t.size();\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+ss[i].size() > t.size()) continue;\n                // dp[pos+ss[i].size()][mask|1<<i] |= t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<complex>\nusing namespace std;\n\n#define REP(i, N) for(int i = 0; i < (int)(N); i++)\nbool dp[32][1 << 12];\n\nint main() {\n\tfor(int N, M; cin >> N >> M, (N || M); ) {\n\t\tstring str;\n\t\tstring word[12];\n\t\tREP(i, N) cin >> word[i];\n\t\tREP(i, M) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstr += s;\n\t\t}\n\t\tint len = str.size();\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(j, 32) dp[j][0] = true;\n\t\t\n\t\tint mask = (1 << N) - 1;\n\t\tint sum = 0;\n\t\tREP(pos, len + 1) {\n\t\t\tint j = pos & 31;\n\t\t\tREP(i, N) if( word[i] == str.substr(pos, word[i].size()) ) {\n\t\t\t\tint am = (pos + word[i].size()) & 31;\n\t\t\t\tREP(state, mask) if( (state & (1 << i) ) == 0){\n\t\t\t\t\tdp[am][state | (1 << i)] |= dp[j][state];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dp[j][mask];\n\t\t\tfor(int state = 1; state < 1 << N; state++)\n\t\t\t\tdp[j][state] = 0; \n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    unordered_map<ull,set<int> > m[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!m[l].count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=m[l][u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nstring c[20];\nstring s;\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) A[i] = 0;\n\t\tfor(int i = 0 ; i < 20 ; i++) D[i] = 0;\n\t\tfor(int i = 0 ; i < 20 ; i++) c[i] = \"\";\n\t\t\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i];\n\t\t\tfor(int j = 0 ; j < c[i].size() ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += c[i].size();\n\t\t}\n\t\ts = \"\";\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < m ; i++){ \n\t\t\tstring t;cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint len = s.size();\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\n\ninline long long to_int64(char x) {\n  return (long long)x;\n}\n   \nstruct RollingHash {\n     \n  const array<int, 1> mods = {{int(1e9+7)}};//, int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 1> Ks = {{1007}};//, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n   \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n   \n  void construct() {\n    hash.resize(ModsSize);\n    rep(i, ModsSize) hash[i].resize(N+1);\n    rep(i, ModsSize) {\n      for(int j=N-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n   \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(N+1);\n   \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, N+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  } \n    \n  RollingHash(string const& s) {\n    S = s;\n    N = s.size();\n    construct();\n  }\n   \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n \n  bool same(int a_start, int a_end, int b_start, int b_end, RollingHash const& rh) const {\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh.get_hash(i, b_start, b_end)) return false;\n    }\n    return true;\n  }\n   \n};\n\nint sizes[1<<12];\n\nint main() {\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<RollingHash> vs;\n    rep(i, N) {\n      string s; cin >> s;\n      vs.push_back(RollingHash(s));\n    }\n \n    rep(i, 1<<N) sizes[i] = 0;\n\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      char s[5001];\n      scanf(\"%s\", s);\n      t += s;\n    }\n\n    int TSize = t.size();\n    RollingHash T(t);\n    \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i].N, vs[i])) {\n            dp[S|(1<<i)] = 1;\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring e[12];\nint idx[5010];\nll dp[5010][1 << 12];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tmap<string, int> sm;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> e[i];\n\t\t\tsm[e[i]]++;\n\t\t}\n\t\tstring s;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint L = s.size();\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tidx[i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint len = e[i].length();\n\t\t\tfor(int j = 0; j + len <= L; j++){\n\t\t\t\tif(e[i] == s.substr(j, len)) idx[j] |= 1 << i;\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, 0, sizeof dp);\n\t\tfor(int i = 0; i < L + 1; i++){\n\t\t\tdp[i][0] = 1;\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < 1 << n; j++){\n\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(idx[i] >> k & 1){\n\t\t\t\t\t\tif(j >> k & 1) continue;\n\t\t\t\t\t\tint len = e[k].length();\n\t\t\t\t\t\tdp[i + len][j | (1 << k)] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i <= L; i++){\n\t\t\tans += dp[i][(1 << n) - 1];\n\t\t}\n\t\tfor(auto v : sm){\n\t\t\tif(v.second >= 2){\n\t\t\t\tfor(int i = 2; i <= v.second; i++){\n\t\t\t\t\tans /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#define MAXSTACK 300000\n#define MAXSIZE 5010\n#define MAXN 12\n\nstruct obj {\n   short int p, m;\n} tmpobj, s[MAXSTACK];\n\nbool starts[MAXSIZE][MAXN], ins[MAXSIZE][1<<MAXN];\n\nint main() {\n\nint N, M, i, j, k, l[MAXN], RES, FULL, E;\nstring n[MAXN], input, tmp;\n\ncin >> N; FULL = (1<<N)-1;\ncin >> M;\n\ndo {\n\nfor (i=0; i<N; i++) {cin >> n[i]; l[i] = n[i].size();}\n\ninput = \"\";\nfor (i=0; i<M; i++) {cin >> tmp; input += tmp;}\n\nmemset(starts, false, sizeof(starts));\nfor (i=0; i<input.size(); i++) {\n   for (j=1; j<=20; j++) {\n\t\ttmp = input.substr(i, j);\n\t\tfor (k=0; k<N; k++) {\n\t\t\tif (tmp == n[k]) starts[i][k] = true;\n\t\t}\n\t}\n}\n\nmemset(ins, false, sizeof(ins)); E = 0;\nfor (i=0; i<input.size(); i++) {\n\ttmpobj.p = i;\n\ttmpobj.m = 0;\n\ts[E++] = tmpobj;\n\tins[i][0] = true;\n}\n\nRES = 0;\nwhile (E > 0) {\n\ttmpobj = s[--E];\n\tif (tmpobj.m == FULL) RES++;\n\telse {\n      for (i=0; i<N; i++) if (starts[tmpobj.p][i] == true && ((tmpobj.m>>i)&1) == 0 && ins[tmpobj.p+l[i]][tmpobj.m^(1<<i)] == false) {\n   \t\ts[E].p = tmpobj.p+l[i];\n   \t\ts[E].m = tmpobj.m^(1<<i);\n\t   \tins[s[E].p][s[E].m] = true;\n\t\t\tE++;\n\t\t\tif (E == MAXSTACK) E = 0;\n   \t}\n\t}\n}\n\ncout << RES << endl;\n\ncin >> N; FULL = (1<<N)-1;\ncin >> M;\n\n} while (N!=0 || M!=0);\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \ninline long long to_int64(char x) {\n  return (long long)x;\n}\n  \ntemplate<class T> struct RollingHash {\n    \n  const array<int, 3> mods = {{int(1e9+7), int(1e9+9), int(1234567891)}};\n  const array<int, 3> Ks = {{1007, 1009, 1013}};\n  const int ModsSize = mods.size();\n  \n  vector<T> S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n  \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n  \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n  \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n   \n  RollingHash(vector<T> const& S) {\n    this->S = S;\n    construct();\n  }\n  \n  RollingHash(string const& S) {\n    int n = S.size();\n    rep(i, n) { this->S.push_back(S[i]); }\n    construct();\n  }\n  \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end) const { // not verified\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> const& rh) const {\n    if(rh == nullptr) { return same(a_start, a_end, b_start, b_end); }\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh->get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool compare(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> rh = nullptr) const {  // not verified\n    int a_len = a_end - a_start;\n    int b_len = b_end - b_start;\n  \n    int len = min(a_len, b_len);\n    int max_len = len + 1;\n    int min_len = 0;\n  \n    while(min_len + 1 < max_len) {\n      int next_len = (min_len + max_len) / 2;\n      if(same(a_start, a_start + next_len, b_start, b_start + next_len, rh)) {\n        min_len = next_len;\n      }\n      else {\n        max_len = next_len;\n      }\n    }\n  \n    if(a_start + min_len == a_end) {\n      if(b_start + min_len == b_end) { return 0; }\n      else { return -1; }\n    }\n    else {\n      if(b_start + min_len == b_end) { return 1; }\n      else { return S[a_start + min_len] == S[b_start + min_len]; }\n    }\n  \n  }\n  \n};\n \nint fact[13];\n \nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<shared_ptr<RollingHash<char>>> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(make_shared<RollingHash<char>>(RollingHash<char>(s)));\n    }\n\n    vector<int> sizes(1 << N);\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i]->S.size();\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      string s; cin >> s, t += s;\n    }\n\n    RollingHash<char> T(t);\n    int TSize = t.size();\n \n    ll sum = 0;\n    int DP[TSize + 10][1<<N];\n    memset(DP, 0, sizeof DP);\n    \n    rep(st, TSize) {\n      int* dp = DP[st];\n      rep(i, N)\n        if(T.same(st, st + vs[i]->S.size(), 0, vs[i]->S.size(), vs[i]))\n          dp[1<<i] = 1;\n\n      rep(S, 1<<N) {\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i]->S.size(), vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<climits>\n#include<algorithm>\n#include<set>\n#include<vector>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_E 13\n\nusing namespace std;\n\nint n,m;\nstring e[MAX_E];\nstring text;\nbool dp[5001][(1<<12)];\n\nint main()\n{\n  while(cin >> n >> m,n|m)\n    {\n      rep(i,n)\n\t{\n\t  cin >> e[i];\n\t}\n      text = \"\";\n      rep(i,m)\n\t{\n\t  string content;\n\t  cin >> content;\n\t  text += content;\n\t}\n\n      int len = text.size();\n      rep(i,len+1)rep(j,(1<<n))dp[i][j] = false;\n      int ans = 0;\n\n      rep(i,len)\n\t{\n\t  rep(j,n)\n\t    {\n\t      int e_len = e[j].size();\n\t      if(i+e_len >= text.size())continue;\n\t      if(text.substr(i,e_len) == e[j])\n\t\t{\n\t\t  dp[i+e_len][(1<<j)] = true;\n\t\t}\n\t    }\n\t}\n\n      rep(cur,len+1)\n\t{\n\t  rep(state,(1<<n))\n\t    {\n\t      if(dp[cur][state] == false)continue;\n\t      rep(k,n)\n\t\t{\n\t\t  if((state>>k) & 1)continue;\n\t\t  int e_len = e[k].size();\n\t\t  if(text.size() < cur+e_len)continue;\n\t\t  if(text.substr(cur,e_len) == e[k])\n\t\t    {\n\t\t      dp[cur+e_len][state|(1<<k)] = true;\n\t\t    }\n\t\t}\n\t    }\n\t  if(dp[cur][(1<<n)-1])ans++;\n\t  //ans += (long long)dp[cur][(1<<n)-1];\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\n\null StoH(string a){\n  ull res=0;\n  for(int i=0;i<a.size();i++)res=res*B+a[i];\n  return res;\n}\n\nvector<bool> search(string &a,string &key){\n  vector<bool> res(a.size(),0);\n  ull klen=key.size(),h=StoH(a.substr(0,klen)),target=StoH(key),t=1;\n  for(int i=0;i<klen;i++) t*=B;\n  for(int i=klen;i<a.size();i++){\n    if(h==target) res[i-klen]=1;\n    h = h*B+a[i]-a[i-klen]*t;\n  }\n  if(h==target) res[a.size()-klen] = 1;\n  return res;\n}\n\nint n,m,len;\nstring e[12];\nvector<bool> es[12];\nbool used[12],mem[1<<12];\n\nbool check(int idx,int sta){\n  if(sta==(1<<n)-1) return 1;\n  if(mem[sta])return 0;\n  mem[sta]=1;\n\n  for(int i=0;i<n;i++){\n    if(used[i]||!es[i][idx])continue;\n    used[i]=1;\n    if(check(idx+e[i].size(),sta+(1<<i))) return 1;\n    used[i]=0;\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n\n    len=0;\n    for(int i=0;i<n;i++)cin>>e[i],len+=e[i].size();\n  \n    string mp;\n    for(int i=0;i<m;i++){\n      string tmp;\n      cin>>tmp;\n      mp+=tmp;\n    }\n\n    for(int i=0;i<n;i++)es[i]=search(mp,e[i]);\n    int ans=0;\n    for(int i=0;i<mp.size()-len+1;i++){\n      memset(used,0,sizeof(used));\n      memset(mem,0,sizeof(mem));\n      if(check(i,0)) ans++;\n    }\n    cout<<ans<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\null p[6000], thash[6000];\null shash[13];\n\nint n,m;\nint len;\nchar t[6000];\nchar ss[13][22];\nint sslen[13];\n\nint solve(){\n    rep(i,n){\n        ull x = 0;\n        for(int j=0;ss[i][j];j++) x = x*3 + ss[i][j];\n        shash[i] = x;\n    }\n    p[0] = 1;\n    thash[0] = 0;\n    rep(i,len) thash[i+1] = thash[i]*3 + t[i];\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+sslen[i] > len) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+sslen[i]] - thash[pos] * p[sslen[i]];\n                // if(h1 != h2) continue;\n                dp[pos+sslen[i]][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    p[0] = 1;\n    rep(i,5001) p[i+1] = p[i]*3;\n\n    while(scanf(\"%d%d\",&n,&m), n){\n        len = 0;\n        rep(i,n){\n            scanf(\"%s\",ss[i]);\n            sslen[i] = strlen(ss[i]);\n        }\n        rep(i,m){\n            static char buf[22];\n            scanf(\"%s\",buf);\n            int l;\n            for(l=0; buf[l]; l++) t[l+len] = buf[l];\n            len += l;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m;\nstring e[13];\nstring text;\nint edge[5001][13];\nint dp[5001][1<<12];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> e[i];\n\t\t}\n\t\ttext=\"\";\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext+=str;\n\t\t}\n\t\tmemset(edge,0,sizeof(edge));\n\t\tint len=text.size();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=len-e[i].size();j++){\n\t\t\t\tedge[j][i]=(text.substr(j,e[i].size())==e[i])?1:0;\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tif(i==0)dp[j][i]=1;\n\t\t\t\tif(i==((1<<n)-1)){\n\t\t\t\t\tres+=dp[j][i];\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(edge[j][k]==1 && (!((i>>k) & 1))){\n\t\t\t\t\t\tdp[j+e[k].size()][i|(1<<k)]|=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\nbool dp[4096][5001];\n\nvoid solve(int n,int m){\n\tstring e[12],T;\n\tint ans=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\n\tfill(dp[0],dp[0]+T.size()+1,true);\n\tfor(int s=1;s<(1<<n);++s){\n\t\tfill(dp[s],dp[s]+T.size()+1,false);\n\t}\n\tfor(int s=0;s<(1<<n)-1;++s){\n\t\tfor(int j=0;j<T.size();++j){\n\t\t\tif(dp[s][j]){\n\t\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\t\tif(!((s>>i)&1)&&T.substr(j,e[i].size())==e[i]){\n\t\t\t\t\t\tdp[s+(1<<i)][j+e[i].size()]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=1;j<=T.size();++j){\n\t\tans+=dp[(1<<n)-1][j];\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(n,m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n];\n    for(int i=0;i<n;i++) cin>>e[i];\n    string b,t;\n    for(int i=0;i<M;i++){\n      cin>>t;\n      b+=t;\n    }\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nstring s[12],t;\nint len[12];\nint match[5000];\nbool dp[5001][1<<12];\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,n){\n      cin>>s[i];\n      len[i]=s[i].size();\n    }\n    t=\"\";\n    rep(i,m){\n      string in;\n      cin>>in;\n      t+=in;\n    }\n    m=t.size();\n    rep(i,m){\n      match[i]=0;\n      rep(j,n){\n        if(m-i<len[j])continue;\n        if(t.substr(i,len[j])==s[j])match[i]|=(1<<j);\n      }\n    }\n    rep(i,m+1)rep(j,1<<n)dp[i][j]=false;\n    rep(i,m){\n      dp[i][0]=true;\n      rep(S,1<<n){\n        if(!dp[i][S])continue;\n        rep(j,n){\n          if(((S>>j)&1)==0&&((match[i]>>j)&1)==1)dp[i+len[j]][S|(1<<j)]=true;\n        }\n      }\n    }\n    int res=0;\n    rep(i,m+1)if(dp[i][(1<<n)-1]){\n      res++;\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n// ok[i][j] := elm[i] が s[j] で受理されるか\nbool ok[12][5000];\n// dp[i][j] := s[i] までで j(mask) が受理されるか\nbool dp[5000][1 << 12];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        vector<string> elm(n);\n        for (int i = 0; i < n; i++)\n            cin >> elm[i];\n        string s = \"\";\n        for (int i = 0; i < m; i++)\n        {\n            string a;\n            cin >> a;\n            s += a;\n        }\n        int m = s.size();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                ok[i][j] = false;\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < (1 << n); j++)\n                dp[i][j] = false;\n        for (int i = 0; i < n; i++)\n        {\n            int sz = elm[i].size();\n            for (int j = 0; j <= m - sz; j++)\n            {\n                if (elm[i] == s.substr(j, sz))\n                {\n                    ok[i][j + sz - 1] = true;\n                    dp[j + sz - 1][1 << i] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 1; j < (1 << n); j++)\n            {\n                if (!dp[i][j])\n                    continue;\n                for (int k = 0; k < n; k++)\n                {\n                    int sz = elm[k].size();\n                    if (i + sz >= m)\n                        continue;\n                    if ((j >> k) & 1)\n                        continue;\n                    if (!ok[k][i + sz])\n                        continue;\n                    dp[i + sz][j ^ (1 << k)] = true;\n                }\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < m; i++)\n            if (dp[i][(1 << n) - 1])\n                ret++;\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nchar c[12][21];\nchar s[5001];\nint A[128],B[128];\nbool D[12];\n\n\nint check(){\n\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tscanf(\"%s\",c[i]);\n\t\t\tint L = strlen(c[i]);\n\t\t\tfor(int j = 0 ; j < L ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += L;\n\t\t}\n\t\tint ans = 0;\n\t\tint len = 0;\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tscanf(\"%s\",s+len);\n\t\t\tlen += strlen(s);\n\t\t}\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n//#define int long long\n\nvoid solve() {\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) return;\n        vector<string> inputs;\n        REP(i, n) {\n            string a;\n            cin >> a;\n            inputs.push_back(a);\n        }\n        string now;\n        REP(i, m) {\n            string b;\n            cin >> b;\n            now += b;\n        }\n        m = now.length();\n        vector<vector<int>> dp((1 << n), vector<int>(m+1, 0));\n        int ans = 0;\n        REP(i, m+1) {\n            dp[0][i] = 1;\n            vector<int> can;\n            REP(j, n) {\n                if (inputs[j].length() >= m + 1 - i) continue;\n                int ok = 1;\n                REP(t, inputs[j].length()) {\n                    if (inputs[j][t] != now[t + i]) {\n                        ok = 0;\n                        break;\n                    }\n                }\n                if(ok == 1)\n                can.push_back(j);\n            }\n            REP(q, (1 << n)) {\n                if (dp[q][i] == 0) continue;\n                for(auto j: can){\n                    if((q &(1 << j)) == 0)\n                        dp[q + (1 << j)][i + inputs[j].length()] += dp[q][i];\n                }\n            }\n            if (dp[(1 << n) - 1][i])\n                ans++;;\n        }\n        cout << ans << endl;\n    }\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m;\nstring e[13];\nstring text;\nint edge[5001][13];\nbool dp[5001][1<<12];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> e[i];\n\t\t}\n\t\ttext=\"\";\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext+=str;\n\t\t}\n\t\tmemset(edge,0,sizeof(edge));\n\t\tint len=text.size();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<=len-e[i].size();j++){\n\t\t\t\tedge[j][i]=(text.substr(j,e[i].size())==e[i])?1:0;\n\t\t\t}\n\t\t}\n\t\tmemset(dp,false,sizeof(dp));\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tif(i==0)dp[j][i]=true;\n\t\t\t\tif(i==((1<<n)-1)){\n\t\t\t\t\tres+=dp[j][i]?1:0;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(edge[j][k]==1 && (!((i>>k) & 1))){\n\t\t\t\t\t\tdp[j+e[k].size()][i|(1<<k)]|=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n\nint fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<string> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(s);\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].size();\n      }\n    }\n\n    string T;\n    rep(i, M) {\n      char s[5001]; cin >> s, T += s;\n    }\n\n    int TSize = T.size();\n \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      int dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(!T.compare(st + sizes[S], sizes[S|(1<<i)] - sizes[S], vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\n\null StoH(string a){\n  ull res=0;\n  for(int i=0;i<a.size();i++)res=res*B+a[i];\n  return res;\n}\n\nvector<bool> search(string &a,string &key){\n  vector<bool> res(a.size(),0);\n  ull klen=key.size(),h=StoH(a.substr(0,klen)),target=StoH(key),t=1;\n  for(int i=0;i<klen;i++) t*=B;\n  for(int i=klen;i<a.size();i++){\n    if(h==target) res[i-klen]=1;\n    h = h*B+a[i]-a[i-klen]*t;\n  }\n  if(h==target) res[a.size()-klen] = 1;\n  return res;\n}\n\nint n,m,len;\nstring e[12];\nvector<bool> es[12];\nbool used[12],mem[1<<12];\n\nbool check(int idx,int sta){\n  if(sta==(1<<n)-1) return 1;\n  if(mem[sta])return 0;\n  mem[sta]=1;\n  \n  for(int i=0;i<n;i++){\n    if(used[i]||!es[i][idx])continue;\n    used[i]=1;\n    if(check(idx+e[i].size(),sta+(1<<i))) return 1;\n    used[i]=0;\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n\n    len=0;\n    for(int i=0;i<n;i++)cin>>e[i],len+=e[i].size();\n  \n    string mp;\n    for(int i=0;i<m;i++){\n      string tmp;\n      cin>>tmp;\n      mp+=tmp;\n    }\n\n    for(int i=0;i<n;i++)es[i]=search(mp,e[i]);\n    int ans=0;\n    for(int i=0;i<mp.size()-len+1;i++){\n      memset(used,0,sizeof(used));\n      memset(mem,0,sizeof(mem));\n      if(check(i,0)) ans++;\n    }\n    cout<<ans<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<set>\n#include<algorithm>\nusing namespace std;\n#define is insert\n\nstring e[12],T;\nint n;\n\nbool dfs(int x,bool f[]){\n\tbool r=true;\n\tfor(int i=0;i<n;++i){\n\t\tif(!f[i]){\n\t\t\tr=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(r||x==T.size()){\n\t\treturn r;\n\t}\n\tset<string> s;\n\tfor(int i=0;i<n;++i){\n\t\tif(f[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(T.substr(x,e[i].size())!=e[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(s.find(e[i])!=s.end()){\n\t\t\tcontinue;\n\t\t}\n\t\ts.is(e[i]);\n\t\tf[i]=true;\n\t\tif(dfs(x+e[i].size(),f)){\n\t\t\treturn true;\n\t\t}\n\t\tf[i]=false;\n\t}\n\treturn false;\n}\n\nvoid solve(int m){\n\tint ans=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t}\n\tT.clear();\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\t\n\tfor(int j=0;j<T.size();++j){//5000\n\t\tbool f[12];\n\t\tfill(f,f+n,false);\n\t\tif(dfs(j,f)){\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint main() {\n  while(1) {\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    vector<string> vs(n);\n    REP(i,n) cin>>vs[i];\n    int sum = 0;\n    string tx;\n    REP(cnt,m) {\n      string line;\n      cin>>line;\n      tx += line;\n    }\n    int l = tx.size();\n    vector<vector<bool>> dp(l+1, vector<bool>(1<<n, false));\n    REP(i,l+1) dp[i][0] = true;\n    REP(i,1<<n) REP(j,n) {\n      if ((i>>j)&1) continue;\n      int ls = vs[j].size();\n      REP(k,l+1-ls) {\n        if (dp[k][i] && tx.substr(k, ls) == vs[j]) {\n          dp[k+ls][i|(1<<j)] = true;\n        }\n      }\n    }\n    REP(i,l+1) {\n      if (dp[i][(1<<n)-1]) ++sum;\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define P 1000000007\n#define N 1000010\ntypedef long long ll;\n//const int INF=1000000000;\nll p[N],aa[N];\n// rolling hashを計算\nvoid calcRollingHash(string &s){\n  int n=s.size();\n  aa[0]=0;\n  // hash値を計算\n  for(int i=1;i<=n;i++)aa[i]=aa[i-1]*P+s[i-1];\n}\n// 文字列の先頭位置を終端位置を指定し、ハッシュ値を取り出す\ninline ll hh(int x,int y){\n  return aa[y+1]-aa[x]*p[y-x+1];\n}\n\n// 格文字列のハッシュ値\nll hashVal[12];\nll dp[1<<12][12];\nstring strs[12];\nstring fullTxt;\n\nint n,m;\nll dfs(int pos,int mask,int cur){\n  if(dp[mask][cur]>=0)return dp[mask][cur];\n  else if(mask==(1<<n)-1)return 1;\n  ll res=0;\n  for(int i=0;i<n;i++){\n    if((mask>>i)&1)continue;\n    // ハッシュ値が一致する場合\n    if(hh(pos,pos+strs[i].size()-1)==hashVal[i]){\n      res+=dfs(pos+strs[i].size(),mask|(1<<i),i);\n    }\n  }\n  return dp[mask][cur]=res;\n}\nll fact[20];\nint main(){\n  fact[0]=1;\n  for(int i=1;i<20;i++)fact[i]=fact[i-1]*i;\n  // P**iを計算\n  p[0]=1;\n  for(int i=1;i<=10000;i++)p[i]=p[i-1]*P;\n  while(cin>>n>>m&&(n|m)){\n    fullTxt=\"\";\n    int sz=0;\n    map<string,int> scnt;\n    for(int i=0;i<n;i++){\n      cin>>strs[i];\n      scnt[strs[i]]++;\n      sz+=strs[i].size();\n      // ハッシュ値を計算しておく\n      ll bb[1000];\n      bb[0]=0;\n      for(int j=1;j<=strs[i].size();j++)\n\tbb[j]=bb[j-1]*P+strs[i][j-1];\n      hashVal[i]=bb[strs[i].size()];\n    }\n    ll divNum=1;\n    for(map<string,int>::iterator it=scnt.begin();\n\tit!=scnt.end();it++){\n      divNum*=fact[it->second];\n    }\n    for(int i=0;i<m;i++){\n      string tmp;cin>>tmp;\n      fullTxt+=tmp;\n    }\n    // 計算済みの結果を登録しておく\n    map<ll,ll> mem;\n    calcRollingHash(fullTxt);\n    ll res=0;\n    for(int i=0;i+sz<=fullTxt.size();i++){\n      ll hv=hh(i,i+sz-1);\n      // 計算済みであれば\n      if(mem.find(hv)!=mem.end())res+=mem[hv];\n      // まだ計算済みでない\n      else{\n\tmemset(dp,-1,sizeof(dp));\n\tll tmp=0;\n\tfor(int j=0;j<n;j++){\n\t  if(hh(i,i+strs[j].size()-1)==hashVal[j])\n\t    tmp+=dfs(i+strs[j].size(),1<<j,j);\n\t}\n\tmem[hv]=tmp;\n\tres+=tmp;\n      }\n    }\n    cout<<res/divNum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nint n,M;\nstring e[20];\nmap<int,map<ull,set<int> > > m;\nvoid dfs(int x,int y,int d,int c,string s){\n  if(d==x||d==y){\n    RollingHash rh(s);\n    //cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n    m[s.size()][rh.find(0,s.size())].insert(c);\n    if(d==y) return;\n  }\n  for(int i=0;i<n;i++){\n    if((c>>i)&1) continue;\n    dfs(x,y,d+1,c+(1LL<<i),s+e[i]);\n  }\n}\nsigned main(){\n  while(cin>>n>>M,n){\n    string t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    m.clear();\n    dfs(x,y,0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(auto &a:m){\n\tint l=a.first;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tauto &p=a.second;\n\tif(!p.count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=p[u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\nbool dp[4096][5001];\n\nvoid solve(int n,int m){\n\tstring e[12],T;\n\tint ans=0,mn=20;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t\tmn=min(mn,(int)e[i].size());\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\n\tbool f[12][5000];\n\tfor(int i=0;i<n;++i){\n\t\tfor(int j=0;j<=T.size()-mn;++j){\n\t\t\tif(T.substr(j,e[i].size())==e[i]) f[i][j]=true;\n\t\t\telse f[i][j]=false;\n\t\t}\n\t}\n\tfill(dp[0],dp[0]+T.size()+1,true);\n\tfor(int s=1;s<(1<<n);++s) fill(dp[s],dp[s]+T.size()+1,false);\n\tfor(int s=0;s<(1<<n)-1;++s){\n\t\tfor(int j=0;j<=T.size()-mn;++j){\n\t\t\tif(dp[s][j]){\n\t\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\t\tif(!((s>>i)&1)&&f[i][j]) dp[s+(1<<i)][j+e[i].size()]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=1;j<=T.size();++j) ans+=dp[(1<<n)-1][j];\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(n,m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=177771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<ull,set<short> > m[400];\n    int count=0;\n    function<void(int,short,string)> dfs=[&](int d,short c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tcount++;\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!m[l].count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<short> &si=m[l][u];\n\tset<short> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  short k=(~j)&((1<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<int> edge[5001];\n\nbool same(string a,string b,int len,int v){\n\tif(a.size()<len || b.size()<len+v)return false;\n\ta=a.substr(0,v);\n\tb=b.substr(len,v);\n\treturn (a==b);\n}\n\nvoid KMP(string text,string pattern,int v){\n\tint textN=text.size();\n\tint patternN=pattern.size();\n\tvector<int> next(patternN+1,0);\n\tnext[0]=1;\n\tfor(int i=1;i<=patternN;i++){\n\t\tstring s=pattern.substr(0,i);\n\t\tint len=1;\n\t\twhile(i-len>0 && !same(s,pattern,len,i-len))len++;\n\t\tnext[i]=len;\n\t}\n\tint cnt=0;\n\tint tp=0,pp=0;\n\twhile(tp<textN){\n\t\tif(text[tp]==pattern[pp]){\n\t\t\ttp++;\n\t\t\tpp++;\n\t\t}else{\n\t\t\tpp-=next[pp];\n\t\t\tif(pp<0){\n\t\t\t\ttp++;\n\t\t\t\tpp++;\n\t\t\t}\n\t\t}\n\t\tif(pp==patternN){\n\t\t\tedge[tp-pattern.size()].push_back(v);\n\t\t}\n\t}\n}\n\nint n,m;\nstring e[13];\nstring text;\nbool dp[5001][1<<12];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> e[i];\n\t\t}\n\t\ttext=\"\";\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext+=str;\n\t\t}\n\t\tint len=text.size();\n\t\tfor(int i=0;i<len;i++){\n\t\t\tedge[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tKMP(text,e[i],i);\n\t\t}\n\t\tmemset(dp,false,sizeof(dp));\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tif(i==0)dp[j][i]=true;\n\t\t\t\tif(!dp[j][i])continue;\n\t\t\t\tif(i==((1<<n)-1)){\n\t\t\t\t\tres+=dp[j][i]?1:0;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<edge[j].size();l++){\n\t\t\t\t\tint k=edge[j][l];\n\t\t\t\t\tif((!((i>>k) & 1))){\n\t\t\t\t\t\tdp[j+e[k].size()][i|(1<<k)]|=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int N, M;\n  while(cin >> N >> M, N) {\n    string S[12], T;\n    int sum = 0;\n    for(int i = 0; i < N; i++) cin >> S[i], sum += S[i].size();\n    for(int i = 0; i < M; i++) {\n      string q;\n      cin >> q;\n      T += q;\n    }\n\n    vector< int > pos(1 << N, 0);\n    for(int i = 0; i < 1 << N; i++) {\n      for(int j = 0; j < N; j++) if((i >> j) & 1) pos[i] += S[j].size();\n    }\n\n    long long ret = 0LL;\n    for(int i = 0; i <= (int) T.size() - sum; i++) {\n      bitset< 1 << 12 > dp;\n      dp[0] = true;\n      for(int j = 0; j < 1 << N; j++) {\n        if(!dp[j]) continue;\n        for(int k = 0; k < N; k++) {\n          if((j >> k) & 1) continue;\n          if(dp[j | (1 << k)]) continue;\n          if([&]()\n          {\n            for(int l = 0; l < S[k].size(); l++) {\n              if(S[k][l] != T[i + l + pos[j]]) return (false);\n            }\n            return (true);\n          }())\n            dp[j | (1 << k)] = true;\n        }\n      }\n      ret += dp[(1 << N) - 1];\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vector<string> e(n);\n        string t;\n        for(int i = 0; i < n; ++i) {\n            cin >> e[i];\n        }\n        for(int i = 0; i < m; ++i) {\n            string tt;\n            cin >> tt;\n            t += tt;\n        }\n\n        int const T = t.size();\n        vector<vector<bool>> match(T, vector<bool>(n));\n        for(int i = 0; i < T; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(e[j].size() + i > T) {\n                    continue;\n                }\n                match[i][j] = t.substr(i, e[j].size()) == e[j];\n            }\n        }\n\n        vector<vector<char>> dp(T + 1, vector<char>(1 << n));\n        for(int i = 0; i < T; ++i) {\n            dp[i][0] = 1;\n        }\n        for(int i = 0; i < T; ++i) {\n            for(int S = 0; S < (1 << n); ++S) {\n                for(int j = 0; j < n; ++j) {\n                    if(S & (1 << j) || !match[i][j]) {\n                        continue;\n                    }\n                    int len = e[j].size();\n                    if(dp[i + len][S | (1 << j)] != 0) {\n                        continue;\n                    }\n                    dp[i + len][S | (1 << j)] += dp[i][S];\n                }\n            }\n        }\n\n        int res = 0;\n        for(int i = 0; i <= T; ++i) {\n            res += dp[i][(1 << n) - 1];\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct RollingHash{\n    static const int MD = 2;\n    static const vector<ll> hash_base, hash_mod;\n\n    int n;\n    vector<ll> hs[MD], pw[MD];\n\n    RollingHash(){}\n    RollingHash(const string &s){\n        n = s.size();\n        rep(i,MD){\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            rep(j,n){\n                pw[i][j+1] = pw[i][j]*hash_base[i] % hash_mod[i];\n                hs[i][j+1] = (hs[i][j]*hash_base[i]+s[j]) % hash_mod[i];\n            }\n        }\n    }\n\n    // 1-index\n    ll hash_value(int l, int r, int i){\n        return ((hs[i][r] - hs[i][l]*pw[i][r-l])%hash_mod[i]+hash_mod[i])%hash_mod[i];\n    }\n\n    bool match(int l1, int r1, int l2, int r2){\n        bool ret = true;\n        rep(i,MD) ret &= (hash_value(l1-1,r1,i) == hash_value(l2-1,r2,i));\n        return ret;\n    }\n\n    vector<ll> calc(int l, int r){\n        vector<ll> ret(MD);\n        rep(i,MD) ret[i]=hash_value(l-1,r,i);\n        return ret;\n    }\n};\nconst vector<ll> RollingHash::hash_base{1009,1021,1013};\nconst vector<ll> RollingHash::hash_mod{1000000009,1000000007,1000000021};\n\nconst int N = 1<<12;\nbool dp[N];\nint len[N];\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n){\n        vector<string> s(n);\n        rep(i,n) cin >>s[i];\n\n        string t=\"\";\n        while(m--){\n            string tmp;\n            cin >>tmp;\n            t += tmp;\n        }\n\n        vector<int> sz(n);\n        int S = 0;\n        rep(i,n){\n            sz[i] = s[i].size();\n            S += sz[i];\n        }\n        int T = t.size();\n        // S <= 240, T <= 5000\n\n        vector<RollingHash> hs(n);\n        rep(i,n) hs[i] = RollingHash(s[i]);\n        RollingHash ht(t);\n\n        rep(mask,1<<n){\n            len[mask] = 0;\n            rep(i,n)if(mask>>i&1) len[mask] += s[i].size();\n        }\n\n        int ans = 0;\n        rep(i,T-S+1){\n            fill(dp,dp+N,false);\n            dp[0] = true;\n            rep(mask,1<<n)if(dp[mask]){\n                rep(j,n)if(!(mask>>j&1)){\n                    int nx = mask | (1<<j);\n                    if(hs[j].calc(1, sz[j]) == ht.calc(1+i+len[mask], 1+i+len[nx]-1)) dp[nx] = true;\n                }\n            }\n\n            if(dp[(1<<n)-1]) ++ans;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\ntemplate<class Z> Z rng(Z a, Z b) {\n  static mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n  return uniform_int_distribution<Z>(a, b - 1)(mt);\n}\n\nstruct RollingHash {\n  static constexpr uint64_t P0 = 4e9 + 7;\n  static constexpr uint64_t P1 = 4e9 + 9;\n  static uint64_t B0;\n  static uint64_t B1;\n  static vector<uint64_t> powB0;\n  static vector<uint64_t> powB1;\n  const int n;\n  vector<uint64_t> h0;\n  vector<uint64_t> h1;\n  template<class Itr> RollingHash(Itr first, Itr last) : n(distance(first, last)), h0(n + 1), h1(n + 1) {\n    for (int i = 0; i < n; ++i, ++first) {\n      h0[i + 1] = (h0[i] * B0 + *first) % P0;\n      h1[i + 1] = (h1[i] * B1 + *first) % P1;\n    }\n    while (powB0.size() <= n) {\n      powB0.push_back(powB0.back() * B0 % P0);\n      powB1.push_back(powB1.back() * B1 % P1);\n    }\n  }\n  uint64_t get0(int l, int r) { return (h0[r] + (P0 - h0[l]) * powB0[r - l]) % P0; }\n  uint64_t get1(int l, int r) { return (h1[r] + (P1 - h1[l]) * powB1[r - l]) % P1; }\n  pair<uint64_t, uint64_t> get(int l, int r) {\n      return {get0(l, r), get1(l, r)};\n  }\n  bool eq(int l0, int r0, int l1, int r1) {\n    return get0(l0, r0) == get0(l1, r1) and get1(l0, r0) == get1(l1, r1);\n  }\n  template<class Itr> static uint64_t get0(Itr first, Itr last) {\n    uint64_t res = 0;\n    while (first != last) {\n      res = (res * B0 + *first++) % P0;\n    }\n    return res;\n  }\n  template<class Itr> static uint64_t get1(Itr first, Itr last) {\n    uint64_t res = 0;\n    while (first != last) {\n      res = (res * B1 + *first++) % P1;\n    }\n    return res;\n  }\n};\nuint64_t RollingHash::B0 = rng<unsigned>(1, RollingHash::P0);\nuint64_t RollingHash::B1 = rng<unsigned>(1, RollingHash::P1);\nvector<uint64_t> RollingHash::powB0{1};\nvector<uint64_t> RollingHash::powB1{1};\n\nstring e[15];\nstring S;\nvector<RollingHash> eRHS;\nbool dp[5005][1<<12];\nll N, M;\n\nint solve() {\n    eRHS.clear();\n    S.clear();\n    for(int i = 0; i < N; i++) {\n        cin >> e[i];\n        RollingHash rhs(e[i].begin(), e[i].end());\n        eRHS.push_back(rhs);\n    }\n    while(M--) {\n        string a;\n        cin >> a;\n        S += a;\n    }\n    RollingHash RHS(S.begin(), S.end());\n    for(int i = 0; i <= S.size(); i++) {\n        for(int j = 0; j < (1 << N); j++) {\n            dp[i][j] = false;\n        }\n        dp[i][0] = true;\n    }\n    for(int i = 0; i < S.size(); i++) {\n        for(int from = 0; from < (1 << N); from++) {\n            if(!dp[i][from]) continue;\n            for(int j = 0; j < N; j++) {\n                if(from & (1 << j)) continue;\n                int sz = e[j].size();\n                if(i + sz > S.size()) continue;\n                if(eRHS[j].get(0, sz) != RHS.get(i, i+sz)) continue;\n                dp[i+sz][from|(1<<j)] = true;\n            }\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i <= S.size(); i++) {\n        if(dp[i][(1<<N)-1]) ans++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\nint main() {\n    while(cin >> N >> M) {\n        if(N == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 1000000007;\null p[6000], thash[6000];\null shash[13];\n\nint n,m;\nint len;\nchar t[6000];\nchar ss[13][22];\nint sslen[13];\n\nint solve(){\n    rep(i,n){\n        ull x = 0;\n        for(int j=0;ss[i][j];j++) x = x*B + ss[i][j];\n        shash[i] = x;\n    }\n    p[0] = 1;\n    thash[0] = 0;\n    rep(i,len) thash[i+1] = thash[i]*B + t[i];\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+sslen[i] > len) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+sslen[i]] - thash[pos] * p[sslen[i]];\n                // if(h1 != h2) continue;\n                dp[pos+sslen[i]][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    p[0] = 1;\n    rep(i,5001) p[i+1] = p[i]*B;\n\n    while(scanf(\"%d%d\",&n,&m), n){\n        len = 0;\n        rep(i,n){\n            scanf(\"%s\",ss[i]);\n            sslen[i] = strlen(ss[i]);\n        }\n        rep(i,m){\n            static char buf[22];\n            scanf(\"%s\",buf);\n            int l;\n            for(l=0; buf[l]; l++) t[l+len] = buf[l];\n            len += l;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nstring c[20];\nstring s;\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tcin >> c[i];\n\t\t\tfor(int j = 0 ; j < c[i].size() ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += c[i].size();\n\t\t}\n\t\ts = \"\";\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring t;cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tint len = s.size();\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<string> elem;\nstring text;\nbool dp[5050][1 << 12];\nbool flg[5050][1 << 12];\n\nbool check(int idx, int n){\n\tfor(int i = 0; i < elem[n].size(); i++){\n\t\tif(idx + i >= text.size()) return false;\n\t\tif(text[idx + i] != elem[n][i]) return false;\n\t}\n\treturn true;\n}\n\nbool dfs(int idx, int bit){\n\tif(bit == 0) return true;\n\tif(idx >= text.size()) return false;\n\tif(flg[idx][bit]) return dp[idx][bit];\n\tflg[idx][bit] = true;\n\tfor(int i = 0; i < N; i++){\n\t\tif((1 << i) & bit){\n\t\t\tif(check(idx, i)){\n\t\t\t\tif(dfs(idx + elem[i].size(), bit & ~(1 << i))){\n\t\t\t\t\treturn dp[idx][bit] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[idx][bit] = false;\n}\n\nint main(){\n\tint m;\n\twhile(cin >> N >> m, N){\n\t\telem.resize(N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> elem[i];\n\t\t}\n\t\ttext = \"\";\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext += str;\n\t\t}\n\t\tfor(int i = 0; i <= text.size(); i++){\n\t\t\tfor(int j = 0; j < (1 << N); j++){\n\t\t\t\tflg[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < text.size(); i++){\n\t\t\tans += dfs(i, (1<<N) - 1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\n\ninline long long to_int64(char x) {\n  return (long long)x;\n}\n   \nstruct RollingHash {\n     \n  const array<int, 1> mods = {{int(1e9+7)}};//, int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 1> Ks = {{1007}};//, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n   \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n   \n  void construct() {\n    hash.resize(ModsSize);\n    rep(i, ModsSize) hash[i].resize(N+1);\n    rep(i, ModsSize) {\n      for(int j=N-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n   \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(N+1);\n   \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, N+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  } \n    \n  RollingHash(string const& s, int n) {\n    S = s;\n    N = n;\n    construct();\n  }\n   \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n \n  bool same(int a_start, int a_end, int b_start, int b_end, RollingHash const& rh) const {\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh.get_hash(i, b_start, b_end)) return false;\n    }\n    return true;\n  }\n   \n};\n\nint sizes[1<<12];\n\nint main() {\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<RollingHash> vs;\n    rep(i, N) {\n      char s[21]; scanf(\"%s\", s);\n      vs.push_back(RollingHash(s, strlen(s)));\n    }\n \n    rep(i, 1<<N) sizes[i] = 0;\n\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      char s[5001];\n      scanf(\"%s\", s);\n      t += s;\n    }\n\n    int TSize = strlen(t.c_str());\n    RollingHash T(t, TSize);\n    \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i].N, vs[i])) {\n            dp[S|(1<<i)] = 1;\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nconst ll mod[] = { 999999937, 1000000007 }, base = 10000103;\n\nstruct RollingHash\n{\n\tint n;\n\tvector<ll> hs[2], pw[2];\n\tRollingHash() {};\n\tRollingHash(const string& s)\n\t{\n\t\tn = s.size();\n\t\tREP(i, 2)\n\t\t{\n\t\t\ths[i].assign(n + 1, 0);\n\t\t\tpw[i].assign(n + 1, 0);\n\t\t\ths[i][0] = 0;\n\t\t\tpw[i][0] = 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tpw[i][j + 1] = pw[i][j] * base%mod[i];\n\t\t\t\ths[i][j + 1] = (hs[i][j] * base + s[j]) % mod[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tll hash(int l, int r, int i)\n\t{\n\t\treturn ((hs[i][r] - hs[i][l] * pw[i][r - l]) % mod[i] + mod[i]) % mod[i];\n\t}\n\n\tbool match(int l1, int r1, int l2, int r2)\n\t{\n\t\treturn (hash(l1, r1, 0) == hash(l2, r2, 0)) && (hash(l1, r1, 1) == hash(l2, r2, 1));\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tvs v(n);\n\t\tstring s;\n\t\tREP(i, n) cin >> v[i];\n\t\tREP(i, m)\n\t\t{\n\t\t\tstring t; cin >> t;\n\t\t\ts += t;\n\t\t}\n\t\tRollingHash hs(s);\n\t\tvector<set<int>> match(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tRollingHash pat(v[i]);\n\t\t\tll pat1 = pat.hash(0, v[i].size(), 0);\n\t\t\tll pat2 = pat.hash(0, v[i].size(), 1);\n\t\t\tREP(j, (int)s.size() - (int)v[i].size() + 1)\n\t\t\t{\n\t\t\t\tll hs1 = hs.hash(j, j + v[i].size(), 0);\n\t\t\t\tll hs2 = hs.hash(j, j + v[i].size(), 1);\n\t\t\t\tif (pat1 == hs1 && pat2 == hs2) match[i].insert(j);\n\t\t\t}\n\t\t}\n\t\tint len = 0;\n\t\tfor (auto i : v) len += i.size();\n\t\tll ans = 0;\n\t\tREP(i, (int)s.size() - len + 1)\n\t\t{\n\t\t\tvector<bool> used(n);\n\t\t\tint cnt = 0;\n\t\t\tint p = i;\n\t\t\twhile (cnt < n)\n\t\t\t{\n\t\t\t\tint tmp = -1;\n\t\t\t\tREP(j, n)\n\t\t\t\t{\n\t\t\t\t\tif (used[j]) continue;\n\t\t\t\t\tif (match[j].count(p))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tmp == -1) tmp = j;\n\t\t\t\t\t\telse if (v[tmp].size() < v[j].size()) tmp = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tmp == -1) break;\n\t\t\t\tcnt++;\n\t\t\t\tused[tmp] = true;\n\t\t\t\tp += v[tmp].size();\n\t\t\t}\n\t\t\tif (cnt == n) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nbool dp[5001][(1 << 12)];\n\nstruct RollingHash {\n\tstatic const ll mo0=1000000007,mo1=1000000009; static ll mul0,mul1;\n\tstatic const ll add0=1000010007,add1=1003333331; static vector<ll> pmo[2];\n\tstring s; int sz; vector<ll> hash_[2];\n\tvoid init(string s) {\n\t\tthis->s=s; sz=(int)s.size();\n\t\thash_[0].resize(sz+1,0),hash_[1].resize(sz+1,0);\n\t\tif(!mul0) mul0=10009+(((ll)&mul0)>>5)%259,mul1=10007+(((ll)&mul1)>>5)%257;\n\t\tif(pmo[0].empty()) pmo[0].pb(1),pmo[1].pb(1);\n\t\trep(i,sz) hash_[0][i+1]=(hash_[0][i]*mul0+add0+s[i])%mo0;\t//hash_[0][i]はインデックス0~i-1までの文字列のハッシュ値\n\t\trep(i,sz) hash_[1][i+1]=(hash_[1][i]*mul1+add1+s[i])%mo1;\n\t}\n\tpair<ll,ll> hash(int l,int r) {\t//文字列sのインデックス[l,r]の部分文字列のハッシュ値\n\t\tif(l>r) return make_pair(0,0);\n\t\twhile((int)pmo[0].size()<r+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((hash_[0][r+1]+(mo0-hash_[0][l]*pmo[0][r+1-l]%mo0))%mo0,\n\t\t\t             (hash_[1][r+1]+(mo1-hash_[1][l]*pmo[1][r+1-l]%mo1))%mo1);\n\t}\n\tpair<ll,ll> hash(string s) { init(s); return hash(0,(int)s.size()-1); }\t//文字列s全体のハッシュ値\n\tstatic pair<ll,ll> concat(pair<ll,ll> L,pair<ll,ll> R,int RL) { //文字列L+Rのハッシュ値,RLはRの文字列の長さ\n\t\twhile((int)pmo[0].size()<RL+2) pmo[0].pb(pmo[0].back()*mul0%mo0), pmo[1].pb(pmo[1].back()*mul1%mo1);\n\t\treturn make_pair((R.first + L.first*pmo[0][RL])%mo0,(R.second + L.second*pmo[1][RL])%mo1);\n\t}\n};\nvector<ll> RollingHash::pmo[2]; ll RollingHash::mul0,RollingHash::mul1;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        vs vec(n);\n        vector<RollingHash> v(n);\n        vector<pll> kp(n);\n        rep(i,n){\n            cin >> vec[i];\n            kp[i] = v[i].hash(vec[i]);\n        }\n        RollingHash rh;\n        string s;\n        rep(i,m){\n            string t;\n            cin >> t;\n            s += t;\n        }\n        rh.init(s);\n        int ans = 0;\n        rep(i,5001){\n            rep(j,(1 << n)){\n                dp[i][j] = false;\n            }\n        }\n        int leng = len(s);\n        rep(i,5001){\n            dp[i][0] = true;\n        }\n        rep(i,leng+1){\n            rep(j,(1 << n)-1){\n                if(dp[i][j]){\n                    rep(k,n){\n                        if(!((j >> k) & 1)){\n                            if(i+len(vec[k]) <= leng && kp[k] == rh.hash(i,i+len(vec[k])-1)){\n                                dp[i+len(vec[k])][j|(1 << k)] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            if(dp[i][(1 << n)-1]){\n                ans++;\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;++i)\n\nstruct SuffixArray {\n\tstruct SAComp {\n\t\tconst int h; const vector<int> &g;\n\t\tSAComp(const int h_, const vector<int>&g_) : h(h_), g(g_) { ; }\n\t\tbool operator() (int a, int b) {\n\t\t\treturn a == b ? false : g[a] != g[b] ? g[a] < g[b] : g[a + h] < g[b + h];\n\t\t}\n\t};\n\n\tstatic const int SIZE = 100000;\n\tint n;\n\tstring str;\n\tvector<int> sa;\n\tvector<int> lcp;\n\n\tSuffixArray() { ; }\n\tSuffixArray(const string t) :str(t) {\n\t\tInit();\n\t}\n\tvoid Init() {\n\t\tn = str.size();\n\t\tbuildSA();\n\t\tbuildLCP();\n\t}\n\n\t// O(mlogn)\n\n\t////バグあるかも\n\t//int find(const string p) {\n\t//\tint m = p.size();\n\t//\tint left = 0;\n\t//\tint right = n-m;\n\t//\twhile (left < right) {\n\t//\t\tint mid = (left + right) / 2;\n\t//\t\tif (str.substr(sa[mid],m)<p.substr(0,m)) { left = mid + 1; }\n\t//\t\telse { right = mid; }\n\t//\t}\n\t//\treturn str.substr(sa[left], m)== p.substr(0, m)? sa[left] : -1;\n\t//}\nprivate:\n\t//O(nlog^2n)\n\tvoid buildSA() {\n\t\tsa = vector<int>(n + 1);\n\t\tvector<int>g(n + 1);\n\t\tvector<int>b(n + 1);\n\t\tREP(i, n + 1) { sa[i] = i; g[i] = str[i]; }\n\t\tb[0] = 0;\n\t\tb[n] = 0;\n\t\tSAComp f(0, g);\n\t\tsort(sa.begin(), sa.end(), SAComp(0, g));\n\t\tfor (int h = 1; b[n] != n; h *= 2) {\n\t\t\tSAComp comp(h, g);\n\t\t\tsort(sa.begin(), sa.end(), comp);\n\t\t\tREP(i, n) b[i + 1] = b[i] + comp(sa[i], sa[i + 1]);\n\t\t\tREP(i, n + 1) g[sa[i]] = b[i];\n\t\t}\n\t}\n\tvoid buildLCP() {\n\t\tlcp = vector<int>(n + 1);\n\t\tint h = 0;\n\t\tvector<int>b(n + 1);\n\t\tREP(i, n + 1) { b[sa[i]] = i; }\n\t\tREP(i, n + 1) {\n\t\t\tif (b[i]) {\n\t\t\t\tfor (int j = sa[b[i] - 1]; j + h < n && i + h < n && str[j + h] == str[i + h]; h++) { ; }\n\t\t\t\tlcp[b[i]] = h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlcp[b[i]] = -1;\n\t\t\t}\n\t\t\tif (h > 0) { h--; }\n\t\t}\n\t}\npublic:\n\t//[l..r)がtestから始まる\n\tpair<int, int>getlr(string test) {\n\t\tpair<int, int>p;\n\t\t{\n\t\t\tint amin = 0;\n\t\t\tint amax = str.size() + 1;\n\t\t\twhile (amin + 1 != amax) {\n\t\t\t\tint amid((amin + amax) / 2);\n\t\t\t\tstring name = str.substr(sa[amid], test.size());\n\t\t\t\tif (name < test) {\n\t\t\t\t\tamin = amid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.first= amax;\n\t\t}\n\t\t{\n\t\t\tint amin = 0;\n\t\t\tint amax = str.size() + 1;\n\t\t\twhile (amin + 1 != amax) {\n\t\t\t\tint amid((amin + amax + 1) / 2);\n\t\t\t\tstring name = str.substr(sa[amid], test.size());\n\t\t\t\tif (name <= test) {\n\t\t\t\t\tamin = amid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tamax = amid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.second = amax; \n\t\t}\n\t\treturn p;\n\t}\n\n};\n\nint N, M;\nbool solve(const int now, const vector<vector<int>>&oks, bitset<12>&used,vector<string>&words,vector<int>&dp) {\n\tif (dp[used.to_ulong()])return false;\n\tdp[used.to_ulong()] = true;\n\tif (used.count() == N)return true;\n\telse {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!used[i] && oks[now][i]) {\n\t\t\t\tused[i] = true;\n\t\t\t\tif (solve(now + words[i].size(), oks, used, words,dp))return true;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() { \n\twhile (true) { cin >> N >> M;\n\t\tif (N == 0 && M == 0)break;\n\t\tvector<string>words;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\twords.push_back(st);\n\t\t}\n\t\tstring str;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstr += st;\n\t\t}\n\t\tSuffixArray sa(str);\n\n\t\tvector<vector<int>>oks(str.size()+1, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring word(words[i]);\n\t\t\tint al, ar;\n\t\t\tauto p(sa.getlr(word));\n\t\t\tal = p.first;\n\t\t\tar = p.second;\n\t\t\tfor (int x = al; x < ar; ++x) {\n\t\t\t\toks[sa.sa[x]][i] = true;\n\t\t\t}\n\n\t\t}\n\n\t\tint len_sum = 0;\n\t\tfor (int i = 0; i < N; ++i)len_sum += words[i].size();\n\t\tint ans = 0;\n\t\tfor (int i = 0; i <= int(str.size())-len_sum; ++i) {\n\t\t\tbitset<12>bs;\n\t\t\tvector<int>dp(1 << 12);\n\t\t\tif (solve(i, oks, bs, words,dp))ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef int_t hash_t;\n    int_t base1;\n    int_t mod1;\n    vector<int_t> hash1;\n    vector<int_t> pow1;\n    RollingHash() : base1(1009), mod1(1000000007) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1.assign(n+1,0);\n        pow1.assign(n+1,1);\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        return t1;\n    }\n};\n\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n\n    vector<RollingHash::hash_t> hs(n);\n    RollingHash rh;\n    rep(i,n){\n        rh.init(ss[i]);\n        hs[i] = rh.get(0,ss[i].size());\n    }\n    rh.init(t);\n\n    memset(dp,false,sizeof(dp));\n    rep(i,5000) dp[i][0] = true;\n    rep(pos,len){\n        rep(i,n){\n            rep(mask,1<<n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    if(pos+ss[i].size() > t.size()) continue;\n                    if(rh.get(pos,pos+ss[i].size()) != hs[i]) continue;\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nlong long int dp[1 << 12][5001];\nint main() {\n\twhile (1) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tvector<string>elems;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\telems.push_back(st);\n\t\t}\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (elems[i] == elems[j])uf.unionSet(i, j);\n\t\t\t}\n\t\t}\n\t\tlong long int waru = 1; \n\t\t{\n\t\t\tset<int>used;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (used.find(uf.root(i))==used.end()) {\n\t\t\t\t\tused.emplace(uf.root(i));\n\t\t\t\t\tint num=uf.size(i);\n\t\t\t\t\twhile (num >= 2)waru *= num--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t\tstring text;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\ttext += st;\n\t\t}\n\t\tvector<vector<int>>oks(n, vector<int>(text.size()));\n\t\tfor (int e = 0; e < elems.size(); ++e) {\n\t\t\tfor (int i = 0; i <= text.size()-elems[e].size(); ++i) {\n\t\t\t\tif (elems[e] == text.substr(i, elems[e].size())) {\n\t\t\t\t\toks[e][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < 5000; ++i) {\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tfor (int j = 0; j < text.size(); ++j) {\n\t\t\tfor (int i = 0; i < 1 << n; ++i) {\n\t\t\t\tbitset<12>uses(i);\n\t\t\t\tfor (int e = 0; e < n; ++e) {\n\t\t\t\t\tif (oks[e][j]&&!uses[e]) {\n\t\t\t\t\t\tconst int next = j + elems[e].size();\n\t\t\t\t\t\tif (next <= text.size()) {\n\t\t\t\t\t\t\tuses[e] = true;\n\t\t\t\t\t\t\tif (uses.count() == n)ans += dp[i][j];\n\t\t\t\t\t\t\tdp[uses.to_ulong()][next] += dp[i][j];\n\t\t\t\t\t\t\tuses[e] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans/waru << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\n#include<deque>\n#include<queue>\n#include<complex>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\n\nint n, m, ln[20];\nbool dp[5002][4100];\nstring e[20];\n\nvector<int> g[5002];\n\nint *buildFail(const string &p){\n  int M = p.length();\n  int *fail = new int[M + 1];\n  int j = fail[0] = -1;\n\n  for(int i = 1; i <= M; i++){\n    while(j >= 0 && p[j] != p[i - 1]){\n      j = fail[j];\n    }\n    fail[i] = ++j;\n  }\n  return fail;\n}\n\nvoid match(int id, const string &t, const string &p, int *fail){\n  int N = t.length(), M = p.length();\n\n  for(int i = 0, k = 0; i < N; i++){\n    while(k >= 0 && p[k] != t[i]){\n      k = fail[k];\n    }\n    if(++k >= M){\n      g[i - M + 1].push_back(id);\n      k = fail[k];\n    }\n  }\n}\n\nvoid makeG(const string &s){\n  for(int i = 0; i < s.length(); i++){\n    g[i].clear();\n  }\n\n  int *fail = buildFail(s);\n  for(int i = 0; i < n; i++){\n    match(i, s, e[i], fail);\n  }\n}\n\nll solve(const string &s){\n  makeG(s);\n\n  ll res = 0;\n  int FIN = (1 << n) - 1;\n  int len = s.length();\n\n  memset(dp, 0, sizeof(dp));\n\n  for(int i = 0; i < len; i++){\n    dp[i][0] = true;\n\n    for(int j = 0; j < (1 << n) - 1; j++){\n      if(!dp[i][j]) continue;\n\n      for(int k = 0; k < g[i].size(); k++){\n        int to = g[i][k];\n\n        if((j & (1 << to)) == 0){\n          int ni = i + e[to].length();\n          int nj = (j | (1 << to));\n          dp[ni][nj] = true;\n        }\n      }\n    }\n  }\n\n  for(int i = 0; i <= len; i++){\n    res += dp[i][FIN];\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < n; i++){\n      cin >> e[i];\n      ln[i] = e[i].length();\n    }\n\n    ll res = 0;\n    string s = \"\";\n\n    for(int i = 0; i < m; i++){\n      string ts;\n      cin >> ts;\n      s += ts;\n    }\n\n    cout << solve(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\nlong long int dp[1 << 12][501];\nint main() {\n\twhile (1) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (!n)break;\n\t\tvector<string>elems;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\telems.push_back(st);\n\t\t}\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (elems[i] == elems[j])uf.unionSet(i, j);\n\t\t\t}\n\t\t}\n\t\tlong long int waru = 1; \n\t\t{\n\t\t\tset<int>used;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (used.find(uf.root(i))==used.end()) {\n\t\t\t\t\tused.emplace(uf.root(i));\n\t\t\t\t\tint num=uf.size(i);\n\t\t\t\t\twhile (num >= 2)waru *= num--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t\tstring text;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\ttext += st;\n\t\t}\n\t\tvector<vector<int>>oks(n, vector<int>(text.size()));\n\t\tfor (int e = 0; e < elems.size(); ++e) {\n\t\t\tfor (int i = 0; i <= text.size()-elems[e].size(); ++i) {\n\t\t\t\tif (elems[e] == text.substr(i, elems[e].size())) {\n\t\t\t\t\toks[e][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (int i = 0; i < 501; ++i) {\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tlong long int ans = 0;\n\t\tint num = -1;\n\t\tfor (int j = 0; j < text.size(); ++j) {\n\t\t\tif (j % 100 == 0) {\n\t\t\t\tnum++;\n\t\t\t\tfor (int j = 0; j < 1 << 12; ++j) {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 1 << 12; ++j) {\n\t\t\t\t\tfor (int i = 0; i < 100; ++i) {\n\t\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t\t\tdp[j][i] = dp[j][i + 100];\n\t\t\t\t\t}\n\t\t\t\t\tfor (int i = 100; i < 501; ++i) {\n\t\t\t\t\t\tdp[0][i] = 1;\n\t\t\t\t\t\tdp[j][i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 1 << n; ++i) {\n\t\t\t\tbitset<12>uses(i);\n\t\t\t\tfor (int e = 0; e < n; ++e) {\n\t\t\t\t\tif (oks[e][j]&&!uses[e]) {\n\t\t\t\t\t\tconst int next = j + elems[e].size();\n\t\t\t\t\t\tif (next <= text.size()) {\n\t\t\t\t\t\t\tuses[e] = true;\n\t\t\t\t\t\t\tif (uses.count() == n)ans += dp[i][j-num*100];\n\t\t\t\t\t\t\tdp[uses.to_ulong()][next - num * 100] += dp[i][j - num * 100];\n\t\t\t\t\t\t\tuses[e] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans/waru << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\n\ninline long long to_int64(char x) {\n  return (long long)x;\n}\n   \nstruct RollingHash {\n     \n  const array<int, 2> mods = {{int(1e9+7), int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 2> Ks = {{1007, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n   \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n   \n  void construct() {\n    hash.resize(ModsSize);\n    rep(i, ModsSize) hash[i].resize(N+1);\n    rep(i, ModsSize) {\n      for(int j=N-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n   \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(N+1);\n   \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, N+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n    \n  RollingHash(string const& s) {\n    S = s;\n    N = s.size();\n    construct();\n  }\n   \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n \n  bool same(int a_start, int a_end, int b_start, int b_end, RollingHash const& rh) const {\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh.get_hash(i, b_start, b_end)) return false;\n    }\n    return true;\n  }\n   \n};\n\nint sizes[1<<12];\n\nint main() {\n\n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<RollingHash> vs;\n    rep(i, N) {\n      string s; cin >> s;\n      vs.push_back(RollingHash(s));\n    }\n \n    rep(i, 1<<N) sizes[i] = 0;\n\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      char s[5001];\n      scanf(\"%s\", s);\n      t += s;\n    }\n\n    int TSize = t.size();\n    RollingHash T(t);\n    \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i].N, vs[i])) {\n            dp[S|(1<<i)] = 1;\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n\n    cout << sum << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int LLNF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint n,m;\n\t\tstring e[12],t;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\trep(i,0,n) cin >> e[i];\n\t\trep(i,0,m){\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tt+=tmp;\n\t\t}\n\t\t\n\t\tmap<string,int> count;\n\t\trep(i,1,t.size()+1) for(int j=0; j+i<=t.size(); ++j) ++count[t.substr(j,i)];\n\t\t\n\t\tint ans=0;\n\t\tset<string> done;\n\t\tvector<int> perm(n);\n\t\trep(i,0,n) perm[i]=i;\n\t\tdo{\n\t\t\tstring str; \n\t\t\trep(i,0,n) str+=e[perm[i]];\n\t\t\tif(done.find(str)!=done.end()) continue;\n\t\t\tdone.insert(str);\n\t\t\tans+=count[str];\n\t\t}while(next_permutation(perm.begin(),perm.end()));\n\t\n\t\tcout << ans << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<string> elem;\nstring text;\nint dp[5050][1 << 12];\n\nbool check(int idx, int n){\n\tfor(int i = 0; i < elem[n].size(); i++){\n\t\tif(idx + i >= text.size()) return false;\n\t\tif(text[idx + i] != elem[n][i]) return false;\n\t}\n\treturn true;\n}\n\nint dfs(int idx, int bit){\n\tif(bit == 0) return 1;\n\tif(idx >= text.size()) return 0;\n\tif(dp[idx][bit] != -1) return dp[idx][bit];\n\tfor(int i = 0; i < N; i++){\n\t\tif((1 << i) & bit){\n\t\t\tif(check(idx, i)){\n\t\t\t\tif(dfs(idx + elem[i].size(), bit & ~(1 << i))){\n\t\t\t\t\treturn dp[idx][bit] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[idx][bit] = 0;\n}\n\nint main(){\n\tint m;\n\twhile(cin >> N >> m, N){\n\t\telem.resize(N);\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> elem[i];\n\t\t}\n\t\ttext = \"\";\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext += str;\n\t\t}\n\t\tfor(int i = 0; i <= text.size(); i++){\n\t\t\tfor(int j = 0; j < (1 << N); j++){\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < text.size(); i++){\n\t\t\tans += dfs(i, (1<<N) - 1);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    int count=0;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tcount++;\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll B = 29LL;\nconstexpr ll M = 1e9+7;\n\nclass rolling_hash {\npublic:\n    rolling_hash(std::string const& s)\n        : n(s.size())\n    {\n        hs.assign(n+1, 0);\n        p.assign(n+1, 1);\n        for(int j=0; j<n; ++j) {\n            hs[j+1] = (hs[j] * B + s[j]) % M;\n            p[j+1] = p[j] * B % M;\n        }\n    }\n\n    ll query(int l, int r) {\n        return ((hs[r] - hs[l]*p[r-l]) % M + M) % M;\n    }\n\nprivate:\n    int n;\n    std::vector<ll> hs;\n    std::vector<ll> p;\n};\n\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vector<string> e(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> e[i];\n        }\n        string s;\n        for(int i = 0; i < m; ++i) {\n            string t;\n            cin >> t;\n            s += t;\n        }\n\n        vector<ll> e_hash(n);\n        for(int i = 0; i < n; ++i) {\n            ll hs = 0;\n            for(int j = 0; j < e[i].size(); ++j) {\n                hs = (hs * B + e[i][j]) % M;\n            }\n            e_hash[i] = hs;\n        }\n        rolling_hash rh(s);\n        int length = s.size();\n\n        vector<vector<char>> dp(length + 1, vector<char>(1 << n));\n        for(int i = 0; i <= length; ++i) {\n            dp[i][0] = true;\n        }\n        for(int i = 0; i < length; ++i) {\n            for(int S = 0; S < (1 << n); ++S) {\n                if(!dp[i][S]) {\n                    continue;\n                }\n                for(int j = 0; j < n; ++j) {\n                    if((S >> j) & 1) {\n                        continue;\n                    }\n                    if(i + e[j].size() > length) {\n                        continue;\n                    }\n                    dp[i + e[j].size()][S | (1 << j)] |= rh.query(i, i + e[j].size()) == e_hash[j];\n                }\n            }\n        }\n        int res = 0;\n        for(int i = 0; i <= length; ++i) {\n            res += dp[i][(1 << n) - 1];\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nchar c[12][21];\nchar s[5001];\nint A[128],B[128];\nbool D[12];\n\n\nint check(){\n\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tscanf(\"%s\",c[i]);\n\t\t\tint L = strlen(c[i]);\n\t\t\tfor(int j = 0 ; j < L ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += L;\n\t\t}\n\t\tint ans = 0;\n\t\tint len = 0;\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tscanf(\"%s\",s+len);\n\t\t\tlen += strlen(s);\n\t\t}\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\n#include<deque>\n#include<queue>\n#include<complex>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\n\nint n, m;\nbool dp[5002][4100];\nstring e[20];\n\nvector<int> g[5002];\n\nint *buildFail(const string &p){\n  int M = p.length();\n  int *fail = new int[M + 1];\n  int j = fail[0] = -1;\n\n  for(int i = 1; i <= M; i++){\n    while(j >= 0 && p[j] != p[i - 1]){\n      j = fail[j];\n    }\n    fail[i] = ++j;\n  }\n  return fail;\n}\n\nvoid match(int id, const string &t, const string &p, int *fail){\n  int N = t.length(), M = p.length();\n\n  for(int i = 0, k = 0; i < N; i++){\n    while(k >= 0 && p[k] != t[i]){\n      k = fail[k];\n    }\n    if(++k >= M){\n      g[i - M + 1].push_back(id);\n      k = fail[k];\n    }\n  }\n}\n\nvoid makeG(const string &s){\n  for(int i = 0; i < s.length(); i++){\n    g[i].clear();\n  }\n\n  int *fail = buildFail(s);\n  for(int i = 0; i < n; i++){\n    match(i, s, e[i], fail);\n  }\n}\n\nll solve(const string &s){\n  makeG(s);\n\n  ll res = 0;\n  int FIN = (1 << n) - 1;\n  int len = s.length();\n\n  memset(dp, 0, sizeof(dp));\n\n  for(int i = 0; i < len; i++){\n    dp[i][0] = true;\n\n    for(int j = 0; j < (1 << n) - 1; j++){\n      if(!dp[i][j]) continue;\n\n      for(int k = 0; k < g[i].size(); k++){\n        int to = g[i][k];\n\n        if((j & (1 << to)) == 0){\n          int ni = i + e[to].length();\n          int nj = (j | (1 << to));\n          dp[ni][nj] = true;\n        }\n      }\n    }\n  }\n\n  for(int i = 0; i <= len; i++){\n    //trueツつェツ陛環づ個値ツ？ -> trueツづ?づ債づ按つュ1ツづーツ堕ォツつオツつアツづ楪づヲツつ、ツづ可つオツつス\n    if(dp[i][FIN]){\n      res++;\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < n; i++){\n      cin >> e[i];\n    }\n\n    string s = \"\";\n\n    for(int i = 0; i < m; i++){\n      string ts;\n      cin >> ts;\n      s += ts;\n    }\n\n    cout << solve(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool table[12][5000];\nint n;\nstring text;\nstring str[12];\n\nbool dfs(int S, int now) {\n  if (S == (1<<n)-1) return 1;\n  if (now >= text.size()) return 0;\n  REP(i, n) {\n    if (S>>i&1) continue;\n    if (table[i][now] && dfs(S|1<<i, now+str[i].size()))\n      return 1;\n  }\n  return 0;\n}\n\nint main() {\n  int m;\n  while(cin>>n>>m,n||m) {\n    int len = 0;\n    REP(i, n) {\n      cin >> str[i];\n      len += str[i].size();\n    }\n    text.clear();\n    REP(i,m) {\n      string tmp;\n      cin >> tmp;\n      text += tmp;\n    }\n    memset(table,0,sizeof(table));\n    REP(i, n) {\n      REP(j, text.size() - str[i].size() + 1) {\n        if (str[i] == text.substr(j, str[i].size()))\n          table[i][j] = 1;\n      }\n    }\n    int ans = 0;\n    map<string, bool> mp;\n    REP(i, text.size()) {\n      if (mp.count(text.substr(i, len))) {\n        if (mp[text.substr(i, len)])\n          ans++;\n      } else {\n        if (dfs(0, i)) {\n          mp[text.substr(i, len)] = 1;\n          ans++;\n        } else\n          mp[text.substr(i, len)] = 0;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1000000007ULL):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<ull,set<int> > m[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//m[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!m[l].count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=m[l][u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_LEN\t(5000)\n#define MAX_N\t(12)\n\n/* global variables */\n\nbool eoks[MAX_LEN][MAX_N];\nbool eused[MAX_LEN + 1][1 << MAX_N];\n\nstring elms[MAX_N];\nint elens[MAX_N];\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n, m;\n    cin >> n >> m;\n    if ((n | m) == 0) break;\n\n    for (int i = 0; i < n; i++) {\n      cin >> elms[i];\n      elens[i] = elms[i].size();\n    }\n\n    string text;\n    string line;\n\n    for (int i = 0; i < m; i++) {\n      cin >> line;\n      text += line;\n    }\n    int tlen = text.size();\n\n    int allbits = (1 << n) - 1;\n  \n    memset(eoks, false, sizeof(eoks));\n    memset(eused, false, sizeof(eused));\n  \n    for (int pos = 0; pos < tlen; pos++)\n      for (int k = 0; k < n; k++)\n\tif (text.substr(pos, elens[k]) == elms[k]) {\n\t  eoks[pos][k] = true;\n\t  eused[pos + elens[k]][1 << k] = true;\n\t}\n    //p eused\n\n    for (int pos = 0; pos < tlen; pos++) {\n      for (int bits = 0; bits <= allbits; bits++) {\n\tif (! eused[pos][bits]) continue;\n\n\tfor (int k = 0; k < n; k++) {\n\t  int bk = 1 << k;\n\t  int posk = pos + elens[k];\n\t  if (eoks[pos][k] && (bits & bk) == 0 && posk <= tlen)\n\t    eused[posk][bits | bk] = true;\n\t}\n      }\n    }\n\n    int count = 0;\n    for (int pos = 0; pos <= tlen; pos++)\n      if (eused[pos][allbits]) count++;\n  \n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 12\n#define S 5005\n#define M 1777771\nusing namespace std;\ntypedef unsigned long long ull;\n\nbool dp[(1<<N)][S];\nint n, m;\nstring s[N],t;\n\null d1[N],d2[S],A[30];\n\nint main(){\n\n  while(1){\n    \n    cin>>n>>m;\n    if(!n&&!m) break;\n    \n    for(int i=0;i<n;i++) cin>>s[i];\n\n    t=\"\";\n    \n    for(int i=0;i<m;i++){\n      string tmp;\n      cin>>tmp;\n      t+=tmp;\n    }\n\n    for(int i=0;i<n;i++){\n      ull hash=s[i][0];\n      for(int j=1;j<s[i].size();j++)\n\thash=hash*M+s[i][j];\n      d1[i]=hash;\n    }\n    \n    d2[0]=t[0];\n    for(int i=1;i<t.size();i++)\n      d2[i]=d2[i-1]*M+t[i];\n\n    memset(dp,0,sizeof(dp));\n\n    for(int i=0;i<t.size();i++) dp[0][i]=true;\n    \n    A[0]=1;\n    for(int i=1;i<30;i++) A[i]=A[i-1]*M;\n\n    for(int i=0;i<(1<<n);i++){\n\n      for(int j=0;j<t.size();j++){\n\n\tif(!dp[i][j]) continue;\n\t\n\tfor(int k=0;k<n;k++){\n\n\t  if(i&(1<<k)) continue;\n\n\t  int slen=s[k].size();\n\t  \n\t  if(t.size()<j+slen) continue;\n\t  \n\t  ull x=d2[j+A[slen]-1];\n\t  if(j) x-=d2[j-1]*A[slen];\n\t  \n\t  if(d1[k]!=x) continue;\n\t  \n\t  dp[i|(1<<k)][j+slen]=true;\n\t  \n\t}\n\t\n      }\n      \n    }\n\n    int ans=0;\n    \n    for(int i=0;i<=t.size();i++)\n      ans+=dp[(1<<n)-1][i];\n\n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    string e[n],t[m];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<m;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<m;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    map<int,map<ull,set<int> > > m;\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\t//cout<<d<<\" \"<<c<<\" \"<<\" \"<<s<<endl;\n\tm[s.size()][rh.find(0,s.size())].insert(c);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1LL<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(auto &a:m){\n\tint l=a.first;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tauto &p=a.second;\n\tif(!p.count(u)) continue;\n\tif(!m[len-l].count(v)) continue;\n\t//cout<<u<<\" \"<<v<<endl;\n\tset<int> &si=p[u];\n\tset<int> &sj=m[len-l][v];\n\tfor(int j:si){\n\t  int k=(~j)&((1LL<<n)-1);\n\t  if(sj.count(k)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tchar name[21];\n\tint length;\n};\n\n\nint POW[21];\nint N,num_line,TEXT_LENGTH;\nchar buf[101],TEXT[5001];\nbool is_match[5001],pattern_match[5001][20];\nInfo info[20];\nmap<int,bool> MAP;\n\n\nvoid recursive(int start_loc,int loc,int state){\n\tif(is_match[start_loc])return; //すくなくとも1つがマッチしたならreturn\n\n\tif(state == POW[N]-1){ //全文字一致\n\t\tis_match[start_loc] = true;\n\t\treturn;\n\t}\n\n\tint next_state,next_loc;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tif(state & (1 << loop)){ //使用済\n\t\t\t//Do nothin\n\t\t}else{ //TEXT[loc]から、info[loop]との一致比較\n\t\t\tif(pattern_match[loc][loop]){\n\t\t\t\tnext_state = state+POW[loop];\n\t\t\t\tauto at = MAP.find(next_state);\n\t\t\t\tif(at != MAP.end())continue;\n\t\t\t\tMAP[next_state] = true;\n\t\t\t\tnext_loc = loc+info[loop].length;\n\t\t\t\trecursive(start_loc,next_loc,next_state);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tint length,sum_length = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].name);\n\t\tfor(length = 0; info[i].name[length] != '\\0'; length++);\n\t\tinfo[i].length = length;\n\t\tsum_length += length;\n\t}\n\n\t//テキストの読み込み\n\tint index = 0;\n\tfor(int loop = 0; loop < num_line; loop++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int k = 0; buf[k] != '\\n' && buf[k] != '\\0'; k++){\n\t\t\tTEXT[index++] = buf[k];\n\t\t}\n\t}\n\tTEXT_LENGTH = index;\n\n\tfor(int i = 0; i < TEXT_LENGTH; i++)is_match[i] = false;\n\n\tbool FLG;\n\t//場所と文字の一致を先に計算しておく\n\tfor(int loc = 0; loc < TEXT_LENGTH; loc++){\n\t\tfor(int i = 0; i < N; i++)pattern_match[loc][i] = false;\n\t}\n\n\tfor(int loc = 0; loc < TEXT_LENGTH; loc++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(loc+info[i].length > TEXT_LENGTH)continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; k < info[i].length; k++){\n\t\t\t\tif(TEXT[loc+k] != info[i].name[k]){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)pattern_match[loc][i] = true;\n\t\t}\n\t}\n\n\n\n\t//一致の先頭となりえる箇所を全探索\n\tfor(int start_loc = 0; start_loc <= TEXT_LENGTH-sum_length; start_loc++){\n\t\tMAP.clear();\n\t\trecursive(start_loc,start_loc,0);\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < TEXT_LENGTH; i++){\n\t\tif(is_match[i])ans++;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 21; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&num_line);\n\t\tif(N == 0 && num_line == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool table[12][5000];\nint n;\nstring text;\nstring str[12];\n\nbool dfs(int S, int now) {\n  if (S == (1<<n)-1) return 1;\n  if (now >= text.size()) return 0;\n  REP(i, n) {\n    if (S>>i&1) continue;\n    if (table[i][now] && dfs(S|1<<i, now+str[i].size()))\n      return 1;\n  }\n  return 0;\n}\n\nint main() {\n  int m;\n  while(cin>>n>>m,n||m) {\n    REP(i, n) {\n      cin >> str[i];\n    }\n    text.clear();\n    REP(i,m) {\n      string tmp;\n      cin >> tmp;\n      text += tmp;\n    }\n    memset(table,0,sizeof(table));\n    REP(i, n) {\n      REP(j, text.size() - str[i].size() + 1) {\n        if (str[i] == text.substr(j, str[i].size()))\n          table[i][j] = 1;\n      }\n    }\n    int ans = 0;\n    REP(i, text.size()) {\n      if (dfs(0, i))\n        ans++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef unsigned int hash_t;\n\nconstexpr int MAX_LEN = 5000;\nconstexpr hash_t base = 1000000007;\nhash_t pows[MAX_LEN + 1];\n\nclass rolling_hash {\nprivate:\n\tvector<hash_t> hashes;\n\npublic:\n\trolling_hash(const string &s):hashes(s.size() + 1) {\n\t\thashes[0] = 0;\n\t\tfor(unsigned i = 0; i < s.size(); ++i) {\n\t\t\thashes[i + 1] = hashes[i] * base + s[i];\n\t\t}\n\t}\n\n\thash_t hash(int l, int r) const {\n\t\treturn hashes[r] - hashes[l] * pows[r - l];\n\t}\n\n\tstatic hash_t hash(const string &s) {\n\t\thash_t res = 0;\n\t\tfor(const auto &c : s) {\n\t\t\tres *= base;\n\t\t\tres += c;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nvoid init() {\n\tpows[0] = 1;\n\tfor(int i = 1; i <= MAX_LEN; ++i) {\n\t\tpows[i] = pows[i - 1] * base;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tinit();\n\n\tfor(int n, m; cin >> n >> m && n;) {\n\t\tvector<string> query(n);\n\t\tvector<hash_t> query_hashes(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> query[i];\n\t\t\tquery_hashes[i] = rolling_hash::hash(query[i]);\n\t\t}\n\n\t\tstring text = \"\";\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\ttext += move(s);\n\t\t}\n\n\t\tconst int len = text.size();\n\t\trolling_hash rh(text);\n\n\t\tvector<vector<bool>> dp(len + 1, vector<bool>(1 << n, false));\n\n\t\tfor(auto &vec : dp) {\n\t\t\tvec[0] = true;\n\t\t}\n\n\t\tfor(int i = 0; i < len; ++i) {\n\t\t\tfor(int j = 0; j < (1 << n) - 1; ++j) {\n\t\t\t\tif(!dp[i][j]) continue;\n\n\t\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\t\tconst int r = i + query[k].size();\n\t\t\t\t\tif((j & (1 << k)) || r > len) continue;\n\t\t\t\t\tif(query_hashes[k] == rh.hash(i, r)) {\n\t\t\t\t\t\tdp[r][j | (1 << k)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(const auto &vec : dp) {\n\t\t\tif(vec[(1 << n) - 1]) ++ans;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint n, m;\nstring e[15];\nstring text;\nbool dp[5005][1<<12];\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tstring s;\n\t\tfor(int i = 0; i < n; i++) cin >> e[i];\n\t\t\n\t\ttext = \"\";\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> s;\n\t\t\t//s.erase(s.end()-1);\n\t\t\ttext += s;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= text.size(); i++){\n\t\t\tfor(int j = 0; j < (1<<n); j++){\n\t\t\t\tdp[i][j] = false;\n\t\t\t}\n\t\t\tdp[i][0] = true;\n\t\t}\n\t\tfor(int i = 0; i <= text.size(); i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(text.size() - i < e[j].size()) continue;\n\t\t\t\tif(text.substr(i, e[j].size()) != e[j]) continue;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < (1<<n); k++){\n\t\t\t\t\tif(k & (1<<j)) continue;\n\t\t\t\t\tif(!dp[i][k]) continue;\n\t\t\t\t\tdp[i+e[j].size()][k | (1<<j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i <= text.size(); i++){\n\t\t\tif(dp[i][(1<<n)-1]) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\nvector<string> elms;\nstring text;\nvector<vector<int>> cors;\nbool memo[5010][1<<12];\n\nbool dfs(int si, int s, int l){\n    if(s == (1<<N)-1) return true;\n    if(memo[si][s]) return false;\n    \n    for(int i=0; i<N; i++) if((s>>i&1) == 0){\n        if(binary_search(cors[i].begin(), cors[i].end(), si))\n            if(dfs(si+(int)elms[i].size(), s|(1<<i), l+(int)elms[i].size()))\n                return true;\n    }\n    memo[si][s] = true;\n    return false;\n}\n\nvoid solve(){\n    cors.clear(); cors.resize(N);\n    memset(memo, 0, sizeof(memo));\n    for(int i=0; i<N; i++){\n        string elm = elms[i];\n        for(int j=0; j<text.size(); j++){\n            if(text.substr(j, elm.size()) == elm)\n                cors[i].push_back(j);\n        }\n    }\n    int ans = 0;\n    for(int i=0; i<text.size(); i++){\n        ans += dfs(i, 0, 0);\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin>>N>>M, N|M){\n        elms.resize(N);\n        for(auto &s: elms) cin >> s;\n        text = \"\";\n        for(int i=0; i<M; i++){\n            string t; cin >> t;\n            text += t;\n        }\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct KMP{\n\tstring pat;\n\tvi fail;\n\tKMP(const string& p):pat(p),fail(p.size()+1){\n\t\tfail[0]=-1;\n\t\tfor(int i=0,j=-1;i<pat.size();){\n\t\t\twhile(j>=0 && pat[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tfail[i]=j;\n\t\t}\n\t}\n\tint Match(const string& text){\n\t\tfor(int i=0,j=0;i<text.size();){\n\t\t\twhile(j>=0 && text[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tif(j==pat.size())\n\t\t\t\treturn i-j;\n\t\t}\n\t\treturn -1;\n\t}\n\tvi MatchAll(const string& text){\n\t\tvi res;\n\t\tfor(int i=0,j=0;i<text.size();){\n\t\t\twhile(j>=0 && text[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tif(j==pat.size()){\n\t\t\t\tres.push_back(i-j);\n\t\t\t\tj=fail[j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<vvb> vvvb;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvs ps(n);\n\t\trep(i,n) cin>>ps[i];\n\t\tstring t;\n\t\trep(i,m){\n\t\t\tstring x; cin>>x;\n\t\t\tt+=x;\n\t\t}\n\t\tvvi ms(n);\n\t\trep(i,n) ms[i]=KMP(ps[i]).MatchAll(t);\n\t\t\n\t\tm=t.size();\n\t\tvvvb dp(1<<n,vvb(n,vb(m+1)));\n\t\trep(i,n) rep(j,ms[i].size()) dp[1<<i][i][ms[i][j]+ps[i].size()]=1;\n\t\trep(i,1<<n) rep(j,n) if(i>>j&1) rep(k,n) if(!(i>>k&1)){\n\t\t\trep(l,ms[k].size()) if(dp[i][j][ms[k][l]])\n\t\t\t\tdp[i|1<<k][k][ms[k][l]+ps[k].size()]=1;\n\t\t}\n\t\t\n\t\tvi res(m+1);\n\t\trep(i,n) rep(j,m+1) res[j]|=dp.back()[i][j];\n\t\tcout<<accumulate(all(res),0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n// ok[i][j] := elm[i] が s[j] で受理されるか\nbool ok[12][5000];\n// dp[i][j] := s[i] までで j(mask) が受理されるか\nbool dp[5000][1 << 12];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    while (cin >> n >> m, n || m)\n    {\n        vector<string> elm(n);\n        for (int i = 0; i < n; i++)\n            cin >> elm[i];\n        string s = \"\";\n        for (int i = 0; i < m; i++)\n        {\n            string a;\n            cin >> a;\n            s += a;\n        }\n        int m = s.size();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                ok[i][j] = false;\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < (1 << n); j++)\n                dp[i][j] = false;\n        for (int i = 0; i < n; i++)\n        {\n            int sz = elm[i].size();\n            for (int j = 0; j <= m - sz; j++)\n            {\n                if (elm[i] == s.substr(j, sz))\n                {\n                    ok[i][j + sz - 1] = true;\n                    dp[j + sz - 1][1 << i] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 1; j < (1 << n); j++)\n            {\n                for (int k = 0; k < n; k++)\n                {\n                    int sz = elm[k].size();\n                    if (i - sz < 0)\n                        continue;\n                    if (((j >> k) & 1) == 0)\n                        continue;\n                    if ((j ^ (1 << k)) == 0)\n                        continue;\n                    if (dp[i - sz][j ^ (1 << k)] && ok[k][i])\n                        dp[i][j] = true;\n                }\n            }\n        }\n        int ret = 0;\n        for (int i = 0; i < m; i++)\n            if (dp[i][(1 << n) - 1])\n                ret++;\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\nbool dp[4096][5001];\n\nvoid solve(int n,int m){\n\tstring e[12],T;\n\tint ans=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\n\tfill(dp[0],dp[0]+T.size()+1,true);\n\tfor(int s=1;s<(1<<n);++s){\n\t\tfill(dp[s],dp[s]+T.size()+1,false);\n\t}\n\tfor(int s=0;s<(1<<n)-1;++s){\n\t\tfor(int j=0;j<T.size();++j){\n\t\t\tif(dp[s][j]){\n\t\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\t\tif(T.substr(j,e[i].size())==e[i]&&!((s>>i)&1)){\n\t\t\t\t\t\tdp[s+(1<<i)][j+e[i].size()]=true;//j+e[i].size()????????§?????????\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=1;j<=T.size();++j){\n\t\tif(dp[(1<<n)-1][j]){\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(n,m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nbool dp[5001][1<<12],mat[5000][12];\n\nint main()\n{\n\tint N,M;\n\twhile(cin >> N >> M, (N||M))\n\t{\n\t\tint cnt=0;\n\t\tstring str[12], text;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(mat, 0, sizeof(mat));\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> str[i];\n\t\t\t\n\t\twhile(M--)\n\t\t{\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\ttext+=t;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<=text.size()-str[i].size(); j++)\n\t\t{\n\t\t\tbool g=true;\n\t\t\tfor(int k=0; k<str[i].size(); k++)\n\t\t\t{\n\t\t\t\tif(text[j+k]!=str[i][k])\n\t\t\t\t{\n\t\t\t\t\tg=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmat[j][i]=g;\n\t\t\tdp[j+str[i].size()][(1<<i)]=g;\n\t\t}\n\n\t\tfor(int i=0; i<text.size(); i++)\n\t\tfor(int j=0; j<(1<<N); j++)\n\t\t{\n\t\t\tif(!dp[i][j]) continue;\n\t\t\tfor(int k=0; k<N; k++)\n\t\t\t{\n\t\t\t\tif(!mat[i][k]) continue;\n\t\t\t\tif(j&(1<<k)) continue;\n\t\t\t\tdp[i+str[k].size()][j+(1<<k)]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<=text.size(); i++)\n\t\t\tif(dp[i][(1<<N)-1]) cnt++;\n\t\t\t\n\t\t\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nvoid chmax(T1 &a, const T2 &b) {\n  if(a < b) a = b;\n}\ntemplate <typename T1, typename T2>\nvoid chmin(T1 &a, const T2 &b) {\n  if(a > b) a = b;\n}\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i != (int)(s.size())-1) cout << \" \";\n  }\n  cout << \"\\n\";\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nconst int _base = 1e9 + 7;\nstruct RollingHash\n{\n  vector< unsigned > hashed, power;\n  RollingHash(const string& s)\n  {\n    int sz = s.size();\n    hashed.assign(sz + 1, 0);\n    power.assign(sz + 1, 0);\n    power[0] = 1;\n    for(int i = 0; i < sz; i++) {\n      power[i + 1] = power[i] * _base;\n    }\n    for(int i = 0; i < sz; i++) {\n      hashed[i + 1] = (hashed[i] + s[i]) * _base;\n    }\n  }\n  unsigned get(int l, int r)\n  {\n    return((hashed[r] - hashed[l] * power[r - l]));\n  }\n  unsigned connect(int h1, int h2, int h2len)\n  {\n    return(h1 * power[h2len] + h2);\n  }\n  int LCP(RollingHash& b, int l1, int r1, int l2, int r2)\n  {\n    int len = min(r1 - l1, r2 - l2);\n    int low = -1, high = len + 1;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(get(l1, l1 + mid) == b.get(l2, l2 + mid)) low = mid;\n      else high = mid;\n    }\n    return(low);\n  }\n};\nbool solve() {\n  int n, m; cin >> n >> m;\n  if(n == 0) return false;\n  vector<string> e(n);\n  string t = \"\";\n  for(int i=0;i<n;++i) {\n    cin >> e[i];\n  }\n  for(int i=0;i<m;++i) {\n    string tmp; cin >> tmp;\n    for(int j=0;j<(int)(tmp.size());++j) {\n      t.push_back(tmp[j]);\n    }\n  }\n  m = (int)(t.size());\n  vector<RollingHash> vrh;\n  for(int i=0;i<n;++i) {\n    vrh.emplace_back(RollingHash(e[i]));\n  }\n  RollingHash rh(t);\n  vector<bitset<(1<<12)>> dp(m+1, bitset<(1<<12)>(0));\n  int cnt = 0;\n  for(int i=0;i<m;++i) {\n    dp[i][0] = 1;\n    for(int j=0;j<n;++j) {\n      if(i + (int)(e[j].size()) <= m) {\n        auto hash1 = rh.get(i, i+(int)(e[j].size()));\n        for(int bit=0;bit<1<<n;++bit) {\n          if(dp[i][bit] && !(bit>>j&1)) {\n            auto hash2 = vrh[j].get(0, (int)(e[j].size()));\n            if(hash1 == hash2) {\n              dp[i+(int)(e[j].size())][bit | (1<<j)] = 1;\n            }\n          }\n        }\n      }\n    }\n    cnt += dp[i][(1<<n)-1];\n  }\n  cnt += dp[m][(1<<n)-1];\n  cout << cnt << \"\\n\";\n  return true;\n}\nint main() {\n  cout << fixed << setprecision(10);\n  while(1) {\n    if(!solve()) break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dp[1<<12][5000];\n\nint main(){\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nchar c[20][30];\nchar s[10050];\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tscanf(\"%s\",c[i]);\n\t\t\tint L = strlen(c[i]);\n\t\t\tfor(int j = 0 ; j < L ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += L;\n\t\t}\n\t\tint ans = 0;\n\t\tint len = 0;\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tscanf(\"%s\",s+len);\n\t\t\tlen += strlen(s);\n\t\t}\n\t\t\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n\nint fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<string> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(s);\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].size();\n      }\n    }\n\n    string T;\n    rep(i, M) {\n      char s[5001]; cin >> s, T += s;\n    }\n\n    int TSize = T.size();\n \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      ll dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(!T.compare(st + sizes[S], sizes[S|(1<<i)] - sizes[S], vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dp[1<<12][5000];\n\nint main(){\n  for(int i=0;i<(1<<12);i++){\n    for(int j=0;j<5000;j++) dp[i][j]=true;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define REP(i, N) for(int i = 0; i < (int)(N); i++)\nbool dp[32][1 << 12];\n\nint main() {\n\tfor(int N, M; cin >> N >> M, (N || M); ) {\n\t\tstring str;\n\t\tstring word[12];\n\t\tREP(i, N) cin >> word[i];\n\t\tREP(i, M) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstr += s;\n\t\t}\n\t\tint len = str.size();\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tREP(j, 32) dp[j][0] = true;\n\t\t\n\t\tint mask = (1 << N) - 1;\n\t\tint sum = 0;\n\t\tREP(pos, len + 1) {\n\t\t\tint j = pos & 31;\n\t\t\tREP(i, N) if( word[i] == str.substr(pos, word[i].size()) ) {\n\t\t\t\tint am = (pos + word[i].size()) & 31;\n\t\t\t\tREP(state, mask) if( (state & (1 << i) ) == 0){\n\t\t\t\t\tdp[am][state | (1 << i)] |= dp[j][state];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dp[j][mask];\n\t\t\tfor(int state = 1; state < 1 << N; state++)\n\t\t\t\tdp[j][state] = 0; \n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N>>M,N&&M){\n\tVS pat(N); REP(i,N) cin >> pat[i];\n\tVI sz(N); REP(i,N) sz[i] = SZ(pat[i]);\n\tstring T;\n\tREP(i,M){\n\t  string tmp; cin >> tmp;\n\t  T += tmp;\n\t}\n\tM = SZ(T);\n\tvector<vector<bool>> match(N, vector<bool>(M+1,false));\n\tREP(i,N) for(int j=0;j+sz[i]<=M;++j)\n\t  match[i][j] = pat[i] == T.substr(j, sz[i]);\n\n\tVI szb(1<<N);\n\tREP(b,1<<N) REP(i,N)\n\t  if(b>>i&1) szb[b] += sz[i];\n\t  \n\tvector<vector<bool>> dp(1<<N, vector<bool>(M+1,false));\n\tREP(i,M+1) dp[0][i] = true;\n\tREP(b,1<<N){\n\t  REP(i,N){\n\t\tif(b>>i&1) continue;\n\t\tint nxtb = b | (1<<i);\n\t\tfor(int pos=0;pos+sz[i]+szb[b]<=M;++pos){\n\t\t  if((dp[b][pos] && match[i][pos+szb[b]])\n\t\t\t || (match[i][pos] && dp[b][pos+sz[i]]))\n\t\t\t dp[nxtb][pos] = true;\n\t\t}\n\t  }\n\t}\n\tcout << count(ALL(dp[(1<<N)-1]), true) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 1000000007;\null p[6000], thash[6000];\null shash[13];\n\nint n,m;\nint len;\nchar t[6000];\nchar ss[13][22];\nint sslen[13];\n\nint solve(){\n    rep(i,n){\n        ull x = 0;\n        for(int j=0;ss[i][j];j++){\n            x = x*B + ss[i][j];\n        }\n        shash[i] = x;\n    }\n    p[0] = 1;\n    thash[0] = 0;\n    rep(i,len){\n        p[i+1] = p[i]*B;\n        thash[i+1] = thash[i]*B + t[i];\n    }\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+sslen[i] > len) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+sslen[i]] - thash[pos] * p[sslen[i]];\n                // if(h1 != h2) continue;\n                dp[pos+sslen[i]][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    while(scanf(\"%d%d\",&n,&m), n){\n        len = 0;\n        rep(i,n){\n            scanf(\"%s\",ss[i]);\n            sslen[i] = strlen(ss[i]);\n        }\n        rep(i,m){\n            static char buf[22];\n            scanf(\"%s\",buf);\n            int l = strlen(buf);\n            rep(i,l) t[i+len] = buf[i];\n            len += l;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\n#include<vector>\n#include<map>\n#include<deque>\n#include<queue>\n#include<complex>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<climits>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a ; i < n ; i++)\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\n\nint n, m;\nbool dp[5002][4100];\nstring e[20];\n\nvector<int> g[5002];\n\n/*\nint *buildFail(const string &p){\n  int M = p.length();\n  int *fail = new int[M + 1];\n  int j = fail[0] = -1;\n\n  for(int i = 1; i <= M; i++){\n    while(j >= 0 && p[j] != p[i - 1]){\n      j = fail[j];\n    }\n    fail[i] = ++j;\n  }\n  return fail;\n}\n\nvoid match(int id, const string &t, const string &p, int *fail){\n  int N = t.length(), M = p.length();\n\n  for(int i = 0, k = 0; i < N; i++){\n    while(k >= 0 && p[k] != t[i]){\n      k = fail[k];\n    }\n    if(++k >= M){\n      g[i - M + 1].push_back(id);\n      k = fail[k];\n    }\n  }\n}\n\nvoid makeG(const string &s){\n  for(int i = 0; i < s.length(); i++){\n    g[i].clear();\n  }\n\n  int *fail = buildFail(s);\n  for(int i = 0; i < n; i++){\n    match(i, s, e[i], fail);\n  }\n}\n*/\n\nvoid makeG(const string &s){\n  int len = s.length();\n\n  for(int i = 0; i < len; i++){\n    g[i].clear();\n  }\n\n  for(int i = 0; i < n; i++){\n    int lene = e[i].length();\n\n    for(int j = 0; j <= len - lene; j++){\n      bool flg = true;\n\n      for(int k = j; k < j + lene; k++){\n        if(e[i][k - j] != s[k]){\n          flg = false;\n          break;\n        }\n      }\n\n      if(flg){\n        g[j].push_back(i);\n      }\n    }\n  }\n}\n\nll solve(const string &s){\n  makeG(s);\n\n  ll res = 0;\n  int FIN = (1 << n) - 1;\n  int len = s.length();\n\n  memset(dp, 0, sizeof(dp));\n\n  for(int i = 0; i < len; i++){\n    dp[i][0] = true;\n\n    for(int j = 0; j < (1 << n) - 1; j++){\n      if(!dp[i][j]) continue;\n\n      for(int k = 0; k < g[i].size(); k++){\n        int to = g[i][k];\n\n        if((j & (1 << to)) == 0){\n          int ni = i + e[to].length();\n          int nj = (j | (1 << to));\n          dp[ni][nj] = true;\n        }\n      }\n    }\n  }\n\n  for(int i = 0; i <= len; i++){\n    //trueツつェツ陛環づ個値ツ？ -> trueツづ?づ債づ按つュ1ツづーツ堕ォツつオツつアツづ楪づヲツつ、ツづ可つオツつス\n    if(dp[i][FIN]){\n      res++;\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n >> m, n || m){\n    for(int i = 0; i < n; i++){\n      cin >> e[i];\n    }\n\n    string s = \"\";\n\n    for(int i = 0; i < m; i++){\n      string ts;\n      cin >> ts;\n      s += ts;\n    }\n\n    cout << solve(s) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m;\nint len;\nbool visit[1 << 12];\nbool can[12][5100];\nstring e[20];\n\nint calc(int depth, int used, int index) {\n  if (visit[used]) { return 0; }\n  visit[used] = true;\n  if (depth == n) { return 1; }\n  REP(i, n) {\n    if (used & (1 << i) || !can[i][index]) { continue; }\n    int nused = used | (1 << i);\n    if (calc(depth + 1, nused, index + e[i].size()) == 1) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while (cin >> n >> m, n|m) {\n    MEMSET(can, false);\n    REP(i, n) { cin >> e[i]; }\n    string s;\n    REP(i, m) {\n      string t;\n      cin >> t;\n      s += t;\n    }\n    len = s.size();\n    REP(i, n) {\n      int index = 0;\n      while (index < len) {\n        index = s.find(e[i], index);\n        if (index == (int)string::npos) { break; }\n        can[i][index] = true;\n        index++;\n      }\n    }\n    int ans = 0;\n    REP(i, len) {\n      MEMSET(visit, false);\n      ans += calc(0, 0, i);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\n\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint n,m;\n\nll gha[6000];\nbool vis[1<<12][100];\nll po[1000];\nvoid solve(){\n  ll ha[n];\n  int len[n];\n  rep(i,n) {\n    string a;\n    cin >> a;\n    ll h =0 ;\n    len[i] = SZ(a);\n    FOR(it,a)\n      h=h*31+*it;\n    ha[i] =h;\n  }\n  po[0] = 1;\n  rep(i,999) po[i+1] = po[i]*31;\n  int ans = 0;\n  string text;\n  rep(jjj,m) {\n    string a;\n    cin >> a;\n    text += a;\n  }\n\n  rep(i,SZ(text)) gha[i+1] = gha[i]*31+text[i];\n\n  bool vis[250][1<<n];\n  rep(i,250)rep(j,1<<n) vis[i][j]=0;\n  rep(i,250) vis[i][0]=1;\n\n  rep(j,SZ(text)+1){\n    int cur = j%250;\n    rep(i,1<<n){\n      if(!vis[cur][i]) continue;\n      rep(k,n)\n        if((~i&(1<<k)) && len[k]+j<=SZ(text) &&\n           ha[k] == gha[j+len[k]] - gha[j]*po[len[k]])\n          vis[(j+len[k])%250][i|(1<<k)]=1;\n    }\n    ans += vis[cur][(1<<n)-1];\n    rep(i,1<<n) vis[cur][i] = 0;\n    vis[cur][0]=1;\n  }\n  cout << ans << endl;\n  return ;\n  \n  rep(jjj,m){\n    string a;\n    cin >> a;\n    rep(i,SZ(a)) gha[i+1] = gha[i]*31+a[i];\n    \n    rep(i,1<<n)rep(j,SZ(a)+1) vis[i][j]=0;\n    queue<PI> q;\n    rep(i,n) rep(j,SZ(a)-len[i]+1){\n      ll t = gha[j+len[i]]-gha[j]*po[len[i]];\n      if(t == ha[i]) q.push(mp(1<<i,j+len[i]));\n    }\n    \n    while(!q.empty()){\n      int cst  = q.front().F;\n      int cp = q.front().S;\n      q.pop();\n      if(vis[cst][cp]) continue;\n      //cout << cst << \" \" << cp << endl;\n      vis[cst][cp] = 1;\n      ans += cst == (1<<n)-1;\n      rep(i,n){\n        //cout << ha[i] << \" \" << gha[cp+len[i]]-gha[cp]*po[len[i]] << endl;\n        if(((~cst)&(1<<i)) &&\n           ha[i] == gha[cp+len[i]]-gha[cp]*po[len[i]])\n          q.push(mp(cst|(1<<i),cp+len[i]));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  while(cin >> n >> m ,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n];\n    for(int i=0;i<n;i++) cin>>e[i];\n    string b,t;\n    for(int i=0;i<M;i++){\n      cin>>t;\n      b+=t;\n    }\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size())>>4);\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u>>4)||!sa.count(v>>4)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nll const B = 3;\null p[6000], thash[6000];\null shash[13];\n\nint n,m;\nint len;\nchar t[6000];\nchar ss[13][22];\nint sslen[13];\n\nint solve(){\n    rep(i,n){\n        ull x = 0;\n        for(int j=0;ss[i][j];j++){\n            x = x*B + ss[i][j];\n        }\n        shash[i] = x;\n    }\n    p[0] = 1;\n    thash[0] = 0;\n    rep(i,len){\n        p[i+1] = p[i]*B;\n        thash[i+1] = thash[i]*B + t[i];\n    }\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+sslen[i] > len) continue;\n                ull h1 = shash[i];\n                ull h2 = thash[pos+sslen[i]] - thash[pos] * p[sslen[i]];\n                // if(h1 != h2) continue;\n                dp[pos+sslen[i]][mask|1<<i] |= h1 == h2; // t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    while(scanf(\"%d%d\",&n,&m), n){\n        len = 0;\n        rep(i,n){\n            scanf(\"%s\",ss[i]);\n            sslen[i] = strlen(ss[i]);\n        }\n        rep(i,m){\n            static char buf[22];\n            scanf(\"%s\",buf);\n            int l = strlen(buf);\n            rep(i,l) t[i+len] = buf[i];\n            len += l;\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \ninline long long to_int64(char x) {\n  return (long long)x;\n}\n  \nstruct RollingHash {\n    \n  const array<int, 2> mods = {{int(1e9+7), int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 2> Ks = {{1007, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n  \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n  \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n  \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n  \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n   \n  RollingHash(string const& s) {\n    S = s;\n    N = s.size();\n    construct();\n  }\n  \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end) const { // not verified\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash> const& rh) const {\n    if(rh == nullptr) { return same(a_start, a_end, b_start, b_end); }\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh->get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool compare(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash> rh = nullptr) const {  // not verified\n    int a_len = a_end - a_start;\n    int b_len = b_end - b_start;\n  \n    int len = min(a_len, b_len);\n    int max_len = len + 1;\n    int min_len = 0;\n  \n    while(min_len + 1 < max_len) {\n      int next_len = (min_len + max_len) / 2;\n      if(same(a_start, a_start + next_len, b_start, b_start + next_len, rh)) {\n        min_len = next_len;\n      }\n      else {\n        max_len = next_len;\n      }\n    }\n  \n    if(a_start + min_len == a_end) {\n      if(b_start + min_len == b_end) { return 0; }\n      else { return -1; }\n    }\n    else {\n      if(b_start + min_len == b_end) { return 1; }\n      else { return S[a_start + min_len] == S[b_start + min_len]; }\n    }\n  \n  }\n  \n};\n \nint fact[13];\nint DP[5010][1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<shared_ptr<RollingHash>> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(make_shared<RollingHash>(RollingHash(s)));\n    }\n\n    vector<int> sizes(1 << N);\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i]->N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      string s; cin >> s, t += s;\n    }\n\n    RollingHash T(t);\n    int TSize = t.size();\n \n    ll sum = 0;\n    rep(i, TSize + 10) rep(j, 1<<N) DP[i][j] = 0;\n    \n    rep(st, TSize) {\n      int* dp = DP[st];\n      rep(i, N)\n        if(T.same(st, st + vs[i]->N, 0, vs[i]->N, vs[i]))\n          dp[1<<i] = 1;\n\n      rep(S, 1<<N) {\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i]->N, vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint bit[1<<10] = {};\nbool pos[12][5010] = {};\nbool dp[5010][1<<12];\nbool dn[5010][1<<12];\nstring p[12];\nstring s;\n\nint n,m;\nbool dfs(int x,int bit){\n\tif( bit == 0 ) return 1;\n\tif( x == s.size() ) return 0;\n\tif( dn[x][bit] ) return dp[x][bit];\n\tbool ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit >> i & 1) && pos[i][x] ){\n\t\t\tans |= dfs(x+p[i].size(),bit^(1<<i));\n\t\t\tbreak;\n\t\t}\n\t}\n\tdn[x][bit] = true;\n\treturn dp[x][bit] = ans;\n}\n\nint main(){\n\twhile( cin >> n >> m && n ){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(dn,0,sizeof(dn));\n\t\tmemset(pos,0,sizeof(pos));\n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) cin >> p[i];\n\t\ts = \"\";\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring c; cin >> c;\n\t\t\ts += c;\n\t\t}\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tfor(int i = 0 ; i + p[j].size() <= s.size() ; i++){\n\t\t\t\tint f = 1;\n\t\t\t\tfor(int k = 0 ; k < p[j].size() ; k++)\n\t\t\t\t\tif( p[j][k] != s[i+k] ){ f = 0; break; }\n\t\t\t\tif(f) pos[j][i] = 1;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( dfs(i,(1<<n)-1) ){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <map>\n\nusing namespace std;\n\n#define N 10010\ntypedef long long ll;\n//const int INF=1000000000;\nll p[N],q[N];\n// // rolling hashを計算\n// void calcRollingHash(string &s){\n//   int n=s.size();\n//   aa[0]=0;\n//   // hash値を計算\n//   for(int i=1;i<=n;i++)aa[i]=aa[i-1]*P+s[i-1];\n// }\n// // 文字列の先頭位置を終端位置を指定し、ハッシュ値を取り出す\n// inline ll hh(int x,int y){\n//   return aa[y+1]-aa[x]*p[y-x+1];\n// }\n\nclass RollingHash2{\nprivate:\n  ll aa[N];\n  ll bb[N];\n  ll P,Q;\npublic:\n  RollingHash2(){}\n  RollingHash2(string &s,ll _P,ll _Q){\n    int n=s.size();\n    aa[0]=bb[0]=0;\n    P=_P;\n    Q=_Q;\n    // hash値を計算\n    for(int i=1;i<=n;i++)aa[i]=aa[i-1]*P+s[i-1];\n    for(int i=1;i<=n;i++)bb[i]=bb[i-1]*Q+s[i-1];\n  }\n  pair<ll,ll> getHash(int x,int y){\n    return make_pair(aa[y+1]-aa[x]*p[y-x+1],\n\t\t     bb[y+1]-bb[x]*q[y-x+1]);\n  }\n};\nRollingHash2 fHash;\n\n// 格文字列のハッシュ値\npair<ll,ll> hashVal[12];\nll dp[1<<12][12];\nstring strs[12];\nstring fullTxt;\n\nint n,m;\nll dfs(int pos,int mask,int cur){\n  if(dp[mask][cur]>=0)return dp[mask][cur];\n  else if(mask==(1<<n)-1)return 1;\n  ll res=0;\n  for(int i=0;i<n;i++){\n    if((mask>>i)&1)continue;\n    // ハッシュ値が一致する場合\n    if(fHash.getHash(pos,pos+strs[i].size()-1)\n       ==hashVal[i]){\n      res+=dfs(pos+strs[i].size(),mask|(1<<i),i);\n    }\n  }\n  return dp[mask][cur]=res;\n}\n\nll fact[20];\nint main(){\n  const ll P=1000000007;\n  const ll Q=10000000017LL;\n  fact[0]=1;\n  for(int i=1;i<20;i++)fact[i]=fact[i-1]*i;\n  // P**iを計算\n  p[0]=1;\n  for(int i=1;i<=10000;i++)p[i]=p[i-1]*P;\n  q[0]=1;\n  for(int i=1;i<=10000;i++)q[i]=q[i-1]*Q;\n  while(cin>>n>>m&&(n|m)){\n    fullTxt=\"\";\n    int sz=0;\n    map<string,int> scnt;\n    for(int i=0;i<n;i++){\n      cin>>strs[i];\n      scnt[strs[i]]++;\n      sz+=strs[i].size();\n      // ハッシュ値を計算しておく\n      RollingHash2 rh(strs[i],P,Q);\n      hashVal[i]=rh.getHash(0,strs[i].size()-1);\n      // ll bb[1000];\n      // bb[0]=0;\n      // for(int j=1;j<=strs[i].size();j++)\n      // \tbb[j]=bb[j-1]*P+strs[i][j-1];\n      // hashVal[i]=bb[strs[i].size()];\n    }\n    ll divNum=1;\n    for(map<string,int>::iterator it=scnt.begin();\n\tit!=scnt.end();it++){\n      divNum*=fact[it->second];\n    }\n    for(int i=0;i<m;i++){\n      string tmp;cin>>tmp;\n      fullTxt+=tmp;\n    }\n    // 計算済みの結果を登録しておく\n    map<pair<ll,ll>,ll> mem;\n    //calcRollingHash(fullTxt);\n    fHash=RollingHash2(fullTxt,P,Q);\n    ll res=0;\n    for(int i=0;i+sz<=fullTxt.size();i++){\n      pair<ll,ll> hv=fHash.getHash(i,i+sz-1);\n      // 計算済みであれば\n      if(mem.find(hv)!=mem.end())res+=mem[hv];\n      // まだ計算済みでない\n      else{\n\tmemset(dp,-1,sizeof(dp));\n\tll tmp=0;\n\tfor(int j=0;j<n;j++){\n\t  if(fHash.getHash(i,i+strs[j].size()-1)\n\t     ==hashVal[j])\n\t    tmp+=dfs(i+strs[j].size(),1<<j,j);\n\t}\n\tmem[hv]=tmp;\n\tres+=tmp;\n      }\n    }\n    cout<<res/divNum<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 5010\n#define MAX_N 12\ntypedef unsigned long long ull;\nconst ull B = 1000000007ULL;\n\nvector<ull> rolling_hash(string &s)\n{\n    int N = s.size();\n    vector<ull> hash(N+1);\n    hash[0] = 0;\n    \n    for (int i = 0; i < N; i++) {\n        hash[i+1] = hash[i] * B + s[i];        \n    }\n    return hash;\n}\n\nint main()\n{\n    ull p[MAX];\n    p[0] = 1;\n    for (int i = 0; i < MAX-1; i++) {\n        p[i+1] = p[i] * B;\n    }\n\n    int N, M;\n    while (cin >> N >> M, N) {\n        int total = 0, len_e[12];\n        string e;\n        vector<vector<ull>> hash_e(N);\n        for (int i = 0; i < N; i++) {\n            cin >> e;\n            hash_e[i] = rolling_hash(e);\n            total += len_e[i] = e.size();\n        }\n        string str, t;\n        for (int i = 0; i < M; i++) {\n            cin >> t;\n            str += t;\n        }\n\n        int n = str.size(), sum = 0;\n        vector<ull> hash_t = rolling_hash(str);\n        for (int i = 0; i <= n - total; i++) {\n            bool dp[1<<MAX_N] = {};\n            dp[0] = 1;\n            for (int j = 0; j < (1<<N)-1; j++) {\n                if (dp[j] == 0) continue;\n                int pos = i;\n                for (int k = 0; k < N; k++) {\n                    if (j >> k & 1) {\n                        pos += len_e[k];\n                    }                    \n                }\n                for (int k = 0; k < N; k++) {\n                    if (j >> k & 1) continue;\n                    int L = pos, R = pos + len_e[k] - 1;\n                    ull h = hash_t[R+1] - hash_t[L] * p[R - L + 1];\n                    if (h == hash_e[k][len_e[k]]) {\n                        dp[j|(1<<k)] = 1;\n                    }\n                }\n            }\n            sum += dp[(1<<N)-1];\n        }        \n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nchar c[20][30];\nchar s[5050];\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tscanf(\"%s\",c[i]);\n\t\t\tint L = strlen(c[i]);\n\t\t\tfor(int j = 0 ; j < L ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += L;\n\t\t}\n\t\tint ans = 0;\n\t\tint len = 0;\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tscanf(\"%s\",s+len);\n\t\t\tif( s[len-1] == '\\r' ) while(1){}\n\t\t\tlen += strlen(s);\n\t\t}\n\t\t\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nbool pos[12][5010] = {};\nbool dp[5010][1<<12];\nbool dn[5010][1<<12];\nstring p[12];\nstring s;\n\nint n,m;\nbool dfs(int x,int bit){\n\tif( bit == 0 ) return 1;\n\tif( dn[x][bit] ) return dp[x][bit];\n\tbool ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( (bit >> i & 1) && pos[i][x] ){\n\t\t\tans |= dfs(x+p[i].size(),bit^(1<<i));\n\t\t\tif(ans)break;\n\t\t}\n\t}\n\tdn[x][bit] = true;\n\treturn dp[x][bit] = ans;\n}\n\nint main(){\n\twhile( cin >> n >> m && n ){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(dn,0,sizeof(dn));\n\t\tmemset(pos,0,sizeof(pos));\n\t\t\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++) cin >> p[i];\n\t\ts = \"\";\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tstring c; cin >> c;\n\t\t\ts += c;\n\t\t}\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tfor(int i = 0 ; i + p[j].size() <= s.size() ; i++){\n\t\t\t\tint f = 1;\n\t\t\t\tfor(int k = 0 ; k < p[j].size() ; k++)\n\t\t\t\t\tif( p[j][k] != s[i+k] ){ f = 0; break; }\n\t\t\t\tif(f) pos[j][i] = 1;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < s.size() ; i++){\n\t\t\tif( dfs(i,(1<<n)-1) ){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n \nusing namespace std;\n \nstring e[16];\nbool dp[5010][1<<12];\n \nint main() {\n  int n, m;\n  while (cin >> n >> m, n) {\n    REP(i,n) cin >> e[i];\n    string str, in;\n    REP(i,m) { cin >> in; str += in; }\n    memset(dp, false, sizeof(dp));\n    REP(i,5010) dp[i][0] = true;\n    int res = 0;\n    REP(i,str.size()) {\n      REP(k,n) {\n        int len = e[k].size();\n        if (str.substr(i, len) != e[k]) continue;\n        REP(j,1<<n) if (dp[i][j] && (~(j >> k) & 1))\n          dp[i+len][j|(1<<k)] = true;\n      }\n      res += dp[i+1][(1<<n)-1];\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[5000][1<<13];\n\nint solve(vector<string> ss, string t){\n    int n = ss.size();\n    int len = t.size();\n    memset(dp,false,sizeof(dp));\n    rep(i,5000) dp[i][0] = true;\n    rep(pos,len){\n        rep(i,n){\n            rep(mask,1<<n){\n                if(~mask>>i&1 && dp[pos][mask]){\n                    if(t.substr(pos,ss[i].size()) == ss[i]){\n                        dp[pos+ss[i].size()][mask|1<<i] = true;\n                    }\n                }\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            //dump(i);\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 5010\n#define MAX_N 12\ntypedef unsigned long long ull;\nconst ull B = 1000000007ULL;\n \nvector<ull> rolling_hash(string &s)\n{\n    int N = s.size();\n    vector<ull> hash(N+1);\n    hash[0] = 0;\n     \n    for (int i = 0; i < N; i++) {\n        hash[i+1] = hash[i] * B + s[i];        \n    }\n    return hash;\n}\n \nint main()\n{\n    ull p[MAX];\n    p[0] = 1;\n    for (int i = 0; i < MAX-1; i++) {\n        p[i+1] = p[i] * B;\n    }\n \n    int N, M;\n    while (cin >> N >> M, N) {\n        int total = 0, len_e[12];\n        string e;\n        vector<vector<ull>> hash_e(N);\n        for (int i = 0; i < N; i++) {\n            cin >> e;\n            hash_e[i] = rolling_hash(e);\n            total += len_e[i] = e.size();\n        }\n        string str, t;\n        for (int i = 0; i < M; i++) {\n            cin >> t;\n            str += t;\n        }\n \n        int n = str.size(), sum = 0;\n        vector<ull> hash_t = rolling_hash(str);\n        for (int i = 0; i <= n - total; i++) {\n            bool dp[1<<MAX_N] = {};\n            dp[0] = 1;\n            for (int j = 0; j < (1<<N)-1; j++) {\n                if (dp[j] == 0) continue;\n                int pos = i;\n                for (int k = 0; k < N; k++) {\n                    if (j >> k & 1) {\n                        pos += len_e[k];\n                    }                    \n                }\n                for (int k = 0; k < N; k++) {\n                    if (j >> k & 1) continue;\n                    int L = pos, R = pos + len_e[k] - 1;\n                    ull h = hash_t[R+1] - hash_t[L] * p[R - L + 1];\n                    if (h == hash_e[k][len_e[k]]) {\n                        dp[j|(1<<k)] = 1;\n                    }\n                }\n            }\n            sum += dp[(1<<N)-1];\n        }        \n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\nll dp[32][1 << 12];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){ break; }\n\t\tvector<string> patterns(n);\n\t\tfor(int i = 0; i < n; ++i){ cin >> patterns[i]; }\n\t\tstring text;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\ttext += line;\n\t\t}\n\t\tconst int length = text.size();\n\t\tvector<int> match(length);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tconst int p = patterns[i].size();\n\t\t\tfor(int j = 0; j + p <= length; ++j){\n\t\t\t\tint flag = 1;\n\t\t\t\tfor(int k = 0; flag && k < p; ++k){\n\t\t\t\t\tif(text[j + k] != patterns[i][k]){ flag = 0; }\n\t\t\t\t}\n\t\t\t\tmatch[j] |= (flag << i);\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tll answer = 0;\n\t\tfor(int i = 0; i < length; ++i){\n\t\t\tconst int cur = i & 31, next = (i - 1) & 31;\n\t\t\tfor(int j = 0; j < (1 << n); ++j){ dp[next][j] = 0; }\n\t\t\tdp[cur][0] = 1;\n\t\t\tfor(int j = 0; j + 1 < (1 << n); ++j){\n\t\t\t\tint mask = match[i] & ~j;\n\t\t\t\twhile(mask != 0){\n\t\t\t\t\tconst int shift = __builtin_ctz(mask);\n\t\t\t\t\tmask &= mask - 1;\n\t\t\t\t\tconst int a = (i + patterns[shift].size()) & 31;\n\t\t\t\t\tconst int b = j | (1 << shift);\n\t\t\t\t\tdp[a][b] += dp[cur][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dp[(cur + 1) & 31][(1 << n) - 1]){ ++answer; }\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve(int n,int m){\n    vector<string> pat(n);\n    for(int i=0;i<n;i++) cin>>pat[i];\n    string tar;\n    for(int i=0;i<m;i++){\n        string buf;\n        cin>>buf;\n        tar+=buf;\n    }\n    m=tar.size();\n    vector<vector<int>> isJumpable(m,vector<int>(n,0));\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            if(i+pat[j].size()>m) continue;\n            isJumpable[i][j]=(pat[j]==tar.substr(i,pat[j].size()));\n        }\n    }\n    int len=accumulate(pat.begin(),pat.end(),0,[](int lhs,string rhs){return lhs+rhs.size();});\n    int res=0;\n    for(int i=0;i+len<=m;i++){\n        vector<vector<int>> dp(len+1);\n        dp[0].push_back(0);\n        vector<int> used(1<<n);\n        for(int j=0;j<len;j++){\n            for(auto st:dp[j]){\n                if(used[st]) continue;\n                used[st]=true;\n                for(int k=0;k<n;k++){\n                    if((st>>k)&1) continue;\n                    if(isJumpable[i+j][k]){\n                        dp[j+pat[k].size()].push_back(st|(1<<k));\n                    }\n                }                \n            }\n            dp[j].clear();\n        }\n        if(!dp[len].empty()) res++;\n    }\n    return res;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        cout<<solve(n,m)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint n,m;\nstring s;\nstring v[13];\nbool dp[5010][1<<12];\nbool is[5010][12];\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&n,&m) && n!=0) {\n\t\tfor (int i=0; i<n; i++) cin>>v[i];\n\t\ts = \"\";\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\ts += str;\n\t\t}\n\t\tfor (int i=0; i<=s.length(); i++) {\n\t\t\tfor (int k=0; k<(1<<n); k++) dp[i][k] = 0;\n\t\t}\n\t\tfor (int i=0; i<s.length(); i++) {\n\t\t\tfor (int k=0; k<n; k++) is[i][k] = 0;\n\t\t\tfor (int k=0; k<n; k++) if (i+v[k].length()<=s.length()) {\n\t\t\t\tif (s.substr(i,v[k].length())==v[k]) {\n\t\t\t\t\tis[i][k] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i=0; i<s.length(); i++) dp[i][0] = 1;\n\t\tfor (int i=0; i<s.length(); i++) {\n\t\t\tfor (int k=0; k<(1<<n); k++) if (dp[i][k]) {\n\t\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\t\tif (i+v[j].length()<=s.length() && is[i][j] && (k&(1<<j))==0) {\n\t\t\t\t\t\tdp[i+v[j].length()][k+(1<<j)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[i][(1<<n)-1]) ans++;\n\t\t}\n\t\tif (dp[s.length()][(1<<n)-1]) ans++;\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n, m, k;\nvs v;\nint dp[5555][1 << 12];\nstring a;\n\nint solve(int p, int used)\n{\n\tif (p == k) return 1;\n\tif (dp[p][used] >= 0) return dp[p][used];\n\tint res = 0;\n\tREP(i, n)\n\t{\n\t\tif ((used >> i) & 1) continue;\n\t\tif (a.substr(p, v[i].size()) == v[i])\n\t\t{\n\t\t\tchmax(res, solve(p + v[i].size(), used | (1 << i)));\n\t\t}\n\t}\n\treturn dp[p][used] = res;\n}\n\nint check(string s)\n{\n\tMS(dp, -1);\n\ta = s;\n\treturn solve(0, 0);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tstring s;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tv.clear();\n\t\ta.clear();\n\t\ts.clear();\n\t\tv.resize(n); cin >> v;\n\t\tk = 0;\n\t\tfor (auto &i : v) k += i.size();\n\t\tREP(i, m)\n\t\t{\n\t\t\tstring a; cin >> a;\n\t\t\ts += a;\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, s.size() - k + 1)\n\t\t{\n\t\t\tstring t = s.substr(i, k);\n\t\t\tif (check(t))\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\t//cout <<i  << \" \" <<  t << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>//\"geometry.cpp\"\n#include<iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>//\"greater<T>\" Ex. sort(a,a+n,greater<int>());\n#include<cmath>//\"abs\", \"sqrt\"\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n\nvoid solve(int n,int m){\n\tstring e[12],T;\n\tint ans=0;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>e[i];\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tstring t;\n\t\tcin>>t;\n\t\tT+=t;\n\t}\t\n\tfor(int j=0;j<T.size();++j){\n\t\tint x=j;\n\t\tbool f[12],g;\n\t\tfill(f,f+n,false);\n\t\tfor(int k=0;k<n;++k){\n\t\t\tg=false;\n\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\tif(f[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(T.substr(x,e[i].size())!=e[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tx+=e[i].size();\n\t\t\t\tif(x>T.size()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf[i]=true;\n\t\t\t\tg=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!g){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(g){\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tsolve(n,m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nvoid KMP_build(const char *pttn,int *fail){\n\tint n=strlen(pttn);\n\tfail[0]=-1;\n\tfor(int i=1,j=-1;i<=n;i++){\n\t\twhile(j>=0 && pttn[j]!=pttn[i-1]) j=fail[j];\n\t\tfail[i]=++j;\n\t}\n}\n\nvoid KMP_search(const char *s,const char *pttn,const int *fail,bool *res){\n\tint m=strlen(s),n=strlen(pttn),j=0;\n\trep(i,m){\n\t\twhile(j>=0 && s[i]!=pttn[j]) j=fail[j];\n\t\tj++;\n\t\tif(j==n){\n\t\t\tres[i-n+1]=true;\n\t\t\tj=fail[j];\n\t\t}\n\t}\n}\n\nint L; // s の長さ\n\nint n,len[12];\nbool check[12][5000]; // check[i][j] := ( s[j..j+len[i]) == key[i] )\n\nbool dfs(int x,int S){\n\tif(S==(1<<n)-1) return true;\n\tif(x>=L) return false;\n\n\trep(i,n) if(check[i][x] && (S>>i&1)==0 && dfs(x+len[i],S|1<<i)) return true;\n\treturn false;\n}\n\nint main(){\n\tfor(int m;scanf(\"%d%d\",&n,&m),n;){\n\t\tchar key[12][32];\n\t\trep(i,n) scanf(\"%s\",key[i]), len[i]=strlen(key[i]);\n\n\t\tL=0;\n\t\tchar s[5001];\n\t\trep(i,m){\n\t\t\tscanf(\"%s\",s+L);\n\t\t\tL+=strlen(s+L);\n\t\t}\n\n\t\trep(i,n){\n\t\t\trep(x,L) check[i][x]=false;\n\t\t\tint fail[5001];\n\t\t\tKMP_build(key[i],fail);\n\t\t\tKMP_search(s,key[i],fail,check[i]);\n\t\t}\n\n\t\tint ans=0;\n\t\trep(x,L) if(dfs(x,0)) ans++;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint n;\nint m;\nstring t;\nchar buf[114514];\nstring des[114514];\nbool dp[5001][1 << 12];\n \nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n \n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n    }\n \n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n \n    int lim = 1 << n;\n    fill(dp[0], dp[t.size()+1], false);\n    for (int i=0; i<t.size(); i++) {\n      for (int g=0; g<n; g++) {\n        int prev = i+1-des[g].size();\n        if (prev < 0) continue;\n        if (t.substr(prev, des[g].size()) != des[g]) continue;\n \n        for (int st=0; st<lim; st++) {\n          if (st >> g & 1) continue;\n          dp[i+1][st|(1<<g)] |= dp[prev][st];\n        }\n        dp[i+1][1<<g] = true;\n      }\n    }\n \n    int ans = 0;\n    for (int i=0; i<=t.size(); i++) {\n      if (dp[i][lim-1]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint m;\nstring t;\nint sum;\nint num_node;\nint myroot;\nchar buf[114514];\nstring des[114514];\nchar cs[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nint mynext[200000][256];\nvector<int> matched[200000];\nbool dp[1 << 12][5001];\n\nbool Cmp(const string &a, const string &b) {\n  return a.size() > b.size();\n}\n\nint build_PMA(string *pats, int size) {\n  matched[num_node].resize(0);\n  for (int k=0; k<256; k++) mynext[num_node][k] = 0;\n  mynext[num_node][0] = num_node;\n  int root = num_node++;\n  for (int i=0; i<size; i++) {\n    int node = root;\n    for (int j=0; j<pats[i].size(); j++) {\n      char c = pats[i][j];\n      if (!mynext[node][c]) {\n        matched[num_node].resize(0);\n        for (int k=0; k<256; k++) mynext[num_node][k] = 0;\n        mynext[node][c] = num_node++;\n      }\n      node = mynext[node][c];\n    }\n    matched[node].push_back(i);\n  }\n\n  queue<int> q;\n  for (int i=0; i<52; i++) {\n    if (mynext[root][cs[i]]) {\n      mynext[mynext[root][cs[i]]][0] = root;\n      q.push(mynext[root][cs[i]]);\n    } else mynext[root][cs[i]] = root;\n  }\n\n  while (!q.empty()) {\n    int node = q.front(); q.pop();\n    for (int i=0; i<52; i++) {\n      if (mynext[node][cs[i]]) {\n        q.push(mynext[node][cs[i]]);\n        int failer = mynext[node][0];\n        while (!mynext[failer][cs[i]]) failer = mynext[failer][0];\n        mynext[mynext[node][cs[i]]][0] = mynext[failer][cs[i]];\n        if (mynext[node][cs[i]] != mynext[failer][cs[i]]) {\n          matched[mynext[node][cs[i]]].insert(matched[mynext[node][cs[i]]].end(), matched[mynext[failer][cs[i]]].begin(), matched[mynext[failer][cs[i]]].end());\n        }\n      }\n    }\n  }\n  return root;           \n}\n\n\nbool check(int idx) {\n  map<int, set<set<int> > > found;\n  int node = myroot;\n  found[idx] = set<set<int> >();\n  set<int> em;\n  found[idx].insert(em);\n  for (int i=idx; i<idx+sum; i++) {\n    while (!mynext[node][t[i]]) node = mynext[node][0];\n    node = mynext[node][t[i]];\n    if (!matched[node].empty()) {\n      for (int g : matched[node]) {\n        int prev = i+1-(int)des[g].size();\n        for (auto &st : found[prev]) {\n          //cout << \"st:\";\n          //for (auto a : st) cout << a << \" \";\n          //cout << \"\\n\";\n          if (!st.count(g)) {\n            //puts(\"pushed\");\n            set<int> nst(st);\n            nst.insert(g);\n            found[i+1].insert(nst);\n          }\n        }\n      }\n    }\n  }\n\n  return !found[idx+sum].empty();\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    sum = 0;\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      des[i] = buf;\n      sum += (int)des[i].size();\n    }\n    num_node = 1;\n    myroot = build_PMA(des, n);\n\n    t = \"\";\n    for (int i=0; i<m; i++) { \n      scanf(\" %s\", buf);\n      t += buf;\n    }\n\n    int node = myroot;\n    int lim = 1 << n;\n    fill(dp[0], dp[lim], false);\n    for (int i=0; i<t.size(); i++) {\n      while (!mynext[node][t[i]]) node = mynext[node][0];\n      node = mynext[node][t[i]];\n      for (int g : matched[node]) {\n        for (int st=0; st<lim; st++) {\n          if (st >> g & 1) continue;\n          int prev = i+1-des[g].size();\n          dp[st|(1<<g)][i+1] |= dp[st][prev];\n        }\n        dp[1<<g][i+1] = true;\n      }\n    }\n\n    int ans = 0;\n    for (int i=0; i<=t.size(); i++) {\n      if (dp[lim-1][i]) ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tchar name[21];\n\tint length;\n};\n\n\nint POW[21];\nint N,num_line,TEXT_LENGTH;\nchar buf[101],TEXT[5001];\nbool is_match[5001],pattern_match[5001][20];\nInfo info[20];\n\n\nvoid recursive(int start_loc,int loc,int state){\n\tif(is_match[start_loc])return; //すくなくとも1つがマッチしたならreturn\n\n\tif(state == POW[N]-1){ //全文字一致\n\t\tis_match[start_loc] = true;\n\t\treturn;\n\t}\n\n\tint next_state,next_loc;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tif(state & (1 << loop)){ //使用済\n\t\t\t//Do nothin\n\t\t}else{ //TEXT[loc]から、info[loop]との一致比較\n\t\t\tif(pattern_match[loc][loop]){\n\t\t\t\tnext_state = state+POW[loop];\n\t\t\t\tnext_loc = loc+info[loop].length;\n\t\t\t\trecursive(start_loc,next_loc,next_state);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tint length,sum_length = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",info[i].name);\n\t\tfor(length = 0; info[i].name[length] != '\\0'; length++);\n\t\tinfo[i].length = length;\n\t\tsum_length += length;\n\t}\n\n\t//テキストの読み込み\n\tint index = 0;\n\tfor(int loop = 0; loop < num_line; loop++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int k = 0; buf[k] != '\\n' && buf[k] != '\\0'; k++){\n\t\t\tTEXT[index++] = buf[k];\n\t\t}\n\t}\n\tTEXT_LENGTH = index;\n\n\tfor(int i = 0; i < TEXT_LENGTH; i++)is_match[i] = false;\n\n\tbool FLG;\n\t//場所と文字の一致を先に計算しておく\n\tfor(int loc = 0; loc < TEXT_LENGTH; loc++){\n\t\tfor(int i = 0; i < N; i++)pattern_match[loc][i] = false;\n\t}\n\n\tfor(int loc = 0; loc < TEXT_LENGTH; loc++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(loc+info[i].length > TEXT_LENGTH)continue;\n\t\t\tFLG = true;\n\t\t\tfor(int k = 0; k < info[i].length; k++){\n\t\t\t\tif(TEXT[loc+k] != info[i].name[k]){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)pattern_match[loc][i] = true;\n\t\t}\n\t}\n\n\n\n\t//一致の先頭となりえる箇所を全探索\n\tfor(int start_loc = 0; start_loc <= TEXT_LENGTH-sum_length; start_loc++){\n\t\trecursive(start_loc,start_loc,0);\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < TEXT_LENGTH; i++){\n\t\tif(is_match[i])ans++;\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 21; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&num_line);\n\t\tif(N == 0 && num_line == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stack>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) a.rbegin(),a.rend()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define declare(a,it) __typeof(a) it=(a)\n#define FOR(it,a) for(declare(a.begin(),it);it!=a.end();++it)\n#define FORR(it,a) for(declare(a.rbegin(),it);it!=a.rend();++it)\n\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    if(abs(a.real()-b.real())>EPS)\n      return a.real()<b.real();\n    return a.imag()<b.imag();\n  }\n}\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint n,m;\n\nll gha[6000];\nbool vis[1<<12][100];\nll po[1000];\n\nvoid solve(){\n  ll ha[n];\n  int len[n];\n  rep(i,n) {\n    char a[30];\n    scanf(\"%s\",a);\n    ll h =0 ;\n    len[i] = strlen(a);\n    rep(j,len[i])\n      h=h*31+a[j];\n    ha[i] =h;\n  }\n  \n  po[0] = 1;\n  rep(i,999) po[i+1] = po[i]*31;\n  int ans = 0;\n  char text[6000];\n  int tidx = 0;\n  rep(jjj,m) {\n    scanf(\"%s\",text+tidx);\n    while(text[tidx]) ++tidx;\n  }\n  \n  rep(i,tidx) gha[i+1] = gha[i]*31+text[i];\n  \n  bool vis[250][(1<<n)+3];\n  rep(i,250)rep(j,1<<n) vis[i][j]=0;\n  rep(i,250) vis[i][0]=1;\n  \n  rep(j,tidx+1){\n    int cur = j%250;\n    rep(i,1<<n){\n      if(!vis[cur][i]) continue;\n      rep(k,n)\n        if((~i&(1<<k)) && len[k]+j<=tidx &&\n           ha[k] == gha[j+len[k]] - gha[j]*po[len[k]])\n          vis[(j+len[k])%250][i|(1<<k)]=1;\n    }\n    ans += vis[cur][(1<<n)-1];\n    rep(i,1<<n) vis[cur][i] = 0;\n    vis[cur][0]=1;\n  }\n  printf(\"%d\",ans);\n  //cout << ans << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  \n  while(scanf(\"%d%d\",&n,&m) ,n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n\nint l;\nint n,m;\n\nchar c[20][30];\nchar s[5050];\nint A[128],B[128];\nbool D[20];\n\n\nint check(){\n\n\tint remain = false;\n\tfor(int i = 'a' ; i <= 'z' ; i++){\n\t\tif( B[i] != A[i] ){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tremain |= B[i];\n\t\t}\n\t}\n\n\t\n\tif( !remain ) return true;\n\n\tfor(int i = 0 ; i < n ; i++){\n\t\tif( !D[i] ){\n\t\t\tD[i] = true;\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]-- , A[c[i][j]]--;\n\t\t\tint res = check();\n\t\t\tD[i] = false;\t\n\t\t\tfor(int j = 0 ; c[i][j] ; j++) B[c[i][j]]++ , A[c[i][j]]++; \n\t\t\tif( res ) return true;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\tfor(int i = 'a' ; i <= 'z' ; i++) B[i] = 0;\n\t\tl = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tscanf(\"%s\",c[i]);\n\t\t\tint L = strlen(c[i]);\n\t\t\tfor(int j = 0 ; j < L ; j++)\n\t\t\t\tB[c[i][j]]++;\n\t\t\tl += L;\n\t\t}\n\t\tint ans = 0;\n\t\tint len = 0;\n\t\t\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tscanf(\"%s\",s+len);\n\t\t\tlen += strlen(s);\n\t\t}\n\t\tif( len >= l ){\n\t\t\tfor(int j = 'a' ; j <= 'z' ; j++) A[j]=0;\n\t\t\tfor(int j = 0 ; j < l ; j++) A[s[j]]++;\n\t\t\tfor(int j = l ; j <= len ; j++){\n\t\t\t\tif( check() ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tA[s[j-l]]--;\n\t\t\t\tA[s[j]]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \ninline long long to_int64(char x) {\n  return (long long)x;\n}\n  \nstruct RollingHash {\n    \n  const array<int, 2> mods = {{int(1e9+7), int(1e9+9)}};//, int(1234567891)}};\n  const array<int, 2> Ks = {{1007, 1009}};//, 1013}};\n  const int ModsSize = mods.size();\n  \n  int N;\n  string S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n  \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n  \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n  \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n   \n  RollingHash(string const& s) {\n    S = s;\n    N = s.size();\n    construct();\n  }\n  \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n\n  bool same(int a_start, int a_end, int b_start, int b_end, RollingHash const& rh) const {\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh.get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n};\n \nint fact[13];\nint sizes[1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<RollingHash> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(RollingHash(s));\n    }\n\n    rep(i, 1<<N) sizes[i] = 0;\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i].N;\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      char s[5001]; cin >> s, t += s;\n    }\n\n    RollingHash T(t);\n    int TSize = t.size();\n \n    ll sum = 0;\n    rep(st, TSize - sizes[(1<<N)-1] + 1) {\n      int dp[1<<N]; memset(dp, 0, sizeof dp);\n      dp[0] = 1;\n      rep(S, 1<<N) {\n        if(!dp[S]) continue;\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i].N, vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#define REP(i, n) for (i = 0; i < (n); i++)\n#define REP1(i, n) for (i = 1; i <= (n); i++)\nusing namespace std;\n\nconst int CODE = (1 << 12) +10;\nconst int N = 5000 +10;\n\nstruct QUEUE {int n, code;};\n\nbool f[CODE][N];\n\nchar a[20][20];\nchar s[N];\n\nint ans, m, n;\nint len[N];\n\nqueue <QUEUE> que;\n\nbool ri()\n{\n\tint i;\n\n\tans = 0;\n\tmemset(a, 0, sizeof(a));\n\tmemset(f, false, sizeof(f));\n\tmemset(s, 0, sizeof(s));\n\tscanf(\"%d%d\", &n, &m);\n\tif (n == 0 && m == 0) return false;\n\tREP(i, n)\n\t{\n\t\tscanf(\"%s\", a[i]);\n\t\tlen[i] = strlen(a[i]);\n\t}\n\twhile (m--) scanf(\"%s\", s + (strlen(s)));\n\tm = strlen(s);\n\treturn true;\n}\n\nbool same(int st, int x)\n{\n\tint i;\n\n\tif (st + len[x] > m) return false;\n\tREP(i, len[x]) if (s[st + i] != a[x][i]) return false;\n\treturn true;\n}\n\nvoid solve()\n{\n\tint i, j;\n\n\tQUEUE v1, v2;\n\n\twhile (!que.empty()) que.pop();\n\tREP(i, m)\n\t\tREP(j, n)\n\t\t\tif (same(i, j))\n\t\t\t{\n\t\t\t\tv1.n = i;\n\t\t\t\tv1.code = 1 << j;\n\t\t\t\tque.push(v1);\n\t\t\t\tf[1 << j][i] = true;\n\t\t\t}\n\twhile (!que.empty())\n\t{\n\t\tv1 = que.front();\n\t\tque.pop();\n\t\tREP(i, n)\n\t\t\tif ((v1.code & (1 << i)) == 0 && v1.n - len[i] >= 0 && !f[v1.code | (1 << i)][v1.n - len[i]] && f[1 << i][v1.n - len[i]])\n\t\t\t{\n\t\t\t\tf[v1.code | (1 << i)][v1.n - len[i]] = true;\n\t\t\t\tv2.n = v1.n - len[i];\n\t\t\t\tv2.code = v1.code | (1 << i);\n\t\t\t\tque.push(v2);\n\t\t\t}\n\t}\n\tREP(i, m) ans += f[(1 << n) - 1][i];\n}\n\nint main()\n{\n\twhile (ri())\n\t{\n\t\tsolve();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n];\n    for(int i=0;i<n;i++) cin>>e[i];\n    string b,t;\n    for(int i=0;i<M;i++){\n      cin>>t;\n      b+=t;\n    }\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<int> ln[400];\n    function<void(int,int,string)> dfs=[&](int d,int c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\t//if(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<int> edge[5001];\n\nbool same(string a,string b,int len,int v){\n\tif(a.size()<len || b.size()<len+v)return false;\n\ta=a.substr(0,v);\n\tb=b.substr(len,v);\n\treturn (a==b);\n}\n\nvoid KMP(string text,string pattern,int v){\n\tint textN=text.size();\n\tint patternN=pattern.size();\n\tvector<int> next(patternN+1,0);\n\tnext[0]=1;\n\tfor(int i=1;i<=patternN;i++){\n\t\tstring s=pattern.substr(0,i);\n\t\tint len=1;\n\t\twhile(i-len>0 && !same(s,pattern,len,i-len))len++;\n\t\tnext[i]=len;\n\t}\n\tint cnt=0;\n\tint tp=0,pp=0;\n\twhile(tp<textN){\n\t\tif(text[tp]==pattern[pp]){\n\t\t\ttp++;\n\t\t\tpp++;\n\t\t}else{\n\t\t\tpp-=next[pp];\n\t\t\tif(pp<0){\n\t\t\t\ttp++;\n\t\t\t\tpp++;\n\t\t\t}\n\t\t}\n\t\tif(pp==patternN){\n\t\t\tedge[tp-pattern.size()].push_back(v);\n\t\t}\n\t}\n}\n\nint n,m;\nstring e[13];\nstring text;\nbool dp[5001][1<<12];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> e[i];\n\t\t}\n\t\ttext=\"\";\n\t\tfor(int i=0;i<m;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\ttext+=str;\n\t\t}\n\t\tint len=text.size();\n\t\tfor(int i=0;i<len;i++){\n\t\t\tedge[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tKMP(text,e[i],i);\n\t\t}\n\t\tmemset(dp,false,sizeof(dp));\n\t\tll res=0;\n\t\tfor(int i=0;i<(1<<n);i++){\n\t\t\tfor(int j=0;j<=len;j++){\n\t\t\t\tif(i==0)dp[j][i]=true;\n\t\t\t\tif(i==((1<<n)-1)){\n\t\t\t\t\tres+=dp[j][i]?1:0;\n\t\t\t\t}\n\t\t\t\tfor(int l=0;l<edge[j].size();l++){\n\t\t\t\t\tint k=edge[j][l];\n\t\t\t\t\tif((!((i>>k) & 1))){\n\t\t\t\t\t\tdp[j+e[k].size()][i|(1<<k)]|=dp[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <bitset>\nusing namespace std;\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0) break;\n\n        vector<string> e(n);\n        for(int i=0; i<n; i++){\n            cin >> e[i];\n        }\n        string t = \"\";\n        for(int i=0; i<m; i++){\n            string tmp;\n            cin >> tmp;\n            t += tmp;\n        }\n\n        vector<bitset<5000>> dp(1<<n);\n        for(int i=0; i<n; i++){\n            for(int j=0; j+e[i].length()-1<t.length(); j++){\n                if(e[i] == t.substr(j, e[i].length())){\n                    dp[1<<i][j+e[i].length()] = 1;\n                }\n            }\n        }\n        for(int p=0; p<(int)t.length(); p++){\n            for(int i=1; i<(1<<n); i++){\n                if(dp[i][p] == 0) continue;\n                for(int j=0; j<n; j++){\n                    if(i>>j&1) continue;\n                    if(dp[1<<j][p+e[j].length()] == 1){\n                        dp[i|(1<<j)][p+e[j].length()] = 1;\n                    }\n                }\n            }\n        }\n        cout << dp[(1<<n)-1].count() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool table[12][5000];\nint n;\nstring text;\nstring str[12];\nbool visited[1<<12];\n\nbool dfs(int S, int now) {\n  if (visited[S]) return 0;\n  visited[S] = 1;\n  if (S == (1<<n)-1) return 1;\n  if (now >= text.size()) return 0;\n  REP(i, n) {\n    if (S>>i&1) continue;\n    if (table[i][now] && dfs(S|1<<i, now+str[i].size()))\n      return 1;\n  }\n  return 0;\n}\n\nint main() {\n  int m;\n  while(cin>>n>>m,n||m) {\n    int len = 0;\n    REP(i, n) {\n      cin >> str[i];\n      len += str[i].size();\n    }\n    text.clear();\n    REP(i,m) {\n      string tmp;\n      cin >> tmp;\n      text += tmp;\n    }\n    memset(table,0,sizeof(table));\n    REP(i, n) {\n      REP(j, text.size() - str[i].size() + 1) {\n        if (str[i] == text.substr(j, str[i].size()))\n          table[i][j] = 1;\n      }\n    }\n    int ans = 0;\n    REP(i, text.size() - len+1) {\n      memset(visited, 0, sizeof(visited));\n      ans += dfs(0, i);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nbool table[12][5000];\nint n;\nstring text;\nstring str[12];\n\nbool dfs(int S, int now) {\n  if (S == (1<<n)-1) return 1;\n  if (now >= text.size()) return 0;\n  REP(i, n) {\n    if (S>>i&1) continue;\n    if (table[i][now] && dfs(S|1<<i, now+str[i].size()))\n      return 1;\n  }\n  return 0;\n}\n\nint main() {\n  int m;\n  while(cin>>n>>m,n||m) {\n    int len = 0;\n    REP(i, n) {\n      cin >> str[i];\n      len += str[i].size();\n    }\n    text.clear();\n    REP(i,m) {\n      string tmp;\n      cin >> tmp;\n      text += tmp;\n    }\n    memset(table,0,sizeof(table));\n    REP(i, n) {\n      REP(j, text.size() - str[i].size() + 1) {\n        if (str[i] == text.substr(j, str[i].size()))\n          table[i][j] = 1;\n      }\n    }\n    int ans = 0;\n    map<string, bool> mp;\n    REP(i, text.size() - len+1) {\n      if (mp.count(text.substr(i, len))) {\n        if (mp[text.substr(i, len)])\n          ans++;\n      } else {\n        if (dfs(0, i)) {\n          mp[text.substr(i, len)] = 1;\n          ans++;\n        } else\n          mp[text.substr(i, len)] = 0;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct KMP{\n\tstring pat;\n\tvi fail;\n\tKMP(const string& p):pat(p),fail(p.size()+1){\n\t\tfail[0]=-1;\n\t\tfor(int i=0,j=-1;i<pat.size();){\n\t\t\twhile(j>=0 && pat[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tfail[i]=j;\n\t\t}\n\t}\n\tint Match(const string& text){\n\t\tfor(int i=0,j=0;i<text.size();){\n\t\t\twhile(j>=0 && text[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tif(j==pat.size())\n\t\t\t\treturn i-j;\n\t\t}\n\t\treturn -1;\n\t}\n\tvi MatchAll(const string& text){\n\t\tvi res;\n\t\tfor(int i=0,j=0;i<text.size();){\n\t\t\twhile(j>=0 && text[i]!=pat[j])\n\t\t\t\tj=fail[j];\n\t\t\ti++,j++;\n\t\t\tif(j==pat.size()){\n\t\t\t\tres.push_back(i-j);\n\t\t\t\tj=fail[j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvs ps(n);\n\t\trep(i,n) cin>>ps[i];\n\t\tstring t;\n\t\trep(i,m){\n\t\t\tstring x; cin>>x;\n\t\t\tt+=x;\n\t\t}\n\t\tvvi ms(n);\n\t\trep(i,n) ms[i]=KMP(ps[i]).MatchAll(t);\n\t\t\n\t\tm=t.size();\n\t\tvector<vvi> dp(1<<n,vvi(n,vi(m+1)));\n\t\trep(i,n) rep(j,ms[i].size()) dp[1<<i][i][ms[i][j]+ps[i].size()]=1;\n\t\trep(i,1<<n) rep(j,n) if(i>>j&1) rep(k,n) if(!(i>>k&1)){\n\t\t\trep(l,ms[k].size()) if(dp[i][j][ms[k][l]])\n\t\t\t\tdp[i|1<<k][k][ms[k][l]+ps[k].size()]=1;\n\t\t}\n\t\t\n\t\tvi res(m+1);\n\t\trep(i,n) rep(j,m+1) res[j]|=dp.back()[i][j];\n\t\tcout<<accumulate(all(res),0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned int ull;\nstruct RollingHash{\n  string S;\n  ull B;\n  vector<ull> hash,p;\n  int len;\n  RollingHash(){}\n  RollingHash(string S,ull B=1777771):S(S),B(B){init();};\n  void init(){\n    len=S.length();\n    hash.resize(len+1);\n    p.resize(len+1);\n    hash[0]=0;p[0]=1;\n    for(int i=0;i<len;i++){\n      hash[i+1]=hash[i]*B+S[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l,r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n\nsigned main(){\n  int n,M;\n  while(cin>>n>>M,n){\n    string e[n],t[M];\n    for(int i=0;i<n;i++) cin>>e[i];\n    for(int i=0;i<M;i++) cin>>t[i];\n    string b;\n    for(int i=0;i<M;i++) b+=t[i];\n    int x=n/2,y=n-x;\n    set<ull> sa;\n    set<ull> m[1<<12];\n    set<short> ln[400];\n    function<void(int,short,string)> dfs=[&](int d,short c,string s){\n      if(d==x||d==y){\n\tRollingHash rh(s);\n\tln[s.size()].insert(c);\n\tm[c].insert(rh.find(0,s.size()));\n\tsa.insert(rh.find(0,s.size()));\n\tif(d==y) return;\n      }\n      for(int i=0;i<n;i++){\n\tif((c>>i)&1) continue;\n\tdfs(d+1,c+(1<<i),s+e[i]);\n      }\n    };\n    dfs(0,0,\"\");\n    //cout<<\"count:\"<<count<<endl;\n    int len=0;\n    for(int i=0;i<n;i++) len+=e[i].size();\n    RollingHash rh(b);\n    int ans=0;\n    for(int i=0;i<=(int)b.size()-len;i++){\n      bool flg=0;\n      for(int l=0;l<400;l++){\n\tif(ln[l].empty()) continue;\n\tull u=rh.find(i,i+l),v=rh.find(i+l,i+len);\n\tif(!sa.count(u)||!sa.count(v)) continue;\n\tfor(int j:ln[l]){\n\t  int k=(~j)&((1<<n)-1);\n\t  if(m[j].count(u)&&m[k].count(v)){\n\t    flg=1;\n\t    break;\n\t  }\n\t}\n\tif(flg) break;\n      }\n      if(flg) ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \ninline long long to_int64(char x) {\n  return (long long)x;\n}\n  \ntemplate<class T> struct RollingHash {\n    \n  const array<int, 3> mods = {{int(1e9+7), int(1e9+9), int(1234567891)}};\n  const array<int, 3> Ks = {{1007, 1009, 1013}};\n  const int ModsSize = mods.size();\n  \n  vector<T> S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n  \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n  \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n  \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n   \n  RollingHash(vector<T> const& S) {\n    this->S = S;\n    construct();\n  }\n  \n  RollingHash(string const& S) {\n    int n = S.size();\n    rep(i, n) { this->S.push_back(S[i]); }\n    construct();\n  }\n  \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end) const { // not verified\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool same(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> const& rh) const {\n    if(rh == nullptr) { return same(a_start, a_end, b_start, b_end); }\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh->get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n  \n  bool compare(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> rh = nullptr) const {  // not verified\n    int a_len = a_end - a_start;\n    int b_len = b_end - b_start;\n  \n    int len = min(a_len, b_len);\n    int max_len = len + 1;\n    int min_len = 0;\n  \n    while(min_len + 1 < max_len) {\n      int next_len = (min_len + max_len) / 2;\n      if(same(a_start, a_start + next_len, b_start, b_start + next_len, rh)) {\n        min_len = next_len;\n      }\n      else {\n        max_len = next_len;\n      }\n    }\n  \n    if(a_start + min_len == a_end) {\n      if(b_start + min_len == b_end) { return 0; }\n      else { return -1; }\n    }\n    else {\n      if(b_start + min_len == b_end) { return 1; }\n      else { return S[a_start + min_len] == S[b_start + min_len]; }\n    }\n  \n  }\n  \n};\n \nint fact[13];\nint DP[5010][1<<12];\n\nint main() {\n \n  fact[0] = 1;\n  REP(i, 1, 13) fact[i] = fact[i-1] * i;\n \n  for(int N, M; cin >> N >> M && (N|M);) {\n    vector<shared_ptr<RollingHash<char>>> vs;\n    set<string> se;\n    rep(i, N) {\n      string s; cin >> s;\n      se.insert(s);\n      vs.push_back(make_shared<RollingHash<char>>(RollingHash<char>(s)));\n    }\n\n    vector<int> sizes(1 << N);\n    rep(S, 1<<N) {\n      rep(i, N) {\n        if(S >> i & 1) continue;\n        sizes[S | (1<<i)] += vs[i]->S.size();\n      }\n    }\n\n    string t;\n    rep(i, M) {\n      string s; cin >> s, t += s;\n    }\n\n    RollingHash<char> T(t);\n    int TSize = t.size();\n \n    ll sum = 0;\n    rep(i, TSize + 10) rep(j, 1<<N) DP[i][j] = 0;\n    \n    rep(st, TSize) {\n      int* dp = DP[st];\n      rep(i, N)\n        if(T.same(st, st + vs[i]->S.size(), 0, vs[i]->S.size(), vs[i]))\n          dp[1<<i] = 1;\n\n      rep(S, 1<<N) {\n        rep(i, N) {\n          if(S >> i & 1) continue;\n          if(T.same(st + sizes[S], st + sizes[S|(1<<i)], 0, vs[i]->S.size(), vs[i])) {\n            dp[S|(1<<i)] += dp[S];\n          }\n        }\n      }\n      sum += dp[(1<<N)-1];\n    }\n    cout << sum / (fact[vs.size()] / fact[se.size()]) << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nint main(){\n  for(int n,m;cin>>n>>m,n;){\n    string e[12];\n    for(int i=0;i<n;i++){\n      cin>>e[i];\n    }\n    string t;\n    for(int i=0;i<m;i++){\n      string tt;\n      cin>>tt;\n      t+=tt;\n    }\n    bool ma[12][5000];\n    int sum=0;\n    for(int i=0;i<n;i++){\n      sum+=e[i].size();\n      for(int j=0;j<t.size();j++){\n\tma[i][j]=e[i]==t.substr(j,e[i].size());\n      }\n    }\n    int a=0;\n    for(int i=0;i+sum-1<t.size();i++){\n      int x[1<<12];\n      fill(begin(x),end(x),-1);\n      x[0]=i;\n      for(int j=0;j<1<<n;j++){\n\tif(x[j]>=0){\n\t  for(int k=0;k<n;k++){\n\t    if(!(j>>k&1)&&ma[k][x[j]]){\n\t      x[j|1<<k]=x[j]+e[k].size();\n\t    }\n\t  }\n\t}\n      }\n      a+=x[(1<<n)-1]>=0;\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#define int ll\n//#define endl \"\\n\"\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const &);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream & os, tuple<T...> const & t){ _ot<0>(os, t); return os; }\ntemplate<class T, class U> ostream & operator<<(ostream & os, pair<T,U> const & p){ return os << \"(\" << p.first << \", \" << p.second << \") \"; }\ntemplate<class T> ostream & operator<<(ostream & os, vector<T> const & v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\ntemplate<class T> inline bool chmax(T & x, T const & y){ return x<y ? x=y,true : false; }\ntemplate<class T> inline bool chmin(T & x, T const & y){ return x>y ? x=y,true : false; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n// ll const mod = 1000000007;\n// ll const inf = 1LL<<60;\n\nbool dp[6000][1<<13];\n\nstruct RollingHash {\n    typedef ll int_t;\n    typedef int_t hash_t;\n    int_t base1;\n    int_t mod1;\n    static int_t hash1[6000];\n    static int_t pow1[6000];\n    RollingHash() : base1(1009), mod1(1000000007) {}\n    void init(const string &s) {\n        int n = s.size();\n        hash1[0] = 0;\n        pow1[0] = 1;\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n        }\n    }\n    hash_t get(int l,int r) {\n        int_t t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        return t1;\n    }\n};\nRollingHash::int_t RollingHash::hash1[6000];\nRollingHash::int_t RollingHash::pow1[6000];\n\nint solve(vector<string> & ss, string & t){\n    int n = ss.size();\n    int len = t.size();\n\n    rep(i,len+1)rep(j,1<<n) dp[i][j] = false;\n    rep(i,len+1) dp[i][0] = true;\n    rep(pos,len){\n        rep(mask,1<<n){\n            if(!dp[pos][mask]) continue;\n            rep(i,n){\n                if(mask>>i&1) continue;\n                if(pos+ss[i].size() > t.size()) continue;\n                dp[pos+ss[i].size()][mask|1<<i] |= t.substr(pos,ss[i].size()) == ss[i];\n            }\n        }\n\n        // dump(pos);\n        // rep(i,1<<n){\n        //     dump(bitset<3>(i),dp[pos][i]);\n        // }\n    }\n\n    int ans = 0;\n    rep(i,len+1){\n        if(dp[i][(1<<n)-1]){\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n,m;\n    while(cin >> n >> m && n){\n        vector<string> s(n);\n        rep(i,n) cin >> s[i];\n        string t;\n        rep(i,m){\n            string x;\n            cin >> x;\n            t += x;\n        }\n        cout << solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto& a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst ll base = 10007;\nconst ll mod = (1ll << 52) - 1;\n\nbool mt[12][5005]; // match\nbool dp[1 << 12][5005]; // dp...\n\nint main() {\n\tcin.sync_with_stdio(false); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\t// dp state: 0/i = 1 always as starting state\n\trep(i, 0, 5005) dp[0][i] = 1;\n\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m; if (!n && !m) break;\n\t\tvector<string> elem(n);\n\t\trep(i, 0, n) cin >> elem[i];\n\t\tstring buf;\n\t\trep(i, 0, m) { string s; cin >> s; buf += s; }\n\t\t// pad buf\n\t\tm = buf.size(); buf = \" \" + buf;\n\t\t// calculate each match\n\t\trep(h, 0, n) rep(i, 1, m + 1) mt[h][i] = buf.substr(i, elem[h].size()) == elem[h]; \n\t\t// reset dp from *1*\n\t\trep(i, 1, (1 << n)) rep(j, 0, m + 2) dp[i][j] = 0;\n\t\t// start dp\n\t\trep(i, 1, m + 1) rep(j, 0, (1 << n) - 1) rep(k, 0, n)\n\t\t\tif (dp[j][i] && mt[k][i] && !(j & (1 << k))) {\n\t\t\t\t//cout << \"mark \" << bitset<3>(j) << \"->\" << bitset<3>(j | (1 << k)) << \", \" << i << \"->\" << (i + elem[k].size()) << endl;\n\t\t\t\tdp[j | (1 << k)][i + elem[k].size()] = 1;\n\t\t\t}\n\t\t// calc\n\t\tint a = 0;\n\t\trep(i, 1, m + 2) if (dp[(1 << n) - 1][i]) a++;\n\t\tcout << a << endl;\n\t\t// test\n\t\t/*\n\t\trep(i, 1, m + 1) {\n\t\t\trep(j, 0, n) if (mt[j][i]) printf(\"Matches elem %d at %d\\n\", j, i);\n\t\t}\n\t\t*/\n\t}\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1291\n  Title:Search of Concatenated Strings\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint n,m;\nchar e[12][21];\nint  len[12];\nchar t[5001];\nchar flag[5001][4096];\nvoid dump_flag(char flag[5001][4096],int len)\n{\n  int i,j;\n  for(i=0;i<len;i++)\n    for(j=0;j<4096;j++)\n      if(flag[i][j])\n\tprintf(\"%d %d\\n\",i,j);\n}\nmain()\n{\n  int l,ln,l_s,i,j,k,cnt,loop,mask,pat;\n  char buf[101];\n  while(scanf(\"%d %d\",&n,&m) && (n||m))\n    {\n      memset(flag,0,sizeof(flag));\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"%s\",&e[i][0]); \n\t  len[i]=strlen(&e[i][0]);\n\t}\n      t[0]='\\0';\n      for(i=0;i<m;i++)\n\t{\n\t  scanf(\"%s\",buf);\n\t  ln=strlen(buf);\n\t  if(buf[ln-1]<' ')\n\t    buf[ln-1]='\\0';\n\t  strcat(t,buf);\n\t}\n      l_s=strlen(t);\n      loop=1<<n;\n      for(i=0,cnt=0;i<l_s;i++)\n\t{\n\t  for(j=0;j<loop;j++)\n\t    {\n\t    if(j && flag[i][j]==0)\n\t    continue;\n\t    for(k=0,mask=1;k<n;k++,mask<<=1)\n\t\t{\n\t\t  if(j & mask)\n\t\t    continue;\n\t\t  if(0==strncmp(&e[k][0],&t[i],(l=len[k])))\n\t\t    {\n\t\t      pat=j|mask;\n\t\t      flag[i+l][pat]=1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      for(i=0,cnt=0;i<l_s;i++)\n\tcnt += flag[i][loop-1];\n      printf(\"%d\\n\",cnt);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1291\n  Title:Search of Concatenated Strings\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint n,m;\nchar e[12][21];\nint  len[12];\nchar t[5001];\nchar flag[5001][4096];\nvoid dump_flag(char flag[5001][4096],int len)\n{\n  int i,j;\n  for(i=0;i<len;i++)\n    for(j=0;j<4096;j++)\n      if(flag[i][j])\n\tprintf(\"%d %d\\n\",i,j);\n}\nmain()\n{\n  int l,ln,l_s,i,j,k,cnt,loop,mask,pat;\n  char buf[101];\n  while(scanf(\"%d %d\",&n,&m) && (n||m))\n    {\n      memset(flag,0,sizeof(flag));\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"%s\",&e[i][0]); \n\t  len[i]=strlen(&e[i][0]);\n\t}\n      t[0]='\\0';\n      for(i=0;i<m;i++)\n\t{\n\t  scanf(\"%s\",buf);\n\t  ln=strlen(buf);\n\t  if(buf[ln-1]<' ')\n\t    buf[ln-1]='\\0';\n\t  strcat(t,buf);\n\t}\n      l_s=strlen(t);\n      loop=1<<n;\n      for(i=0,cnt=0;i<l_s;i++)\n\t{\n\t  for(j=0;j<loop;j++)\n\t    {\n\t    if(j && flag[i][j]==0)\n\t    continue;\n\t    for(k=0,mask=1;k<n;k++,mask<<=1)\n\t\t{\n\t\t  if(j & mask)\n\t\t    continue;\n\t\t  if(0==strncmp(&e[k][0],&t[i],(l=len[k])))\n\t\t    {\n\t\t      pat=j|mask;\n\t\t      flag[i+l][pat]=1;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      for(i=0,cnt=0;i<=l_s;i++)\n\tcnt += flag[i][loop-1];\n      printf(\"%d\\n\",cnt);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1291\n  Title:Search of Concatenated Strings\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint n,m;\nchar e[12][21];\nint  len[12];\nint  len_total;\nchar t[5001];\nint solve(char *s,int use,int cnt)\n{\n  int i,mask;\n\n  //  printf(\"s=%s [%d][%d]\\n\",s,use,cnt);\n\n  if(cnt==0)\n    return(1);\n  for(i=0,mask=1;i<n;i++,mask<<=1)\n    {\n      if(mask & use)\n\tcontinue;\n      if(0==strncmp(s,&e[i][0],len[i]))\n\treturn(solve(s+len[i],use|mask,cnt-1));\n    }\n  return(0);\n}\n\nmain()\n{\n  int i,cnt;\n  char buf[101];\n  while(scanf(\"%d %d\",&n,&m) && (n||m))\n    {\n      for(i=0;i<n;i++)\n\t{\n\t  scanf(\"%s\",&e[i][0]); \n\t  len[i]=strlen(&e[i][0]);\n\t}\n      t[0]='\\0';\n      for(i=0;i<m;i++)\n\t{\n\t  scanf(\"%s\",buf); \n\t  if(buf[strlen(buf)-1]<' ')\n\t    buf[strlen(buf)-1]='\\0';\n\t  strcat(t,buf);\n\t}\n      for(i=0,cnt=0;i<strlen(t)-len_total;i++)\n\t{\n\t  if(solve(t+i,0,n))\n\t    cnt++;\n\t}\n      printf(\"%d\\n\",cnt);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1291 Search of Concatenated Strings\n// 2018.5.6 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nchar e[12][22]; int w[12];\nchar t[5001]; int len;\nchar dp[5001][1<<12];\n  \nint main()\n{\n\tint n, m, i, j, k, S, lim, ans;\n\tchar *p;\n\n\twhile (n = in()) {\n\t\tm = in();\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tp = e[i]; while ((*p = gc()) > ' ') p++;\n\t\t\t*p = 0, w[i] = p-e[i];\n\t\t}\n\n\t\tp = t; while (m--) {\n\t\t\twhile ((*p = gc()) > ' ') p++;\n\t\t}\n\t\t*p = 0, len = p-t;\n\n\t\tlim = (1<<n)-1;\n\t\tmemset(dp, 0, sizeof(dp));\n\n\t    for (i = 0; i < len; i++) {\n\t\t\tfor (j = 0; j < n; j++) if ((k = i+1-w[j]) >= 0) {\n\t\t\t\tif (memcmp(t+k, e[j], w[j])) continue;\n  \n\t\t\t\tfor (S = 0; S <= lim; S++) {\n\t\t\t\t\tif ((S >> j) & 1) continue;\n\t\t\t\t\tdp[i+1][S|(1<<j)] |= dp[k][S];\n\t\t\t\t}\n\t\t\t\tdp[i+1][1<<j] = 1;\n\t\t\t}\n\t\t}\n  \n\t\tans = 0;\n\t\tfor (i = 0; i <= len; i++) if (dp[i][lim]) ans++;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tint n, m, len;\n\tString[] s;\n\tString str;\n\tint[] a;\n\tint[][] sum;\n\tboolean[] u;\n\tboolean[][] v;\n\t\n\tboolean match(int k, String t, int h, int x){\n\t\tif(k==n)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tint nx = x | (1<<i);\n\t\t\tif(v[nx][h+s[i].length()-1])continue;\n\t\t\tboolean f = true;\n\t\t\tfor(int j=0;j<s[i].length();j++){\n\t\t\t\tif(t.charAt(h+j)!=s[i].charAt(j)){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!u[i]&&f){\n\t\t\t\tv[nx][h+s[i].length()-1] = true;\n\t\t\t\tu[i] = true;\n\t\t\t\tif(match(k+1, t, h+s[i].length(), nx))return true;\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\ts = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0;i<m;i++)sb.append(sc.next());\n\t\t\tstr = sb.toString();\n\t\t\tlen = 0;\n\t\t\ta = new int[26];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlen += s[i].length();\n\t\t\t\tfor(char ch:s[i].toCharArray())a[ch-'a']++;\n\t\t\t}\n\t\t\tsum = new int[str.length()+1][26];\n\t\t\tfor(int i=1;i<=str.length();i++){\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tsum[i][j] = sum[i-1][j] + (str.charAt(i-1)-'a'==j?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tu = new boolean[n];\n\t\t\tfor(int i=0;i+len<=str.length();i++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(a[j]!=sum[i+len][j]-sum[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)continue;\n\t\t\t\tArrays.fill(u, false);\n\t\t\t\tv = new boolean[(1<<n)+1][len+1];\n\t\t\t\tif(match(0, str.substring(i, i+len), 0, 0))c++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] e = new String[n];\n\t\t\tfor(int i=0;i<n;i++)e[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString s = sb.toString();\n\t\t\tint N = s.length();\n\t\t\tList<boolean[]> l = new LinkedList<boolean[]>();\n\t\t\tboolean[] H = new boolean[1<<n];\n\t\t\tH[0] = true;\n\t\t\tl.add(H);\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\t\tf[0] = true;\n\t\t\t\tint sub = 0;\n\t\t\t\tboolean[] t = new boolean[n];\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint x = i-e[j].length()+1;\n\t\t\t\t\tif(x<0)continue;\n\t\t\t\t\tt[j] = s.startsWith(e[j], x);\n\t\t\t\t\tsub|=1<<j;\n\t\t\t\t}\n\t\t\t\tfor(int S=1;S<1<<n;S++){\n\t\t\t\t\tif((S&sub)==0)continue;\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(t[j]&&((S>>j)&1)>0){\n\t\t\t\t\t\t\tboolean[] p = l.get(l.size()-e[j].length());\n\t\t\t\t\t\t\tif(p[S-(1<<j)]){\n\t\t\t\t\t\t\t\tf[S] = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[(1<<n)-1])res++;\n\t\t\t\tl.add(f);\n\t\t\t\tif(20<l.size())l.remove(0);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tdouble p,e,t;\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\tString [] data = new String[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tdata[i] = sc.next();\n\t\t\t}\n\t\t\tStringBuilder str = new StringBuilder();\n\t\t\twhile(m-- > 0){\n\t\t\t\tString s = sc.next();\n\t\t\t\tstr.append(s);\n\t\t\t}\n\t\t\tArrayList<HashSet<Integer>> matchind = new ArrayList<HashSet<Integer>>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmatchind.add(new HashSet<Integer>());\n\t\t\t}\n\t\t\tint len = str.length();\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(match(str, i, data[j])){\n\t\t\t\t\t\tmatchind.get(j).add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean [][] dp = new boolean[1 << n][len + 1];\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfor(int j = 0;j < n; j++){\n\t\t\t\t\tif(matchind.get(j).contains(i) == false) continue;\n\t\t\t\t\tdp[0][i] = true;\n\t\t\t\t\tfor(int k = 0; k < (1 << n); k++){\n\t\t\t\t\t\tif(dp[k][i] == false) continue;\n\t\t\t\t\t\tif((k & (1 << j)) > 0) continue;\n\t\t\t\t\t\tint nextbit = (k | (1 << j));\n\t\t\t\t\t\tint nexti = i + data[j].length();\n\t\t\t\t\t\t//debug(nextbit, nexti, i,j,k);\n\t\t\t\t\t\tdp[nextbit][nexti] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i <= len;i++){\n\t\t\t\tif(dp[(1 << n) - 1][i]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tprivate boolean match(StringBuilder str, int ind, String patt) {\n\t\tif(str.length() - ind < patt.length()){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0; i < patt.length(); i++){\n\t\t\tif(str.charAt(i +  ind) != patt.charAt(i)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tint n, m, len;\n\tString[] s;\n\tString str;\n\tint[] a;\n\tint[][] sum;\n\tboolean[] u;\n\t\n\tboolean match(int k, String t, int h){\n\t\tif(k==n)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tboolean f = true;\n\t\t\tfor(int j=0;j<s[i].length();j++){\n\t\t\t\tif(t.charAt(h+j)!=s[i].charAt(j)){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!u[i]&&f){\n\t\t\t\tu[i] = true;\n\t\t\t\tif(match(k+1, t, h+s[i].length()))return true;\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\ts = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0;i<m;i++)sb.append(sc.next());\n\t\t\tstr = sb.toString();\n\t\t\tlen = 0;\n\t\t\ta = new int[26];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlen += s[i].length();\n\t\t\t\tfor(char ch:s[i].toCharArray())a[ch-'a']++;\n\t\t\t}\n\t\t\tsum = new int[str.length()+1][26];\n\t\t\tfor(int i=1;i<=str.length();i++){\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tsum[i][j] = sum[i-1][j] + (str.charAt(i-1)-'a'==j?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tu = new boolean[n];\n\t\t\tfor(int i=0;i+len<=str.length();i++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(a[j]!=sum[i+len][j]-sum[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)continue;\n\t\t\t\tArrays.fill(u, false);\n\t\t\t\tif(match(0, str.substring(i, i+len), 0))c++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tString in[] = new String[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = sc.next();\n\t\t\t}\n\n\t\t\tString buffer = \"\";\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tbuffer += sc.next();\n\t\t\t}\n\t\t\tint len = buffer.length();\n\n\t\t\tboolean[][] ans = new boolean[1 << n][len + 100];\n\t\t\tArrays.fill(ans[0],true);\n\t\t\tlong res = 0;\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (buffer.startsWith(in[i])) {\n\t\t\t\t\t\tfor (int k = 0; k < 1 << n; k++) {\n\t\t\t\t\t\t\tif (!ans[k][j]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint shi = 1 << i;\n\t\t\t\t\t\t\tif ((k & shi) != 0) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(ans[k|shi][j+in[i].length()]){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans[k | shi][j + in[i].length()] = ans[k][j];\n\t\t\t\t\t\t\tif ((k | shi) == (1 << n) - 1) {\n//\t\t\t\t\t\t\t\tSystem.out.println(j);\n\t\t\t\t\t\t\t\tres++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tbuffer = buffer.substring(1);\n//\t\t\t\tSystem.out.println(buffer);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] e = new String[n];\n\t\t\tfor(int i=0;i<n;i++)e[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString s = sb.toString();\n\t\t\tint N = s.length();\n\t\t\tList<boolean[]> l = new LinkedList<boolean[]>();\n\t\t\tboolean[] H = new boolean[1<<n];\n\t\t\tH[0] = true;\n\t\t\tl.add(H);\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\t\tf[0] = true;\n\t\t\t\tboolean[] t = new boolean[n];\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint x = i-e[j].length()+1;\n\t\t\t\t\tif(x<0)continue;\n\t\t\t\t\tt[j] = s.startsWith(e[j], x);\n\t\t\t\t}\n\t\t\t\tfor(int S=1;S<1<<n;S++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(t[j]&&((S>>j)&1)>0){\n\t\t\t\t\t\t\tboolean[] p = l.get(l.size()-e[j].length());\n\t\t\t\t\t\t\tif(p[S-(1<<j)]){\n\t\t\t\t\t\t\t\tf[S] = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[(1<<n)-1])res++;\n\t\t\t\tl.add(f);\n\t\t\t\tif(20<l.size())l.remove(0);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\t\n\tlong modpow(long x, long n, long M){\n\t\tlong res = 1;\n\t\twhile(n>0){\n\t\t\tif((n&1)>0)res = res*x%M;\n\t\t\tx = x*x%M;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\t\n//\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong P = 107, MOD = 1000000000;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] e = new String[n];\n\t\t\tfor(int i=0;i<n;i++)e[i]=sc.next();\n\t\t\tlong[] h = new long[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tlong H = 0, L = e[j].length();\n\t\t\t\tfor(int i=0;i<L;i++)H=(H*P+e[j].charAt(i))%MOD;\n\t\t\t\th[j] = H;\n\t\t\t}\n//\t\t\tdebug(h);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString s = sb.toString();\n\t\t\tint N = s.length();\n\t\t\tboolean[][] t = new boolean[N][n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint L = e[j].length();\n\t\t\t\tif(N<L)continue;\n\t\t\t\tlong H = 0;\n\t\t\t\tfor(int i=0;i<L;i++)H=(H*P+s.charAt(i))%MOD;\n//\t\t\t\tSystem.out.println(H+\" \"+h[j]);\n\t\t\t\tif(h[j]==H&&s.startsWith(e[j]))t[L-1][j] = true;\n\t\t\t\tfor(int i=L;i<N;i++){\n\t\t\t\t\tH = (H-(s.charAt(i-L)*modpow(P, L-1, MOD))%MOD+MOD)%MOD;\n\t\t\t\t\tH = (H*P+s.charAt(i))%MOD;\n\t\t\t\t\tif(h[j]==H&&s.startsWith(e[j], i-L+1))t[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int j=0;j<n;j++)for(int i=0;i<N;i++)if(t[i][j])System.out.println(e[j]+\" at \"+(i-e[j].length()+1));\n//\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<n;j++){\n//\t\t\t\tif(s.startsWith(e[j], i))t[i+e[j].length()-1][j] = true;\n//\t\t\t}\n\t\t\tList<boolean[]> l = new LinkedList<boolean[]>();\n\t\t\tboolean[] H = new boolean[1<<n];\n\t\t\tH[0] = true;\n\t\t\tl.add(H);\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\t\tf[0] = true;\n\t\t\t\tfor(int S=1;S<1<<n;S++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(t[i][j]&&((S>>j)&1)>0){\n\t\t\t\t\t\t\tboolean[] p = l.get(l.size()-e[j].length());\n\t\t\t\t\t\t\tif(p[S-(1<<j)]){\n\t\t\t\t\t\t\t\tf[S] = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[(1<<n)-1])res++;\n\t\t\t\tl.add(f);\n\t\t\t\tif(20<l.size())l.remove(0);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] e = new String[n];\n\t\t\tfor(int i=0;i<n;i++)e[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString s = sb.toString();\n\t\t\tint N = s.length();\n\t\t\tList<boolean[]> l = new LinkedList<boolean[]>();\n\t\t\tboolean[] H = new boolean[1<<n];\n\t\t\tH[0] = true;\n\t\t\tl.add(H);\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\t\tf[0] = true;\n\t\t\t\tint sub = 0;\n\t\t\t\tboolean[] t = new boolean[n];\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint x = i-e[j].length()+1;\n\t\t\t\t\tif(x<0)continue;\n\t\t\t\t\tt[j] = s.startsWith(e[j], x);\n\t\t\t\t\tsub+=1<<j;\n\t\t\t\t}\n\t\t\t\tfor(int S=1;S<1<<n;S++){\n\t\t\t\t\tif((S&sub)==0)continue;\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(t[j]&&((S>>j)&1)>0){\n\t\t\t\t\t\t\tboolean[] p = l.get(l.size()-e[j].length());\n\t\t\t\t\t\t\tif(p[S-(1<<j)]){\n\t\t\t\t\t\t\t\tf[S] = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[(1<<n)-1])res++;\n\t\t\t\tl.add(f);\n\t\t\t\tif(20<l.size())l.remove(0);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\t\n\tlong modpow(long x, long n, long M){\n\t\tlong res = 1;\n\t\twhile(n>0){\n\t\t\tif((n&1)>0)res = res*x%M;\n\t\t\tx = x*x%M;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\t\n//\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong P = 107, MOD = 1000000000;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] e = new String[n];\n\t\t\tfor(int i=0;i<n;i++)e[i]=sc.next();\n\t\t\tlong[] h = new long[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tlong H = 0, L = e[j].length();\n\t\t\t\tfor(int i=0;i<L;i++)H=(H*P+e[j].charAt(i))%MOD;\n\t\t\t\th[j] = H;\n\t\t\t}\n\t\t\tlong[] pow = new long[21];\n\t\t\tfor(int i=0;i<21;i++)pow[i]=modpow(P, i, MOD);\n//\t\t\tdebug(h);\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString s = sb.toString();\n\t\t\tint N = s.length();\n\t\t\tboolean[][] t = new boolean[N][n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint L = e[j].length();\n\t\t\t\tif(N<L)continue;\n\t\t\t\tlong H = 0;\n\t\t\t\tfor(int i=0;i<L;i++)H=(H*P+s.charAt(i))%MOD;\n//\t\t\t\tSystem.out.println(H+\" \"+h[j]);\n\t\t\t\tif(h[j]==H&&s.startsWith(e[j]))t[L-1][j] = true;\n\t\t\t\tfor(int i=L;i<N;i++){\n\t\t\t\t\tH = (H-(s.charAt(i-L)*pow[L-1])%MOD+MOD)%MOD;\n\t\t\t\t\tH = (H*P+s.charAt(i))%MOD;\n\t\t\t\t\tif(h[j]==H&&s.startsWith(e[j], i-L+1))t[i][j]=true;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int j=0;j<n;j++)for(int i=0;i<N;i++)if(t[i][j])System.out.println(e[j]+\" at \"+(i-e[j].length()+1));\n//\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<n;j++){\n//\t\t\t\tif(s.startsWith(e[j], i))t[i+e[j].length()-1][j] = true;\n//\t\t\t}\n\t\t\tList<boolean[]> l = new LinkedList<boolean[]>();\n\t\t\tboolean[] H = new boolean[1<<n];\n\t\t\tH[0] = true;\n\t\t\tl.add(H);\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\t\tf[0] = true;\n\t\t\t\tfor(int S=1;S<1<<n;S++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(t[i][j]&&((S>>j)&1)>0){\n\t\t\t\t\t\t\tboolean[] p = l.get(l.size()-e[j].length());\n\t\t\t\t\t\t\tif(p[S-(1<<j)]){\n\t\t\t\t\t\t\t\tf[S] = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[(1<<n)-1])res++;\n\t\t\t\tl.add(f);\n\t\t\t\tif(20<l.size())l.remove(0);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tint n, m, len;\n\tString[] s;\n\tString str;\n\tint[] a;\n\tint[][] sum;\n\tboolean[] u;\n\tboolean[][] v;\n\t\n\tboolean match(int k, String t, int h, int x){\n\t\tif(k==n)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tint nx = x | (1<<i);\n\t\t\tif(v[nx][h+s[i].length()-1])continue;\n\t\t\tboolean f = true;\n\t\t\tfor(int j=0;j<s[i].length();j++){\n\t\t\t\tif(t.charAt(h+j)!=s[i].charAt(j)){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!u[i]&&f){\n\t\t\t\tv[nx][h+s[i].length()-1] = true;\n\t\t\t\tu[i] = true;\n\t\t\t\tif(match(k+1, t, h+s[i].length(), nx))return true;\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\ts = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tArrays.sort(s, new Comparator<String>() {\n\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\treturn o2.length()-o1.length();\n\t\t\t\t}\n\t\t\t});\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0;i<m;i++)sb.append(sc.next());\n\t\t\tstr = sb.toString();\n\t\t\tlen = 0;\n\t\t\ta = new int[26];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlen += s[i].length();\n\t\t\t\tfor(char ch:s[i].toCharArray())a[ch-'a']++;\n\t\t\t}\n\t\t\tsum = new int[str.length()+1][26];\n\t\t\tfor(int i=1;i<=str.length();i++){\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tsum[i][j] = sum[i-1][j] + (str.charAt(i-1)-'a'==j?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tu = new boolean[n];\n\t\t\tfor(int i=0;i+len<=str.length();i++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(a[j]!=sum[i+len][j]-sum[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)continue;\n\t\t\t\tArrays.fill(u, false);\n\t\t\t\tv = new boolean[(1<<n)+1][len+1];\n\t\t\t\tif(match(0, str.substring(i, i+len), 0, 0))c++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tint n, m, len;\n\tString[] s;\n\tString str;\n\tint[] a;\n\tint[][] sum;\n\tboolean[] u;\n\tboolean[][] v;\n\t\n\tboolean match(int k, String t, int h, int x){\n\t\tif(k==n)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint nx = x | (1<<i);\n\t\t\tif(v[nx][h+s[i].length()-1])continue;\n\t\t\tboolean f = t.startsWith(s[i]);\n//\t\t\tfor(int j=0;j<s[i].length();j++){\n//\t\t\t\tif(t.charAt(h+j)!=s[i].charAt(j)){\n//\t\t\t\t\tf = false;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tif(!u[i]&&f){\n\t\t\t\tv[nx][h+s[i].length()-1] = true;\n\t\t\t\tu[i] = true;\n\t\t\t\tif(match(k+1, t.substring(s[i].length()), h+s[i].length(), nx))return true;\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\ts = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0;i<m;i++)sb.append(sc.next());\n\t\t\tstr = sb.toString();\n\t\t\tlen = 0;\n\t\t\ta = new int[26];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlen += s[i].length();\n\t\t\t\tfor(char ch:s[i].toCharArray())a[ch-'a']++;\n\t\t\t}\n\t\t\tsum = new int[str.length()+1][26];\n\t\t\tfor(int i=1;i<=str.length();i++){\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tsum[i][j] = sum[i-1][j] + (str.charAt(i-1)-'a'==j?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tu = new boolean[n];\n\t\t\tfor(int i=0;i+len<=str.length();i++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(a[j]!=sum[i+len][j]-sum[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)continue;\n\t\t\t\tArrays.fill(u, false);\n\t\t\t\tv = new boolean[(1<<n)+1][len+1];\n\t\t\t\tif(match(0, str.substring(i, i+len), 0, 0))c++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] e = new String[n];\n\t\t\tfor(int i=0;i<n;i++)e[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString s = sb.toString();\n\t\t\tint N = s.length();\n\t\t\tboolean[][] t = new boolean[N][n];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(s.startsWith(e[j], i))t[i+e[j].length()-1][j] = true;\n\t\t\t}\n\t\t\tList<boolean[]> l = new LinkedList<boolean[]>();\n\t\t\tboolean[] H = new boolean[1<<n];\n\t\t\tH[0] = true;\n\t\t\tl.add(H);\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\t\tf[0] = true;\n\t\t\t\tfor(int S=1;S<1<<n;S++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(t[i][j]&&((S>>j)&1)>0){\n\t\t\t\t\t\t\tboolean[] p = l.get(l.size()-e[j].length());\n\t\t\t\t\t\t\tif(p[S-(1<<j)]){\n\t\t\t\t\t\t\t\tf[S] = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[(1<<n)-1])res++;\n\t\t\t\tl.add(f);\n\t\t\t\tif(20<l.size())l.remove(0);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tbyte[][] e = new byte[5000][1<<12];\n\t\tboolean[][] f = new boolean[5000][12];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] s = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString t = sb.toString();\n\t\t\tint N = t.length();\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<1<<n;j++)e[i][j]=0;\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tString sub = t.substring(0, i);\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tf[i-1][j]=sub.endsWith(s[j]);\n\t\t\t\t\tif(f[i-1][j])e[i-1][1<<j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++)for(int S=0;S<1<<n;S++){\n\t\t\t\tif(e[i][S]==0)continue;\n\t\t\t\tif(S==(1<<n)-1)res++;\n\t\t\t\tfor(int j=0;j<n;j++)if(((S>>j)&1)==0){\n\t\t\t\t\tif(i+s[j].length()<N&&f[i+s[j].length()][j])e[i+s[j].length()][S|(1<<j)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tint n, m, len;\n\tString[] s;\n\tString str;\n\tint[] a;\n\tint[][] sum;\n\tboolean[] u;\n\tboolean[][] v;\n\t\n\tboolean match(int k, String t, int h, int x){\n\t\tif(k==n)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(u[i])continue;\n\t\t\tint nx = x | (1<<i);\n\t\t\tif(v[nx][h+s[i].length()-1])continue;\n\t\t\tboolean f = t.startsWith(s[i]);\n//\t\t\tfor(int j=0;j<s[i].length();j++){\n//\t\t\t\tif(t.charAt(h+j)!=s[i].charAt(j)){\n//\t\t\t\t\tf = false;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tif(!u[i]&&f){\n\t\t\t\tv[nx][h+s[i].length()-1] = true;\n\t\t\t\tu[i] = true;\n\t\t\t\tif(match(k+1, t.substring(s[i].length()), h+s[i].length(), nx))return true;\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\ts = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0;i<m;i++)sb.append(sc.next());\n\t\t\tstr = sb.toString();\n\t\t\tlen = 0;\n\t\t\ta = new int[26];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlen += s[i].length();\n\t\t\t\tfor(char ch:s[i].toCharArray())a[ch-'a']++;\n\t\t\t}\n\t\t\tsum = new int[str.length()+1][26];\n\t\t\tfor(int i=1;i<=str.length();i++){\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tsum[i][j] = sum[i-1][j] + (str.charAt(i-1)-'a'==j?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tu = new boolean[n];\n\t\t\tfor(int i=0;i+len<=str.length();i++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(a[j]!=sum[i+len][j]-sum[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)continue;\n\t\t\t\tArrays.fill(u, false);\n\t\t\t\tv = new boolean[(1<<n)+1][len+1];\n\t\t\t\tif(match(0, str.substring(i, i+len), 0, 0))c++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tint n, m, len;\n\tString[] s;\n\tString str;\n\tint[] a;\n\tint[][] sum;\n\tboolean[] u;\n\tboolean[][] v;\n\t\n\tboolean match(int k, String t, int h, int x){\n\t\tif(k==n)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint nx = x | (1<<i);\n\t\t\tif(v[nx][h+s[i].length()-1])continue;\n\t\t\tboolean f = true;\n\t\t\tfor(int j=0;j<s[i].length();j++){\n\t\t\t\tif(t.charAt(h+j)!=s[i].charAt(j)){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!u[i]&&f){\n\t\t\t\tv[nx][h+s[i].length()-1] = true;\n\t\t\t\tu[i] = true;\n\t\t\t\tif(match(k+1, t, h+s[i].length(), nx))return true;\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\ts = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0;i<m;i++)sb.append(sc.next());\n\t\t\tstr = sb.toString();\n\t\t\tlen = 0;\n\t\t\ta = new int[26];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlen += s[i].length();\n\t\t\t\tfor(char ch:s[i].toCharArray())a[ch-'a']++;\n\t\t\t}\n\t\t\tsum = new int[str.length()+1][26];\n\t\t\tfor(int i=1;i<=str.length();i++){\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tsum[i][j] = sum[i-1][j] + (str.charAt(i-1)-'a'==j?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tu = new boolean[n];\n\t\t\tfor(int i=0;i+len<=str.length();i++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(a[j]!=sum[i+len][j]-sum[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)continue;\n\t\t\t\tArrays.fill(u, false);\n\t\t\t\tv = new boolean[(1<<n)+1][len+1];\n\t\t\t\tif(match(0, str.substring(i, i+len), 0, 0))c++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tString[] e = new String[n];\n\t\t\tfor(int i=0;i<n;i++)e[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile(m--!=0)sb.append(sc.next());\n\t\t\tString s = sb.toString();\n\t\t\tint N = s.length();\n\t\t\tboolean[][] t = new boolean[N][n];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(s.startsWith(e[j], i))t[i+e[j].length()-1][j] = true;\n\t\t\t}\n\t\t\tList<boolean[]> l = new LinkedList<boolean[]>();\n\t\t\tboolean[] H = new boolean[1<<n];\n\t\t\tH[0] = true;\n\t\t\tl.add(H);\n\t\t\tint res = 0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tboolean[] f = new boolean[1<<n];\n\t\t\t\tf[0] = true;\n\t\t\t\tfor(int S=1;S<1<<n;S++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(t[i][j]&&((S>>j)&1)>0){\n\t\t\t\t\t\t\tboolean[] p = l.get(l.size()-e[j].length());\n\t\t\t\t\t\t\tif(p[S-(1<<j)]){\n\t\t\t\t\t\t\t\tf[S] = true; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f[(1<<n)-1])res++;\n\t\t\t\tl.add(f);\n\t\t\t\tif(20<l.size())l.remove(0);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Search of Concatenated Strings\npublic class Main{\n\n\tint n, m, len;\n\tString[] s;\n\tString str;\n\tint[] a;\n\tint[][] sum;\n\tboolean[] u;\n\t\n\tboolean match(int k, String t){\n\t\tif(k==n)return true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!u[i]&&t.startsWith(s[i])){\n\t\t\t\tu[i] = true;\n\t\t\t\tif(match(k+1, t.substring(s[i].length())))return true;\n\t\t\t\tu[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\ts = new String[n];\n\t\t\tfor(int i=0;i<n;i++)s[i]=sc.next();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i=0;i<m;i++)sb.append(sc.next());\n\t\t\tstr = sb.toString();\n\t\t\tlen = 0;\n\t\t\ta = new int[26];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlen += s[i].length();\n\t\t\t\tfor(char ch:s[i].toCharArray())a[ch-'a']++;\n\t\t\t}\n\t\t\tsum = new int[str.length()+1][26];\n\t\t\tfor(int i=1;i<=str.length();i++){\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tsum[i][j] = sum[i-1][j] + (str.charAt(i-1)-'a'==j?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tu = new boolean[n];\n\t\t\tfor(int i=0;i+len<=str.length();i++){\n\t\t\t\tboolean f = true;\n\t\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\t\tif(a[j]!=sum[i+len][j]-sum[i][j]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f)continue;\n\t\t\t\tArrays.fill(u, false);\n\t\t\t\tif(match(0, str.substring(i, i+len)))c++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef check(pos, k)\n  return true if k >= $n\n  return false if pos >= $tlen\n\n  for i in (0...$n)\n    if ! $used[i] && $ehashs[i][pos]\n      $used[i] = true\n      tf = check(pos + $elens[i], k + 1)\n      $used[i] = false\n\n      return true if tf\n    end\n  end\n  \n  false\nend\n\n### main\n\nloop do\n  $n, m = gets.split.map(&:to_i)\n  break if ($n | m) == 0\n\n  elms = $n.times.map{gets.strip}\n  $elens = elms.map{|elm| elm.length}\n  #p elms\n\n  text = ''\n  m.times.each{text += gets.strip}\n  $tlen = text.length\n  #p text\n\n  $ehashs = $n.times.map{{}}\n\n  for i in (0...$n)\n    elmi = elms[i]\n    eleni = $elens[i]\n    for j in (0...$tlen)\n      $ehashs[i][j] = true if text[j, eleni] == elmi\n    end\n  end\n  #p $ehashs\n\n  $used = $n.times.map{false}\n  count = 0\n  \n  for pos in (0...$tlen)\n    count += 1 if check(pos, 0)\n  end\n\n  puts count\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        a = sorted([S() for _ in range(n)])\n        ak = collections.Counter(''.join(a))\n        al = sum(ak.values())\n        t = ''.join([S() for _ in range(m)])\n        if len(t) < al:\n            return 0\n\n        fm = {}\n        def ff(s, a):\n            if len(a) == 1:\n                return s == a[0]\n            key = (s, tuple(a))\n            if key in fm:\n                return fm[key]\n            for i in range(len(a)):\n                if s[:len(a[i])] != a[i]:\n                    continue\n                if ff(s[len(a[i]):], a[:i] + a[i+1:]):\n                    fm[key] = True\n                    return True\n            fm[key] = False\n            return False\n\n        r = 0\n        for i in range(len(t) - al + 1):\n            ts = t[i:i+al]\n            if collections.Counter(ts) != ak:\n                continue\n            if ff(ts, a):\n                r += 1\n\n        return r\n\n    while 1:\n        n,m = LI()\n        if n == 0:\n            break\n        rr.append(f(n,m))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef solve():\n    N, M = map(int, readline().split())\n    if N == M == 0:\n        return False\n    ca = ord('a')\n    E = [list(map(lambda x: ord(x)-ca, readline().strip())) for i in range(N)]\n    F = \"\".join(readline().strip() for i in range(M))\n    L = sum(map(len, E))\n    MOD = 10**9 + 9; base = 37\n    ALL = (1 << N) - 1; bALL = (1 << (1 << N)) - 1\n    pw = [1]*(L+1)\n    for i in range(L):\n        pw[i+1] = pw[i] * base % MOD\n    V = [0]*N; P = [0]*N; K = [0]*N\n    S = [0]*N\n    for i in range(N):\n        v = 0\n        for c in E[i]:\n            v = (v * base + c) % MOD\n        V[i] = v\n        K[i] = len(E[i])\n        P[i] = pw[K[i]]\n        r = bALL\n        for s in range(ALL + 1):\n            if s & (1 << i):\n                r ^= 1 << s\n        S[i] = r\n\n    A = len(F)\n    dp = [1] * (A+1)\n    H = [0]*(A+1)\n    ans = s = 0\n    for i in range(A):\n        H[i+1] = s = (s * base + (ord(F[i]) - ca)) % MOD\n        r = 1\n        for j in range(N):\n            if K[j] <= i+1 and (s - H[i+1 - K[j]] * P[j]) % MOD == V[j]:\n                r |= (dp[i+1 - K[j]] & S[j]) << (1 << j)\n        dp[i+1] = r\n        if r & (1 << ALL):\n            ans += 1\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  }
]