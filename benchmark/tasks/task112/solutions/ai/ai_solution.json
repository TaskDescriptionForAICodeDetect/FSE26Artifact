[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n\ntypedef struct {\n    int adjacency[MAX_STATIONS][MAX_STATIONS];\n    int num_stations;\n} Graph;\n\nvoid initializeGraph(Graph *g, int num_stations) {\n    g->num_stations = num_stations;\n    for (int i = 0; i < num_stations; ++i) {\n        for (int j = 0; j < num_stations; ++j) {\n            g->adjacency[i][j] = (i == j) ? 0 : INT_MAX;\n        }\n    }\n}\n\nvoid addConnection(Graph *g, int src, int dest) {\n    g->adjacency[src][dest] = 1;\n    g->adjacency[dest][src] = 1;\n}\n\nvoid floydWarshall(Graph *g) {\n    for (int k = 0; k < g->num_stations; ++k) {\n        for (int i = 0; i < g->num_stations; ++i) {\n            for (int j = 0; j < g->num_stations; ++j) {\n                if (g->adjacency[i][k] != INT_MAX && g->adjacency[k][j] != INT_MAX &&\n                    g->adjacency[i][j] > g->adjacency[i][k] + g->adjacency[k][j]) {\n                    g->adjacency[i][j] = g->adjacency[i][k] + g->adjacency[k][j];\n                }\n            }\n        }\n    }\n}\n\nint canTravel(Graph *g, int src, int dest, int max_intermediate) {\n    if (src < 0 || src >= g->num_stations || dest < 0 || dest >= g->num_stations) {\n        return 0;\n    }\n    if (g->adjacency[src][dest] == INT_MAX) {\n        return 0;\n    }\n    int stops = g->adjacency[src][dest] - 1;\n    return stops <= max_intermediate;\n}\n\nint main() {\n    int num_stations, num_connections;\n    scanf(\"%d %d\", &num_stations, &num_connections);\n\n    Graph g;\n    initializeGraph(&g, num_stations);\n\n    for (int i = 0; i < num_connections; ++i) {\n        int src, dest;\n        scanf(\"%d %d\", &src, &dest);\n        addConnection(&g, src, dest);\n    }\n\n    floydWarshall(&g);\n\n    int src, dest, max_intermediate;\n    scanf(\"%d %d %d\", &src, &dest, &max_intermediate);\n\n    if (canTravel(&g, src, dest, max_intermediate)) {\n        printf(\"1\\n\");\n    } else {\n        printf(\"0\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass TrainJourneyPlanner {\n    private Map<String, List<String>> adjacencyList;\n\n    public TrainJourneyPlanner() {\n        adjacencyList = new HashMap<>();\n    }\n\n    public void addConnection(String from, String to) {\n        adjacencyList.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\n        adjacencyList.computeIfAbsent(to, k -> new ArrayList<>());\n    }\n\n    public boolean canReachDestination(String start, String destination) {\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        \n        queue.offer(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n\n            if (current.equals(destination)) {\n                return true;\n            }\n\n            for (String neighbor : adjacencyList.getOrDefault(current, new ArrayList<>())) {\n                if (!visited.contains(neighbor)) {\n                    queue.offer(neighbor);\n                    visited.add(neighbor);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public List<String> findShortestRoute(String start, String destination) {\n        Map<String, String> parentMap = new HashMap<>();\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        \n        queue.offer(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n\n            if (current.equals(destination)) {\n                return reconstructPath(parentMap, start, destination);\n            }\n\n            for (String neighbor : adjacencyList.getOrDefault(current, new ArrayList<>())) {\n                if (!visited.contains(neighbor)) {\n                    queue.offer(neighbor);\n                    visited.add(neighbor);\n                    parentMap.put(neighbor, current);\n                }\n            }\n        }\n\n        return new ArrayList<>();\n    }\n\n    private List<String> reconstructPath(Map<String, String> parentMap, String start, String destination) {\n        List<String> path = new ArrayList<>();\n        String current = destination;\n\n        while (current != null) {\n            path.add(0, current);\n            current = parentMap.get(current);\n            \n            if (current != null && current.equals(start)) {\n                path.add(0, start);\n                break;\n            }\n        }\n\n        return path;\n    }\n\n    public static void main(String[] args) {\n        TrainJourneyPlanner planner = new TrainJourneyPlanner();\n        \n        // Example network connections\n        planner.addConnection(\"A\", \"B\");\n        planner.addConnection(\"B\", \"C\");\n        planner.addConnection(\"C\", \"D\");\n        planner.addConnection(\"A\", \"D\");\n        \n        // Test journey possibility\n        boolean canReach = planner.canReachDestination(\"A\", \"D\");\n        System.out.println(\"Can reach destination: \" + canReach);\n        \n        // Find shortest route\n        List<String> shortestRoute = planner.findShortestRoute(\"A\", \"D\");\n        System.out.println(\"Shortest Route: \" + shortestRoute);\n    }\n}",
    "timestamp": "2025-08-05 18:40:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> buildGraph(int n, const vector<pair<int, int>>& edges) {\n    vector<vector<int>> graph(n + 1);\n    for (const auto& edge : edges) {\n        graph[edge.first].push_back(edge.second);\n    }\n    return graph;\n}\n\nvector<int> bfsShortestPath(const vector<vector<int>>& graph, int start, int n) {\n    vector<int> dist(n + 1, INT_MAX);\n    queue<int> q;\n    dist[start] = 0;\n    q.push(start);\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : graph[u]) {\n            if (dist[v] == INT_MAX) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist;\n}\n\nbool canTravel(int start, int end, const vector<int>& dist, int maxStops) {\n    return dist[end] != INT_MAX && dist[end] <= maxStops;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n    \n    int tickets;\n    cin >> tickets;\n    vector<pair<pair<int, int>, int>> ticketInfo(tickets);\n    for (int i = 0; i < tickets; ++i) {\n        cin >> ticketInfo[i].first.first >> ticketInfo[i].first.second >> ticketInfo[i].second;\n    }\n    \n    int queries;\n    cin >> queries;\n    while (queries--) {\n        int start, end;\n        cin >> start >> end;\n        \n        bool possible = false;\n        for (const auto& ticket : ticketInfo) {\n            int boarding = ticket.first.first;\n            int destination = ticket.first.second;\n            int maxStops = ticket.second;\n            \n            auto graph = buildGraph(n, edges);\n            auto distFromBoarding = bfsShortestPath(graph, boarding, n);\n            \n            if (canTravel(start, boarding, distFromBoarding, maxStops)) {\n                auto distFromDest = bfsShortestPath(graph, destination, n);\n                if (canTravel(destination, end, distFromDest, maxStops)) {\n                    possible = true;\n                    break;\n                }\n            }\n        }\n        cout << (possible ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n#define INFINITY INT_MAX\n\ntypedef struct {\n    int adjacency[MAX_STATIONS][MAX_STATIONS];\n    int num_stations;\n} RailNetwork;\n\nvoid initialize_network(RailNetwork* network) {\n    for (int i = 0; i < MAX_STATIONS; i++) {\n        for (int j = 0; j < MAX_STATIONS; j++) {\n            network->adjacency[i][j] = INFINITY;\n        }\n    }\n    network->num_stations = 0;\n}\n\nvoid add_connection(RailNetwork* network, int from, int to) {\n    network->adjacency[from][to] = 1;\n    network->num_stations = (from > network->num_stations) ? from + 1 : network->num_stations;\n    network->num_stations = (to > network->num_stations) ? to + 1 : network->num_stations;\n}\n\nbool can_reach_destination(RailNetwork* network, int start, int end, int* intermediate_stops, int num_intermediate) {\n    bool visited[MAX_STATIONS] = {false};\n    int current_path[MAX_STATIONS];\n    int path_length = 0;\n\n    current_path[path_length++] = start;\n    visited[start] = true;\n\n    int current = start;\n    while (current != end) {\n        bool found_next = false;\n        for (int next = 0; next < network->num_stations; next++) {\n            if (network->adjacency[current][next] != INFINITY && !visited[next]) {\n                current_path[path_length++] = next;\n                visited[next] = true;\n                current = next;\n                found_next = true;\n                break;\n            }\n        }\n\n        if (!found_next) {\n            return false;\n        }\n    }\n\n    if (current != end) {\n        return false;\n    }\n\n    if (num_intermediate > 0) {\n        for (int i = 0; i < num_intermediate; i++) {\n            bool stop_found = false;\n            for (int j = 0; j < path_length; j++) {\n                if (current_path[j] == intermediate_stops[i]) {\n                    stop_found = true;\n                    break;\n                }\n            }\n            if (!stop_found) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    RailNetwork network;\n    initialize_network(&network);\n\n    add_connection(&network, 0, 1);\n    add_connection(&network, 1, 2);\n    add_connection(&network, 2, 3);\n    add_connection(&network, 1, 3);\n\n    int intermediate_stops[] = {1};\n    bool journey_possible = can_reach_destination(&network, 0, 3, intermediate_stops, 1);\n\n    printf(\"Journey possible: %s\\n\", journey_possible ? \"Yes\" : \"No\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:40:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <limits>\n\nclass RailNetwork {\nprivate:\n    std::unordered_map<std::string, std::vector<std::pair<std::string, int>>> adjacencyList;\n\npublic:\n    void addConnection(const std::string& from, const std::string& to, int distance) {\n        adjacencyList[from].push_back({to, distance});\n        adjacencyList[to].push_back({from, distance});\n    }\n\n    bool canReachDestination(const std::string& start, const std::string& end, int maxStops) {\n        std::unordered_map<std::string, int> distances;\n        std::unordered_map<std::string, int> stops;\n        std::priority_queue<std::pair<int, std::string>, std::vector<std::pair<int, std::string>>, std::greater<>> pq;\n\n        for (const auto& station : adjacencyList) {\n            distances[station.first] = std::numeric_limits<int>::max();\n            stops[station.first] = std::numeric_limits<int>::max();\n        }\n\n        distances[start] = 0;\n        stops[start] = 0;\n        pq.push({0, start});\n\n        while (!pq.empty()) {\n            auto [currentDistance, currentStation] = pq.top();\n            pq.pop();\n\n            if (currentStation == end) return true;\n            if (stops[currentStation] > maxStops) continue;\n\n            for (const auto& [nextStation, edgeDistance] : adjacencyList[currentStation]) {\n                int newDistance = currentDistance + edgeDistance;\n                int newStops = stops[currentStation] + 1;\n\n                if (newDistance < distances[nextStation] && newStops <= maxStops) {\n                    distances[nextStation] = newDistance;\n                    stops[nextStation] = newStops;\n                    pq.push({newDistance, nextStation});\n                }\n            }\n        }\n\n        return false;\n    }\n};\n\nint main() {\n    RailNetwork network;\n\n    // Example network construction\n    network.addConnection(\"A\", \"B\", 5);\n    network.addConnection(\"B\", \"C\", 3);\n    network.addConnection(\"A\", \"D\", 7);\n    network.addConnection(\"D\", \"C\", 2);\n\n    std::string start = \"A\";\n    std::string end = \"C\";\n    int maxStops = 2;\n\n    bool canTravel = network.canReachDestination(start, end, maxStops);\n    std::cout << (canTravel ? \"Journey possible\" : \"Journey not possible\") << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:41:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TrainJourney {\n    private Map<String, List<String>> graph;\n\n    public TrainJourney() {\n        this.graph = new HashMap<>();\n    }\n\n    public void addConnection(String from, String to) {\n        graph.putIfAbsent(from, new ArrayList<>());\n        graph.get(from).add(to);\n    }\n\n    public boolean canTravel(String boarding, String destination, int maxStops) {\n        if (!graph.containsKey(boarding) || !graph.containsKey(destination)) {\n            return false;\n        }\n\n        Queue<String> queue = new LinkedList<>();\n        queue.add(boarding);\n        int stops = 0;\n        Set<String> visited = new HashSet<>();\n\n        while (!queue.isEmpty() && stops <= maxStops) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String current = queue.poll();\n                if (current.equals(destination)) {\n                    return true;\n                }\n                if (visited.contains(current)) {\n                    continue;\n                }\n                visited.add(current);\n                if (graph.containsKey(current)) {\n                    for (String neighbor : graph.get(current)) {\n                        if (!visited.contains(neighbor)) {\n                            queue.add(neighbor);\n                        }\n                    }\n                }\n            }\n            stops++;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        TrainJourney tj = new TrainJourney();\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n\n        for (int i = 0; i < n; i++) {\n            String[] parts = scanner.nextLine().split(\" \");\n            String from = parts[0];\n            String to = parts[1];\n            tj.addConnection(from, to);\n        }\n\n        String boarding = scanner.next();\n        String destination = scanner.next();\n        int maxStops = scanner.nextInt();\n\n        System.out.println(tj.canTravel(boarding, destination, maxStops) ? \"yes\" : \"no\");\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:41:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef can_travel(railroad_network, tickets, start, end):\n    # Build the graph\n    graph = defaultdict(list)\n    for (src, dst) in railroad_network:\n        graph[src].append(dst)\n        graph[dst].append(src)\n    \n    # BFS to find shortest path from start to end\n    def bfs_shortest_path(src, dst):\n        queue = deque([(src, [src])])\n        visited = set()\n        \n        while queue:\n            current_station, path = queue.popleft()\n            if current_station == dst:\n                return path\n            for neighbor in graph[current_station]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, path + [neighbor]))\n        return None\n\n    shortest_path = bfs_shortest_path(start, end)\n\n    if not shortest_path:\n        return False\n\n    # Check if the journey can be made with available tickets\n    for boarding, destination in tickets:\n        if boarding in shortest_path and destination in shortest_path:\n            start_idx = shortest_path.index(boarding)\n            end_idx = shortest_path.index(destination)\n            if start_idx <= end_idx and all(station in shortest_path for station in shortest_path[start_idx:end_idx+1]):\n                return True\n    \n    return False\n\n\n# Example usage\nrailroad_network = [\n    (\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"C\"), (\"C\", \"D\"), (\"D\", \"E\"), (\"E\", \"F\"), (\"B\", \"D\"), (\"C\", \"E\")\n]\ntickets = [\n    (\"A\", \"E\"), (\"B\", \"F\"), (\"A\", \"C\"), (\"D\", \"F\")\n]\nprint(can_travel(railroad_network, tickets, \"A\", \"E\"))  # True\nprint(can_travel(railroad_network, tickets, \"A\", \"F\"))  # False",
    "timestamp": "2025-08-13 00:29:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TrainJourney {\n    \n    static class Graph {\n        private final Map<String, List<String>> adjList = new HashMap<>();\n        \n        public void addEdge(String src, String dest) {\n            adjList.computeIfAbsent(src, k -> new ArrayList<>()).add(dest);\n            adjList.computeIfAbsent(dest, k -> new ArrayList<>()).add(src); // assuming undirected graph\n        }\n        \n        public boolean canTravel(String start, String end, Set<String> visited) {\n            if (start.equals(end)) {\n                return true;\n            }\n            \n            visited.add(start);\n            \n            if (adjList.containsKey(start)) {\n                for (String neighbor : adjList.get(start)) {\n                    if (!visited.contains(neighbor)) {\n                        if (canTravel(neighbor, end, visited)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    \n    public static boolean canMakeJourney(Graph graph, String boardingStation, String destination) {\n        return graph.canTravel(boardingStation, destination, new HashSet<>());\n    }\n    \n    public static void main(String[] args) {\n        Graph railwayGraph = new Graph();\n        railwayGraph.addEdge(\"A\", \"B\");\n        railwayGraph.addEdge(\"B\", \"C\");\n        railwayGraph.addEdge(\"C\", \"D\");\n        railwayGraph.addEdge(\"D\", \"E\");\n        \n        // Example: Check if journey can be made from \"A\" to \"E\"\n        String boarding = \"A\";\n        String destination = \"E\";\n        \n        if (canMakeJourney(railwayGraph, boarding, destination)) {\n            System.out.println(\"Journey can be made from \" + boarding + \" to \" + destination);\n        } else {\n            System.out.println(\"Journey cannot be made from \" + boarding + \" to \" + destination);\n        }\n    }\n}",
    "timestamp": "2025-08-13 00:29:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_STATIONS 100\n\n// Function prototypes\nint canMakeJourney(int stations, int graph[MAX_STATIONS][MAX_STATIONS], int start, int destination);\nvoid dijkstra(int stations, int graph[MAX_STATIONS][MAX_STATIONS], int start, int dist[]);\n\n// Main function\nint main() {\n    int stations;\n    int graph[MAX_STATIONS][MAX_STATIONS];\n    int start, destination;\n    \n    // Sample data - replace with actual input\n    stations = 5;\n    int connections[5][5] = {\n        {0, 10, 0, 0, 0},\n        {0, 0, 5, 0, 0},\n        {0, 0, 0, 2, 0},\n        {0, 0, 0, 0, 1},\n        {0, 0, 0, 0, 0}\n    };\n    \n    // Copy sample data to graph\n    for (int i = 0; i < stations; i++)\n        for (int j = 0; j < stations; j++)\n            graph[i][j] = connections[i][j];\n    \n    // Sample start and destination\n    start = 0;\n    destination = 4;\n    \n    if (canMakeJourney(stations, graph, start, destination)) {\n        printf(\"Journey is possible.\\n\");\n    } else {\n        printf(\"Journey is not possible.\\n\");\n    }\n    \n    return 0;\n}\n\n// Function to determine if a journey can be made\nint canMakeJourney(int stations, int graph[MAX_STATIONS][MAX_STATIONS], int start, int destination) {\n    int dist[MAX_STATIONS];\n    dijkstra(stations, graph, start, dist);\n    \n    if (dist[destination] == INT_MAX) {\n        return 0;\n    }\n    return 1;\n}\n\n// Dijkstra's Algorithm for shortest path\nvoid dijkstra(int stations, int graph[MAX_STATIONS][MAX_STATIONS], int start, int dist[]) {\n    int visited[MAX_STATIONS] = {0};\n    for (int i = 0; i < stations; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[start] = 0;\n    \n    for (int i = 0; i < stations - 1; i++) {\n        int minDist = INT_MAX;\n        int minIndex;\n        \n        for (int j = 0; j < stations; j++) {\n            if (!visited[j] && dist[j] < minDist) {\n                minDist = dist[j];\n                minIndex = j;\n            }\n        }\n        \n        visited[minIndex] = 1;\n        \n        for (int k = 0; k < stations; k++) {\n            if (!visited[k] && graph[minIndex][k] && dist[minIndex] != INT_MAX && dist[minIndex] + graph[minIndex][k] < dist[k]) {\n                dist[k] = dist[minIndex] + graph[minIndex][k];\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 00:29:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\nclass RailNetwork:\n    def __init__(self):\n        self.graph = defaultdict(list)\n    \n    def add_connection(self, start, end):\n        self.graph[start].append(end)\n        self.graph[end].append(start)\n    \n    def can_journey(self, start, end, ticket_start, ticket_end):\n        # Check if ticket covers the journey\n        if start != ticket_start or end != ticket_end:\n            return False\n        \n        # BFS to find if path exists\n        visited = set()\n        queue = deque([start])\n        visited.add(start)\n        \n        while queue:\n            current = queue.popleft()\n            \n            if current == end:\n                return True\n            \n            for neighbor in self.graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        return False\n\ndef main():\n    # Create railroad network\n    network = RailNetwork()\n    \n    # Add connections\n    network.add_connection('A', 'B')\n    network.add_connection('B', 'C')\n    network.add_connection('C', 'D')\n    network.add_connection('A', 'D')\n    \n    # Test journey\n    start = 'A'\n    end = 'D'\n    ticket_start = 'A'\n    ticket_end = 'D'\n    \n    result = network.can_journey(start, end, ticket_start, ticket_end)\n    print(f\"Journey possible: {result}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:29:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef can_travel(n, connections, tickets, start, end):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # BFS to find the shortest path from start to end\n    visited = set()\n    queue = deque()\n    queue.append((start, [start]))\n    visited.add(start)\n    \n    shortest_path = None\n    \n    while queue:\n        current, path = queue.popleft()\n        if current == end:\n            shortest_path = path\n            break\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, path + [neighbor]))\n    \n    if not shortest_path:\n        return False\n    \n    # Check each ticket to see if it covers any segment of the shortest path\n    for ticket in tickets:\n        boarding, destination = ticket\n        # Find the positions of boarding and destination in the shortest path\n        try:\n            idx_boarding = shortest_path.index(boarding)\n            idx_destination = shortest_path.index(destination)\n        except ValueError:\n            continue\n        \n        # Ensure boarding comes before destination in the path\n        if idx_boarding < idx_destination:\n            # Check if the segment from boarding to destination is contiguous\n            for i in range(idx_boarding, idx_destination):\n                if shortest_path[i+1] not in graph[shortest_path[i]]:\n                    break\n            else:\n                return True\n    \n    return False\n\n# Example usage:\n# n = 4\n# connections = [(1, 2), (2, 3), (3, 4)]\n# tickets = [(1, 3), (2, 4)]\n# start = 1\n# end = 4\n# print(can_travel(n, connections, tickets, start, end))  # Output: True",
    "timestamp": "2025-08-13 00:30:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <limits>\n\nclass TrainNetwork {\npublic:\n    void addConnection(const std::string& from, const std::string& to) {\n        connections[from].push_back(to);\n        connections[to].push_back(from);\n    }\n\n    bool canTravel(const std::string& start, const std::string& destination) {\n        if (start == destination) return true;\n\n        std::unordered_map<std::string, int> distances;\n        std::unordered_map<std::string, std::string> predecessors;\n        std::queue<std::string> toVisit;\n\n        for (auto& pair : connections) {\n            distances[pair.first] = std::numeric_limits<int>::max();\n        }\n\n        distances[start] = 0;\n        toVisit.push(start);\n\n        while (!toVisit.empty()) {\n            std::string current = toVisit.front();\n            toVisit.pop();\n\n            for (const std::string& neighbor : connections[current]) {\n                if (distances[current] + 1 < distances[neighbor]) {\n                    distances[neighbor] = distances[current] + 1;\n                    predecessors[neighbor] = current;\n                    toVisit.push(neighbor);\n                }\n            }\n        }\n\n        if (distances[destination] == std::numeric_limits<int>::max()) {\n            return false;\n        }\n\n        return true;\n    }\n\nprivate:\n    std::unordered_map<std::string, std::vector<std::string>> connections;\n};\n\nint main() {\n    TrainNetwork network;\n\n    // Sample connections\n    network.addConnection(\"A\", \"B\");\n    network.addConnection(\"B\", \"C\");\n    network.addConnection(\"C\", \"D\");\n    network.addConnection(\"A\", \"D\");\n\n    std::string start, destination;\n    std::cout << \"Enter start station: \";\n    std::cin >> start;\n    std::cout << \"Enter destination station: \";\n    std::cin >> destination;\n\n    if (network.canTravel(start, destination)) {\n        std::cout << \"Journey possible from \" << start << \" to \" << destination << \".\\n\";\n    } else {\n        std::cout << \"Journey not possible from \" << start << \" to \" << destination << \".\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:28"
  }
]