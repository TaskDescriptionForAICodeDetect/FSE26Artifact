[
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic vector<edge> G[100000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint a,b,q; scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n\tstatic int c[40000],d[40000];\n\trep(i,q) scanf(\"%d%d\",c+i,d+i), c[i]--, d[i]--;\n\n\t// calculate distances from a\n\tstatic int dist_a[100000];\n\trep(u,n) dist_a[u]=(u==a?0:INF);\n\tpriority_queue< pair<int,int> > Qa; Qa.push(make_pair(0,a));\n\twhile(!Qa.empty()){\n\t\tint d_now=-Qa.top().first,u=Qa.top().second; Qa.pop();\n\t\tif(d_now>dist_a[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_a[v]>dist_a[u]+cost){\n\t\t\t\tdist_a[v]=dist_a[u]+cost;\n\t\t\t\tQa.push(make_pair(-dist_a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// calculate distances from b\n\tstatic int dist_b[100000];\n\trep(u,n) dist_b[u]=(u==b?0:INF);\n\tpriority_queue< pair<int,int> > Qb; Qb.push(make_pair(0,b));\n\twhile(!Qb.empty()){\n\t\tint d_now=-Qb.top().first,u=Qb.top().second; Qb.pop();\n\t\tif(d_now>dist_b[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_b[v]>dist_b[u]+cost){\n\t\t\t\tdist_b[v]=dist_b[u]+cost;\n\t\t\t\tQb.push(make_pair(-dist_b[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// build the shortest path DAG from a to b\n\tstatic vector<int> H[100000];\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\tif(dist_a[u]+cost+dist_b[v]==dist_a[b]) H[u].push_back(v);\n\t}\n\n\t// find a topological order of H\n\tvector<int> top;\n\tstatic bool vis[100000];\n\tqueue<int> Q; Q.push(a);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\ttop.push_back(u);\n\t\trep(i,H[u].size()){\n\t\t\tint v=H[u][i];\n\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t}\n\t}\n// printf(\"n=%d, a=%d, b=%d: \",n,a,b);\n// rep(i,top.size()) printf(\"%d \",top[i]); puts(\"\");\n\n\t// query\n/*\n\trep(i,(q+63)/64){\n\t\tstatic ll dp[100000];\n\t\tmemset(dp,0,sizeof dp);\n\t\trep(j,64) if(64*i+j<q) dp[c[64*i+j]]|=1LL<<j;\n\t\trep(i,n){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tdp[v]|=dp[u];\n\t\t\t}\n\t\t}\n\t\trep(j,64) if(64*i+j<q) puts(dp[d[64*i+j]]&(1LL<<j)?\"Yes\":\"No\");\n\t}\n*/\n\t// naive\n\trep(i,q){\n\t\trep(u,n) vis[u]=false;\n\t\tvis[c[i]]=true;\n\t\trep(i,top.size()){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tvis[v]|=vis[u];\n\t\t\t}\n\t\t}\n/*\n\t\tQ.push(c[i]);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tvis[u]=true;\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n*/\n\t\tputs(vis[d[i]]?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost) {\n    if(start == goal) return true;\n\n    bool ok = false;\n\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight)) continue;\n\n        ok = true;\n        result[start].insert(e.to);\n    }\n\n    return ok;\n}\n\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0);\n\n    return result;\n}\n\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    result.push_back(current);\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    ts_dfs(result, edge, visited, start);\n    return result;\n}\n\n// const vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n//     vector<int> order;\n//     queue<int> q;\n//     vector<bool> visited(edge.size(), false);\n// \n//     for(q.push(start); !q.empty(); q.pop()) {\n//         int current = q.front();\n// \n//         if(visited[current]) continue;\n//         visited[current] = true;\n// \n//         order.push_back(current);\n//         for(const auto& to: edge[current]) q.push(to);\n//     }\n// \n//     return order;\n// }\n\nint main() {\n    struct Query {int begin, end;};\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query(Q);\n    for(auto& q: query) cin >> q.begin >> q.end;\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    for(const auto& q: query) {\n        vector<unsigned long long int> dp(S, 0);\n        dp[q.begin - 1] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        cout << (dp[q.end - 1] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x> >\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tstatic bool used0[100010];\n\trep(i,100010)used0[i]=used[i];\n\t\n\trep(ppp,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\tif(!used0[e]){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tstack<int> sta;\n\t\tsta.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!sta.empty()){\n\t\t\tint x=sta.top(); sta.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\trep(i,nG[x].size()){\n\t\t\t\tint nex=nG[x][i];\n\t\t\t\tif(!used[nex]){\n\t\t\t\t\tsta.push(nex);\n\t\t\t\t\tused[nex]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nstruct edge{int to,cost;\nedge(int to,int cost):to(to),cost(cost){}};\n\nint S,R;\nvector<edge> g1[100010],g2[100010];\nvi g3[100010];\nvector<pi> G;\nint a,b,nq;\nint dist[100010],used[100010];\npi distv[100010];\nll mask[100010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>S>>R;\n\trep(i,R){\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\tu--,v--;\n\t\tg1[u].pb(edge(v,w));\n\t\tg1[v].pb(edge(u,w));\n\t}\n\tcin>>a>>b>>nq;\n\ta--;b--;\n\t\n\tfill(dist,dist+S,INF);\n\tpriority_queue<pi,vector<pi>,greater<pi> > Q;\n\tdist[a]=0;\n\tQ.push(mp(0,a));\n\t\n\twhile(sz(Q)){\n\t\tpi p=Q.top();Q.pop();\n\t\tint v=p.sec;\n\t\tif(p.fir > dist[v])continue;\n\t\trep(i,sz(g1[v])){\n\t\t\tint w=g1[v][i].to;\n\t\t\tint nd=p.fir+g1[v][i].cost;\n\t\t\tif(nd < dist[w]){\n\t\t\t\tdist[w]=nd;\n\t\t\t\tQ.push(mp(nd,w));\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,S)rep(j,sz(g1[i])){\n\t\tif(dist[i]+g1[i][j].cost == dist[g1[i][j].to]){\n\t\t\tg2[g1[i][j].to].pb(edge(i,g1[i][j].cost));\n\t\t}\n\t}\n\t\n\tstack<int> T;\n\tT.push(b);\n\t\n\twhile(sz(T)){\n\t\tint v=T.top();T.pop();\n\t\tif(used[v])continue;\n\t\tused[v]=1;\n\t\trep(i,sz(g2[v])){\n\t\t\tint w=g2[v][i].to;\n\t\t\tif(dist[v] == dist[w]+g2[v][i].cost){\n\t\t\t\tg3[w].pb(v);\n\t\t\t\tT.push(w);\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,S)distv[i]=mp(dist[i],i);\n\tsort(distv,distv+S);\n\t\n\trep(i,S){\n\t\tint v=distv[i].sec;\n\t\trep(j,sz(g3[v])){\n\t\t\tG.pb(mp(v,g3[v][j]));\n\t\t}\n\t}\n\t\n\tint c,d;\n\tvector<pi> q;\n\trep(i,nq){\n\t\tcin>>c>>d;\n\t\tq.pb(mp(c-1,d-1));\n\t\tif(sz(q)==64 || i==nq-1){\n\t\t\tfill(mask,mask+S,0);\n\t\t\trep(j,sz(q)){\n\t\t\t\tmask[q[j].fir] |= 1LL<<j;\n\t\t\t}\n\t\t\trep(j,sz(G)){\n\t\t\t\tmask[G[j].sec] |= mask[G[j].fir];\n\t\t\t}\n\t\t\trep(j,sz(q)){\n\t\t\t\tcout<<(mask[q[j].sec] & 1LL<<j ? \"Yes\":\"No\")<<endl;\n\t\t\t}\n\t\t\tq.clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<int>& memo) {\n    if(start == goal) return true;\n    if(memo[start] != NIL) return true;\n    memo[start] = 0;\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n        memo[start] = 1;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<int> memo(edge.size(), NIL);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n// 幅優先だとダメ\n// const vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n//     vector<int> order;\n//     queue<int> q;\n//     vector<bool> visited(edge.size(), false);\n// \n//     for(q.push(start); !q.empty(); q.pop()) {\n//         int current = q.front();\n// \n//         if(visited[current]) continue;\n//         visited[current] = true;\n// \n//         order.push_back(current);\n//         for(const auto& to: edge[current]) q.push(to);\n//     }\n// \n//     return order;\n// }\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(int b, int e) :begin(b), end(e) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    for(int i = 0; i < Q; i += 1) {\n        vector<bitset<1>> dp(S, bitset<1>(0));\n        for(int j = 0; j < 1 && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        for(int j = 0; j < 1 && i + j < Q; ++j) cout << (dp[query[i + j].end][j] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\n\nvoid dfs(int v, vector<int> &topo)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i], topo);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (weight[x.to] < x.cost) continue;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tif (weight[TG[x.to][i].to] > x.cost + TG[x.to][i].cost){\n\t\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tqueue<int> q;\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> topo;\n\tfor (int i = 0; i < N; i++){\n\t\tif (!vis[i]) dfs(i, topo);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tmemset(accessable, 0, sizeof(accessable));\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<int>& memo) {\n    if(start == goal) return true;\n    if(memo[start] != NIL) return true;\n    memo[start] = 0;\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n        memo[start] = 1;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<int> memo(edge.size(), NIL);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n// 幅優先だとダメ\n// const vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n//     vector<int> order;\n//     queue<int> q;\n//     vector<bool> visited(edge.size(), false);\n// \n//     for(q.push(start); !q.empty(); q.pop()) {\n//         int current = q.front();\n// \n//         if(visited[current]) continue;\n//         visited[current] = true;\n// \n//         order.push_back(current);\n//         for(const auto& to: edge[current]) q.push(to);\n//     }\n// \n//     return order;\n// }\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(int b, int e) :begin(b), end(e) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    for(int i = 0; i < Q; i += 64) {\n        vector<bitset<64>> dp(S, bitset<64>(0));\n        for(int j = 0; j < 64 && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        for(int j = 0; j < 64 && i + j < Q; ++j) cout << (dp[query[i + j].end][j] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n    Edge(int t, int w) :to(t), weight(w) {}\n};\n\nvector<bool> memo;\nbool restore(vector<set<int>>& edge, const vector<set<int>>& previous, const int current, const int goal) {\n    if(current == goal) return true;\n    if(memo[current]) return true;\n    bool ok = false;\n    for(const auto& i: previous[current]) {\n        if(!restore(edge, previous, i, goal)) continue;\n        edge[i].insert(current);\n        ok = true;\n    }\n    return memo[current] = ok;\n}\n\nint main() {\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n\n    // Dijkstra\n    typedef tuple<int, int, int> Node;\n\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    vector<int> distance(S, INT_MAX);\n    vector<set<int>> previous(S);\n\n    for(q.emplace(0, a, a); !q.empty(); q.pop()) {\n        int cost, id, prev;\n        tie(cost, id, prev) = q.top();\n\n        if(distance[id] == cost) previous[id].insert(prev);\n        if(distance[id] <= cost) continue;\n        if(id != prev) previous[id] = {prev};\n        distance[id] = cost;\n\n        for(const auto& e: original[id]) q.emplace(cost + e.weight, e.to, id);\n    }\n\n    // DAG\n    vector<set<int>> edge(S);\n    memo.resize(S);\n    restore(edge, previous, b, a);\n\n    // topological sort\n    vector<int> order;\n    vector<bool> visited(S, false);\n    queue<int> q2;\n    q2.push(a);\n    while(!q2.empty()) {\n        int v = q2.front();\n        q2.pop();\n        if(visited[v]) continue;\n        visited[v] = true;\n        order.push_back(v);\n        for(const auto& i: edge[v]) q2.push(i);\n    }\n\n    // DP\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n\n        vector<unsigned long long int> dp(S, 0);\n        dp[c] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) {\n            dp[to] |= dp[from];\n        }\n        if(distance[b] == INT_MAX) cout << \"No\" << endl;\n        else                       cout << (dp[d] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int inf = 5 * 1e8;\nint s,r,a,b,q,c,d,u,v,w;\nvector<pii> g[100100];\nvector<int> ming[100100];\nint dis[100100];\nbool vis[100100];\n\nbool dfs(int now,int goal){\n  if(now == goal)return true;\n  if(vis[now])return false;\n  vis[now] = true;\n\n  rep(i,ming[now].size()){\n    if(dfs(ming[now][i],goal))return true;\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%d%d\",&s,&r);\n  rep(i,r){\n    scanf(\"%d%d%d\",&u,&v,&w); u--; v--;\n    g[u].push_back(pii(w,v));\n    g[v].push_back(pii(w,u));\n  }\n  \n  scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n  memset(dis,-1,sizeof(dis));\n  dis[a] = 0;\n  priority_queue<pii,vector<pii>,greater<pii> > que;\n  que.push(pii(0,a));\n\n  while(que.size()){\n    pii p = que.top(); que.pop();\n    int cost = p.first, pos = p.second;\n    if(dis[pos]<cost)continue;\n\n    rep(i,g[pos].size()){\n      int ncost = cost + g[pos][i].first, npos = g[pos][i].second;\n      if(dis[npos]< 0 || dis[npos] > ncost){\n\tdis[npos] = ncost;\n\tque.push(pii(ncost,npos));\n      }\n    }\n  }\n\n  memset(vis,0,sizeof(vis));\n  vis[b] = true;\n  queue<int> state;\n  state.push(b);\n\n  while(state.size()){\n    int p = state.front(); state.pop();\n\n    rep(i,g[p].size()){\n      int np = g[p][i].second, nc = g[p][i].first;\n      if(dis[p] == dis[np] + nc){\n\tming[p].push_back(np);\n\tming[np].push_back(p);\n\tif(!vis[np]){\n\t  state.push(np);\n\t  vis[np] = true;\n\t}\n      }\n    }\n  }\n\n  map<pii,bool> memo;\n  rep(i,q){\n    scanf(\"%d%d\",&c,&d); c--; d--;\n\n    bool f;\n    if(memo.find(pii(c,d))!=memo.end())f = memo[pii(c,d)];\n    else{\n      memset(vis,0,sizeof(vis));\n      memo[pii(c,d)] = f = dfs(c,d);\n    }\n\n    if(f)cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nbool visit(const vector<vi> &g, int v, vector<int> &order, vector<int> &color) {\n  color[v] = 1;\n  for(int e : g[v]) {\n    if (color[e] == 2) continue;\n    if (color[e] == 1) return false;\n    if (!visit(g, e, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(const vector<vi> &g, vector<int> &order) {\n  int n = g.size();\n  vector<int> color(n);\n  rep(u, n) if (!color[u] && !visit(g, u, order, color))\n    return false;\n  reverse(all(order));\n  return true;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint s, r; cin >> s >> r;\n\tint S, T, Q;\n\tvector<vi> g(s);\n\t{\n\t\tvi dist(s, inf), rdist(s, inf);\n\t\tvector<vector<pi>> e(s), re(s);\n\t\trep(i, r){\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\te[a].emplace_back(b, c);\n\t\t\tre[b].emplace_back(a, c);\n\t\t}\n\t\tcin >> S >> T >> Q; S--; T--;\n\t\t\n\t\tauto dij = [](int s, const vector<vector<pi>> &e, vi &dist){\n\t\t\tint n = e.size();\n\t\t\tpriority_queue<pi> q; q.emplace(0, s);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint c, d; tie(d, c) = q.top(); q.pop();\n\t\t\t\tif(dist[c] < -d) continue;\n\t\t\t\tdist[c] = -d;\n\t\t\t\tfor(pi p : e[c]){\n\t\t\t\t\tint nd = -d + p.second;\n\t\t\t\t\tif(dist[p.first] > nd){\n\t\t\t\t\t\tdist[p.first] = nd;\n\t\t\t\t\t\tq.emplace(-nd, p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdij(S, e, dist);\n\t\tdij(T, re, rdist);\n\t\t/*\n\t\tdbg(dist);\n\t\tdbg(rdist);\n\t\t*/\n\t\trep(i, s) for(pi p : e[i])\n\t\t\tif(dist[i] + p.second + rdist[p.first] == dist[T])\n\t\t\t\tg[i].pb(p.first);\n\t}\n\t//dbg(g);\n\tvi ord, rord(s);\n\ttopologicalSort(g, ord);\n\t//dbg(ord);\n\t\n\tvector<pi> in;\n\trep(it, Q){\n\t\tint a, b; cin >> a >> b; in.emplace_back(a - 1, b - 1);\n\t\tif(!(it == Q - 1 || in.size() == 64)) continue;\n\t\tvector<unsigned long long > f(s);\n\t\trep(i, in.size()) f[in[i].first] |= 1ull << i;\n\t\twhile(1){\n\t\t\tbool up = 0;\n\t\t\trep(i, s) for(int j : g[i]){\n\t\t\t\tif((f[j] | f[i]) != f[j]) { f[j] |= f[i]; up = 1; }\n\t\t\t}\n\t\t\tif(!up) break;\n\t\t}\n\t\trep(i, in.size()) cout << (f[in[i].second] >> i & 1 ? \"Yes\" : \"No\") << endl;\n\t\tin.clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\n#define INF (1 << 30)\n\nvector<P> edge[105000];\nint adist[105000], bdist[105000];\nint a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(int *dist, int x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tint d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(int i = 0;i < edge[from].size();i++){\n\t    int r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] < d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(int c, int d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(int i = 0;i < edge[c].size();i++){\n\tint r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(int i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(int i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"YES\" << endl;\n\telse\n\t    cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n\tswap(u[i], v[i]);\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> NG[100000], G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i]);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tbool done[100000];\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\t\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (done[x.to]) continue;\n\t\tdone[x.to] = true;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = 0; j < TG[i].size(); j++){\n\t\t\tif (weight[TG[i][j].to] == TG[i][j].cost + weight[i]){\n\t\t\t\tNG[TG[i][j].to].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint in[100000] = {0};\n\tqueue<int> q;\n\tmemset(done, 0, sizeof(done));\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tif (done[x]) continue;\n\t\tfor (int i = 0; i < NG[x].size(); i++){\n\t\t\tq.push(NG[x][i]);\n\t\t\tG[NG[x][i]].push_back(x);\n\t\t\tin[x]++;\n\t\t}\n\t\tdone[x] = true;\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tif (!in[i]) dfs(i);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tmemset(accessable, 0, sizeof(accessable));\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nconst int INF = 1010101010;\n\nstruct cmper{\n\tconst vector<int> &v;\n\texplicit cmper(const vector<int> &w) : v(w) {}\n\tbool operator() (const pii &p, const pii &q) const{\n\t\treturn v[p.second] < v[q.second];\n\t}\n};\n\nint main(){\n\tint s, r, a, b, c, qr;\n\tscanf(\"%d%d\", &s, &r);\n\tvector<vector<pii> > G(s + 1);\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tG[a].push_back(pii(c, b));\n\t\tG[b].push_back(pii(c, a));\n\t}\n\tscanf(\"%d%d%d\", &a, &b, &qr);\n\tvector<int> xs(qr), ys(qr);\n\tfor(int i = 0; i < qr; ++i){\n\t\tscanf(\"%d%d\", &xs[i], &ys[i]);\n\t}\n\n\tvector<int> ds(s + 1, INF);\n\tpriority_queue<pii> pq;\n\tvector<vector<int> > from(s + 1);\n\tpq.push(pii(0, a));\n\tds[a] = 0;\n\twhile(!pq.empty()){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\t\tint u = p.second;\n\t\tint d = -p.first;\n\t\tif(ds[u] != d){ continue; }\n\n\t\tfor(size_t i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i].second;\n\t\t\tint nd = d + G[u][i].first;\n\t\t\tif(ds[v] > nd){\n\t\t\t\tfrom[v].clear();\n\t\t\t\tpq.push(pii(-nd, v));\n\t\t\t}\n\t\t\tif(ds[v] >= nd){\n\t\t\t\tds[v] = nd;\n\t\t\t\tfrom[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<char> vis(s + 1);\n\tqueue<int> q;\n\tq.push(b);\n\tvis[b] = 1;\n\tvector<pii> es;\n\twhile(!q.empty()){\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(size_t i = 0; i < from[u].size(); ++i){\n\t\t\tint v = from[u][i];\n\t\t\tes.push_back(pii(v, u));\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(es.begin(), es.end(), cmper(ds));\n\n\tvector<ull> dp(s + 1);\n\tfor(int k = 0; k < qr; ){\n\t\tint t = min(k + 64, qr);\n\t\tfill(dp.begin(), dp.end(), 0ull);\n\t\tfor(int i = k; i < t; ++i){\n\t\t\tdp[xs[i]] |= 1ull << (i - k);\n\t\t}\n\t\tfor(size_t i = 0; i < es.size(); ++i){\n\t\t\tdp[es[i].second] |= dp[es[i].first];\n\t\t}\n\t\tfor(int i = k; i < t; ++i){\n\t\t\tputs(dp[ys[i]] >> (i - k) & 1 ? \"Yes\" : \"No\");\n\t\t}\n\t\tk = t;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <functional>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef unsigned long long int ull;\n#define pb push_back\n#define INF 1000000000\n#define fi first\n#define sec second\nint dist1[100100],dist2[100100];\nint c[40100],d[40100];\nbitset<1024> dp[100100];\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> g[100100];\nint comp(int x,int y){\n    return dist1[x]<dist1[y];\n}\nvoid dijkstra(int s,int t){\n    for(int i=0;i<100100;i++)dist1[i]=INF,dist2[i]=INF;\n    dist1[s]=0,dist2[t]=0;\n    priority_queue<P,vector<P>,greater<P> >q;\n    q.push(P(0,s));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist1[e.to]>dist1[v]+e.cost){\n                dist1[e.to] = dist1[v]+e.cost;\n                q.push(P(dist1[e.to],e.to));\n            }\n        }\n    }\n    q.push(P(0,t));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist2[e.to]>dist2[v]+e.cost){\n                dist2[e.to] = dist2[v]+e.cost;\n                q.push(P(dist2[e.to],e.to));\n            }\n        }\n    }\n    return;\n}\nint S,R,Q;\nint a,b;\nint main(){\n    scanf(\"%d %d\",&S,&R);\n    for(int i=0;i<R;i++){\n        int u,v,w;\n        scanf(\"%d %d %d\",&u,&v,&w);\n        u--;v--;\n        g[u].pb(edge(v,w));\n        g[v].pb(edge(u,w));\n    }\n    scanf(\"%d %d %d\",&a,&b,&Q);\n    a--;b--;\n    dijkstra(a,b);\n    /*for(int i=0;i<S;i++)\n    {\n        cout << dist1[i] << ' ' << dist2[i] << endl;\n    }*/\n    vector<int> tp;\n    for(int i=0;i<S;i++)tp.pb(i);\n    sort(tp.begin(),tp.end(),comp);\n    //for(int i=0;i<S;i++)cout << tp[i] << ' ';\n    for(int i=0;i<Q;i+=1024){\n        for(int j=0;j<min(1024,Q-i);j++){\n            scanf(\"%d %d\",&c[j],&d[j]);\n            c[j]--;d[j]--;\n            dp[c[j]].set(j);\n        } \n        for(int j=0;j<S;j++){\n            int f = tp[j];\n            if(dist1[f]+dist2[f]!=dist1[b])continue;\n            for(int k=0;k<g[f].size();k++){\n                edge e = g[f][k];\n                if(dist1[e.to]+dist2[e.to]!=dist1[b])continue;\n                if(dist1[e.to]!=dist1[f]+e.cost)continue;\n                dp[e.to]|=dp[f];\n            }\n        }\n        for(int j=0;j<min(1024,Q-i);j++){\n            if(dp[d[j]][j])printf(\"Yes\\n\");\n            else printf(\"No\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      if(used[e.to]) continue;\n      add_edge( ret, e.to, idx, -1, false);\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 3000 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 3000){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 3000);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1 << 30)\ntypedef pair<int, int> P;\n\nvector<P> valid_edge;\nint adist[105000], bdist[105000];\nvector<P> edge[105000];\n\nvoid dijkstra(int start, int *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tint from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(int i = 0;i < edge[from].size();i++){\n\t    int to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(int now){\n    for(int i = 0;i < edge[now].size();i++){\n\tint to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    int s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(int i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    int c[64], d[65];\n    long long dp[105000];\n    for(int i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(int j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1 << j);\n\t}\n\tfor(int j = 0;j < valid_edge.size();j++){\n\t    int from = valid_edge[j].first;\n\t    int to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(int j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1 << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n    Edge(int t, int w) :to(t), weight(w) {}\n};\n\nvoid restore(vector<set<int>>& edge, const vector<set<int>>& previous, const int current) {\n    for(const auto& i: previous[current]) {\n        if(edge[i].count(current)) continue;\n        edge[i].insert(current);\n        restore(edge, previous, i);\n    }\n}\n\nint main() {\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n\n    // Dijkstra\n    typedef tuple<int, int, int> Node;\n\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    vector<int> distance(S, INT_MAX);\n    vector<set<int>> previous(S);\n\n    q.emplace(0, a, a);\n    while(!q.empty()) {\n        int cost, id, prev;\n        tie(cost, id, prev) = q.top();\n        q.pop();\n\n        if(distance[id] < cost) continue;\n        if(previous[id].count(prev)) continue;\n        distance[id] = cost;\n        if(id != prev) previous[id].insert(prev);\n\n        for(const auto& e: original[id]) q.emplace(cost + e.weight, e.to, id);\n    }\n\n    // DAG\n    vector<set<int>> edge(S);\n    restore(edge, previous, b);\n\n    // topological sort\n    vector<int> order;\n    vector<bool> visited(S, false);\n    queue<int> q2;\n    q2.push(a);\n    while(!q2.empty()) {\n        int v = q2.front();\n        q2.pop();\n        if(visited[v]) continue;\n        visited[v] = true;\n        order.push_back(v);\n        for(const auto& i: edge[v]) q2.push(i);\n    }\n\n    // DP\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n\n        vector<unsigned long long int> dp(S, 0);\n        dp[c] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) {\n            dp[to] |= dp[from];\n        }\n\n        cout << (dp[d] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 103000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\nif(adist[b] != bdist[a])reutrn 1;\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] == INF || adist[v[i]] == INF ||\n\t   bdist[u[i]] == INF || bdist[v[i]] == INF)\n\t    continue;\n\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n\tswap(u[i], v[i]);\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level: 4\n//Category: グラフ,Graph,最短経路,DAG\n//Note:\n\n/**\n * AからBまでの最短経路をDijkstra法で求め、そのときに使った辺のみから\n * なるDAGを構成する。\n * すると、cからdに最短経路で行けるかの判定は、このDAG上でcからdに行けるかの\n * 判定と等価になる。\n * 1クエリについて最悪全ノードの探索が必要で、これはO(S+R)になるが、\n * 到達可能かどうかは1bitしか使わないのでbit parallelで高速化ができる。\n * (S+R) × Q = 10^10 程度なので、数十倍程度の高速化をすれば制限時間に間に合う。\n *\n * オーダーは O(R log S + (S+R)Q)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<128> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].emplace_back(v, w);\n        graph[v].emplace_back(u, w);\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill_n(memo.begin(), S, INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    vector<int> ord;\n    {\n        array<bool, 100000> visited;\n        array<int, 100000> ref_cnt;\n        fill_n(visited.begin(), S, false);\n        fill_n(ref_cnt.begin(), S, 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            ord.push_back(cur);\n            q.pop();\n            for(int to : dag[cur]) {\n                if(--ref_cnt[to] == 0) {\n                    q.push(to);\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 128> dest;\n    for(int i = 0; i < Q; ) {\n        for(auto &f : reachable) {\n            f.reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 128 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        for(int v : ord) {\n            for(int next : dag[v]) {\n                reachable[next] |= reachable[v];\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int sep = 32;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[100000];\nint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tassert(pos[to] > i);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tans[i] = ((dp[pos[qt[i]]] & (1ull << i)) > 0ull) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += sep){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[40000];\nint dp[40000];\nulint ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], ulint ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tans[i] = dp[pos[qt[i]]] & (1ull << i);\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += 64){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"YES\" : \"NO\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int sep = 64;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<vector<int>> pre;\nvector<vector<int>> rpre;\nvector<int> tps, pos;\nbool visit[100000];\nulint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 100000, 0);\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < tps.size(); i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\tif (pos[to] == -1) continue;\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tif (pos[qt[i]] == -1) ans[i] = false;\n\t\telse {\n\t\t\tans[i] = (dp[pos[qt[i]]] & (1ull << i)) ? true : false;\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n, -1);\n\ttoposort(B);\n\t\n\tfor (int i = 0; i < Q; i += sep){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n    Edge(int t, int w) :to(t), weight(w) {}\n};\n\nvoid restore(vector<set<int>>& edge, const vector<set<int>>& previous, const int current) {\n    for(const auto& i: previous[current]) {\n        if(edge[i].count(current)) continue;\n        edge[i].insert(current);\n        restore(edge, previous, i);\n    }\n}\n\nint main() {\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n\n    // Dijkstra\n    typedef tuple<int, int, int> Node;\n\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    vector<int> distance(S, INT_MAX);\n    vector<set<int>> previous(S);\n\n    for(q.emplace(0, a, a); !q.empty(); q.pop()) {\n        int cost, id, prev;\n        tie(cost, id, prev) = q.top();\n\n        if(distance[id] == cost) previous[id].insert(prev);\n        if(distance[id] <= cost) continue;\n        if(id != prev) previous[id] = {prev};\n        distance[id] = cost;\n\n        for(const auto& e: original[id]) q.emplace(cost + e.weight, e.to, id);\n    }\n\n    // DAG\n    vector<set<int>> edge(S);\n    restore(edge, previous, b);\n\n    // topological sort\n    vector<int> order;\n    vector<bool> visited(S, false);\n    queue<int> q2;\n    q2.push(a);\n    while(!q2.empty()) {\n        int v = q2.front();\n        q2.pop();\n        if(visited[v]) continue;\n        visited[v] = true;\n        order.push_back(v);\n        for(const auto& i: edge[v]) q2.push(i);\n    }\n\n    // DP\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n\n        vector<unsigned long long int> dp(S, 0);\n        dp[c] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) {\n            dp[to] |= dp[from];\n        }\n\n        cout << (dp[d] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] < d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] == INF || adist[v[i]] == INF ||\n\t   bdist[u[i]] == INF || bdist[v[i]] == INF)\n\t    continue;\n\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n\tswap(u[i], v[i]);\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second;\n\tif(dist[from] < tmp.first)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long tw = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] > dist[from] + tw){\n\t\tdist[to] = dist[from] + tw;\n\t\tpq.push(P(dist[to], to));\n\t\tif(to >= 105000)exit(1);\n\t    }\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level:\n//Category:\n//Note:\n\n/**\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    array<int, 100000> ref_cnt;\n    {\n        array<bool, 100000> visited;\n        fill(visited.begin(), visited.end(), false);\n        fill(ref_cnt.begin(), ref_cnt.end(), 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<ULL, 100000> reachable;\n    array<int, 70> dest;\n    for(int i = 0; i < Q; ) {\n        fill(reachable.begin(), reachable.end(), 0);\n        int cnt = 0;\n        for(int j = 0; j < 64 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d] |= 1LL<<j;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]] & (1LL<<j)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nbool visit(const vector<vi> &g, int v, vector<int> &order, vector<int> &color) {\n  color[v] = 1;\n  for(int e : g[v]) {\n    if (color[e] == 2) continue;\n    if (color[e] == 1) return false;\n    if (!visit(g, e, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(const vector<vi> &g, vector<int> &order) {\n  int n = g.size();\n  vector<int> color(n);\n  rep(u, n) if (!color[u] && !visit(g, u, order, color))\n    return false;\n  reverse(all(order));\n  return true;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint s, r; cin >> s >> r;\n\tint S, T, Q;\n\tvector<vi> g(s);\n\t{\n\t\tvi dist(s, inf), rdist(s, inf);\n\t\tvector<vector<pi>> e(s), re(s);\n\t\trep(i, r){\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\te[a].emplace_back(b, c);\n\t\t\tre[b].emplace_back(a, c);\n\t\t}\n\t\tcin >> S >> T >> Q; S--; T--;\n\t\t\n\t\tauto dij = [](int s, const vector<vector<pi>> &e, vi &dist){\n\t\t\tint n = e.size();\n\t\t\tpriority_queue<pi> q; q.emplace(0, s);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint c, d; tie(d, c) = q.top(); q.pop();\n\t\t\t\tif(dist[c] < -d) continue;\n\t\t\t\tdist[c] = -d;\n\t\t\t\tfor(pi p : e[c]){\n\t\t\t\t\tint nd = -d + p.second;\n\t\t\t\t\tif(dist[p.first] > nd){\n\t\t\t\t\t\tdist[p.first] = nd;\n\t\t\t\t\t\tq.emplace(-nd, p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdij(S, e, dist);\n\t\tdij(T, re, rdist);\n\t\t/*\n\t\tdbg(dist);\n\t\tdbg(rdist);\n\t\t*/\n\t\trep(i, s) for(pi p : e[i])\n\t\t\tif(dist[i] + p.second + rdist[p.first] == dist[T])\n\t\t\t\tg[i].pb(p.first);\n\t}\n\t//dbg(g);\n\tvi ord;\n\ttopologicalSort(g, ord);\n\t\n\tvector<pi> in;\n\trep(it, Q){\n\t\tint a, b; cin >> a >> b; in.emplace_back(a - 1, b - 1);\n\t\tif(!(it == Q - 1 || in.size() == 64)) continue;\n\t\tvector<unsigned long long > f(s);\n\t\trep(i, in.size()) f[in[i].first] |= 1ull << i;\n\t\tfor(int i : ord) for(int j : g[i]) f[j] |= f[i];\n\t\trep(i, in.size()) cout << (f[in[i].second] >> i & 1 ? \"Yes\" : \"No\") << endl;\n\t\tin.clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x> >\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tstatic bool used0[100010];\n\trep(i,100010)used0[i]=used[i];\n\t\n\trep(i,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\tif(!used0[e]){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tstack<int> sta;\n\t\tsta.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!sta.empty()){\n\t\t\tint x=sta.top(); sta.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\trep(i,nG[x].size()){\n\t\t\t\tint nex=nG[x][i];\n\t\t\t\tif(!used[nex]){\n\t\t\t\t\tsta.push(nex);\n\t\t\t\t\tused[nex]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int sep = 32;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<vector<int>> pre;\nvector<vector<int>> rpre;\nvector<int> tps, pos;\nbool visit[100000];\nulint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 100000, 0);\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < tps.size(); i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\tif (pos[to] == -1) continue;\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tassert(pos[to] > i);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tans[i] = ((dp[pos[qt[i]]] & (1ull << i)) > 0ull) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n, -1);\n\ttoposort(B);\n\t\n\tfor (int i = 0; i < Q; i += sep){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef unsigned long long wolf;\nvector<pair<int,int> > g[110000];\nvector<int> G[110000];\nint ijk[110000];\nint v[110000];\nint x[41000];\nint y[41000];\nwolf L[110000];\nwolf R[110000];\nwolf tmp[110000];\npair<int ,int> r[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tp--;q--;\n\t\tg[p].push_back(make_pair(q,r));\n\t\tg[q].push_back(make_pair(p,r));\n\t}\n\tint c,d,e;\n\tscanf(\"%d%d%d\",&c,&d,&e);\n\tc--;d--;\n\tfor(int i=0;i<e;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t//\tL[x[i]].push_back(i);\n\t//\tR[x[i]].push_back(i);\n\t}\n\tpriority_queue<pair<int,int> >Q;\n\tQ.push(make_pair(0,c));\n\tfor(int i=0;i<a;i++)ijk[i]=999999999;\n\tijk[c]=0;\n\twhile(Q.size()){\n\t\tint cost=-Q.top().first;\n\t\tint at=Q.top().second;\n\t\tQ.pop();\n\t\tif(v[at])continue;\n\t\tv[at]=1;\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\tQ.push(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<g[i].size();j++)if(ijk[i]+g[i][j].second==ijk[g[i][j].first]){\n\t\t\tG[i].push_back(g[i][j].first);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)r[i]=make_pair(ijk[i],i);\n\tstd::sort(r,r+a);\n\tfor(int i=0;i<(e+63)/64;i++){\n\t\tqueue<pair<int,wolf> > Q2;\n\t\tfor(int j=i*64;j<min(i*64+64,e);j++){\n\t\t\tL[x[j]]+=(1LL<<(j%64));\n\t\t\tR[y[j]]+=(1LL<<(j%64));\n\t\t}\n\t\tfor(int j=0;j<a;j++)tmp[j]=0LL;\n\t\twolf ans=0LL;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tint at=r[j].second;\n\t\t\ttmp[at]|=L[at];\n\t\t\tans|=(tmp[at]&R[at]);\n\t\t\tfor(int k=0;k<G[at].size();k++){\n\t\t\t\ttmp[G[at][k]]|=tmp[at];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<min(64,e-i*64);j++){\n\t\t\tif(ans&(1LL<<j))printf(\"Yes\\n\");\n\t\t\telse printf(\"No\\n\");\n\t\t}\n\t\tfor(int j=i*64;j<min(i*64+64,e);j++){\n\t\t\tL[x[j]]-=(1LL<<(j%64));\n\t\t\tR[y[j]]-=(1LL<<(j%64));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level: 4\n//Category: グラフ,Graph,最短経路,DAG\n//Note:\n\n/**\n * AからBまでの最短経路をDijkstra法で求め、そのときに使った辺のみから\n * なるDAGを構成する。\n * すると、cからdに最短経路で行けるかの判定は、このDAG上でcからdに行けるかの\n * 判定と等価になる。\n * 1クエリについて最悪全ノードの探索が必要で、これはO(N+M)になるが、\n * 到達可能かどうかは1bitしか使わないのでbit parallelで高速化ができる。\n * (N+M) × Q = 10^10 程度なので、数十倍程度の高速化をすれば制限時間に間に合う。\n *\n * オーダーは O(N log R + (N+M)Q)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<128> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    vector<int> ord;\n    {\n        array<int, 100000> ref_cnt;\n        array<bool, 100000> visited;\n        fill(visited.begin(), visited.end(), false);\n        fill(ref_cnt.begin(), ref_cnt.end(), 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            ord.push_back(cur);\n            q.pop();\n            for(int to : dag[cur]) {\n                if(--ref_cnt[to] == 0) {\n                    q.push(to);\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 128> dest;\n    for(int i = 0; i < Q; ) {\n        for(auto &f : reachable) {\n            f.reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 128 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        for(int v : ord) {\n            for(int next : dag[v]) {\n                reachable[next] |= reachable[v];\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] < d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 103000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nbool comp(const int &a, const int &b){\n    return adist[a] < adist[b];\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    long long c[64], d[64];\n    long long dp[105000];\n    long long topo[105000];\n    for(int i = 0;i < 105000;i++)topo[i] = i;\n    sort(topo, topo + s, comp);\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(int j = 0;j < s;j++){\n\t    int p = topo[j];\n\t    if(adist[p] + bdist[p] != adist[b])continue;\n\t    for(int k = 0;k < edge[p].size();k++){\n\t\tint to = edge[p][k].first, d = edge[p][k].second;\n\t\tif(adist[to] + bdist[to] == adist[b] &&\n\t\t   adist[to] == adist[p] + d)\n\t\t    dp[to] |= dp[p];\n\t    }\n\t}\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second;\n\tif(dist[from] < tmp.first)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long tw = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] < dist[from] + tw)continue;\n\t    dist[to] = dist[from] + tw;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return adist[b] - bdist[a];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 40000 > > dp(graph.size(), 0);\n\n  for(int i = 0; i < query.size(); i++){\n    dp[query[i].first][i] = 1;\n  }\n  for(int __ = 0; __ < edges.size(); __++){\n    int j = edges[__];\n    if(dp[j] == 0uLL) continue;\n    for(int k = 0; k < graph[j].size(); k++){\n      dp[graph[j][k].to] |= dp[j];\n    }\n  }\n  for(int i = 0; i < query.size(); i++){\n    puts( dp[query[i].second][i] ? \"Yes\" : \"No\");\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n \nusing namespace std;\n \nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost) : to(to), cost(cost){}\n    Edge(){}\n};\n \nbool operator < (const Edge &a, const Edge &b)\n{\n    return (a.cost > b.cost);\n}\n \nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n \nvoid dfs(int v)\n{\n    vis[v] = true;\n     \n    for (int i = 0; i < G[v].size(); i++)\n        if (!vis[G[v][i]]) dfs(G[v][i]);\n    topo.push_back(v);\n}\n \nint main()\n{\n    int N, M;\n     \n    scanf(\"%d %d\", &N, &M);\n     \n    for (int i = 0; i < M; i++){\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        --u; --v;\n        TG[u].push_back(Edge(v, w));\n        TG[v].push_back(Edge(u, w));\n    }\n     \n    int a, b, Q;\n     \n    scanf(\"%d %d %d\", &a, &b, &Q);\n     \n    --a; --b;\n     \n    for (int i = 0; i < Q; i++){\n        scanf(\"%d %d\", c + i, d + i);\n        --c[i]; --d[i];\n    }\n     \n    priority_queue<Edge> pq;\n    bool done[100000] = {0};\n    int weight[100000];\n    fill(weight, weight + N, 1001001001);\n     \n    for (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n        Edge x = pq.top();\n         \n        if (done[x.to]) continue;\n        done[x.to] = true;\n        weight[x.to] = x.cost;\n         \n        for (int i = 0; i < TG[x.to].size(); i++){\n            pq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n        }\n    }\n     \n    int in[100000] = {0};\n    queue<int> q;\n    memset(done, 0, sizeof(done));\n     \n    for (q.push(b); q.size(); q.pop()){\n        int x = q.front();\n        if (done[x]) continue;\n        for (int i = 0; i < TG[x].size(); i++){\n            if (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n                q.push(TG[x][i].to);\n                G[TG[x][i].to].push_back(x);\n                in[x]++;\n            }\n        }\n        done[x] = true;\n    }\n     \n    for (int i = 0; i < N; i++){\n        if (!in[i]) dfs(i);\n    }\n    reverse(topo.begin(), topo.end());\n     \n    for (int i = 0; i < (Q + 63) / 64; i++){\n        memset(accessable, 0, sizeof(accessable));\n        for (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n            accessable[c[j]] |= (1ll << (j % 64));\n        }\n        for (int j = 0; j < topo.size(); j++){\n            for (int k = 0; k < G[topo[j]].size(); k++){\n                accessable[G[topo[j]][k]] |= accessable[topo[j]];\n            }\n        }\n        for (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n            if ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic vector<edge> G[100000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint a,b,q; scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n\tstatic int c[40000],d[40000];\n\trep(i,q) scanf(\"%d%d\",c+i,d+i), c[i]--, d[i]--;\n\n\t// calculate distances from a\n\tstatic int dist_a[100000];\n\trep(u,n) dist_a[u]=(u==a?0:INF);\n\tpriority_queue< pair<int,int> > Qa; Qa.push(make_pair(0,a));\n\twhile(!Qa.empty()){\n\t\tint d_now=-Qa.top().first,u=Qa.top().second; Qa.pop();\n\t\tif(d_now>dist_a[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_a[v]>dist_a[u]+cost){\n\t\t\t\tdist_a[v]=dist_a[u]+cost;\n\t\t\t\tQa.push(make_pair(-dist_a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// calculate distances from b\n\tstatic int dist_b[100000];\n\trep(u,n) dist_b[u]=(u==b?0:INF);\n\tpriority_queue< pair<int,int> > Qb; Qb.push(make_pair(0,b));\n\twhile(!Qb.empty()){\n\t\tint d_now=-Qb.top().first,u=Qb.top().second; Qb.pop();\n\t\tif(d_now>dist_b[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_b[v]>dist_b[u]+cost){\n\t\t\t\tdist_b[v]=dist_b[u]+cost;\n\t\t\t\tQb.push(make_pair(-dist_b[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// build the shortest path DAG from a to b\n\tstatic vector<int> H[100000];\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\tif(dist_a[u]+cost+dist_b[v]==dist_a[b]) H[u].push_back(v);\n\t}\n\n\t// find a topological order of H\n\tvector<int> top;\n\tstatic bool vis[100000];\n\tqueue<int> Q; Q.push(a);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\ttop.push_back(u);\n\t\trep(i,H[u].size()){\n\t\t\tint v=H[u][i];\n\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t}\n\t}\n\n\t// query\n\trep(i,(q+63)/64){\n\t\tstatic ll dp[100000];\n\t\tmemset(dp,0,sizeof dp);\n\t\trep(j,64) if(64*i+j<q) dp[c[64*i+j]]|=1LL<<j;\n\t\trep(i,n){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tdp[v]|=dp[u];\n\t\t\t}\n\t\t}\n\t\trep(j,64) if(64*i+j<q) puts(dp[d[64*i+j]]&(1LL<<j)?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x> >\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tstatic bool used0[100010];\n\trep(i,100010)used0[i]=used[i];\n\t\n\trep(i,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\tif(!used0[e]){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tstack<int> sta;\n\t\tsta.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!sta.empty()){\n\t\t\tint x=sta.top(); sta.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\trrep(i,nG[x].size()){\n\t\t\t\tint nex=nG[x][i];\n\t\t\t\tif(!used[nex]){\n\t\t\t\t\tsta.push(nex);\n\t\t\t\t\tused[nex]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x> >\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\trep(i,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tstack<int> sta;\n\t\tsta.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!sta.empty()){\n\t\t\tint x=sta.top(); sta.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\trep(i,nG[x].size()){\n\t\t\t\tint nex=nG[x][i];\n\t\t\t\tif(!used[nex]){\n\t\t\t\t\tsta.push(nex);\n\t\t\t\t\tused[nex]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 1500 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 1500){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 1500);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 2048 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 2048){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 2048);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int to, const int weight) :to(to), weight(weight) {}\n};\n\nconst vector<set<int>> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    struct Node {\n        int vertex;\n        int cost;\n        vector<int> path;\n        Node(const int v, const int c, const vector<int>& p) :vertex(v), cost(c), path(p) {}\n        bool operator<(const Node& n) const {return cost > n.cost;}\n    };\n    vector<int> distance(edge.size(), INF);\n    priority_queue<Node> q;\n    for(q.emplace(start, 0, vector<int>()); !q.empty(); q.pop()) {\n        auto v = q.top().vertex;\n        auto cost = q.top().cost;\n        auto path = q.top().path;\n        path.push_back(v);\n        if(v == goal && cost <= distance[v]) for(int i = 1; i < path.size(); ++i) result[path[i - 1]].insert(path[i]);\n//         if(distance[v] != INF) continue;\n        if(distance[goal] <= cost) continue;\n        distance[v] = cost;\n        for(const auto& e: edge[v]) q.emplace(e.to, cost + e.weight, path);\n    }\n    return result;\n}\n\nvoid dfs(vector<int>& result, const vector<set<int>>& edge, const int v, vector<bool> &visited) {\n    if(visited[v]) return;\n    visited[v] = true;\n    for(const auto& to: edge[v]) dfs(result, edge, to, visited);\n    result.push_back(v);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    dfs(result, edge, start, visited);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(const int begin, const int end) :begin(begin), end(end) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n    cin >> S >> R;\n    vector<vector<Edge>> original(S);\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n    }\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = Dijkstra(original, a, b);\n    auto order = topological_sort(edge, a);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S);\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] = dp[to] | dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic vector<edge> G[100000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint a,b,q; scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n\tstatic int c[40000],d[40000];\n\trep(i,q) scanf(\"%d%d\",c+i,d+i), c[i]--, d[i]--;\n\n\t// calculate distances from a\n\tstatic int dist_a[100000];\n\trep(u,n) dist_a[u]=(u==a?0:INF);\n\tpriority_queue< pair<int,int> > Qa; Qa.push(make_pair(0,a));\n\twhile(!Qa.empty()){\n\t\tint d_now=-Qa.top().first,u=Qa.top().second; Qa.pop();\n\t\tif(d_now>dist_a[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_a[v]>dist_a[u]+cost){\n\t\t\t\tdist_a[v]=dist_a[u]+cost;\n\t\t\t\tQa.push(make_pair(-dist_a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// calculate distances from b\n\tstatic int dist_b[100000];\n\trep(u,n) dist_b[u]=(u==b?0:INF);\n\tpriority_queue< pair<int,int> > Qb; Qb.push(make_pair(0,b));\n\twhile(!Qb.empty()){\n\t\tint d_now=-Qb.top().first,u=Qb.top().second; Qb.pop();\n\t\tif(d_now>dist_b[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_b[v]>dist_b[u]+cost){\n\t\t\t\tdist_b[v]=dist_b[u]+cost;\n\t\t\t\tQb.push(make_pair(-dist_b[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// build the shortest path DAG from a to b\n\tstatic vector<int> H[100000];\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\tif(dist_a[u]+cost+dist_b[v]==dist_a[b]) H[u].push_back(v);\n\t}\n\n\t// find a topological order of H\n\tvector<int> top;\n\tstatic bool vis[100000];\n\tqueue<int> Q; Q.push(a);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\ttop.push_back(u);\n\t\trep(i,H[u].size()){\n\t\t\tint v=H[u][i];\n\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t}\n\t}\n\n\t// query\n\trep(i,(q+63)/64){\n\t\tstatic ll dp[100000];\n\t\tmemset(dp,0,sizeof dp);\n\t\trep(j,64) if(64*i+j<q) dp[c[64*i+j]]|=1LL<<j;\n\t\trep(i,n){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tdp[v]|=dp[u];\n\t\t\t}\n\t\t}\n\t\trep(j,64) if(64*i+j<q) puts(dp[d[64*i+j]]&(1LL<<j)?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}swap(u[i], v[i]);\nif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int sep = 64;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[100000];\nulint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 100000, 0);\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tassert(pos[to] > i);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tans[i] = ((dp[pos[qt[i]]] & (1ull << i)) > 0ull) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += sep){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 1024 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 1024){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 1024);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nconst int INF=1001001001;\nint N,M;\nint S,T,Q;\nvector<edge>G[100000];\nvector<int>L[100000];\nint dist[100000];\nbool used[100000];\nunsigned long long dp[100000];\nvector<int>ord;\nvoid dijkstra(){\n    fill_n(dist,N,INF);\n    dist[S]=0;\n    priority_queue<P,vector<P>,greater<P> >que;\n    que.push(P(0,S));\n\n    while(que.size()){\n        P p=que.top();que.pop();\n        if(dist[p.second]<p.first)continue;\n        for(int i=0;i<G[p.second].size();i++){\n            edge &e=G[p.second][i];\n            if(dist[e.to]<=p.first+e.cost)continue;\n            dist[e.to]=p.first+e.cost;\n            que.push(P(dist[e.to],e.to));\n        }\n    }\n}\n\nvoid dfs(int v){\n    used[v]=true;\n    for(int i=0;i<L[v].size();i++){\n        int to=L[v][i];\n        if(used[to])continue;\n        dfs(to);\n    }\n    ord.push_back(v);\n}\n\nvoid build(){\n    queue<int>que;\n    que.push(T);\n    used[T]=true;\n    while(que.size()){\n        int pos=que.front();que.pop();\n        for(int i=0;i<G[pos].size();i++){\n            edge &e=G[pos][i];\n            if(dist[e.to]+e.cost==dist[pos]){\n                L[e.to].push_back(pos);\n                if(!used[e.to]){\n                    used[e.to]=true;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&M);\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        a--;b--;\n        G[a].push_back(edge(b,c));\n        G[b].push_back(edge(a,c));\n    }\n    scanf(\"%d%d%d\",&S,&T,&Q);\n    S--;T--;\n\n    dijkstra();\n\n    build();\n    fill_n(used,N,false);\n    for(int i=0;i<N;i++)if(!used[i])dfs(i);\n    reverse(ord.begin(),ord.end());\n\n\n    for(int i=0;i<(Q+63)/64;i++){\n        int a[64],b[64];\n        int lim=min(64,Q-i*64);\n        fill_n(dp,N,0);\n        for(int j=0;j<lim;j++){\n            scanf(\"%d%d\",&a[j],&b[j]);\n            a[j]--;b[j]--;\n            dp[a[j]]|=(1ll<<j);\n        }\n        for(int j=0;j<N;j++){\n            int v=ord[j];\n            for(int k=0;k<L[v].size();k++){\n                int to=L[v][k];\n                dp[to]|=dp[v];\n            }\n        }\n\n        for(int j=0;j<lim;j++){\n            if(dp[b[j]]>>j&1)puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int sep = 32;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[100000];\nulint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 100000, 0);\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tassert(pos[to] > i);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tans[i] = ((dp[pos[qt[i]]] & (1ull << i)) > 0ull) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += sep){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 2512 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 2512){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 2512);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<int>& memo) {\n    if(start == goal) return true;\n    if(cost >= distance[goal]) return false;\n    if(memo[start] != NIL) return true;\n    memo[start] = 0;\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n        memo[start] = 1;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<int> memo(edge.size(), NIL);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n//     for(int i = 0; i < edge.size(); ++i) ts_dfs(result, edge, visited, i);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(int b, int e) :begin(b), end(e) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S, bitset<BIT>());\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int to, const int weight) :to(to), weight(weight) {}\n};\n\nconst vector<set<int>> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    struct Node {\n        int vertex;\n        int cost;\n        vector<int> path;\n        Node(const int v, const int c, const vector<int>& p) :vertex(v), cost(c), path(p) {}\n        bool operator<(const Node& n) const {return cost > n.cost;}\n    };\n    vector<int> distance(edge.size(), INF);\n    priority_queue<Node> q;\n    for(q.emplace(start, 0, vector<int>()); !q.empty(); q.pop()) {\n        auto v = q.top().vertex;\n        auto cost = q.top().cost;\n        auto path = q.top().path;\n        path.push_back(v);\n        if(v == goal && cost <= distance[v]) for(int i = 1; i < path.size(); ++i) result[path[i - 1]].insert(path[i]);\n        if(distance[v] != INF) continue;\n        distance[v] = cost;\n        for(const auto& e: edge[v]) q.emplace(e.to, cost + e.weight, path);\n    }\n    return result;\n}\n\nvoid dfs(vector<int>& result, const vector<set<int>>& edge, const int v, vector<bool> &visited) {\n    if(visited[v]) return;\n    visited[v] = true;\n    for(const auto& to: edge[v]) dfs(result, edge, to, visited);\n    result.push_back(v);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    dfs(result, edge, start, visited);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(const int begin, const int end) :begin(begin), end(end) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n    cin >> S >> R;\n    vector<vector<Edge>> original(S);\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n    }\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = Dijkstra(original, a, b);\n    auto order = topological_sort(edge, a);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S);\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] = dp[to] | dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <cstring>\n#include <functional>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef unsigned long long int ull;\n#define pb push_back\n#define INF 1000000000\n#define fi first\n#define sec second\nint dist1[100100],dist2[100100];\nint c[40100],d[40100];\null dp[100100];\nstruct edge\n{\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> g[100100];\nint comp(int x,int y)\n{\n\treturn dist1[x]<dist1[y];\n}\nvoid dijkstra(int s,int t)\n{\n\tfor(int i=0;i<100100;i++)dist1[i]=INF,dist2[i]=INF;\n\tdist1[s]=0,dist2[t]=0;\n\tpriority_queue<P,vector<P>,greater<P> >q;\n\tq.push(P(0,s));\n\twhile(!q.empty())\n\t{\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tint v = a.sec;\n\t\tfor(int i=0;i<g[v].size();i++)\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif(dist1[e.to]>dist1[v]+e.cost)\n\t\t\t{\n\t\t\t\tdist1[e.to] = dist1[v]+e.cost;\n\t\t\t\tq.push(P(dist1[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\tq.push(P(0,t));\n\twhile(!q.empty())\n\t{\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tint v = a.sec;\n\t\tfor(int i=0;i<g[v].size();i++)\n\t\t{\n\t\t\tedge e = g[v][i];\n\t\t\tif(dist2[e.to]>dist2[v]+e.cost)\n\t\t\t{\n\t\t\t\tdist2[e.to] = dist2[v]+e.cost;\n\t\t\t\tq.push(P(dist2[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint S,R,Q;\nint a,b;\nint main()\n{\n\tscanf(\"%d %d\",&S,&R);\n\tfor(int i=0;i<R;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d %d %d\",&u,&v,&w);\n\t\tu--;v--;\n\t\tg[u].pb(edge(v,w));\n\t\tg[v].pb(edge(u,w));\n\t}\n\tscanf(\"%d %d %d\",&a,&b,&Q);\n\ta--;b--;\n\tdijkstra(a,b);\n\t/*for(int i=0;i<S;i++)\n\t{\n\t\tcout << dist1[i] << ' ' << dist2[i] << endl;\n\t}*/\n\tvector<int> tp;\n\tfor(int i=0;i<S;i++)tp.pb(i);\n\tsort(tp.begin(),tp.end(),comp);\n\t//for(int i=0;i<S;i++)cout << tp[i] << ' ';\n\tfor(int i=0;i<Q;i+=60)\n\t{\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int j=0;j<min(60,Q-i);j++)\n\t\t{\n\t\t\tcin >> c[j] >> d[j];\n\t\t\tc[j]--;d[j]--;\n\t\t\tdp[c[j]]|=(1ull<<j);\n\t\t} \n\t\tfor(int j=0;j<S;j++)\n\t\t{\n\t\t\tint f = tp[j];\n\t\t\tif(dist1[f]+dist2[f]!=dist1[b])continue;\n\t\t\tfor(int k=0;k<g[f].size();k++)\n\t\t\t{\n\t\t\t\tedge e = g[f][k];\n\t\t\t\tif(dist1[e.to]+dist2[e.to]!=dist1[b])continue;\n\t\t\t\tif(dist1[e.to]!=dist1[f]+e.cost)continue;\n\t\t\t\tdp[e.to]|=dp[f];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<min(60,Q-i);j++)\n\t\t{\n\t\t\tif(dp[d[j]]&(1ull<<j))cout << \"Yes\" << endl;\n\t\t\telse cout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] <= d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return adist[b] - bdist[a];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\nstruct edge2{\n  int u, v, cost;\n  bool operator<(const edge2& hoge)const{\n    return cost < hoge.cost;\n  }\n};\ntypedef vector< vector< edge > > Graph;\ntypedef vector< edge2 > Edges; /* 辺集合 */\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< unsigned long long int > dp(graph.size());\n  for(int _ = 0; _ < query.size(); _ += 64){\n    int start = _, end = min< int >( _ + 64, query.size());\n    fill( dp.begin(), dp.end(), 0uLL);\n    for(int i = start; i < end; i++){\n      dp[query[i].first] |= 1uLL << (i - start);\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( ((dp[query[i].second] >> (i - start)) & 1) ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    for(long long i = come[now];i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    fill(come, come + 105000, false);\n    dfs(a);\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i]);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (weight[x.to] < x.cost) continue;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tif (weight[TG[x.to][i].to] > x.cost + TG[x.to][i].cost){\n\t\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tqueue<int> q;\n\tbool done[100000] = {0};\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tif (done[x]) continue;\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t}\n\t\t}\n\t\tdone[x] = true;\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tif (!vis[i]) dfs(i);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tmemset(accessable, 0, sizeof(accessable));\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 40000 > > dp(graph.size(), 0);\n\n  for(int i = 0; i < query.size(); i++){\n    dp[query[i].first] |= 1uLL << i;\n  }\n  for(int __ = 0; __ < edges.size(); __++){\n    int j = edges[__];\n    if(dp[j] == 0uLL) continue;\n    for(int k = 0; k < graph[j].size(); k++){\n      dp[graph[j][k].to] |= dp[j];\n    }\n  }\n  for(int i = 0; i < query.size(); i++){\n    puts( dp[query[i].second].test(i) ? \"Yes\" : \"No\");\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int to, const int weight) :to(to), weight(weight) {}\n};\n\nconst vector<set<int>> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n    const int INF = INT_MAX;\n    struct Node {\n        int vertex;\n        int cost;\n        vector<int> path;\n        Node(const int v, const int c, const vector<int>& p) :vertex(v), cost(c), path(p) {}\n        bool operator<(const Node& n) const {return cost > n.cost;}\n    };\n    vector<set<int>> result(edge.size());\n    vector<int> distance(edge.size(), INF);\n    priority_queue<Node> q;\n    for(q.emplace(start, 0, vector<int>()); !q.empty(); q.pop()) {\n        auto v = q.top().vertex;\n        auto cost = q.top().cost;\n        auto path = q.top().path;\n        path.push_back(v);\n        if(v == goal && cost <= distance[v]) for(int i = 1; i < path.size(); ++i) result[path[i - 1]].insert(path[i]);\n        if(distance[v] != INF) continue;\n//         if(distance[goal] <= cost) continue;\n        distance[v] = cost;\n        for(const auto& e: edge[v]) q.emplace(e.to, cost + e.weight, path);\n    }\n    return result;\n}\n\nvoid dfs(vector<int>& result, const vector<set<int>>& edge, const int v, vector<bool> &visited) {\n    if(visited[v]) return;\n    visited[v] = true;\n    for(const auto& to: edge[v]) dfs(result, edge, to, visited);\n    result.push_back(v);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    dfs(result, edge, start, visited);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(const int begin, const int end) :begin(begin), end(end) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n    cin >> S >> R;\n    vector<vector<Edge>> original(S);\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = Dijkstra(original, a, b);\n    auto order = topological_sort(edge, a);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S);\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] = dp[to] | dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nvoid dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<int>& memo) {\n//     if(start == goal) return true;\n//     if(memo[start] != NIL) return true;\n//     memo[start] = 0;\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n//         if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n//         memo[start] = 1;\n        result[start].insert(e.to);\n        dfs(result, edge, distance, e.to, goal, cost + e.weight, memo);\n    }\n//     return memo[start];\n}\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<int> memo(edge.size(), NIL);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(int b, int e) :begin(b), end(e) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S, bitset<BIT>(0));\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end][j] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level: 4\n//Category: グラフ,Graph,最短経路,DAG\n//Note:\n\n/**\n * AからBまでの最短経路をDijkstra法で求め、そのときに使った辺のみから\n * なるDAGを構成する。\n * すると、cからdに最短経路で行けるかの判定は、このDAG上でcからdに行けるかの\n * 判定と等価になる。\n * 1クエリについて最悪全ノードの探索が必要で、これはO(N+M)になるが、\n * 到達可能かどうかは1bitしか使わないのでbit parallelで高速化ができる。\n * (N+M) × Q = 10^10 程度なので、数十倍程度の高速化をすれば制限時間に間に合う。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<128> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    array<int, 100000> ref_cnt;\n    {\n        array<bool, 100000> visited;\n        fill(visited.begin(), visited.end(), false);\n        fill(ref_cnt.begin(), ref_cnt.end(), 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 128> dest;\n    for(int i = 0; i < Q; ) {\n        for(auto &f : reachable) {\n            f.reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 128 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    for(long long &i = come[now];i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    fill(come, come + 105000, false);\n    dfs(a);\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nbool come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    if(come[now])return;\n    come[now] = true;\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\nfill(come, come + 105000, false);\n    dfs(a);\n    long long c[64], d[65];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 3000 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 3000){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 3000);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j].none())continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, b, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <bitset>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef unsigned long long int ull;\n#define pb push_back\n#define INF 1000000000\n#define fi first\n#define sec second\nint dist1[100100],dist2[100100];\nint c[40100],d[40100];\nbitset<40000> dp[100100];\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> g[100100];\nint comp(int x,int y){\n    return dist1[x]<dist1[y];\n}\nvoid dijkstra(int s,int t){\n    for(int i=0;i<100100;i++)dist1[i]=INF,dist2[i]=INF;\n    dist1[s]=0,dist2[t]=0;\n    priority_queue<P,vector<P>,greater<P> >q;\n    q.push(P(0,s));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist1[e.to]>dist1[v]+e.cost){\n                dist1[e.to] = dist1[v]+e.cost;\n                q.push(P(dist1[e.to],e.to));\n            }\n        }\n    }\n    q.push(P(0,t));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist2[e.to]>dist2[v]+e.cost){\n                dist2[e.to] = dist2[v]+e.cost;\n                q.push(P(dist2[e.to],e.to));\n            }\n        }\n    }\n    return;\n}\nint S,R,Q;\nint a,b;\nint main(){\n    scanf(\"%d %d\",&S,&R);\n    for(int i=0;i<R;i++){\n        int u,v,w;\n        scanf(\"%d %d %d\",&u,&v,&w);\n        u--;v--;\n        g[u].pb(edge(v,w));\n        g[v].pb(edge(u,w));\n    }\n    scanf(\"%d %d %d\",&a,&b,&Q);\n    a--;b--;\n    dijkstra(a,b);\n    /*for(int i=0;i<S;i++)\n    {\n        cout << dist1[i] << ' ' << dist2[i] << endl;\n    }*/\n    vector<int> tp;\n    for(int i=0;i<S;i++)tp.pb(i);\n    sort(tp.begin(),tp.end(),comp);\n    //for(int i=0;i<S;i++)cout << tp[i] << ' ';\n    for(int i=0;i<Q;i++){\n    \tscanf(\"%d %d\",&c[i],&d[i]);\n    \tc[i]--; d[i]--;\n    \tdp[c[i]].set(i);\n    }\n    for(int j=0;j<S;j++){\n        int f = tp[j];\n        if(dist1[f]+dist2[f]!=dist1[b])continue;\n        for(int k=0;k<g[f].size();k++){\n            edge e = g[f][k];\n            if(dist1[e.to]+dist2[e.to]!=dist1[b])continue;\n            if(dist1[e.to]!=dist1[f]+e.cost)continue;\n            dp[e.to]|=dp[f];\n        }\n    }\n    for(int i=0;i<Q;i++){\n    \tif(dp[d[i]][i])printf(\"Yes\\n\");\n    \telse printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level:\n//Category:\n//Note:\n\n/**\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    array<int, 100000> ref_cnt;\n    fill(ref_cnt.begin(), ref_cnt.end(), 0);\n    for(int i = 0; i < S; ++i) {\n        for(int to : dag[i]) {\n            ref_cnt[to]++;\n        }\n    }\n    // Determine reachability for each query\n    array<ULL, 100000> reachable;\n    array<int, 70> dest;\n    for(int i = 0; i < Q; ) {\n        fill(reachable.begin(), reachable.end(), 0);\n        int cnt = 0;\n        for(int j = 0; j < 64 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d] |= 1<<j;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]] & (1<<j)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 3000 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 3000){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 3000);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j].none())continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nconst int INF=1001001001;\nint N,M;\nint S,T,Q;\nvector<edge>G[100000];\nvector<int>L[100000];\nint dist[100000];\nbool used[100000];\nunsigned long long dp[100000];\nvector<int>ord;\nvoid dijkstra(){\n    fill_n(dist,N,INF);\n    dist[S]=0;\n    priority_queue<P,vector<P>,greater<P> >que;\n    que.push(P(0,S));\n\n    while(que.size()){\n        P p=que.top();que.pop();\n        if(dist[p.second]<p.first)continue;\n        for(int i=0;i<G[p.second].size();i++){\n            edge &e=G[p.second][i];\n            if(dist[e.to]<=p.first+e.cost)continue;\n            dist[e.to]=p.first+e.cost;\n            que.push(P(dist[e.to],e.to));\n        }\n    }\n}\n\nvoid dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to])continue;\n        dfs(e.to);\n    }\n    ord.push_back(v);\n}\n\nvoid build(){\n    queue<int>que;\n    que.push(T);\n    fill_n(used,N,false);\n    used[T]=true;\n    while(que.size()){\n        int pos=que.front();que.pop();\n        for(int i=0;i<G[pos].size();i++){\n            edge &e=G[pos][i];\n            if(dist[e.to]+e.cost==dist[pos]){\n                L[e.to].push_back(pos);\n                if(!used[e.to]){\n                    used[e.to]=true;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&M);\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        a--;b--;\n        G[a].push_back(edge(b,c));\n        G[b].push_back(edge(a,c));\n    }\n    scanf(\"%d%d%d\",&S,&T,&Q);\n    S--;T--;\n\n    dijkstra();\n    for(int i=0;i<N;i++)if(!used[i])dfs(i);\n    reverse(ord.begin(),ord.end());\n    build();\n    for(int i=0;i<N;i++){\n        for(int j=0;j<L[i].size();j++){\n            cout<<i+1<<\" \"<<L[i][j]+1<<endl;\n        }\n    }\n\n    for(int i=0;i<(Q+63)/64;i++){\n        int a[64],b[64];\n        int lim=min(64,Q-i*64);\n        fill_n(dp,N,0);\n        for(int j=0;j<lim;j++){\n            scanf(\"%d%d\",&a[j],&b[j]);\n            a[j]--;b[j]--;\n            dp[a[j]]|=(1ll<<j);\n        }\n        for(int j=0;j<N;j++){\n            int v=ord[j];\n            for(int k=0;k<L[v].size();k++){\n                int to=L[v][k];\n                dp[to]|=dp[v];\n            }\n        }\n\n        for(int j=0;j<lim;j++){\n            if(dp[b[j]]>>j&1)puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n    Edge(int t, int w) :to(t), weight(w) {}\n};\n\nvoid restore(vector<set<int>>& edge, const vector<set<int>>& previous, const int current) {\n    for(const auto& i: previous[current]) {\n        if(edge[i].count(current)) continue;\n        edge[i].insert(current);\n        restore(edge, previous, i);\n    }\n}\n\nint main() {\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n\n    // Dijkstra\n    typedef tuple<int, int, int> Node;\n\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    vector<int> distance(S, INT_MAX);\n    vector<set<int>> previous(S);\n\n    for(q.emplace(0, a, a); !q.empty(); q.pop()) {\n        int cost, id, prev;\n        tie(cost, id, prev) = q.top();\n\n        if(distance[id] == cost) previous[id].insert(prev);\n        if(distance[id] <= cost) continue;\n        if(id != prev) previous[id] = {prev};\n        distance[id] = cost;\n\n        for(const auto& e: original[id]) q.emplace(cost + e.weight, e.to, id);\n    }\n\n    // DAG\n    vector<set<int>> edge(S);\n    restore(edge, previous, b);\n\n    // topological sort\n    vector<int> order;\n    vector<bool> visited(S, false);\n    queue<int> q2;\n    q2.push(a);\n    while(!q2.empty()) {\n        int v = q2.front();\n        q2.pop();\n        if(visited[v]) continue;\n        visited[v] = true;\n        order.push_back(v);\n        for(const auto& i: edge[v]) q2.push(i);\n    }\n\n    // DP\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n\n        vector<unsigned long long int> dp(S, 0);\n        dp[c] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) {\n            dp[to] |= dp[from];\n        }\n        if(distance[b] == INT_MAX) cout << \"No\" << endl;\n        else                       cout << (dp[d] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1ull << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> T round_up(T a, T b) { return (a + b - 1) / b; }\n\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\nbool topo_dfs(int v, const vector<vector<int> >& g, vector<int>& color, vector<int>& order)\n{\n    color[v] = 1;\n    for (int i = 0; i < (int)g[v].size(); ++i)\n    {\n        int to = g[v][i];\n        if (color[to] == 2)\n            continue;\n        else if (color[to] == 1)\n            return false;\n        else if (!topo_dfs(to, g, color, order))\n            return false;\n    }\n    color[v] = 2;\n\n    order.push_back(v);\n    return true;\n}\n// O(V + E)\n// impossible -> return empty vector\nvector<int> topological_sort(const vector<vector<int> >& g)\n{\n    const int n = g.size();\n\n    vector<int> color(n);\n    vector<int> order;\n\n    for (int i = 0; i < n; ++i)\n        if (color[i] == 0 && !topo_dfs(i, g, color, order))\n            return vector<int>();\n    reverse(all(order));\n    return order;\n}\n\nint main()\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    vector<pint> g[ten(5)];\n    rep(i, m)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        --u, --v;\n        g[u].pb(pint(v, w));\n        g[v].pb(pint(u, w));\n    }\n\n    int a, b, Q;\n    scanf(\"%d%d%d\", &a, &b, &Q);\n    --a, --b;\n\n    // 最短経路グラフを作るためにdijkstraします\n    vector<int> prev[ten(5)];\n    int dis[ten(5)];\n    {\n        const int inf = ten(9);\n        priority_queue<pint, vector<pint>, greater<pint> > q;\n\n        fill_n(dis, n, inf);\n        dis[a] = 0;\n        q.push(pint(0, a));\n        while (!q.empty())\n        {\n            int cost = q.top().first;\n            int v = q.top().second;\n            q.pop();\n\n            if (cost > dis[v])\n                continue;\n\n            rep(i, g[v].size())\n            {\n                int to = g[v][i].first;\n                int ncost = cost + g[v][i].second;\n                if (ncost < dis[to])\n                {\n                    dis[to] = ncost;\n                    q.push(pint(ncost, to));\n\n                    prev[to].clear();\n                }\n\n                if (ncost == dis[to])\n                    prev[to].pb(v);\n            }\n        }\n    }\n\n\n    // 最短経路グラフを作ります\n    vector<vector<int> > min_g(n);\n    {\n        queue<int> q;\n        bool visit[ten(5)];\n        fill_n(visit, n, false);\n\n        visit[b] = true;\n        q.push(b);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n\n            rep(i, prev[v].size())\n            {\n                int pre = prev[v][i];\n\n                min_g[pre].pb(v);\n\n                if (!visit[pre])\n                    q.push(pre);\n            }\n        }\n    }\n\n    vector<int> order = topological_sort(min_g);\n    assert(!order.empty());\n\n    // O((Q / 64) * (V + E))\n    while (Q > 0)\n    {\n        typedef unsigned long long ull;\n\n        // 64クエリ or クエリがなくなるまで先読みします\n        vector<int> c, d;\n        while (c.size() < 64 && Q > 0)\n        {\n            --Q;\n            int cc, dd;\n            scanf(\"%d%d\", &cc, &dd);\n            --cc, --dd;\n            c.pb(cc), d.pb(dd);\n        }\n\n        // dp[v]のi bit目が立っている時，c[i] -> vは最短経路上で到達可能\n        ull dp[ten(5)];\n        fill_n(dp, n, 0);\n        rep(i, c.size())\n            dp[c[i]] |= bin(i);\n\n        rep(i, order.size())\n        {\n            int v = order[i];\n            rep(j, min_g[v].size())\n                dp[min_g[v][j]] |= dp[v];\n        }\n\n        rep(i, c.size())\n            puts((dp[d[i]] >> i & 1) ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<stack>\nusing namespace std;\ntypedef unsigned long long ull;\n\n#define NMAX 100000\n#define EMAX 200000\n#define INFTY (1<<21)\n#define LIM 64\nvector<pair<int, int> > G[NMAX];  \nvector<int> DAG[NMAX];  \nvector<int> PI[NMAX];\n\nvoid dijkstra(int n, int a, int b){\n  priority_queue<pair<int, int> > PQ;\n  int d[NMAX];\n  bool vis[NMAX];\n  for ( int i = 0; i < n; i++ ){\n    d[i] = INFTY;\n    vis[i] = false;\n    PI[i].clear();\n  }\n  d[a] = 0;\n  PQ.push(make_pair(0, a));\n  \n  pair<int, int> cur;\n  int u, v, w, nw;\n  while(!PQ.empty()){\n    cur = PQ.top(); PQ.pop();\n    u = cur.second;\n    w = cur.first*(-1);\n    vis[u] = true;\n    for ( int i = 0; i < G[u].size(); i++ ){\n      v = G[u][i].first;\n      nw = G[u][i].second;\n      if ( vis[v] ) continue;\n      if ( d[v] == d[u] + nw ){\n\tPI[v].push_back(u);\n      } else if ( d[v] > d[u] + nw ){\n\tPI[v].clear();\n\tPI[v].push_back(u);\n\td[v] = d[u] + nw;\n\tPQ.push(make_pair((-1)*d[v], v));\n      }\n    }\n  }\n}\n\nvoid makeDag(int n, int u){\n  bool vis[NMAX];\n  for ( int i = 0; i < n; i++ ) {\n    DAG[i].clear();\n    vis[i] = false;\n  }\n  stack<int> st; st.push(u);\n  vis[u] = true;\n  while(!st.empty()){\n    u = st.top(); st.pop();\n    for ( int i = 0; i < PI[u].size(); i++ ) DAG[PI[u][i]].push_back(u);\n    for ( int i = 0; i < PI[u].size(); i++ ){    \n      int v = PI[u][i];\n      if ( !vis[v] ){\n\tvis[v] = true;\n\tst.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort(int n, int s, int order[NMAX]){\n  int indeg[NMAX];\n  for ( int i = 0; i < n; i++ ) {\n    indeg[i] = 0;\n    order[i] = INFTY;\n  }\n  \n  for ( int u = 0; u < n; u++ ){\n    for ( int i = 0; i < DAG[u].size(); i++ ){\n      int v = DAG[u][i];\n      indeg[v]++;\n    }\n  }\n\n  int pos = 0;\n  queue<int> q;\n  q.push(s);\n  for (; !q.empty(); ){\n    int u = q.front(); q.pop();\n    order[u] = pos;\n    pos++;\n    for ( int i = 0; i < DAG[u].size(); i++ ){\n      int v = DAG[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 ){\n\tq.push(v);\n      }\n    }\n  }\n}\n\nvoid valid(int n, int nedge, int sources[], int targets[], int bit, int qs[], int qt[], bool ans[]){\n  static ull dp[NMAX];\n  for ( int i = 0; i < n; i++ ) dp[i] = 0;\n  for ( int i = 0; i < bit; i++ ){\n    dp[qs[i]] |= ( 1ULL << i);\n  }\n  \n  for ( int i = 0; i < nedge; i++ ){\n    dp[targets[i]] |= dp[sources[i]];\n  }\n\n  for ( int i = 0; i < bit; i++ ){\n    ans[i] = dp[qt[i]] & ( 1ULL << i);\n  }\n}\n\nmain(){\n  int n, e, q, a, b, u, v, w;\n  scanf(\"%d %d\", &n, &e);\n  for ( int i = 0; i < e; i++ ){\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    G[u].push_back(make_pair(v, w));\n    G[v].push_back(make_pair(u, w));\n  }\n  scanf(\"%d %d %d\", &a, &b, &q);\n  a--; b--;\n\n  dijkstra(n, a, b);\n\n  makeDag(n, b);\n\n  int order[NMAX];\n\n  tsort(n, a, order);\n  \n  vector<pair<int, int> > torder_with_index(n);\n  for ( int i = 0; i < n; i++ ) torder_with_index[i] = make_pair(order[i], i);\n  sort( torder_with_index.begin(), torder_with_index.end());\n  static int sources[EMAX];\n  static int targets[EMAX];\n  int nedge = 0;\n  for ( int i = 0; i < n; i++ ){\n    if ( torder_with_index[i].first == INFTY ) break;\n    u = torder_with_index[i].second;\n    for ( int j = 0; j < DAG[u].size(); j++ ){\n      v = DAG[u][j];\n      sources[nedge] = u;\n      targets[nedge] = v;\n      nedge++;\n    }\n  }\n\n  static int qs[NMAX], qt[NMAX];\n  static bool ans[NMAX];\n  for(int nquery = 0; nquery < q;){\n    int bit;\n    for ( bit = 0; bit < LIM && nquery < q; bit++, nquery++ ){\n      scanf(\"%d %d\", &qs[bit], &qt[bit]);\n      qs[bit]--; qt[bit]--;\n    }\n    valid(n, nedge, sources, targets, bit, qs, qt, ans);\n    for ( int i = 0; i < bit; i++ ){\n      if ( ans[i] ) printf(\"Yes\\n\");\n      else printf(\"No\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace EGraph{\n\ttypedef ll Cost;Cost CINF=1LL<<56;\n\tstruct Edge{\n\t\tint from,to;Cost cost;\n\t\tEdge(int from,int to,Cost cost)\n\t\t: from(from),to(to),cost(cost) {};\n\t\tbool operator<(Edge r) const{\n\t\t\treturn cost<r.cost;\n\t\t}\n\t\tbool operator>(Edge r) const{\n\t\t\treturn cost>r.cost;\n\t\t}\n\t};\n\ttypedef vector<vector<Edge> >  Graph;\n}\n\nnamespace ShortestPath{\n    using namespace EGraph;\n\n    struct Task{\n        int prev,pos;Cost cost;\n        Task(int prev,int pos,Cost cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n \n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<Cost> bellmanFord(Graph g,int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge& e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-CINF;\n                }\n            }\n        }\n        return d;\n    }\n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<Cost> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<Cost> d(V,CINF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<Cost> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n}\n\nusing namespace ShortestPath;\n\n\nll MOD=1000000007;\n\nclass Main{\npublic:\n\t\n\tvoid run(){\n\t\tint S,R;scanf(\"%d%d\",&S,&R);\n\t\tGraph g(S);\n\t\tREP(i,R){\n\t\t\tint u,v,w;scanf(\"%d%d%d\",&u,&v,&w);u--;v--;\n\t\t\tg[u].push_back(Edge(u,v,w));\n\t\t\tg[v].push_back(Edge(v,u,w));\n\t\t}\n\n\t\tint a,b,Q;scanf(\"%d%d%d\",&a,&b,&Q);a--;b--;\n\t\tvector<Cost> ads=dijkstra(g, a),bds=dijkstra(g, b);\n\t\tREP(q,Q){\n\t\t\tint c,d;scanf(\"%d%d\",&c,&d);c--;d--;\n\t\t\tif(ads[d]+bds[d]==ads[c]+bds[c]){\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t}else{\n\t\t\t\tcout<<\"No\"<<endl;\t\t\n\t\t\t}\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[40000];\nint dp[40000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tans[i] = (dp[pos[qt[i]]] & (1ull << i)) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += 64){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i]);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\t\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (weight[x.to] <= x.cost) continue;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t}\n\t}\n\t\n\tqueue<int> q;\n\tbool done[100000] = {0};\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tif (done[x]) continue;\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t}\n\t\t}\n\t\tdone[x] = true;\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tif (!vis[i]) dfs(i);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tmemset(accessable, 0, sizeof(accessable));\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\n    const int BIT = 64;\nstruct Edge {\n    int to, weight;\n    Edge(const int to, const int weight) :to(to), weight(weight) {}\n};\n\n// const vector<set<int>> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n//     const int INF = INT_MAX;\n//     struct Node {\n//         int vertex;\n//         int cost;\n//         vector<int> path;\n//         Node(const int v, const int c, const vector<int>& p) :vertex(v), cost(c), path(p) {}\n//         bool operator<(const Node& n) const {return cost > n.cost;}\n//     };\n//     vector<set<int>> result(edge.size());\n//     vector<int> distance(edge.size(), INF);\n//     priority_queue<Node> q;\n//     for(q.emplace(start, 0, vector<int>()); !q.empty(); q.pop()) {\n//         auto v = q.top().vertex;\n//         auto cost = q.top().cost;\n//         auto path = q.top().path;\n//         path.push_back(v);\n//         if(v == goal && cost <= distance[v]) for(int i = 1; i < path.size(); ++i) result[path[i - 1]].insert(path[i]);\n// //         if(distance[v] != INF) continue;\n//         if(distance[goal] <= cost) continue;\n//         distance[v] = cost;\n//         for(const auto& e: edge[v]) q.emplace(e.to, cost + e.weight, path);\n//     }\n//     return result;\n// }\n\n// void dfs(vector<int>& result, const vector<set<int>>& edge, const int v, vector<bool> &visited) {\n//     if(visited[v]) return;\n//     visited[v] = true;\n//     for(const auto& to: edge[v]) dfs(result, edge, to, visited);\n//     result.push_back(v);\n// }\n// const vector<int> topological_sort(const vector<set<int>>& edge, const int start) {\n//     vector<int> result;\n//     vector<bool> visited(edge.size(), false);\n//     dfs(result, edge, start, visited);\n//     reverse(result.begin(), result.end());\n//     return result;\n// }\n\nconst vector<set<int>> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n    const int INF = INT_MAX;\n    struct Node {\n        int vertex;\n        int cost;\n        vector<int> path;\n        Node(const int v, const int c, const vector<int>& p) :vertex(v), cost(c), path(p) {}\n        bool operator<(const Node& n) const {return cost > n.cost;}\n    };\n\n    vector<set<int>> result(edge.size());\n    vector<int> distance(edge.size(), INF);\n    priority_queue<Node> q;\n    for(q.emplace(start, 0, vector<int>()); !q.empty(); q.pop()) {\n        auto v = q.top().vertex;\n        auto cost = q.top().cost;\n        auto path = q.top().path;\n        path.push_back(v);\n        if(v == goal && cost <= distance[v]) for(int i = 1; i < path.size(); ++i) result[path[i]].insert(path[i - 1]);\n        if(distance[goal] <= cost) continue;\n        distance[v] = cost;\n        for(const auto& e: edge[v]) q.emplace(e.to, cost + e.weight, path);\n    }\n    return result;\n}\n\nvoid dfs(vector<int>& result, const vector<set<int>>& edge, const int v, vector<bool> &visited) {\n    if(visited[v]) return;\n    visited[v] = true;\n    for(const auto& to: edge[v]) dfs(result, edge, to, visited);\n    result.push_back(v);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    dfs(result, edge, goal, visited);\n    return result;\n}\n\nbitset<BIT> check(vector<bitset<BIT>>& dp, const vector<set<int>>& edge, const int v, vector<bool> &visited) {\n    if(visited[v]) return dp[v];\n    visited[v] = true;\n    for(const auto& to: edge[v]) dp[v] |= check(dp, edge, to, visited);\n    return dp[v];\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(const int begin, const int end) :begin(begin), end(end) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n    cin >> S >> R;\n    vector<vector<Edge>> original(S);\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n    }\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = Dijkstra(original, a, b);\n//     auto order = topological_sort(edge, a);\n\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S);\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n//         for(const auto& from: order) for(const auto& to: edge[from]) dp[to] = dp[to] | dp[from];\n        vector<bool>visited(S,false);\n        check(dp, edge, b, visited);\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nconst int INF=1001001001;\nint N,M;\nint S,T,Q;\nvector<edge>G[100000];\nvector<int>L[100000];\nint dist[100000];\nbool used[100000];\nint par[20][100000];\nint depth[100000];\nvoid dijkstra(){\n    fill_n(dist,N,INF);\n    dist[S]=0;\n    priority_queue<P,vector<P>,greater<P> >que;\n    que.push(P(0,S));\n\n    while(que.size()){\n        P p=que.top();que.pop();\n        if(dist[p.second]<p.first)continue;\n        for(int i=0;i<G[p.second].size();i++){\n            edge &e=G[p.second][i];\n            if(dist[e.to]<=p.first+e.cost)continue;\n            dist[e.to]=p.first+e.cost;\n            que.push(P(dist[e.to],e.to));\n        }\n    }\n}\n\nvoid build(){\n    fill_n(*par,20*100000,-1);\n    queue<int>que;\n    que.push(T);\n    used[T]=true;\n    while(que.size()){\n        int pos=que.front();que.pop();\n        for(int i=0;i<G[pos].size();i++){\n            edge &e=G[pos][i];\n            if(dist[e.to]+e.cost==dist[pos]){\n                L[e.to].push_back(pos);\n                par[0][pos]=e.to;\n                if(!used[e.to]){\n                    used[e.to]=true;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    for(int i=1;i<20;i++){\n        for(int j=0;j<N;j++){\n            if(par[i-1][j]==-1)continue;\n            par[i][j]=par[i-1][par[i-1][j]];\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&M);\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        a--;b--;\n        G[a].push_back(edge(b,c));\n        G[b].push_back(edge(a,c));\n    }\n    scanf(\"%d%d%d\",&S,&T,&Q);\n    S--;T--;\n\n    dijkstra();\n    build();\n\n\n    while(Q--){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        if(!used[a]||!used[b]||dist[a]>=dist[b]){\n            cout<<\"No\"<<endl;\n            continue;\n        }\n\n        for(int i=19;i>=0;i--){\n            if(par[i][b]==-1)continue;\n            int c=par[i][b];\n            if(dist[c]<dist[a])continue;\n            b=c;\n        }\n\n        if(a!=b)cout<<\"No\"<<endl;\n        else cout<<\"Yes\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {int from, to, weight;};\nstruct Query {int from, to;};\n\nvector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n    typedef tuple<int, int> Node;\n    const int INF = INT_MAX >> 1;\n\n    vector<int> cost(edge.size(), INF);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.emplace(0, start);\n    while(!q.empty()) {\n        int c, v;\n        tie(c, v) = q.top();\n        q.pop();\n        if(cost[v] != INF) continue;\n        cost[v] = c;\n        if(v == goal) break;\n        for(const auto& e: edge[v]) if(cost[e.to] == INF) q.emplace(c + e.weight, e.to);\n    }\n    return cost;\n}\n\nvector<vector<int>> optimize(const vector<vector<Edge>>& edge, const vector<int>& cost, const int start, const int goal) {\n    vector<vector<int>> outedge(edge.size());\n    vector<vector<int>> inedge(edge.size());\n    for(const auto& list: edge) for(const auto& e: list) {\n        if(cost[e.from] + e.weight > cost[e.to]) continue;\n        outedge[e.from].push_back(e.to);\n        inedge[e.to].push_back(e.from);\n    }\n\n    typedef tuple<int, int> Node;\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    for(int v = 0; v < edge.size(); ++v) q.emplace(outedge[v].size(), v);\n    vector<bool> visited(edge.size(), false);\n    while(!q.empty()) {\n        int outdegree, v;\n        tie(outdegree, v) = q.top();\n        q.pop();\n        if(outdegree) break;\n        if(visited[v]) continue;\n        visited[v] = true;\n        if(v == start || v == goal) continue;\n        for(const auto& i: inedge[v]) {\n            outedge[i].erase(find(outedge[i].begin(), outedge[i].end(), v));    // → ここではフラグだけ付けておいて、後で構築しなおしたほうが早いかもしれない\n            q.emplace(outedge[i].size(), i);\n        }\n    }\n    return outedge;\n}\n\nvoid dfs(const vector<vector<int>>& edge, const int v, vector<bool>& visited, vector<int>& order) {\n    if(visited[v]) return;\n    visited[v] = true;\n    for(const auto& to: edge[v]) dfs(edge, to, visited, order);\n    order.push_back(v);\n}\n\nvector<int> topological_sort(const vector<vector<int>>& edge, const int start, const int goal) {\n    vector<int> order;\n    vector<bool>visited(edge.size(), false);\n    dfs(edge, start, visited, order);\n    reverse(order.begin(), order.end());\n    return order;\n}\n\nint main() {\n    int S, R;\n    cin >> S >> R;\n\n    vector<vector<Edge>> edge(S);\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        edge[u].push_back({u, v, w});\n        edge[v].push_back({v, u, w});\n    }\n\n    int a, b;\n    cin >> a >> b;\n    --a; --b;\n\n    int Q;\n    cin >> Q;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        query.push_back({--c, --d});\n    }\n\n    auto cost = Dijkstra(edge, a, b);\n    auto optimized_edge = optimize(edge, cost, a, b);\n    auto order = topological_sort(optimized_edge, a, b);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S);\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].from].set(j);\n        for(const auto& from: order) for(const auto& to: optimized_edge[from]) dp[to] = dp[to] | dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].to].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[100000];\nint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tassert(pos[to] > i);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tans[i] = ((dp[pos[qt[i]]] & (1ull << i)) > 0ull) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += 64){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second;\n\tif(dist[from] < tmp.first)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long tw = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] > dist[from] + tw){\n\t\tdist[to] = dist[from] + tw;\n\t\tpq.push(P(dist[to], to));\n\t    }\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return adist[b] - bdist[a];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\nlong **dd,*n,*a,*b,s,r,u,v,w,q,c,d,i,j,jj,mn,inf,ss;\ncin>>s>>r;\ninf=r*1001;\ndd=new long*[s+1];\nfor(i=1;i<=s;i++){\ndd[i]=new long[s+1];\nfor(j=1;j<=s;j++)dd[i][j]=0;\n}\nn=new long[s+1];\na=new long[s+1];\nb=new long[s+1];\nfor(i=1;i<=s;i++){a[i]=inf;b[i]=0;}\nfor(i=0;i<r;i++){cin>>u>>v>>w;dd[u][v]=w;}\ncin>>u>>v>>q;\na[v]=0;jj=0;\nwhile(1){\nmn=inf;\nfor(i=1;i<=s;i++){\nif(!b[i]&&mn>a[i]){mn=a[i];j=i;}\n}\nn[j]=jj;jj=j;b[j]=1;\nif(mn==inf)break;\nfor(i=1;i<=s;i++){\nif(dd[i][j]>0&&a[i]>dd[i][j]+a[j]){a[i]=dd[i][j]+a[j];}\n}\n}\nj=u;\nfor(i=1;i<=s;i++){b[i]=j;if(j==v)break;j=n[j];}\nss=i;\nfor(i=0;i<q;i++){\ncin>>c>>d;\nfor(j=1;j<=ss;j++)if(b[j]==c)break;\nfor(;j<=ss;j++)if(b[j]==d)break;\nif(j>ss)cout<<\"No\"<<endl;else cout<<\"Yes\"<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[100000];\nint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tans[i] = ((dp[pos[qt[i]]] & (1ull << i)) > 0ull) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += 64){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\n\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    long long c[64], d[65];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1 << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1 << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<int>& memo) {\n    if(start == goal) return true;\n    if(memo[start] != NIL) return true;\n    memo[start] = 0;\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n        memo[start] = 1;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<int> memo(edge.size(), NIL);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    for(int i = 0; i < edge.size(); ++i) ts_dfs(result, edge, visited, i);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(int b, int e) :begin(b), end(e) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S, bitset<BIT>());\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<bool>& memo) {\n    if(start == goal) return true;\n    if(memo[start]) return true;\n\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n\n        memo[start] = true;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\n\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<bool> memo(edge.size(), false);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n// const vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n//     vector<int> order;\n//     queue<int> q;\n//     vector<bool> visited(edge.size(), false);\n// \n//     for(q.push(start); !q.empty(); q.pop()) {\n//         int current = q.front();\n// \n//         if(visited[current]) continue;\n//         visited[current] = true;\n// \n//         order.push_back(current);\n//         for(const auto& to: edge[current]) q.push(to);\n//     }\n// \n//     return order;\n// }\n\nint main() {\n    struct Query {int begin, end;};\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query(Q);\n    for(auto& q: query) cin >> q.begin >> q.end;\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    for(const auto& q: query) {\n        vector<unsigned long long int> dp(S, 0);\n        dp[q.begin - 1] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        cout << (dp[q.end - 1] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[40000];\nint dp[40000];\nulint ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], ulint ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tans[i] = dp[pos[qt[i]]] & (1ull << i);\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += 64){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level: 4\n//Category: グラフ,Graph,最短経路,DAG\n//Note:\n\n/**\n * AからBまでの最短経路をDijkstra法で求め、そのときに使った辺のみから\n * なるDAGを構成する。\n * すると、cからdに最短経路で行けるかの判定は、このDAG上でcからdに行けるかの\n * 判定と等価になる。\n * 1クエリについて最悪全ノードの探索が必要で、これはO(N+M)になるが、\n * 到達可能かどうかは1bitしか使わないのでbit parallelで高速化ができる。\n * (N+M) × Q = 10^10 程度なので、数十倍程度の高速化をすれば制限時間に間に合う。\n *\n * オーダーは O(N log R + (N+M)Q)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<128> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].emplace_back(v, w);\n        graph[v].emplace_back(u, w);\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill_n(memo.begin(), S, INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    vector<int> ord;\n    {\n        array<int, 100000> ref_cnt;\n        array<bool, 100000> visited;\n        fill_n(visited.begin(), S, false);\n        fill_n(ref_cnt.begin(), S, 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            ord.push_back(cur);\n            q.pop();\n            for(int to : dag[cur]) {\n                if(--ref_cnt[to] == 0) {\n                    q.push(to);\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 128> dest;\n    for(int i = 0; i < Q; ) {\n        for(int v : ord) {\n            reachable[v].reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 128 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        for(int v : ord) {\n            for(int next : dag[v]) {\n                reachable[next] |= reachable[v];\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n\n#define NMAX 100000\n#define EMAX 200000\n#define INFTY (1<<21)\n#define LIM 64\nvector<pair<int, int> > G[NMAX];\nvector<int> DAG[NMAX];\nvector<int> PI[NMAX];\n\nvoid dijkstra(int n, int a, int b){\n\tpriority_queue<pair<int, int> > PQ;\n    int d[NMAX];\n    bool vis[NMAX];\n    for ( int i = 0; i < n; i++ ){\n    d[i] = INFTY;\n    vis[i] = false;\n    PI[i].clear();\n  }\n  d[a] = 0;\n  PQ.push(make_pair(0, a));\n\n  pair<int, int> cur;\n  int u, v, w, nw;\n  while(!PQ.empty()){\n    cur = PQ.top(); PQ.pop();\n  u= cur.second;\n    w = cur.first*(-1);\n    vis[u] = true;\n    for ( int i = 0; i < G[u].size(); i++ ){\n      v = G[u][i].first;\n      nw = G[u][i].second;\n      if ( vis[v] ) continue;\n      if ( d[v] == d[u] + nw ){\n    PI[v].push_back(u);\n      } else if ( d[v] > d[u] + nw ){\n    PI[v].clear();\n    PI[v].push_back(u);\n    d[v] = d[u] + nw;\n    PQ.push(make_pair((-1)*d[v], v));\n      }\n    }\n  }\n}\n\nvoid makeDag(int n, int u){\n  bool vis[NMAX];\n  for ( int i = 0; i < n; i++ ) {\n    DAG[i].clear();\n    vis[i] = false;\n  }\n  stack<int> st; st.push(u);\n  vis[u] = true;\n  while(!st.empty()){\n    u = st.top(); st.pop();\n    for ( int i = 0; i < PI[u].size(); i++ ) DAG[PI[u][i]].push_back(u);\n    for ( int i = 0; i < PI[u].size(); i++ ){\n      int v = PI[u][i];\n      if ( !vis[v] ){\n    vis[v] = true;\n    st.push(v);\n      }\n    }\n  }\n}\n\nvoid tsort(int n, int s, int order[NMAX]){\n  int indeg[NMAX];\n  for ( int i = 0; i < n; i++ ) {\n    indeg[i] = 0;\n    order[i] = INFTY;\n  }\n\n  for ( int u = 0; u < n; u++ ){\n    for ( int i = 0; i < DAG[u].size(); i++ ){\n      int v = DAG[u][i];\n      indeg[v]++;\n    }\n  }\n\n  int pos = 0;\n  queue<int> q;\n  q.push(s);\n  for (; !q.empty(); ){\n    int u = q.front(); q.pop();\n    order[u] = pos;\n    pos++;\n    for ( int i = 0; i < DAG[u].size(); i++ ){\n      int v = DAG[u][i];\n      indeg[v]--;\n      if ( indeg[v] == 0 ){\n    q.push(v);\n      }\n    }\n  }\n}\n\nvoid valid(int n, int nedge, int sources[], int targets[], int bit, int qs[], int qt[], bool ans[]){\n  static ull dp[NMAX];\n  for ( int i = 0; i < n; i++ ) dp[i] = 0;\n  for ( int i = 0; i < bit; i++ ){\n    dp[qs[i]] |= ( 1ULL << i);\n  }\n\n  for ( int i = 0; i < nedge; i++ ){\n    dp[targets[i]] |= dp[sources[i]];\n  }\n\n  for ( int i = 0; i < bit; i++ ){\n    ans[i] = dp[qt[i]] & ( 1ULL << i);\n  }\n}\n\nint main(){\n  int n, e, q, a, b, u, v, w;\n  scanf(\"%d %d\", &n, &e);\n  for ( int i = 0; i < e; i++ ){\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    G[u].push_back(make_pair(v, w));\n    G[v].push_back(make_pair(u, w));\n  }\n  scanf(\"%d %d %d\", &a, &b, &q);\n  a--; b--;\n\n  dijkstra(n, a, b);\n\n  makeDag(n, b);\n\n  int order[NMAX];\n\n  tsort(n, a, order);\n\n  vector<pair<int, int> > torder_with_index(n);\n  for ( int i = 0; i < n; i++ ) torder_with_index[i] = make_pair(order[i], i);\n  sort( torder_with_index.begin(), torder_with_index.end());\n  static int sources[EMAX];\n  static int targets[EMAX];\n  int nedge = 0;\n  for ( int i = 0; i < n; i++ ){\n    if ( torder_with_index[i].first == INFTY ) break;\n    u = torder_with_index[i].second;\n    for ( int j = 0; j < DAG[u].size(); j++ ){\n      v = DAG[u][j];\n      sources[nedge] = u;\n      targets[nedge] = v;\n      nedge++;\n    }\n  }\n\n  static int qs[NMAX], qt[NMAX];\n  static bool ans[NMAX];\n  for(int nquery = 0; nquery < q;){\n    int bit;\n    for ( bit = 0; bit < LIM && nquery < q; bit++, nquery++ ){\n      scanf(\"%d %d\", &qs[bit], &qt[bit]);\n      qs[bit]--; qt[bit]--;\n    }\n    valid(n, nedge, sources, targets, bit, qs, qt, ans);\n    for ( int i = 0; i < bit; i++ ){\n      if ( ans[i] ) printf(\"Yes\\n\");\n      else printf(\"No\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost) {\n    if(start == goal) return true;\n\n    bool ok = false;\n\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight)) continue;\n\n        ok = true;\n        result[start].insert(e.to);\n    }\n\n    return ok;\n}\n\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0);\n\n    return result;\n}\n\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n// const vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n//     vector<int> order;\n//     queue<int> q;\n//     vector<bool> visited(edge.size(), false);\n// \n//     for(q.push(start); !q.empty(); q.pop()) {\n//         int current = q.front();\n// \n//         if(visited[current]) continue;\n//         visited[current] = true;\n// \n//         order.push_back(current);\n//         for(const auto& to: edge[current]) q.push(to);\n//     }\n// \n//     return order;\n// }\n\nint main() {\n    struct Query {int begin, end;};\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query(Q);\n    for(auto& q: query) cin >> q.begin >> q.end;\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    for(const auto& q: query) {\n        vector<unsigned long long int> dp(S, 0);\n        dp[q.begin - 1] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        cout << (dp[q.end - 1] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1 << 30)\ntypedef pair<int, int> P;\n\nvector<P> valid_edge;\nint adist[105000], bdist[105000];\nvector<P> edge[105000];\n\nvoid dijkstra(int start, int *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tint from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(int i = 0;i < edge[from].size();i++){\n\t    int to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(int now){\n    for(int i = 0;i < edge[now].size();i++){\n\tint to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    int s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(int i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    int c[64], d[65];\n    long long dp[105000];\n    for(int i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(int j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1 << j);\n\t}\n\tfor(int j = 0;j < valid_edge.size();j++){\n\t    int from = valid_edge[j].first;\n\t    int to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(int j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1 << j))cout << \"YES\" << endl;\n\t    else cout << \"NO\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second;\n\tif(dist[from] < tmp.first)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long tw = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] <= dist[from] + tw)continue;\n\t    dist[to] = dist[from] + tw;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return adist[b] - bdist[a];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i]);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\t\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (weight[x.to] <= x.cost) continue;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tif (weight[TG[x.to][i].to] > x.cost + TG[x.to][i].cost){\n\t\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tqueue<int> q;\n\tbool done[100000] = {0};\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tif (done[x]) continue;\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t}\n\t\t}\n\t\tdone[x] = true;\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tif (!vis[i]) dfs(i);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tmemset(accessable, 0, sizeof(accessable));\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1ull << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> T round_up(T a, T b) { return (a + b - 1) / b; }\n\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\nbool topo_dfs(int v, const vector<vector<int> >& g, vector<int>& color, vector<int>& order)\n{\n    color[v] = 1;\n    for (int i = 0; i < (int)g[v].size(); ++i)\n    {\n        int to = g[v][i];\n        if (color[to] == 2)\n            continue;\n        else if (color[to] == 1)\n            return false;\n        else if (!topo_dfs(to, g, color, order))\n            return false;\n    }\n    color[v] = 2;\n\n    order.push_back(v);\n    return true;\n}\n// O(V + E)\n// impossible -> return empty vector\nvector<int> topological_sort(const vector<vector<int> >& g)\n{\n    const int n = g.size();\n\n    vector<int> color(n);\n    vector<int> order;\n\n    for (int i = 0; i < n; ++i)\n        if (color[i] == 0 && !topo_dfs(i, g, color, order))\n            return vector<int>();\n    reverse(all(order));\n    return order;\n}\n\nint main()\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    static vector<pint> g[ten(5)];\n    rep(i, m)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        --u, --v;\n        g[u].pb(pint(v, w));\n        g[v].pb(pint(u, w));\n    }\n\n    int a, b, Q;\n    scanf(\"%d%d%d\", &a, &b, &Q);\n    --a, --b;\n\n    // 最短経路グラフを作るためにdijkstraします\n    static vector<int> prev[ten(5)];\n    int dis[ten(5)];\n    {\n        const int inf = ten(9);\n        priority_queue<pint, vector<pint>, greater<pint> > q;\n\n        fill_n(dis, n, inf);\n        dis[a] = 0;\n        q.push(pint(0, a));\n        while (!q.empty())\n        {\n            int cost = q.top().first;\n            int v = q.top().second;\n            q.pop();\n\n            if (cost > dis[v])\n                continue;\n\n            rep(i, g[v].size())\n            {\n                int to = g[v][i].first;\n                int ncost = cost + g[v][i].second;\n                if (ncost < dis[to])\n                {\n                    dis[to] = ncost;\n                    q.push(pint(ncost, to));\n\n                    prev[to].clear();\n                }\n\n                if (ncost == dis[to])\n                    prev[to].pb(v);\n            }\n        }\n    }\n\n\n    // 最短経路グラフを作ります\n    vector<vector<int> > min_g(n);\n    {\n        queue<int> q;\n        static bool visit[ten(5)];\n        fill_n(visit, n, false);\n\n        visit[b] = true;\n        q.push(b);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n\n            rep(i, prev[v].size())\n            {\n                int pre = prev[v][i];\n\n                min_g[pre].pb(v);\n\n                if (!visit[pre])\n                {\n                    visit[pre] = true;\n                    q.push(pre);\n                }\n            }\n        }\n    }\n\n    vector<int> order = topological_sort(min_g);\n    assert(!order.empty());\n\n    // O((Q / 64) * (V + E))\n    while (Q > 0)\n    {\n        typedef unsigned long long ull;\n\n        // 64クエリ or クエリがなくなるまで先読みします\n        vector<int> c, d;\n        while (c.size() < 64 && Q > 0)\n        {\n            --Q;\n            int cc, dd;\n            scanf(\"%d%d\", &cc, &dd);\n            --cc, --dd;\n            c.pb(cc), d.pb(dd);\n        }\n\n        // dp[v]のi bit目が立っている時，c[i] -> vは最短経路上で到達可能\n        static ull dp[ten(5)];\n        fill_n(dp, n, 0);\n        rep(i, c.size())\n            dp[c[i]] |= bin(i);\n\n        rep(i, order.size())\n        {\n            int v = order[i];\n            rep(j, min_g[v].size())\n                dp[min_g[v][j]] |= dp[v];\n        }\n\n        rep(i, c.size())\n            puts((dp[d[i]] >> i & 1) ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nbool visit(const vector<vi> &g, int v, vector<int> &order, vector<int> &color) {\n  color[v] = 1;\n  for(int e : g[v]) {\n    if (color[e] == 2) continue;\n    if (color[e] == 1) return false;\n    if (!visit(g, e, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(const vector<vi> &g, vector<int> &order) {\n  int n = g.size();\n  vector<int> color(n);\n  rep(u, n) if (!color[u] && !visit(g, u, order, color))\n    return false;\n  reverse(all(order));\n  return true;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint s, r; cin >> s >> r;\n\tint S, T, Q;\n\tvector<vi> g(s);\n\t\n\t{\n\t\tvi dist(s, inf), rdist(s, inf);\n\t\tvector<vector<pi>> e(s);\n\t\trep(i, r){\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\te[a].emplace_back(b, c);\n\t\t\te[b].emplace_back(a, c);\n\t\t}\n\t\tcin >> S >> T >> Q; S--; T--;\n\t\t\n\t\tauto dij = [](int s, const vector<vector<pi>> &e, vi &dist){\n\t\t\tint n = e.size();\n\t\t\tpriority_queue<pi> q; q.emplace(0, s);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint c, d; tie(d, c) = q.top(); q.pop();\n\t\t\t\tif(dist[c] < -d) continue;\n\t\t\t\tdist[c] = -d;\n\t\t\t\tfor(pi p : e[c]){\n\t\t\t\t\tint nd = -d + p.second;\n\t\t\t\t\tif(dist[p.first] > nd){\n\t\t\t\t\t\tdist[p.first] = nd;\n\t\t\t\t\t\tq.emplace(-nd, p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdij(S, e, dist);\n\t\tdij(T, e, rdist);\n\t\t/*\n\t\tdbg(dist);\n\t\tdbg(rdist);\n\t\t*/\n\t\trep(i, s) for(pi p : e[i])\n\t\t\tif(dist[i] + p.second + rdist[p.first] == dist[T])\n\t\t\t\tg[i].pb(p.first);\n\t}\n\t//dbg(g);\n\tvi ord, rord(s);\n\ttopologicalSort(g, ord);\n\t//dbg(ord);\n\t\n\tvector<pi> in;\n\trep(it, Q){\n\t\tint a, b; cin >> a >> b; in.emplace_back(a - 1, b - 1);\n\t\tif(!(it == Q - 1 || in.size() == 64)) continue;\n\t\tvector<unsigned long long > f(s);\n\t\trep(i, in.size()) f[in[i].first] |= 1ull << i;\n\t\tfor(int i : ord) for(int j : g[i]) f[j] |= f[i];\n\t\trep(i, in.size()) cout << (f[in[i].second] >> i & 1 ? \"Yes\" : \"No\") << endl;\n\t\tin.clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n \nusing namespace std;\n \nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost) : to(to), cost(cost){}\n    Edge(){}\n};\n \nbool operator < (const Edge &a, const Edge &b)\n{\n    return (a.cost > b.cost);\n}\n \nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> NG[100000], G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n \nvoid dfs(int v)\n{\n    vis[v] = true;\n     \n    for (int i = 0; i < G[v].size(); i++)\n        if (!vis[G[v][i]]) dfs(G[v][i]);\n    topo.push_back(v);\n}\n \nint main()\n{\n    int N, M;\n     \n    scanf(\"%d %d\", &N, &M);\n     \n    for (int i = 0; i < M; i++){\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        --u; --v;\n        TG[u].push_back(Edge(v, w));\n        TG[v].push_back(Edge(u, w));\n    }\n     \n    int a, b, Q;\n     \n    scanf(\"%d %d %d\", &a, &b, &Q);\n     \n    --a; --b;\n     \n    for (int i = 0; i < Q; i++){\n        scanf(\"%d %d\", c + i, d + i);\n        --c[i]; --d[i];\n    }\n     \n    priority_queue<Edge> pq;\n    bool done[100000] = {0};\n    int weight[100000];\n    fill(weight, weight + N, 1001001001);\n     \n    for (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n        Edge x = pq.top();\n         \n        if (done[x.to]) continue;\n        done[x.to] = true;\n        weight[x.to] = x.cost;\n         \n        for (int i = 0; i < TG[x.to].size(); i++){\n            pq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n        }\n    }\n     \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < TG[i].size(); j++){\n            if (weight[TG[i][j].to] == TG[i][j].cost + weight[i]){\n                NG[TG[i][j].to].push_back(i);\n            }\n        }\n    }\n     \n    int in[100000] = {0};\n    queue<int> q;\n    memset(done, 0, sizeof(done));\n     \n    for (q.push(b); q.size(); q.pop()){\n        int x = q.front();\n        if (done[x]) continue;\n        for (int i = 0; i < NG[x].size(); i++){\n            q.push(NG[x][i]);\n            G[NG[x][i]].push_back(x);\n            in[x]++;\n        }\n        done[x] = true;\n    }\n     \n    for (int i = 0; i < N; i++){\n        if (!in[i]) dfs(i);\n    }\n    reverse(topo.begin(), topo.end());\n     \n    for (int i = 0; i < (Q + 63) / 64; i++){\n        memset(accessable, 0, sizeof(accessable));\n        for (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n            accessable[c[j]] |= (1 << (j % 64));\n        }\n        for (int j = 0; j < topo.size(); j++){\n            for (int k = 0; k < G[topo[j]].size(); k++){\n                accessable[G[topo[j]][k]] |= accessable[topo[j]];\n            }\n        }\n        for (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n            if ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1 << 30)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] < d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"YES\" << endl;\n\telse\n\t    cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i]);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tbool done[100000];\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\t\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (done[x.to]) continue;\n\t\tdone[x.to] = true;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t}\n\t}\n\t\n\tqueue<int> q;\n\tmemset(done, 0, sizeof(done));\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tif (done[x]) continue;\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t}\n\t\t}\n\t\tdone[x] = true;\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tif (!vis[i]) dfs(i);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tmemset(accessable, 0, sizeof(accessable));\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40001], qt[40001];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[40000];\nint dp[40000];\nulint ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], ulint ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tans[i] = dp[pos[qt[i]]] & (1ull << i);\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += 64){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"YES\" : \"NO\");\n\t}\n}\n\nint main()\n{\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n\tswap(u[i], v[i]);\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x> >\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tstatic bool used0[100010];\n\trep(i,100010)used0[i]=used[i];\n\t\n\trep(ppp,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\tif(!used0[e]){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tstack<int> sta;\n\t\tsta.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!sta.empty()){\n\t\t\tint x=sta.top(); sta.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\tif(d[x]<d[e]){\n\t\t\t\trrep(i,nG[x].size()){\n\t\t\t\t\tint nex=nG[x][i];\n\t\t\t\t\tif(!used[nex]){\n\t\t\t\t\t\tsta.push(nex);\n\t\t\t\t\t\tused[nex]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nconst int INF=1001001001;\nint N,M;\nint S,T,Q;\nvector<edge>G[100000];\nvector<int>L[100000];\nint dist[100000];\nbool used[100000];\nunsigned long long dp[100000];\nvector<int>ord;\nvoid dijkstra(){\n    fill_n(dist,N,INF);\n    dist[S]=0;\n    priority_queue<P,vector<P>,greater<P> >que;\n    que.push(P(0,S));\n\n    while(que.size()){\n        P p=que.top();que.pop();\n        if(dist[p.second]<p.first)continue;\n        for(int i=0;i<G[p.second].size();i++){\n            edge &e=G[p.second][i];\n            if(dist[e.to]<=p.first+e.cost)continue;\n            dist[e.to]=p.first+e.cost;\n            que.push(P(dist[e.to],e.to));\n        }\n    }\n}\n\nvoid dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to])continue;\n        dfs(e.to);\n    }\n    ord.push_back(v);\n}\n\nvoid build(){\n    queue<int>que;\n    que.push(T);\n    fill_n(used,N,false);\n    used[T]=true;\n    while(que.size()){\n        int pos=que.front();que.pop();\n        for(int i=0;i<G[pos].size();i++){\n            edge &e=G[pos][i];\n            if(dist[e.to]+e.cost==dist[pos]){\n                L[e.to].push_back(pos);\n                if(!used[e.to]){\n                    used[e.to]=true;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&M);\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        a--;b--;\n        G[a].push_back(edge(b,c));\n        G[b].push_back(edge(a,c));\n    }\n    scanf(\"%d%d%d\",&S,&T,&Q);\n    S--;T--;\n\n    dijkstra();\n    for(int i=0;i<N;i++)if(!used[i])dfs(i);\n    reverse(ord.begin(),ord.end());\n    build();\n    \n\n    for(int i=0;i<(Q+63)/64;i++){\n        int a[64],b[64];\n        int lim=min(64,Q-i*64);\n        fill_n(dp,N,0);\n        for(int j=0;j<lim;j++){\n            scanf(\"%d%d\",&a[j],&b[j]);\n            a[j]--;b[j]--;\n            dp[a[j]]|=(1ll<<j);\n        }\n        for(int j=0;j<N;j++){\n            int v=ord[j];\n            for(int k=0;k<L[v].size();k++){\n                int to=L[v][k];\n                dp[to]|=dp[v];\n            }\n        }\n\n        for(int j=0;j<lim;j++){\n            if(dp[b[j]]>>j&1)puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nbool visit(const vector<vi> &g, int v, vector<int> &order, vector<int> &color) {\n  color[v] = 1;\n  for(int e : g[v]) {\n    if (color[e] == 2) continue;\n    if (color[e] == 1) return false;\n    if (!visit(g, e, order, color)) return false;\n  }\n  order.push_back(v); color[v] = 2;\n  return true;\n}\nbool topologicalSort(const vector<vi> &g, vector<int> &order) {\n  int n = g.size();\n  vector<int> color(n);\n  rep(u, n) if (!color[u] && !visit(g, u, order, color))\n    return false;\n  reverse(all(order));\n  return true;\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint s, r; cin >> s >> r;\n\tint S, T, Q;\n\tvector<vi> g(s);\n\t{\n\t\tvi dist(s, inf), rdist(s, inf);\n\t\tvector<vector<pi>> e(s), re(s);\n\t\trep(i, r){\n\t\t\tint a, b, c; cin >> a >> b >> c; a--; b--;\n\t\t\te[a].emplace_back(b, c);\n\t\t\tre[b].emplace_back(a, c);\n\t\t}\n\t\tcin >> S >> T >> Q; S--; T--;\n\t\t\n\t\tauto dij = [](int s, const vector<vector<pi>> &e, vi &dist){\n\t\t\tint n = e.size();\n\t\t\tpriority_queue<pi> q; q.emplace(0, s);\n\t\t\twhile(!q.empty()){\n\t\t\t\tint c, d; tie(d, c) = q.top(); q.pop();\n\t\t\t\tif(dist[c] < -d) continue;\n\t\t\t\tdist[c] = -d;\n\t\t\t\tfor(pi p : e[c]){\n\t\t\t\t\tint nd = -d + p.second;\n\t\t\t\t\tif(dist[p.first] > nd){\n\t\t\t\t\t\tdist[p.first] = nd;\n\t\t\t\t\t\tq.emplace(-nd, p.first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tdij(S, e, dist);\n\t\tdij(T, re, rdist);\n\t\t/*\n\t\tdbg(dist);\n\t\tdbg(rdist);\n\t\t*/\n\t\trep(i, s) for(pi p : e[i])\n\t\t\tif(dist[i] + p.second + rdist[p.first] == dist[T])\n\t\t\t\tg[i].pb(p.first);\n\t}\n\t//dbg(g);\n\tvi ord;\n\ttopologicalSort(g, ord);\n\t\n\tvector<pi> in;\n\trep(it, Q){\n\t\tint a, b; cin >> a >> b; in.emplace_back(a - 1, b - 1);\n\t\tif(!(it == Q - 1 || in.size() == 64)) continue;\n\t\tvector<ll> f(s);\n\t\trep(i, in.size()) f[in[i].first] |= 1ull << i;\n\t\tfor(int i : ord) for(int j : g[i]) f[j] |= f[i];\n\t\trep(i, in.size()) cout << (f[in[i].second] >> i & 1 ? \"Yes\" : \"No\") << endl;\n\t\tin.clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\nconst long long int NIL = LLONG_MAX;\n\nstruct Edge {\n    long long int to, weight;\n    Edge(const long long int t, const long long int w) :to(t), weight(w) {}\n};\n\nconst vector<long long int> Dijkstra(const vector<vector<Edge>>& edge, const long long int start) {\n    typedef tuple<long long int, long long int> Node;\n\n    vector<long long int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        long long int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<long long int>>& result, const vector<vector<Edge>>& edge, const vector<long long int>& distance, const long long int start, const long long int goal, const long long int cost, vector<long long int>& memo) {\n    if(start == goal) return true;\n    if(memo[start] != NIL) return true;\n    memo[start] = 0;\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n        memo[start] = 1;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\nconst vector<set<long long int>> make_DAG(const vector<vector<Edge>>& edge,const long long int start, const long long int goal) {\n    vector<set<long long int>> result(edge.size());\n    vector<long long int> memo(edge.size(), NIL);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\nvoid ts_dfs(vector<long long int>& result, const vector<set<long long int>>& edge, vector<bool>& visited, const long long int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<long long int> topological_sort(const vector<set<long long int>>& edge, const long long int start, const long long int goal) {\n    vector<long long int> result;\n    vector<bool> visited(edge.size(), false);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\n\nint main() {\n    struct Query {\n        long long int begin, end;\n        Query(long long int b, long long int e) :begin(b), end(e) {}\n    };\n\n    long long int S, R;\n    long long int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(long long int i = 0; i < R; ++i) {\n        long long int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(long long int i = 0; i < Q; ++i) {\n        long long int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    const long long int BIT = 64;\n    for(long long int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S, bitset<BIT>(0));\n        for(long long int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        for(long long int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end][j] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 103000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nbool comp(const int &a, const int &b){\n    return adist[a] < adist[b];\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    long long c[64], d[64];\n    long long dp[105000];\n    long long topo[105000];\n    for(int i = 0;i < 105000;i++)topo[i] = i;\n    sort(topo, topo + s, comp);\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(int j = 0;j < s;j++){\n\t    if(adist[j] + bdist[j] != adist[b])continue;\n\t    for(int k = 0;k < edge[j].size();k++){\n\t\tint to = edge[j][k].first, d = edge[j][k].second;\n\t\tif(adist[to] + bdist[to] == adist[b] &&\n\t\t   adist[to] == adist[j] + d)\n\t\t    dp[to] |= dp[j];\n\t    }\n\t}\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level: 4\n//Category: グラフ,Graph,最短経路,DAG\n//Note:\n\n/**\n * AからBまでの最短経路をDijkstra法で求め、そのときに使った辺のみから\n * なるDAGを構成する。\n * すると、cからdに最短経路で行けるかの判定は、このDAG上でcからdに行けるかの\n * 判定と等価になる。\n * 1クエリについて最悪全ノードの探索が必要で、これはO(N+M)になるが、\n * 到達可能かどうかは1bitしか使わないのでbit parallelで高速化ができる。\n * (N+M) × Q = 10^10 程度なので、数十倍程度の高速化をすれば制限時間に間に合う。\n *\n * オーダーは O(N log R + (N+M)Q)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<256> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    array<int, 100000> ref_cnt;\n    {\n        array<bool, 100000> visited;\n        fill(visited.begin(), visited.end(), false);\n        fill(ref_cnt.begin(), ref_cnt.end(), 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 256> dest;\n    for(int i = 0; i < Q; ) {\n        for(auto &f : reachable) {\n            f.reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 128 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef unsigned long long wolf;\nvector<pair<int,int> > g[110000];\nvector<int> G[110000];\nint ijk[110000];\nint ijk2[110000];\nint v[110000];\nint x[41000];\nint y[41000];\nwolf L[110000];\nwolf R[110000];\nwolf tmp[110000];\npair<int ,int> r[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r;scanf(\"%d%d%d\",&p,&q,&r);\n\t\tp--;q--;\n\t\tg[p].push_back(make_pair(q,r));\n\t\tg[q].push_back(make_pair(p,r));\n\t}\n\tint c,d,e;\n\tscanf(\"%d%d%d\",&c,&d,&e);\n\tc--;d--;\n\tfor(int i=0;i<e;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tx[i]--;y[i]--;\n\t//\tL[x[i]].push_back(i);\n\t//\tR[x[i]].push_back(i);\n\t}\n\tpriority_queue<pair<int,int> >Q;\n\tQ.push(make_pair(0,c));\n\tfor(int i=0;i<a;i++)ijk[i]=ijk2[i]=999999999;\n\tijk[c]=0;\n\tijk2[d]=0;\n\twhile(Q.size()){\n\t\tint cost=-Q.top().first;\n\t\tint at=Q.top().second;\n\t\tQ.pop();\n\t\tif(v[at])continue;\n\t\tv[at]=1;\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\tQ.push(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)v[i]=0;\n\tQ.push(make_pair(0,d));\n\twhile(Q.size()){\n\t\tint cost=-Q.top().first;\n\t\tint at=Q.top().second;\n\t\tQ.pop();\n\t\tif(v[at])continue;\n\t\tv[at]=1;\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tif(!v[g[at][i].first]&&ijk2[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\tijk2[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\tQ.push(make_pair(-ijk2[g[at][i].first],g[at][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<g[i].size();j++)if(ijk[i]+g[i][j].second+ijk2[g[i][j].first]==ijk[d]){\n\t\t\tG[i].push_back(g[i][j].first);\n\t\t//\tprintf(\"%d %d\\n\",i,g[i][j].first);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)r[i]=make_pair(ijk[i],i);\n\tstd::sort(r,r+a);\n\tfor(int i=0;i<(e+63)/64;i++){\n\t\tqueue<pair<int,wolf> > Q2;\n\t\tfor(int j=i*64;j<min(i*64+64,e);j++){\n\t\t\tL[x[j]]+=(1LL<<(j%64));\n\t\t\tR[y[j]]+=(1LL<<(j%64));\n\t\t}\n\t\tfor(int j=0;j<a;j++)tmp[j]=0LL;\n\t\twolf ans=0LL;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tint at=r[j].second;\n\t\t\ttmp[at]|=L[at];\n\t\t\tans|=(tmp[at]&R[at]);\n\t\t\tfor(int k=0;k<G[at].size();k++){\n\t\t\t\ttmp[G[at][k]]|=tmp[at];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<min(64,e-i*64);j++){\n\t\t\tif(ans&(1LL<<j))printf(\"Yes\\n\");\n\t\t\telse printf(\"No\\n\");\n\t\t}\n\t\tfor(int j=i*64;j<min(i*64+64,e);j++){\n\t\t\tL[x[j]]-=(1LL<<(j%64));\n\t\t\tR[y[j]]-=(1LL<<(j%64));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x> >\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\trep(i,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tqueue<int> que1;\n\t\tque1.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!que1.empty()){\n\t\t\tint x=que1.front(); que1.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\trep(i,nG[x].size()){\n\t\t\t\tint nex=nG[x][i];\n\t\t\t\tif(!used[nex]){\n\t\t\t\t\tque1.push(nex);\n\t\t\t\t\tused[nex]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1ull << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> T round_up(T a, T b) { return (a + b - 1) / b; }\n\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\nbool topo_dfs(int v, const vector<vector<int> >& g, vector<int>& color, vector<int>& order)\n{\n    color[v] = 1;\n    for (int i = 0; i < (int)g[v].size(); ++i)\n    {\n        int to = g[v][i];\n        if (color[to] == 2)\n            continue;\n        else if (color[to] == 1)\n            return false;\n        else if (!topo_dfs(to, g, color, order))\n            return false;\n    }\n    color[v] = 2;\n\n    order.push_back(v);\n    return true;\n}\n// O(V + E)\n// impossible -> return empty vector\nvector<int> topological_sort(const vector<vector<int> >& g)\n{\n    const int n = g.size();\n\n    vector<int> color(n);\n    vector<int> order;\n\n    for (int i = 0; i < n; ++i)\n        if (color[i] == 0 && !topo_dfs(i, g, color, order))\n            return vector<int>();\n    reverse(all(order));\n    return order;\n}\n\nint main()\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    vector<pint> g[ten(5)];\n    rep(i, m)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        --u, --v;\n        g[u].pb(pint(v, w));\n    }\n\n    int a, b, Q;\n    scanf(\"%d%d%d\", &a, &b, &Q);\n    --a, --b;\n\n    // 最短経路グラフを作るためにdijkstraします\n    vector<int> prev[ten(5)];\n    {\n        const int inf = ten(9);\n        int dis[ten(5)];\n        priority_queue<pint, vector<pint>, greater<pint> > q;\n\n        fill_n(dis, n, inf);\n        dis[a] = 0;\n        q.push(pint(0, a));\n        while (!q.empty())\n        {\n            int cost = q.top().first;\n            int v = q.top().second;\n            q.pop();\n\n            if (cost > dis[v])\n                continue;\n\n            rep(i, g[v].size())\n            {\n                int to = g[v][i].first;\n                int ncost = cost + g[v][i].second;\n                if (ncost < dis[to])\n                {\n                    dis[to] = ncost;\n                    q.push(pint(ncost, to));\n\n                    prev[to].clear();\n                }\n\n                if (ncost == dis[to])\n                    prev[to].pb(v);\n            }\n        }\n    }\n\n\n    // 最短経路グラフを作ります\n    vector<vector<int> > min_g(n);\n    {\n        queue<int> q;\n        bool visit[ten(5)];\n        fill_n(visit, n, false);\n\n        visit[b] = true;\n        q.push(b);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n\n            rep(i, prev[v].size())\n            {\n                int pre = prev[v][i];\n\n                min_g[pre].pb(v);\n\n                if (!visit[pre])\n                    q.push(pre);\n            }\n        }\n    }\n\n\n    vector<int> order = topological_sort(min_g);\n    assert(!order.empty());\n\n\n    // O((Q / 64) * (V + E))\n    while (Q)\n    {\n        typedef unsigned long long ull;\n\n        // 64クエリ or クエリがなくなるまで先読みします\n        vector<int> c, d;\n        for (int i = 0; i < 3 && Q; ++i, --Q)\n        {\n            int cc, dd;\n            scanf(\"%d%d\", &cc, &dd);\n            --cc, --dd;\n            c.pb(cc), d.pb(dd);\n        }\n\n        // dp[v]のi bit目が立っている時，c[i] -> vは最短経路上で到達可能\n        ull dp[ten(5)];\n        fill_n(dp, n, 0);\n        rep(i, c.size())\n            dp[c[i]] |= bin(i);\n\n        rep(i, order.size())\n        {\n            int v = order[i];\n            rep(j, min_g[v].size())\n                dp[min_g[v][j]] |= dp[v];\n        }\n\n        rep(i, c.size())\n            puts((dp[d[i]] >> i & 1) ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost) {\n    if(start == goal) return true;\n\n    bool ok = false;\n\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight)) continue;\n\n        ok = true;\n        result[start].insert(e.to);\n    }\n\n    return ok;\n}\n\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0);\n\n    return result;\n}\n\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> order;\n    queue<int> q;\n    vector<bool> visited(edge.size(), false);\n\n    for(q.push(start); !q.empty(); q.pop()) {\n        int current = q.front();\n\n        if(visited[current]) continue;\n        visited[current] = true;\n\n        order.push_back(current);\n        for(const auto& to: edge[current]) q.push(to);\n    }\n\n    return order;\n}\n\nint main() {\n    struct Query {int begin, end;};\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query(Q);\n    for(auto& q: query) cin >> q.begin >> q.end;\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    for(const auto& q: query) {\n        vector<unsigned long long int> dp(S, 0);\n        dp[q.begin - 1] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        cout << (dp[q.end - 1] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <functional>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef unsigned long long int ull;\n#define pb push_back\n#define INF 1000000000\n#define fi first\n#define sec second\nint dist1[100100],dist2[100100];\nint c[40100],d[40100];\nbitset<1024> dp[100100];\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> g[100100];\nint comp(int x,int y){\n    return dist1[x]<dist1[y];\n}\nvoid dijkstra(int s,int t){\n    for(int i=0;i<100100;i++)dist1[i]=INF,dist2[i]=INF;\n    dist1[s]=0,dist2[t]=0;\n    priority_queue<P,vector<P>,greater<P> >q;\n    q.push(P(0,s));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist1[e.to]>dist1[v]+e.cost){\n                dist1[e.to] = dist1[v]+e.cost;\n                q.push(P(dist1[e.to],e.to));\n            }\n        }\n    }\n    q.push(P(0,t));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist2[e.to]>dist2[v]+e.cost){\n                dist2[e.to] = dist2[v]+e.cost;\n                q.push(P(dist2[e.to],e.to));\n            }\n        }\n    }\n    return;\n}\nint S,R,Q;\nint a,b;\nint main(){\n    scanf(\"%d %d\",&S,&R);\n    for(int i=0;i<R;i++){\n        int u,v,w;\n        scanf(\"%d %d %d\",&u,&v,&w);\n        u--;v--;\n        g[u].pb(edge(v,w));\n        g[v].pb(edge(u,w));\n    }\n    scanf(\"%d %d %d\",&a,&b,&Q);\n    a--;b--;\n    dijkstra(a,b);\n    /*for(int i=0;i<S;i++)\n    {\n        cout << dist1[i] << ' ' << dist2[i] << endl;\n    }*/\n    vector<int> tp;\n    for(int i=0;i<S;i++)tp.pb(i);\n    sort(tp.begin(),tp.end(),comp);\n    //for(int i=0;i<S;i++)cout << tp[i] << ' ';\n    for(int i=0;i<Q;i+=1024){\n    \tfor(int j=0;j<100100;j++)dp[j]=bitset<1024>(0);\n        for(int j=0;j<min(1024,Q-i);j++){\n            scanf(\"%d %d\",&c[j],&d[j]);\n            c[j]--;d[j]--;\n            dp[c[j]].set(j);\n        } \n        for(int j=0;j<S;j++){\n            int f = tp[j];\n            if(dist1[f]+dist2[f]!=dist1[b])continue;\n            for(int k=0;k<g[f].size();k++){\n                edge e = g[f][k];\n                if(dist1[e.to]+dist2[e.to]!=dist1[b])continue;\n                if(dist1[e.to]!=dist1[f]+e.cost)continue;\n                dp[e.to]|=dp[f];\n            }\n        }\n        for(int j=0;j<min(1024,Q-i);j++){\n            if(dp[d[j]][j])printf(\"Yes\\n\");\n            else printf(\"No\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 103000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\nif(adist[b] != bdist[a])return 1;\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] == INF || adist[v[i]] == INF ||\n\t   bdist[u[i]] == INF || bdist[v[i]] == INF)\n\t    continue;\n\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n\tswap(u[i], v[i]);\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <cstring>\n#include <bitset>\n#include <functional>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef unsigned long long int ull;\n#define pb push_back\n#define INF 1000000000\n#define fi first\n#define sec second\nint dist1[100100],dist2[100100];\nint c[40100],d[40100];\nbitset<1024> dp[100100];\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nvector<edge> g[100100];\nint comp(int x,int y){\n    return dist1[x]<dist1[y];\n}\nvoid dijkstra(int s,int t){\n    for(int i=0;i<100100;i++)dist1[i]=INF,dist2[i]=INF;\n    dist1[s]=0,dist2[t]=0;\n    priority_queue<P,vector<P>,greater<P> >q;\n    q.push(P(0,s));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist1[e.to]>dist1[v]+e.cost){\n                dist1[e.to] = dist1[v]+e.cost;\n                q.push(P(dist1[e.to],e.to));\n            }\n        }\n    }\n    q.push(P(0,t));\n    while(!q.empty()){\n        P a = q.top();\n        q.pop();\n        int v = a.sec;\n        for(int i=0;i<g[v].size();i++){\n            edge e = g[v][i];\n            if(dist2[e.to]>dist2[v]+e.cost){\n                dist2[e.to] = dist2[v]+e.cost;\n                q.push(P(dist2[e.to],e.to));\n            }\n        }\n    }\n    return;\n}\nint S,R,Q;\nint a,b;\nint main(){\n    scanf(\"%d %d\",&S,&R);\n    for(int i=0;i<R;i++){\n        int u,v,w;\n        scanf(\"%d %d %d\",&u,&v,&w);\n        u--;v--;\n        g[u].pb(edge(v,w));\n        g[v].pb(edge(u,w));\n    }\n    scanf(\"%d %d %d\",&a,&b,&Q);\n    a--;b--;\n    dijkstra(a,b);\n    /*for(int i=0;i<S;i++)\n    {\n        cout << dist1[i] << ' ' << dist2[i] << endl;\n    }*/\n    vector<int> tp;\n    for(int i=0;i<S;i++)tp.pb(i);\n    sort(tp.begin(),tp.end(),comp);\n    //for(int i=0;i<S;i++)cout << tp[i] << ' ';\n    for(int i=0;i<Q;i+=1024){\n    \tfor(int j=0;j<100100;j++)dp[j]=bitset<1024>();\n        for(int j=0;j<min(1024,Q-i);j++){\n            scanf(\"%d %d\",&c[j],&d[j]);\n            c[j]--;d[j]--;\n            dp[c[j]].set(j);\n        } \n        for(int j=0;j<S;j++){\n            int f = tp[j];\n            if(dist1[f]+dist2[f]!=dist1[b])continue;\n            for(int k=0;k<g[f].size();k++){\n                edge e = g[f][k];\n                if(dist1[e.to]+dist2[e.to]!=dist1[b])continue;\n                if(dist1[e.to]!=dist1[f]+e.cost)continue;\n                dp[e.to]|=dp[f];\n            }\n        }\n        for(int j=0;j<min(1024,Q-i);j++){\n            if(dp[d[j]][j])printf(\"Yes\\n\");\n            else printf(\"No\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] <= d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nvoid Dijkstra(int n,const vector<edge> *G,int s,int *dist){\n\trep(u,n) dist[u]=(u==s?0:INF);\n\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,s));\n\twhile(!Q.empty()){\n\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\tif(d_now>dist[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist[v]>dist[u]+cost){\n\t\t\t\tdist[v]=dist[u]+cost;\n\t\t\t\tQ.push(make_pair(-dist[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic vector<edge> G[100000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint a,b,q; scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n\tstatic int c[40000],d[40000];\n\trep(i,q) scanf(\"%d%d\",c+i,d+i), c[i]--, d[i]--;\n\n\t// calculate distances from a/b\n\tstatic int dist_a[100000]; Dijkstra(n,G,a,dist_a);\n\tstatic int dist_b[100000]; Dijkstra(n,G,b,dist_b);\n\n\t// build the shortest path DAG from a to b\n\tstatic vector<int> H[100000];\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\tif(dist_a[u]+cost+dist_b[v]==dist_a[b]) H[u].push_back(v);\n\t}\n\n\t// find a topological order of H\n\tvector<int> top;\n\tstatic int deg[100000]; // degree of vertices\n\trep(u,n) rep(i,H[u].size()) {\n\t\tint v=H[u][i];\n\t\tdeg[v]++;\n\t}\n\tqueue<int> Q; Q.push(a);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\ttop.push_back(u);\n\t\trep(i,H[u].size()){\n\t\t\tint v=H[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0) Q.push(v);\n\t\t}\n\t}\n// printf(\"n=%d, a=%d, b=%d: \",n,a,b);\n// rep(i,top.size()) printf(\"%d \",top[i]); puts(\"\");\n\n\t// query\n/*\n\trep(i,(q+63)/64){\n\t\tstatic ll dp[100000];\n\t\tmemset(dp,0,sizeof dp);\n\t\trep(j,64) if(64*i+j<q) dp[c[64*i+j]]|=1LL<<j;\n\t\trep(i,n){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tdp[v]|=dp[u];\n\t\t\t}\n\t\t}\n\t\trep(j,64) if(64*i+j<q) puts(dp[d[64*i+j]]&(1LL<<j)?\"Yes\":\"No\");\n\t}\n*/\n\t// naive\n\trep(i,q){\n\t\tstatic bool vis[100000];\n\t\trep(u,n) vis[u]=false;\n\t\tvis[c[i]]=true;\n\t\trep(j,top.size()){\n\t\t\tint u=top[j];\n\t\t\trep(k,H[u].size()){\n\t\t\t\tint v=H[u][k];\n\t\t\t\tvis[v]|=vis[u];\n\t\t\t}\n\t\t}\n/*\n\t\tQ.push(c[i]);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tvis[u]=true;\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n*/\n\t\tputs(vis[d[i]]?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {int from, to, weight;};\nstruct Query {int from, to;};\n\nvector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n    typedef tuple<int, int> Node;\n    const int INF = INT_MAX >> 1;\n\n    vector<int> cost(edge.size(), INF);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.emplace(0, start);\n    while(!q.empty()) {\n        int c, v;\n        tie(c, v) = q.top();\n        q.pop();\n        if(c > cost[goal]) break;\n        if(c > cost[v]) continue;\n        cost[v] = c;\n        for(const auto& e: edge[v]) q.emplace(c + e.weight, e.to);\n    }\n    return cost;\n}\n\nvector<vector<int>> optimize(const vector<vector<Edge>>& edge, const vector<int>& cost, const int start, const int goal) {\n    vector<vector<int>> outedge(edge.size());\n    vector<vector<int>> inedge(edge.size());\n    for(const auto& list: edge) for(const auto& e: list) {\n        if(cost[e.from] + e.weight > cost[e.to]) continue;\n        outedge[e.from].push_back(e.to);\n        inedge[e.to].push_back(e.from);\n    }\n\n    typedef tuple<int, int> Node;\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    for(int v = 0; v < edge.size(); ++v) q.emplace(outedge[v].size(), v);\n    vector<bool> visited(edge.size(), false);\n    while(!q.empty()) {\n        int outdegree, v;\n        tie(outdegree, v) = q.top();\n        q.pop();\n        if(outdegree) break;\n        if(visited[v]) continue;\n        visited[v] = true;\n        if(v == start || v == goal) continue;\n        for(const auto& i: inedge[v]) {\n            outedge[i].erase(find(outedge[i].begin(), outedge[i].end(), v));    // → ここではフラグだけ付けておいて、後で構築しなおしたほうが早いかもしれない\n            q.emplace(outedge[i].size(), i);\n        }\n    }\n    return outedge;\n}\n\nvoid dfs(const vector<vector<int>>& edge, const int v, vector<bool>& visited, vector<int>& order) {\n    if(visited[v]) return;\n    visited[v] = true;\n    for(const auto& to: edge[v]) dfs(edge, to, visited, order);\n    order.push_back(v);\n}\n\nvector<int> topological_sort(const vector<vector<int>>& edge, const int start, const int goal) {\n    vector<int> order;\n    vector<bool>visited(edge.size(), false);\n    dfs(edge, start, visited, order);\n    reverse(order.begin(), order.end());\n    return order;\n}\n\nint main() {\n    int S, R;\n    cin >> S >> R;\n\n    vector<vector<Edge>> edge(S);\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        edge[u].push_back({u, v, w});\n        edge[v].push_back({v, u, w});\n    }\n\n    int a, b;\n    cin >> a >> b;\n    --a; --b;\n\n    int Q;\n    cin >> Q;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        query.push_back({--c, --d});\n    }\n\n    auto cost = Dijkstra(edge, a, b);\n    auto optimized_edge = optimize(edge, cost, a, b);\n    auto order = topological_sort(optimized_edge, a, b);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S);\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].from].set(j);\n        for(const auto& from: order) for(const auto& to: optimized_edge[from]) dp[to] = dp[to] | dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].to].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level: 4\n//Category: グラフ,Graph,最短経路,DAG\n//Note:\n\n/**\n * AからBまでの最短経路をDijkstra法で求め、そのときに使った辺のみから\n * なるDAGを構成する。\n * すると、cからdに最短経路で行けるかの判定は、このDAG上でcからdに行けるかの\n * 判定と等価になる。\n * 1クエリについて最悪全ノードの探索が必要で、これはO(S+R)になるが、\n * 到達可能かどうかは1bitしか使わないのでbit parallelで高速化ができる。\n * (S+R) × Q = 10^10 程度なので、数十倍程度の高速化をすれば制限時間に間に合う。\n *\n * オーダーは O(R log S + (S+R)Q)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<128> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(scanf(\"%d %d\", &S, &R) == EOF) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        --u; --v;\n        graph[u].emplace_back(v, w);\n        graph[v].emplace_back(u, w);\n    }\n    int A, B, Q;\n    scanf(\"%d %d %d\", &A, &B, &Q);\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill_n(memo.begin(), S, INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    vector<int> ord;\n    {\n        array<bool, 100000> visited;\n        array<int, 100000> ref_cnt;\n        fill_n(visited.begin(), S, false);\n        fill_n(ref_cnt.begin(), S, 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            ord.push_back(cur);\n            q.pop();\n            for(int to : dag[cur]) {\n                if(--ref_cnt[to] == 0) {\n                    q.push(to);\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 128> dest;\n    for(int i = 0; i < Q; ) {\n        for(auto &f : reachable) {\n            f.reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 128 && i < Q; ++i, ++j) {\n            int c, d;\n            scanf(\"%d %d\", &c, &d);\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        for(int v : ord) {\n            for(int next : dag[v]) {\n                reachable[next] |= reachable[v];\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                puts(\"Yes\");\n            } else {\n                puts(\"No\");\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nvoid Dijkstra(int n,const vector<edge> *G,int s,int *dist){\n\trep(u,n) dist[u]=(u==s?0:INF);\n\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,s));\n\twhile(!Q.empty()){\n\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\tif(d_now>dist[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist[v]>dist[u]+cost){\n\t\t\t\tdist[v]=dist[u]+cost;\n\t\t\t\tQ.push(make_pair(-dist[v],v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic vector<edge> G[100000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint a,b,q; scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n\tstatic int c[40000],d[40000];\n\trep(i,q) scanf(\"%d%d\",c+i,d+i), c[i]--, d[i]--;\n\n\t// calculate distances from a/b\n\tstatic int dist_a[100000]; Dijkstra(n,G,a,dist_a);\n\tstatic int dist_b[100000]; Dijkstra(n,G,b,dist_b);\n\n\t// build the shortest path DAG from a to b\n\tstatic vector<int> H[100000];\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\tif(dist_a[u]+cost+dist_b[v]==dist_a[b]) H[u].push_back(v);\n\t}\n\n\t// find a topological order of H\n\tvector<int> top;\n\tstatic int deg[100000]; // degree of vertices\n\trep(u,n) rep(i,H[u].size()) {\n\t\tint v=H[u][i];\n\t\tdeg[v]++;\n\t}\n\tqueue<int> Q; Q.push(a);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\ttop.push_back(u);\n\t\trep(i,H[u].size()){\n\t\t\tint v=H[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0) Q.push(v);\n\t\t}\n\t}\n\n\t// query\n\trep(i,(q+63)/64){\n\t\tstatic ll dp[100000];\n\t\tmemset(dp,0,sizeof dp);\n\t\trep(j,64) if(64*i+j<q) dp[c[64*i+j]]|=1LL<<j;\n\t\trep(i,top.size()){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tdp[v]|=dp[u];\n\t\t\t}\n\t\t}\n\t\trep(j,64) if(64*i+j<q) puts(dp[d[64*i+j]]&(1LL<<j)?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x>>\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\trep(i,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tqueue<int> que1;\n\t\tque1.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!que1.empty()){\n\t\t\tint x=que1.front(); que1.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\trep(i,nG[x].size()){\n\t\t\t\tint nex=nG[x][i];\n\t\t\t\tif(!used[nex]){\n\t\t\t\t\tque1.push(nex);\n\t\t\t\t\tused[nex]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level: 4\n//Category: グラフ,Graph,最短経路,DAG\n//Note:\n\n/**\n * AからBまでの最短経路をDijkstra法で求め、そのときに使った辺のみから\n * なるDAGを構成する。\n * すると、cからdに最短経路で行けるかの判定は、このDAG上でcからdに行けるかの\n * 判定と等価になる。\n * 1クエリについて最悪全ノードの探索が必要で、これはO(N+M)になるが、\n * 到達可能かどうかは1bitしか使わないのでbit parallelで高速化ができる。\n * (N+M) × Q = 10^10 程度なので、数十倍程度の高速化をすれば制限時間に間に合う。\n *\n * オーダーは O(N log R + (N+M)Q)。\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<192> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    array<int, 100000> ref_cnt;\n    {\n        array<bool, 100000> visited;\n        fill(visited.begin(), visited.end(), false);\n        fill(ref_cnt.begin(), ref_cnt.end(), 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 192> dest;\n    for(int i = 0; i < Q; ) {\n        for(auto &f : reachable) {\n            f.reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 192 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n \nusing namespace std;\n \nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost) : to(to), cost(cost){}\n    Edge(){}\n};\n \nbool operator < (const Edge &a, const Edge &b)\n{\n    return (a.cost > b.cost);\n}\n \nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n \nvoid dfs(int v)\n{\n    vis[v] = true;\n     \n    for (int i = 0; i < G[v].size(); i++)\n        if (!vis[G[v][i]]) dfs(G[v][i]);\n    topo.push_back(v);\n}\n \nint main()\n{\n    int N, M;\n     \n    scanf(\"%d %d\", &N, &M);\n     \n    for (int i = 0; i < M; i++){\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        --u; --v;\n        TG[u].push_back(Edge(v, w));\n        TG[v].push_back(Edge(u, w));\n    }\n     \n    int a, b, Q;\n     \n    scanf(\"%d %d %d\", &a, &b, &Q);\n     \n    --a; --b;\n     \n    for (int i = 0; i < Q; i++){\n        scanf(\"%d %d\", c + i, d + i);\n        --c[i]; --d[i];\n    }\n     \n    priority_queue<Edge> pq;\n    bool done[100000] = {0};\n    int weight[100000];\n    fill(weight, weight + N, 1001001001);\n     \n    for (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n        Edge x = pq.top();\n         \n        if (done[x.to]) continue;\n        done[x.to] = true;\n        weight[x.to] = x.cost;\n         \n        for (int i = 0; i < TG[x.to].size(); i++){\n            pq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n        }\n    }\n     \n    int in[100000] = {0};\n    queue<int> q;\n    memset(done, 0, sizeof(done));\n     \n    for (q.push(b); q.size(); q.pop()){\n        int x = q.front();\n        if (done[x]) continue;\n        for (int i = 0; i < TG[x].size(); i++){\n            if (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n                q.push(TG[x][i].to);\n                G[TG[x][i].to].push_back(x);\n                in[x]++;\n            }\n        }\n        done[x] = true;\n    }\n     \n    for (int i = 0; i < N; i++){\n        if (!in[i]) dfs(i);\n    }\n    reverse(topo.begin(), topo.end());\n     \n    for (int i = 0; i < (Q + 63) / 64; i++){\n        memset(accessable, 0, sizeof(accessable));\n        for (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n            accessable[c[j]] |= (1 << (j % 64));\n        }\n        for (int j = 0; j < topo.size(); j++){\n            for (int k = 0; k < G[topo[j]].size(); k++){\n                accessable[G[topo[j]][k]] |= accessable[topo[j]];\n            }\n        }\n        for (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n            if ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n     \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint S, R, a, b, Q;\n\nvector<pii> edges;\n\nvoid dijkstra(const vector< vector<pii> > &g, int s, int t, vector<int> &ret){\n\tint n = g.size();\n\tret = vector<int>(n, INF);\n\tvector< vector<int> > prev(S);\n\n\tvector<pii> cand;\n\tpriority_queue<pii, vector<pii>, greater<pii> > dp;\n\tdp.push(pii(0, s));\n\tret[s] = 0;\n\twhile(!dp.empty()){\n\t\tint s = dp.top().second;\n\t\tdp.pop();\n\t\tFOR(it, prev[s]) cand.push_back(pii(*it, s));\n\t\tFOR(it, g[s]){\n\t\t\tint t = it->first;\n\t\t\tif(ret[t] > ret[s]+it->second){\n\t\t\t\tret[t] = ret[s]+it->second;\n\t\t\t\tprev[t].clear();\n\t\t\t\tprev[t].push_back(s);\n\t\t\t\tdp.push(pii(ret[t], t));\n\t\t\t}else if(ret[t] == ret[s]+it->second){\n\t\t\t\tprev[t].push_back(s);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tvector<int> vis(S, 0);\n\tq.push(t);\n\tvis[t] = 1;\n\tret = vector<int>(n, 0);\n\twhile(!q.empty()){\n\t\tint s = q.front();\n\t\tret[s] = 1;\n\t\tq.pop();\n\t\tFOR(it, prev[s]){\n\t\t\tif(!vis[*it]){\n\t\t\t\tvis[*it] = 1;\n\t\t\t\tq.push(*it);\n\t\t\t}\n\t\t}\n\t}\n\tFOR(it, cand) if(ret[it->first] && ret[it->second]) edges.push_back(*it);\n}\n\nvoid solve(vector<ull> src, vector<ull> dest){\n\tvector<ull> f(S, 0);\n\tREP(i, src.size()) f[src[i]] |= 1ULL << i;\n\tFOR(it, edges) f[it->second] |= f[it->first];\n\tREP(i, dest.size()) puts((f[dest[i]] & (1ULL << i)) ? \"Yes\" : \"No\");\n}\n\nmain(){\n\tscanf(\"%d%d\", &S, &R);\n\tvector< vector<pii> > g(S);\n\tREP(i, R){\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\tg[u-1].push_back(pii(v-1, w));\n\t\tg[v-1].push_back(pii(u-1, w));\n\t}\n\tscanf(\"%d%d%d\", &a, &b, &Q);\n\tvector<int> dis;\n\tdijkstra(g, a-1, b-1, dis);\n\tvector<ull> src(64), dest(64);\n\tREP(i, Q){\n\t\tint c, d;\n\t\tscanf(\"%d%d\", &c, &d);\n\t\tsrc[i%64] = c-1;\n\t\tdest[i%64] = d-1;\n\t\tif(i%64 == 63) solve(src, dest);\n\t}\n\tif(Q%64){\n\t\tsrc.resize(Q%64);\n\t\tdest.resize(Q%64);\n\t\tsolve(src, dest);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define pb push_back\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define rev(vec) reverse(vec.begin(),vec.end())\n#define pque(x) priority_queue<x>\n#define rpque(x) priority_queue<x,vector<x>,greater<x> >\n#define fr first\n#define sc second\n\nconst int INF=1000000000;\n\n\nint main(){\n\tint s,r,u,v,w,a,b,q;\n\tstatic vector<P> G[100010];\n\t\n\tscanf(\"%d%d\",&s,&r);\n\trep(i,r){\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].pb(P(v,w));\n\t\tG[v].pb(P(u,w));\n\t}\n\tscanf(\"%d%d%d\",&a,&b,&q);\n\t\n\tstatic bool used[100010];\n\tstatic int d[100010];\n\trpque(P) que;\n\tstatic vector<int> prev[100010];\n\t\n\trep(i,100010)used[i]=false;\n\trep(i,100010)d[i]=INF;\n\td[a]=0;\n\tque.push(P(0,a));\n\t\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed=G[p.sc][i];\n\t\t\t\tif(d[ed.fr]>d[p.sc]+ed.sc){\n\t\t\t\t\td[ed.fr]=d[p.sc]+ed.sc;\n\t\t\t\t\tprev[ed.fr].clear();\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t\tque.push(P(d[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t\telse if(d[ed.fr]==d[p.sc]+ed.sc){\n\t\t\t\t\tprev[ed.fr].pb(p.sc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc]=true;\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,prev[i].size()){\n\t\t\tprintf(\"%d \",prev[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\t\n\t\n\trep(i,100010)used[i]=false;\n\tqueue<int> que0;\n\tstatic vector<int> nG[100010];\n\tque0.push(b); used[b]=true;\n\t\n\twhile(!que0.empty()){\n\t\tint x=que0.front(); que0.pop();\n\t\trep(i,prev[x].size()){\n\t\t\tint p=prev[x][i];\n\t\t\tnG[p].pb(x);\n\t\t\tif(!used[p]){\n\t\t\t\tque0.push(p);\n\t\t\t\tused[p]=true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep1(i,s){\n\t\tprintf(\"%d:\",i);\n\t\trep(j,nG[i].size()){\n\t\t\tprintf(\"%d \",nG[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tstatic bool used0[100010];\n\trep(i,100010)used0[i]=used[i];\n\t\n\trep(ppp,q){\n\t\tint c,e;\n\t\tscanf(\"%d%d\",&c,&e);\n\t\t\n\t\tif(!used0[e]){\n\t\t\tprintf(\"No\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\trep(i,100010)used[i]=false;\n\t\tstack<int> sta;\n\t\tsta.push(c); used[c]=true;\n\t\t\n\t\tbool ret=false;\n\t\twhile(!sta.empty()){\n\t\t\tint x=sta.top(); sta.pop();\n\t\t\tif(x==e){ ret=true; break; }\n\t\t\trrep(i,nG[x].size()){\n\t\t\t\tint nex=nG[x][i];\n\t\t\t\tif(!used[nex]){\n\t\t\t\t\tsta.push(nex);\n\t\t\t\t\tused[nex]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ret)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] <= d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return adist[b] - bdist[a];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\n\nvoid dfs(int v, vector<int> &topo)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i], topo);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (weight[x.to] < x.cost) continue;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tif (weight[TG[x.to][i].to] > x.cost + TG[x.to][i].cost){\n\t\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tqueue<int> q;\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> topo;\n\tfor (int i = 0; i < N; i++){\n\t\tif (!vis[i]) dfs(i, topo);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tlong long int accessable[100000] = {0};\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] <= d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nbool come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == INF)continue;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    long long c[64], d[65];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level:\n//Category:\n//Note:\n\n/**\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    array<int, 100000> ref_cnt;\n    {\n        array<bool, 100000> visited;\n        fill(visited.begin(), visited.end(), false);\n        fill(ref_cnt.begin(), ref_cnt.end(), 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<ULL, 100000> reachable;\n    array<int, 70> dest;\n    for(int i = 0; i < Q; ) {\n        fill(reachable.begin(), reachable.end(), 0);\n        int cnt = 0;\n        for(int j = 0; j < 64 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d] |= 1<<j;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]] & (1<<j)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\nlong **dd,*n,*a,*b,s,r,u,v,w,q,c,d,i,j,jj,mn,inf;\ncin>>s>>r;\ninf=r*1000;\ndd=new long*[s+1];\nfor(i=1;i<=s;i++){\ndd[i]=new long[s+1];\nfor(j=1;j<=s;j++)dd[i][j]=0;\n}\nn=new long[s+1];\na=new long[s+1];\nb=new long[s+1];\nfor(i=1;i<=s;i++){a[i]=inf;b[i]=0;}\nfor(i=0;i<r;i++){cin>>u>>v>>w;dd[u][v]=w;}\ncin>>u>>v>>q;\na[v]=0;jj=0;\nwhile(1){\nmn=inf;\nfor(i=1;i<=s;i++){\nif(!b[i]&&mn>a[i]){mn=a[i];j=i;}\n}\nn[j]=jj;jj=j;b[j]=1;\nif(j==u)break;\nif(mn==inf)break;\nfor(i=1;i<=s;i++){\nif(dd[i][j]>0&&a[i]>dd[i][j]+a[j]){a[i]=dd[i][j]+a[j];}\n}\n}\nj=u;\nfor(i=1;i<=s;i++){b[i]=j;j=n[j];}\nfor(i=0;i<q;i++){\ncin>>c>>d;\nfor(j=1;j<=s;j++)if(b[j]==c)break;\nfor(;j<=s;j++)if(b[j]==d)break;\nif(j>s)cout<<\"No\"<<endl;else cout<<\"Yes\"<<endl;\n\n\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse(ALL(ret));\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< bitset< 3000 > > dp(graph.size());\n\n  for(int _ = 0; _ < query.size(); _ += 3000){\n    fill( dp.begin(), dp.end(), 0);\n    int start = _, end = min< int >( query.size(), start + 3000);\n    for(int i = start; i < end; i++){\n      dp[query[i].first][i - start] = 1;\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( dp[query[i].second][i - start] ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level:\n//Category:\n//Note:\n\n/**\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef bitset<64> Flag;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    array<vector<pair<int,LL>>, 100000> graph;\n    array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    array<LL, 100000> memo;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n            }\n        }\n    }\n\n    array<int, 100000> ref_cnt;\n    {\n        array<bool, 100000> visited;\n        fill(visited.begin(), visited.end(), false);\n        fill(ref_cnt.begin(), ref_cnt.end(), 0);\n        queue<int> q;\n        q.push(B);\n        visited[B] = true;\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int to : dag[cur]) {\n                ref_cnt[to]++;\n                if(!visited[to]) {\n                    q.push(to);\n                    visited[to] = true;\n                }\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<Flag, 100000> reachable;\n    array<int, 70> dest;\n    for(int i = 0; i < Q; ) {\n        for(auto &f : reachable) {\n            f.reset();\n        }\n        int cnt = 0;\n        for(int j = 0; j < 64 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d][j] = true;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]][j]) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] < d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"YES\" << endl;\n\telse\n\t    cout << \"NO\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<int> tps, pos;\nbool visit[100000];\nint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 0, n);\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\t//printf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < 64; i++){\n\t\tans[i] = (dp[pos[qt[i]]] & (1ull << i)) ? true : false;\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!visit[i]) toposort(i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i += 64){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n\nstruct NODE{\n\tint from,to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {};\n\tNODE(int from,int to,int cost) : from(from) , to(to) , cost(cost) {};\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector<NODE> graph[100000];\nvector<NODE> dag[100000];\nvector<NODE> rdag[100000];\n\n\nint qc[40000],qd[40000];\n\nint cost[100000] = {};\n\nlong long dp[100000] = {};\n\n\nint a_to_c_can[100000] = {};\nint b_to_d_can[100000] = {};\nint cost2[100000] = {};\n\nvoid acdfs(int x){\n\tif( !a_to_c_can[x] ){\n\t\ta_to_c_can[x] = 1;\n\t}else return;\n\tfor(int i = 0 ; i < dag[x].size() ; i++)\n\t\tacdfs(dag[x][i].to);\n}\nvoid bddfs(int x){\n\tif( !b_to_d_can[x] ){\n\t\tb_to_d_can[x] = 1;\n\t}else return;\n\tfor(int i = 0 ; i < rdag[x].size() ; i++)\n\t\tbddfs(rdag[x][i].to);\n}\nint main(){\n\t\n\tmemset(cost,-1,sizeof(cost));\n\tint S,R;\n\tscanf(\"%d%d\",&S,&R);\n\t\n\tfor(int i = 0 ; i < R ; i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tu--,v--;\n\t\tgraph[u].push_back(NODE(u,v,w));\n\t\tgraph[v].push_back(NODE(v,u,w));\n\t}\n\tint a,b,qu;\n\tscanf(\"%d%d%d\",&a,&b,&qu);\n\tfor(int i = 0 ; i < qu ; i++){\n\t\tscanf(\"%d%d\",&qc[i],&qd[i]);\n\t\tqc[i]--,qd[i]--;\n\t}\n\ta--,b--;\n\tpriority_queue<NODE> Q;\n\tQ.push(NODE(a,0));\n\twhile(Q.size()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\tif( cost[q.to] == -1 ){\n\t\t\tcost[q.to] = q.cost;\n\t\t}else continue;\n\t\tfor(int i = 0 ; i < graph[q.to].size() ; i++)\n\t\t\tQ.push(NODE(graph[q.to][i].to,q.cost+graph[q.to][i].cost));\n\t}\n\tfor(int i = 0 ; i < S ; i++){\n\t\tfor(int j = 0 ; j < graph[i].size() ; j++){\n\t\t\tif( cost[i] + graph[i][j].cost == cost[graph[i][j].to] ){\n\t\t\t\tdag[i].push_back(NODE(i,graph[i][j].to,1));\n\t\t\t\trdag[graph[i][j].to].push_back(NODE(graph[i][j].to,i,1));\n\t\t\t}\n\t\t}\n\t}\n\tacdfs(a);\n\tbddfs(b);\n\t/*\n\tfor(int i = 0 ; i < S ; i++)\n\t\tcout << a_to_c_can[i] << \" \";\n\tcout << endl;\n\tfor(int i = 0 ; i < S ; i++)\n\t\tcout << b_to_d_can[i] << \" \";\n\tcout << endl;\n\tfor(int i = 0 ; i < S ; i++)\n\t\tcout << cost[i] << \" \";\n\tcout << endl;\n\t*/\n\t/*for(int i = 0 ; i < S ; i++){\n\t\tfor(int j = 0 ; j < dag[i].size() ; j++) cout << \"(\" << i << \",\" << dag[i][j].to << \")\" << \" \";\n\t\tcout << endl;\n\t}\n\t*/\n\t// 最短経路dagのトポロジカルソートは、重みでソートするだけで良い\n\tvector< pair<int,int> > tpr_sort;\n\tfor(int i = 0 ; i < S ; i++) tpr_sort.push_back(make_pair(cost[i],i));\n\tsort(tpr_sort.begin(),tpr_sort.end());\n\tint sz = 60;\n\tfor( int d = 0 ; d < qu ; d += sz ){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint x = d , y = min(qu,d+sz);\n\t\tfor(int i = x ; i < y ; i++){\n\t\t\tdp[qc[i]] |= (1ll<<(i-x));\n\t\t}\n\t\tfor(int i_ = 0 ; i_ < S ; i_++){\n\t\t\tint i = tpr_sort[i_].second;\n\t\t\tfor(int j = 0 ; j < dag[i].size() ; j++)\n\t\t\t\tdp[dag[i][j].to] |= dp[i];\n\t\t}\n\t\tfor(int i = x ; i < y ; i++){\n\t\t\tif( (dp[qd[i]]>>(i-x)&1) && a_to_c_can[qc[i]] && b_to_d_can[qd[i]] ){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to; T cost;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<edge<ll>>> G_(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b; ll c;\n        scanf(\"%d %d %lld\", &a, &b, &c);\n        a--; b--;\n        G_[a].emplace_back(b, c);\n        G_[b].emplace_back(a, c);\n    }\n    int a, b, q;\n    cin >> a >> b >> q;\n    a--; b--;\n    vector<vector<int>> G(n);\n    {\n        vector<ll> d(n, INF<ll>);\n        priority_queue<pair<ll, int>,vector<pair<ll, int>>,greater<>> Q;\n        d[a] = 0;\n        Q.emplace(0, a);\n        while(!Q.empty()){\n            int cost; int i;\n            tie(cost, i) = Q.top(); Q.pop();\n            if(d[i] < cost) continue;\n            for (auto &&e : G_[i]) {\n                auto cost2 = cost + e.cost;\n                if(d[e.to] <= cost2) continue;\n                d[e.to] = cost2;\n                Q.emplace(d[e.to], e.to);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (auto &&j : G_[i]) {\n                if(d[i]+j.cost == d[j.to]) {\n                    G[j.to].emplace_back(i);\n                }\n            }\n        }\n\n    }\n    vector<vector<int>> G2(n);\n    vector<int> ord;\n    {\n        vector<int> visited(n);\n        visited[b] = 1;\n        queue<int> Q;\n        Q.emplace(b);\n        vector<int> deg(n);\n        while(!Q.empty()){\n            int i = Q.front(); Q.pop();\n            for (auto &&j : G[i]) {\n                G2[j].emplace_back(i);\n                deg[i]++;\n                if(!visited[j]) {\n                    visited[j] = 1;\n                    Q.emplace(j);\n                }\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if(!deg[i]) Q.emplace(i);\n        }\n        while(!Q.empty()){\n            int i = Q.front(); Q.pop();\n            ord.emplace_back(i);\n            for (auto &&j : G2[i]) {\n                deg[j]--;\n                if(!deg[j]) Q.emplace(j);\n            }\n        }\n        reverse(ord.begin(),ord.end());\n    }\n    reverse(ord.begin(),ord.end());\n    constexpr int B = 4096;\n    vector<bitset<B>> v(n);\n    vector<int> cs(q), ds(q);\n    for (int i = 0; i < q; ++i) {\n        scanf(\"%d %d\", &cs[i], &ds[i]);\n        cs[i]--; ds[i]--;\n    }\n    for (int l = 0; l < q; l += B) {\n        int r = min(q, l+B);\n        for (int j = 0; j < n; ++j) v[j].reset();\n        for (int k = l; k < r; ++k) {\n            v[cs[k]].set(k-l);\n        }\n        for (auto &&j : ord) {\n            for (auto &&k : G2[j]) {\n                v[k] |= v[j];\n            }\n        }\n        for (int k = l; k < r; ++k) {\n            if(v[ds[k]][k-l]) puts(\"Yes\");\n            else puts(\"No\");\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Name: Railroad\n//Level:\n//Category:\n//Note:\n\n/**\n */\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL INF = 100000LL * 1000 * 10;\n\nbool solve() {\n    int S, R;\n    if(!(cin >> S >> R)) return false;\n    if(!S && !R) return false;\n\n    static array<vector<pair<int,LL>>, 100000> graph;\n    static array<vector<int>, 100000> dag;\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        graph[u].push_back(make_pair(v, w));\n        graph[v].push_back(make_pair(u, w));\n    }\n    int A, B, Q;\n    cin >> A >> B >> Q;\n    --A; --B;\n\n    // Find shortest path\n    static array<LL, 100000> memo;\n    static array<int, 100000> ref_cnt;\n    priority_queue<pair<LL,int>> q;\n    LL best_cost = INF;\n    fill(memo.begin(), memo.end(), INF);\n    fill(ref_cnt.begin(), ref_cnt.end(), 0);\n    q.push(make_pair(0, A));\n    memo[A] = 0;\n    while(!q.empty()) {\n        const LL cost = -q.top().first;\n        const int cur = q.top().second;\n        q.pop();\n        if(cost > best_cost) break;\n        if(cur == B && best_cost == INF) {\n            best_cost = cost;\n        }\n        if(memo[cur] < cost) continue;\n        for(const auto &next : graph[cur]) {\n            const LL nc = cost + next.second;\n            if(nc < memo[next.first]) {\n                dag[next.first].clear();\n                dag[next.first].push_back(cur);\n                ref_cnt[cur] = 1;\n                memo[next.first] = nc;\n                q.push(make_pair(-nc, next.first));\n            } else if(memo[next.first] == nc) {\n                dag[next.first].push_back(cur);\n                ref_cnt[cur]++;\n            }\n        }\n    }\n\n    // Determine reachability for each query\n    array<ULL, 100000> reachable;\n    array<int, 70> dest;\n    for(int i = 0; i < Q; ) {\n        fill(reachable.begin(), reachable.end(), 0);\n        int cnt = 0;\n        for(int j = 0; j < 64 && i < Q; ++i, ++j) {\n            int c, d;\n            cin >> c >> d;\n            --c; --d;\n            reachable[d] |= 1<<j;\n            dest[j] = c;\n            ++cnt;\n        }\n        auto rem_cnt = ref_cnt;\n        queue<int> q;\n        q.push(B);\n        while(!q.empty()) {\n            const int cur = q.front();\n            q.pop();\n            for(int next : dag[cur]) {\n                reachable[next] |= reachable[cur];\n                if(--rem_cnt[next] == 0) {\n                    q.push(next);\n                }\n            }\n        }\n        for(int j = 0; j < cnt; ++j) {\n            if(reachable[dest[j]] & (1<<j)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic vector<edge> G[100000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint a,b,q; scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n\tstatic int c[40000],d[40000];\n\trep(i,q) scanf(\"%d%d\",c+i,d+i), c[i]--, d[i]--;\n\n\t// calculate distances from a\n\tstatic int dist_a[100000];\n\trep(u,n) dist_a[u]=(u==a?0:INF);\n\tpriority_queue< pair<int,int> > Qa; Qa.push(make_pair(0,a));\n\twhile(!Qa.empty()){\n\t\tint d_now=-Qa.top().first,u=Qa.top().second; Qa.pop();\n\t\tif(d_now>dist_a[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_a[v]>dist_a[u]+cost){\n\t\t\t\tdist_a[v]=dist_a[u]+cost;\n\t\t\t\tQa.push(make_pair(-dist_a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// calculate distances from b\n\tstatic int dist_b[100000];\n\trep(u,n) dist_b[u]=(u==b?0:INF);\n\tpriority_queue< pair<int,int> > Qb; Qb.push(make_pair(0,b));\n\twhile(!Qb.empty()){\n\t\tint d_now=-Qb.top().first,u=Qb.top().second; Qb.pop();\n\t\tif(d_now>dist_b[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_b[v]>dist_b[u]+cost){\n\t\t\t\tdist_b[v]=dist_b[u]+cost;\n\t\t\t\tQb.push(make_pair(-dist_b[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// build the shortest path DAG from a to b\n\tstatic vector<int> H[100000];\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\tif(dist_a[u]+cost+dist_b[v]==dist_a[b]) H[u].push_back(v);\n\t}\n\n\t// find a topological order of H\n\tvector<int> top;\n\tstatic bool vis[100000];\n\tqueue<int> Q; Q.push(a);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\ttop.push_back(u);\n\t\trep(i,H[u].size()){\n\t\t\tint v=H[u][i];\n\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t}\n\t}\n\n\t// query\n/*\n\trep(i,(q+63)/64){\n\t\tstatic ll dp[100000];\n\t\tmemset(dp,0,sizeof dp);\n\t\trep(j,64) if(64*i+j<q) dp[c[64*i+j]]|=1LL<<j;\n\t\trep(i,n){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tdp[v]|=dp[u];\n\t\t\t}\n\t\t}\n\t\trep(j,64) if(64*i+j<q) puts(dp[d[64*i+j]]&(1LL<<j)?\"Yes\":\"No\");\n\t}\n*/\n\t// naive\n\trep(i,q){\n\t\trep(u,n) vis[u]=false;\n\t\tQ.push(c[i]);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tvis[u]=true;\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n\t\tputs(vis[d[i]]?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n\nint a[40000],b[40000];\n\nstruct NODE{\n\tint from,to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {};\n\tNODE(int from,int to,int cost) : from(from) , to(to) , cost(cost) {};\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector<NODE> graph[100000];\nvector<NODE> dag[100000];\nvector<NODE> rdag[100000];\n\n\nint qc[40000],qd[40000];\n\nint cost[100000] = {};\n\nlong long dp[40000] = {};\n\n\nint a_to_c_can[40000] = {};\nint b_to_d_can[40000] = {};\nint cost2[40000] = {};\n\nvoid acdfs(int x){\n\tif( !a_to_c_can[x] ){\n\t\ta_to_c_can[x] = 1;\n\t}else return;\n\tfor(int i = 0 ; i < dag[x].size() ; i++)\n\t\tacdfs(dag[x][i].to);\n}\nvoid bddfs(int x){\n\tif( !b_to_d_can[x] ){\n\t\tb_to_d_can[x] = 1;\n\t}else return;\n\tfor(int i = 0 ; i < rdag[x].size() ; i++)\n\t\tbddfs(rdag[x][i].to);\n}\nint main(){\n\t\n\tmemset(cost,-1,sizeof(cost));\n\tint S,R;\n\tscanf(\"%d%d\",&S,&R);\n\t\n\tfor(int i = 0 ; i < R ; i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tu--,v--;\n\t\tgraph[u].push_back(NODE(u,v,w));\n\t\tgraph[v].push_back(NODE(v,u,w));\n\t}\n\tint a,b,qu;\n\tscanf(\"%d%d%d\",&a,&b,&qu);\n\tfor(int i = 0 ; i < qu ; i++){\n\t\tscanf(\"%d%d\",&qc[i],&qd[i]);\n\t\tqc[i]--,qd[i]--;\n\t}\n\ta--,b--;\n\tpriority_queue<NODE> Q;\n\tQ.push(NODE(a,0));\n\twhile(Q.size()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\tif( cost[q.to] == -1 ){\n\t\t\tcost[q.to] = q.cost;\n\t\t}else continue;\n\t\tfor(int i = 0 ; i < graph[q.to].size() ; i++)\n\t\t\tQ.push(NODE(graph[q.to][i].to,q.cost+graph[q.to][i].cost));\n\t}\n\tfor(int i = 0 ; i < S ; i++){\n\t\tfor(int j = 0 ; j < graph[i].size() ; j++){\n\t\t\tif( cost[i] + graph[i][j].cost == cost[graph[i][j].to] ){\n\t\t\t\tdag[i].push_back(NODE(i,graph[i][j].to,1));\n\t\t\t\trdag[graph[i][j].to].push_back(NODE(graph[i][j].to,i,1));\n\t\t\t}\n\t\t}\n\t}\n\tacdfs(a);\n\tbddfs(b);\n\t/*\n\tfor(int i = 0 ; i < S ; i++)\n\t\tcout << a_to_c_can[i] << \" \";\n\tcout << endl;\n\tfor(int i = 0 ; i < S ; i++)\n\t\tcout << b_to_d_can[i] << \" \";\n\tcout << endl;\n\tfor(int i = 0 ; i < S ; i++)\n\t\tcout << cost[i] << \" \";\n\tcout << endl;\n\t*/\n\t// 最短経路dagのトポロジカルソートは、重みでソートするだけで良い\n\tvector< pair<int,int> > tpr_sort;\n\tfor(int i = 0 ; i < S ; i++) tpr_sort.push_back(make_pair(cost[i],i));\n\tsort(tpr_sort.begin(),tpr_sort.end());\n\tint sz = 60;\n\tfor( int d = 0 ; d < qu ; d += sz ){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint x = d , y = min(qu,d+sz);\n\t\tfor(int i = x ; i < y ; i++){\n\t\t\tdp[qc[i]] |= (1ll<<(i-x));\n\t\t}\n\t\tfor(int i_ = 0 ; i_ < S ; i_++){\n\t\t\tint i = tpr_sort[i_].second;\n\t\t\tfor(int j = 0 ; j < dag[i].size() ; j++)\n\t\t\t\tdp[dag[i][j].to] |= dp[i];\n\t\t}\n\t\tfor(int i = x ; i < y ; i++){\n\t\t\tif( (dp[qd[i]]>>(i-x)&1) && a_to_c_can[qc[i]] && b_to_d_can[qd[i]] ){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nbool come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    if(come[now])return;\n    come[now] = true;\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == INF)continue;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    long long c[64], d[65];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<bool>& memo) {\n    if(start == goal) return true;\n    if(memo[start]) return true;\n\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n\n        memo[start] = true;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\n\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<bool> memo(edge.size(), false);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\n\n// void ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n//     if(visited[current]) return;\n//     visited[current] = true;\n//     for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n//     result.push_back(current);\n// }\n// const vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n//     vector<int> result;\n//     vector<bool> visited(edge.size(), false);\n//     ts_dfs(result, edge, visited, start);\n//     reverse(result.begin(), result.end());\n//     return result;\n// }\n\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> order;\n    queue<int> q;\n    vector<bool> visited(edge.size(), false);\n\n    for(q.push(start); !q.empty(); q.pop()) {\n        int current = q.front();\n\n        if(visited[current]) continue;\n        visited[current] = true;\n\n        order.push_back(current);\n        for(const auto& to: edge[current]) q.push(to);\n    }\n\n    return order;\n}\n\nint main() {\n    struct Query {int begin, end;};\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query(Q);\n    for(auto& q: query) cin >> q.begin >> q.end;\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n    for(const auto& q: query) {\n        vector<unsigned long long int> dp(S, 0);\n        dp[q.begin - 1] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        cout << (dp[q.end - 1] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] <= d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(adist[d] + bdist[d] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    for(int i = 0;i < 105000;i++)dist[i] = INF;\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second;\n\tif(dist[from] < tmp.first)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long tw = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] > dist[from] + tw){\n\t\tdist[to] = dist[from] + tw;\n\t\tpq.push(P(dist[to], to));\n\t\tif(to >= 105000)return 1;\n\t    }\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\nconst int sep = 64;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> Pr;\ntypedef tuple<int, int, int> Tp;\n\nint n, m, A, B, Q;\nvector<vector<Pr>> g;\nint qs[40000], qt[40000];\n\nvector<vector<int>> mg;\nvector<vector<int>> rmg;\nvector<vector<int>> pre;\nvector<vector<int>> rpre;\nvector<int> tps, pos;\nbool visit[100000];\nulint dp[100000];\nbool ans[40000];\n\nvoid dijkstra()\n{\n\tmg = rmg = vector<vector<int>>(n);\n\t\n\tvector<int> dist(n, INF);\n\tdist[A] = 0;\n\t\n\tpriority_queue<Pr, vector<Pr>, greater<Pr>> pq;\n\tpq.push(Pr(0, A));\n\twhile (pq.size()){\n\t\tPr p = pq.top(); pq.pop();\n\t\tint pos = p.second, sum = p.first;\n\t\tif (dist[pos] < sum) continue;\n\t\t\n\t\tfor (auto &e : g[pos]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] > sum + cost){\n\t\t\t\tdist[to] = sum + cost;\n\t\t\t\tpq.push(Pr(sum + cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int v = 0; v < n; v++){\n\t\tfor (auto &e : g[v]){\n\t\t\tint to = e.first, cost = e.second;\n\t\t\tif (dist[to] == dist[v] + cost){\n\t\t\t\tmg[v].push_back(to);\n\t\t\t\trmg[to].push_back(v);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid toposort(int v)\n{\n\tvisit[v] = true;\n\t\n\tfor (int to : rmg[v]){\n\t\tif (!visit[to]) toposort(to);\n\t}\n\t\n\tpos[v] = tps.size();\n\ttps.push_back(v);\n}\n\nvoid doDp(int qs[], int qt[], bool ans[])\n{\n\tfill_n(dp, 100000, 0);\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tdp[pos[qs[i]]] |= 1ull << i;\n\t}\n\t\n\tfor (int i = 0; i < tps.size(); i++){\n\t\tfor (int to : mg[tps[i]]){\n\t\t\tif (pos[to] == -1) continue;\n\t\t\tprintf(\"%d -> %d\\n\", tps[i], to);\n\t\t\tdp[pos[to]] |= dp[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < sep; i++){\n\t\tif (pos[qt[i]] == -1) ans[i] = false;\n\t\telse {\n\t\t\tans[i] = ((dp[pos[qt[i]]] & (1ull << i)) > 0ull) ? true : false;\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tdijkstra();\n\t\n\tfill_n(visit, n, false);\n\ttps = vector<int>();\n\tpos = vector<int>(n, -1);\n\ttoposort(B);\n\t\n\tfor (int i = 0; i < Q; i += sep){\n\t\tdoDp(qs + i, qt + i, ans + i);\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tputs(ans[i] ? \"Yes\" : \"No\");\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tg = vector<vector<Pr>>(n);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\tg[--u].push_back(Pr(--v, w));\n\t\tg[v].push_back(Pr(u, w));\n\t}\n\tscanf(\"%d %d %d\", &A, &B, &Q);\n\t--A; --B;\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", &qs[i], &qt[i]);\n\t\tqs[i]--; qt[i]--;\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<bitset>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int to, const int weight) :to(to), weight(weight) {}\n};\n\nconst vector<set<int>> Dijkstra(const vector<vector<Edge>>& edge, const int start, const int goal) {\n    const int INF = INT_MAX;\n    struct Node {\n        int vertex;\n        int cost;\n        vector<int> path;\n        Node(const int v, const int c, const vector<int>& p) :vertex(v), cost(c), path(p) {}\n        bool operator<(const Node& n) const {return cost > n.cost;}\n    };\n    vector<set<int>> result(edge.size());\n    vector<int> distance(edge.size(), INF);\n    priority_queue<Node> q;\n    for(q.emplace(start, 0, vector<int>()); !q.empty(); q.pop()) {\n        auto v = q.top().vertex;\n        auto cost = q.top().cost;\n        auto path = q.top().path;\n        path.push_back(v);\n        if(v == goal && cost <= distance[v]) for(int i = 1; i < path.size(); ++i) result[path[i - 1]].insert(path[i]);\n        if(distance[goal] <= cost) continue;\n        distance[v] = cost;\n        for(const auto& e: edge[v]) q.emplace(e.to, cost + e.weight, path);\n    }\n    return result;\n}\n\nvoid dfs(vector<int>& result, const vector<set<int>>& edge, const int v, vector<bool> &visited) {\n    if(visited[v]) return;\n    visited[v] = true;\n    for(const auto& to: edge[v]) dfs(result, edge, to, visited);\n    result.push_back(v);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n    dfs(result, edge, start, visited);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(const int begin, const int end) :begin(begin), end(end) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n    cin >> S >> R;\n    vector<vector<Edge>> original(S);\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = Dijkstra(original, a, b);\n    auto order = topological_sort(edge, a);\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S);\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] = dp[to] | dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[205000], bdist[205000];\nvector<P> edge[205000];\n\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 205000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    long long c[64], d[65];\n    long long dp[205000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 205000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1 << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1 << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 103000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(int now, long long *dp){\n    if(come[now])return;\n    come[now] = true;\n    for(int i = 0;i < edge[now].size();i++){\n\tint to = edge[now][i].first, d = edge[now][i].second;\n\tif(adist[now] + d == adist[to] &&\n\t   bdist[now] == d + bdist[to]){\n\t    dp[to] |= dp[now];\n\t    dfs(to, dp);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfill(come, come + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tdfs(a, dp);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tstatic vector<edge> G[100000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint a,b,q; scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n\tstatic int c[40000],d[40000];\n\trep(i,q) scanf(\"%d%d\",c+i,d+i), c[i]--, d[i]--;\n\n\t// calculate distances from a\n\tstatic int dist_a[100000];\n\trep(u,n) dist_a[u]=(u==a?0:INF);\n\tpriority_queue< pair<int,int> > Qa; Qa.push(make_pair(0,a));\n\twhile(!Qa.empty()){\n\t\tint d_now=-Qa.top().first,u=Qa.top().second; Qa.pop();\n\t\tif(d_now>dist_a[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_a[v]>dist_a[u]+cost){\n\t\t\t\tdist_a[v]=dist_a[u]+cost;\n\t\t\t\tQa.push(make_pair(-dist_a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// calculate distances from b\n\tstatic int dist_b[100000];\n\trep(u,n) dist_b[u]=(u==b?0:INF);\n\tpriority_queue< pair<int,int> > Qb; Qb.push(make_pair(0,b));\n\twhile(!Qb.empty()){\n\t\tint d_now=-Qb.top().first,u=Qb.top().second; Qb.pop();\n\t\tif(d_now>dist_b[u]) continue;\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(dist_b[v]>dist_b[u]+cost){\n\t\t\t\tdist_b[v]=dist_b[u]+cost;\n\t\t\t\tQb.push(make_pair(-dist_b[v],v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// build the shortest path DAG from a to b\n\tstatic vector<int> H[100000];\n\trep(u,n) rep(i,G[u].size()) {\n\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\tif(dist_a[u]+cost+dist_b[v]==dist_a[b]) H[u].push_back(v);\n\t}\n\n\t// find a topological order of H\n\tvector<int> top;\n\tstatic bool vis[100000];\n\tvis[a]=true;\n\tqueue<int> Q; Q.push(a);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\ttop.push_back(u);\n\t\trep(i,H[u].size()){\n\t\t\tint v=H[u][i];\n\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t}\n\t}\n// printf(\"n=%d, a=%d, b=%d: \",n,a,b);\n// rep(i,top.size()) printf(\"%d \",top[i]); puts(\"\");\n\n\t// query\n/*\n\trep(i,(q+63)/64){\n\t\tstatic ll dp[100000];\n\t\tmemset(dp,0,sizeof dp);\n\t\trep(j,64) if(64*i+j<q) dp[c[64*i+j]]|=1LL<<j;\n\t\trep(i,n){\n\t\t\tint u=top[i];\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tdp[v]|=dp[u];\n\t\t\t}\n\t\t}\n\t\trep(j,64) if(64*i+j<q) puts(dp[d[64*i+j]]&(1LL<<j)?\"Yes\":\"No\");\n\t}\n*/\n\t// naive\n\trep(i,q){\n\t\trep(u,n) vis[u]=false;\n\t\tvis[c[i]]=true;\n\t\trep(j,top.size()){\n\t\t\tint u=top[j];\n\t\t\trep(k,H[u].size()){\n\t\t\t\tint v=H[u][k];\n\t\t\t\tvis[v]|=vis[u];\n\t\t\t}\n\t\t}\n/*\n\t\tQ.push(c[i]);\n\t\twhile(!Q.empty()){\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tvis[u]=true;\n\t\t\trep(j,H[u].size()){\n\t\t\t\tint v=H[u][j];\n\t\t\t\tif(!vis[v]) vis[v]=true, Q.push(v);\n\t\t\t}\n\t\t}\n*/\n\t\tputs(vis[d[i]]?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nbool come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    if(come[now])return;\n    come[now] = true;\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    long long c[64], d[65];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1ull << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> T round_up(T a, T b) { return (a + b - 1) / b; }\n\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n\n#define F first\n#define S second\n\n\nbool topo_dfs(int v, const vector<vector<int> >& g, vector<int>& color, vector<int>& order)\n{\n    color[v] = 1;\n    for (int i = 0; i < (int)g[v].size(); ++i)\n    {\n        int to = g[v][i];\n        if (color[to] == 2)\n            continue;\n        else if (color[to] == 1)\n            return false;\n        else if (!topo_dfs(to, g, color, order))\n            return false;\n    }\n    color[v] = 2;\n\n    order.push_back(v);\n    return true;\n}\n// O(V + E)\n// impossible -> return empty vector\nvector<int> topological_sort(const vector<vector<int> >& g)\n{\n    const int n = g.size();\n\n    vector<int> color(n);\n    vector<int> order;\n\n    for (int i = 0; i < n; ++i)\n        if (color[i] == 0 && !topo_dfs(i, g, color, order))\n            return vector<int>();\n    reverse(all(order));\n    return order;\n}\n\nint main()\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n\n    vector<pint> g[ten(5)];\n    rep(i, m)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        --u, --v;\n        g[u].pb(pint(v, w));\n        g[v].pb(pint(u, w));\n    }\n\n    int a, b, Q;\n    scanf(\"%d%d%d\", &a, &b, &Q);\n    --a, --b;\n\n    // 最短経路グラフを作るためにdijkstraします\n    vector<int> prev[ten(5)];\n    int dis[ten(5)];\n    {\n        const int inf = ten(9);\n        priority_queue<pint, vector<pint>, greater<pint> > q;\n\n        fill_n(dis, n, inf);\n        dis[a] = 0;\n        q.push(pint(0, a));\n        while (!q.empty())\n        {\n            int cost = q.top().first;\n            int v = q.top().second;\n            q.pop();\n\n            if (cost > dis[v])\n                continue;\n\n            rep(i, g[v].size())\n            {\n                int to = g[v][i].first;\n                int ncost = cost + g[v][i].second;\n                if (ncost < dis[to])\n                {\n                    dis[to] = ncost;\n                    q.push(pint(ncost, to));\n\n                    prev[to].clear();\n                }\n\n                if (ncost == dis[to])\n                    prev[to].pb(v);\n            }\n        }\n    }\n\n\n    // 最短経路グラフを作ります\n    vector<vector<int> > min_g(n);\n    {\n        queue<int> q;\n        bool visit[ten(5)];\n        fill_n(visit, n, false);\n\n        visit[b] = true;\n        q.push(b);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n\n            rep(i, prev[v].size())\n            {\n                int pre = prev[v][i];\n\n                min_g[pre].pb(v);\n\n                if (!visit[pre])\n                {\n                    visit[pre] = true;\n                    q.push(pre);\n                }\n            }\n        }\n    }\n\n    vector<int> order = topological_sort(min_g);\n    assert(!order.empty());\n\n    // O((Q / 64) * (V + E))\n    while (Q > 0)\n    {\n        typedef unsigned long long ull;\n\n        // 64クエリ or クエリがなくなるまで先読みします\n        vector<int> c, d;\n        while (c.size() < 64 && Q > 0)\n        {\n            --Q;\n            int cc, dd;\n            scanf(\"%d%d\", &cc, &dd);\n            --cc, --dd;\n            c.pb(cc), d.pb(dd);\n        }\n\n        // dp[v]のi bit目が立っている時，c[i] -> vは最短経路上で到達可能\n        ull dp[ten(5)];\n        fill_n(dp, n, 0);\n        rep(i, c.size())\n            dp[c[i]] |= bin(i);\n\n        rep(i, order.size())\n        {\n            int v = order[i];\n            rep(j, min_g[v].size())\n                dp[min_g[v][j]] |= dp[v];\n        }\n\n        rep(i, c.size())\n            puts((dp[d[i]] >> i & 1) ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<climits>\nusing namespace std;\n\nstruct Edge {\n    int to, weight;\n    Edge(int t, int w) :to(t), weight(w) {}\n};\n\nvoid restore(vector<set<int>>& edge, const vector<set<int>>& previous, const int current) {\n    for(const auto& i: previous[current]) {\n        if(edge[i].count(current)) continue;\n        edge[i].insert(current);\n        restore(edge, previous, i);\n    }\n}\n\nint main() {\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n\n    // Dijkstra\n    typedef tuple<int, int, int> Node;\n\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    vector<int> distance(S, INT_MAX);\n    vector<set<int>> previous(S);\n\n    q.emplace(0, a, a);\n    while(!q.empty()) {\n        int cost, id, prev;\n        tie(cost, id, prev) = q.top();\n        q.pop();\n\n        if(distance[id] < cost) continue;\n        if(distance[id] == cost && previous[id].count(prev)) continue;\n        if(distance[id] == cost) previous[id].insert(prev);\n        else                     previous[id] = {prev};\n        distance[id] = cost;\n\n        for(const auto& e: original[id]) q.emplace(cost + e.weight, e.to, id);\n    }\n\n    // DAG\n    vector<set<int>> edge(S);\n    restore(edge, previous, b);\n\n    // topological sort\n    vector<int> order;\n    vector<bool> visited(S, false);\n    queue<int> q2;\n    q2.push(a);\n    while(!q2.empty()) {\n        int v = q2.front();\n        q2.pop();\n        if(visited[v]) continue;\n        visited[v] = true;\n        order.push_back(v);\n        for(const auto& i: edge[v]) q2.push(i);\n    }\n\n    // DP\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n\n        vector<unsigned long long int> dp(S, 0);\n        dp[c] = 1;\n        for(const auto& from: order) for(const auto& to: edge[from]) {\n            dp[to] |= dp[from];\n        }\n\n        cout << (dp[d] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<algorithm>\n#include<climits>\n#include<bitset>\nusing namespace std;\n\nconst int NIL = INT_MAX;\n\nstruct Edge {\n    int to, weight;\n    Edge(const int t, const int w) :to(t), weight(w) {}\n};\n\nconst vector<int> Dijkstra(const vector<vector<Edge>>& edge, const int start) {\n    typedef tuple<int, int> Node;\n\n    vector<int> distance(edge.size(), NIL);\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n\n    for(q.emplace(0, start); !q.empty(); q.pop()) {\n        int cost, current;\n        tie(cost, current) = q.top();\n\n        if(distance[current] != NIL) continue;\n\n        distance[current] = cost;\n        for(const auto& e: edge[current]) q.emplace(cost + e.weight, e.to);\n    }\n\n    return distance;\n}\n\nbool dfs(vector<set<int>>& result, const vector<vector<Edge>>& edge, const vector<int>& distance, const int start, const int goal, const int cost, vector<int>& memo) {\n    if(start == goal) return true;\n//     if(memo[start] != NIL) return true;\n    memo[start] = 0;\n    for(const auto& e: edge[start]) {\n        if(distance[e.to] != cost + e.weight) continue;\n        if(result[start].count(e.to)) continue;\n        if(!dfs(result, edge, distance, e.to, goal, cost + e.weight, memo)) continue;\n        memo[start] = 1;\n        result[start].insert(e.to);\n    }\n    return memo[start];\n}\nconst vector<set<int>> make_DAG(const vector<vector<Edge>>& edge,const int start, const int goal) {\n    vector<set<int>> result(edge.size());\n    vector<int> memo(edge.size(), NIL);\n    dfs(result, edge, Dijkstra(edge, start), start, goal, 0, memo);\n    return result;\n}\n\nvoid ts_dfs(vector<int>& result, const vector<set<int>>& edge, vector<bool>& visited, const int current) {\n    if(visited[current]) return;\n    visited[current] = true;\n    for(const auto& to: edge[current]) ts_dfs(result, edge, visited, to);\n    result.push_back(current);\n}\nconst vector<int> topological_sort(const vector<set<int>>& edge, const int start, const int goal) {\n    vector<int> result;\n    vector<bool> visited(edge.size(), false);\n//     for(int i = 0; i < edge.size(); ++i) ts_dfs(result, edge, visited, i);\n    ts_dfs(result, edge, visited, start);\n    reverse(result.begin(), result.end());\n    return result;\n}\n\nint main() {\n    struct Query {\n        int begin, end;\n        Query(int b, int e) :begin(b), end(e) {}\n    };\n\n    int S, R;\n    int a, b, Q;\n\n    cin >> S >> R;\n    vector<vector<Edge>> original(S, vector<Edge>());\n    for(int i = 0; i < R; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        --u; --v;\n        original[u].emplace_back(v, w);\n        original[v].emplace_back(u, w);\n    }\n\n    cin >> a >> b >> Q;\n    --a; --b;\n    vector<Query> query;\n    for(int i = 0; i < Q; ++i) {\n        int c, d;\n        cin >> c >> d;\n        --c; --d;\n        query.emplace_back(c, d);\n    }\n\n    auto edge = make_DAG(original, a, b);\n    auto order = topological_sort(edge, a, b);\n\n//     cout<<\"edge\"<<endl;for(int i=0;i<S;++i){\n//         cout<<i+1<<\"    \";\n//         for(auto v: edge[i])cout<<\" \"<<v+1;\n//         cout<<endl;\n//     }\n\n    const int BIT = 64;\n    for(int i = 0; i < Q; i += BIT) {\n        vector<bitset<BIT>> dp(S, bitset<BIT>());\n        for(int j = 0; j < BIT && i + j < Q; ++j) dp[query[i + j].begin].set(j);\n        for(const auto& from: order) for(const auto& to: edge[from]) dp[to] |= dp[from];\n        for(int j = 0; j < BIT && i + j < Q; ++j) cout << (dp[query[i + j].end].test(j) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint S, R, a, b, Q;\n\nvector<pii> edges;\n\nvoid dijkstra(const vector< vector<pii> > &g, int s, int t, vector<int> &ret){\n\tint n = g.size();\n\tret = vector<int>(n, INF);\n\tvector< vector<int> > prev(S);\n\n\tpriority_queue<pii, vector<pii>, greater<pii> > dp;\n\tdp.push(pii(0, s));\n\tret[s] = 0;\n\twhile(!dp.empty()){\n\t\tint s = dp.top().second;\n\t\tdp.pop();\n\t\tFOR(it, g[s]){\n\t\t\tint t = it->first;\n\t\t\tif(ret[t] > ret[s]+it->second){\n\t\t\t\tret[t] = ret[s]+it->second;\n\t\t\t\tprev[t].clear();\n\t\t\t\tprev[t].push_back(s);\n\t\t\t\tdp.push(pii(ret[t], t));\n\t\t\t}else if(ret[t] == ret[s]+it->second){\n\t\t\t\tprev[t].push_back(s);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tvector<int> vis(S, 0);\n\tq.push(t);\n\tvis[t] = 1;\n\twhile(!q.empty()){\n\t\tint s = q.front();\n\t\tq.pop();\n\t\tFOR(it, prev[s]){\n\t\t\tedges.push_back(pii(*it, s));\n\t\t\tif(!vis[*it]){\n\t\t\t\tq.push(*it);\n\t\t\t\tvis[*it] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treverse(ALL(edges));\n}\n\nvoid solve(vector<ull> src, vector<ull> dest){\n\tvector<ull> f(S, 0);\n\tREP(i, src.size()) f[src[i]] |= 1LL << i;\n\tFOR(it, edges) f[it->second] |= f[it->first];\n\tREP(i, dest.size()) puts((f[dest[i]] & (1LL << i)) ? \"Yes\" : \"No\");\n}\n\nmain(){\n\tscanf(\"%d%d\", &S, &R);\n\tvector< vector<pii> > g(S);\n\tREP(i, R){\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\tg[u-1].push_back(pii(v-1, w));\n\t\tg[v-1].push_back(pii(u-1, w));\n\t}\n\tscanf(\"%d%d%d\", &a, &b, &Q);\n\tvector<int> dis;\n\tdijkstra(g, a-1, b-1, dis);\n\tvector<ull> src(64), dest(64);\n\tREP(i, Q){\n\t\tint c, d;\n\t\tscanf(\"%d%d\", &c, &d);\n\t\tsrc[i%64] = c-1;\n\t\tdest[i%64] = d-1;\n\t\tif(i%64 == 63) solve(src, dest);\n\t}\n\tif(Q%64){\n\t\tsrc.resize(Q%64);\n\t\tdest.resize(Q%64);\n\t\tsolve(src, dest);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\n\nvoid dfs(int v, vector<int> &topo)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i], topo);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (weight[x.to] < x.cost) continue;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tif (weight[TG[x.to][i].to] > x.cost + TG[x.to][i].cost){\n\t\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tqueue<int> q;\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> topo;\n\tdfs(a, topo);\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tlong long int accessable[100000] = {0};\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); j++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\n\nconstexpr int INF = 1'000'000'100;\nint S, R;\nstd::vector<P> G[100100];\nint A, B, Q;\nstd::vector<int> Q1[100100], Q2[100100];\nint distA[100100], distB[100100], order[100100];\nstd::bitset<400> visited[100100];\nbool exists[40100];\n\nstd::priority_queue<P, std::vector<P>, std::greater<P>> pq;\n\nvoid dijkstra(int A, int (&dist)[100100]){\n    std::fill(dist + 1, dist + 1 + S, INF);\n\n    pq.emplace(0, A);\n    dist[A] = 0;\n\n    until(pq.empty()){\n        int d, u;\n        std::tie(d, u) = pq.top();\n        pq.pop();\n\n        if(d > dist[u]){\n            continue;\n        }\n\n        for(auto &e : G[u]){\n            int v, w;\n            std::tie(v, w) = e;\n\n            if(dist[v] > d + w){\n                dist[v] = d + w;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> S >> R;\n\n    for(int i=0;i<R;++i){\n        int u, v, w;\n        std::cin >> u >> v >> w;\n\n        G[u].emplace_back(v, w);\n        G[v].emplace_back(u, w);\n    }\n\n    std::cin >> A >> B >> Q;\n\n    for(int i=0;i<Q;++i){\n        int c, d;\n        std::cin >> c >> d;\n\n        Q1[c].emplace_back(i);\n        Q2[d].emplace_back(i);\n    }\n\n    dijkstra(A, distA);\n    dijkstra(B, distB);\n\n    std::iota(order, order + S, 1);\n    std::sort(order, order + S, [&](int l, int r){return distA[l] < distA[r];});\n\n    for(int i=0;i<Q;i+=400){\n        for(int j=1;j<=S;++j){\n            visited[j].reset();\n        }\n\n        for(int u : order){\n            for(auto q : Q2[u]){\n                if(i <= q && q < i + 400 &&\n                   visited[u].test(q - i) && distA[u] + distB[u] == distA[B]){\n                    exists[q] = true;\n                }\n            }\n\n            for(auto q : Q1[u]){\n                if(i <= q && q < i + 400){\n                    visited[u].set(q - i);\n                }\n            }\n\n            for(auto &e : G[u]){\n                int v, w;\n                std::tie(v, w) = e;\n\n                if(distA[v] == distA[u] + w){\n                    visited[v] |= visited[u];\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<Q;++i){\n        if(exists[i]){\n            std::cout << \"Yes\" << std::endl;\n        }else{\n            std::cout << \"No\" << std::endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int inf = 1e9;\nint s,r,a,b,q,c,d,u,v,w;\nvector<pii> g[100100];\nvector<int> ming[100100];\nint dis[100100];\nbool vis[100100];\n\nbool dfs(int now,int goal){\n  if(now == goal)return true;\n  if(vis[now])return false;\n  vis[now] = true;\n\n  rep(i,ming[now].size()){\n    if(dfs(ming[now][i],goal))return true;\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%d%d\",&s,&r);\n  rep(i,r){\n    scanf(\"%d%d%d\",&u,&v,&w); u--; v--;\n    g[u].push_back(pii(w,v));\n    g[v].push_back(pii(w,u));\n  }\n  \n  scanf(\"%d%d%d\",&a,&b,&q); a--; b--;\n  memset(dis,-1,sizeof(dis));\n  dis[a] = 0;\n  priority_queue<pii,vector<pii>,greater<pii> > que;\n  que.push(pii(0,a));\n\n  while(que.size()){\n    pii p = que.top(); que.pop();\n    int cost = p.first, pos = p.second;\n    if(dis[pos]<cost)continue;\n\n    rep(i,g[pos].size()){\n      int ncost = cost + g[pos][i].first, npos = g[pos][i].second;\n      if(dis[npos]< 0 || dis[npos] > ncost){\n\tdis[npos] = ncost;\n\tque.push(pii(ncost,npos));\n      }\n    }\n  }\n\n  memset(vis,0,sizeof(vis));\n  vis[b] = true;\n  queue<int> state;\n  state.push(b);\n\n  while(state.size()){\n    int p = state.front(); state.pop();\n\n    rep(i,g[p].size()){\n      int np = g[p][i].second, nc = g[p][i].first;\n      if(dis[p] == dis[np] + nc){\n\tming[np].push_back(p);\n\tif(!vis[np]){\n\t  state.push(np);\n\t  vis[np] = true;\n\t}\n      }\n    }\n  }\n\n  map<pii,bool> memo;\n  rep(i,q){\n    scanf(\"%d%d\",&c,&d); c--; d--;\n\n    bool f;\n    if(memo.find(pii(c,d))!=memo.end())f = memo[pii(c,d)];\n    else{\n      memset(vis,0,sizeof(vis));\n      memo[pii(c,d)] = f = dfs(c,d);\n    }\n\n    if(f)printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 103000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] == INF || adist[v[i]] == INF ||\n\t   bdist[u[i]] == INF || bdist[v[i]] == INF)\n\t    continue;\n\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n\tswap(u[i], v[i]);\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 50){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1ULL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 50 && i + j < q;j++){\n\t    if(dp[d[j]] & (1ULL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 30;\n\nstruct edge{\n  int to, cost;\n};\nstruct edge2{\n  int u, v, cost;\n  bool operator<(const edge2& hoge)const{\n    return cost < hoge.cost;\n  }\n};\ntypedef vector< vector< edge > > Graph;\ntypedef vector< edge2 > Edges; /* 辺集合 */\n\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, Graph& graph) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int > min_cost;\n  min_cost.resize(info.size(), -1);\n  que.push( Pi( 0, s));\n  min_cost[s] = 0;\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n        graph[e.to].clear(); /* 最短ルートではない */\n      }\n      if(p.first + e.cost == min_cost[e.to]){\n        add_edge( graph, e.to, p.second, -1, false); /* 最短ルート */\n      }\n    }\n  }\n  return -1;\n}\n\nGraph Make_Dag(Graph& graph, int start){\n  vector< bool > used(graph.size(), false);\n  queue< int > Que;\n  Graph ret(graph.size());\n\n  Que.push(start);\n  used[start] = true;\n  while(!Que.empty()){\n    int idx = Que.front(); Que.pop();\n    for(int i = 0; i < graph[idx].size(); i++){\n      edge& e = graph[idx][i];\n      add_edge( ret, e.to, idx, -1, false);\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      Que.push(e.to);\n    }\n  }\n  return ret;\n}\n\nvoid dfs(int idx, vector< bool >& used, Graph& graph, vector< int >& ret){\n  used[idx] = true;\n  for(int i = 0; i < graph[idx].size(); i++){\n    edge& e = graph[idx][i];\n    if(!used[e.to]) dfs( e.to, used, graph, ret);\n  }\n  ret.push_back(idx);\n}\n\nvector< int > Topological(Graph& graph){\n  vector< int > ret;\n  vector< bool > used(graph.size(), false);\n  for(int i = 0; i < graph.size(); i++){\n    if(!used[i]) dfs( i, used, graph, ret);\n  }\n  reverse( ret.begin(), ret.end());\n  return ret;\n}\n\n\nvoid solve(Graph& graph, vector< int >& edges, vector< Pi >& query){\n  vector< unsigned long long int > dp(graph.size());\n  for(int _ = 0; _ < query.size(); _ += 64){\n    int start = _, end = min< int >( _ + 64, query.size());\n    fill( dp.begin(), dp.end(), 0uLL);\n    for(int i = start; i < end; i++){\n      dp[query[i].first] |= 1uLL << (i - start);\n    }\n    for(int __ = 0; __ < edges.size(); __++){\n      int j = edges[__];\n      if(dp[j] == 0uLL) continue;\n      for(int k = 0; k < graph[j].size(); k++){\n        dp[graph[j][k].to] |= dp[j];\n      }\n    }\n    for(int i = start; i < end; i++){\n      puts( ((dp[query[i].second] >> (i - start)) & 1) ? \"Yes\" : \"No\");\n    }\n  }\n}\n\nint main(){\n  int S, R;\n  scanf(\"%d %d\", &S, &R);\n  Graph info(S);\n  for(int i = 0; i < R; i++){\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    u--, v--;\n    add_edge( info, u, v, w);\n  }\n  int a, b, Q;\n  scanf(\"%d %d %d\", &a, &b, &Q);\n  a--, b--;\n\n  Graph graph(S);\n  Dijkstra( info, a, -1, graph);\n  Graph ret = Make_Dag(graph, b);\n  vector< int > rets = Topological(ret);\n  vector< Pi > query(Q);\n  for(int i = 0; i < query.size(); i++){\n    scanf(\"%d %d\", &query[i].first, &query[i].second);\n    query[i].first--, query[i].second--;\n  }\n  solve( ret, rets, query);\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100001\n\nenum Type{\n\tfrom_A,\n\tfrom_B,\n};\n\nstruct Edge{\n\tEdge(int arg_to,int arg_dist){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t}\n\tint to,dist;\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_sum_dist){\n\t\tnode_id = arg_node_id;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総距離の昇順(PQ)\n\t\treturn sum_dist > arg.sum_dist;\n\t}\n\n\tint node_id,sum_dist;\n};\n\nstruct Data{\n\tData(int arg_node_id,int arg_sum_dist){\n\t\tnode_id = arg_node_id;\n\t\tsum_dist = arg_sum_dist;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn sum_dist < arg.sum_dist;\n\t}\n\tint node_id,sum_dist;\n};\n\nint N,M;\nint A,B,C,D;\nint min_dist[NUM][2];\nbool is_on_shortest_path[NUM],visited[NUM];\nvector<Edge> G[NUM];\nvector<int> DAG_G[NUM];\n\nvoid dijkstra(int start,Type type){\n\n\tfor(int i = 0; i < N; i++)min_dist[i][type] = BIG_NUM;\n\tmin_dist[start][type] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(Info(start,0));\n\n\tint next_node,next_dist;\n\twhile(!Q.empty()){\n\t\tif(Q.top().sum_dist > min_dist[Q.top().node_id][type]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\t\t\t\tnext_dist = Q.top().sum_dist+G[Q.top().node_id][i].dist;\n\n\t\t\t\tif(min_dist[next_node][type] > next_dist){\n\t\t\t\t\tmin_dist[next_node][type] = next_dist;\n\t\t\t\t\tQ.push(Info(next_node,next_dist));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\nbool can_visit(int node_id,int goal){\n\n\tint next_node;\n\n\tfor(int i = 0; i < DAG_G[node_id].size(); i++){\n\t\tnext_node = DAG_G[node_id][i];\n\t\tif(next_node == goal)return true;\n\n\t\tif(min_dist[next_node][from_A] >= min_dist[D][from_A])continue; //Dより遠いノードはSKIP\n\t\tif(visited[next_node])continue;\n\n\t\tvisited[next_node] = true; //枝分かれ後に合流する可能性あり\n\t\tif(can_visit(next_node,goal))return true;\n\t}\n\treturn false;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tint from,to,dist;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %d\",&from,&to,&dist);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,dist));\n\t\tG[to].push_back(Edge(from,dist));\n\t}\n\n\tint num_query;\n\tscanf(\"%d %d %d\",&A,&B,&num_query);\n\tA--;\n\tB--;\n\n\t//AとBからダイクストラ\n\tdijkstra(A,from_A);\n\tdijkstra(B,from_B);\n\n\t//A→B間の最短距離上に無い点を調べる\n\tfor(int i = 0; i < N; i++){\n\t\tif(min_dist[i][from_A]+min_dist[i][from_B] == min_dist[B][from_A]){\n\t\t\tis_on_shortest_path[i] = true;\n\t\t}else{\n\t\t\tis_on_shortest_path[i] = false;\n\t\t}\n\t}\n\n\tvector<Data> V;\n\t//最短経路DAGを構成する\n\tfor(int i = 0; i < N; i++){\n\t\tif(is_on_shortest_path[i]){\n\t\t\tV.push_back(Data(i,min_dist[i][from_A]));\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tint node_id,next_node;\n\t//最短経路DAG上のエッジを生成する\n\tfor(int i = 0; i < V.size(); i++){\n\t\tnode_id = V[i].node_id;\n\n\t\tfor(int k = 0; k < G[node_id].size(); k++){\n\t\t\tnext_node = G[node_id][k].to;\n\t\t\tif(min_dist[next_node][from_A] <= min_dist[node_id][from_A])continue; //next_nodeの方がAに近ければSKIP\n\n\t\t\tif(min_dist[node_id][from_A]+G[node_id][k].dist+min_dist[next_node][from_B] > min_dist[B][from_A])continue; //最短経路上の辺でなければSKIP\n\n\t\t\tDAG_G[node_id].push_back(next_node);\n\t\t}\n\t}\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\t\tscanf(\"%d %d\",&C,&D);\n\t\tC--;\n\t\tD--;\n\t\tif(is_on_shortest_path[C] == false || is_on_shortest_path[D] == false ||\n\t\t\t\tmin_dist[C][from_A] >= min_dist[D][from_A]){\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++)visited[i] = false;\n\n\t\tvisited[C] = true;\n\t\tif(can_visit(C,D)){\n\t\t\tprintf(\"Yes\\n\");\n\t\t}else{\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nbool come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    if(come[now]){ return;}\n    come[now] = true;\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    fill(come, come + 105000, false);\n    dfs(a);\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <utility>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename T = int >\nstruct Edge {\n  int from, to;\n  T cost;\n  int idx;\n\n  Edge() = default;\n\n  Edge(int from, int to, T cost = 1, int idx = -1) : from(from), to(to), cost(cost), idx(idx) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T = int >\nstruct Graph {\n  vector< vector< Edge< T > > > g;\n  int es;\n\n  Graph() = default;\n\n  explicit Graph(int n) : g(n), es(0) {}\n\n  size_t size() const {\n    return g.size();\n  }\n\n  void add_directed_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost, es++);\n  }\n\n  void add_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost, es);\n    g[to].emplace_back(to, from, cost, es++);\n  }\n\n  void read(int M, int padding = -1, bool weighted = false, bool directed = false) {\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      cin >> a >> b;\n      a += padding;\n      b += padding;\n      T c = T(1);\n      if(weighted) cin >> c;\n      if(directed) add_directed_edge(a, b, c);\n      else add_edge(a, b, c);\n    }\n  }\n};\n\n/**\n * @brief Dijkstra(単一始点最短路)\n */\ntemplate< typename T >\nvector< T > dijkstra(const Graph< T > &g, int s) {\n  const auto INF = numeric_limits< T >::max();\n  vector< T > dist(g.size(), INF);\n\n  using Pi = pair< T, int >;\n  priority_queue< Pi, vector< Pi >, greater<> > que;\n  dist[s] = 0;\n  que.emplace(dist[s], s);\n  while(!que.empty()) {\n    T cost;\n    int idx;\n    tie(cost, idx) = que.top();\n    que.pop();\n    if(dist[idx] < cost) continue;\n    for(auto &e : g.g[idx]) {\n      auto next_cost = cost + e.cost;\n      if(dist[e.to] <= next_cost) continue;\n      dist[e.to] = next_cost;\n      que.emplace(dist[e.to], e.to);\n    }\n  }\n  return dist;\n}\n\n\n/**\n * @brief Topological-Sort(トポロジカルソート)\n */\ntemplate< typename T >\nvector< int > topological_sort(const Graph< T > &g) {\n  const int N = (int) g.size();\n  vector< int > deg(N);\n  for(int i = 0; i < N; i++) {\n    for(auto &to : g.g[i]) ++deg[to];\n  }\n  stack< int > st;\n  for(int i = 0; i < N; i++) {\n    if(deg[i] == 0) st.emplace(i);\n  }\n  vector< int > ord;\n  while(!st.empty()) {\n    auto p = st.top();\n    st.pop();\n    ord.emplace_back(p);\n    for(auto &to : g.g[p]) {\n      if(--deg[to] == 0) st.emplace(to);\n    }\n  }\n  return ord;\n}\n\n\n/**\n * @brief Offline-Dag-Reachability(DAGの到達可能性)\n */\ntemplate< typename T >\nvector< int > offline_dag_reachability(const Graph< T > &g, vector< pair< int, int > > &qs) {\n  const int N = (int) g.size();\n  const int Q = (int) qs.size();\n  auto ord = topological_sort(g);\n  vector< int > ans(Q);\n  for(int l = 0; l < Q; l += 64) {\n    int r = min(Q, l + 64);\n    vector< int64_t > dp(N);\n    for(int k = l; k < r; k++) {\n      dp[qs[k].first] |= int64_t(1) << (k - l);\n    }\n    for(auto &idx : ord) {\n      for(auto &to : g.g[idx]) dp[to] |= dp[idx];\n    }\n    for(int k = l; k < r; k++) {\n      ans[k] = (dp[qs[k].second] >> (k - l)) & 1;\n    }\n  }\n  return ans;\n}\n\n\nint main() {\n  int S, R, A, B, Q;\n  cin >> S >> R;\n  Graph< int > g(S);\n  vector< int > U(R), V(R), C(R);\n  for(int i = 0; i < R; i++) {\n    cin >> U[i] >> V[i] >> C[i];\n    --U[i], --V[i];\n    g.add_edge(U[i], V[i], C[i]);\n  }\n  cin >> A >> B >> Q;\n  --A, --B;\n  auto pre = dijkstra(g, A);\n  auto suf = dijkstra(g, B);\n\n  Graph< int > dag(S);\n  for(int i = 0; i < R; i++) {\n    if(pre[U[i]] + C[i] + suf[V[i]] == pre[B]) dag.add_directed_edge(U[i], V[i]);\n    if(pre[V[i]] + C[i] + suf[U[i]] == pre[B]) dag.add_directed_edge(V[i], U[i]);\n  }\n  vector< pair< int, int > > qs(Q);\n  for(auto &p : qs) {\n    cin >> p.first >> p.second;\n    --p.first, --p.second;\n  }\n  auto ans = offline_dag_reachability(dag, qs);\n  for(auto &p : ans) cout << (p ? \"Yes\\n\" : \"No\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\n\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nvoid dfs(long long now){\n    for(long long i = 0;i < edge[now].size();i++){\n\tlong long to = edge[now][i].first, r = edge[now][i].second;\n\tif(adist[to] == adist[now] + r && bdist[to] + r == bdist[now]){\n\t    valid_edge.push_back(P(now, to));\n\t    dfs(to);\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u, v, w;\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(v, w));\n\tedge[v].push_back(P(u, w));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    dfs(a);\n    long long c[64], d[65];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{\n    int to,cost;\n    edge(int to,int cost):to(to),cost(cost){}\n};\nconst int INF=1001001001;\nint N,M;\nint S,T,Q;\nvector<edge>G[100000];\nvector<int>L[100000];\nint dist[100000];\nbool used[100000];\nunsigned long long dp[100000];\nvector<int>ord;\nvoid dijkstra(){\n    fill_n(dist,N,INF);\n    dist[S]=0;\n    priority_queue<P,vector<P>,greater<P> >que;\n    que.push(P(0,S));\n\n    while(que.size()){\n        P p=que.top();que.pop();\n        if(dist[p.second]<p.first)continue;\n        for(int i=0;i<G[p.second].size();i++){\n            edge &e=G[p.second][i];\n            if(dist[e.to]<=p.first+e.cost)continue;\n            dist[e.to]=p.first+e.cost;\n            que.push(P(dist[e.to],e.to));\n        }\n    }\n}\n\nvoid dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(used[e.to])continue;\n        dfs(e.to);\n    }\n    ord.push_back(v);\n}\n\nvoid build(){\n    queue<int>que;\n    que.push(T);\n    fill_n(used,N,false);\n    used[T]=true;\n    while(que.size()){\n        int pos=que.front();que.pop();\n        for(int i=0;i<G[pos].size();i++){\n            edge &e=G[pos][i];\n            if(dist[e.to]+e.cost==dist[pos]){\n                L[e.to].push_back(pos);\n                if(!used[e.to]){\n                    used[e.to]=true;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&M);\n    for(int i=0;i<M;i++){\n        int a,b,c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        a--;b--;\n        G[a].push_back(edge(b,c));\n        G[b].push_back(edge(a,c));\n    }\n    scanf(\"%d%d%d\",&S,&T,&Q);\n    S--;T--;\n\n    dijkstra();\n    for(int i=0;i<N;i++)if(!used[i])dfs(i);\n    reverse(ord.begin(),ord.end());\n    build();\n    for(int i=0;i<N;i++){\n        for(int j=0;j<L[i].size();j++){\n            cout<<i+1<<\" \"<<L[i][j]+1<<endl;\n        }\n    }\n\n    for(int i=0;i<(Q+63)/64;i++){\n        int a[64],b[64];\n        int lim=min(64,Q-i*64);\n        for(int j=0;j<lim;j++){\n            scanf(\"%d%d\",&a[j],&b[j]);\n            a[j]--;b[j]--;\n            dp[a[j]]|=(1ll<<j);\n        }\n        for(int j=0;j<N;j++){\n            int v=ord[j];\n            for(int k=0;k<L[v].size();k++){\n                int to=L[v][k];\n                dp[to]|=dp[v];\n            }\n        }\n\n        for(int j=0;j<lim;j++){\n            if(dp[b[j]]>>j&1)puts(\"Yes\");\n            else puts(\"No\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\n#define INF (1LL << 60)\ntypedef pair<long long, long long> P;\n\nvector<P> valid_edge;\nlong long adist[105000], bdist[105000];\nvector<P> edge[105000];\nlong long come[105000];\nvoid dijkstra(long long start, long long *dist){\n    fill(dist, dist + 105000, INF);\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dist[start] = 0;\n    pq.push(P(0, start));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long from = tmp.second, d = tmp.first;\n\tif(dist[from] < d)continue;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long to = edge[from][i].first, r = edge[from][i].second;\n\t    if(dist[from] + r >= dist[to])continue;\n\t    dist[to] = dist[from] + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\nint main(){\n    long long s, r, a, b, q, u[210000], v[210000], w[210000];\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u[i] >> v[i] >> w[i];\n\tedge[u[i]].push_back(P(v[i], w[i]));\n\tedge[v[i]].push_back(P(u[i], w[i]));\n    }\n    cin >> a >> b >> q;\n    dijkstra(a, adist);\n    dijkstra(b, bdist);\n    for(int i = 0;i < r;i++){\n\tif(adist[u[i]] + bdist[u[i]] == bdist[a] && \n\t   adist[v[i]] + bdist[v[i]] == bdist[a] && \n\t   adist[u[i]] + w[i] == adist[v[i]]){\n\t    valid_edge.push_back(P(u[i], v[i]));\n\t}\n    }\n\n    long long c[64], d[64];\n    long long dp[105000];\n    for(long long i = 0;i < q;i += 60){\n\tfill(dp, dp + 105000, 0);\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    cin >> c[j] >> d[j];\n\t    dp[c[j]] |= (1LL << j);\n\t}\n\tfor(long long j = 0;j < valid_edge.size();j++){\n\t    long long from = valid_edge[j].first;\n\t    long long to = valid_edge[j].second;\n\t    dp[to] |= dp[from];\n\t}\n\tfor(long long j = 0;j < 60 && i + j < q;j++){\n\t    if(dp[d[j]] & (1LL << j))cout << \"Yes\" << endl;\n\t    else cout << \"No\" << endl;\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost) : to(to), cost(cost){}\n\tEdge(){}\n};\n\nbool operator < (const Edge &a, const Edge &b)\n{\n\treturn (a.cost > b.cost);\n}\n\nlong long int accessable[100000];\nbool vis[100000];\nvector<Edge> TG[100000];\nvector<int> G[100000];\nint c[40000], d[40000];\nvector<int> topo;\n\nvoid dfs(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (!vis[G[v][i]]) dfs(G[v][i]);\n\ttopo.push_back(v);\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tscanf(\"%d %d\", &N, &M);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tint u, v, w;\n\t\tscanf(\"%d %d %d\", &u, &v, &w);\n\t\t--u; --v;\n\t\tTG[u].push_back(Edge(v, w));\n\t\tTG[v].push_back(Edge(u, w));\n\t}\n\t\n\tint a, b, Q;\n\t\n\tscanf(\"%d %d %d\", &a, &b, &Q);\n\t\n\t--a; --b;\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d\", c + i, d + i);\n\t\t--c[i]; --d[i];\n\t}\n\t\n\tpriority_queue<Edge> pq;\n\tbool done[100000];\n\tint weight[100000];\n\tfill(weight, weight + N, 1001001001);\n\t\n\tfor (pq.push(Edge(a, 0)); pq.size(); pq.pop()){\n\t\tEdge x = pq.top();\n\t\t\n\t\tif (done[x.to]) continue;\n\t\tdone[x.to] = true;\n\t\tweight[x.to] = x.cost;\n\t\t\n\t\tfor (int i = 0; i < TG[x.to].size(); i++){\n\t\t\tpq.push(Edge(TG[x.to][i].to, x.cost + TG[x.to][i].cost));\n\t\t}\n\t}\n\t\n\tint in[100000] = {0};\n\tqueue<int> q;\n\tmemset(done, 0, sizeof(done));\n\t\n\tfor (q.push(b); q.size(); q.pop()){\n\t\tint x = q.front();\n\t\tif (done[x]) continue;\n\t\tfor (int i = 0; i < TG[x].size(); i++){\n\t\t\tif (weight[x] == weight[TG[x][i].to] + TG[x][i].cost){\n\t\t\t\tq.push(TG[x][i].to);\n\t\t\t\tG[TG[x][i].to].push_back(x);\n\t\t\t\tin[x]++;\n\t\t\t}\n\t\t}\n\t\tdone[x] = true;\n\t}\n\t\n\tfor (int i = 0; i < N; i++){\n\t\tif (!in[i]) dfs(i);\n\t}\n\treverse(topo.begin(), topo.end());\n\t\n\tfor (int i = 0; i < (Q + 63) / 64; i++){\n\t\tmemset(accessable, 0, sizeof(accessable));\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\taccessable[c[j]] |= (1 << (j % 64));\n\t\t}\n\t\tfor (int j = 0; j < topo.size(); j++){\n\t\t\tfor (int k = 0; k < G[topo[j]].size(); k++){\n\t\t\t\taccessable[G[topo[j]][k]] |= accessable[topo[j]];\n\t\t\t}\n\t\t}\n\t\tfor (int j = i * 64; j < min(Q, (i + 1) * 64); j++){\n\t\t\tif ((accessable[d[j]] >> (j % 64)) & 1) puts(\"Yes\");\n\t\t\telse puts(\"No\");\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<long long, long long> P;\n#define INF (1LL << 60)\n\nvector<P> edge[105000];\nlong long adist[105000], bdist[105000];\nlong long a, b, c, d, q, u, v, w, s, r;\nvoid dijkstra(long long *dist, long long x){\n    fill(dist, dist + 105000, INF);\n    dist[x] = 0;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    pq.push(P(0, x));\n    while(!pq.empty()){\n\tP tmp = pq.top();pq.pop();\n\tlong long d = tmp.first, from = tmp.second;\n\tif(dist[from] < d)break;\n\tfor(long long i = 0;i < edge[from].size();i++){\n\t    long long r = edge[from][i].first, to = edge[from][i].second;\n\t    if(dist[to] <= d + r)continue;\n\t    dist[to] = d + r;\n\t    pq.push(P(dist[to], to));\n\t}\n    }\n}\n\n\nbool solve(long long c, long long d){\n    if(adist[c] + bdist[c] != adist[b])return false;\n    if(c == d)return true;\n    for(long long i = 0;i < edge[c].size();i++){\n\tlong long r = edge[c][i].first, to = edge[c][i].second;\n\tif(adist[c] + r != adist[to])continue;\n\tif(solve(to, d))return true;\n    }\n    return false;\n}\n\nint main(){\n    cin >> s >> r;\n    for(long long i = 0;i < r;i++){\n\tcin >> u >> v >> w;\n\tedge[u].push_back(P(w, v));\n\tedge[v].push_back(P(w, u));\n    }\n    cin >> a >> b >> q;\n    dijkstra(adist, a);\n    dijkstra(bdist, b);\n    if(adist[b] != bdist[a])return 1;\n    for(long long i = 0;i < q;i++){\n\tcin >> c >> d;\n\tif(solve(c, d))\n\t    cout << \"Yes\" << endl;\n\telse\n\t    cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 100003\n\nint S;\nint   hi[MAX], *to[MAX]; short *w[MAX];\nint dist[MAX];\nchar  mk[MAX];\nint  hi2[MAX], *to2[MAX];\n\nint   q[MAX], top, tail;\ntypedef struct { int s, e; } T;\nT ord[200002], _ord[200002]; int sz;\nint f[200002];\n\nint c[65], d[65];\nunsigned long long dp[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, e, d;\n\n\tmemset(dist, INF, S << 2);\n\tqsize = 0;\n\tenq(start, 0), dist[start] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n}\n\nvoid order(int goal)\n{\n    int i, k, s, e, max;\n\n\tq[0] = goal, top = 0, tail = 1;\n\tmk[goal] = 1;\n\tsz = 0, max = 0;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (!mk[e]) mk[e] = 1, q[tail++] = e;\n\n\t\t\t_ord[sz].s = e, _ord[sz++].e = s;\n\t\t\tk = dist[s];\n\t\t\tif (k > max) max = k;\n\t\t\tf[k]++;\n\t\t}\n\t}\n\n\tfor (i = 1; i <= max; i++) f[i] += f[i-1];\n\tfor (i = sz-1; i >= 0; i--) {\n\t\tk = dist[_ord[i].e], ord[--f[k]] = _ord[i];\n\t}\n}\n\nint main()\n{\n\tint R, Q, u, v, _w, i, j, k;\n\tint *memo;\n\tunsigned long long mask;\n\t\n\tS = in()+1, R = in();\n\tmemo = malloc(R*12);\n\tj = 0, i = R; while (i--) {\n\t\tmemo[j++] = u = in(), hi[u]++;\n\t\tmemo[j++] = v = in(), hi[v]++;\n\t\tmemo[j++] = in();\n\t}\n\tfor (i = 0; i < S; i++) if (hi[i]) {\n\t\tto [i] = malloc(hi[i] << 2), w[i] = malloc(hi[i] << 1);\n\t\tto2[i] = malloc(hi[i] << 2);\n\t}\n\n\tmemset(hi, 0, S << 2);\n\tj = 0; while (R--) {\n\t\tu = memo[j++], v = memo[j++], _w = memo[j++];\n\t\tk = hi[u]++, to[u][k] = v, w[u][k] = _w;\n\t\tk = hi[v]++, to[v][k] = u, w[v][k] = _w;\n\t}\n\tfree(memo);\n\n\tu = in(), v = in();\n\tdijkstra(u);\n\torder(v);\n\n\tQ = in(); for (i = 0; i < Q; ) {\n\t\tfor (k = 0; k < 64 && i < Q; i++) c[k] = in(), d[k++] = in();\n        memset(dp, 0, S << 3);\n\t\tmask = 1; for (j = 0; j < k; j++) dp[c[j]] |= mask, mask <<= 1;\n\t\tfor (j = 0; j < sz; j++) dp[ord[j].e] |= dp[ord[j].s];\n        mask = 1; for (j = 0; j < k; j++) {\n            puts(dp[d[j]] & mask? \"Yes\": \"No\"), mask <<= 1;\n\t\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 200000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\nint S; \nint hi[100002], *to[100002]; short *w[100002];\nint dist[100002];\nchar mk[100002];\nint c[40002], d[40002];\n\nint q[100002], top, tail;\nint hi2[100002], *to2[100002];\nint deg[100002];\nint ord[100002], cnt;\n\nunsigned long long dp[100002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, e, d;\n\n\tmemset(dist, INF, S << 2);\n\tqsize = 0;\n\tenq(start, 0), dist[start] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\td = dist[s] + w[s][i];\n\t\t\tif (dist[e] > d) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n}\n\nvoid tsort(int start, int goal)\n{\n    int i, s, e;\n\n\tmemset(mk, 0, S);\n\tq[0] = goal, top = 0, tail = 1;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tif (mk[s]) continue;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (dist[s] == dist[e] + w[s][i]) {\n\t\t\t\tq[tail++] = e;\n\t\t\t\tto2[e][hi2[e]++] = s;\n\t\t\t}\n\t\t}\n\t\tmk[s] = 1;\n\t}\n\n\tcnt = 0;\n\tfor (s = 0; s < S; s++) for (i = 0; i < hi2[s]; i++) deg[to2[s][i]]++;\n\tq[0] = start, top = 0, tail = 1;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tord[cnt++] = s;\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (--deg[e] == 0) q[tail++] = e;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint R, Q, u, v, _w, a, b, i, j, k, ii;\n\tint *memo;\n\t\n\tS = in(), R = in();\n\tmemo = malloc(R*3*sizeof(int));\n\tj = 0, i = R; while (i--) {\n\t\tmemo[j++] = u = in()-1, hi[u]++;\n\t\tmemo[j++] = v = in()-1, hi[v]++;\n\t\tmemo[j++] = in();\n\t}\n\tfor (i = 0; i < S; i++) if (hi[i]) {\n\t\tto [i] = malloc(hi[i] << 2), w[i] = malloc(hi[i] << 1);\n\t\tto2[i] = malloc(hi[i] << 2);\n\t}\n\t\n\tmemset(hi, 0, S << 2);\n\tj = 0; while (R--) {\n\t\tu = memo[j++], v = memo[j++], _w = memo[j++];\n\t\tk = hi[u]++, to[u][k] = v, w[u][k] = _w;\n\t\tk = hi[v]++, to[v][k] = u, w[v][k] = _w;\n\t}\n\tfree(memo);\n\t\n\ta = in()-1, b = in()-1, Q = in();\n\tfor (i = 0; i < Q; i++) c[i] = in()-1, d[i] = in()-1;\n\n\tdijkstra(a);\n\ttsort(a, b);\n\n\t\n    ii = (Q+63)>>6; for (i = 0; i < ii; i++) {\n        memset(dp, 0, sizeof(dp));\n\t\tfor (j = 0; j < 64; j++) if ((i<<6)+j < Q) dp[c[(i<<6)+j]] |= 1LL << j;\n\t\tfor (j = 0; j < cnt; j++) {\n\t\t\tu = ord[j];\n\t\t\tfor (k = 0; k < hi2[u]; k++) dp[to2[u][k]] |= dp[u];\n\t\t}\n        for (j = 0; j < 64; j++) if ((i<<6)+j < Q) {\n            puts(dp[d[(i<<6)+j]] & (1LL<<j)? \"Yes\": \"No\");\n\t\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 100003\n\nint S; \nint   hi[MAX], *to[MAX]; short *w[MAX];\nint dist[MAX];\nchar  mk[MAX];\nint  hi2[MAX], *to2[MAX];\n\nint   q[MAX], top, tail;\ntypedef struct { int s, e; } T;\nT ord[200002], _ord[200002]; int sz;\nint f[200002];\n\nint c[40002], d[40002];\nunsigned long long dp[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, e, d;\n\n\tmemset(dist, INF, S << 2);\n\tqsize = 0;\n\tenq(start, 0), dist[start] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n}\n\nvoid order(int goal)\n{\n    int i, k, s, e, max;\n\n\tq[0] = goal, top = 0, tail = 1;\n\tmk[goal] = 1;\n\tsz = 0, max = 0;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (!mk[e]) mk[e] = 1, q[tail++] = e;\n\n\t\t\t_ord[sz].s = e, _ord[sz++].e = s;\n\t\t\tk = dist[s];\n\t\t\tif (k > max) max = k;\n\t\t\tf[k]++;\n\t\t}\n\t}\n\n\tfor (i = 1; i <= max; i++) f[i] += f[i-1];\n\tfor (i = sz-1; i >= 0; i--) {\n\t\tk = dist[_ord[i].e], ord[--f[k]] = _ord[i];\n\t}\n}\n\nint main()\n{\n\tint R, Q, u, v, _w, a, b, i, j, k;\n\tint *memo;\n\tunsigned long long mask;\n\t\n\tS = in()+1, R = in();\n\tmemo = malloc(R*3*sizeof(int));\n\tj = 0, i = R; while (i--) {\n\t\tmemo[j++] = u = in(), hi[u]++;\n\t\tmemo[j++] = v = in(), hi[v]++;\n\t\tmemo[j++] = in();\n\t}\n\tfor (i = 0; i < S; i++) if (hi[i]) {\n\t\tto [i] = malloc(hi[i] << 2), w[i] = malloc(hi[i] << 1);\n\t\tto2[i] = malloc(hi[i] << 2);\n\t}\n\n\tmemset(hi, 0, S << 2);\n\tj = 0; while (R--) {\n\t\tu = memo[j++], v = memo[j++], _w = memo[j++];\n\t\tk = hi[u]++, to[u][k] = v, w[u][k] = _w;\n\t\tk = hi[v]++, to[v][k] = u, w[v][k] = _w;\n\t}\n\tfree(memo);\n\t\n\ta = in(), b = in();\n\tdijkstra(a);\n\torder(b);\n\n\tQ = in();\n\tfor (i = 0; i < Q; i++) c[i] = in(), d[i] = in();\n\tk = 1+((Q-1)>>6); for (i = 0; k--; i += 64) {\n        memset(dp, 0, sizeof(dp));\n\t\tfor (mask = 1, j = 0; j < 64; j++, mask <<= 1) dp[c[i+j]] |= mask;\n\t\tfor (j = 0; j < sz; j++) dp[ord[j].e] |= dp[ord[j].s];\n        for (mask = 1, j = 0; j < 64; j++, mask <<= 1) if (i+j < Q) {\n            puts(dp[d[i+j]] & mask? \"Yes\": \"No\");\n\t\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2017.11.18 bal4u@uu\n\n#include <stdio.h>\n//#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 205000\ntypedef struct { int t, node; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x55555555\n#define MAX 100000\ntypedef struct { int to[10], d[10]; } TBL;\nTBL tbl[MAX+1]; int size;\nint len[MAX+1];\nint c[40001], d[40001];\nint node[MAX+1];\nchar visited[MAX+1];\n\nvoid dijkstra(int start)\n{\n\tint i, s, d;\n\n\tqsize = 0;\n\tmemset(node, INF, sizeof(int)*size);\n//\tmemset(visited, 0, size);\n\tenq(start, 0);\n\twhile(qsize) {\n\t\ts = que[0].node, d = que[0].t, deq();\n\t\tif (visited[s]) continue;\n\t\tvisited[s] = 1;\n\t\tnode[s] = d;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\tif (visited[tbl[s].to[i]]) continue;\n\t\t\tenq(tbl[s].to[i], d+tbl[s].d[i]);\n\t\t}\n\t}\n}\n\nint tq[MAX+1], top, tail;\nTBL tbl2[MAX+1];\nint len2[MAX+1];\nunsigned long long dp[MAX+1];\n\nvoid topologicalSort(int goal)\n{\n    int s, e, i;\n\n\tmemset(visited, 0, size);\n\ttq[0] = goal, top = 0, tail = 1;\n\twhile (top < tail) {\n\t\ts = tq[top++];\n\t\tif (visited[s]) continue;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s].to[i];\n\t\t\tif (node[s] == node[e] + tbl[s].d[i]) {\n\t\t\t\ttq[tail++] = e;\n\t\t\t\ttbl2[e].to[len2[e]++] = s;\n\t\t\t}\n\t\t}\n\t\tvisited[s] = 1;\n\t}\n}\n\nchar buf[30], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\treturn n;\n}\n\nint main()\n{\n\tint r, q, u, v, w, a, b, i, j, ii, jj, k;\n\n\tfgets(p=buf, 30, stdin);\n\tsize = getint(), p++, r = getint();\n\tfor (i = 0; i < r; i++) {\n\t\tfgets(p=buf, 30, stdin);\n\t\tu = getint()-1, p++, v = getint()-1, p++, w = getint();\n\t\tk = len[u], tbl[u].to[k] = v, tbl[u].d[k] = w, len[u]++;\n\t\tk = len[v], tbl[v].to[k] = u, tbl[v].d[k] = w, len[v]++;\n\t}\n\tfgets(p=buf, 30, stdin);\n\ta = getint()-1, p++, b = getint()-1, p++, q = getint();\n\tfor (i = 0; i < q; i++) {\n\t\tfgets(p=buf, 30, stdin), c[i] = getint()-1, p++, d[i] = getint()-1;\n\t}\n\n\tdijkstra(a);\n\ttopologicalSort(b);\n\n    for (ii = (q+63)>>6, i = 0; i < ii; i++){\n        memset(dp, 0, sizeof(dp));\n\t\tjj = (i+1)<<6; if (q < jj) jj = q;\n        for (j = i << 6; j < jj; j++) dp[c[j]] |= (1LL << (j & 63));\n        for (j = 0; j < size; j++) {\n            for (k = 0; k < len2[j]; k++) {\n                dp[tbl2[j].to[k]] |= dp[j];\n            }\n        }\n        for (j = i << 6; j < jj; j++)\n            puts(((dp[d[j]] >> (j & 63)) & 1) ? \"Yes\" : \"No\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\nint S; \nint   hi[100002], *to[100002]; short *w[100002];\nint dist[100002];\nchar  mk[100002];\nint c[40002], d[40002];\n\nint   q[250002], top, tail;\nint hi2[100002], *to2[100002];\nint deg[100002];\nint ord[100002], cnt;\nunsigned long long dp[100002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, e, d;\n\n\tmemset(dist, INF, S << 2);\n\tqsize = 0;\n\tenq(start, 0), dist[start] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (dist[e] > d) dist[e] = d, enq(e, d);\n\t\t}\n\t}\n}\n\nvoid tsort(int start, int goal)\n{\n    int i, s, e;\n\n\tq[0] = goal, top = 0, tail = 1;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tif (mk[s]) continue;\n\t\tmk[s] = 1;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (dist[s] == dist[e] + w[s][i]) {\n\t\t\t\tq[tail++] = e;\n\t\t\t\tto2[e][hi2[e]++] = s;\n\t\t\t}\n\t\t}\n\t}\n\tcnt = 0;\n\tfor (s = 0; s < S; s++) for (i = 0; i < hi2[s]; i++) deg[to2[s][i]]++;\n\tq[0] = start, top = 0, tail = 1;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tord[cnt++] = s;\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (--deg[e] == 0) q[tail++] = e;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint R, Q, u, v, _w, a, b, i, j, k, ii;\n\tint *memo;\n\t\n\tS = in(), R = in();\n\tmemo = malloc(R*3*sizeof(int));\n\tj = 0, i = R; while (i--) {\n\t\tmemo[j++] = u = in()-1, hi[u]++;\n\t\tmemo[j++] = v = in()-1, hi[v]++;\n\t\tmemo[j++] = in();\n\t}\n\tfor (i = 0; i < S; i++) if (hi[i]) {\n\t\tto [i] = malloc(hi[i] << 2), w[i] = malloc(hi[i] << 1);\n\t\tto2[i] = malloc(hi[i] << 2);\n\t}\n\n\tmemset(hi, 0, S << 2);\n\tj = 0; while (R--) {\n\t\tu = memo[j++], v = memo[j++], _w = memo[j++];\n\t\tk = hi[u]++, to[u][k] = v, w[u][k] = _w;\n\t\tk = hi[v]++, to[v][k] = u, w[v][k] = _w;\n\t}\n\tfree(memo);\n\t\n\ta = in()-1, b = in()-1, Q = in();\n\tfor (i = 0; i < Q; i++) c[i] = in()-1, d[i] = in()-1;\n\n\tdijkstra(a);\n\ttsort(a, b);\n\n    ii = (Q+63)>>6; for (i = 0; i < ii; i++) {\n        memset(dp, 0, sizeof(dp));\n\t\tfor (j = 0; j < 64; j++) if ((i<<6)+j < Q) dp[c[(i<<6)+j]] |= 1LL << j;\n\t\tfor (j = 0; j < cnt; j++) {\n\t\t\tu = ord[j];\n\t\t\tfor (k = 0; k < hi2[u]; k++) dp[to2[u][k]] |= dp[u];\n\t\t}\n        for (j = 0; j < 64; j++) if ((i<<6)+j < Q) {\n            puts(dp[d[(i<<6)+j]] & (1LL<<j)? \"Yes\": \"No\");\n\t\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 100003\n\nint S; \nint   hi[MAX], *to[MAX]; short *w[MAX];\nint dist[MAX];\nchar  mk[MAX];\nint hi2[MAX], *to2[MAX];\n\nint   q[MAX], top, tail;\ntypedef struct { int s, e, d; } T;\nT ord[3*MAX]; int sz;\n\nint c[40002], d[40002];\nunsigned long long dp[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, e, d;\n\n\tmemset(dist, INF, S << 2);\n\tqsize = 0;\n\tenq(start, 0), dist[start] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (dist[e] > d) hi2[e] = 0, enq(e, d);\n\t\t\tif (dist[e] >= d) dist[e] = d, to2[e][hi2[e]++] = s;\n\t\t}\n\t}\n}\n\nint cmp(T *a, T *b) { return a->d - b->d; }\n\nvoid order(int goal)\n{\n    int i, s, e;\n\n\tmemset(hi, 0, S << 2);\n\tq[0] = goal, top = 0, tail = 1;\n\tmk[goal] = 1;\n\tsz = 0;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tord[sz].s = e, ord[sz].e = s, ord[sz++].d = dist[s];\n\t\t\tif (!mk[e]) mk[e] = 1, q[tail++] = e;\n\t\t}\n\t}\n\tqsort(ord, sz, sizeof(T), cmp);\n}\n\nint main()\n{\n\tint R, Q, u, v, _w, a, b, i, j, k, ii;\n\tint *memo;\n\t\n\tS = in()+1, R = in();\n\tmemo = malloc(R*3*sizeof(int));\n\tj = 0, i = R; while (i--) {\n\t\tmemo[j++] = u = in(), hi[u]++;\n\t\tmemo[j++] = v = in(), hi[v]++;\n\t\tmemo[j++] = in();\n\t}\n\tfor (i = 0; i < S; i++) if (hi[i]) {\n\t\tto [i] = malloc(hi[i] << 2), w[i] = malloc(hi[i] << 1);\n\t\tto2[i] = malloc(hi[i] << 2);\n\t}\n\n\tmemset(hi, 0, S << 2);\n\tj = 0; while (R--) {\n\t\tu = memo[j++], v = memo[j++], _w = memo[j++];\n\t\tk = hi[u]++, to[u][k] = v, w[u][k] = _w;\n\t\tk = hi[v]++, to[v][k] = u, w[v][k] = _w;\n\t}\n\tfree(memo);\n\t\n\ta = in(), b = in();\n\tdijkstra(a);\n\torder(b);\n\n\tQ = in();\n\tfor (i = 0; i < Q; i++) c[i] = in(), d[i] = in();\n\tii = (Q+63)>>6; for (i = 0; i < ii; i++) {\n        memset(dp, 0, sizeof(dp));\n\t\tfor (j = 0; j < 64; j++) if ((i<<6)+j < Q) dp[c[(i<<6)+j]] |= 1LL << j;\n\t\tfor (j = 0; j < sz; j++) dp[ord[j].e] |= dp[ord[j].s];\n        for (j = 0; j < 64; j++) if ((i<<6)+j < Q) {\n            puts(dp[d[(i<<6)+j]] & (1LL<<j)? \"Yes\": \"No\");\n\t\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 100003\n\nint S; \nint   hi[MAX], *to[MAX]; short *w[MAX];\nint dist[MAX];\nchar  mk[MAX];\nint hi2[MAX], *to2[MAX];\n\nint   q[MAX], top, tail;\ntypedef struct { int s, e; } T;\nT ord[200002], _ord[200002]; int sz;\nint f[200002];\n\nint c[40002], d[40002];\nunsigned long long dp[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, e, d;\n\n\tmemset(dist, INF, S << 2);\n\tqsize = 0;\n\tenq(start, 0), dist[start] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (dist[e] > d) hi2[e] = 0, enq(e, d);\n\t\t\tif (dist[e] >= d) dist[e] = d, to2[e][hi2[e]++] = s;\n\t\t}\n\t}\n}\n\nvoid order(int goal)\n{\n    int i, k, s, e, max;\n\n\tmax = 0;\n\tq[0] = goal, top = 0, tail = 1;\n\tmk[goal] = 1;\n\tsz = 0;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (!mk[e]) mk[e] = 1, q[tail++] = e;\n\n\t\t\t_ord[sz].s = e, _ord[sz++].e = s;\n\t\t\tk = dist[s];\n\t\t\tif (k > max) max = k;\n\t\t\tf[k]++;\n\t\t}\n\t}\n\n\tfor (i = 1; i <= max; i++) f[i] += f[i-1];\n\tfor (i = sz-1; i >= 0; i--) {\n\t\tk = dist[_ord[i].e], ord[--f[k]] = _ord[i];\n\t}\n}\n\nint main()\n{\n\tint R, Q, u, v, _w, a, b, i, j, k;\n\tint *memo;\n\t\n\tS = in()+1, R = in();\n\tmemo = malloc(R*3*sizeof(int));\n\tj = 0, i = R; while (i--) {\n\t\tmemo[j++] = u = in(), hi[u]++;\n\t\tmemo[j++] = v = in(), hi[v]++;\n\t\tmemo[j++] = in();\n\t}\n\tfor (i = 0; i < S; i++) if (hi[i]) {\n\t\tto [i] = malloc(hi[i] << 2), w[i] = malloc(hi[i] << 1);\n\t\tto2[i] = malloc(hi[i] << 2);\n\t}\n\n\tmemset(hi, 0, S << 2);\n\tj = 0; while (R--) {\n\t\tu = memo[j++], v = memo[j++], _w = memo[j++];\n\t\tk = hi[u]++, to[u][k] = v, w[u][k] = _w;\n\t\tk = hi[v]++, to[v][k] = u, w[v][k] = _w;\n\t}\n\tfree(memo);\n\t\n\ta = in(), b = in();\n\tdijkstra(a);\n\torder(b);\n\n\tQ = in();\n\tfor (i = 0; i < Q; i++) c[i] = in(), d[i] = in();\n\tk = (Q+63)>>6; for (i = 0; i < k; i++) {\n        memset(dp, 0, sizeof(dp));\n\t\tfor (j = 0; j < 64; j++) if ((i<<6)+j < Q) dp[c[(i<<6)+j]] |= 1LL<<j;\n\t\tfor (j = 0; j < sz; j++) dp[ord[j].e] |= dp[ord[j].s];\n        for (j = 0; j < 64; j++) if ((i<<6)+j < Q) {\n            puts(dp[d[(i<<6)+j]] & (1LL<<j)? \"Yes\": \"No\");\n\t\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0275 Railroad\n// 2018.2.21 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX+2]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 100003\n\nint S;\nint   memo[600002];\nint   hi[MAX], *to[MAX]; short *w[MAX];\nint dist[MAX];\nchar  mk[MAX];\nint  hi2[MAX], *to2[MAX];\n\nint   q[MAX], top, tail;\ntypedef struct { int s, e; } T;\nT ord[200002], _ord[200002]; int sz;\nint f[200002];\n\nint c[40002], d[40002];\nunsigned long long dp[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int start)\n{\n\tint i, s, e, d;\n\n\tmemset(dist, INF, S << 2);\n\tqsize = 0;\n\tenq(start, 0), dist[start] = 0;\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) hi2[e] = 0, dist[e] = d, enq(e, d);\n\t\t\tto2[e][hi2[e]++] = s;\n\t\t}\n\t}\n}\n\nvoid order(int goal)\n{\n    int i, k, s, e, max;\n\n\tq[0] = goal, top = 0, tail = 1;\n\tmk[goal] = 1;\n\tsz = 0, max = 0;\n\twhile (top < tail) {\n\t\ts = q[top++];\n\t\tfor (i = 0; i < hi2[s]; i++) {\n\t\t\te = to2[s][i];\n\t\t\tif (!mk[e]) mk[e] = 1, q[tail++] = e;\n\n\t\t\t_ord[sz].s = e, _ord[sz++].e = s;\n\t\t\tk = dist[s];\n\t\t\tif (k > max) max = k;\n\t\t\tf[k]++;\n\t\t}\n\t}\n\n\tfor (i = 1; i <= max; i++) f[i] += f[i-1];\n\tfor (i = sz-1; i >= 0; i--) {\n\t\tk = dist[_ord[i].e], ord[--f[k]] = _ord[i];\n\t}\n}\n\nint main()\n{\n\tint R, Q, u, v, _w, a, b, i, j, k;\n\tunsigned long long mask;\n\t\n\tS = in()+1, R = in();\n\tj = 0, i = R; while (i--) {\n\t\tmemo[j++] = u = in(), hi[u]++;\n\t\tmemo[j++] = v = in(), hi[v]++;\n\t\tmemo[j++] = in();\n\t}\n\tfor (i = 0; i < S; i++) if (hi[i]) {\n\t\tto [i] = malloc(hi[i] << 2), w[i] = malloc(hi[i] << 1);\n\t\tto2[i] = malloc(hi[i] << 2);\n\t}\n\n\tmemset(hi, 0, S << 2);\n\tj = 0; while (R--) {\n\t\tu = memo[j++], v = memo[j++], _w = memo[j++];\n\t\tk = hi[u]++, to[u][k] = v, w[u][k] = _w;\n\t\tk = hi[v]++, to[v][k] = u, w[v][k] = _w;\n\t}\n\t\n\ta = in(), b = in();\n\tdijkstra(a);\n\torder(b);\n\n\tQ = in();\n\tfor (i = 0; i < Q; i++) c[i] = in(), d[i] = in();\n\tk = 1+((Q-1)>>6); for (i = 0; k--; i += 64) {\n        memset(dp, 0, sizeof(dp));\n\t\tmask = 1; for (j = 0; j < 64; j++) dp[c[i+j]] |= mask, mask <<= 1;\n\t\tfor (j = 0; j < sz; j++) dp[ord[j].e] |= dp[ord[j].s];\n        mask = 1; for (j = 0; j < 64; j++) {\n\t\t\tif (i+j >= Q) return 0;\n            puts(dp[d[i+j]] & mask? \"Yes\": \"No\");\n\t\t\tmask <<= 1;\n\t\t}\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tint n;\n\tList<Integer>[] e;\n\tTreeMap<Pair, Integer> map;\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tPair(int f, int s) {\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.f != o.f) {\n\t\t\t\treturn this.f - o.f;\n\t\t\t}\n\t\t\treturn this.s - o.s;\n\t\t}\n\t}\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint min;\n\n\t\tD(int pos, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\treturn this.pos - o.pos;\n\t\t}\n\t}\n\n\tint dijkstra(int start, int goal) {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tqueue.add(new D(start, 0));\n\t\tboolean[] vis = new boolean[n];\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint min = d.min;\n\n\t\t\tif (vis[pos]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos] = true;\n\t\t\tif (pos == goal) {\n\t\t\t\treturn min;\n\t\t\t}\n\n\t\t\tfor (Integer to : e[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nmin = min + map.get(new Pair(pos, to));\n\t\t\t\tif (vis[to]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tqueue.add(new D(npos, nmin));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\tn = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\te = new LinkedList[n];\n\t\tmap = new TreeMap<Pair, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = new LinkedList<Integer>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint w = sc.nextInt();\n\t\t\te[u].add(v);\n\t\t\tmap.put(new Pair(u, v), w);\n\t\t}\n\t\tint a = sc.nextInt() - 1;\n\t\tint b = sc.nextInt() - 1;\n\t\tint opt = dijkstra(a, b);\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint c = sc.nextInt() - 1;\n\t\t\tint d = sc.nextInt() - 1;\n\t\t\tint s = dijkstra(a, c);\n\t\t\tint t = dijkstra(c, d);\n\t\t\tint u = dijkstra(d, b);\n\t\t\tif (s + t + u == opt) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final long MAX_INT = 1L << 62;\n\n  // inner classes\n\n  static class Edge {\n    int node, weight;\n\n    Edge(int node, int weight) {\n      this.node = node;\n      this.weight = weight;\n    }\n  }\n\n  // main\n\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    int sn = sc.nextInt();\n    int rn = sc.nextInt();\n\n    ArrayList<ArrayList<Edge>> nbrs = new ArrayList<ArrayList<Edge>>();\n    for (int i = 0; i < sn; i++)\n      nbrs.add(new ArrayList<Edge>());\n\n    for (int i = 0; i < rn; i++) {\n      int u = sc.nextInt() - 1;\n      int v = sc.nextInt() - 1;\n      int w = sc.nextInt();\n\n      nbrs.get(u).add(new Edge(v, w));\n      nbrs.get(v).add(new Edge(u, w));\n    }\n\n    int ta = sc.nextInt() - 1;\n    int tb = sc.nextInt() - 1;\n    int qn = sc.nextInt();\n\n    long[] dists = new long[sn];\n    for (int i = 0; i < sn; i++)\n      dists[i] = MAX_INT;\n    dists[ta] = 0;\n\n    ArrayList<ArrayList<Integer>> prevs = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> q = new ArrayList<Integer>();\n    for (int i = 0; i < sn; i++) {\n      prevs.add(new ArrayList<Integer>());\n      q.add(i);\n    }\n\n    while (! q.isEmpty()) {\n      Integer ui = q.get(0);\n      for (int i = 1; i < q.size(); i++) {\n        Integer ui0 = q.get(i);\n        if (dists[ui.intValue()] > dists[ui0.intValue()])\n          ui = ui0;\n      }\n\n      q.remove(ui);\n      int u = ui.intValue();\n\n      if (u == tb) continue;\n\n      for (Edge edge: nbrs.get(u)) {\n        int v = edge.node;\n\n        long dist0 = dists[u] + edge.weight;\n        ArrayList<Integer> pv = prevs.get(v);\n        if (dists[v] > dist0) {\n          dists[v] = dist0;\n          pv.clear();\n          pv.add(u);\n        }\n        else if (dists[v] == dist0)\n          pv.add(u);\n      }\n    }\n\n    /*\n    for (int i = 0; i < sn; i++)\n      System.out.print(\" \" + dists[i]);\n    System.out.println();\n    */\n\n    boolean[] onroutes = new boolean[sn];\n    Arrays.fill(onroutes, false);\n    onroutes[tb] = true;\n\n    q.clear();\n    q.add(tb);\n\n    while (! q.isEmpty()) {\n      int u = q.remove(0);\n      if (u == ta) continue;\n\n      for (int v: prevs.get(u)) {\n        if (! onroutes[v]) {\n          onroutes[v] = true;\n          q.add(v);\n        }\n      }\n    }\n\n    for (int i = 0; i < qn; i++) {\n      int c = sc.nextInt() - 1;\n      int d = sc.nextInt() - 1;\n\n      if (onroutes[c] && onroutes[d] && dists[c] < dists[d])\n        System.out.println(\"Yes\");\n      else\n        System.out.println(\"No\");\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tint n;\n\tList<Integer>[] e;\n\tTreeMap<Pair, Integer> map;\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tPair(int f, int s) {\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.f != o.f) {\n\t\t\t\treturn this.f - o.f;\n\t\t\t}\n\t\t\treturn this.s - o.s;\n\t\t}\n\t}\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint min;\n\n\t\tD(int pos, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\treturn this.pos - o.pos;\n\t\t}\n\t}\n\n\tint dijkstra(int start, int goal) {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tqueue.add(new D(start, 0));\n\t\tboolean[] vis = new boolean[n];\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint min = d.min;\n\n\t\t\tif (vis[pos]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos] = true;\n\t\t\tif (pos == goal) {\n\t\t\t\treturn min;\n\t\t\t}\n\n\t\t\tfor (Integer to : e[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nmin = min + map.get(new Pair(pos, to));\n\t\t\t\tif (vis[to]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tqueue.add(new D(npos, nmin));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\tn = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\te = new LinkedList[n];\n\t\tmap = new TreeMap<Pair, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = new LinkedList<Integer>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint w = sc.nextInt();\n\t\t\te[u].add(v);\n\t\t\tmap.put(new Pair(u, v), w);\n\t\t}\n\t\tint a = sc.nextInt() - 1;\n\t\tint b = sc.nextInt() - 1;\n\t\tint opt = dijkstra(a, b);\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint c = sc.nextInt() - 1;\n\t\t\tint d = sc.nextInt() - 1;\n\t\t\tint s = dijkstra(a, c);\n\t\t\tint t = dijkstra(c, d);\n\t\t\tint u = dijkstra(d, b);\n\t\t\tif (s + t + u == opt) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.TreeMap;\n\npublic class Main {\n\tint n;\n\tList<Integer>[] e;\n\tTreeMap<Pair, Integer> map;\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tPair(int f, int s) {\n\t\t\tif (f < s) {\n\t\t\t\tthis.f = f;\n\t\t\t\tthis.s = s;\n\t\t\t} else {\n\t\t\t\tthis.f = s;\n\t\t\t\tthis.s = f;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (this.f != o.f) {\n\t\t\t\treturn this.f - o.f;\n\t\t\t}\n\t\t\treturn this.s - o.s;\n\t\t}\n\t}\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint min;\n\n\t\tD(int pos, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\treturn this.pos - o.pos;\n\t\t}\n\t}\n\n\tint dijkstra(int start, int goal) {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tqueue.add(new D(start, 0));\n\t\tboolean[] vis = new boolean[n];\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint min = d.min;\n\n\t\t\tif (vis[pos]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos] = true;\n\t\t\tif (pos == goal) {\n\t\t\t\treturn min;\n\t\t\t}\n\n\t\t\tfor (Integer to : e[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nmin = min + map.get(new Pair(pos, to));\n\t\t\t\tif (vis[to]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tqueue.add(new D(npos, nmin));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\tn = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\te = new LinkedList[n];\n\t\tmap = new TreeMap<Pair, Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te[i] = new LinkedList<Integer>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tint w = sc.nextInt();\n\t\t\te[u].add(v);\n\t\t\te[v].add(u);\n\t\t\tmap.put(new Pair(u, v), w);\n\t\t}\n\t\tint a = sc.nextInt() - 1;\n\t\tint b = sc.nextInt() - 1;\n\t\tint opt = dijkstra(a, b);\n\t\tint q = sc.nextInt();\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint c = sc.nextInt() - 1;\n\t\t\tint d = sc.nextInt() - 1;\n\t\t\tint s = dijkstra(a, c);\n\t\t\tint t = dijkstra(c, d);\n\t\t\tint u = dijkstra(d, b);\n\t\t\tif (s + t + u == opt) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final long MAX_INT = 1L << 62;\n\n  // inner classes\n\n  static class Edge {\n    int node, weight;\n\n    Edge(int node, int weight) {\n      this.node = node;\n      this.weight = weight;\n    }\n  }\n\n  // main\n\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    int sn = sc.nextInt();\n    int rn = sc.nextInt();\n\n    ArrayList<ArrayList<Edge>> nbrs = new ArrayList<ArrayList<Edge>>();\n    for (int i = 0; i < sn; i++)\n      nbrs.add(new ArrayList<Edge>());\n\n    for (int i = 0; i < rn; i++) {\n      int u = sc.nextInt() - 1;\n      int v = sc.nextInt() - 1;\n      int w = sc.nextInt();\n\n      nbrs.get(u).add(new Edge(v, w));\n      nbrs.get(v).add(new Edge(u, w));\n    }\n\n    int ta = sc.nextInt() - 1;\n    int tb = sc.nextInt() - 1;\n    int qn = sc.nextInt();\n\n    long[] dists = new long[sn];\n    for (int i = 0; i < sn; i++)\n      dists[i] = MAX_INT;\n    dists[ta] = 0;\n\n    ArrayList<ArrayList<Integer>> prevs = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> q = new ArrayList<Integer>();\n    for (int i = 0; i < sn; i++) {\n      prevs.add(new ArrayList<Integer>());\n      q.add(i);\n    }\n\n    while (! q.isEmpty()) {\n      Integer ui = q.get(0);\n      for (int i = 1; i < q.size(); i++) {\n        Integer ui0 = q.get(i);\n        if (dists[ui.intValue()] > dists[ui0.intValue()])\n          ui = ui0;\n      }\n\n      q.remove(ui);\n      int u = ui.intValue();\n\n      if (u == tb) continue;\n\n      for (Edge edge: nbrs.get(u)) {\n        int v = edge.node;\n\n        long dist0 = dists[u] + edge.weight;\n        ArrayList<Integer> pv = prevs.get(v);\n        if (dists[v] > dist0) {\n          dists[v] = dist0;\n          pv.clear();\n          pv.add(u);\n        }\n        else if (dists[v] == dist0)\n          pv.add(u);\n      }\n    }\n\n    /*\n    for (int i = 0; i < sn; i++)\n      System.out.print(\" \" + dists[i]);\n    System.out.println();\n    */\n\n    boolean[] onroutes = new boolean[sn];\n    Arrays.fill(onroutes, false);\n    onroutes[tb] = true;\n\n    q.clear();\n    q.add(tb);\n\n    while (! q.isEmpty()) {\n      int u = q.remove(0);\n      if (u == ta) continue;\n\n      for (int v: prevs.get(u)) {\n        if (! onroutes[v]) {\n          onroutes[v] = true;\n          q.add(v);\n        }\n      }\n    }\n\n    for (int i = 0; i < qn; i++) {\n      int c = sc.nextInt() - 1;\n      int d = sc.nextInt() - 1;\n\n      if (onroutes[c] && onroutes[d] && dists[c] < dists[d])\n        System.out.println(\"Yes\");\n      else\n        System.out.println(\"No\");\n    }\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\n\n### main\n\nsn, rn = gets.strip.split(' ').map{|s| s.to_i}\n\nnbrs = sn.times.map{[]}\n\nrn.times do\n  u, v, w = gets.strip.split(' ').map{|s| s.to_i}\n  u -= 1\n  v -= 1\n\n  nbrs[u] << [v, w]\n  nbrs[v] << [u, w]\nend\n#p nbrs\n\nta, tb, qn = gets.strip.split(' ').map{|s| s.to_i}\nta -= 1\ntb -= 1\n\ndists = sn.times.map{MAX_INT}\ndists[ta] = 0\n\nprevs = []\nq = (0...sn).to_a\n\nwhile ! q.empty?\n  u = q.min{|a, b| dists[a] <=> dists[b]}\n  q.delete(u)\n\n  next if u == tb\n\n  for edge in nbrs[u]\n    v, w = edge\n    dist0 = dists[u] + w\n    if dists[v] > dist0\n      dists[v] = dist0\n      prevs[v] = [u]\n    elsif dists[v] == dist0\n      prevs[v] << u\n    end\n  end\nend\n#p dists\n#p prevs\n\nonroutes = sn.times.map{false}\nonroutes[tb] = true\nq = [tb]\n\nwhile ! q.empty?\n  u = q.shift\n  next if u == ta\n\n  for v in prevs[u]\n    if ! onroutes[v]\n      onroutes[v] = true\n      q << v\n    end\n  end\nend\n#p routes\n\nqn.times do\n  c, d = gets.strip.split(' ').map{|s| s.to_i}\n  c -= 1\n  d -= 1\n\n  if onroutes[c] && onroutes[d] && dists[c] < dists[d]\n    puts 'Yes'\n  else\n    puts 'No'\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\n\n### subroutines\n\ndef get_routes(st, prevs)\n  if prevs[st].nil?\n    return [[st]]\n  end\n\n  routes = []\n\n  for st0 in prevs[st]\n    routes += get_routes(st0, prevs).map{|rt| rt << st}\n  end\n\n  routes\nend\n\n### main\n\nsn, rn = gets.strip.split(' ').map{|s| s.to_i}\n\nedges = sn.times.map{{}}\nnbrs = sn.times.map{[]}\n\nrn.times do\n  u, v, w = gets.strip.split(' ').map{|s| s.to_i}\n  u -= 1\n  v -= 1\n\n  edges[u][v] = edges[v][u] = w\n  nbrs[u] << v\n  nbrs[v] << u\nend\n#p edges\n#p nbrs\n\nta, tb, qn = gets.strip.split(' ').map{|s| s.to_i}\nta -= 1\ntb -= 1\n\ndists = sn.times.map{MAX_INT}\ndists[ta] = 0\n\nprevs = []\nq = (0...sn).to_a\n\nwhile ! q.empty?\n  u = q.min{|a, b| dists[a] <=> dists[b]}\n  q.delete(u)\n\n  next if u == tb\n\n  for v in nbrs[u]\n    dist0 = dists[u] + edges[u][v]\n    if dists[v] > dist0\n      dists[v] = dist0\n      prevs[v] = [u]\n    elsif dists[v] == dist0\n      prevs[v] << u\n    end\n  end\nend\n#p dists\n#p prevs\n\nroutes = get_routes(tb, prevs)\n#p routes\n\nqn.times do\n  c, d = gets.strip.split(' ').map{|s| s.to_i}\n  c -= 1\n  d -= 1\n\n  ok = false\n  for rt in routes\n    ci = rt.index(c)\n    di = rt.index(d)\n    if ! ci.nil? && ! di.nil? && ci < di\n      ok = true\n      break\n    end\n  end\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\n\n### subroutines\n\ndef get_routes(st, prevs)\n  if prevs[st].nil?\n    return [[st]]\n  end\n\n  routes = []\n\n  for st0 in prevs[st]\n    routes += get_routes(st0, prevs).map{|rt| rt << st}\n  end\n\n  routes\nend\n\n### main\n\nsn, rn = gets.strip.split(' ').map{|s| s.to_i}\n\nedges = sn.times.map{[]}\nnbrs = sn.times.map{[]}\n\nrn.times do\n  u, v, w = gets.strip.split(' ').map{|s| s.to_i}\n  u -= 1\n  v -= 1\n\n  edges[u][v] = edges[v][u] = w\n  nbrs[u] << v\n  nbrs[v] << u\nend\n#p edges\n#p nbrs\n\nta, tb, qn = gets.strip.split(' ').map{|s| s.to_i}\nta -= 1\ntb -= 1\n\ndists = sn.times.map{MAX_INT}\ndists[ta] = 0\n\nprevs = []\nq = (0...sn).to_a\n\nwhile ! q.empty?\n  u = q.min{|a, b| dists[a] <=> dists[b]}\n  q.delete(u)\n\n  next if u == tb\n\n  for v in nbrs[u]\n    dist0 = dists[u] + edges[u][v]\n    if dists[v] > dist0\n      dists[v] = dist0\n      prevs[v] = [u]\n    elsif dists[v] == dist0\n      prevs[v] << u\n    end\n  end\nend\n#p dists\n#p prevs\n\nroutes = get_routes(tb, prevs)\n#p routes\n\nqn.times do\n  c, d = gets.strip.split(' ').map{|s| s.to_i}\n  c -= 1\n  d -= 1\n\n  ok = false\n  for rt in routes\n    ci = rt.index(c)\n    di = rt.index(d)\n    if ! ci.nil? && ! di.nil? && ci < di\n      ok = true\n      break\n    end\n  end\n\n  puts (ok ? 'Yes' : 'No')\nend"
  },
  {
    "language": "Ruby",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final long MAX_INT = 1L << 62;\n\n  // inner classes\n\n  static class Edge {\n    int node, weight;\n\n    Edge(int node, int weight) {\n      this.node = node;\n      this.weight = weight;\n    }\n  }\n\n  // main\n\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    int sn = sc.nextInt();\n    int rn = sc.nextInt();\n\n    ArrayList<ArrayList<Edge>> nbrs = new ArrayList<ArrayList<Edge>>();\n    for (int i = 0; i < sn; i++)\n      nbrs.add(new ArrayList<Edge>());\n\n    for (int i = 0; i < rn; i++) {\n      int u = sc.nextInt() - 1;\n      int v = sc.nextInt() - 1;\n      int w = sc.nextInt();\n\n      nbrs.get(u).add(new Edge(v, w));\n      nbrs.get(v).add(new Edge(u, w));\n    }\n\n    int ta = sc.nextInt() - 1;\n    int tb = sc.nextInt() - 1;\n    int qn = sc.nextInt();\n\n    long[] dists = new long[sn];\n    for (int i = 0; i < sn; i++)\n      dists[i] = MAX_INT;\n    dists[ta] = 0;\n\n    ArrayList<ArrayList<Integer>> prevs = new ArrayList<ArrayList<Integer>>();\n    ArrayList<Integer> q = new ArrayList<Integer>();\n    for (int i = 0; i < sn; i++) {\n      prevs.add(new ArrayList<Integer>());\n      q.add(i);\n    }\n\n    while (! q.isEmpty()) {\n      Integer ui = q.get(0);\n      for (int i = 1; i < q.size(); i++) {\n        Integer ui0 = q.get(i);\n        if (dists[ui.intValue()] > dists[ui0.intValue()])\n          ui = ui0;\n      }\n\n      q.remove(ui);\n      int u = ui.intValue();\n\n      if (u == tb) continue;\n\n      for (Edge edge: nbrs.get(u)) {\n        int v = edge.node;\n\n        long dist0 = dists[u] + edge.weight;\n        ArrayList<Integer> pv = prevs.get(v);\n        if (dists[v] > dist0) {\n          dists[v] = dist0;\n          pv.clear();\n          pv.add(u);\n        }\n        else if (dists[v] == dist0)\n          pv.add(u);\n      }\n    }\n\n    /*\n    for (int i = 0; i < sn; i++)\n      System.out.print(\" \" + dists[i]);\n    System.out.println();\n    */\n\n    boolean[] onroutes = new boolean[sn];\n    Arrays.fill(onroutes, false);\n    onroutes[tb] = true;\n\n    q.clear();\n    q.add(tb);\n\n    while (! q.isEmpty()) {\n      int u = q.remove(0);\n      if (u == ta) continue;\n\n      for (int v: prevs.get(u)) {\n        if (! onroutes[v]) {\n          onroutes[v] = true;\n          q.add(v);\n        }\n      }\n    }\n\n    for (int i = 0; i < qn; i++) {\n      int c = sc.nextInt() - 1;\n      int d = sc.nextInt() - 1;\n\n      if (onroutes[c] && onroutes[d] && dists[c] < dists[d])\n        System.out.println(\"Yes\");\n      else\n        System.out.println(\"No\");\n    }\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = (1 << 30)\n\n### main\n\nsn, rn = gets.strip.split(' ').map{|s| s.to_i}\n\nedges = sn.times.map{{}}\nnbrs = sn.times.map{[]}\n\nrn.times do\n  u, v, w = gets.strip.split(' ').map{|s| s.to_i}\n  u -= 1\n  v -= 1\n\n  edges[u][v] = edges[v][u] = w\n  nbrs[u] << v\n  nbrs[v] << u\nend\n#p edges\n#p nbrs\n\nta, tb, qn = gets.strip.split(' ').map{|s| s.to_i}\nta -= 1\ntb -= 1\n\ndists = sn.times.map{MAX_INT}\ndists[ta] = 0\n\nprevs = []\nq = (0...sn).to_a\n\nwhile ! q.empty?\n  u = q.min{|a, b| dists[a] <=> dists[b]}\n  q.delete(u)\n\n  next if u == tb\n\n  for v in nbrs[u]\n    dist0 = dists[u] + edges[u][v]\n    if dists[v] > dist0\n      dists[v] = dist0\n      prevs[v] = [u]\n    elsif dists[v] == dist0\n      prevs[v] << u\n    end\n  end\nend\n#p dists\n#p prevs\n\nonroutes = sn.times.map{false}\nonroutes[tb] = true\nq = [tb]\n\nwhile ! q.empty?\n  u = q.shift\n  next if u == ta\n\n  for v in prevs[u]\n    if ! onroutes[v]\n      onroutes[v] = true\n      q << v\n    end\n  end\nend\n#p routes\n\nqn.times do\n  c, d = gets.strip.split(' ').map{|s| s.to_i}\n  c -= 1\n  d -= 1\n\n  if onroutes[c] && onroutes[d] && dists[c] < dists[d]\n    puts 'Yes'\n  else\n    puts 'No'\n  end\nend"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ns, r = map(int, input().split())\nedges = [[] for _ in range(s)]\nfor _ in range(r):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges[u].append((v, w))\n    edges[v].append((u, w))\n\na, b, q = map(int, input().split())\na -= 1\nb -= 1\n\n\ndef dijkstra(start):\n    INF = 10 ** 20\n    dist = [INF] * s\n    dist[start] = 0\n    parents = [[] for _ in range(s)]\n    que = []\n    heappush(que, (0, start))\n    while que:\n        score, node = heappop(que)\n        for to, w in edges[node]:\n            if dist[to] > score + w:\n                dist[to] = score + w\n                parents[to] = {node}\n                heappush(que, (score + w, to))\n            elif dist[to] == score + w:\n                parents[to].add(node)\n    return dist, parents\n\n\ndef on_shortest_path(c, d, mem):\n    if c == d:return True\n    if d in mem:return False\n    mem.add(d)\n    if dist_from_a[c] >= dist_from_a[d]:return False\n    for parent in parents[d]:\n        if on_shortest_path(c, parent, mem):return True\n    return False\n\n\ndist_from_a, parents = dijkstra(a)\ndist_from_b, _ = dijkstra(b)\nshortest = dist_from_a[b]\nfor _ in range(q):\n    c, d = map(int, input().split())\n    c -= 1\n    d -= 1\n    if dist_from_a[c] + dist_from_b[c] == shortest and \\\n       dist_from_a[d] + dist_from_b[d] == shortest and \\\n       on_shortest_path(c, d, set()):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  INF = 10 ** 20\n  s, r = map(int, input().split())\n  \n  edges = [[] for _ in range(s)]\n  for _ in range(r):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges[u].append((v, w))\n    edges[v].append((u, w))\n  \n  a, b, q = map(int, input().split())\n  a -= 1\n  b -= 1\n  costs = [(INF, [])] * s\n  costs[a] = (0, [[a]])\n  que = []\n  heappush(que, (0, a))\n  while que:\n    dist, node = heappop(que)\n    total, paths = costs[node]\n    for to, weight in edges[node]:\n      to_total, to_paths = costs[to]\n      if to_total > total + weight:\n        costs[to] = (total + weight, [lst + [to] for lst in paths])\n        heappush(que, (total + weight, to))\n      elif to_total == total + weight:\n        costs[to] = (to_total, to_paths + [lst + [to] for lst in paths])\n  \n  \n  _, atob = costs[b]\n  from_to = [set() for _ in range(s)]\n  for path in atob:\n    for i, p in enumerate(path):\n      from_to[p] = from_to[p] | set(path[i + 1:])\n  \n  for _ in range(q):\n    start, goal = map(int, input().split())\n    start -= 1\n    goal -= 1\n    if goal in from_to[start]:\n      print(\"Yes\")\n    else:\n      print(\"No\")\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  INF = 10 ** 20\n  s, r = map(int, input().split())\n  \n  edges = [[] for _ in range(s)]\n  for _ in range(r):\n    u, v, w = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges[u].append((v, w))\n    edges[v].append((u, w))\n  \n  a, b, q = map(int, input().split())\n  a -= 1\n  b -= 1\n  costs = [(INF, [])] * s\n  costs[a] = (0, [[a]])\n  que = []\n  heappush(que, a)\n  while que:\n    node = heappop(que)\n    total, paths = costs[node]\n    for to, weight in edges[node]:\n      to_total, to_paths = costs[to]\n      if to_total > total + weight:\n        costs[to] = (total + weight, [lst + [to] for lst in paths])\n        heappush(que, to)\n      elif to_total == total + weight:\n        costs[to] = (to_total, to_paths + [lst + [to] for lst in paths])\n  \n  \n  _, atob = costs[b]\n  from_to = [set() for _ in range(s)]\n  for path in atob:\n    for i, p in enumerate(path):\n      from_to[p] = from_to[p] | set(path[i + 1:])\n  \n  for _ in range(q):\n    start, goal = map(int, input().split())\n    start -= 1\n    goal -= 1\n    if goal in from_to[start]:\n      print(\"Yes\")\n    else:\n      print(\"No\")\n\nmain()\n"
  }
]