[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint n;\nint grid[10][10];\nbool visited[10][10];\nint target_sum;\nint start_count = 0;\nint start_positions[100][2];\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < n && !visited[x][y] && grid[x][y] >= 0;\n}\n\nbool solve(int index, int current_sum, int x, int y, int dx, int dy) {\n    if (current_sum == target_sum) {\n        for (int i = index + 1; i < start_count; i++) {\n            int sx = start_positions[i][0];\n            int sy = start_positions[i][1];\n            if (!visited[sx][sy]) {\n                int val = -grid[sx][sy];\n                bool found = false;\n                for (int dir = 0; dir < 4; dir++) {\n                    int ndx = (dir == 0) ? 1 : (dir == 1) ? -1 : 0;\n                    int ndy = (dir == 2) ? 1 : (dir == 3) ? -1 : 0;\n                    if (is_valid(sx + ndx, sy + ndy)) {\n                        visited[sx][sy] = true;\n                        if (solve(i, val, sx + ndx, sy + ndy, ndx, ndy)) {\n                            found = true;\n                            break;\n                        }\n                        visited[sx][sy] = false;\n                    }\n                }\n                if (!found) return false;\n            }\n        }\n        return true;\n    }\n    if (current_sum > target_sum) return false;\n    int nx = x + dx;\n    int ny = y + dy;\n    if (is_valid(nx, ny)) {\n        visited[nx][ny] = true;\n        if (solve(index, current_sum + grid[nx][ny], nx, ny, dx, dy)) {\n            return true;\n        }\n        visited[nx][ny] = false;\n    }\n    if (dx == 0 && dy == 0) {\n        for (int dir = 0; dir < 4; dir++) {\n            int ndx = (dir == 0) ? 1 : (dir == 1) ? -1 : 0;\n            int ndy = (dir == 2) ? 1 : (dir == 3) ? -1 : 0;\n            if (is_valid(x + ndx, y + ndy)) {\n                visited[x + ndx][y + ndy] = true;\n                if (solve(index, current_sum + grid[x + ndx][y + ndy], x + ndx, y + ndy, ndx, ndy)) {\n                    return true;\n                }\n                visited[x + ndx][y + ndy] = false;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (scanf(\"%d\", &n) == 1 && n != 0) {\n        start_count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &grid[i][j]);\n                visited[i][j] = false;\n                if (grid[i][j] < 0) {\n                    start_positions[start_count][0] = i;\n                    start_positions[start_count][1] = j;\n                    start_count++;\n                }\n            }\n        }\n        bool possible = false;\n        if (start_count > 0) {\n            int sx = start_positions[0][0];\n            int sy = start_positions[0][1];\n            target_sum = -grid[sx][sy];\n            visited[sx][sy] = true;\n            possible = solve(0, 0, sx, sy, 0, 0);\n        }\n        printf(possible ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:57:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PuzzleSolver {\n    static int[][] grid;\n    static int n;\n    static boolean[][] visited;\n    static List<int[]> startPoints;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int datasets = sc.nextInt();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            n = sc.nextInt();\n            grid = new int[n][n];\n            visited = new boolean[n][n];\n            startPoints = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = sc.nextInt();\n                    if (grid[i][j] < 0) {\n                        startPoints.add(new int[]{i, j});\n                    }\n                }\n            }\n\n            System.out.println(solve() ? \"YES\" : \"NO\");\n        }\n    }\n\n    static boolean solve() {\n        for (int[] start : startPoints) {\n            int startRow = start[0], startCol = start[1];\n            int target = Math.abs(grid[startRow][startCol]);\n            \n            if (!dfs(startRow, startCol, target, 0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static boolean dfs(int row, int col, int target, int currentSum) {\n        if (currentSum == target) {\n            return true;\n        }\n\n        visited[row][col] = true;\n\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int[] dir : directions) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (isValid(newRow, newCol) && !visited[newRow][newCol]) {\n                if (grid[newRow][newCol] < 0 && currentSum + Math.abs(grid[newRow][newCol]) > target) {\n                    continue;\n                }\n\n                if (dfs(newRow, newCol, target, currentSum + Math.abs(grid[newRow][newCol]))) {\n                    return true;\n                }\n            }\n        }\n\n        visited[row][col] = false;\n        return false;\n    }\n\n    static boolean isValid(int row, int col) {\n        return row >= 0 && row < n && col >= 0 && col < n;\n    }\n}",
    "timestamp": "2025-08-05 18:57:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> grid;\nvector<vector<bool>> visited;\nvector<pair<int, int>> starts;\nint target_sum;\nint n;\n\nbool dfs(int x, int y, int sum, int steps, int max_steps, int dx, int dy) {\n    if (steps > max_steps) return false;\n    if (x < 0 || x >= n || y < 0 || y >= n) return false;\n    if (visited[x][y]) return false;\n    if (grid[x][y] < 0 && steps != 0) return false;\n    \n    sum += grid[x][y];\n    if (sum > target_sum) return false;\n    if (steps == max_steps) {\n        return sum == target_sum;\n    }\n    \n    visited[x][y] = true;\n    bool found = false;\n    \n    if (dx == 0 && dy == 0) {\n        found = dfs(x+1, y, sum, steps+1, max_steps, 1, 0) ||\n                dfs(x-1, y, sum, steps+1, max_steps, -1, 0) ||\n                dfs(x, y+1, sum, steps+1, max_steps, 0, 1) ||\n                dfs(x, y-1, sum, steps+1, max_steps, 0, -1);\n    } else {\n        found = dfs(x+dx, y+dy, sum, steps+1, max_steps, dx, dy);\n    }\n    \n    visited[x][y] = false;\n    return found;\n}\n\nbool solve() {\n    for (auto &start : starts) {\n        int x = start.first, y = start.second;\n        int val = -grid[x][y];\n        target_sum = val;\n        bool possible = false;\n        \n        visited.assign(n, vector<bool>(n, false));\n        visited[x][y] = true;\n        \n        possible = dfs(x+1, y, 0, 1, val, 1, 0) ||\n                  dfs(x-1, y, 0, 1, val, -1, 0) ||\n                  dfs(x, y+1, 0, 1, val, 0, 1) ||\n                  dfs(x, y-1, 0, 1, val, 0, -1);\n        \n        if (!possible) return false;\n    }\n    return true;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    while (cin >> n, n != 0) {\n        grid.assign(n, vector<int>(n));\n        starts.clear();\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> grid[i][j];\n                if (grid[i][j] < 0) {\n                    starts.emplace_back(i, j);\n                }\n            }\n        }\n        \n        if (solve()) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_GRID 50\n\nint grid[MAX_GRID][MAX_GRID];\nint visited[MAX_GRID][MAX_GRID];\nint n;\n\nint dfs(int row, int col, int start_val, int current_sum) {\n    if (row < 0 || row >= n || col < 0 || col >= n || visited[row][col]) \n        return 0;\n\n    current_sum += grid[row][col];\n    visited[row][col] = 1;\n\n    if (current_sum == abs(start_val)) \n        return 1;\n\n    if (current_sum > abs(start_val)) \n        return 0;\n\n    // Try moving right\n    if (dfs(row, col + 1, start_val, current_sum)) \n        return 1;\n\n    // Try moving down \n    if (dfs(row + 1, col, start_val, current_sum)) \n        return 1;\n\n    // Try moving left\n    if (dfs(row, col - 1, start_val, current_sum)) \n        return 1;\n\n    // Try moving up\n    if (dfs(row - 1, col, start_val, current_sum)) \n        return 1;\n\n    visited[row][col] = 0;\n    return 0;\n}\n\nint solve_puzzle() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] < 0) {\n                memset(visited, 0, sizeof(visited));\n                if (!dfs(i, j, grid[i][j], 0)) \n                    return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        scanf(\"%d\", &n);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                scanf(\"%d\", &grid[i][j]);\n            }\n        }\n\n        printf(\"%s\\n\", solve_puzzle() ? \"YES\" : \"NO\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass PuzzleSolver {\nprivate:\n    vector<vector<int>> grid;\n    int n;\n    vector<vector<bool>> visited;\n    vector<pair<int, int>> startPoints;\n\n    bool isValidMove(int x, int y) {\n        return x >= 0 && x < n && y >= 0 && y < n && !visited[x][y];\n    }\n\n    bool dfs(int x, int y, int startNum, int currentSum, int direction) {\n        if (currentSum == abs(startNum)) return true;\n        if (abs(currentSum) > abs(startNum)) return false;\n\n        visited[x][y] = true;\n\n        // Try 4 directions\n        vector<pair<int, int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n        for (auto& dir : dirs) {\n            int nx = x + dir.first;\n            int ny = y + dir.second;\n\n            if (isValidMove(nx, ny)) {\n                // Check if we're crossing another start point\n                bool crossStartPoint = false;\n                for (auto& start : startPoints) {\n                    if (start.first == nx && start.second == ny && grid[nx][ny] < 0) {\n                        crossStartPoint = true;\n                        break;\n                    }\n                }\n                \n                if (!crossStartPoint) {\n                    int newSum = currentSum + grid[nx][ny];\n                    if (dfs(nx, ny, startNum, newSum, direction)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        visited[x][y] = false;\n        return false;\n    }\n\npublic:\n    bool solve() {\n        cin >> n;\n        if (n == 0) return false;\n\n        grid.resize(n, vector<int>(n));\n        visited.resize(n, vector<bool>(n, false));\n        startPoints.clear();\n\n        // Read grid\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cin >> grid[i][j];\n                if (grid[i][j] < 0) {\n                    startPoints.push_back({i, j});\n                }\n            }\n        }\n\n        // Try solving for each start point\n        for (auto& start : startPoints) {\n            int x = start.first, y = start.second;\n            int startNum = grid[x][y];\n\n            // Reset visited\n            for (auto& row : visited) {\n                fill(row.begin(), row.end(), false);\n            }\n\n            bool solved = false;\n            // Try 4 directions from start point\n            vector<pair<int, int>> dirs = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n            for (auto& dir : dirs) {\n                int nx = x + dir.first;\n                int ny = y + dir.second;\n\n                if (isValidMove(nx, ny)) {\n                    if (dfs(nx, ny, startNum, grid[nx][ny], 0)) {\n                        solved = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!solved) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    PuzzleSolver solver;\n    while (true) {\n        if (!solver.solve()) break;\n        cout << (solver.solve() ? \"YES\" : \"NO\") << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:58:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PuzzleSolver {\n    static int n;\n    static int[][] grid;\n    static boolean[][] visited;\n    static List<int[]> starts;\n    static int targetSum;\n    static boolean solved;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            n = scanner.nextInt();\n            if (n == 0) break;\n            grid = new int[n][n];\n            visited = new boolean[n][n];\n            starts = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = scanner.nextInt();\n                    if (grid[i][j] < 0) {\n                        starts.add(new int[]{i, j, -grid[i][j]});\n                    }\n                }\n            }\n            solved = false;\n            targetSum = starts.get(0)[2];\n            for (int[] start : starts) {\n                if (start[2] != targetSum) {\n                    solved = false;\n                    break;\n                }\n            }\n            if (!solved) {\n                System.out.println(\"NO\");\n                continue;\n            }\n            solve(0);\n            System.out.println(solved ? \"YES\" : \"NO\");\n        }\n        scanner.close();\n    }\n\n    static void solve(int index) {\n        if (index == starts.size()) {\n            solved = true;\n            return;\n        }\n        int[] start = starts.get(index);\n        int x = start[0];\n        int y = start[1];\n        int sum = start[2];\n        visited[x][y] = true;\n        dfs(x, y, sum, 0, index);\n        visited[x][y] = false;\n    }\n\n    static void dfs(int x, int y, int sum, int currentSum, int index) {\n        if (solved) return;\n        if (currentSum == sum) {\n            solve(index + 1);\n            return;\n        }\n        if (currentSum > sum) return;\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (int[] dir : dirs) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny]) {\n                if (grid[nx][ny] < 0) continue;\n                visited[nx][ny] = true;\n                dfs(nx, ny, sum, currentSum + grid[nx][ny], index);\n                visited[nx][ny] = false;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:59:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_puzzles(datasets):\n    def can_solve(grid, n):\n        marked_positions = [(x, y) for x in range(n) for y in range(n) if grid[x][y] < 0]\n        \n        def valid_path(x, y, target_sum, visited, dx, dy):\n            current_sum = 0\n            while 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                visited.add((x, y))\n                current_sum += grid[x][y]\n                if current_sum == target_sum:\n                    return True\n                x += dx\n                y += dy\n            return False\n\n        visited = set()\n        for x, y in marked_positions:\n            target_sum = -grid[x][y]\n            if not (valid_path(x + 1, y, target_sum, visited, 1, 0) or\n                    valid_path(x - 1, y, target_sum, visited, -1, 0) or\n                    valid_path(x, y + 1, target_sum, visited, 0, 1) or\n                    valid_path(x, y - 1, target_sum, visited, 0, -1)):\n                return False\n        return True\n\n    results = []\n    for data in datasets:\n        n = data[0]\n        grid = [data[i+1:i+1+n] for i in range(0, len(data)-1, n)]\n        results.append('YES' if can_solve(grid, n) else 'NO')\n    \n    return results\n\n# Example of usage:\n# datasets = [\n#     (4, -6, 1, 1, 1, 5, 2, -5, 3, -3, 6, 4, 2, 3, 2, 1),\n#     (5, -4, 2, 2, 1, 5, 1, 3, 0, -1, 3, 3, -3, 4, -6, 1, 2, 2, 1, 0, 4)\n# ]\n# print(solve_puzzles(datasets))",
    "timestamp": "2025-08-13 01:39:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class GridPuzzleSolver {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            int[][] grid = new int[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    grid[i][j] = scanner.nextInt();\n                }\n            }\n            System.out.println(canSolvePuzzle(grid, n) ? \"YES\" : \"NO\");\n        }\n        scanner.close();\n    }\n\n    private static boolean canSolvePuzzle(int[][] grid, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] < 0) { // starting point\n                    int targetSum = -grid[i][j];\n                    if (!isValidPath(grid, n, i, j, targetSum, new boolean[n][n])) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean isValidPath(int[][] grid, int n, int i, int j, int targetSum, boolean[][] visited) {\n        return canDrawLine(grid, n, i, j, targetSum, visited, true) || canDrawLine(grid, n, i, j, targetSum, visited, false);\n    }\n\n    private static boolean canDrawLine(int[][] grid, int n, int x, int y, int targetSum, boolean[][] visited, boolean isVertical) {\n        int i = x, j = y, sum = 0;\n        while (i < n && j < n && i >= 0 && j >= 0 && !visited[i][j] && grid[i][j] >= 0 && sum + grid[i][j] <= targetSum) {\n            sum += grid[i][j];\n            visited[i][j] = true;\n            if (isVertical) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        i = x; j = y;\n        while (i < n && j < n && i >= 0 && j >= 0 && sum < targetSum && grid[i][j] >= 0) {\n            if (isVertical) {\n                i--;\n            } else {\n                j--;\n            }\n            if (i >= 0 && j >= 0 && grid[i][j] >= 0 && !visited[i][j] && sum + grid[i][j] <= targetSum) {\n                sum += grid[i][j];\n                visited[i][j] = true;\n            }\n        }\n        return sum == targetSum;\n    }\n}",
    "timestamp": "2025-08-13 01:39:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 10\n#define UNVISITED 0\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint grid[MAX][MAX], visited[MAX][MAX];\nint n;\n\n// Directions for right, left, down, up\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint isValid(Point p) {\n    return p.x >= 0 && p.x < n && p.y >= 0 && p.y < n && !visited[p.x][p.y] && grid[p.x][p.y] >= 0;\n}\n\nint solveFrom(Point start, int remainingSum, int direction) {\n    if (remainingSum == 0) return 1;\n\n    Point next = {start.x + dx[direction], start.y + dy[direction]};\n    if (isValid(next)) {\n        visited[next.x][next.y] = 1;\n        if (solveFrom(next, remainingSum - grid[next.x][next.y], direction)) return 1;\n        visited[next.x][next.y] = UNVISITED; // Backtrack\n    }\n    return 0;\n}\n\nint attemptSolve(Point start) {\n    // Try in all four directions\n    for (int dir = 0; dir < 4; ++dir) {\n        visited[start.x][start.y] = 1;\n        if (solveFrom(start, -grid[start.x][start.y], dir)) return 1;\n        visited[start.x][start.y] = UNVISITED;\n    }\n    return 0;\n}\n\nint solvePuzzle() {\n    // Reset visited\n    for (int i = 0; i < n; ++i) \n        for (int j = 0; j < n; ++j) \n            visited[i][j] = UNVISITED;\n    \n    for (int i = 0; i < n; ++i) \n        for (int j = 0; j < n; ++j) \n            if (grid[i][j] < 0) // Starting point\n                if (!attemptSolve((Point){i, j})) \n                    return 0; // Cannot solve for one of the starting points\n    return 1;\n}\n\nint main() {\n    int numCases;\n    scanf(\"%d\", &numCases);\n    \n    while (numCases--) {\n        scanf(\"%d\", &n);\n        \n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                scanf(\"%d\", &grid[i][j]);\n        \n        printf(solvePuzzle() ? \"YES\\n\" : \"NO\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 01:39:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_solve_puzzle(n, grid):\n    def find_start_points():\n        return [(r, c) for r in range(n) for c in range(n) if grid[r][c] < 0]\n    \n    def is_valid_move(r, c):\n        return 0 <= r < n and 0 <= c < n\n    \n    def trace_line(sr, sc, target_sum):\n        visited = set()\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        \n        def dfs(r, c, current_sum):\n            if current_sum == abs(target_sum):\n                return True\n            \n            if current_sum > abs(target_sum):\n                return False\n            \n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                \n                if is_valid_move(nr, nc) and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    if dfs(nr, nc, current_sum + abs(grid[nr][nc])):\n                        return True\n                    visited.remove((nr, nc))\n            \n            return False\n        \n        visited.add((sr, sc))\n        return dfs(sr, sc, 0)\n    \n    start_points = find_start_points()\n    \n    def solve():\n        for sr, sc in start_points:\n            if not trace_line(sr, sc, grid[sr][sc]):\n                return False\n        return True\n    \n    return solve()\n\ndef main():\n    while True:\n        try:\n            n = int(input())\n            grid = [list(map(int, input().split())) for _ in range(n)]\n            \n            result = 'YES' if can_solve_puzzle(n, grid) else 'NO'\n            print(result)\n        \n        except EOFError:\n            break\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 01:39:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        n = int(input[ptr])\n        ptr += 1\n        grid = []\n        starts = []\n        for i in range(n):\n            row = list(map(int, input[ptr:ptr+n]))\n            ptr += n\n            grid.append(row)\n            for j in range(n):\n                if row[j] < 0:\n                    starts.append((i, j, -row[j]))\n        \n        visited = [[False for _ in range(n)] for _ in range(n)]\n        possible = True\n        \n        for x, y, target in starts:\n            if visited[x][y]:\n                possible = False\n                break\n            visited[x][y] = True\n            found = False\n            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                current_sum = 0\n                temp_visited = []\n                ok = True\n                while 0 <= nx < n and 0 <= ny < n:\n                    if visited[nx][ny]:\n                        if grid[nx][ny] < 0:\n                            ok = False\n                        break\n                    current_sum += grid[nx][ny]\n                    temp_visited.append((nx, ny))\n                    if current_sum == target:\n                        found = True\n                        for (vx, vy) in temp_visited:\n                            visited[vx][vy] = True\n                        break\n                    if current_sum > target:\n                        break\n                    nx += dx\n                    ny += dy\n                if found:\n                    break\n            if not found:\n                possible = False\n                break\n        \n        print(\"YES\" if possible else \"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 01:40:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nbool canDrawLine(vector<vector<int>>& grid, int n, int x, int y, int targetSum) {\n    vector<vector<bool>> visited(n, vector<bool>(n, false));\n    queue<pair<int, int>> q;\n    q.push({x, y});\n    visited[x][y] = true;\n    int sum = grid[x][y];\n    \n    // Directions: right, down, left, up\n    int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    while (!q.empty()) {\n        int curX = q.front().first;\n        int curY = q.front().second;\n        q.pop();\n        \n        for (int d = 0; d < 4; ++d) {\n            int newX = curX + dir[d][0];\n            int newY = curY + dir[d][1];\n            \n            if (newX >= 0 && newX < n && newY >= 0 && newY < n && !visited[newX][newY]) {\n                if (sum + grid[newX][newY] == targetSum) {\n                    return true;\n                }\n                if (grid[newX][newY] > 0) {\n                    q.push({newX, newY});\n                    visited[newX][newY] = true;\n                    sum += grid[newX][newY];\n                }\n            }\n        }\n    }\n    return false;\n}\n\nbool solvePuzzle(vector<vector<int>>& grid, int n) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] < 0) {\n                if (!canDrawLine(grid, n, i, j, -grid[i][j])) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        vector<vector<int>> grid(n, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        cout << (solvePuzzle(grid, n) ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:01:38"
  }
]