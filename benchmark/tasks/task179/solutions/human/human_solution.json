[
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,nn;\nint L[8][8];\nbool u[8][8];\n\nbool ans=false;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid dfs( bool isSearchP,int x,int y, int sum,int nL ){\n  /*\n  if( isSearchP )    cout << \"sP \";\n  else     cout << \"   \";\n  cout << x << \" \" << y << \" \" << sum << \" \" << nL <<endl;\n  */\n  if( ans ) return;\n\n  if( isSearchP ){ // 起点探索\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( u[i][j] ) continue;\n\tif( L[i][j]<0 ){\n\t  //\t  cout << \" 起点：\"<< i << \",\" << j << endl;\n\t  u[i][j]=true;\n\t  dfs( false,i,j,L[i][j],nL-1 );\n\t  u[i][j]=false;\n\t}\n      }\n    }\n  }else{ // 起点からの線がつながるかをチェック\n    if( nL==0 ){\n      ans = true;      return;\n    }\n    if( sum==0 )\n      dfs( true,0,0,0,nL ); // 新たな起点を探しにいく\n\n    int nx,ny, ns;\n    for( int i=0;i<4;i++ ){\n      nx=x+dx[i]; ny=y+dy[i];\n      if( nx<0 || nx>=n ) continue;\n      if( ny<0 || ny>=n ) continue;\n      if( u[nx][ny] )     continue;\n      if( L[nx][ny]<0 )   continue;\n\n      ns = sum + L[nx][ny];\n      u[nx][ny]=true;\n      dfs( false,nx,ny,ns,nL-1 );\n      u[nx][ny]=false;\n    }\n  }\n}\n\nint main(){\n  while( cin>>n && n ){\n    int sum=0;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tcin >> L[i][j];\n\tsum += L[i][j];\n\tu[i][j] = false;\n      }\n    //    cout << \"sum=\" << sum << endl;\n    ans = false;\n    if( sum==0 )\n      dfs( true,0,0,0,n*n );\n    if( ans ) cout << \"YES\" << endl;\n    else      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<ull> cache;\nvector<int> V_sum;\nvector<int> coor;\nset<vector<ull> > visited;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n\n  if( cur >= V ){\n    if( used == (1ULL<<(n*n))-1ULL ) return true;\n    return false;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( field[ny][nx] < 0 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) )\n      return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    visited.clear();\n    ull initial_state = 0ULL;\n    V = 0;\n    cache.clear();\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcache.push_back(tmp);\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nint n, a[9][9], cnt, px[75], py[75]; bool vis[9][9];\nbool solve(int sx, int sy, int cur, int vcnt, int sum) {\n\tif (cur == cnt) return vcnt == n * n + 1;\n\tif (sum == -a[px[cur]][py[cur]]) {\n\t\tvis[px[cur + 1]][py[cur + 1]] = true;\n\t\tbool res = solve(px[cur + 1], py[cur + 1], cur + 1, vcnt + 1, 0);\n\t\tvis[px[cur + 1]][py[cur + 1]] = false;\n\t\treturn res;\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + dir[i], ty = sy + dir[i ^ 1];\n\t\tif (0 <= tx && tx < n && 0 <= ty && ty < n && !vis[tx][ty] && a[tx][ty] > 0 && sum + a[tx][ty] <= -a[px[cur]][py[cur]]) {\n\t\t\tvis[tx][ty] = true;\n\t\t\tbool res = solve(tx, ty, cur, vcnt + 1, sum + a[tx][ty]);\n\t\t\tvis[tx][ty] = false;\n\t\t\tif (res) return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] < 0) {\n\t\t\t\t\tpx[cnt] = i;\n\t\t\t\t\tpy[cnt] = j;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvis[px[0]][py[0]] = true;\n\t\tbool ret = solve(px[0], py[0], 0, 1, 0);\n\t\tvis[px[0]][py[0]] = false;\n\t\tcout << (ret ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nint t[10][10];\nbool v[10][10];\nvector<P> can;\nint dy[] = {-1,0,1,0} , dx[] = {0,1,0,-1};\n\nbool rec(int id);\n\nbool dfs(int id,int y,int x,int sum){\n  if(sum == 0)return rec(id+1);\n  if(sum>0)return false;\n\n  for(int i=0;i<4;i++){\n    int ty = y+dy[i], tx = x+dx[i];\n    if(ty<0 || tx<0 || n<=ty || n<= tx)continue;\n    if(v[ty][tx])continue;\n    v[ty][tx] = true;\n    if(dfs(id,ty,tx,sum+t[ty][tx]))return true;\n    v[ty][tx] = false;\n  }\n  return false;\n}\n\nbool rec(int id){\n  if(id == can.size())return true;\n  int y = can[id].first, x = can[id].second;\n  v[y][x] = true;\n  return dfs(id,y,x,t[y][x]);\n}\n\nint main(){\n  while(cin >> n,n){\n    int sum = 0; can.clear();\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tcin >> t[i][j];\n\tsum += t[i][j];\n\tif(t[i][j]<0)can.push_back(P(i,j));\n\tv[i][j] = false;\n      }\n\n    cout << ( (!sum && rec(0))?\"YES\\n\":\"NO\\n\" );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n;\nint data[8][8];\nbool flag;\nstruct A{\n  bool visited[8][8];\n};\n\nvoid rec(A);\nvoid rec2(int, int, int, int, A);\n\nvoid print(A a) {\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < n; j++) {\n      if(a.visited[i][j]) cout << '#';\n      else cout << ' ';\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid rec(A a) {\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < n; j++) {\n      if(!a.visited[i][j] && data[i][j] < 0) {\n\ta.visited[i][j] = true;\n\trec2(j, i, -data[i][j], 0, a);\n\treturn;\n      }\n    }\n  }\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < n; j++) {\n      if(!a.visited[i][j]) return;\n    }\n  }\n  flag = true;\n}\n\nvoid rec2(int x, int y, int cost, int sum, A a) {\n  static int d[4][2] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\n  if(sum == cost) {rec(a);return;}\n  if(sum > cost) return;\n\n  for(int i = 0; i < 4; i++) {\n    int nx = x + d[i][0];\n    int ny = y + d[i][1];\n    if(nx < 0 || nx >= n) continue;\n    if(ny < 0 || ny >= n) continue;\n    if(a.visited[ny][nx]) continue;\n    if(data[ny][nx] < 0) continue;\n\n    a.visited[ny][nx] = true;\n    rec2(nx, ny, cost, sum+data[ny][nx], a);\n    a.visited[ny][nx] = false;\n  }\n}\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tcin >> data[i][j];\n      }\n    }\n    A a;\n    for(int i = 0; i < 8; i++) {\n      for(int j = 0; j < 8; j++) {\n\ta.visited[i][j] = false;\n      }\n    }\n    flag = false;\n    rec(a);\n    if(flag) cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nint t[10][10];\nlong long v;\nmap<long long,bool> m;\nvector<P> can;\nint dy[] = {-1,0,1,0} , dx[] = {0,1,0,-1};\n\nbool rec(int id);\n\nbool dfs(int id,int y,int x,int sum){\n  if(sum == 0)return rec(id+1);\n  if(sum>0)return false;\n\n  for(int i=0;i<4;i++){\n    int ty = y+dy[i], tx = x+dx[i];\n    if(ty<0 || tx<0 || n<=ty || n<= tx)continue;\n    if( (v>>(ty*n+tx)) & 1LL || t[ty][tx]<0)continue;\n    v |= 1LL << (ty*n+tx);\n    if(dfs(id,ty,tx,sum+t[ty][tx]))return true;\n    v &= ~(1LL << (ty*n+tx));\n  }\n  return false;\n}\n\nbool rec(int id){\n  if(id == can.size())return true;\n  if(m[v])return false;\n  m[v] = true;\n  int y = can[id].first, x = can[id].second;\n  return dfs(id,y,x,t[y][x]);\n}\n\nint main(){\n  while(cin >> n,n){\n    int sum = 0; can.clear(); m.clear();\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tcin >> t[i][j];\n\tsum += t[i][j];\n\tif(t[i][j]<0){\n\t  can.push_back(P(i,j));\n\t  v |= 1LL<<(i*n+j);\n\t}\n      }\n    v = 0LL;\n\n    cout << ( (!sum && rec(0))?\"YES\\n\":\"NO\\n\" );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,nn;\nint L[8][8];\nbool u[8][8];\n\nbool ans=false;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid dfs( bool isSearchP,int x,int y, int sum,int nL ){\n  /*\n  if( isSearchP )    cout << \"sP \";\n  else     cout << \"   \";\n  cout << x << \" \" << y << \" \" << sum << \" \" << nL <<endl;\n  */\n  if( ans ) return;\n\n  if( isSearchP ){ // 起点探索\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( u[i][j] ) continue;\n\tif( L[i][j]<0 ){\n\t  //\t  cout << \" 起点：\"<< i << \",\" << j << endl;\n\t  u[i][j]=true;\n\t  dfs( false,i,j,L[i][j],nL-1 );\n\t  if( ans ) return;\n\t  u[i][j]=false;\n\t}\n      }\n    }\n  }else{ // 起点からの線がつながるかをチェック\n    if( nL==0 ){\n      ans = true;      return;\n    }\n    if( sum==0 )\n      dfs( true,0,0,0,nL ); // 新たな起点を探しにいく\n\n    int nx,ny, ns;\n    for( int i=0;i<4;i++ ){\n      nx=x+dx[i]; ny=y+dy[i];\n      if( u[nx][ny] )     continue;\n      if( nx<0 || nx>=n ) continue;\n      if( ny<0 || ny>=n ) continue;\n      if( L[nx][ny]<0 )   continue;\n\n      ns = sum + L[nx][ny];\n      u[nx][ny]=true;\n      dfs( false,nx,ny,ns,nL-1 );\n      if( ans ) return;\n      u[nx][ny]=false;\n    }\n  }\n}\n\nint main(){\n  while( cin>>n && n ){\n    int sum=0;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tcin >> L[i][j];\n\tsum += L[i][j];\n\tu[i][j] = false;\n      }\n    //    cout << \"sum=\" << sum << endl;\n    ans = false;\n    if( sum==0 )\n      dfs( true,0,0,0,n*n );\n    if( ans ) cout << \"YES\" << endl;\n    else      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//06\n#include<iostream>\n\nusing namespace std;\n\nint n;\nint g[8][8];\n\nbool dfs();\n\nbool gr(int r,int y,int x){\n  int t=g[y][x];\n  r+=t;\n  if(r>0){\n    return false;\n  }else{\n    g[y][x]=0;\n    bool e=false;\n    if(r==0){\n      e=dfs();\n    }else{\n      for(int i=0;i<4;i++){\n\tint d[]={0,1,0,-1,0};\n\tint nx=x+d[i];\n\tint ny=y+d[i+1];\n\tif(0<=nx&&nx<n&&0<=ny&&ny<n&&g[ny][nx]>0){\n\t  if(gr(r,ny,nx)){\n\t    e=true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    g[y][x]=t;\n    return e;\n  }\n}\n\nbool dfs(){\n  bool m=false;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      m|=g[i][j];\n      if(g[i][j]<0){\n\treturn gr(0,i,j);\n      }\n    }\n  }\n  return !m;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcin>>g[i][j];\n      }\n    }\n    cout<<(dfs()?\"YES\":\"NO\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint n, m;\nvector<vector<int> > a;\nvector<pair<int, int> > s;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nbool solve(int k, int y, int x, int rest)\n{\n    if(rest < 0)\n        return false;\n\n    if(rest == 0){\n        if(k == m)\n            return true;\n        y = s[k].first;\n        x = s[k].second;\n        rest = -a[y][x];\n        ++ k;\n    }\n\n    for(int i=0; i<4; ++i){\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        if(y2 < 0 || y2 >= n || x2 < 0 || x2 >= n)\n            continue;\n        if(a[y2][x2] > 0){\n            a[y2][x2] *= -1;\n            if(solve(k, y2, x2, rest + a[y2][x2]))\n                return true;\n            a[y2][x2] *= -1;\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    for(;;){\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        a.assign(n, vector<int>(n));\n        s.clear();\n        m = 0;\n        int sum = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                cin >> a[i][j];\n                sum += a[i][j];\n                if(a[i][j] < 0){\n                    s.push_back(make_pair(i, j));\n                    ++ m;\n                }\n            }\n        }\n\n        if(sum != 0){\n            cout << \"NO\" << endl;\n            continue;\n        }\n\n        if(solve(0, -1, -1, 0))\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint n;\nint b[10][10];\nint id[10][10];\nvector<vector<ull> > v;\nint nid;\nint midx;\n\nconst int dx[4] = { 1,-1, 0, 0};\nconst int dy[4] = { 0, 0, 1,-1};\n\n#define HASH(x,y) (((ull)1) << (((x)-1) + ((y)-1)*8)) \n\nvoid check(int x, int y, int sum, ull f){\n  if(sum == 0){\n    v[nid].push_back(f);\n    return;\n  }\n  //printf(\"check(%d,%d,%d,%llu)\\n\",x,y,sum,f);\n  REP(i,4){\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    ull h  = HASH(xx,yy);\n    int s = sum - b[yy][xx];\n    if(s < 0 || (h & f) != 0 || b[yy][xx] < 0) continue;\n    check(xx,yy,s,(f|h));\n  }\n}\n\nbool ans(int idx, ull f){\n  if(idx == midx) return true;\n  REP(i,v[idx].size()){\n    if((f & v[idx][i]) == 0 && ans(idx+1, (f | v[idx][i])))\n       return true;\n  }\n  return false;\n}\n\nint main(){\n  REP(i,10) REP(j,10) b[i][j] = 1000;\n  while(scanf(\"%d\",&n),n){\n    int idx = 0;\n    int sum = 0;\n\n    REP(i,n) REP(j,n){\n      int tmp;\n      scanf(\"%d\",&tmp); \n      b[i+1][j+1] = tmp;\n      if(tmp < 0){\n\tid[i+1][j+1] = idx++;\n      }\n      sum += tmp;\n    }\n\n    midx = idx;\n\n    if(sum != 0){\n      puts(\"NO\");\n      continue;\n    }\n\n    v = vector<vector<ull> >(idx);\n\n    for(int y=1; y<=n; y++){\n      for(int x=1; x<=n; x++){\n\tif(b[y][x] < 0){\n\t  nid = id[y][x];\n\t  check(x,y,-b[y][x],HASH(x,y));\n\t}\n      }\n    }\n\n    puts(ans(0,0)?\"YES\":\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef unsigned long long ll;\n\nvector<vector<ll> > lines;\n\nint n;\nint field[9][9];\n\nvector<ll> tmp;\n\nconst int dy[]={0,0,-1,1};\nconst int dx[]={1,-1,0,0};\n\nbool ok=false;\n\nll fin;\n\n\nvoid dfs(ll s,int idx){\n\tif(ok){\n\t\treturn;\n\t}\n\tif(idx==lines.size()){\n\t\tif(fin==s)\n\t\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < lines[idx].size(); i++){\n\t\tif((s&lines[idx][i])==0){\n\t\t\tdfs(s|lines[idx][i],idx+1);\n\t\t}\n\t}\n}\n\nvoid lineSearch(ll s,int curSum,int ret,int x,int y){\n\tif(curSum==ret){\n\t\ttmp.push_back(s);\n\t}\n\tfor(int i= 0; i < 4; i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx>=0&&ny>=0&&nx<n&&ny<n&&field[ny][nx]>=1&&(curSum+field[ny][nx]<=ret)){\n\t\t\tif(!((s>>(ny*n+nx))&(1ull))){\n\t\t\t\tll ns=s|(((1ull)<<(ny*n+nx)));\n\t\t\t\tlineSearch(ns,curSum+field[ny][nx],ret,nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(cin>>n&&n!=0){\n\t\tfin=0;\n\t\tfor(int i = 0; i < n*n; i++){\n\t\t\tfin|=(1ull<<i);\n\t\t}\n\n\t\tok=false;\n\t\tlines.clear();\n\t\tvector<pair<int,pair<int,int> > > vpii;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]<0){\n\t\t\t\t\tvpii.push_back(make_pair(field[i][j],make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < vpii.size(); i++){\n\t\t\ttmp.clear();\n\t\t\tlineSearch(((1ull)<<(vpii[i].second.first*n+vpii[i].second.second)),0,-vpii[i].first,vpii[i].second.second,vpii[i].second.first);\n\t\t\tlines.push_back(tmp);\n\t\t}\n\t\tdfs(0ull,0);\n\t\tif(ok)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<vector>\nstruct P{int x,y;P(int x,int y):x(x),y(y){}};\n\nint num[10][10];\nbool visited[10][10];\nstd::vector<P>v;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nbool BackTrack(int x,int y,int index,int rest)\n{\n\tif(rest==0)\n\t{\n\t\tif(index==v.size()-1)\n\t\t\treturn true;\n\t\t++index;\n\t\tx=v[index].x;\n\t\ty=v[index].y;\n\t\trest = -num[y][x];\n\t\treturn BackTrack(x,y,index,rest);\n\t}\n\tbool res = false;\n\tfor(int i=0; i<4; ++i)\n\t{\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(visited[ny][nx])continue;\n\t\tvisited[ny][nx] = true;\n\n\t\tres = res || BackTrack(nx,ny,index,rest-num[ny][nx]);\n\n\t\tvisited[ny][nx] = false;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n,i,j,t;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tv.clear();\n\t\tmemset(visited,1,sizeof(visited));\n\n\t\tint check = 0;\n\t\tfor(i=1; i<=n; ++i)\n\t\t{\n\t\t\tfor(j=1; j<=n; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tnum[i][j]=t;\n\t\t\t\tif(t<0)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(P(j,i));\n\t\t\t\t\tvisited[i][j]=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvisited[i][j]=false;\n\t\t\t\t}\n\t\t\t\tcheck += t;\n\t\t\t}\n\t\t}\n\n\t\tint x=v[0].x;\n\t\tint y=v[0].y;\n\t\tputs(check==0&&BackTrack(x,y,0,-num[y][x]) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<P> rt;\n//map<vector<vector<int> >,bool> mp;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(y>=0&&y<n&&x>=0&&x<n)\n\t\treturn true;\n\treturn false;\n}\nbool cal(vector<vector<int> >&,int);\nbool f(vector<vector<int> > v,int y,int x,int left,int now){\n\tif(!left){\n\t\treturn cal(v,now+1);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\tif(inf(ny,nx)&&v[ny][nx]>0&&left-v[ny][nx]>=0){\n\t\t\tint temp=v[ny][nx];\n\t\t\tv[ny][nx]=0;\n\t\t\tif(f(v,ny,nx,left-temp,now)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tv[ny][nx]=temp;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool cal(vector<vector<int> > &v,int now){\n\tif(now==rt.size()){\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\tif(v[i][j]!=0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tint y=rt[now].first;\n\tint x=rt[now].second;\n\tint temp=v[y][x];\n\tv[y][x]=0;\n\tif(f(v,y,x,-temp,now))\n\t\treturn true;\n\tv[y][x]=temp;\n\treturn false;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tvector<vector<int> > v(n,vector<int>(n));\n\t\trt.clear();\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>v[i][j];\n\t\t\tif(v[i][j]<0)\n\t\t\trt.pb(P(i,j));\n\t\t}\n\t\tif(cal(v,0))\n\t\tcout<<\"YES\"<<endl;\n\t\t\telse\n\t\tcout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<int> V_sum;\nvector<int> coor;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n\n  if( cur >= V ){\n    //if( used == (1ULL<<(n*n))-1ULL ) return true;\n    //return false;\n    return true;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    //if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( field[ny][nx] < 0 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) ) return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    ull initial_state = 0ULL;\n    V = 0;\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n;\nint board[8][8];\nbool used[8][8];\n\nbool ok(int y, int x) {\n  return 0 <= y && y < n && 0 <= x && x < n;\n}\n\nbool solve(int y, int x, int r) {\n  if (r < 0) return false;\n  if (used[y][x]) return false;\n  used[y][x] = true;\n  if (r == 0) {\n    rep (i, n) rep (j, n) if (!used[i][j] && board[i][j] < 0) {\n      bool res = solve(i, j, -board[i][j]);\n      used[y][x] = false;\n      return res;\n    }\n    return true;\n  }\n  rep (k, 4) {\n    int ny = y + dy[k];\n    int nx = x + dx[k];\n    if (!ok(ny, nx)) continue;\n    if (board[ny][nx] < 0) continue;\n    if (solve(ny, nx, r - board[ny][nx])) return true;\n  }\n  used[y][x] = false;\n  return false;\n}\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    rep (i, n) rep (j, n) cin >> board[i][j];\n    rep (i, n) rep (j, n) used[i][j] = false;\n    int sum = 0;\n    rep (i, n) rep (j, n) sum += board[i][j];\n    if (sum != 0) {\n      cout << \"NO\" << endl;\n      continue;\n    }\n    rep (i, n) rep (j, n) if (board[i][j] < 0) {\n      if (solve(i, j, -board[i][j])) cout << \"YES\" << endl;\n      else cout << \"NO\" << endl;\n      i = j = n;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<int> V_sum;\nvector<int> coor;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\n/*\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n*/\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n\n  if( cur >= V ){\n    return true;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( field[ny][nx] < 0 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) ) return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    ull initial_state = 0ULL;\n    V = 0;\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef unsigned long long ll;\n\nvector<vector<ll> > lines;\nint n;\nint field[9][9];\n\nvector<ll> tmp;\n\nconst int dy[]={0,0,-1,1};\nconst int dx[]={1,-1,0,0};\n\nbool ok=false;\n\nll fin;\n\n\nvoid dfs(ll s,int idx){\n\tif(ok){\n\t\treturn;\n\t}\n\tif(idx==lines.size()){\n\t\tif(fin==s)\n\t\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < lines[idx].size(); i++){\n\t\tif((s&lines[idx][i])==0){\n\t\t\tdfs(s|lines[idx][i],idx+1);\n\t\t}\n\t}\n}\n\nvoid lineSearch(ll s,int curSum,int ret,int x,int y){\n\tif(curSum==ret){\n\t\ttmp.push_back(s);\n\t}\n\tfor(int i= 0; i < 4; i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx>=0&&ny>=0&&nx<n&&ny<n&&field[ny][nx]>=1&&(curSum+field[ny][nx]<=ret)){\n\t\t\tif(!((s>>(ny*n+nx))&(1ull))){\n\t\t\t\tll ns=s|(((1ull)<<(ny*n+nx)));\n\t\t\t\tlineSearch(ns,curSum+field[ny][nx],ret,nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(cin>>n&&n!=0){\n\t\tfin=0;\n\t\tfor(int i = 0; i < n*n; i++){\n\t\t\tfin|=(1ull<<i);\n\t\t}\n\n\t\tok=false;\n\t\tlines.clear();\n\t\tvector<pair<int,pair<int,int> > > vpii;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]<0){\n\t\t\t\t\tvpii.push_back(make_pair(field[i][j],make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < vpii.size(); i++){\n\t\t\ttmp.clear();\n\t\t\tif(i==5){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\n\t\t\tlineSearch(((1ull)<<(vpii[i].second.first*n+vpii[i].second.second)),0,-vpii[i].first,vpii[i].second.second,vpii[i].second.first);\n\t\t\tlines.push_back(tmp);\n\t\t}\n\t\tdfs(0ull,0);\n\t\tif(ok)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,nn;\nint L[8][8];\nbool u[8][8];\n\nbool ans=false;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid dfs( bool isSearchP,int x,int y, int sum,int nL ){\n  /*\n  if( isSearchP )    cout << \"sP \";\n  else     cout << \"   \";\n  cout << x << \" \" << y << \" \" << sum << \" \" << nL <<endl;\n  */\n  if( ans ) return;\n\n  if( isSearchP ){ // 起点探索\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( u[i][j] ) continue;\n\tif( L[i][j]<0 ){\n\t  //\t  cout << \" 起点：\"<< i << \",\" << j << endl;\n\t  u[i][j]=true;\n\t  dfs( false,i,j,L[i][j],nL-1 );\n\t  if( ans ) return;\n\t  u[i][j]=false;\n\t}\n      }\n    }\n  }else{ // 起点からの線がつながるかをチェック\n    if( nL==0 ){\n      ans = true;      return;\n    }\n    if( sum==0 )\n      dfs( true,0,0,0,nL ); // 新たな起点を探しにいく\n\n    int nx,ny, ns;\n    for( int i=0;i<4;i++ ){\n      nx=x+dx[i]; ny=y+dy[i];\n      if( u[nx][ny] )     continue;\n      if( nx<0 || nx>=n ) continue;\n      if( ny<0 || ny>=n ) continue;\n      if( L[nx][ny]<0 )   continue;\n      ns = sum + L[nx][ny];\n      if( ns>0 ) continue;\n\n      u[nx][ny]=true;\n      dfs( false,nx,ny,ns,nL-1 );\n      if( ans ) return;\n      u[nx][ny]=false;\n    }\n  }\n}\n\nint main(){\n  while( cin>>n && n ){\n    int sum=0;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tcin >> L[i][j];\n\tsum += L[i][j];\n\tu[i][j] = false;\n      }\n    //    cout << \"sum=\" << sum << endl;\n    ans = false;\n    if( sum==0 )\n      dfs( true,0,0,0,n*n );\n    if( ans ) cout << \"YES\" << endl;\n    else      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<P> rt;\n//map<vector<vector<int> >,bool> mp;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(y>=0&&y<n&&x>=0&&x<n)\n\t\treturn true;\n\treturn false;\n}\nbool cal(vector<vector<int> >&,int);\nbool f(vector<vector<int> > &v,int y,int x,int left,int now){\n\tif(!left){\n\t\treturn cal(v,now+1);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\tif(inf(ny,nx)&&v[ny][nx]>0&&left-v[ny][nx]>=0){\n\t\t\tint temp=v[ny][nx];\n\t\t\tv[ny][nx]=0;\n\t\t\tif(f(v,ny,nx,left-temp,now)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tv[ny][nx]=temp;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool cal(vector<vector<int> > &v,int now){\n\tif(now==rt.size()){\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\tif(v[i][j]!=0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tint y=rt[now].first;\n\tint x=rt[now].second;\n\tint temp=v[y][x];\n\tv[y][x]=0;\n\tif(f(v,y,x,-temp,now))\n\t\treturn true;\n\tv[y][x]=temp;\n\treturn false;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tvector<vector<int> > v(n,vector<int>(n));\n\t\trt.clear();\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>v[i][j];\n\t\t\tif(v[i][j]<0)\n\t\t\trt.pb(P(i,j));\n\t\t}\n\t\tif(cal(v,0))\n\t\tcout<<\"YES\"<<endl;\n\t\t\telse\n\t\tcout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint n;\nint b[10][10];\nint id[10][10];\nvector<vector<ull> > v;\nint nid;\n\nconst int dx[4] = { 1,-1, 0, 0};\nconst int dy[4] = { 0, 0, 1,-1};\n\n#define HASH(x,y) (((ull)1) << (((x)-1) + ((y)-1)*8)) \n\nvoid check(int x, int y, int sum, ull f){\n  if(sum == 0){\n    v[nid].push_back(f);\n    return;\n  }\n  REP(i,4){\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    int s  = sum - b[yy][xx];\n    if(s < 0 || b[yy][xx] < 0) continue;\n    ull h  = HASH(xx,yy);\n    if((h & f) != 0) continue;\n    check(xx,yy,s,(f|h));\n  }\n}\n\nbool ans(int idx, ull f){\n  if(idx == v.size()) return true;\n  REP(i,v[idx].size()){\n    if((f & v[idx][i]) == 0 && ans(idx+1, (f|v[idx][i])))\n       return true;\n  }\n  return false;\n}\n\nint main(){\n  REP(i,10) REP(j,10) b[i][j] = -1;\n  while(scanf(\"%d\",&n),n){\n    int idx = 0;\n    int sum = 0;\n\n    REP(i,n) REP(j,n){\n      int tmp;\n      scanf(\"%d\",&tmp); \n      b[i+1][j+1] = tmp;\n      if(tmp < 0)\n\tid[i+1][j+1] = idx++;\n      sum += tmp;\n    }\n\n    if(sum != 0){\n      puts(\"NO\");\n      continue;\n    }\n\n    v = vector<vector<ull> >(idx);\n\n    for(int y=1; y<=n; y++){\n      for(int x=1; x<=n; x++){\n\tif(b[y][x] < 0){\n\t  nid = id[y][x];\n\t  check(x,y,-b[y][x],HASH(x,y));\n\t}\n      }\n    }\n\n    puts(ans(0,0)?\"YES\":\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Rep(i,n) for(int i = 0; i < n; i++)\n\nbool dfs(int, int);\nbool dfs2( int, int, const int, const int, int);\n\nint n, number[8][8];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\n\nbool dfs2(int x, int y, const int basex, const int basey, int sub){\n\n\n  if(sub < 0) return false;\n  if(sub == 0) return dfs( basex + 1, basey);\n\n  Rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= n || nx < 0 || nx >= n || number[ny][nx] <= 0) continue;\n    int next = number[ny][nx];\n    number[ny][nx] = 0;\n    if(dfs2( nx, ny, basex, basey, sub - next)) return true;\n    number[ny][nx] = next;\n  }\n  return false;\n}\n\nbool dfs(int x, int y){\n\n  if(y == n){\n    Rep(i,n) Rep(j,n) if(number[i][j] != 0) return false;\n    return true;\n  }\n  if(x == n) return dfs( 0, y + 1);\n  if(number[y][x] >= 0) return dfs( x + 1, y);\n  else{\n    int prev = number[y][x];\n    number[y][x] = 0;\n    if(dfs2( x, y, x, y, -prev)) return true;\n    number[y][x] = prev;\n  }\n  return false;\n}\n\nint main(){\n  while(cin >> n, n){\n\n    int ret = 0;\n    \n    Rep(i,n){\n      Rep(j,n){\n        cin >> number[i][j];\n        ret += number[i][j];\n      }\n    }\n    if(ret == 0 && dfs(0,0)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef unsigned long long ll;\n\nvector<vector<ll> > lines;\nint n;\nint field[9][9];\n\nvector<ll> tmp;\n\nconst int dy[]={0,0,-1,1};\nconst int dx[]={1,-1,0,0};\n\nbool ok=false;\n\nll fin;\n\n\nvoid dfs(ll s,int idx){\n\tif(ok){\n\t\treturn;\n\t}\n\tif(idx==lines.size()){\n\t\tif(fin==s)\n\t\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < lines[idx].size(); i++){\n\t\tif((s&lines[idx][i])==0){\n\t\t\tdfs(s|lines[idx][i],idx+1);\n\t\t}\n\t}\n}\n\nvoid lineSearch(ll s,int curSum,int ret,int x,int y){\n\tif(curSum==ret){\n\t\ttmp.push_back(s);\n\t}\n\tfor(int i= 0; i < 4; i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx>=0&&ny>=0&&nx<n&&ny<n&&field[ny][nx]>=1&&(curSum+field[ny][nx]<=ret)){\n\t\t\tif(!((s>>(ny*n+nx))&(1ull))){\n\t\t\t\tll ns=s|(((1ull)<<(ny*n+nx)));\n\t\t\t\tlineSearch(ns,curSum+field[ny][nx],ret,nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(cin>>n&&n!=0){\n\t\tfin=0;\n\t\tfor(int i = 0; i < n*n; i++){\n\t\t\tfin|=(1ull<<i);\n\t\t}\n\n\t\tok=false;\n\t\tlines.clear();\n\t\tvector<pair<int,pair<int,int> > > vpii;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]<0){\n\t\t\t\t\tvpii.push_back(make_pair(field[i][j],make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < vpii.size(); i++){\n\t\t\ttmp.clear();\n\t\t\tif(i==5){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\n\t\t\tlineSearch(((1ull)<<(vpii[i].second.first*n+vpii[i].second.second)),0,-vpii[i].first,vpii[i].second.second,vpii[i].second.first);\n\t\t\tlines.push_back(tmp);\n\t\t}\n\t\tdfs(0ull,0);\n\t\tif(ok)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795\n#endif\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\n\nbool ans;\nint n;\nbool vis[8][8];\nint in[8][8];\n\nvoid dfs(int rest,int x,int y,int visnum){\n  if(ans)return;\n  \n  if(visnum==0 && rest==0){\n    ans=true;\n    return;\n  }\n  \n  if(rest==0){\n    rep(i,n)rep(j,n){\n      if(vis[i][j])continue;\n      if(in[i][j]<0){\n\tvis[i][j]=true;\n\tdfs(-in[i][j],i,j,visnum-1);\n\tvis[i][j]=false;\n\treturn;\n      }\n    }\n  }else{\n    rep(i,4){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx<0 || n<=nx || ny<0 || n<=ny ||\n\t vis[nx][ny] || in[nx][ny]<0 || in[nx][ny]>rest)continue;\n      vis[nx][ny]=true;\n      dfs(rest-in[nx][ny],nx,ny,visnum-1);\n      vis[nx][ny]=false;\n    }\n  }\n}\n\nmain(){\n  while(cin>>n,n){\n    ans=false;\n    memset(vis,0,sizeof(vis));\n    rep(i,n)rep(j,n)cin>>in[i][j];\n\n    dfs(0,0,0,n*n);\n    if(ans)cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nint t[10][10],pass[10][10];\nint dx[] = {-1,1,0,0};\nint dy[] = {0,0,1,-1};\nvector<P> v;\n\nbool solve(int x,int y,int rem,int sum,int vi){\n\tif(sum == 0){\n\t\tif(rem == 0){\n\t\t\tif(v.size() - 1 == vi){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\telse if(vi < v.size()-1){\n\t\t\tint nvi = vi + 1;\n\n\t\t\tpass[y][x] = vi+1;\n\t\t\tif(solve(v[nvi].second,v[nvi].first,rem-1,-t[v[nvi].first][v[nvi].second],nvi)) return true;\n\t\t\tpass[y][x] = 0;\n\t\t}\n\t}\n\tif(rem <= 0 || sum <= 0 || vi >= v.size()) return false;\n\n\tif(t[y][x]>0) pass[y][x] = vi+1;\n\tfor(int i=0;i<4;i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif(0<=nx && nx<n && 0<=ny && ny<n && !pass[ny][nx]){\n\t\t\tif(solve(nx,ny,rem-1,sum-t[ny][nx],vi)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tif(t[y][x]>0) pass[y][x] = 0;\n\n\treturn false;\n}\n\nint main(void){\n\twhile(cin>>n,n){\n\t\tmemset(pass,0,sizeof(pass));\n\t\tv.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin>>t[i][j];\n\t\t\t\tif(t[i][j] < 0){\n\t\t\t\t\tv.push_back(P(i,j));\n\t\t\t\t\tpass[i][j] = v.size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<(solve(v[0].second,v[0].first,n*n-1,-t[v[0].first][v[0].second],0) ? \"YES\" : \"NO\")<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nint n;\nint b[10][10];\nint id[10][10];\nvector<vector<ull> > v;\nint nid;\n\nconst int dx[4] = { 1,-1, 0, 0};\nconst int dy[4] = { 0, 0, 1,-1};\n\ninline ull hash(int x, int y){\n  return (((ull)1) << ((x-1) + (y-1)*8));\n}\n\nvoid check(int x, int y, int sum, ull f){\n  if(sum == 0){\n    v[nid].push_back(f);\n    return;\n  }\n  REP(i,4){\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    int s  = sum - b[yy][xx];\n    if(s < 0 || b[yy][xx] < 0) continue;\n    ull h  = hash(xx,yy);\n    if((h & f) != 0) continue;\n    check(xx,yy,s,(f|h));\n  }\n}\n\nbool ans(int idx, ull f){\n  if(idx == v.size()) return true;\n  REP(i,v[idx].size()){\n    if((f & v[idx][i]) == 0 && ans(idx+1, (f | v[idx][i])))\n       return true;\n  }\n  return false;\n}\n\nint main(){\n  REP(i,10) REP(j,10) b[i][j] = -1;\n  while(scanf(\"%d\",&n), n){\n    int idx = 0;\n    int sum = 0;\n\n    REP(i,n) REP(j,n){\n      int tmp;\n      scanf(\"%d\",&tmp); \n      b[i+1][j+1] = tmp;\n      if(tmp < 0)\n\tid[i+1][j+1] = idx++;\n      sum += tmp;\n    }\n\n    if(sum != 0){\n      puts(\"NO\");\n      continue;\n    }\n\n    v.clear();\n    v = vector<vector<ull> >(idx);\n\n    for(int y=1; y<=n; y++){\n      for(int x=1; x<=n; x++){\n\tif(b[y][x] < 0){\n\t  nid = id[y][x];\n\t  check(x,y,-b[y][x],hash(x,y));\n\t}\n      }\n    }\n\n    puts(ans(0,0)?\"YES\":\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint masu[10][10];\nvector< pair<int,int> > kitens;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\n\nint done[10][10];\nint n;\n\nint search(int x,int y,int p,int cv){\n\tif( cv < 0 ) return 0;\n\telse if( cv == 0 ){\n\t\tp++;\n\t\tif( p == kitens.size() ){\n\t\t\treturn 1;\n\t\t}\n\t\tcv = -masu[kitens[p].first][kitens[p].second];\n\t\ty = kitens[p].first;\n\t\tx = kitens[p].second;\n\t}else{\n\t\tif( x < 0 || y < 0 || y >= n || x >= n || done[y][x] || masu[y][x] < 0 )\n\t\t\treturn 0;\n\t\tcv -= masu[y][x];\n\t}\n\tif( cv < 0 ) return 0;\n\tdone[y][x] = true;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( search(x+dx[i],y+dy[i],p,cv) ) return 1;\n\t}\n\tdone[y][x] = false;\n\treturn 0;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tkitens.clear();\n\t\tint checksum = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tdone[i][j] = 0;\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif( masu[i][j] < 0 ){\n\t\t\t\t\tkitens.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t\tchecksum += masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( checksum != 0 || !search(-1,-1,-1,0) )\n\t\t\tcout << \"NO\" << endl;\n\t\telse\n\t\t\tcout << \"YES\" << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint n;\nint b[10][10];\nint id[10][10];\nvector<vector<ull> > v;\nint nid;\n\nconst int dx[4] = { 1,-1, 0, 0};\nconst int dy[4] = { 0, 0, 1,-1};\n\ninline ull HASH(int x, int y){\n  while((((x)-1) + ((y)-1)*8) >= 64);\n  return (((ull)1) << (((x)-1) + ((y)-1)*8));\n}\n\nvoid check(int x, int y, int sum, ull f){\n  if(sum == 0){\n    v[nid].push_back(f);\n    return;\n  }\n  REP(i,4){\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    int s  = sum - b[yy][xx];\n    if(s < 0 || b[yy][xx] < 0) continue;\n    ull h  = HASH(xx,yy);\n    if((h & f) != 0) continue;\n    check(xx,yy,s,(f|h));\n  }\n}\n\nbool ans(int idx, ull f){\n  if(idx == v.size()) return true;\n  REP(i,v[idx].size()){\n    if((f & v[idx][i]) == 0 && ans(idx+1, (f|v[idx][i])))\n       return true;\n  }\n  return false;\n}\n\nint main(){\n  REP(i,10) REP(j,10) b[i][j] = -1;\n  while(scanf(\"%d\",&n),n){\n    int idx = 0;\n    int sum = 0;\n\n    REP(i,n) REP(j,n){\n      int tmp;\n      scanf(\"%d\",&tmp); \n      b[i+1][j+1] = tmp;\n      if(tmp < 0)\n\tid[i+1][j+1] = idx++;\n      sum += tmp;\n    }\n\n    if(sum != 0){\n      puts(\"NO\");\n      continue;\n    }\n\n    v = vector<vector<ull> >(idx);\n\n    for(int y=1; y<=n; y++){\n      for(int x=1; x<=n; x++){\n\tif(b[y][x] < 0){\n\t  nid = id[y][x];\n\t  check(x,y,-b[y][x],HASH(x,y));\n\t}\n      }\n    }\n\n    puts(ans(0,0)?\"YES\":\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<vector>\nstruct P{int x,y;P(int x,int y):x(x),y(y){}};\n\nint num[10][10];\nbool visited[10][10];\nstd::vector<P>v;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nbool BackTrack(int x,int y,int index,int rest)\n{\n\tif(rest<0) return false;\n\tif(rest==0)\n\t{\n\t\tif(index==v.size()-1)\n\t\t\treturn true;\n\t\t++index;\n\t\tx=v[index].x;\n\t\ty=v[index].y;\n\t\trest = -num[y][x];\n\t\treturn BackTrack(x,y,index,rest);\n\t}\n\tfor(int i=0; i<4; ++i)\n\t{\n\t\tint nx = x+dx[i];\n\t\tint ny = y+dy[i];\n\t\tif(visited[ny][nx])continue;\n\t\tvisited[ny][nx] = true;\n\n\t\tif(BackTrack(nx,ny,index,rest-num[ny][nx]))\n\t\t\treturn true;\n\n\t\tvisited[ny][nx] = false;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tint n,i,j,t;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tv.clear();\n\t\tmemset(visited,1,sizeof(visited));\n\n\t\tint check = 0;\n\t\tfor(i=1; i<=n; ++i)\n\t\t{\n\t\t\tfor(j=1; j<=n; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tnum[i][j]=t;\n\t\t\t\tif(t<0)\n\t\t\t\t{\n\t\t\t\t\tv.push_back(P(j,i));\n\t\t\t\t\tvisited[i][j]=true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvisited[i][j]=false;\n\t\t\t\t}\n\t\t\t\tcheck += t;\n\t\t\t}\n\t\t}\n\n\t\tint x=v[0].x;\n\t\tint y=v[0].y;\n\t\tputs(check==0&&BackTrack(x,y,0,-num[y][x]) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N,table[8][8];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nbool FLG,check[8][8];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= N-1 && col >= 0 && col <= N-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid dfs(int sum,int row,int col,int rest){\n\n\tif(FLG) return;\n\n\tif(sum == 0 && rest == 0){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tif(sum == 0){\n\n\t\tfor(int row = 0; row < N; row++){\n\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\tif(check[row][col])continue;\n\t\t\t\tif(table[row][col] < 0){\n\t\t\t\t\tcheck[row][col] = true;\n\t\t\t\t\tdfs(abs(table[row][col]),row,col,rest-1);\n\t\t\t\t\tcheck[row][col] = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t  }else{\n\n\t\t  for(int i = 0; i < 4; i++){\n\t\t\t  int adj_row = row+diff_row[i];\n\t\t\t  int adj_col = col+diff_col[i];\n\n\t\t\t  if(rangeCheck(adj_row,adj_col) == false || check[adj_row][adj_col] == true)continue;\n\n\t\t\t  check[adj_row][adj_col] = true;\n\t\t\t  dfs(sum-table[adj_row][adj_col],adj_row,adj_col,rest-1);\n\t\t\t  check[adj_row][adj_col] = false;\n\t\t  }\n\t  }\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++){\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t\tcheck[row][col] = false;\n\t\t}\n\t}\n\n\tFLG = false;\n\n\tdfs(0,0,0,N*N);\n\n\tif(FLG){\n\t\tprintf(\"YES\\n\");\n\t}else{\n\t\tprintf(\"NO\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 22:52~\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nbool solve(const vvi& a,const vector<pii>& ss,int i,int j,int si,int rest,vvi& vis)\n{\n\tint n=a.size();\n\tif(i<0 || n<=i || j<0 || n<=j || vis[i][j]) return false;\n\tif(a[i][j]<0){\n\t\tif(ss[si]!=mp(i,j)) return false;\n\t\tvis[i][j]=-1-si;\n\t\trep(k,4){\n\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\tif(solve(a,ss,ni,nj,si,rest,vis)) return true;\n\t\t}\n\t\tvis[i][j]=0;\n\t}\n\telse{\n\t\tif(rest<a[i][j]) return false;\n\t\tvis[i][j]=-1-si;\n\t\trest-=a[i][j];\n\t\tif(rest==0){\n\t\t\tsi++;\n\t\t\tif(si==ss.size()) return true;\n\t\t\tint ni=ss[si].first,nj=ss[si].second;\n\t\t\tif(solve(a,ss,ni,nj,si,-a[ni][nj],vis)) return true;\n\t\t}\n\t\telse{\n\t\t\trep(k,4){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\tif(solve(a,ss,ni,nj,si,rest,vis)) return true;\n\t\t\t}\n\t\t}\n\t\tvis[i][j]=0;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvvi a(n,vi(n));\n\t\trep(i,n) rep(j,n) cin>>a[i][j];\n\t\t\n\t\tint pos=0,neg=0;\n\t\trep(i,n) rep(j,n) (a[i][j]>0?pos:neg)+=a[i][j];\n\t\tif(pos+neg){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<pii> ss;\n\t\trep(i,n) rep(j,n) if(a[i][j]<0) ss.emplace_back(i,j);\n\t\tvvi vis(n,vi(n));\n\t\tint i=ss[0].first,j=ss[0].second;\n\t\tbool res=solve(a,ss,i,j,0,-a[i][j],vis);\n\t\tcout<<(res?\"YES\":\"NO\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nconst int dy[] = { 0, 1, -1, 0}, dx[] = { 1, 0, 0, -1};\nint n, mas[8][8];\nbool used[8][8];\nbool isover( int& y, int& x){\n  return x < 0 || y < 0 || x >= n || y >= n;\n}\nbool dfs( int hoge, int y, int x, int sum){\n  if(hoge == 0 && sum == n * n) return true;\n  bool ret = false;\n  if(hoge < 0){\n    for(int i = 0 ; i < 4 ; i++ ){\n      int ny = y + dy[i], nx = x + dx[i];\n      if(!isover(ny,nx) && mas[ny][nx] > 0 && !used[ny][nx]){\n        used[ny][nx] = true;\n        ret += dfs( hoge + mas[ny][nx], ny, nx, sum + 1);\n        used[ny][nx] = false;\n      }\n    }\n  }else if(!hoge){\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = 0 ; j < n ; j++ ){\n        if(mas[i][j] < 0 && !used[i][j]){\n          used[i][j] = true;\n          ret += dfs( mas[i][j], i, j, sum + 1);\n          used[i][j] = false;\n          return ret;\n        }\n      }\n    }\n  }\n  return ret;\n}\nint main(){\n  while(cin >> n , n){\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = 0 ; j < n ; j++ ){\n        cin >> mas[i][j];\n      }\n    }\n    cout << (dfs(0,0,0,0) ? \"YES\" : \"NO\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[] = {+1,-1, 0, 0};\nint dy[] = { 0, 0,+1,-1};\nint tb[10][10];\nint tf[10][10];\n\nint n,t,sum;\nvector<int> sx,sy;\n\nbool dfs(int x, int y, int s, int c, int m)\n{\n\tint tx,ty,ts,tc,tm;\n\tts = s+1;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\ttc = c;\n\t\ttx = x+dx[i];\n\t\tty = y+dy[i];\n\t\ttm = m+tb[tx][ty];\n\n\t\tif(tf[tx][ty]==0) continue;\n\t\tif(tb[tx][ty]<=0) continue;\n\n\t\tif(tm>0) continue;\n\t\tif(tm==0)\n\t\t{\n\t\t\ttc++;\n\n\t\t\tif(tc==sx.size())\n\t\t\t{\n\t\t\t\tif(ts==n*n)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tts++;\n\t\t\ttx = sx[tc];\n\t\t\tty = sy[tc];\n\t\t\ttm = tb[tx][ty];\n\t\t}\n\n\t\ttf[x][y]=0;\n\t\tif(dfs(tx,ty,ts,tc,tm)) return true;\n\t\ttf[x][y]=1;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tsum = 0;\n\t\tsx.clear();\n\t\tsy.clear();\n\n\t\tfor(int i=0; i<100; i++)\n\t\t{\n\t\t\ttb[i/10][i%10] = 0;\n\t\t\ttf[i/10][i%10] = 1;\n\t\t}\n\n\t\tfor(int i=0; i<n*n; i++)\n\t\t{\n\t\t\tcin >> t; sum+=t;\n\t\t\ttb[(i/n)+1][(i%n)+1] = t;\n\n\t\t\tif(t<0)\n\t\t\t{\n\t\t\t\tsx.push_back((i/n)+1);\n\t\t\t\tsy.push_back((i%n)+1);\n\t\t\t}\n\t\t}\n\n\t\t// »è»Ì1\n\t\tif(sum!=0) { cout << \"NO\\n\"; continue; }\n\n\t\tif(dfs(sx[0],sy[0],1,0,tb[sx[0]][sy[0]]))\n\t\t{\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nint n;\nint a[10][10];\nint ta[10][10];\n\nint kiten_cnt;\nint kiten_y[70];\nint kiten_x[70];\n\nint dy[4] = {0, 1, 0, -1};\nint dx[4] = {-1, 0, 1, 0};\n\nbool ans;\n\n//ta??????????????????????????\\??????????????????\n\nvoid dfs(int kiten_num, int syohi, int y, int x) {\n    if (kiten_num == kiten_cnt) {\n        bool exist_not_zero = false;\n        rep(i,n) {\n            rep(j,n) {\n                if (ta[i][j] != 0) exist_not_zero = true;\n            }\n        }\n        if (exist_not_zero) {\n            return;\n        } else {\n            ans = true;\n            return;\n        }\n    }\n\n    if (ta[y][x] > 0) {\n        syohi += ta[y][x];\n        ta[y][x] = 0;\n    } else {\n        syohi = 0;\n        ta[y][x] = 0;\n    }\n\n    if (syohi == abs(a[kiten_y[kiten_num]][kiten_x[kiten_num]])) {\n        kiten_num++;\n        dfs(kiten_num, 0, kiten_y[kiten_num], kiten_x[kiten_num]);\n    } else {\n        rep(i,4) {\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n\n            if (ny < 0 || n <= ny || nx < 0 || n <= nx) continue;\n            if (ta[ny][nx] == 0 || ta[ny][nx] < 0) continue;\n            if (syohi + ta[ny][nx] > abs(a[kiten_y[kiten_num]][kiten_x[kiten_num]])) continue;\n\n            dfs(kiten_num, syohi, ny, nx);\n        }\n    }\n\n    ta[y][x] = a[y][x];\n}\n\nint main()\n{\n#ifdef LOCAL\n    ifstream in(\"input.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n\n    while (true) {\n        cin >> n;\n        if (n == 0) break;\n\n        kiten_cnt = 0;\n\n        rep(i,n) {\n            rep(j,n) {\n                cin >> a[i][j];\n                ta[i][j] = a[i][j];\n                if (a[i][j] < 0) {\n                    kiten_y[kiten_cnt] = i;\n                    kiten_x[kiten_cnt] = j;\n                    kiten_cnt++;\n                }\n            }\n        }\n\n        ans = false;\n        dfs(0, 0, kiten_y[0], kiten_x[0]);\n\n        if (ans) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint n;\nint pz[8][8];\nbool chk[8][8];\nint cnt;\null ans;\nvector<ull> v[64];\n\n#define ENC(x,y) (((ull)1) << ((y)*n + (x)))\n\nvoid check(int x, int y, int sum, ull f){\n  chk[y][x] = true;\n\n  if(sum == 0){\n    v[cnt].push_back(f);\n  }else if(sum < 0){\n    REP(i,4){\n      int xx = x + _dx[i];\n      int yy = y + _dy[i];\n      if(ISIN(xx,yy,n,n) && !chk[yy][xx] && pz[yy][xx] >= 0)\n        check(xx,yy,sum+pz[yy][xx],(f|ENC(xx,yy)));\n    }\n  }\n\n  chk[y][x] = false;\n}\n\nbool solve(int now, ull f){\n  if(now == cnt)\n    return f == ans;\n\n  REP(i,v[now].size()){\n    if((f & v[now][i]) == 0){\n      if(solve(now+1, (f|v[now][i])))\n        return true;\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d\",&n),n){\n    int sum = 0;\n    cnt = 0;\n\n    REP(i,n) REP(j,n) scanf(\"%d\",&pz[i][j]);\n    REP(i,n) REP(j,n){\n      int t = pz[i][j];\n      sum += t;\n      if(t < 0){\n        v[cnt].clear();\n\n        check(j,i,t,ENC(j,i));\n        cnt++;\n      }\n    }\n\n    if(sum != 0){\n      puts(\"NO\");\n      continue;\n    }\n\n    ans = 0;\n    REP(i,n*n){\n      ans <<= 1;\n      ans |= 1;\n    }\n\n    puts(solve(0,0)?\"YES\":\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint b[10][10];\nint n;\nint m;\nint row[110];\nint col[110];\nint sz[110];\npair<int,pair<int,int> > p[110];\nint v[10][10];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint dfs(int a,int s,int c,int d){\n\tif(a==m)return 1;\n\tif(s==sz[a])return dfs(a+1,0,row[a+1],col[a+1]);\n\tfor(int i=0;i<4;i++){\n\t\tif(c+dx[i]<0||c+dx[i]>=n||d+dy[i]<0||d+dy[i]>=n||v[c+dx[i]][d+dy[i]])continue;\n\t\tif(s+b[c+dx[i]][d+dy[i]]>sz[a])continue;\n\t\tv[c+dx[i]][d+dy[i]]=1;\n\t\tif(dfs(a,s+b[c+dx[i]][d+dy[i]],c+dx[i],d+dy[i]))return 1;\n\t\tv[c+dx[i]][d+dy[i]]=0;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)v[i][j]=0;\n\t\tn=a;\n\t\tm=0;\n\t\tint SUM=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tSUM+=b[i][j];\n\t\t\tif(b[i][j]<0){\n\t\t\t\tp[m++]=make_pair(-b[i][j],make_pair(i,j));\n\t\t\t\tv[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tif(SUM){\n\t\t\tprintf(\"NO\\n\");continue;\n\t\t}\n\t\tstd::sort(p,p+m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\trow[i]=p[i].second.first;\n\t\t\tcol[i]=p[i].second.second;\n\t\t\tsz[i]=p[i].first;\n\t\t}\n\t\tint ret=dfs(0,0,row[0],col[0]);\n\t\tif(ret)printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef unsigned long long ll;\n\nvector<vector<ll> > lines;\nint n;\nint field[9][9];\n\nvector<ll> tmp;\n\nconst int dy[]={0,0,-1,1};\nconst int dx[]={1,-1,0,0};\n\nbool ok=false;\n\nll fin;\n\n\nvoid dfs(ll s,int idx){\n\tif(ok){\n\t\treturn;\n\t}\n\tif(idx==lines.size()){\n\t\tif(fin==s)\n\t\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < lines[idx].size(); i++){\n\t\tif((s&lines[idx][i])==0){\n\t\t\tdfs(s|lines[idx][i],idx+1);\n\t\t}\n\t}\n}\n\nvoid lineSearch(ll s,int curSum,int ret,int x,int y){\n\tif(curSum==ret){\n\t\ttmp.push_back(s);\n\t}\n\tfor(int i= 0; i < 4; i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx>=0&&ny>=0&&nx<n&&ny<n&&field[ny][nx]>=1&&(curSum+field[ny][nx]<=ret)){\n\t\t\tif(!((s>>(ny*n+nx))&(1ull))){\n\t\t\t\tll ns=s|(((1ull)<<(ny*n+nx)));\n\t\t\t\tlineSearch(ns,curSum+field[ny][nx],ret,nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(cin>>n&&n!=0){\n\t\tfin=0;\n\t\tfor(int i = 0; i < n*n; i++){\n\t\t\tfin|=(1ull<<i);\n\t\t}\n\n\t\tok=false;\n\t\tlines.clear();\n\t\tvector<pair<int,pair<int,int> > > vpii;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]<0){\n\t\t\t\t\tvpii.push_back(make_pair(field[i][j],make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < vpii.size(); i++){\n\t\t\ttmp.clear();\n\t\t\tlineSearch(((1ull)<<(vpii[i].second.first*n+vpii[i].second.second)),0,-vpii[i].first,vpii[i].second.second,vpii[i].second.first);\n\t\t\tlines.push_back(tmp);\n\t\t}\n\t\tdfs(0ull,0);\n\t\tif(ok)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\nusing namespace std;\n\n\nint d[8][8];\n\nint isok1(int n){\n\tint mins = 0 , pls = 0;\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tif(d[i][j] < 0 ) mins += -d[i][j];\n\t\t\telse pls += d[i][j];\n\treturn mins <= pls;\n}\n\n\nint n,I,N;\nset<long long> bit[25];\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid dfs(int x,int y,long long u,int sum){\n\tif( sum == 0 ){\n\t\tbit[I].insert(u);\n\t\treturn;\n\t}\n\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i] , ty = y + dy[i];\n\t\tif( tx >= 0 && tx < n && ty < n && ty >= 0 && !(u>>(ty*n+tx)&1) && sum >= d[ty][tx] && d[ty][tx] > 0 ) {\n\t\t\tdfs(tx,ty,u|(1ll<<(ty*n+tx)),sum-d[ty][tx]);\n\t\t}\n\t}\n}\n//set<long long> used[30];\nbool exactCover(int n,long long u){\n\tif(n == -1) return u == (1ll<<(N*N))-1;\n\t/*if(!used[n].count(u)) used[n].insert(u);\n\telse return false;*/\n\t/*for(int i = 0 ; i < n ; i++){\n\t\tbool f = 0;\n\t\tfor(set<long long>::iterator it = bit[i].begin() ; it != bit[i].end() ; ++it) if( !(u&(*it)) ) f = 1;\n\t\tif(!f){return false;}\n\t}*/\n\t\n\tfor(set<long long>::iterator it = bit[n].begin() ; it != bit[n].end() ; ++it){\n\t\tif( !(u&(*it)) && exactCover(n-1,u|(*it)) ) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tN = n;\n\t\tvector<int> sx,sy;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\td[i][j] = a;\n\t\t\t\tif(a < 0) sx.push_back(j);\n\t\t\t\tif(a < 0) sy.push_back(i);\n\t\t\t}\n\t\t}\n\t\t//for(int i = 0 ; i < 30 ; i++) used[i].clear();\n\t\tif( isok1(n) ){\n\t\t\tfor(int i = 0 ; i < 25 ; i++) bit[i].clear();\n\t\t\tfor(int i = 0 ; i < sx.size() ; i++){\n\t\t\t\tI = i;\n\t\t\t\tdfs(sx[i],sy[i],1ll<<(sy[i]*n+sx[i]),-d[sy[i]][sx[i]]);\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < sx.size() ; i++)\n\t\t\t\tfor(int j = 0 ; j < sx.size()-1 ; j++){\n\t\t\t\t\tif( bit[j].size() > bit[j+1].size() ){\n\t\t\t\t\t\tswap(bit[j],bit[j+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcout << (exactCover(sx.size()-1,0)?\"YES\":\"NO\") << endl;\t\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n\nint masu[10][10];\nvector< pair<int,int> > kitens;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\n\nint done[10][10];\nint test[10][10];\nint n;\n\nint badSituation(int x,int y,int p){\n\tstack< pair<int,int> > S;\n\tmemcpy(test,done,sizeof(test));\n\tS.push(make_pair(y,x));\n\ttest[y][x] = true;\n\tfor(int i = p+1 ; i < kitens.size() ; i++){\n\t\tS.push(kitens[i]);\n\t\ttest[kitens[i].first][kitens[i].second] = true;\n\t}\n\t\n\twhile(S.size()){\n\t\tpair<int,int> pt = S.top(); S.pop();\n\t\t\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint tx = pt.second + dx[i];\n\t\t\tint ty = pt.first + dy[i];\n\t\t\tif( tx < 0 || ty < 0 || ty >= n || tx >= n || test[ty][tx] ) continue;\n\t\t\ttest[ty][tx] = true;\n\t\t\tS.push(make_pair(ty,tx));\n\t\t}\n\t}\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tif( !test[i][j] ) return true;\n\treturn false;\n}\nint search(int x,int y,int p,int cv){\n\tif( cv < 0 ) return 0;\n\telse if( cv == 0 ){\n\t\tp++;\n\t\tif( p == kitens.size() ){\n\t\t\treturn 1;\n\t\t}\n\t\tcv = -masu[kitens[p].first][kitens[p].second];\n\t\ty = kitens[p].first;\n\t\tx = kitens[p].second;\n\t}else{\n\t\tif( x < 0 || y < 0 || y >= n || x >= n || done[y][x] || masu[y][x] < 0 )\n\t\t\treturn 0;\n\t\tcv -= masu[y][x];\n\t}\n\tif( cv < 0 ) return 0;\n\tif( badSituation(x,y,p) ){\n\t\treturn 0;\n\t}\n\tdone[y][x] = true;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( search(x+dx[i],y+dy[i],p,cv) ) return 1;\n\t}\n\tdone[y][x] = false;\n\treturn 0;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tkitens.clear();\n\t\tint checksum = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tdone[i][j] = 0;\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif( masu[i][j] < 0 ){\n\t\t\t\t\tkitens.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t\tchecksum += masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( checksum != 0 || !search(-1,-1,-1,0) )\n\t\t\tcout << \"NO\" << endl;\n\t\telse\n\t\t\tcout << \"YES\" << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing vec = std::vector<int>;\nusing mat = std::vector<vec>;\nconstexpr int MAX_H = 8;\nconstexpr int MAX_W = 8;\n\nbool visited[MAX_H][MAX_W];\n\nbool is_reach(int N)\n{\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!visited[i][j]) return 0;\n        }\n    }\n    return 1;\n}\n\nbool dfs(int x, int y, int sum, int idx, const mat &p,\n         const std::vector<std::pair<int, int>> &start)\n{\n    int N = p.size();\n    if (sum == 0) {\n        if (idx == (int)start.size()) {            \n            return is_reach(N);\n        }\n\n        int nx = start[idx].first;\n        int ny = start[idx].second;\n        \n        visited[ny][nx] = 1;\n        bool res = dfs(nx, ny, p[ny][nx], idx + 1, p, start);\n        visited[ny][nx] = 0;\n        return res;\n    } \n\n    constexpr int dx[] = {-1, 0, 1, 0};\n    constexpr int dy[] = {0, -1, 0, 1};        \n    \n    bool res = 0;    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        \n        if (nx < 0 || nx >= N || ny < 0 || ny >= N ||\n            p[ny][nx] < 0 || sum + p[ny][nx] > 0) {\n            continue;\n        }\n        if (!visited[ny][nx]) {\n            visited[ny][nx] = 1;\n            res |= dfs(nx, ny, sum + p[ny][nx], idx, p, start);\n            visited[ny][nx] = 0;\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    while (1) {\n        int N;\n        std::cin >> N;\n        if (N == 0) {\n            break;\n        }\n        \n        mat p(N, vec(N));\n        std::vector<std::pair<int, int>> start;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                std::cin >> p[i][j];            \n                if (p[i][j] < 0) {\n                    start.emplace_back(j, i);\n                }\n            }\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        std::cout << (dfs(-1, -1, 0, 0, p, start) ? \"YES\" : \"NO\") << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint n;\n\nbool solve(int x, int y, int idx, int sum, int all, vector<vector<int> >& visited, const vector<vector<int> >&p, const vector<pair<int, int> >& s)\n{\n\n  //printf(\"%d %d %d %d %d\\n\", x, y, idx, sum, all);\n\n  if (all == n*n && idx >= s.size())\n    return true;\n\n  if (idx >= s.size())\n    return false;\n\n  if (-p[s[idx].second][s[idx].first] == sum)\n    return solve(s[idx+1].first, s[idx+1].second, idx+1, 0, all, visited, p, s);\n\n  for (int d = 0; d < 4; ++d) {\n    int xx = x + dx[d];\n    int yy = y + dy[d];\n    if (xx < 0 || n <= xx || yy < 0 || n <= yy || visited[yy][xx] ||\n\tsum+p[yy][xx] > -p[s[idx].second][s[idx].first])\n      continue;\n    visited[yy][xx] = 1;\n    if (solve(xx, yy, idx, sum+p[yy][xx], all+1, visited, p, s))\n      return true;\n    visited[yy][xx] = 0;\n  }\n\n  return false;\n}\n\nint main()\n{\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    vector<vector<int> > p(n, vector<int>(n)), visited(n, vector<int>(n, 0));\n    vector<pair<int, int> > s;\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < n; ++j) {\n\tcin >> p[i][j];\n\tif (p[i][j] < 0) {\n\t  s.push_back(make_pair(j, i));\n\t  visited[i][j] = 1;\n\t}\n      }\n    }\n\n    if (solve(s[0].first, s[0].second, 0, 0, (int)s.size(), visited, p, s))\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint DX[4] = {0, 0, 1, -1};\nint DY[4] = {1, -1, 0, 0};\nvector< vector<int> > p;\nvector< vector< vector<int> > > dfs(int y, int x, int cost)\n{\n    vector< vector< vector<int> > > result;\n    if(cost == 0) {\n        result.push_back(p);\n        return result;\n    }\n    for(int i=0; i<4; i++) {\n        int ny = y + DY[i];\n        int nx = x + DX[i];\n        if(ny < 0 || p.size() <= ny) continue;\n        if(nx < 0 || p.size() <= nx) continue;\n        if(p[ny][nx] <= 0) continue;\n        if(cost < p[ny][nx]) continue;\n        int c = p[ny][nx];\n        p[ny][nx] = 0;\n        vector< vector< vector<int> > > r = dfs(ny, nx, cost - c);\n        p[ny][nx] = c;\n        result.insert(result.end(), r.begin(), r.end());\n    }\n    return result;\n}\nint main()\n{\n    int n;\n    while(cin>>n, n) {\n        vector< vector<int> > puzzle(n, vector<int>(n));\n        for(int i=0; i<n; i++) for(int j=0; j<n; j++) cin>>puzzle[i][j];\n\n        queue< vector< vector<int> > > q;\n        q.push(puzzle);\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(puzzle[i][j] >= 0) continue;\n                vector< vector< vector<int> > > next;\n                queue< vector< vector<int> > > nq;\n                while(!q.empty()) {\n                    p = q.front();\n                    q.pop();\n                    p[i][j] = 0;\n                    next = dfs(i, j, -puzzle[i][j]);\n                    for(vector< vector< vector<int> > >::iterator i=next.begin(); i!=next.end(); i++) {\n                        nq.push(*i);\n                    }\n                }\n                q = nq;\n            }\n        }\n\n        bool ok = false;\n        while(!q.empty()) {\n            vector< vector<int> > p = q.front();\n            q.pop();\n            bool clear = true;\n            for(int i=0; i<n; i++) for(int j=0; j<n; j++) {\n                if(p[i][j] != 0) clear = false;\n            }\n            if(clear) ok = true;\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint dx[] = { 1, -1, 0, 0 };\nint dy[] = { 0, 0, 1, -1 };\nint field[8][8] = { { 0 } };\nbool used[8][8] = { { false } };\nvector<int> startX, startY;\n\nbool dfs(int n, int x, int y, int r, int k){\n\tif(r == 0){\n\t\tif(k == startX.size()){ return true; }\n\t\tx = startX[k];\n\t\ty = startY[k];\n\t\t++k;\n\t}else if(used[y][x] || field[y][x] < 0){\n\t\treturn false;\n\t}\n\tr -= field[y][x];\n\tif(r < 0){ return false; }\n\tused[y][x] = true;\n\tif(r == 0){\n\t\tif(dfs(n, 0, 0, 0, k)){ return true; }\n\t}else{\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif(x >= 0 && x < n && y >= 0 && y < n){\n\t\t\t\tif(dfs(n, nx, ny, r, k)){ return true; }\n\t\t\t}\n\t\t}\n\t}\n\tused[y][x] = false;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tsum += field[i][j];\n\t\t\t\tif(field[i][j] < 0){\n\t\t\t\t\tstartX.push_back(j);\n\t\t\t\t\tstartY.push_back(i);\n\t\t\t\t}\n\t\t\t\tused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tcout << (sum == 0 && dfs(n, 0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n\t\tstartX.clear();\n\t\tstartY.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[] = {+1,-1, 0, 0};\nint dy[] = { 0, 0,+1,-1};\nint tb[10][10];\nint tf[10][10];\n\nint n,t,sum;\nvector<int> sx,sy;\n\nbool dfs(int x, int y, int s, int c, int m)\n{\n\t//cout << x << \" \" << y << \" \" << s << \" \" << c << \" \" << m << endl;\n\n\tint tx,ty,ts,tc,tm,f;\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tf  = false;\n\t\ttc = c;\n\t\tts = s+1;\n\t\ttx = x+dx[i];\n\t\tty = y+dy[i];\n\t\ttm = m+tb[tx][ty];\n\n\t\tif(tf[tx][ty]==0) continue;\n\t\tif(tb[tx][ty]<=0) continue;\n\n\t\tif(tm>0) continue;\n\t\tif(tm==0)\n\t\t{\n\t\t\ttc++;\n\n\t\t\tif(tc==sx.size())\n\t\t\t{\n\t\t\t\tif(ts==n*n)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tts++;\n\t\t\ttx = sx[tc];\n\t\t\tty = sy[tc];\n\t\t\ttm = tb[tx][ty];\n\t\t\tf  = true;\n\t\t\ttf[x+dx[i]][y+dy[i]]=0;\n\t\t}\n\n\t\ttf[x][y]=0;\n\t\tif(dfs(tx,ty,ts,tc,tm)) return true;\n\t\ttf[x][y]=1;\n\n\t\tif(f)\n\t\t{\n\t\t\ttf[x+dx[i]][y+dy[i]]=1;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tsum = 0;\n\t\tsx.clear();\n\t\tsy.clear();\n\n\t\tfor(int i=0; i<100; i++)\n\t\t{\n\t\t\ttb[i/10][i%10] = 0;\n\t\t\ttf[i/10][i%10] = 1;\n\t\t}\n\n\t\tfor(int i=0; i<n*n; i++)\n\t\t{\n\t\t\tcin >> t; sum+=t;\n\t\t\ttb[(i/n)+1][(i%n)+1] = t;\n\n\t\t\tif(t<0)\n\t\t\t{\n\t\t\t\tsx.push_back((i/n)+1);\n\t\t\t\tsy.push_back((i%n)+1);\n\t\t\t}\n\t\t}\n\n\t\tcout << sum << endl;\n\n\t\t// »è»Ì1\n\t\tif(sum!=0) { cout << \"NO\\n\"; continue; }\n\n\t\tif(dfs(sx[0],sy[0],1,0,tb[sx[0]][sy[0]]))\n\t\t{\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nint t[10][10];\nlong long v;\nmap<long long,bool> m;\nvector<P> can;\nint dy[] = {-1,0,1,0} , dx[] = {0,1,0,-1};\n\nbool rec(int id);\n\nbool dfs(int id,int y,int x,int sum){\n  if(sum == 0)return rec(id+1);\n  if(sum>0)return false;\n\n  for(int i=0;i<4;i++){\n    int ty = y+dy[i], tx = x+dx[i];\n    if(ty<0 || tx<0 || n<=ty || n<= tx)continue;\n    if( (v>>(ty*n+tx)) & 1LL || t[ty][tx]<0)continue;\n    v |= 1LL << (ty*n+tx);\n    if(dfs(id,ty,tx,sum+t[ty][tx]))return true;\n    v -= 1LL << (ty*n+tx);\n  }\n  return false;\n}\n\nbool rec(int id){\n  if(id == can.size())return true;\n  if(m[v])return false;\n  m[v] = true;\n  int y = can[id].first, x = can[id].second;\n  v |= 1LL << y*n+x;\n  return dfs(id,y,x,t[y][x]);\n}\n\nint main(){\n  while(cin >> n,n){\n    int sum = 0; can.clear(); m.clear();\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tcin >> t[i][j];\n\tsum += t[i][j];\n\tif(t[i][j]<0)can.push_back(P(i,j));\n      }\n    v = 0LL;\n\n    cout << ( (!sum && rec(0))?\"YES\\n\":\"NO\\n\" );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint m,n;\nint a[10][10],c[10][10];\npair<int,pair<int,int> > b[64];\nint fn(int);\nint fm(int,int,int,int);\nint fn(int p){\n  int i,j;\n  if(p==m){\n    for(i=1;i<n+1;i++){\n      for(j=1;j<n+1;j++){\n\tif(a[j][i]>0&&c[j][i]==-1)\n\t  break;\n      }\n      if(j!=n+1)\n\tbreak;\n    }\n    if(i==n+1)\n      return 1;\n  }else{\n    if(fm(b[p].first,b[p].second.first-1,b[p].second.second,p))\n      return 1;\n    if(fm(b[p].first,b[p].second.first+1,b[p].second.second,p))\n      return 1;\n    if(fm(b[p].first,b[p].second.first,b[p].second.second-1,p))\n      return 1;\n    if(fm(b[p].first,b[p].second.first,b[p].second.second+1,p))\n      return 1;\n  }\n  return 0;\n}\nint fm(int w,int x,int y,int p){\n  if(a[x][y]>0&&w>=a[x][y]&&c[x][y]==-1){\n    c[x][y]=p;\n    if(w==a[x][y]){\n      if(fn(p+1))\n\treturn 1;\n    }else{\n      if(fm(w-a[x][y],x-1,y,p))\n\treturn 1;\n      if(fm(w-a[x][y],x+1,y,p))\n\treturn 1;\n      if(fm(w-a[x][y],x,y-1,p))\n\treturn 1;\n      if(fm(w-a[x][y],x,y+1,p))\n\treturn 1;\n    }\n    c[x][y]=-1;\n  }\n  return 0;\n}\nint main(){\n  int i,j;\n  while(cin>>n&&n){\n    memset(a,-1,sizeof(a));\n    m=0;\n    for(i=1;i<n+1;i++){\n      for(j=1;j<n+1;j++){\n\tcin>>a[j][i];\n\tif(a[j][i]<0){\n\t  b[m]=make_pair(-a[j][i],make_pair(j,i));\n\t  m++;\n\t}\n      }\n    }\n    sort(b,b+m);\n    memset(c,-1,sizeof(c));\n    if(fn(0))\n      cout<<\"YES\"<<endl;\n    else\n      cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,B[8][8];\nbool dfs(int y,int x,bool vis[8][8],int sum,int type){\n\tif(type==0){\n\t\tvis[y][x]=true;\n\t\tif(dfs(y,x,vis,B[y][x],1)) return true;\n\t\tvis[y][x]=false;\n\t\treturn false;\n\t}\n\telse{\n\t\tif(sum>0) return false;\n\t\tif(sum==0){\n\t\t\tint yy=-1,xx;\n\t\t\tbool end=true;\n\t\t\trep(i,n) rep(j,n) {\n\t\t\t\tif(!vis[i][j]) end=false;\n\t\t\t\tif(!vis[i][j] && B[i][j]<0){\n\t\t\t\t\tif(yy==-1 || B[yy][xx]<B[i][j]) yy=i, xx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) return true;\n\t\t\treturn dfs(yy,xx,vis,0,0);\n\t\t}\n\t\trep(k,4){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && !vis[yy][xx] && B[yy][xx]>0){\n\t\t\t\tvis[yy][xx]=true;\n\t\t\t\tif(dfs(yy,xx,vis,sum+B[yy][xx],1)) return true;\n\t\t\t\tvis[yy][xx]=false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tint sy=-1,sx;\n\t\trep(i,n) rep(j,n) {\n\t\t\tscanf(\"%d\",B[i]+j);\n\t\t\tif(B[i][j]<0){\n\t\t\t\tif(sy==-1 || B[sy][sx]<B[i][j]) sy=i, sx=j;\n\t\t\t}\n\t\t}\n\n\t\tbool vis[8][8]={};\n\t\tputs(dfs(sy,sx,vis,0,0)?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 8\n\nint F[MAX_N][MAX_N];\nint n;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nbool finished();\nbool dfs(int, int , int);\nbool solve();\n\nbool finished() {\n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j]) {\n                //printf(\"i: %d, j: %d\\n\", i, j);\n                return false;\n            }\n    //printf(\"returning true...\\n\");\n    return true;\n}\n\nvoid debug() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%d \", F[i][j]);\n        }\n        puts(\"\");\n    }\n}\n\nbool dfs(int y, int x, int c) {\n    if (c == 0) {\n        //debug();\n        //printf(\"calling finish()\\n\");\n        if (finished()) return true;\n        return solve();\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < n && 0 <= ny && ny < n && F[ny][nx] > 0) {\n            int f = F[ny][nx];\n            F[ny][nx] = 0;\n            bool res = dfs(ny, nx, c+f);\n            F[ny][nx] = f;\n            if (res) return true;\n        }\n    }\n}\n\nbool solve() {\n    bool res = true;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (F[i][j] < 0) {\n                int f = F[i][j];\n                F[i][j] = 0;\n                if (!dfs(i, j, f)) \n                    res = false;\n                else\n                    return true;\n                F[i][j] = f;\n                if (!res) break;\n            }\n            if (!res) break;\n        }\n    }\n    if (!res) return false;\n    \n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j] != 0) \n                return false;\n    return true;\n}\n\nint main() {\n    while (scanf(\"%d\", &n), n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int p; scanf(\"%d\", &p);\n                F[i][j] = p;\n            }\n        }\n        puts(solve() ? \"YES\" : \"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <stdio.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef pair<int, int> Point;\ntypedef pair<int, Point> SP;\ntypedef vector<vector<int> > Mat;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint n;\nMat mat;\nvector<vector<bool> > used;\nvector<SP> starts(0);\n \nbool dfs(int cur, int sum, int x, int y) {\n//  cout << x << \", \"<< y << \", \" << sum << endl;\n  if (starts[cur].first == sum) {\n    //cout << \"ok \" << cur << endl;\n    cur++;\n    sum = 0;\n    if (cur >= starts.size()) {\n      return true;\n    }\n    x = starts[cur].second.second;\n    y = starts[cur].second.first;\n  }\n  else if (starts[cur].first < sum) {\n    return false;\n  }\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if (0 <= nx && nx < n && 0 <= ny && ny < n && !used[ny][nx]) {\n      used[ny][nx] = true;\n      if (dfs(cur, sum + mat[ny][nx], nx, ny)) return true;\n      used[ny][nx] = false;\n    }\n  }\n  return false;\n  \n}\nvoid solve() {\n  mat = Mat(n, vector<int>(n));\n  used = vector<vector<bool> >(n, vector<bool>(n, false));\n  starts.clear();\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      int a;\n      cin >> a;\n      sum += a;\n      if (a < 0) {\n        a *= -1;\n        used[i][j] = true;\n        starts.push_back(SP(a, Point(i, j)));\n      }\n      mat[i][j] = a;\n    }\n  }\n  bool ret = false;;\n  if (sum != 0) {\n    ret = false;\n  }\n  else if (starts.size() == 1) {\n    ret = true;\n  }\n  else {\n    sort(starts.begin(), starts.end());\n\n    ret = dfs(0, 0, starts[0].second.second, starts[0].second.first);\n  }\n  cout << (ret ? \"YES\" : \"NO\") << endl;\n  return;\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nint t[10][10];\nbool v[10][10];\nvector<P> can;\nint dy[] = {-1,0,1,0} , dx[] = {0,1,0,-1};\n\nbool rec(int id);\n\nbool dfs(int id,int y,int x,int sum){\n  if(sum == 0)return rec(id+1);\n  if(sum>0)return false;\n\n  for(int i=0;i<4;i++){\n    int ty = y+dy[i], tx = x+dx[i];\n    if(ty<0 || tx<0 || n<=ty || n<= tx)continue;\n    if(v[ty][tx])continue;\n    v[ty][tx] = true;\n    if(dfs(id,ty,tx,sum+t[ty][tx]))return true;\n    v[ty][tx] = false;\n  }\n  return false;\n}\n\nbool rec(int id){\n  if(id == can.size())return true;\n  int y = can[id].first, x = can[id].second;\n  v[y][x] = true;\n  return dfs(id,y,x,t[y][x]);\n}\n\nint main(){\n  while(cin >> n,n){\n    int sum = 0; can.clear();\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tcin >> t[i][j];\n\tsum += t[i][j];\n\tif(t[i][j]<0)can.push_back(P(i,j));\n\tv[i][j] = false;\n      }\n\n    cout << ( (!sum && rec(0))?\"YES\\n\":\"NO\\n\" );\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\n\nint masu[10][10];\nvector< pair<int,int> > kitens;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\n\nint done[10][10];\nint test[10][10];\nint n;\n\nint search(int x,int y,int p,int cv){\n\tif( cv < 0 ) return 0;\n\telse if( cv == 0 ){\n\t\tp++;\n\t\tif( p == kitens.size() ){\n\t\t\treturn 1;\n\t\t}\n\t\tcv = -masu[kitens[p].first][kitens[p].second];\n\t\ty = kitens[p].first;\n\t\tx = kitens[p].second;\n\t}else{\n\t\tif( x < 0 || y < 0 || y >= n || x >= n || done[y][x] || masu[y][x] < 0 )\n\t\t\treturn 0;\n\t\tcv -= masu[y][x];\n\t\tif( cv == 0 ){\n\t\t\tdone[y][x] = true;\n\t\t\tif( search(x,y,p,cv) ) return true;\n\t\t\tdone[y][x] = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif( cv < 0 ) return 0;\n\tdone[y][x] = true;\n\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tif( search(x+dx[i],y+dy[i],p,cv) ) return 1;\n\t}\n\tdone[y][x] = false;\n\treturn 0;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tkitens.clear();\n\t\tint checksum = 0;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tdone[i][j] = 0;\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif( masu[i][j] < 0 ){\n\t\t\t\t\tkitens.push_back(make_pair(i,j));\n\t\t\t\t}\n\t\t\t\tchecksum += masu[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( checksum != 0 || !search(-1,-1,-1,0) )\n\t\t\tcout << \"NO\" << endl;\n\t\telse\n\t\t\tcout << \"YES\" << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint ba[8][8];\nint dx[] ={0,1,0,-1};\nint dy[] ={-1,0,1,0};\ntypedef pair<int,int> pii;\nvector<pair<int, pii> > v;\nint n;\n\nbool solve(int);\n\nbool visited[8][8];\nint cnt = 0;\nbool rec(int x, int y, int sum, int k) {\n//  printf(\"x=%d,y=%d, sum=%d, k=%d\\n\",x,y,sum,k);\n  REP(i,4) {\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    if (xx<0||xx>=n||yy<0||yy>=n) continue;\n    if (visited[xx][yy] || ba[xx][yy] < 0) continue;\n\n    if (sum + ba[xx][yy] > v[k].first) continue;\n    visited[xx][yy] = 1;\n    cnt++;\n    if (sum + ba[xx][yy] == v[k].first) {\n      //        printf(\"OK %d,%d\\n\", xx,yy);\n      if(solve(k+1))\n        return 1;\n    } else  if (rec(xx,yy,sum+ba[xx][yy],k))\n      return 1;\n    visited[xx][yy] = 0;\n    cnt--;\n  }\n  return 0;\n}\n\nbool solve(int k) {\n//  cout << \"k=\"<<k <<  endl;\n  if (k==v.size()) {\n    if (cnt == n*n-v.size()) return 1;\n    else return 0;\n  }\n  pii p = v[k].second;\n  int x = p.first, y = p.second;\n//  cout << x << \" \" << y << endl;\n  if (rec(x,y,0,k))\n    return 1;\n  return 0;\n}\n\nint main() {\n  while(cin >> n,n) {\n    v.clear();\n    REP(y,n) {\n      REP(x,n) {\n        cin >> ba[x][y];\n        if (ba[x][y] < 0) {\n          v.push_back(make_pair(-ba[x][y], pii(x,y)));\n        }\n      }\n    }\n    sort(ALL(v));\n    // FOR(it, v) {\n    //   pii p = it->second;\n    //   cout << it->first << \" \" << p.first << \", \" << p.second << endl;\n    // }\n    memset(visited,0,sizeof(visited));\n    cnt = 0;\n    if (solve(0))\n      cout << \"YES\" << endl;\n    else\n      cout << \"NO\" << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\nusing namespace std;\n\n\nint d[8][8];\n\nint isok1(int n){\n\tint mins = 0 , pls = 0;\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tif(d[i][j] < 0 ) mins += -d[i][j];\n\t\t\telse pls += d[i][j];\n\treturn mins <= pls;\n}\n\n\nint n,I;\nset<unsigned long long> bit[30];\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid dfs(int x,int y,long long u,int sum){\n\tif( sum == 0 ){\n\t\tbit[I].insert(u);\n\t\treturn;\n\t}\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i] , ty = y + dy[i];\n\t\tif( tx >= 0 && tx < n && ty < n && ty >= 0 && !(u>>(ty*n+tx)&1) && sum >= d[ty][tx] && d[ty][tx] > 0 ) {\n\t\t\tdfs(tx,ty,u|(1ull<<(ty*n+tx)),sum-d[ty][tx]);\n\t\t}\n\t}\n}\nbool exactCover(int i,unsigned long long u){\n\tif(i == -1) return u == 0;\n\tfor(set<unsigned long long>::iterator it = bit[i].begin() ; it != bit[i].end() ; ++it){\n\t\tif( (u&(*it)) == (*it) && exactCover(i-1,u-(*it)) ) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tvector<int> sx,sy;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\td[i][j] = a;\n\t\t\t\tif(a < 0) sx.push_back(j);\n\t\t\t\tif(a < 0) sy.push_back(i);\n\t\t\t}\n\t\t}\n\t\tif( isok1(n) ){\n\t\t\tfor(int i = 0 ; i < 30 ; i++) bit[i].clear();\n\t\t\tfor(int i = 0 ; i < sx.size() ; i++){\n\t\t\t\tI = i;\n\t\t\t\tdfs(sx[i],sy[i],1ull<<(sy[i]*n+sx[i]),-d[sy[i]][sx[i]]);\n\t\t\t}\n\t\t\tcout << (exactCover(sx.size()-1,(1ull<<(n*n))-1)?\"YES\":\"NO\") << endl;\t\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<int> V_sum;\nvector<int> coor;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n\n  if( cur >= V ){\n    if( used == (1ULL<<(n*n))-1ULL ) return true;\n    return false;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    //if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( field[ny][nx] < 0 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) ) return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    ull initial_state = 0ULL;\n    V = 0;\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define Range(x, y, w, h) ((0<=x)&&(x<w)&&(0<=y)&&(y<h))\n\nconst int width = 8;\nconst int height = 8;\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {-1, 1, 0, 0};\n\nint map_size;\n\nint kiten_size;\nint kiten_n[30];\nint kiten_x[30];\nint kiten_y[30];\nint kiten_pnt;\n\nbool result;\n\nusing namespace std;\n\nvoid search(int map[][width], int mx, int my, int cnt) {\n\tfor(int dd=0; dd < 4 && !result; dd++) {\n\t\tint nx = mx + dx[dd];\n\t\tint ny = my + dy[dd];\n\t\tif(Range(nx, ny, map_size, map_size) && (map[ny][nx] != 0)){\n\t\t\tint tmp = map[ny][nx];\n\t\t\tif((tmp+cnt) == kiten_n[kiten_pnt]) {\n\t\t\t\tmap[ny][nx] = 0;\n\t\t\t\tif(++kiten_pnt >= kiten_size) {\n\t\t\t\t\tresult = true;\n\t\t\t\t\tmap[ny][nx] = tmp;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsearch(map, kiten_x[kiten_pnt], kiten_y[kiten_pnt], 0);\n\t\t\t\t\tkiten_pnt--;\n\t\t\t\t\tmap[ny][nx] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if((tmp+cnt) < kiten_n[kiten_pnt]){\n\t\t\t\tmap[ny][nx] = 0;\n\t\t\t\tsearch(map, nx, ny, (tmp+cnt));\n\t\t\t\tmap[ny][nx] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint n;\n\tint sum;\n\tint map[height][width];\n\tint tmp;\n\n\twhile(cin >> n, n) // input n\n\t{\n\t\tsum = kiten_size = 0;\n\t\tfor(int y=0; y < n; y++) for(int x=0; x < n; x++) {\n\t\t\tcin >> tmp; map[y][x] = tmp; // input map[y][x]\n\t\t\tsum += tmp;\n\t\t\tif(tmp < 0) { // check point\n\t\t\t\tkiten_n[kiten_size] = -tmp;\n\t\t\t\tkiten_x[kiten_size] = x;\n\t\t\t\tkiten_y[kiten_size++] = y;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tif(sum) { // not zero\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tmap_size = n; kiten_pnt = 0; result = false;\n\t\tsearch(map, kiten_x[kiten_pnt], kiten_y[kiten_pnt], 0);\n\t\tif(result)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,B[8][8];\nbool dfs(int y,int x,bool vis[8][8],int sum,int type){\n\tif(type==0){\n\t\tvis[y][x]=true;\n\t\tif(dfs(y,x,vis,B[y][x],1)) return true;\n\t\tvis[y][x]=false;\n\t\treturn false;\n\t}\n\telse{\n\t\tif(sum>0) return false;\n\t\tif(sum==0){\n\t\t\tint yy,xx;\n\t\t\tbool end=true;\n\t\t\trep(i,n) rep(j,n) {\n\t\t\t\tif(!vis[i][j]) end=false;\n\t\t\t\tif(!vis[i][j] && B[i][j]<0) yy=i, xx=j;\n\t\t\t}\n\t\t\tif(end) return true;\n\t\t\treturn dfs(yy,xx,vis,0,0);\n\t\t}\n\t\trep(k,4){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && !vis[yy][xx] && B[yy][xx]>0){\n\t\t\t\tvis[yy][xx]=true;\n\t\t\t\tif(dfs(yy,xx,vis,sum+B[yy][xx],1)) return true;\n\t\t\t\tvis[yy][xx]=false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tint sx,sy;\n\t\trep(i,n) rep(j,n) {\n\t\t\tscanf(\"%d\",B[i]+j);\n\t\t\tif(B[i][j]<0) sy=i, sx=j;\n\t\t}\n\n\t\tbool vis[8][8]={};\n\t\tputs(dfs(sx,sy,vis,0,0)?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint dx[] = { 1, -1, 0, 0 };\nint dy[] = { 0, 0, 1, -1 };\nint field[8][8] = { { 0 } };\nbool used[8][8] = { { false } };\nvector<int> startX, startY;\n\nbool dfs(int n, int x, int y, int r, int k){\n\tif(r == 0){\n\t\tif(k == startX.size()){ return true; }\n\t\tx = startX[k];\n\t\ty = startY[k];\n\t\t++k;\n\t}else if(used[y][x] || field[y][x] < 0){\n\t\treturn false;\n\t}\n\tr -= field[y][x];\n\tif(r < 0){ return false; }\n\tused[y][x] = true;\n\tfor(int i = 0; i < 4; ++i){\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif(x >= 0 && x < n && y >= 0 && y < n){\n\t\t\tif(dfs(n, nx, ny, r, k)){ return true; }\n\t\t}\n\t}\n\tused[y][x] = false;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tsum += field[i][j];\n\t\t\t\tif(field[i][j] < 0){\n\t\t\t\t\tstartX.push_back(j);\n\t\t\t\t\tstartY.push_back(i);\n\t\t\t\t}\n\t\t\t\tused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tcout << (sum == 0 && dfs(n, 0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n\t\tstartX.clear();\n\t\tstartY.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\nusing namespace std;\nstruct State { int x[8][8]; };\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nint F[8][8], n; vector<tuple<int,int,int>>vec;\nint solve(State S, int pos, int rec, int px, int py, int cnts) {\n\tif (pos == vec.size() - 1 && cnts == n*n) { return 1; }\n\tint cnt = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint cx = px + dx[i], cy = py + dy[i];\n\t\tif (cx < 0 || cy < 0 || cx >= n || cy >= n || S.x[cx][cy] == 1)continue;\n\t\tif (F[cx][cy] + rec > get<2>(vec[pos]))continue;\n\t\tState T = S; T.x[cx][cy] = 1;\n\t\tif (F[cx][cy] + rec == get<2>(vec[pos])) {\n\t\t\tcnt += solve(T, pos + 1, 0, get<0>(vec[pos + 1]), get<1>(vec[pos + 1]), cnts + 1);\n\t\t}\n\t\telse {\n\t\t\tcnt += solve(T, pos, rec + F[cx][cy], cx, cy, cnts + 1);\n\t\t}\n\t}\n\treturn cnt;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break; vec.clear();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcin >> F[i][j];\n\t\t\t\tif (F[i][j] < 0)vec.push_back(make_tuple(i, j, -F[i][j]));\n\t\t\t}\n\t\t}\n\t\tState ST; vec.push_back(make_tuple(-1, -1, -1));\n\t\tfor (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { ST.x[i][j] = 0; if (F[i][j] < 0)ST.x[i][j] = 1; } }\n\t\tint sum = solve(ST, 0, 0, get<0>(vec[0]), get<1>(vec[0]), vec.size() - 1);\n\t\tif (sum >= 1)cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Rep(i,n) for(int i = 0; i < n; i++)\n\nbool dfs(int, int);\nint dfs2( int, int, const int, const int, int);\n\nint n, number[8][8];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\n\nint dfs2(int x, int y, const int basex, const int basey, int sub){\n  if(sub < 0) return false;\n  if(sub == 0) return dfs( basex + 1, basey);\n\n  Rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= n || nx < 0 || nx >= n || number[ny][nx] == 0) continue;\n    int next = number[ny][nx];\n    number[ny][nx] = 0;\n    if(dfs2( ny, nx, basex, basey, sub - next)) return true;\n    number[ny][nx] = next;\n  }\n  return false;\n}\n\nbool dfs(int x, int y){\n\n  if(y == n){\n    Rep(i,n) Rep(j,n) if(number[i][j] != 0) return false;\n    return true;\n  }\n  if(x == n || number[y][x] == 0) return dfs( 0, y + 1);\n  if(number[y][x] > 0) return dfs( x + 1, y);\n  if(number[y][x] < 0){\n    int prev = number[y][x];\n    number[y][x] = 0;\n    if(dfs2( x, y, x, y, prev)) return true;\n    number[y][x] = prev;\n  }\n}\n\nint main(){\n  while(cin >> n, n){\n\n    int ret = 0;\n    Rep(i,n){\n      Rep(j,n){\n        cin >> number[i][j];\n        ret += number[i][j];\n      }\n    }\n    if(ret == 0 && dfs(0,0)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\nusing namespace std;\n\n\nint d[8][8];\n\nint isok1(int n){\n\tint mins = 0 , pls = 0;\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tif(d[i][j] < 0 ) mins += -d[i][j];\n\t\t\telse pls += d[i][j];\n\treturn mins <= pls;\n}\n\n\nint n,I;\nset<long long> bit[25];\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid dfs(int x,int y,long long u,int sum){\n\tif( sum == 0 ){\n\t\tbit[I].insert(u);\n\t\treturn;\n\t}\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i] , ty = y + dy[i];\n\t\tif( tx >= 0 && tx < n && ty < n && ty >= 0 && !(u>>(ty*n+tx)&1) && sum >= d[ty][tx] && d[ty][tx] > 0 ) {\n\t\t\tdfs(tx,ty,u|(1ll<<(ty*n+tx)),sum-d[ty][tx]);\n\t\t}\n\t}\n}\nbool exactCover(int n,long long u){\n\tif(n == -1) return u == 0;\n\tfor(set<long long>::iterator it = bit[n].begin() ; it != bit[n].end() ; ++it){\n\t\tif( (u&(*it)) == (*it) && exactCover(n-1,u-(*it)) ) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tvector<int> sx,sy;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\td[i][j] = a;\n\t\t\t\tif(a < 0) sx.push_back(j);\n\t\t\t\tif(a < 0) sy.push_back(i);\n\t\t\t}\n\t\t}\n\t\tif( isok1(n) ){\n\t\t\tfor(int i = 0 ; i < 25 ; i++) bit[i].clear();\n\t\t\tfor(int i = 0 ; i < sx.size() ; i++){\n\t\t\t\tI = i;\n\t\t\t\tdfs(sx[i],sy[i],1ll<<(sy[i]*n+sx[i]),-d[sy[i]][sx[i]]);\n\t\t\t}\n\t\t\tcout << (exactCover(sx.size()-1,(1ll<<(n*n))-1)?\"YES\":\"NO\") << endl;\t\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<ull> cache;\nvector<int> V_sum;\nvector<int> coor;\nset<vector<ull> > visited;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y){\n\n  if( cur >= V ){\n    if( used == (1ULL<<(n*n))-1ULL ){\n      rep(i,V)if(V_sum[i]!=0)return false;\n      return true;\n    }\n    return false;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    \n    int cost = field[ny][nx];\n    if( cost + V_sum[cur] > 0 ) continue;\n\n    int next = cur;\n    int npre = (i+2)%4;\n    ull next_used = used | (1ULL<<(nx+ny*n));\n\n    if( cost + V_sum[cur] == 0 ) {\n      next++; \n      npre = -1;\n      nx = coor[next] % n;\n      ny = coor[next] / n;\n    }\n    V_sum[cur] += cost;\n    if(dfs(next_used,next,npre,nx,ny)) return true;\n    V_sum[cur] -= cost;\n  }\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    visited.clear();\n    ull initial_state = 0ULL;\n    V = 0;\n    cache.clear();\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcache.push_back(tmp);\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef unsigned long long ll;\n\nvector<vector<ll> > lines;\nint n;\nint field[9][9];\n\nvector<ll> tmp;\n\nconst int dy[]={0,0,-1,1};\nconst int dx[]={1,-1,0,0};\n\nbool ok=false;\n\nll fin;\n\n\nvoid dfs(ll s,int idx){\n\tif(ok){\n\t\treturn;\n\t}\n\tif(idx==lines.size()){\n\t\tif(fin==s)\n\t\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < lines[idx].size(); i++){\n\t\tif((s&lines[idx][i])==0){\n\t\t\tdfs(s|lines[idx][i],idx+1);\n\t\t}\n\t}\n}\n\nvoid lineSearch(ll s,int curSum,int ret,int x,int y){\n\tif(curSum==ret){\n\t\ttmp.push_back(s);\n\t}\n\tfor(int i= 0; i < 4; i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx>=0&&ny>=0&&nx<n&&ny<n&&field[ny][nx]>=1&&(curSum+field[ny][nx]<=ret)){\n\t\t\tif(!((s>>(ny*n+nx))&(1ull))){\n\t\t\t\tll ns=s|(((1ull)<<(ny*n+nx)));\n\t\t\t\tlineSearch(ns,curSum+field[ny][nx],ret,nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(cin>>n&&n!=0){\n\t\tfin=0;\n\t\tfor(int i = 0; i < n*n; i++){\n\t\t\tfin|=(1ull<<i);\n\t\t}\n\n\t\tok=false;\n\t\tlines.clear();\n\t\tvector<pair<int,pair<int,int> > > vpii;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]<0){\n\t\t\t\t\tvpii.push_back(make_pair(field[i][j],make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < vpii.size(); i++){\n\t\t\ttmp.clear();\n\t\t\tif(i==5){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\n\t\t\tlineSearch(((1ull)<<(vpii[i].second.first*n+vpii[i].second.second)),0,-vpii[i].first,vpii[i].second.second,vpii[i].second.first);\n\t\t\tlines.push_back(tmp);\n\t\t}\n\t\tdfs(0ull,0);\n\t\tif(ok)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Rep(i,n) for(int i = 0; i < n; i++)\n\nbool dfs(int, int);\nint dfs2( int, int, const int, const int, int);\n\nint n, number[8][8];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\n\nint dfs2(int x, int y, const int basex, const int basey, int sub){\n  if(sub < 0) return false;\n  if(sub == 0) return dfs( basex, basey);\n\n  Rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= n || nx < 0 || nx >= n || number[ny][nx] <= 0) continue;\n    int next = number[ny][nx];\n    number[ny][nx] = 0;\n    if(dfs2( ny, nx, basex, basey, sub - next)) return true;\n    number[ny][nx] = next;\n  }\n  return false;\n}\n\nbool dfs(int x, int y){\n\n  if(y == n){\n    Rep(i,n) Rep(j,n) if(number[i][j] != 0) return false;\n    return true;\n  }\n  if(x == n || number[y][x] == 0) return dfs( 0, y + 1);\n  if(number[y][x] > 0) return dfs( x + 1, y);\n  if(number[y][x] < 0){\n    int prev = number[y][x];\n    number[y][x] = 0;\n    if(dfs2( x, y, x, y, prev)) return true;\n    number[y][x] = prev;\n  }\n}\n\nint main(){\n  while(cin >> n, n){\n\n    int ret = 0;\n    Rep(i,n){\n      Rep(j,n){\n        cin >> number[i][j];\n        ret += number[i][j];\n      }\n    }\n    if(ret == 0 && dfs(0,0)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint n;\nint b[10][10];\nint id[10][10];\nvector<vector<ull> > v;\nint nid;\n\nconst int dx[4] = { 1,-1, 0, 0};\nconst int dy[4] = { 0, 0, 1,-1};\n\ninline ull hash(int x, int y){\n  return (((ull)1) << ((x-1) + (y-1)*8));\n}\n\nvoid check(int x, int y, int sum, ull f){\n  if(sum == 0){\n    v[nid].push_back(f);\n    return;\n  }\n  REP(i,4){\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    int s  = sum - b[yy][xx];\n    if(s < 0 || b[yy][xx] < 0) continue;\n    ull h  = hash(xx,yy);\n    if((h & f) != 0) continue;\n    check(xx,yy,s,(f|h));\n  }\n}\n\nbool ans(int idx, ull f){\n  if(idx == v.size()) return true;\n  REP(i,v[idx].size()){\n    if((f & v[idx][i]) == 0 && ans(idx+1, (f | v[idx][i])))\n       return true;\n  }\n  return false;\n}\n\nint main(){\n  REP(i,10) REP(j,10) b[i][j] = -1;\n  while(scanf(\"%d\",&n),n){\n    int idx = 0;\n    int sum = 0;\n\n    REP(i,n) REP(j,n){\n      int tmp;\n      scanf(\"%d\",&tmp); \n      b[i+1][j+1] = tmp;\n      if(tmp < 0)\n\tid[i+1][j+1] = idx++;\n      sum += tmp;\n    }\n\n    if(sum != 0){\n      printf(\"NO\\n\");\n      continue;\n    }\n\n    v = vector<vector<ull> >(idx);\n\n    for(int y=1; y<=n; y++){\n      for(int x=1; x<=n; x++){\n\tif(b[y][x] < 0){\n\t  nid = id[y][x];\n\t  check(x,y,-b[y][x],hash(x,y));\n\t}\n      }\n    }\n\n    printf(ans(0,0)?\"YES\\n\":\"NO\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint n;\nvector<pint> pl;\nint fi[10][10];\nbool seen[10][10];\n\nbool rec(int x, int y, int ind, int sum) {\n\t//cout << x << \", \" << y << \" (\" << ind << \") : \" << sum << endl;\n\tif (sum == -fi[pl[ind].first][pl[ind].second]) {\n\t\tif (ind == pl.size()-1) return true;\n\t\telse if ( rec(pl[ind+1].first, pl[ind+1].second, ind+1, 0) ) return true;\n\t\telse return false;\n\t}\n\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n\t\tif (seen[nx][ny]) continue;\n\t\tif (sum + fi[nx][ny] >  -fi[pl[ind].first][pl[ind].second]) continue;\n\t\t\n\t\tseen[nx][ny] = true;\n\t\tif ( rec(nx, ny, ind, sum + fi[nx][ny]) ) return true;\n\t\tseen[nx][ny] = false;\n\t}\n\n\treturn false;\n}\n\nbool solve() {\n\tint sum_kiten = 0, sum_rem = 0;\n\tmemset(seen, 0, sizeof(seen));\n\n\tpl.clear();\n\tfor (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) {\n\t\tcin >> fi[i][j];\n\t\tif (fi[i][j] < 0) sum_kiten -= fi[i][j], pl.PB(pint(i,j)), seen[i][j] = true;\n\t\telse sum_rem += fi[i][j];\n\t}\n\tif (sum_rem != sum_kiten) {\n\t\treturn false;\n\t}\n\n\t//COUT(pl);\n\n\tif ( rec(pl[0].first, pl[0].second, 0, 0) ) return true;\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> n) {  \n\t\tif (n == 0) break;\n\t\tif (solve()) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\nusing namespace std;\n\n\nint d[8][8];\n\nint isok1(int n){\n\tint mins = 0 , pls = 0;\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tif(d[i][j] < 0 ) mins += -d[i][j];\n\t\t\telse pls += d[i][j];\n\treturn mins == pls;\n}\n\n\nint n,I;\nset<unsigned long long> bit[64];\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid dfs(int x,int y,long long u,int sum){\n\tif( sum == 0 ){\n\t\tbit[I].insert(u);\n\t\treturn;\n\t}\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i] , ty = y + dy[i];\n\t\tif( tx >= 0 && tx < n && ty < n && ty >= 0 && !(u>>(ty*n+tx)&1) && sum >= d[ty][tx] && d[ty][tx] > 0 ) {\n\t\t\tdfs(tx,ty,u|(1ull<<(ty*n+tx)),sum-d[ty][tx]);\n\t\t}\n\t}\n}\nbool exactCover(int i,unsigned long long u){\n\tif(i == -1) return u == 0;\n\tfor(set<unsigned long long>::iterator it = bit[i].begin() ; it != bit[i].end() ; ++it){\n\t\tif( (u&(*it)) == (*it) && exactCover(i-1,u-(*it)) ) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tvector<int> sx,sy;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\td[i][j] = a;\n\t\t\t\tif(a < 0) sx.push_back(j);\n\t\t\t\tif(a < 0) sy.push_back(i);\n\t\t\t}\n\t\t}\n\t\tif( isok1(n) ){\n\t\t\tfor(int i = 0 ; i < 64 ; i++) bit[i].clear();\n\t\t\tfor(int i = 0 ; i < sx.size() ; i++){\n\t\t\t\tI = i;\n\t\t\t\tdfs(sx[i],sy[i],1ull<<(sy[i]*n+sx[i]),-d[sy[i]][sx[i]]);\n\t\t\t}\n\t\t\tcout << (exactCover(sx.size()-1,(1ull<<(n*n))-1)?\"YES\":\"NO\") << endl;\t\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nint n;\n#define MAX_N 8\nint F[MAX_N][MAX_N];\n\nconst int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nvoid debug();\n\nbool finished() {\n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j] != 0) \n                return false;\n    return true;\n}\n\nvoid debug() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%4d\", F[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nbool dfs(int y, int x, int c) {\n    //printf(\"c: %d\\n\", c);\n    if (c > 0) return false;\n    if (c == 0) {\n        if (finished()) return true;\n        for (int i = 0; i < n; i++) \n            for (int j = 0; j < n; j++) \n                if (F[i][j] < 0) {\n                    bool ans;\n                    int f = F[i][j];\n                    F[i][j] = 0;\n                    ans = dfs(i, j, f);\n                    F[i][j] = f;\n                    return ans;\n                }\n        return false;\n    }\n\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (0 <= nx && nx < n && 0 <= ny && ny < n && F[ny][nx] > 0) {\n            int f = F[ny][nx];\n            F[ny][nx] = 0;\n            if (dfs(ny, nx, c+f)) return true;\n            else F[ny][nx] = f;\n        }\n    }\n    return false;\n}\n\nbool solve() {\n    bool ans;\n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j] < 0) {\n                int f = F[i][j];\n                F[i][j] = 0;\n                ans = dfs(i, j, f);\n                return ans;\n            }\n}\n \nint main() {\n    while (scanf(\"%d\", &n), n) {\n        for (int i = 0; i < n; i++) \n            for (int j = 0; j < n; j++) \n                scanf(\"%d\", &F[i][j]);\n       puts(solve() ? \"YES\" : \"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint table[ 10 ][ 10 ];\nbool visited[ 10 ][ 10 ];\nint n;\n\ntypedef pair<int, int> pii;\n\nbool is_same_sum() {\n  int sum_neg = 0;\n  int sum_pos = 0;\n  for ( int i = 1; i <= n; i++ ) {\n\tfor ( int j = 1; j <= n; j++ ) {\n\t  if ( table[ i ][ j ] > 0 ) {\n\t\tsum_pos += table[ i ][ j ];\n\t  } else {\n\t\tsum_neg -= table[ i ][ j ];\n\t  }\n\t}\n  }\n  return sum_pos == sum_neg;\n}\n\nbool is_global_fin;\n\nint dx[ 4 ] = { 0, 1, 0, -1 };\nint dy[ 4 ] = { 1, 0, -1, 0 };\nvoid dfs( vector<pii> &ss, int index, int local_sum, int y, int x ) {\n  visited[ y ][ x ] = true;\n  for ( int i = 0; i < 4; i++ ) {\n\tif ( is_global_fin ) return;\n\tint ny = y + dy[ i ];\n\tint nx = x + dx[ i ];\n\tif ( !visited[ ny ][ nx ] &&\n\t\t table[ ny ][ nx ] > 0 ) {\n\t  if ( local_sum + table[ ny ][ nx ] == -table[ ss[ index ].first ][ ss[ index ].second ] ) {\n\t\tif ( index + 1 == ss.size() ) {\n\t\t  is_global_fin = true;\n\t\t} else {\n\t\t  dfs( ss, index + 1, 0, ss[ index ].first, ss[ index ].second );\n\t\t}\n\t  } else if ( local_sum + table[ ny ][ nx ] < -table[ ss[ index ].first ][ ss[ index ].second ] ) {\n\t\tdfs( ss, index, local_sum + table[ ny ][ nx ], ny, nx );\n\t  }\n\t}\n  }\n  visited[ y ][ x ] = false;\n}\n\nbool solve( vector<pii> &ss ) {\n  if ( !is_same_sum() ) {\n\treturn false;\n  } else {\n\tis_global_fin = false;\n\tdfs( ss, 0, 0, ss[ 0 ].first, ss[ 0 ].second );\n\treturn is_global_fin;\n  }\n}  \n\nint main() {\n  while ( true ) {\n\tcin >> n;\n\tif ( n == 0 ) break;\n\t\n\tfor ( int i = 1; i <= 8; i++ ) {\n\t  for ( int j = 1; j <= 8; j++ ) {\n\t\ttable[ i ][ j ] = 0;\n\t\tvisited[ i ][ j ] = false;\n\t  }\n\t}\n\tvector<pii> ss;\n\tfor ( int i = 1; i <= n; i++ ) {\n\t  for ( int j = 1; j <= n; j++ ) {\n\t\tcin >> table[ i ][ j ];\n\t\tif ( table[ i ][ j ] < 0 ) {\n\t\t  ss.push_back( make_pair( i, j ) );\n\t\t}\n\t  }\n\t}\n\tif ( solve( ss ) ) {\n\t  cout << \"YES\" << endl;\n\t} else {\n\t  cout << \"NO\" << endl;\n\t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint field[8][8] = { { 0 } };\nbool used[8][8] = { { false } };\nvector<int> startX, startY;\n\nbool dfs(int n, int x, int y, int r){\n\tif(r == 0){\n\t\tint usedCount = 0;\n\t\tbool loopFlag = true;\n\t\tfor(int i = 0; i < n && loopFlag; ++i){\n\t\t\tfor(int j = 0; j < n && loopFlag; ++j){\n\t\t\t\tif(used[i][j]){ ++usedCount; }\n\t\t\t\tif(!used[i][j] && field[i][j] < 0){\n\t\t\t\t\tx = j; y = i; loopFlag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(usedCount == n * n){ return true; }\n\t}else if(used[y][x] || field[y][x] < 0){\n\t\treturn false;\n\t}\n\tr -= field[y][x];\n\tif(r < 0){ return false; }\n\tused[y][x] = true;\n\tif(x > 0 && dfs(n, x - 1, y, r)){ return true; }\n\tif(x < n - 1 && dfs(n, x + 1, y, r)){ return true; }\n\tif(y > 0 && dfs(n, x, y - 1, r)){ return true; }\n\tif(y < n - 1 && dfs(n, x, y + 1, r)){ return true; }\n\tused[y][x] = false;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(n, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<ull> cache;\nvector<int> V_sum;\nvector<int> coor;\nset<vector<ull> > visited;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y){\n\n  if( cur >= V ){\n    if( used == (1ULL<<(n*n))-1ULL ){\n      rep(i,V)if(V_sum[i]!=0)return false;\n      return true;\n    }\n    return false;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    \n    int cost = field[ny][nx];\n    if( cost + V_sum[cur] > 0 ) continue;\n\n    int next = cur;\n    int npre = (i+2)%4;\n    ull next_used = used | (1ULL<<(nx+ny*n));\n\n    if( cost + V_sum[cur] == 0 ) {\n      next++; \n      npre = -1;\n      nx = coor[next] % n;\n      ny = coor[next] / n;\n    }\n    V_sum[cur] += cost;\n    if(dfs(next_used,next,npre,nx,ny)) return true;\n    V_sum[cur] -= cost;\n  }\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    visited.clear();\n    ull initial_state = 0ULL;\n    V = 0;\n    cache.clear();\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcache.push_back(tmp);\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dy[] = {-1,0,1,0}, dx[] = {0,-1,0,1};\nint n, used[8][8], p[8][8], res;\n\nvoid dfs(int sum, int y, int x, int rest){\n  //  printf(\"%d %d %d %d\\n\", sum, y, x, rest);\n  if(res) return;\n\n  if(sum == 0 && rest == 0){\n    res = 1;\n    return;\n  }\n  if(sum == 0){\n    rep(i, n) rep(j, n){\n      if(used[i][j]) continue;\n      if(p[i][j]<0){\n\tused[i][j] = 1;\n\tdfs(-p[i][j], i, j, rest-1);\n\tused[i][j] = 0;\n\treturn;\n      }\n    }\n  }else{\n    rep(d, 4){\n      int ny = y + dy[d], nx = x + dx[d];\n      if(ny < 0 || nx < 0 || ny >= n || nx >= n || used[ny][nx] || p[ny][nx] < 0 || p[ny][nx] > sum) continue;\n      //      printf(\"next %d %d %d %d\\n\", ny, nx, used[ny][nx], p[ny][nx]);\n      used[ny][nx] = 1;\n      dfs(sum - p[ny][nx], ny, nx, rest-1);\n      used[ny][nx] = 0;\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d\", &n) && n){\n    res = 0;\n    memset(used, 0, sizeof(used));\n    rep(i, n) rep(j, n) scanf(\"%d\", &p[i][j]);\n\n    dfs(0, 0, 0, n*n);\n    puts(res?\"YES\":\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<int> V_sum;\nvector<int> coor;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n\n  if( cur >= V ){\n    if( used == (1ULL<<(n*n))-1ULL ) return true;\n    return false;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( field[ny][nx] < 0 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) ) return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    visited.clear();\n    ull initial_state = 0ULL;\n    V = 0;\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n    /*\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n    */\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,nn;\nint L[8][8];\nbool u[8][8];\n\nbool ans=false;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid dfs( bool isSearchP,int x,int y, int sum,int nL ){\n  /*\n  if( isSearchP )    cout << \"sP \";\n  else     cout << \"   \";\n  cout << x << \" \" << y << \" \" << sum << \" \" << nL <<endl;\n  */\n\n  if( isSearchP ){ // 起点探索\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( u[i][j] ) continue;\n\tif( L[i][j]<0 ){\n\t  //\t  cout << \" 起点：\"<< i << \",\" << j << endl;\n\t  u[i][j]=true;\n\t  dfs( false,i,j,L[i][j],nL-1 );\n\t  u[i][j]=false;\n\t}\n      }\n    }\n  }else{ // 起点からの線がつながるかをチェック\n    if( nL==0 ){\n      ans = true;      return;\n    }\n    if( sum==0 )\n      dfs( true,0,0,0,nL ); // 新たな起点を探しにいく\n\n    int nx,ny, ns;\n    for( int i=0;i<4;i++ ){\n      nx=x+dx[i]; ny=y+dy[i];\n      if( nx<0 || nx>=n ) continue;\n      if( ny<0 || ny>=n ) continue;\n      if( u[nx][ny] )     continue;\n      if( L[nx][ny]<0 )   continue;\n\n      ns = sum + L[nx][ny];\n      u[nx][ny]=true;\n      dfs( false,nx,ny,ns,nL-1 );\n      u[nx][ny]=false;\n    }\n  }\n}\n\nint main(){\n  while( cin>>n && n ){\n    int sum=0;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tcin >> L[i][j];\n\tsum += L[i][j];\n\tu[i][j] = false;\n      }\n    //    cout << \"sum=\" << sum << endl;\n    ans = false;\n    if( sum==0 )\n      dfs( true,0,0,0,n*n );\n    if( ans ) cout << \"YES\" << endl;\n    else      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\ntypedef unsigned long long ll;\n\nvector<vector<ll> > lines;\nint n;\nint field[9][9];\n\nvector<ll> tmp;\n\nconst int dy[]={0,0,-1,1};\nconst int dx[]={1,-1,0,0};\n\nbool ok=false;\n\nll fin;\n\n\nvoid dfs(ll s,int idx){\n\tif(ok){\n\t\treturn;\n\t}\n\tif(idx==lines.size()){\n\t\tif(fin==s)\n\t\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < lines[idx].size(); i++){\n\t\tif((s&lines[idx][i])==0){\n\t\t\tdfs(s|lines[idx][i],idx+1);\n\t\t}\n\t}\n}\n\nvoid lineSearch(ll s,int curSum,int ret,int x,int y){\n\tif(curSum==ret){\n\t\ttmp.push_back(s);\n\t}\n\tfor(int i= 0; i < 4; i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(nx>=0&&ny>=0&&nx<n&&ny<n&&field[ny][nx]>=1&&(curSum+field[ny][nx]<=ret)){\n\t\t\tif(!((s>>(ny*n+nx))&(1ull))){\n\t\t\t\tll ns=s|(((1ull)<<(ny*n+nx)));\n\t\t\t\tlineSearch(ns,curSum+field[ny][nx],ret,nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\n\twhile(cin>>n&&n!=0){\n\t\tfin=0;\n\t\tfor(int i = 0; i < n*n; i++){\n\t\t\tfin|=(1ull<<i);\n\t\t}\n\n\t\tok=false;\n\t\tlines.clear();\n\t\tvector<pair<int,pair<int,int> > > vpii;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]<0){\n\t\t\t\t\tvpii.push_back(make_pair(field[i][j],make_pair(i,j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < vpii.size(); i++){\n\t\t\ttmp.clear();\n\t\t\tif(i==5){\n\t\t\t\t//cout<<endl;\n\t\t\t}\n\n\t\t\tlineSearch(((1ull)<<(vpii[i].second.first*n+vpii[i].second.second)),0,-vpii[i].first,vpii[i].second.second,vpii[i].second.first);\n\t\t\tlines.push_back(tmp);\n\t\t}\n\t\tdfs(0ull,0);\n\t\tif(ok)\n\t\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\t\tcout<<\"NO\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <stdio.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef pair<int, int> Point;\ntypedef pair<int, Point> SP;\ntypedef vector<vector<int> > Mat;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint n;\nMat mat;\nvector<vector<bool> > used;\nvector<SP> starts(0);\n \nbool dfs(int cur, int sum, int x, int y) {\n//  cout << x << \", \"<< y << \", \" << sum << endl;\n  if (starts[cur].first == sum) {\n    //cout << \"ok \" << cur << endl;\n    cur++;\n    sum = 0;\n    if (cur >= starts.size()) {\n      return true;\n    }\n    x = starts[cur].second.second;\n    y = starts[cur].second.first;\n  }\n  else if (starts[cur].first < sum) {\n    return false;\n  }\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if (0 <= nx && nx < n && 0 <= ny && ny < n && !used[ny][nx]) {\n      used[ny][nx] = true;\n      if (dfs(cur, sum + mat[ny][nx], nx, ny)) return true;\n      used[ny][nx] = false;\n    }\n  }\n  return false;\n  \n}\nvoid solve() {\n  mat = Mat(n, vector<int>(n));\n  used = vector<vector<bool> >(n, vector<bool>(n, false));\n  starts.clear();\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      int a;\n      cin >> a;\n      sum += a;\n      if (a < 0) {\n        a *= -1;\n        used[i][j] = true;\n        starts.push_back(SP(a, Point(i, j)));\n      }\n      mat[i][j] = a;\n    }\n  }\n  bool ret = false;;\n  if (sum != 0) {\n    ret = false;\n  }\n  else if (starts.size() == 1) {\n    ret = true;\n  }\n  else {\n    sort(starts.begin(), starts.end(), greater<SP>());\n\n    ret = dfs(0, 0, starts[0].second.second, starts[0].second.first);\n  }\n  cout << (ret ? \"YES\" : \"NO\") << endl;\n  return;\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvoid disp(int stage[12][12], const int stage_size){\n  for(int y = 0; y < stage_size; y++){\n    for(int x = 0; x < stage_size; x++){\n      printf(\"%d \",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nclass Cell {\npublic:\n  int x;\n  int y;\n  int energy;\n  Cell(int x,int y,int energy)\n    : x(x), y(y), energy(energy) {}\n};\n\nbool check_all_zero(int stage[12][12], const int stage_size){\n  for(int y = 0; y < stage_size; y++){\n    for(int x = 0; x < stage_size; x++){\n      if(stage[y][x] != 0) return false;\n    }\n  }\n  return true;\n}\n\nCell find_starting_point(int stage[12][12], const int stage_size){\n  for(int y = 0; y < stage_size; y++){\n    for(int x = 0; x < stage_size; x++){\n      if(stage[y][x] < 0){\n        return Cell(x,y,-stage[y][x]);\n      }\n    }\n  }\n  return Cell(-1,-1,0);\n}\n\nbool dfs(int stage[12][12], const int stage_size,\n         int sx, int sy,int life){\n  bool res = false;\n  if(life < 0){\n    return false;\n  }\n  if(life == 0){\n    // disp(stage,stage_size);\n\n    if(check_all_zero(stage,stage_size)){\n      return true;\n    }\n    else{\n      Cell c = find_starting_point(stage,stage_size);\n      if(c.x == -1 && c.y == -1) return false;\n      stage[c.y][c.x] = 0;\n      // disp(stage,stage_size);\n      // cout << c.energy << endl;\n      res |= dfs(stage,stage_size,c.x,c.y,c.energy);\n      stage[c.y][c.x] = -c.energy;\n    }\n  }\n\n  for(int i = 0; i < 4; i++){\n    int dx = tx[i] + sx;\n    int dy = ty[i] + sy;\n    if(dx < 0 || dy < 0 || dx >= stage_size || dy >= stage_size){\n      continue;\n    }\n    if(stage[dy][dx] <= 0){\n      continue;\n    }\n    if(life - stage[dy][dx] < 0){\n      continue;\n    }\n\n    int tmp = stage[dy][dx];\n    stage[dy][dx] = 0;\n    res |= dfs(stage,stage_size,dx,dy,life - tmp);\n    stage[dy][dx] = tmp;\n  }\n  return res;\n}\n\nint main(){\n  int stage_size;\n  while(~scanf(\"%d\",&stage_size)){\n    if(stage_size == 0) break;\n    int stage[12][12];\n    for(int y = 0; y < stage_size; y++){\n      for(int x = 0; x < stage_size; x++){\n        scanf(\"%d\",&stage[y][x]);\n      }\n    }\n\n    printf(\"%s\\n\",dfs(stage,stage_size,0,0,0) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nint n, a[9][9], cnt, px[75], py[75]; bool vis[9][9];\nbool solve(int sx, int sy, int cur, int vcnt, int sum) {\n\tif (cur == cnt) return vcnt == n * n + 1;\n\tif (sum == -a[px[cur]][py[cur]]) {\n\t\tvis[px[cur + 1]][py[cur + 1]] = true;\n\t\tbool res = solve(px[cur + 1], py[cur + 1], cur + 1, vcnt + 1, 0);\n\t\tvis[px[cur + 1]][py[cur + 1]] = false;\n\t\treturn res;\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + dir[i], ty = sy + dir[i ^ 1];\n\t\tif (0 <= tx && tx < n && 0 <= ty && ty < n && !vis[tx][ty] && a[tx][ty] > 0 && sum + a[tx][ty] <= -a[px[cur]][py[cur]]) {\n\t\t\tvis[tx][ty] = true;\n\t\t\tbool res = solve(tx, ty, cur, vcnt + 1, sum + a[tx][ty]);\n\t\t\tvis[tx][ty] = false;\n\t\t\tif (res) return true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tcnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] < 0) {\n\t\t\t\t\tpx[cnt] = i;\n\t\t\t\t\tpy[cnt] = j;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvis[px[0]][py[0]] = true;\n\t\tbool ret = solve(px[0], py[0], 0, 1, 0);\n\t\tvis[px[0]][py[0]] = false;\n\t\tcout << (ret ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<P> rt;\n//map<vector<vector<int> >,bool> mp;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(y>=0&&y<n&&x>=0&&x<n)\n\t\treturn true;\n\treturn false;\n}\nbool cal(vector<vector<int> >,int);\nbool f(vector<vector<int> > v,int y,int x,int left,int now){\n\tif(!left){\n\t\treturn cal(v,now+1);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\tif(inf(ny,nx)&&v[ny][nx]>0&&left-v[ny][nx]>=0){\n\t\t\tint temp=v[ny][nx];\n\t\t\tv[ny][nx]=0;\n\t\t\tif(f(v,ny,nx,left-temp,now)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tv[ny][nx]=temp;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool cal(vector<vector<int> > v,int now){\n\tif(now==rt.size()){\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\tif(v[i][j]!=0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tint y=rt[now].first;\n\tint x=rt[now].second;\n\tint temp=v[y][x];\n\tv[y][x]=0;\n\tif(f(v,y,x,-temp,now))\n\t\treturn true;\n\t//v[y][x]=temp;\n\t\n\treturn false;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tvector<vector<int> > v(n,vector<int>(n));\n\t\trt.clear();\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>v[i][j];\n\t\t\tif(v[i][j]<0)\n\t\t\trt.pb(P(i,j));\n\t\t}\n\t\tif(cal(v,0))\n\t\tcout<<\"YES\"<<endl;\n\t\t\telse\n\t\tcout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nint DX[4] = {0, 0, 1, -1};\nint DY[4] = {1, -1, 0, 0};\nvector< vector< vector<int> > > dfs(vector< vector<int> > p, int y, int x, int cost)\n{\n    vector< vector< vector<int> > > result;\n    if(cost == 0) {\n        result.push_back(p);\n        return result;\n    }\n    for(int i=0; i<4; i++) {\n        int ny = y + DY[i];\n        int nx = x + DX[i];\n        if(ny < 0 || p.size() <= ny) continue;\n        if(nx < 0 || p.size() <= nx) continue;\n        if(p[ny][nx] <= 0) continue;\n        if(cost < p[ny][nx]) continue;\n        vector< vector<int> > np = p;\n        int nc = cost;\n        nc -= np[ny][nx];\n        np[ny][nx] = 0;\n        vector< vector< vector<int> > > r = dfs(np, ny, nx, nc);\n        result.insert(result.end(), r.begin(), r.end());\n    }\n    return result;\n}\nint main()\n{\n    int n;\n    while(cin>>n, n) {\n        vector< vector<int> > puzzle(n, vector<int>(n));\n        for(int i=0; i<n; i++) for(int j=0; j<n; j++) cin>>puzzle[i][j];\n\n        queue< vector< vector<int> > > q;\n        q.push(puzzle);\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<n; j++) {\n                if(puzzle[i][j] >= 0) continue;\n                vector< vector< vector<int> > > next;\n                queue< vector< vector<int> > > nq;\n                while(!q.empty()) {\n                    vector< vector<int> > p = q.front();\n                    q.pop();\n                    p[i][j] = 0;\n                    next = dfs(p, i, j, -puzzle[i][j]);\n                    for(vector< vector< vector<int> > >::iterator i=next.begin(); i!=next.end(); i++) {\n                        nq.push(*i);\n                    }\n                }\n                q = nq;\n            }\n        }\n\n        bool ok = false;\n        while(!q.empty()) {\n            vector< vector<int> > p = q.front();\n            q.pop();\n            bool clear = true;\n            for(int i=0; i<n; i++) for(int j=0; j<n; j++) {\n                if(p[i][j] != 0) clear = false;\n            }\n            if(clear) ok = true;\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint n;\nint b[10][10];\nint id[10][10];\nvector<vector<ull> > v;\nint nid;\nint midx;\n\nconst int dx[4] = { 1,-1, 0, 0};\nconst int dy[4] = { 0, 0, 1,-1};\n\n#define HASH(x,y) (((ull)1) << (((x)-1) + ((y)-1)*8)) \n\nvoid check(int x, int y, int sum, ull f){\n  if(sum == 0){\n    v[nid].push_back(f);\n    return;\n  }\n  //printf(\"check(%d,%d,%d,%llu)\\n\",x,y,sum,f);\n  REP(i,4){\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    ull h  = HASH(xx,yy);\n    int s = sum - b[yy][xx];\n    if(s < 0 || (h & f) != 0 || b[yy][xx] < 0) continue;\n    check(xx,yy,s,(f|h));\n  }\n}\n\nbool ans(int idx, ull f){\n  if(idx == midx) return true;\n  REP(i,v[idx].size()){\n    if((f & v[idx][i]) == 0 && ans(idx+1, (f|v[idx][i])))\n       return true;\n  }\n  return false;\n}\n\nint main(){\n  REP(i,10) REP(j,10) b[i][j] = -1;\n  while(scanf(\"%d\",&n),n){\n    int idx = 0;\n    int sum = 0;\n\n    REP(i,n) REP(j,n){\n      int tmp;\n      scanf(\"%d\",&tmp); \n      b[i+1][j+1] = tmp;\n      if(tmp < 0){\n\tid[i+1][j+1] = idx++;\n      }\n      sum += tmp;\n    }\n\n    midx = idx;\n\n    if(sum != 0){\n      puts(\"NO\");\n      continue;\n    }\n\n    v = vector<vector<ull> >(idx);\n\n    for(int y=1; y<=n; y++){\n      for(int x=1; x<=n; x++){\n\tif(b[y][x] < 0){\n\t  nid = id[y][x];\n\t  check(x,y,-b[y][x],HASH(x,y));\n\t}\n      }\n    }\n\n    puts(ans(0,0)?\"YES\":\"NO\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint n, m[10][10];\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\nvector<P> vp;\nbool ans;\n\nvoid solve(int x, int y, int s, int id, int cnt, map<P,bool> memo ){\n\tmemo[P(x,y)] = true;\n\tif( ans ) return;\n\t\n\tif( s == 0 ){\n\t\tif( id == vp.size()-1 ){\n\t\t\tif( cnt == n*n )\n\t\t\t\tans = true;\n\t\t\treturn;\n\t\t}else{\n\t\t\tint nx = vp[id+1].first;\n\t\t\tint ny = vp[id+1].second;\n\t\t\tsolve( nx , ny , m[ny][nx] , id+1 , cnt+1, memo );\n\t\t}\n\t}\n\t\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= n || my >= n ) continue;\n\t\tif( m[my][mx] < 0 || memo[P(mx,my)] || s + m[my][mx] > 0 ) continue;\n\t\tsolve( mx , my , s+m[my][mx] , id , cnt+1, memo );\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tvp.clear();\n\t\tans = false;\n\t\tmap<P,bool> memo;\n\t\t\n\t\tfor(int y=0 ; y < n ; y++ ){\n\t\t\tfor(int x=0 ; x < n ; x++ ){\n\t\t\t\tcin >> m[y][x];\n\t\t\t\tif( m[y][x] < 0 ){\n\t\t\t\t\tvp.push_back( P(x,y) );\n\t\t\t\t}\n\t\t\t\tmemo[P(x,y)] = false;\n\t\t\t}\n\t\t}\n\t\tint sx = vp[0].first;\n\t\tint sy = vp[0].second;\n\t\tsolve( sx , sy , m[sy][sx] , 0 , 1 ,  memo );\n\t\tif( ans )\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<int> V_sum;\nvector<int> coor;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n  if( cur >= V ) return true;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) ) return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    ull initial_state = 0ULL;\n    V = 0;\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\nint K;\nint a[64][64];\nint bx[64];\nint by[64];\nbool used[64][64];\nint rest;\nbool dfs(int k, int sum, int sx, int sy){\n  //printf(\"dfs : k = %d sum = %d sx = %d sy = %d\\n\", k, sum, sx, sy);\n  if(k == K){\n    return rest == 0;\n  }\n  REP(r, 4){\n    int nx = sx + dx[r];\n    int ny = sy + dy[r];\n    if(valid(nx, ny, N, N) && !used[ny][nx] && a[ny][nx] > 0){\n      used[ny][nx] = true;\n      rest--;\n      if(sum - a[ny][nx] < 0){\n      }else if(sum - a[ny][nx] == 0){\n        if(k + 1 == K) {\n          if(dfs(k + 1, 0, 0, 0)) return true;\n        }else{\n          if(dfs(k + 1, -a[by[k + 1]][bx[k + 1]], bx[k + 1], by[k + 1])) return true;\n        }\n      }else if(sum - a[ny][nx] > 0){\n        if(dfs(k, sum - a[ny][nx], nx, ny)) return true;\n      }\n      used[ny][nx] = false;\n      rest++;\n    }\n  }\n  return false;\n}\nint main(){\n  while(cin>>N && N){\n    REP(i, N)REP(j, N) cin>>a[i][j];\n    K = 0;\n    REP(i, N)REP(j, N)if(a[i][j] < 0){\n      by[K] = i;\n      bx[K] = j;\n      K++;\n    }\n    memset(used, 0, sizeof(used));\n    rest = N * N - K;\n    bool ans = dfs(0, -a[by[0]][bx[0]], bx[0], by[0]);\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[] = {+1,-1, 0, 0};\nint dy[] = { 0, 0,+1,-1};\nint tb[10][10];\nint tf[10][10];\n\nint n,t,sum;\nvector<int> sx,sy;\n\nbool dfs(int x, int y, int s, int c, int m)\n{\n\t//cout << x << \" \" << y << \" \" << s << \" \" << c << \" \" << m << endl;\n\n\tint tx,ty,ts,tc,tm,f;\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tf  = false;\n\t\ttc = c;\n\t\tts = s+1;\n\t\ttx = x+dx[i];\n\t\tty = y+dy[i];\n\t\ttm = m+tb[tx][ty];\n\n\t\tif(tf[tx][ty]==0) continue;\n\t\tif(tb[tx][ty]<=0) continue;\n\n\t\tif(tm>0) continue;\n\t\tif(tm==0)\n\t\t{\n\t\t\ttc++;\n\n\t\t\tif(tc==sx.size())\n\t\t\t{\n\t\t\t\tif(ts==n*n)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tts++;\n\t\t\ttx = sx[tc];\n\t\t\tty = sy[tc];\n\t\t\ttm = tb[tx][ty];\n\t\t\tf  = true;\n\t\t\ttf[x+dx[i]][y+dy[i]]=0;\n\t\t}\n\n\t\ttf[x][y]=0;\n\t\tif(dfs(tx,ty,ts,tc,tm)) return true;\n\t\ttf[x][y]=1;\n\n\t\tif(f)\n\t\t{\n\t\t\ttf[x+dx[i]][y+dy[i]]=1;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tsum = 0;\n\t\tsx.clear();\n\t\tsy.clear();\n\n\t\tfor(int i=0; i<100; i++)\n\t\t{\n\t\t\ttb[i/10][i%10] = 0;\n\t\t\ttf[i/10][i%10] = 1;\n\t\t}\n\n\t\tfor(int i=0; i<n*n; i++)\n\t\t{\n\t\t\tcin >> t; sum+=t;\n\t\t\ttb[(i/n)+1][(i%n)+1] = t;\n\n\t\t\tif(t<0)\n\t\t\t{\n\t\t\t\tsx.push_back((i/n)+1);\n\t\t\t\tsy.push_back((i%n)+1);\n\t\t\t}\n\t\t}\n\n\t\t// »è»Ì1\n\t\tif(sum!=0) { cout << \"NO\\n\"; continue; }\n\n\t\tif(dfs(sx[0],sy[0],1,0,tb[sx[0]][sy[0]]))\n\t\t{\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<int> P;\nconst int MAX_N = 9;\n\nint N, f[MAX_N][MAX_N];\nint my[] = {0, 0, 1, -1};\nint mx[] = {1, -1, 0, 0};\n\nvoid dfs(int y, int x, int sum, int tar, vector<P> &r, vector< vector<P> > &rs, vector< vector<bool> > &used){\n  if(sum == tar) { rs.push_back(r); return ; }\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < N && nx < N && !used[ny][nx] && f[ny][nx] >= 0 && sum + f[ny][nx] <= tar){\n      vector<P> nr = r;\n      nr.push_back(P(ny, nx));\n      used[ny][nx] = 1;\n      dfs(ny, nx, sum + f[ny][nx], tar, nr, rs, used);\n      used[ny][nx] = 0;\n    }\n  }\n}\n\nbool isValid(vector<P> &v, vector< vector<bool> > &used){\n  REP(i, v.size()){\n    int y = v[i].real(), x = v[i].imag();\n    if(used[y][x]) return false;\n  }\n  return true;\n}\n\nbool check(int now, vector< vector< vector<P> > > &v, vector< vector<bool> > &used, vector<int> &rs){\n  if(now >= v.size()){\n    bool res = true;\n    REP(i, N) REP(j, N) if(!used[i][j]) res = false;\n    return res;\n  }\n  bool ret = false;\n  REP(i, v[now].size()){\n    if(isValid(v[now][i], used)){\n      REP(j, v[now][i].size()) {\n        int y = v[now][i][j].real(), x = v[now][i][j].imag();\n        used[y][x] = true;\n      }\n      rs.push_back(i);\n      ret = max(ret, check(now + 1, v, used, rs));\n      rs.pop_back();\n      REP(j, v[now][i].size()) {\n        int y = v[now][i][j].real(), x = v[now][i][j].imag();\n        used[y][x] = false;\n      }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while(cin >>N && N){\n    vector< vector< vector<P> > > v;\n    REP(i, N) REP(j, N) cin >>f[i][j];\n    //REP(i, N){\n    //  REP(j, N) printf(\"%5d\", f[i][j]);\n    //  cout <<endl;\n    //}\n    REP(i, N){\n      REP(j, N){\n        if(f[i][j] >= 0) continue;\n        vector< vector<bool> > used(N, vector<bool>(N, 0));\n        vector< vector<P> > rs;\n        vector<P> r;\n        dfs(i, j, 0, abs(f[i][j]), r, rs, used);\n        v.push_back(rs);\n        //cout <<i <<\", \" <<j <<\", \" <<abs(f[i][j]) <<endl;\n        //REP(i, rs.size()){ REP(j, rs[i].size()) cout <<rs[i][j] <<\"( \" <<f[rs[i][j].real()][rs[i][j].imag()] <<\" ) , \"; cout <<endl; }\n      }\n    }\n    vector< vector<bool> > used(N, vector<bool>(N, 0));\n    REP(i, N) REP(j, N) if(f[i][j] < 0) used[i][j] = true;\n    vector<int> rs;\n    int ans = check(0, v, used, rs);\n    cout <<(ans ? \"YES\" : \"NO\") <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint dx[] = {+1,-1, 0, 0};\nint dy[] = { 0, 0,+1,-1};\nint tb[10][10];\nbool visited[10][10];\n\nint n,t,sum;\nvector<int> sx,sy;\n\nbool dfs(int x, int y, int s, int c, int m)\n{\n\tint tx,ty,ttx,tty,tc,tm,ts;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tbool v=false;\n\t\tts = s;\n\t\ttc = c;\n\t\ttx = x+dx[i];\n\t\tty = y+dy[i];\n\t\tttx= x;\n\t\ttty= y;\n\t\ttm = m+tb[tx][ty];\n\n\t\tif(tb[tx][ty]<=0) continue;\n\t\tif(visited[tx][ty]) continue;\n\t\tif(tm>0) continue;\n\t\tif(tm==0)\n\t\t{\n\t\t\ttc++;\n\t\t\tts++;\n\t\t\tif(tc==sx.size())\n\t\t\t{\n\t\t\t\tif(ts==n*n)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tttx=tx;\n\t\t\ttty=ty;\n\t\t\ttx = sx[tc];\n\t\t\tty = sy[tc];\n\t\t\ttm = tb[tx][ty];\n\t\t}\n\t\tvisited[ttx][tty]=1;\n\t\tvisited[x][y]=1;\n\t\tif(dfs(tx,ty,ts+1,tc,tm)) return true;\n\t\tvisited[x][y]=0;\n\t\tvisited[ttx][tty]=0;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tsum = 0;\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tsx.clear();\n\t\tsy.clear();\n\n\t\tfor(int i=0; i<100; i++)\n\t\t{\n\t\t\ttb[i/10][i%10] = 0;\n\t\t}\n\n\t\tfor(int i=0; i<n*n; i++)\n\t\t{\n\t\t\tcin >> t; sum+=t;\n\t\t\ttb[(i/n)+1][(i%n)+1] = t;\n\n\t\t\tif(t<0)\n\t\t\t{\n\t\t\t\tsx.push_back((i/n)+1);\n\t\t\t\tsy.push_back((i%n)+1);\n\t\t\t}\n\t\t}\n\n\t\t// »è»Ì1\n\t\tif(sum!=0) { cout << \"NO\\n\"; continue; }\n\n\t\tif(dfs(sx[0],sy[0],1,0,tb[sx[0]][sy[0]]))\n\t\t{\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n#include <iostream>\n#include <conio.h>\n\nusing namespace std;\n\n#define GU (-100)\n\nlist<unsigned long long> LineData[32];\nint map[8 + 2][8 + 2];\nint n;\n\nint make_line(int x, int y, int now, int goal, unsigned long long flag, int start_id)\n{\n\tif (now == goal){\n\t\tLineData[start_id].push_back(flag);\n\t\treturn (0);\n\t}\n\t\n\tif (map[x][y] <= 0 || now > goal || (flag >> ((y - 1) * 8 + (x - 1))) & 1 == 1){\n\t\treturn (0);\n\t}\n\t\n\tnow += map[x][y];\n\tint d = (((y - 1) * 8) +  (x - 1));\n\t\n\t*(((int *)(&flag)) + (d / 32)) |= 1 << (d % 32);\n\t\n\tmake_line(x + 1, y, now, goal, flag, start_id);\n\tmake_line(x - 1, y, now, goal, flag, start_id);\n\tmake_line(x, y + 1, now, goal, flag, start_id);\n\tmake_line(x, y - 1, now, goal, flag, start_id);\n\t\n\treturn (0);\n}\n\nbool is_clear(int depth, int start_cnt, unsigned long long flag)\n{\n\tlist<unsigned long long>::iterator it;\n\t\n\tif (depth == start_cnt){\n\t\tint st_cnt;\n\t\tst_cnt = 0;\n\t\tfor (int i = 0; i < 64; i++){\n\t\t\tst_cnt += (*(((int *)(&flag)) + (i / 32)) >> i % 32) & 1;\n\t\t}\n\t\treturn (st_cnt == n * n ? true : false);\n\t}\n\t\n\tfor (it = LineData[depth].begin(); it != LineData[depth].end(); it++){\n\t\tif (flag ^ *it == flag | *it && is_clear(depth + 1, start_cnt, flag | *it) == true){\n\t\t\treturn (true);\n\t\t}\n\t}\n\t\n\treturn (false);\n}\n\nint main(void)\n{\n\tint start_cnt;\n\tlong long start_flag;\n\t\n\twhile (1){\n\t\tfor (int i = 0; i < 32; i++){\n\t\t\tLineData[i].clear();\n\t\t}\n\t\tfor (int y = 0; y < 10; y++){\n\t\t\tfor (int x = 0; x < 10; x++){\n\t\t\t\tmap[x][y] = GU;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\t\n\t\tfor (int y = 1; y <= n; y++){\n\t\t\tfor (int x = 1; x <= n; x++){\n\t\t\t\tscanf(\"%d\", &map[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstart_cnt = start_flag = 0;\n\t\tfor (int y = 1; y <= n; y++){\n\t\t\tfor (int x = 1; x <= n; x++){\n\t\t\t\tif (map[x][y] < 0){\n\t\t\t\t\tmake_line(x + 1, y, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x - 1, y, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x, y + 1, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x, y - 1, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tint d = ((y - 1) * 8 +  (x - 1));\n\t\t\t\t\t*(((int *)(&start_flag)) + (d / 32)) |= 1 << (d % 32);\n\t\t\t\t\tstart_cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < start_cnt; i++){\n\t\t\tLineData[i].sort();\n\t\t\tLineData[i].unique();\n#if 0\n\t\t\tfor (list<unsigned long long>::iterator it = LineData[i].begin(); it != LineData[i].end(); it++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = 0; i < 8; i++){\n\t\t\t\t\tfor (int j = 0; j < 8; j++){\n\t\t\t\t\t\tprintf(\"%d\", (*it >> i * 8 + j) & 1);\n\t\t\t\t\t\tif ((*it >> i * 8 + j) & 1 == 1){\n\t\t\t\t\t\t\tsum += map[j + 1][i + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", sum);\n\t\t\t//\tgetch();\n\t\t\t}\n#endif\n\t\t}\n\t\tprintf(\"%s\\n\", is_clear(0, start_cnt, start_flag) == true ? \"YES\" : \"NO\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define Range(x, y, w, h) ((0<=x)&&(x<w)&&(0<=y)&&(y<h))\n\nconst int width = 8;\nconst int height = 8;\nconst int dx[] = {0, 0, -1, 1};\nconst int dy[] = {-1, 1, 0, 0};\n\nint map_size;\n\nint kiten_size;\nint kiten_n[30];\nint kiten_x[30];\nint kiten_y[30];\nint kiten_pnt;\n\nbool result;\n\nusing namespace std;\n\nvoid search(int map[][width], int mx, int my, int cnt) {\n\tfor(int dd=0; dd < 4; dd++) {\n\t\tint nx = mx + dx[dd];\n\t\tint ny = my + dy[dd];\n\t\tif(Range(nx, ny, map_size, map_size) && (map[ny][nx] != 0)){\n\t\t\tint tmp = map[ny][nx];\n\t\t\tif((tmp+cnt) == kiten_n[kiten_pnt]) {\n\t\t\t\tmap[ny][nx] = 0;\n\t\t\t\tif(++kiten_pnt >= kiten_size) {\n\t\t\t\t\tresult = true;\n\t\t\t\t\tmap[ny][nx] = tmp;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsearch(map, kiten_x[kiten_pnt], kiten_y[kiten_pnt], 0);\n\t\t\t\t}\n\t\t\t\tmap[ny][nx] = tmp;\n\t\t\t}\n\t\t\telse if((tmp+cnt) < kiten_n[kiten_pnt]){\n\t\t\t\tmap[ny][nx] = 0;\n\t\t\t\tsearch(map, nx, ny, (tmp+cnt));\n\t\t\t\tmap[ny][nx] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint n;\n\tint sum;\n\tint map[height][width];\n\tint tmp;\n\n\twhile(cin >> n, n) // input n\n\t{\n\t\tsum = kiten_size = 0;\n\t\tfor(int y=0; y < n; y++) for(int x=0; x < n; x++) {\n\t\t\tcin >> tmp; map[y][x] = tmp; // input map[y][x]\n\t\t\tsum += tmp;\n\t\t\tif(tmp < 0) { // check point\n\t\t\t\tkiten_n[kiten_size] = -tmp;\n\t\t\t\tkiten_x[kiten_size] = x;\n\t\t\t\tkiten_y[kiten_size++] = y;\n\t\t\t\tmap[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tif(sum) { // not zero\n\t\t\tprintf(\"NO\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tmap_size = n; kiten_pnt = 0; result = false;\n\t\tsearch(map, kiten_x[kiten_pnt], kiten_y[kiten_pnt], 0);\n\t\tif(result)\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\nusing namespace std;\n\n\nint d[8][8];\n\nint isok1(int n){\n\tint mins = 0 , pls = 0;\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tif(d[i][j] < 0 ) mins += -d[i][j];\n\t\t\telse pls += d[i][j];\n\treturn mins <= pls;\n}\n\n\nint n,I;\nset<unsigned long long> bit[25];\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid dfs(int x,int y,long long u,int sum){\n\tif( sum == 0 ){\n\t\tbit[I].insert(u);\n\t\treturn;\n\t}\t\n\tfor(int i = 0 ; i < 4 ; i++){\n\t\tint tx = x + dx[i] , ty = y + dy[i];\n\t\tif( tx >= 0 && tx < n && ty < n && ty >= 0 && !(u>>(ty*n+tx)&1) && sum >= d[ty][tx] && d[ty][tx] > 0 ) {\n\t\t\tdfs(tx,ty,u|(1ull<<(ty*n+tx)),sum-d[ty][tx]);\n\t\t}\n\t}\n}\nbool exactCover(int i,unsigned long long u){\n\tif(i == -1) return u == 0;\n\tfor(set<unsigned long long>::iterator it = bit[i].begin() ; it != bit[i].end() ; ++it){\n\t\tif( (u&(*it)) == (*it) && exactCover(i-1,u-(*it)) ) return true;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin >> n && n){\n\t\tvector<int> sx,sy;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tint a; cin >> a;\n\t\t\t\td[i][j] = a;\n\t\t\t\tif(a < 0) sx.push_back(j);\n\t\t\t\tif(a < 0) sy.push_back(i);\n\t\t\t}\n\t\t}\n\t\tif( isok1(n) ){\n\t\t\tfor(int i = 0 ; i < 25 ; i++) bit[i].clear();\n\t\t\tfor(int i = 0 ; i < sx.size() ; i++){\n\t\t\t\tI = i;\n\t\t\t\tdfs(sx[i],sy[i],1ull<<(sy[i]*n+sx[i]),-d[sy[i]][sx[i]]);\n\t\t\t}\n\t\t\tcout << (exactCover(sx.size()-1,(1ull<<(n*n))-1)?\"YES\":\"NO\") << endl;\t\n\t\t}else{\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n#include <iostream>\n\nusing namespace std;\n\n#define GU (-100)\n\nlist<unsigned long long> LineData[32];\nint map[8 + 2][8 + 2];\nint n;\n\nint make_line(int x, int y, int now, int goal, unsigned long long flag, int start_id)\n{\n\tif (now == goal){\n\t\tLineData[start_id].push_back(flag);\n\t\treturn (0);\n\t}\n\t\n\tif (map[x][y] <= 0 || now > goal || (flag >> ((y - 1) * 8 + (x - 1))) & 1 == 1){\n\t\treturn (0);\n\t}\n\t\n\tnow += map[x][y];\n\tint d = (((y - 1) * 8) +  (x - 1));\n\t\n\t*(((int *)(&flag)) + (d / 32)) |= 1 << (d % 32);\n\t\n\tmake_line(x + 1, y, now, goal, flag, start_id);\n\tmake_line(x - 1, y, now, goal, flag, start_id);\n\tmake_line(x, y + 1, now, goal, flag, start_id);\n\tmake_line(x, y - 1, now, goal, flag, start_id);\n\t\n\treturn (0);\n}\n\nbool is_clear(int depth, int start_cnt, unsigned long long flag)\n{\n\tlist<unsigned long long>::iterator it;\n\t\n\tif (depth == start_cnt){\n\t\tint st_cnt;\n\t\tst_cnt = 0;\n\t\tfor (int i = 0; i < 64; i++){\n\t\t\tst_cnt += (*(((int *)(&flag)) + (i / 32)) >> i % 32) & 1;\n\t\t}\n\t\treturn (st_cnt == n * n ? true : false);\n\t}\n\t\n\tfor (it = LineData[depth].begin(); it != LineData[depth].end(); it++){\n\t\tif (flag ^ *it == flag | *it && is_clear(depth + 1, start_cnt, flag | *it) == true){\n\t\t\treturn (true);\n\t\t}\n\t}\n\t\n\treturn (false);\n}\n\nint main(void)\n{\n\tint start_cnt;\n\tlong long start_flag;\n\t\n\twhile (1){\n\t\tfor (int i = 0; i < 32; i++){\n\t\t\tLineData[i].clear();\n\t\t}\n\t\tfor (int y = 0; y < 10; y++){\n\t\t\tfor (int x = 0; x < 10; x++){\n\t\t\t\tmap[x][y] = GU;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\t\n\t\tfor (int y = 1; y <= n; y++){\n\t\t\tfor (int x = 1; x <= n; x++){\n\t\t\t\tscanf(\"%d\", &map[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstart_cnt = start_flag = 0;\n\t\tfor (int y = 1; y <= n; y++){\n\t\t\tfor (int x = 1; x <= n; x++){\n\t\t\t\tif (map[x][y] < 0){\n\t\t\t\t\tmake_line(x + 1, y, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x - 1, y, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x, y + 1, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x, y - 1, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tint d = ((y - 1) * 8 +  (x - 1));\n\t\t\t\t\t*(((int *)(&start_flag)) + (d / 32)) |= 1 << (d % 32);\n\t\t\t\t\tstart_cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < start_cnt; i++){\n\t\t\tLineData[i].sort();\n\t\t\tLineData[i].unique();\n#if 0\n\t\t\tfor (list<unsigned long long>::iterator it = LineData[i].begin(); it != LineData[i].end(); it++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = 0; i < 8; i++){\n\t\t\t\t\tfor (int j = 0; j < 8; j++){\n\t\t\t\t\t\tprintf(\"%d\", (*it >> i * 8 + j) & 1);\n\t\t\t\t\t\tif ((*it >> i * 8 + j) & 1 == 1){\n\t\t\t\t\t\t\tsum += map[j + 1][i + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", sum);\n\t\t\t//\tgetch();\n\t\t\t}\n#endif\n\t\t}\n\t\tprintf(\"%s\\n\", is_clear(0, start_cnt, start_flag) == true ? \"YES\" : \"NO\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<ull> cache;\nvector<int> V_sum;\nvector<int> coor;\nset<vector<ull> > visited;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y){\n\n  if( cur >= V ){\n    if( used == (1ULL<<(n*n))-1ULL ){\n      rep(i,V)if(V_sum[i]!=0)return false;\n      return true;\n    }\n    return false;\n  }\n\n  if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    \n    int cost = field[ny][nx];\n    if( cost + V_sum[cur] > 0 ) continue;\n\n    int next = cur;\n    int npre = (i+2)%4;\n    ull next_used = used | (1ULL<<(nx+ny*n));\n\n    if( cost + V_sum[cur] == 0 ) {\n      next++; \n      npre = -1;\n      nx = coor[next] % n;\n      ny = coor[next] / n;\n    }\n    V_sum[cur] += cost;\n    if(dfs(next_used,next,npre,nx,ny)) return true;\n    V_sum[cur] -= cost;\n  }\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    visited.clear();\n    ull initial_state = 0ULL;\n    V = 0;\n    cache.clear();\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcache.push_back(tmp);\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[] = {+1,-1, 0, 0};\nint dy[] = { 0, 0,+1,-1};\nint tb[10][10];\nint tf[10][10];\n\nint n,t,sum;\nvector<int> sx,sy;\n\nbool dfs(int x, int y, int s, int c, int m)\n{\n\tint tx,ty,ts,tc,tm;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\ttc = c;\n\t\tts = s+1;\n\t\ttx = x+dx[i];\n\t\tty = y+dy[i];\n\t\ttm = m+tb[tx][ty];\n\n\t\tif(tf[tx][ty]==0) continue;\n\t\tif(tb[tx][ty]<=0) continue;\n\n\t\tif(tm>0) continue;\n\t\tif(tm==0)\n\t\t{\n\t\t\ttc++;\n\n\t\t\tif(tc==sx.size())\n\t\t\t{\n\t\t\t\tif(ts==n*n)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tts++;\n\t\t\ttx = sx[tc];\n\t\t\tty = sy[tc];\n\t\t\ttm = tb[tx][ty];\n\t\t}\n\n\t\ttf[x][y]=0;\n\t\tif(dfs(tx,ty,ts,tc,tm)) return true;\n\t\ttf[x][y]=1;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tsum = 0;\n\t\tsx.clear();\n\t\tsy.clear();\n\n\t\tfor(int i=0; i<100; i++)\n\t\t{\n\t\t\ttb[i/10][i%10] = 0;\n\t\t\ttf[i/10][i%10] = 1;\n\t\t}\n\n\t\tfor(int i=0; i<n*n; i++)\n\t\t{\n\t\t\tcin >> t; sum+=t;\n\t\t\ttb[(i/n)+1][(i%n)+1] = t;\n\n\t\t\tif(t<0)\n\t\t\t{\n\t\t\t\tsx.push_back((i/n)+1);\n\t\t\t\tsy.push_back((i%n)+1);\n\t\t\t}\n\t\t}\n\n\t\t// »è»Ì1\n\t\tif(sum!=0) { cout << \"NO\\n\"; continue; }\n\n\t\tif(dfs(sx[0],sy[0],1,0,tb[sx[0]][sy[0]]))\n\t\t{\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<int> V_sum;\nvector<int> coor;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n\n  if( cur >= V ){\n    return true;\n  }\n\n  if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( field[ny][nx] < 0 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) ) return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    ull initial_state = 0ULL;\n    V = 0;\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n  int n;\n  int x[8][8];\n\n  while( cin>>n && n ){\n    int sum=0;\n\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tcin >> x[i][j];\n\tsum += x[i][j];\n      }\n    if( sum==0 ){\n      cout << \"YES\" << endl;\n    }else\n      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,nn;\nint L[8][8];\nbool u[8][8];\n\nbool ans=false;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nvoid dfs( bool isSearchP,int x,int y, int sum,int nL ){\n  /*\n  if( isSearchP )    cout << \"sP \";\n  else     cout << \"   \";\n  cout << x << \" \" << y << \" \" << sum << \" \" << nL <<endl;\n  */\n  if( ans ) return;\n\n  if( isSearchP ){ // 起点探索\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( u[i][j] ) continue;\n\tif( L[i][j]<0 ){\n\t  //\t  cout << \" 起点：\"<< i << \",\" << j << endl;\n\t  u[i][j]=true;\n\t  dfs( false,i,j,L[i][j],nL-1 );\n\t  if( ans ) return;\n\t  u[i][j]=false;\n\t}\n      }\n    }\n  }else{ // 起点からの線がつながるかをチェック\n    if( nL==0 ){\n      ans = true;      return;\n    }\n    if( sum==0 ){\n      dfs( true,0,0,0,nL ); // 新たな起点を探しにいく\n      if( ans ) return;\n    }\n\n    int nx,ny, ns;\n    for( int i=0;i<4;i++ ){\n      nx=x+dx[i]; ny=y+dy[i];\n      if( u[nx][ny] )     continue;\n      if( nx<0 || nx>=n ) continue;\n      if( ny<0 || ny>=n ) continue;\n      if( L[nx][ny]<0 )   continue;\n      ns = sum + L[nx][ny];\n      if( ns>0 ) continue;\n\n      u[nx][ny]=true;\n      dfs( false,nx,ny,ns,nL-1 );\n      if( ans ) return;\n      u[nx][ny]=false;\n    }\n  }\n}\n\nint main(){\n  while( cin>>n && n ){\n    int sum=0;\n    for( int i=0;i<n;i++ )\n      for( int j=0;j<n;j++ ){\n\tcin >> L[i][j];\n\tsum += L[i][j];\n\tu[i][j] = false;\n      }\n    //    cout << \"sum=\" << sum << endl;\n    ans = false;\n    if( sum==0 )\n      dfs( true,0,0,0,n*n );\n    if( ans ) cout << \"YES\" << endl;\n    else      cout << \"NO\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,B[8][8];\nbool dfs(int y,int x,bool vis[8][8],int sum,int type){\n\tif(type==0){\n\t\tvis[y][x]=true;\n\t\tif(dfs(y,x,vis,B[y][x],1)) return true;\n\t\tvis[y][x]=false;\n\t\treturn false;\n\t}\n\telse{\n\t\tif(sum>0) return false;\n\t\tif(sum==0){\n\t\t\tint yy,xx;\n\t\t\tbool end=true;\n\t\t\trep(i,n) rep(j,n) {\n\t\t\t\tif(!vis[i][j]) end=false;\n\t\t\t\tif(!vis[i][j] && B[i][j]<0) yy=i, xx=j;\n\t\t\t}\n\t\t\tif(end) return true;\n\t\t\treturn dfs(yy,xx,vis,0,0);\n\t\t}\n\t\trep(k,4){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && !vis[yy][xx] && B[yy][xx]>0){\n\t\t\t\tvis[yy][xx]=true;\n\t\t\t\tif(dfs(yy,xx,vis,sum+B[yy][xx],1)) return true;\n\t\t\t\tvis[yy][xx]=false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tint sx,sy;\n\t\trep(i,n) rep(j,n) {\n\t\t\tscanf(\"%d\",B[i]+j);\n\t\t\tif(B[i][j]<0) sy=i, sx=j;\n\t\t}\n\n\t\tbool vis[8][8]={};\n\t\tputs(dfs(sy,sx,vis,0,0)?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint field[8][8] = { { 0 } };\nbool used[8][8] = { { false } };\nvector<int> startX, startY;\n\nbool dfs(int n, int x, int y, int r){\n\tif(r == 0){\n\t\tint usedCount = 0;\n\t\tbool loopFlag = true;\n\t\tfor(int i = 0; i < n && loopFlag; ++i){\n\t\t\tfor(int j = 0; j < n && loopFlag; ++j){\n\t\t\t\tif(used[i][j]){ ++usedCount; }\n\t\t\t\tif(!used[i][j] && field[i][j] < 0){\n\t\t\t\t\tx = j; y = i; loopFlag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(usedCount == n * n){ return true; }\n\t}else if(used[y][x] || field[y][x] < 0){\n\t\treturn false;\n\t}\n\tr -= field[y][x];\n\tif(r < 0){ return false; }\n\tused[y][x] = true;\n\tif(x > 0 && dfs(n, x - 1, y, r)){ return true; }\n\tif(x < n - 1 && dfs(n, x + 1, y, r)){ return true; }\n\tif(y > 0 && dfs(n, x, y - 1, r)){ return true; }\n\tif(y < n - 1 && dfs(n, x, y + 1, r)){ return true; }\n\tused[y][x] = false;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tsum += field[i][j];\n\t\t\t\tused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tcout << (sum == 0 && dfs(n, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <stdio.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef pair<int, int> Point;\ntypedef pair<int, Point> SP;\ntypedef vector<vector<int> > Mat;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint n;\nMat mat;\nvector<vector<bool> > used;\nvector<SP> starts(0);\n \nbool dfs(int cur, int sum, int x, int y) {\n//  cout << x << \", \"<< y << \", \" << sum << endl;\n  if (starts[cur].first == sum) {\n    //cout << \"ok \" << cur << endl;\n    cur++;\n    sum = 0;\n    if (cur >= starts.size()) {\n      return true;\n    }\n    x = starts[cur].second.second;\n    y = starts[cur].second.first;\n  }\n  else if (starts[cur].first < sum) {\n    return false;\n  }\n  for (int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if (0 <= nx && nx < n && 0 <= ny && ny < n && !used[ny][nx]) {\n      used[ny][nx] = true;\n      if (dfs(cur, sum + mat[ny][nx], nx, ny)) return true;\n      used[ny][nx] = false;\n    }\n  }\n  return false;\n  \n}\nvoid solve() {\n  mat = Mat(n, vector<int>(n));\n  used = vector<vector<bool> >(n, vector<bool>(n, false));\n  starts.clear();\n  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      int a;\n      cin >> a;\n      sum += a;\n      if (a < 0) {\n        a *= -1;\n        used[i][j] = true;\n        starts.push_back(SP(a, Point(i, j)));\n      }\n      mat[i][j] = a;\n    }\n  }\n  bool ret = false;;\n  if (sum != 0) {\n    ret = false;\n  }\n  else if (starts.size() == 1) {\n    ret = true;\n  }\n  else {\n    ret = dfs(0, 0, starts[0].second.second, starts[0].second.first);\n  }\n  cout << (ret ? \"YES\" : \"NO\") << endl;\n  return;\n}\n\n\nint main() {\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define MAX 16\n#define INV -128\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\n\nbool dfs(int si, int sj, int n, int map[][MAX], bool vis[][MAX], int now, int left){\n\n  //cout << si << ' ' <<  sj << endl;\n\n  if( now == 0 ){\n    --left;\n    if( left == 0 ){\n      for(int i = 0; i < n; ++i){\n\tfor(int j = 0; j < n; ++j){\n\t  if( !vis[i+1][j+1] ) return false;\n\t}\n      }\n      return true;\n    }else{\n      for(int i = 0; i < n; ++i){\n\tfor(int j = 0; j < n; ++j){\n\t  if( map[i+1][j+1] < 0 && !vis[i+1][j+1] ){\n\t    vis[i+1][j+1]=true;\n\t    if( dfs( i+1,j+1, n, map,vis,-map[i+1][j+1],left) )return true;\n\t    vis[i+1][j+1]=false;\n\t  }\n\t}\n      }\n    }\n  }else{\n    for(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n      int ti = si+di[k];\n      int tj = sj+dj[k];\n      if( map[ti][tj] > 0 && map[ti][tj] != INV && !vis[ti][tj] ){ \n\tvis[ti][tj]=true;\n\tif( dfs( ti, tj, n, map, vis, now-map[ti][tj],left ) ) return true;\n\tvis[ti][tj]=false;\n      }\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    int left=0;\n    bool ans=false;\n    int map[MAX][MAX];\n    bool vis[MAX][MAX];\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < MAX; ++i){\n      for(int j = 0; j < MAX; ++j){\n\tmap[i][j] = INV;\n\tvis[i][j] = false;\n      }\n    }\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tcin >> map[i+1][j+1];\n\tif( map[i+1][j+1] < 0 ) ++left;\n      }\n    }\n\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tif( map[i+1][j+1] < 0 ){\n\t  vis[i+1][j+1]=true;\n\t  if( dfs( i+1, j+1, n, map, vis, -map[i+1][j+1], left ) ) ans = true;\n\t  else ans = false;\n\t  goto END;\n\t}\n      }\n    }\n\n  END:;\n    if( ans ){\n      cout << \"YES\" << endl;\n    }else{\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX 9\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst string Y = \"YES\", N = \"NO\";\nint n,field[MAX][MAX],V;\nvector<int> V_sum;\nvector<int> coor;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\ninline bool isValid(int x,int y){ return 0 <= x && x < n && 0 <= y && y < n; }\n\nbool check(ull used,int cur,int x,int y){\n  int sp_x = x, sp_y = y;\n\n  REP(i,cur,V){\n    ull tmp_used = used;\n    if( i != cur ) sp_x = coor[i] % n, sp_y = coor[i] / n;\n    deque<int> deq;\n    deq.push_back(sp_x+sp_y*n);\n    bool ok = false;\n    int score = V_sum[i];\n    if( score == 0 ) ok = true;\n    while(!deq.empty()){\n      int p = deq.front(); deq.pop_front();\n      int cx = p % n, cy = p / n;\n      if(ok)break;\n      rep(j,4){\n\tint nx = cx + dx[j];\n\tint ny = cy + dy[j];\n\tif(!isValid(nx,ny))continue;\n\tif((tmp_used>>(nx+ny*n))&1)continue;\n\ttmp_used |= (1ULL<<(nx+ny*n));\n\tscore += field[ny][nx];\n\tif( score >= 0 ){\n\t  ok = true;\n\t  break;\n\t}\n\tdeq.push_back(nx+ny*n);\n      }\n    }\n    if(!ok)return false;\n  }\n  return true;\n}\n\nbool dfs(ull used,int cur,int pre,int x,int y,int sum){\n\n  if( cur >= V ){\n    if( used == (1ULL<<(n*n))-1ULL ) return true;\n    return false;\n  }\n\n  //if(!check(used,cur,x,y))return false;\n\n  rep(i,4){\n    if( i == pre ) continue;\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if( !isValid(nx,ny) ) continue;\n    if( (used>>(nx+ny*n)) & 1 ) continue;\n    if( field[ny][nx] < 0 ) continue;\n    if( sum + field[ny][nx] > V_sum[cur] ) continue;\n\n    int ncur = cur;\n    int npre = ( i + 2 ) % 4;\n    int nsum = sum + field[ny][nx];\n    ull nused = used | (1ULL<<(nx+ny*n));\n    if( sum + field[ny][nx] == V_sum[cur] ){\n      ncur++;\n      npre = -1;\n      nsum = 0;\n      nx = coor[ncur] % n;\n      ny = coor[ncur] / n;\n    }\n    if( dfs(nused,ncur,npre,nx,ny,nsum) ) return true;\n  }\n\n  return false;  \n}\n\nint main(){\n\n  while( scanf(\"%d\",&n), n ){\n    //visited.clear();\n    ull initial_state = 0ULL;\n    V = 0;\n    coor.clear();\n    V_sum.clear();\n    int sum = 0;\n    rep(i,n)rep(j,n){\n      scanf(\"%d\",&field[i][j]);\n      sum += field[i][j];\n      if( field[i][j] < 0 ){\n\tV++;\n\tull tmp = (1ULL<<(j+i*n));\n\tcoor.push_back(j+i*n);\n\tinitial_state |= (1ULL<<(j+i*n));\n\tV_sum.push_back(-field[i][j]);\n      }\n    }\n    /*\n    if( sum != 0 ){\n      cout << N << endl;\n      continue;\n    }\n    */\n    bool res = dfs(initial_state,0,-1,coor[0]%n,coor[0]/n,0);\n    cout << (res?Y:N) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n#include <iostream>\n#include <set>\n\nusing namespace std;\n\n#define GU (-100)\n\nlist<unsigned long long> LineData[32];\nset<unsigned long long> come_flag;\nint map[8 + 2][8 + 2];\nint n;\n\nint make_line(int x, int y, int now, int goal, unsigned long long flag, int start_id)\n{\n\tif (now == goal){\n\t\tLineData[start_id].push_back(flag);\n\t\treturn (0);\n\t}\n\t\n\tif (map[x][y] <= 0 || now > goal || (flag >> ((y - 1) * 8 + (x - 1))) & 1 == 1){\n\t\treturn (0);\n\t}\n\t\n\tnow += map[x][y];\n\tint d = (((y - 1) * 8) +  (x - 1));\n\t\n\t*(((int *)(&flag)) + (d / 32)) |= 1 << (d % 32);\n\t\n\tmake_line(x + 1, y, now, goal, flag, start_id);\n\tmake_line(x - 1, y, now, goal, flag, start_id);\n\tmake_line(x, y + 1, now, goal, flag, start_id);\n\tmake_line(x, y - 1, now, goal, flag, start_id);\n\t\n\treturn (0);\n}\n\nbool is_clear(int depth, int start_cnt, unsigned long long flag)\n{\n\tlist<unsigned long long>::iterator it;\n\t\n\tif (depth == start_cnt){\n\t\tint st_cnt;\n\t\tst_cnt = 0;\n\t\tfor (int i = 0; i < 64; i++){\n\t\t\tst_cnt += (flag >> i) & 1;\n\t\t}\n\t\treturn (st_cnt == n * n ? true : false);\n\t}\n\t\n\tif (come_flag.find(flag) == come_flag.end()){\n\t\tcome_flag.insert(flag);\n\t\t\n\t\tfor (it = LineData[depth].begin(); it != LineData[depth].end(); it++){\n\t\t\tif (flag ^ *it == flag | *it && is_clear(depth + 1, start_cnt, flag | *it) == true){\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (false);\n}\n\nint main(void)\n{\n\tint start_cnt;\n\tlong long start_flag;\n\t\n\twhile (1){\n\t\tfor (int i = 0; i < 32; i++){\n\t\t\tLineData[i].clear();\n\t\t}\n\t\tfor (int y = 0; y < 10; y++){\n\t\t\tfor (int x = 0; x < 10; x++){\n\t\t\t\tmap[x][y] = GU;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\t\n\t\tfor (int y = 1; y <= n; y++){\n\t\t\tfor (int x = 1; x <= n; x++){\n\t\t\t\tscanf(\"%d\", &map[x][y]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tstart_cnt = start_flag = 0;\n\t\tfor (int y = 1; y <= n; y++){\n\t\t\tfor (int x = 1; x <= n; x++){\n\t\t\t\tif (map[x][y] < 0){\n\t\t\t\t\tmake_line(x + 1, y, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x - 1, y, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x, y + 1, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tmake_line(x, y - 1, 0, -map[x][y], 0, start_cnt);\n\t\t\t\t\tint d = ((y - 1) * 8 +  (x - 1));\n\t\t\t\t\t*(((int *)(&start_flag)) + (d / 32)) |= 1 << (d % 32);\n\t\t\t\t\tstart_cnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < start_cnt; i++){\n\t\t\tLineData[i].sort();\n\t\t\tLineData[i].unique();\n#if 0\n\t\t\tfor (list<unsigned long long>::iterator it = LineData[i].begin(); it != LineData[i].end(); it++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = 0; i < 8; i++){\n\t\t\t\t\tfor (int j = 0; j < 8; j++){\n\t\t\t\t\t\tprintf(\"%d\", (*it >> i * 8 + j) & 1);\n\t\t\t\t\t\tif ((*it >> i * 8 + j) & 1 == 1){\n\t\t\t\t\t\t\tsum += map[j + 1][i + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tputs(\"\");\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", sum);\n\t\t\t//\tgetch();\n\t\t\t}\n#endif\n\t\t}\n\t\tprintf(\"%s\\n\", is_clear(0, start_cnt, start_flag) == true ? \"YES\" : \"NO\");\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint n,B[8][8];\nbool dfs(int y,int x,bool vis[8][8],int sum,int type){\n\tif(type==0){\n\t\tvis[y][x]=true;\n\t\tif(dfs(y,x,vis,B[y][x],1)) return true;\n\t\tvis[y][x]=false;\n\t\treturn false;\n\t}\n\telse{\n\t\tif(sum>0) return false;\n\t\tif(sum==0){\n\t\t\tint yy=-1,xx;\n\t\t\tbool end=true;\n\t\t\trep(i,n) rep(j,n) {\n\t\t\t\tif(!vis[i][j]) end=false;\n\t\t\t\tif(!vis[i][j] && B[i][j]<0){\n\t\t\t\t\tif(yy==-1 || B[i][j]<B[yy][xx]) yy=i, xx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) return true;\n\t\t\treturn dfs(yy,xx,vis,0,0);\n\t\t}\n\t\trep(k,4){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(0<=yy && yy<n && 0<=xx && xx<n && !vis[yy][xx] && B[yy][xx]>0){\n\t\t\t\tvis[yy][xx]=true;\n\t\t\t\tif(dfs(yy,xx,vis,sum+B[yy][xx],1)) return true;\n\t\t\t\tvis[yy][xx]=false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tint sy=-1,sx;\n\t\trep(i,n) rep(j,n) {\n\t\t\tscanf(\"%d\",B[i]+j);\n\t\t\tif(B[i][j]<0){\n\t\t\t\tif(sy==-1 || B[i][j]<B[sy][sx]) sy=i, sx=j;\n\t\t\t}\n\t\t}\n\n\t\tbool vis[8][8]={};\n\t\tputs(dfs(sy,sx,vis,0,0)?\"YES\":\"NO\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint n;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(y>=0&&y<n&&x>=0&&x<n)\n\t\treturn true;\n\treturn false;\n}\nbool cal(vector<vector<int> >/*,int*/);\nbool f(vector<vector<int> > v,int y,int x,int left/*,int sy*/){\n\tif(!left){\n\t\t//bool x=cal(v);\n\t\t//cout<<x<<endl;\n\t\treturn cal(v/*,sy*/);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\tif(inf(ny,nx)&&v[ny][nx]>0&&left-v[ny][nx]>=0){\n\t\t\tint temp=v[ny][nx];\n\t\t\tv[ny][nx]=0;\n\t\t\tif(f(v,ny,nx,left-temp/*,sy*/)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tv[ny][nx]=temp;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nbool cal(vector<vector<int> > v/*,int y*/){\n\t/*cout<<\"--------\"<<endl;\n\tfor(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++)\n\tcout<<v[i][j];\n\t\tcout<<endl;\n\t}*/\n\tbool flag=true;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++){\n\t\tif(v[i][j]!=0)\n\t\t\tflag=false;\n\t\tif(v[i][j]<0){\n\t\t\tint temp=v[i][j];\n\t\t\tv[i][j]=0;\n\t\t\tif(f(v,i,j,-temp/*,i*/))\n\t\t\t\treturn true;\n\t\t\tv[i][j]=temp;\n\t\t}\n\t}\n\tif(flag)\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tvector<vector<int> > v(n,vector<int>(n));\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>v[i][j];\n\t\t}\n\t\tif(cal(v))\n\t\tcout<<\"YES\"<<endl;\n\t\telse\n\t\tcout<<\"NO\"<<endl;\n\t\tcout<<cal(v/*,0*/)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a) 0<=a&&a<n\nusing namespace std;\nint n,f[8][8],dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nbool dfs(int sy,int sx,int fy,int fx,int r){\n\tbool a=0;\n\tif(r>0)return 0;\n\tif(r==0){\n\t\tfor(;sy<n&&(sx>=n||f[sy][sx]>=0);sx++)if(sx>=n)sx=-1,sy++;\n\t\tif(sy<n){\n\t\t\tr=f[sy][sx];f[sy][sx]=0;\n\t\t\ta=dfs(sy,sx,sy,sx,r);\n\t\t\tf[sy][sx]=r;\n\t\t\treturn a;\n\t\t}\n\t\ta=1;rep(i,n)rep(j,n)if(f[i][j])a=0;\n\t\treturn a;\n\t}\n\trep(d,4){\n\t\tint ny=fy+dy[d],nx=fx+dx[d],t;\n\t\tif(ck(ny)&&ck(nx)&&f[ny][nx]>0&&f[ny][nx]+r<=0){\n\t\t\tt=f[ny][nx];f[ny][nx]=0;\n\t\t\ta=a||dfs(sy,sx,ny,nx,r+t);\n\t\t\tf[ny][nx]=t;\n\t\t\tif(a)return a;\n\t\t}\n\t}\n\treturn a;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\trep(i,n)rep(j,n)cin>>f[i][j];\n\t\tcout<<(dfs(0,0,0,0,0)?\"YES\":\"NO\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 8\n\nint F[MAX_N][MAX_N];\nint n;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nbool finished();\nbool dfs(int, int , int);\nbool solve();\n\nbool finished() {\n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j]) {\n                //printf(\"i: %d, j: %d\\n\", i, j);\n                return false;\n            }\n    //printf(\"returning true...\\n\");\n    return true;\n}\n\nvoid debug() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%d \", F[i][j]);\n        }\n        puts(\"\");\n    }\n}\n\nbool dfs(int y, int x, int c) {\n    if (c == 0) {\n        //debug();\n        //printf(\"calling finish()\\n\");\n        if (finished()) return true;\n        return solve();\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < n && 0 <= ny && ny < n && F[ny][nx] > 0) {\n            int f = F[ny][nx];\n            F[ny][nx] = 0;\n            bool res = dfs(ny, nx, c+f);\n            F[ny][nx] = f;\n            if (res) return true;\n        }\n    }\n}\n\nbool solve() {\n    bool res = true;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (F[i][j] < 0) {\n                int f = F[i][j];\n                F[i][j] = 0;\n                if (!dfs(i, j, f)) \n                    res = false;\n                else\n                    return true;\n                F[i][j] = f;\n                if (!res) break;\n            }\n            if (!res) break;\n        }\n    }\n    if (!res) return false;\n    \n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j] != 0) \n                return false;\n    return true;\n}\n\nint main() {\n    while (scanf(\"%d\", &n), n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int p; scanf(\"%d\", &p);\n                F[i][j] = p;\n            }\n        }\n        puts(solve() ? \"YES\" : \"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint N,table[8][8];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nbool FLG,check[8][8];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= N-1 && col >= 0 && col <= N-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid dfs(int sum,int tmp_row,int tmp_col,int rest){\n\n\tif(FLG) return;\n\n\tif(sum == 0 && rest == 0){\n\t\tFLG = true;\n\t\treturn;\n\t}\n\n\tif(sum == 0){\n\n\t\tfor(int row = 0; row < N; row++){\n\t\t\tfor(int col = 0; col < N; col++){\n\t\t\t\tif(check[row][col])continue;\n\t\t\t\tif(table[row][col] < 0){\n\t\t\t\t\tcheck[row][col] = true;\n\t\t\t\t\tdfs(abs(table[row][col]),row,col,rest-1);\n\t\t\t\t\tcheck[row][col] = false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t  }else{\n\n\t\t  for(int i = 0; i < 4; i++){\n\t\t\t  int adj_row = tmp_row+diff_row[i];\n\t\t\t  int adj_col = tmp_col+diff_col[i];\n\n\t\t\t  if(rangeCheck(adj_row,adj_col) == false || check[adj_row][adj_col] == true || table[adj_row][adj_col] < 0 || sum < table[adj_row][adj_col])continue;\n\n\t\t\t  check[adj_row][adj_col] = true;\n\t\t\t  dfs(sum-table[adj_row][adj_col],adj_row,adj_col,rest-1);\n\t\t\t  check[adj_row][adj_col] = false;\n\t\t  }\n\t  }\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++){\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t\tcheck[row][col] = false;\n\t\t}\n\t}\n\n\tFLG = false;\n\n\tdfs(0,0,0,N*N);\n\n\tif(FLG){\n\t\tprintf(\"YES\\n\");\n\t}else{\n\t\tprintf(\"NO\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint table[ 10 ][ 10 ];\nint visited[ 10 ][ 10 ];\nint n;\n\ntypedef pair<int, int> pii;\n\nvoid print() {\n  for ( int i = 1; i <= n; i++ ) {\n\tfor ( int j = 1; j <= n; j++ ) {\n\t  cerr << visited[ i ][ j ] << \", \";\n\t}\n\tcerr << endl;\n  }\n  cerr << endl;\n  for ( int i = 1; i <= n; i++ ) {\n\tfor ( int j = 1; j <= n; j++ ) {\n\t  cerr << table[ i ][ j ] << \", \";\n\t}\n\tcerr << endl;\n  }\n  cerr << endl;\n}\n\nbool check() {\n  for ( int i = 1; i <= n; i++ ) {\n\tfor ( int j = 1; j <= n; j++ ) {\n\t  if ( visited[ i ][ j ] < 0 ) {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}\n\nbool is_same_sum() {\n  int sum_neg = 0;\n  int sum_pos = 0;\n  for ( int i = 1; i <= n; i++ ) {\n\tfor ( int j = 1; j <= n; j++ ) {\n\t  if ( table[ i ][ j ] > 0 ) {\n\t\tsum_pos += table[ i ][ j ];\n\t  } else {\n\t\tsum_neg -= table[ i ][ j ];\n\t  }\n\t}\n  }\n  return sum_pos == sum_neg;\n}\n\nbool is_global_fin;\n\nint dx[ 4 ] = { 0, 1, 0, -1 };\nint dy[ 4 ] = { 1, 0, -1, 0 };\nvoid dfs( vector<pii> &ss, int index, int local_sum, int y, int x ) {\n  visited[ y ][ x ] = index;\n  for ( int i = 0; i < 4; i++ ) {\n\tif ( is_global_fin ) return;\n\tint ny = y + dy[ i ];\n\tint nx = x + dx[ i ];\n\tif ( visited[ ny ][ nx ] < 0 &&\n\t\t table[ ny ][ nx ] > 0 ) {\n\t  if ( local_sum + table[ ny ][ nx ] == -table[ ss[ index ].first ][ ss[ index ].second ] ) {\n\t\tvisited[ ny ][ nx ] = index;\n\t\tif ( index + 1 == ss.size() && check() ) {\n\t\t  is_global_fin = true;\n\t\t} else {\n\t\t  dfs( ss, index + 1, 0, ss[ index + 1 ].first, ss[ index + 1 ].second );\n\t\t}\n\t\tif ( !is_global_fin ) {\n\t\t  visited[ ny ][ nx ] = -1;\n\t\t}\n\t  } else if ( local_sum + table[ ny ][ nx ] < -table[ ss[ index ].first ][ ss[ index ].second ] ) {\n\t\tdfs( ss, index, local_sum + table[ ny ][ nx ], ny, nx );\n\t  }\n\t}\n  }\n  visited[ y ][ x ] = -1;\n}\n\nbool solve( vector<pii> &ss ) {\n  if ( !is_same_sum() ) {\n\treturn false;\n  } else {\n\tis_global_fin = false;\n\tdfs( ss, 0, 0, ss[ 0 ].first, ss[ 0 ].second );\n\treturn is_global_fin;\n  }\n}  \n\nint main() {\n  while ( true ) {\n\tcin >> n;\n\tif ( n == 0 ) break;\n\t\n\tfor ( int i = 1; i <= 8; i++ ) {\n\t  for ( int j = 1; j <= 8; j++ ) {\n\t\ttable[ i ][ j ] = 0;\n\t\tvisited[ i ][ j ] = -1;\n\t  }\n\t}\n\tvector<pii> ss;\n\tfor ( int i = 1; i <= n; i++ ) {\n\t  for ( int j = 1; j <= n; j++ ) {\n\t\tcin >> table[ i ][ j ];\n\t\tif ( table[ i ][ j ] < 0 ) {\n\t\t  ss.push_back( make_pair( i, j ) );\n\t\t}\n\t  }\n\t}\n\tif ( solve( ss ) ) {\n\t  cout << \"YES\" << endl;\n\t} else {\n\t  cout << \"NO\" << endl;\n\t}\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[] = {+1,-1, 0, 0};\nint dy[] = { 0, 0,+1,-1};\nint tb[10][10];\nint tf[10][10];\n\nint n,t,sum;\nvector<int> sx,sy;\n\nbool dfs(int x, int y, int s, int c, int m)\n{\n\t//cout << x << \" \" << y << \" \" << s << \" \" << c << \" \" << m << endl;\n\n\tint tx,ty,ts,tc,tm,f;\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tf  = false;\n\t\ttc = c;\n\t\tts = s+1;\n\t\ttx = x+dx[i];\n\t\tty = y+dy[i];\n\t\ttm = m+tb[tx][ty];\n\n\t\tif(tf[tx][ty]==0) continue;\n\t\tif(tb[tx][ty]<=0) continue;\n\n\t\tif(tm>0) continue;\n\t\tif(tm==0)\n\t\t{\n\t\t\ttc++;\n\n\t\t\tif(tc==sx.size())\n\t\t\t{\n\t\t\t\tif(ts==n*n)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tts++;\n\t\t\ttx = sx[tc];\n\t\t\tty = sy[tc];\n\t\t\ttm = tb[tx][ty];\n\t\t\tf  = true;\n\t\t\ttf[x+dx[i]][y+dy[i]]=0;\n\t\t}\n\n\t\ttf[x][y]=0;\n\t\tif(dfs(tx,ty,ts,tc,tm)) return true;\n\t\ttf[x][y]=1;\n\n\t\tif(f)\n\t\t{\n\t\t\ttf[x+dx[i]][y+dy[i]]=1;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tsum = 0;\n\t\tsx.clear();\n\t\tsy.clear();\n\n\t\tfor(int i=0; i<100; i++)\n\t\t{\n\t\t\ttb[i/10][i%10] = 0;\n\t\t\ttf[i/10][i%10] = 1;\n\t\t}\n\n\t\tfor(int i=0; i<n*n; i++)\n\t\t{\n\t\t\tcin >> t; sum+=t;\n\t\t\ttb[(i/n)+1][(i%n)+1] = t;\n\n\t\t\tif(t<0)\n\t\t\t{\n\t\t\t\tsx.push_back((i/n)+1);\n\t\t\t\tsy.push_back((i%n)+1);\n\t\t\t}\n\t\t}\n\n\t\tcout << sum << endl;\n\n\t\t// »è»Ì1\n\t\tif(sum!=0) { cout << \"NO\\n\"; continue; }\n\n\t\tif(dfs(sx[0],sy[0],1,0,tb[sx[0]][sy[0]]))\n\t\t{\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint N;\nint K;\nint a[64][64];\nint bx[64];\nint by[64];\nbool used[64][64];\nbool dfs(int k, int sum, int sx, int sy){\n  //printf(\"dfs : k = %d sum = %d sx = %d sy = %d\\n\", k, sum, sx, sy);\n  if(k == K){\n    bool ok = true;\n    REP(y, N)REP(x, N) if(!used[y][x] && a[y][x] > 0) ok = false;\n    return ok;\n  }\n  REP(r, 4){\n    int nx = sx + dx[r];\n    int ny = sy + dy[r];\n    if(valid(nx, ny, N, N) && !used[ny][nx] && a[ny][nx] > 0){\n      used[ny][nx] = true;\n      if(sum - a[ny][nx] < 0){\n      }else if(sum - a[ny][nx] == 0){\n        if(k + 1 == K) {\n          if(dfs(k + 1, 0, 0, 0)) return true;\n        }else{\n          if(dfs(k + 1, -a[by[k + 1]][bx[k + 1]], bx[k + 1], by[k + 1])) return true;\n        }\n      }else if(sum - a[ny][nx] > 0){\n        if(dfs(k, sum - a[ny][nx], nx, ny)) return true;\n      }\n      used[ny][nx] = false;\n    }\n  }\n  return false;\n}\nint main(){\n  while(cin>>N && N){\n    REP(i, N)REP(j, N) cin>>a[i][j];\n    K = 0;\n    REP(i, N)REP(j, N)if(a[i][j] < 0){\n      by[K] = i;\n      bx[K] = j;\n      K++;\n    }\n    memset(used, 0, sizeof(used));\n    bool ans = dfs(0, -a[by[0]][bx[0]], bx[0], by[0]);\n    if(ans) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint field[8][8] = { { 0 } };\nbool used[8][8] = { { false } };\nvector<int> startX, startY;\n\nbool dfs(int n, int x, int y, int r, int k){\n\tif(r == 0){\n\t\tif(k == startX.size()){ return true; }\n\t\tx = startX[k];\n\t\ty = startY[k];\n\t\t++k;\n\t}else if(used[y][x] || field[y][x] < 0){\n\t\treturn false;\n\t}\n\tr -= field[y][x];\n\tif(r < 0){ return false; }\n\tused[y][x] = true;\n\tif(x > 0 && dfs(n, x - 1, y, r, k)){ return true; }\n\tif(x < n - 1 && dfs(n, x + 1, y, r, k)){ return true; }\n\tif(y > 0 && dfs(n, x, y - 1, r, k)){ return true; }\n\tif(y < n - 1 && dfs(n, x, y + 1, r, k)){ return true; }\n\tused[y][x] = false;\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tsum += field[i][j];\n\t\t\t\tif(field[i][j] < 0){\n\t\t\t\t\tstartX.push_back(j);\n\t\t\t\t\tstartY.push_back(i);\n\t\t\t\t}\n\t\t\t\tused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tcout << (sum == 0 && dfs(n, 0, 0, 0, 0) ? \"YES\" : \"NO\") << endl;\n\t\tstartX.clear();\n\t\tstartY.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nvoid disp(int stage[12][12], const int stage_size){\n  for(int y = 0; y < stage_size; y++){\n    for(int x = 0; x < stage_size; x++){\n      printf(\"%d \",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nclass Cell {\npublic:\n  int x;\n  int y;\n  int energy;\n  Cell(int x,int y,int energy)\n    : x(x), y(y), energy(energy) {}\n};\n\nbool check_all_zero(int stage[12][12], const int stage_size){\n  for(int y = 0; y < stage_size; y++){\n    for(int x = 0; x < stage_size; x++){\n      if(stage[y][x] != 0) return false;\n    }\n  }\n  return true;\n}\n\nCell find_starting_point(int stage[12][12], const int stage_size){\n  for(int y = 0; y < stage_size; y++){\n    for(int x = 0; x < stage_size; x++){\n      if(stage[y][x] < 0){\n        return Cell(x,y,-stage[y][x]);\n      }\n    }\n  }\n  return Cell(-1,-1,0);\n}\n\nbool dfs(int stage[12][12], const int stage_size,\n         int sx, int sy,int life){\n  bool res = false;\n  if(life < 0){\n    return false;\n  }\n  if(life == 0){\n    if(check_all_zero(stage,stage_size)){\n      return true;\n    }\n    else{\n      Cell c = find_starting_point(stage,stage_size);\n      if(c.x == -1 && c.y == -1) return false;\n      stage[c.y][c.x] = 0;\n      res |= dfs(stage,stage_size,c.x,c.y,c.energy);\n      stage[c.y][c.x] = -c.energy;\n    }\n  }\n\n  for(int i = 0; i < 4; i++){\n    int dx = tx[i] + sx;\n    int dy = ty[i] + sy;\n    if(dx < 0 || dy < 0 || dx >= stage_size || dy >= stage_size){\n      continue;\n    }\n    if(stage[dy][dx] <= 0){\n      continue;\n    }\n    if(life - stage[dy][dx] < 0){\n      continue;\n    }\n\n    int tmp = stage[dy][dx];\n    stage[dy][dx] = 0;\n    res |= dfs(stage,stage_size,dx,dy,life - tmp);\n    stage[dy][dx] = tmp;\n  }\n  return res;\n}\n\nint main(){\n  int stage_size;\n  while(~scanf(\"%d\",&stage_size)){\n    if(stage_size == 0) break;\n    int stage[12][12];\n    for(int y = 0; y < stage_size; y++){\n      for(int x = 0; x < stage_size; x++){\n        scanf(\"%d\",&stage[y][x]);\n      }\n    }\n\n    printf(\"%s\\n\",dfs(stage,stage_size,0,0,0) ? \"YES\" : \"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define MAX 16\n#define INV -128\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\n\nbool dfs(int si, int sj, int n, int map[][MAX], bool vis[][MAX], int now, int left){\n\n  //cout << si << ' ' <<  sj << endl;\n\n  //if( now > 0 ) return false;\n\n  if( now == 0 ){\n    --left;\n    if( left == 0 ){\n      for(int i = 0; i < n; ++i){\n\tfor(int j = 0; j < n; ++j){\n\t  if( !vis[i+1][j+1] ) return false;\n\t}\n      }\n      return true;\n    }else{\n      for(int i = 0; i < n; ++i){\n\tfor(int j = 0; j < n; ++j){\n\t  if( map[i+1][j+1] < 0 && !vis[i+1][j+1] ){\n\t    vis[i+1][j+1]=true;\n\t    if( dfs( i+1,j+1, n, map,vis,map[i+1][j+1],left) )return true;\n\t    vis[i+1][j+1]=false;\n\t    return false;\n\t  }\n\t}\n      }\n    }\n  }else{\n    for(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n      int ti = si+di[k];\n      int tj = sj+dj[k];\n      if( map[ti][tj] > 0 && map[ti][tj] != INV && !vis[ti][tj] && now+map[ti][tj] <= 0){ \n\tvis[ti][tj]=true;\n\tif( dfs( ti, tj, n, map, vis, now+map[ti][tj],left ) ) return true;\n\tvis[ti][tj]=false;\n      }\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    int left=0;\n    bool ans=false;\n    int map[MAX][MAX];\n    bool vis[MAX][MAX];\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < MAX; ++i){\n      for(int j = 0; j < MAX; ++j){\n\tmap[i][j] = INV;\n\tvis[i][j] = false;\n      }\n    }\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tcin >> map[i+1][j+1];\n\tif( map[i+1][j+1] < 0 ) ++left;\n      }\n    }\n\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tif( map[i+1][j+1] < 0 ){\n\t  vis[i+1][j+1]=true;\n\t  if( dfs( i+1, j+1, n, map, vis, map[i+1][j+1], left ) ) ans = true;\n\t  else ans = false;\n\t  goto END;\n\t}\n      }\n    }\n\n  END:;\n    if( ans ){\n      cout << \"YES\" << endl;\n    }else{\n      cout << \"NO\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\nint n;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(y>=0&&y<n&&x>=0&&x<n)\n\t\treturn true;\n\treturn false;\n}\nbool cal(vector<vector<int> >/*,int*/);\nbool f(vector<vector<int> > v,int y,int x,int left/*,int sy*/){\n\tif(!left){\n\t\t//bool x=cal(v);\n\t\t//cout<<x<<endl;\n\t\treturn cal(v/*,sy*/);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\tif(inf(ny,nx)&&v[ny][nx]>0&&left-v[ny][nx]>=0){\n\t\t\tint temp=v[ny][nx];\n\t\t\tv[ny][nx]=0;\n\t\t\tif(f(v,ny,nx,left-temp/*,sy*/)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tv[ny][nx]=temp;\n\t\t}\n\t}\n\treturn false;\n\t\n}\n\nbool cal(vector<vector<int> > v/*,int y*/){\n\t/*cout<<\"--------\"<<endl;\n\tfor(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++)\n\tcout<<v[i][j];\n\t\tcout<<endl;\n\t}*/\n\tbool flag=true;\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++){\n\t\tif(v[i][j]!=0)\n\t\t\tflag=false;\n\t\tif(v[i][j]<0){\n\t\t\tint temp=v[i][j];\n\t\t\tv[i][j]=0;\n\t\t\tif(f(v,i,j,-temp/*,i*/))\n\t\t\t\treturn true;\n\t\t\tv[i][j]=temp;\n\t\t}\n\t}\n\tif(flag)\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tvector<vector<int> > v(n,vector<int>(n));\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>v[i][j];\n\t\t}\n\t\tcout<<cal(v/*,0*/)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define Rep(i,n) for(int i = 0; i < n; i++)\n\nbool dfs(int, int);\nint dfs2( int, int, const int, const int, int);\n\nint n, number[8][8];\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\n\nint dfs2(int x, int y, const int basex, const int basey, int sub){\n  if(sub < 0) return false;\n  if(sub == 0) return dfs( basex + 1, basey);\n\n  Rep(i,4){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny < 0 || ny >= n || nx < 0 || nx >= n || number[ny][nx] == 0) continue;\n    int next = number[ny][nx];\n    number[ny][nx] = 0;\n    if(dfs2( ny, nx, basex, basey, sub - next)) return true;\n    number[ny][nx] = next;\n  }\n  return false;\n}\n\nbool dfs(int x, int y){\n\n  if(y == n){\n    Rep(i,n) Rep(j,n) if(number[i][j] != 0) return false;\n    return true;\n  }\n  if(x == n || number[y][x] == 0) return dfs( 0, y + 1);\n  if(number[y][x] > 0) return dfs( x + 1, y);\n  if(number[y][x] < 0){\n    int prev = number[y][x];\n    number[y][x] = prev;\n    dfs2( x, y, x, y, prev);\n  }\n}\n\nint main(){\n  while(cin >> n, n){\n\n    int ret = 0;\n    Rep(i,n){\n      Rep(j,n){\n        cin >> number[i][j];\n        ret += number[i][j];\n      }\n    }\n    if(ret == 0 && dfs(0,0)) puts(\"YES\");\n    else puts(\"NO\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 8\n\nint F[MAX_N][MAX_N];\nint n;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nbool finished();\nbool dfs(int, int , int);\nbool solve();\n\nbool finished() {\n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j]) {\n                //printf(\"i: %d, j: %d\\n\", i, j);\n                return false;\n            }\n    //printf(\"returning true...\\n\");\n    return true;\n}\n\nvoid debug() {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            printf(\"%d \", F[i][j]);\n        }\n        puts(\"\");\n    }\n}\n\nbool dfs(int y, int x, int c) {\n    if (c == 0) {\n        //debug();\n        //printf(\"calling finish()\\n\");\n        if (finished()) return true;\n        return solve();\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < n && 0 <= ny && ny < n && F[ny][nx] > 0) {\n            int f = F[ny][nx];\n            F[ny][nx] = 0;\n            bool res = dfs(ny, nx, c+f);\n            F[ny][nx] = f;\n            if (res) return true;\n        }\n    }\n}\n\nbool solve() {\n    bool res = true;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (F[i][j] < 0) {\n                int f = F[i][j];\n                F[i][j] = 0;\n                if (dfs(i, j, f)) \n                    return true;\n                F[i][j] = f;\n            }\n        }\n    }\n    \n    for (int i = 0; i < n; i++) \n        for (int j = 0; j < n; j++) \n            if (F[i][j] != 0) \n                return false;\n    return true;\n}\n\nint main() {\n    while (scanf(\"%d\", &n), n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int p; scanf(\"%d\", &p);\n                F[i][j] = p;\n            }\n        }\n        puts(solve() ? \"YES\" : \"NO\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#define pb push_back\nusing namespace std;\ntypedef pair<int,int> P;\nint n;\nvector<P> rt;\n//map<vector<vector<int> >,bool> mp;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nbool inf(int y,int x){\n\tif(y>=0&&y<n&&x>=0&&x<n)\n\t\treturn true;\n\treturn false;\n}\nbool cal(vector<vector<int> >&,int);\nbool f(vector<vector<int> > v,int y,int x,int left,int now){\n\tif(!left){\n\t\treturn cal(v,now+1);\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tint ny=dy[i]+y,nx=dx[i]+x;\n\t\tif(inf(ny,nx)&&v[ny][nx]>0&&left-v[ny][nx]>=0){\n\t\t\tint temp=v[ny][nx];\n\t\t\tv[ny][nx]=0;\n\t\t\tif(f(v,ny,nx,left-temp,now)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tv[ny][nx]=temp;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool cal(vector<vector<int> > &v,int now){\n\tif(now==rt.size()){\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\tif(v[i][j]!=0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tint y=rt[now].first;\n\tint x=rt[now].second;\n\tint temp=v[y][x];\n\tv[y][x]=0;\n\tif(f(v,y,x,-temp,now))\n\t\treturn true;\n\treturn false;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tvector<vector<int> > v(n,vector<int>(n));\n\t\trt.clear();\n\t\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++){\n\t\t\tcin>>v[i][j];\n\t\t\tif(v[i][j]<0)\n\t\t\trt.pb(P(i,j));\n\t\t}\n\t\tif(cal(v,0))\n\t\tcout<<\"YES\"<<endl;\n\t\t\telse\n\t\tcout<<\"NO\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void) {\n\tint num,sum,i,temp,flag1,flag2;\n\twhile (1) {\n\t\tscanf(\"%d\",&num);\n\t\tif (num==0) break;\n\t\tsum=0,flag2=0;\n\t\tfor (i=0; i<num*num; i++) {\n\t\t\tif (i!=0&&i!=num&&i%num==0) {\n\t\t\t\tif (sum*flag1<0) {\n\t\t\t\t\tflag2=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%d\",&temp);\n\t\t\tsum+=temp;\n\t\t\tif (i==num-1) {\n\t\t\t\tflag1=sum;\n\t\t\t}\n\t\t}\n\t\tif (sum==0&&flag2==0) {\n\t\t\tprintf(\"YES\\n\");\n\t\t} else {\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1034: Line Puzzle\n// 2017.9.29 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 8\n#define N2 66\n\ntypedef struct { signed char r, c, s, t; } T;\nT start[N2]; int m;\n\nsigned char map[N][N]; int n, n2;\nint mv[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};\n\nint cmp(T *a, T *b)\n{\n\tif (b->s - a->s) return b->s - a->s;\n\tif (b->r - a->r) return b->r - a->r;\n\treturn a->c - b->c;\n}\n\nvoid print(signed char a[N][N])\n{\n\tint r, c;\n\n\tfor (r = 0; r < n; r++) {\n\t\tfor (c = 0; c < n; c++) printf(\"%3d \", a[r][c]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint combi(signed char a[N][N], int m0, int n0)\n{\n\tint i, j, f, r, c, s, t, r2, c2, ss, goal;\n\tsigned char tmp[N][N], mk[N2][2];\n\tT q[N2]; int top;\n\n\tif (m0 >= m && n0 >= n2) return 1;\n\tq[0].r = start[m0].r, q[0].c = start[m0].c, q[0].s = 0, q[0].t = 0, top = 1;\n\tgoal = start[m0].s;\n\twhile (top > 0) {\n\t\tr = q[--top].r, c = q[top].c, s = q[top].s, t = q[top].t;\n\t\tmk[t][0] = r, mk[t][1] = c;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 < 0 || r2 >= n || c2 < 0 || c2 >= n || a[r2][c2] <= 0) continue;\n\t\t\tfor (f = j = 0; j <= t; j++) {\n\t\t\t\tif (mk[j][0] == r2 && mk[j][1] == c2) { f = 1; break; }\n\t\t\t}\n\t\t\tif (f) continue;\n\t\t\tss = s + a[r2][c2];\n\t\t\tif (ss < goal) {\n\t\t\t\tq[top].r = r2, q[top].c = c2, q[top].s = ss, q[top++].t = t + 1;\n\t\t\t} else if (ss == goal) {\n\t\t\t\tmemcpy(tmp, a, sizeof(tmp));\n\t\t\t\tfor (j = 1; j <= t; j++) tmp[mk[j][0]][mk[j][1]] = 0;\n\t\t\t\ttmp[r2][c2] = 0;\n//print(tmp);\n\t\t\t\tif (combi(tmp, m0+1, n0+t+2)) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint r, c, t, s;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tn2 = n*n;\n\t\tfor (s = m = 0, r = 0; r < n; r++) for (c = 0; c < n; c++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t < 0) start[m].r = r, start[m].c = c, start[m++].s = -t;\n\t\t\tmap[r][c] = t, s += t;\n\t\t}\n\t\tqsort(start, m, sizeof(T), cmp);\n\t\tputs(s == 0 && combi(map, 0, 0) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1034\n  Title:Line Puzzle\n  @kankichi573\n  2014/02/22 TLE 10.37sec 0/1\n*/\n#include <stdio.h>\n// #include <stdlib.h>\n// #include <string.h>\n// #include <math.h>\n// #include <float.h>\n// #include <stdlib.h>\nint n;\nint board[8][8];\nint get_start(int *x,int *y,int ban[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tif(ban[i][j]<0)\n\t  {\n\t    *x=i; *y=j;\n\t    return(-1);\n\t  }\n    return(0);\n}\nvoid copy_ban(int from[8][8],int to[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tto[i][j]=from[i][j];\n}\nvoid print_ban(int ban[8][8])\n{\n  int i,j;\n  printf(\"------------\\n\");\n    for(i=0;i<n;i++)\n      {\n\tfor(j=0;j<n;j++)\n\t  printf(\"%2d\",ban[i][j]);\n\tprintf(\"\\n\");\n      }\n}\n\nint check_limit(int x)\n{\n  return((x>=0 && x<=n-1)?(-1):0);\n}\nint check_all_zero(int ban[8][8])\n{\n  int i,j;\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      if(ban[i][j])\n\treturn(0);\n  return(-1);\n}\nint xoffs[4]={-1,1,0,0};\nint yoffs[4]={0,0,-1,1};\nint check_ban(int ban[8][8],int x,int y)\n{\n  int ban_save[8][8];\n  int ban_new[8][8];\n  int i,j,sum=0,ret,xn,yn,val;\n  \n  if(check_all_zero(ban))\n    return(-1);\n\n  if(check_connect_zero(ban)==0)\n    return(0);\n  if(x==-1 && y==-1)\n    {\n      ret=get_start(&x,&y,ban);\n      if(ret==0)\n\treturn(0);\n    }\n  //print_ban(ban);\n\n    //printf(\"find:%d %d\\n\",x,y);\n    copy_ban(ban,ban_save);\n    val=ban[x][y];\n    //printf(\"val %d\\n\",val);\n    for(i=0;i<4;i++)\n      {\n\txn = x + xoffs[i];yn = y + yoffs[i];\n\t//printf(\"find:xn=%d yn=%d v=%d\\n\",xn,yn,ban[xn][yn]);\n\tif(check_limit(xn) && check_limit(yn) && \n\t   ban[xn][yn]>0 &&\n\t   ban[xn][yn]+val <=0)\n\t{\n\t  //printf(\"*\");\n\t  ban[xn][yn] += val;\n\t  ban[x][y]=0;\n\t  copy_ban(ban,ban_new);\n\t\n\t  if(ban[xn][yn]==0)\n\t    ret=check_ban(ban_new,-1,-1);\n\t  else\n\t    ret=check_ban(ban_new,xn,yn);\n\t  if(ret)\n\t    return(1);\n\t  copy_ban(ban_save,ban);\n\t}\n\n      }\n \n    return(0);\n}\n\nint paint(int ban[8][8],int flags[8][8],int x,int y)\n{\n  int i,cnt,xn,yn;\n  //printf(\"PAINT %d %d\\n\",x,y);\n  cnt=ban[x][y];\n  flags[x][y]=-1;\n  for(i=0;i<4;i++)\n    {\n      xn = x + xoffs[i];yn = y + yoffs[i];\n      /*\n      printf(\"PAINT2 %d %d %d %d %d\\n\",xn,yn,ban[xn][yn],\n\t     check_limit(xn),check_limit(yn));\n      */\n      if(check_limit(xn) && check_limit(yn) && \n\t ban[xn][yn] && flags[xn][yn]==0)\n\t{\n\t  cnt += paint(ban,flags,xn,yn);\n\t}\n    }\n  return(cnt);\n}\nvoid clear(int flags[8][8])\n{\n  int i,j;\n\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)  \n      flags[i][j]=0;\n\n}\nint check_connect_zero(int ban[8][8])\n{\n  int flags[8][8];\n  int i,j,x,y,ret;\n\n  clear(flags);\n  //printf(\"C-CN\\n\");\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      if(ban[i][j])\n\tgoto NEXT;\n  return(-1); // all zero\n NEXT:\n  x=i;y=j;\n  //printf(\"C-CN %d %d\\n\",x,y);\n  ret=paint(ban,flags,x,y);\n  //printf(\"ret= %d\\n\",ret);\n  if(ret==0)\n    return(-1);\n  else\n    return(0);\n}\n\ncheck_total(int ban[8][8])\n{\n  int i,j,sum=0;\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      sum+=ban[i][j];\n  return((sum==0)?-1:0);\n }\nmain()\n{\n  int i,j;\n\n  while(scanf(\"%d\",&n)&&n)\n    {\n      for(i=0;i<n;i++)\n\tfor(j=0;j<n;j++)\n\t  scanf(\"%d\",&board[i][j]);\n      if(!check_total(board))\n\tprintf(\"NO\\n\");\n      \n      //else\n      //printf(\"yes\\n\");\n      \n      else if (!check_ban(board,-1,-1))\n\tprintf(\"NO\\n\");\n      else\n\tprintf(\"YES\\n\");\n      \n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1034: Line Puzzle\n// 2017.9.29 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 8\n#define N2 66\n\ntypedef struct { signed char r, c, s; } T;\nT start[N2]; int m;\n\nsigned char map[N][N]; int n, n2;\nint mv[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};\n\nint cmp(T *a, T *b)\n{\n\tif (b->s - a->s) return b->s - a->s;\n\tif (b->r - a->r) return b->r - a->r;\n\treturn a->c - b->c;\n}\n\nvoid route(signed char a[N][N], signed char b[N][N][2], int r, int c)\n{\n\tint r2, c2;\n\n\twhile (a[r][c] > 0) {\n\t\ta[r][c] = 0;\n\t\tr2 = b[r][c][0], c2 = b[r][c][1];\n\t\tr = r2, c = c2;\n\t}\n}\n\nvoid print(signed char a[N][N])\n{\n\tint r, c;\n\n\tfor (r = 0; r < n; r++) {\n\t\tfor (c = 0; c < n; c++) printf(\"%3d \", a[r][c]);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint combi(signed char a[N][N], int m0, int n0)\n{\n\tint i, id, r, c, s, r2, c2, ss, goal;\n\tsigned char tmp[N][N], prev[N][N][2], mk[N][N][N][N];\n\tT q[N2]; int top;\n\n\tif (m0 >= m && n0 >= n2) return 1;\n\tmemset(mk, 0, sizeof(mk));\n\tq[0].r = start[m0].r, q[0].c = start[m0].c, q[0].s = 0, top = 1;\n\tgoal = start[m0].s, id = 0;\n\twhile (top > 0) {\n\t\tr = q[--top].r, c = q[top].c, s = q[top].s;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1], id++;\n\t\t\tif (r2 < 0 || r2 >= n || c2 < 0 || c2 >= n ||\n\t\t\t\tmk[r][c][r2][c2] || a[r2][c2] <= 0) continue;\n\t\t\tss = s + a[r2][c2];\n\t\t\tmk[r][c][r2][c2] = 1;\n\t\t\tif (ss < goal) {\n\t\t\t\tprev[r2][c2][0] = r, prev[r2][c2][1] = c;\n\t\t\t\tq[top].r = r2, q[top].c = c2, q[top++].s = ss;\n\t\t\t} else if (ss == goal) {\n\t\t\t\tmemcpy(tmp, a, sizeof(tmp));\n\t\t\t\ttmp[r2][c2] = 0;\n\t\t\t\troute(tmp, prev, r, c);\n//printf(\"m %d, n %d \", m0+1, n0+id+1); print(tmp);\n\t\t\t\tif (combi(tmp, m0+1, n0+id+1)) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint r, c, t, s;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tn2 = n*n;\n\t\tfor (s = m = 0, r = 0; r < n; r++) for (c = 0; c < n; c++) {\n\t\t\tscanf(\"%d\", &t);\n\t\t\tif (t < 0) start[m].r = r, start[m].c = c, start[m++].s = -t;\n\t\t\tmap[r][c] = t, s += t;\n\t\t}\n//\t\tqsort(start, m, sizeof(T), cmp);\n\t\tputs(s == 0 && combi(map, 0, 0) ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1034\n  Title:Line Puzzle\n  @kankichi573\n*/\n#include <stdio.h>\n// #include <stdlib.h>\n// #include <string.h>\n// #include <math.h>\n// #include <float.h>\n// #include <stdlib.h>\nint n;\nint board[8][8];\nint get_start(int *x,int *y,int ban[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tif(ban[i][j]<0)\n\t  {\n\t    *x=i; *y=j;\n\t    return(-1);\n\t  }\n    return(0);\n}\nvoid copy_ban(int from[8][8],int to[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tto[i][j]=from[i][j];\n}\nvoid print_ban(int ban[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      {\n\tfor(j=0;j<n;j++)\n\t  printf(\"%2d\",ban[i][j]);\n\tprintf(\"\\n\");\n      }\n}\n\nint check_limit(int x)\n{\n  return((x>=0 && x<=n-1)?(-1):0);\n}\n\nint xoffs[4]={-1,1,0,0};\nint yoffs[4]={0,0,-1,1};\nint check_ban(int ban[8][8],int x,int y)\n{\n  int ban_save[8][8];\n  int ban_new[8][8];\n  int i,j,sum=0,ret,xn,yn,val;\n  \n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      if(ban[i][j])\n\tgoto NEXT;\n  return(-1);\n NEXT:\n  if(x==-1 && y==-1)\n    ret=get_start(&x,&y,ban);\n    if(ret==0)\n      return;\n    //print_ban(ban);\n\n    //printf(\"find:%d %d\\n\",x,y);\n    copy_ban(ban,ban_save);\n    val=ban[x][y];\n    //printf(\"val %d\\n\",val);\n    for(i=0;i<4;i++)\n      {\n\txn = x + xoffs[i];yn = y + yoffs[i];\n\t//printf(\"find:xn=%d yn=%d v=%d\\n\",xn,yn,ban[xn][yn]);\n\tif(check_limit(xn) && check_limit(yn) && \n\t   ban[xn][yn]>0 &&\n\t   ban[xn][yn]+val <=0)\n\t{\n\t  //printf(\"*\");\n\t  ban[xn][yn] += val;\n\t  ban[x][y]=0;\n\t  copy_ban(ban,ban_new);\n\t\n\t  if(ban[xn][yn]==0)\n\t    ret=check_ban(ban_new,-1,-1);\n\t  else\n\t    ret=check_ban(ban_new,xn,yn);\n\t  if(ret)\n\t    return(1);\n\t  copy_ban(ban_save,ban);\n\t}\n\n      }\n \n    return(0);\n}\ncheck_total(int ban[8][8])\n{\n  int i,j,sum=0;\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      sum+=ban[i][j];\n  return((sum==0)?-1:0);\n }\nmain()\n{\n  int i,j;\n\n  while(scanf(\"%d\",&n)&&n)\n    {\n      for(i=0;i<n;i++)\n\tfor(j=0;j<n;j++)\n\t  scanf(\"%d\",&board[i][j]);\n      if(!check_total(board))\n\tprintf(\"NO\\n\");\n      \n      //else\n      //printf(\"yes\\n\");\n      \n      else if (!check_ban(board,-1,-1))\n\tprintf(\"NO\\n\");\n      else\n\tprintf(\"YES\\n\");\n      \n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void) {\n\tint num,sum,i,temp;\n\twhile (1) {\n\t\tscanf(\"%d\",&num);\n\t\tif (num==0) break;\n\t\tsum=0;\n\t\tfor (i=0; i<num*num; i++) {\n\t\t\tscanf(\"%d\",&temp);\n\t\t\tsum+=temp;\n\t\t}\n\t\tif (sum==0) {\n\t\t\tprintf(\"YES\\n\");\n\t\t} else {\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1034\n  Title:Line Puzzle\n  @kankichi573\n*/\n#include <stdio.h>\n// #include <stdlib.h>\n// #include <string.h>\n// #include <math.h>\n// #include <float.h>\n// #include <stdlib.h>\nint n;\nint board[8][8];\nint get_start(int *x,int *y,int ban[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tif(ban[i][j]<0)\n\t  {\n\t    *x=i; *y=j;\n\t    return(-1);\n\t  }\n    return(0);\n}\nvoid copy_ban(int from[8][8],int to[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tto[i][j]=from[i][j];\n}\nvoid print_ban(int ban[8][8])\n{\n  int i,j;\n  printf(\"------------\\n\");\n    for(i=0;i<n;i++)\n      {\n\tfor(j=0;j<n;j++)\n\t  printf(\"%2d\",ban[i][j]);\n\tprintf(\"\\n\");\n      }\n}\n\nint check_limit(int x)\n{\n  return((x>=0 && x<=n-1)?(-1):0);\n}\n\nint xoffs[4]={-1,1,0,0};\nint yoffs[4]={0,0,-1,1};\nint check_ban(int ban[8][8],int x,int y)\n{\n  int ban_save[8][8];\n  int ban_new[8][8];\n  int i,j,sum=0,ret,xn,yn,val;\n  \n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      if(ban[i][j])\n\tgoto NEXT;\n  return(-1);\n NEXT:\n  if(x==-1 && y==-1)\n    {\n      ret=get_start(&x,&y,ban);\n      if(ret==0)\n\treturn;\n    }\n    print_ban(ban);\n\n    printf(\"find:%d %d\\n\",x,y);\n    copy_ban(ban,ban_save);\n    val=ban[x][y];\n    //printf(\"val %d\\n\",val);\n    for(i=0;i<4;i++)\n      {\n\txn = x + xoffs[i];yn = y + yoffs[i];\n\t//printf(\"find:xn=%d yn=%d v=%d\\n\",xn,yn,ban[xn][yn]);\n\tif(check_limit(xn) && check_limit(yn) && \n\t   ban[xn][yn]>0 &&\n\t   ban[xn][yn]+val <=0)\n\t{\n\t  //printf(\"*\");\n\t  ban[xn][yn] += val;\n\t  ban[x][y]=0;\n\t  copy_ban(ban,ban_new);\n\t\n\t  if(ban[xn][yn]==0)\n\t    ret=check_ban(ban_new,-1,-1);\n\t  else\n\t    ret=check_ban(ban_new,xn,yn);\n\t  if(ret)\n\t    return(1);\n\t  copy_ban(ban_save,ban);\n\t}\n\n      }\n \n    return(0);\n}\ncheck_total(int ban[8][8])\n{\n  int i,j,sum=0;\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      sum+=ban[i][j];\n  return((sum==0)?-1:0);\n }\nmain()\n{\n  int i,j;\n\n  while(scanf(\"%d\",&n)&&n)\n    {\n      for(i=0;i<n;i++)\n\tfor(j=0;j<n;j++)\n\t  scanf(\"%d\",&board[i][j]);\n      if(!check_total(board))\n\tprintf(\"NO\\n\");\n      \n      //else\n      //printf(\"yes\\n\");\n      \n      else if (!check_ban(board,-1,-1))\n\tprintf(\"NO\\n\");\n      else\n\tprintf(\"YES\\n\");\n      \n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1034\n  Title:Line Puzzle\n  @kankichi573\n*/\n#include <stdio.h>\n// #include <stdlib.h>\n// #include <string.h>\n// #include <math.h>\n// #include <float.h>\n// #include <stdlib.h>\nint n;\nint board[8][8];\nint get_start(int *x,int *y,int ban[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tif(ban[i][j]<0)\n\t  {\n\t    *x=i; *y=j;\n\t    return(-1);\n\t  }\n    return(0);\n}\nvoid copy_ban(int from[8][8],int to[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tto[i][j]=from[i][j];\n}\nvoid print_ban(int ban[8][8])\n{\n  int i,j;\n    for(i=0;i<n;i++)\n      {\n\tfor(j=0;j<n;j++)\n\t  printf(\"%2d\",ban[i][j]);\n\tprintf(\"\\n\");\n      }\n}\n\nint check_limit(int x)\n{\n  return((x>=0 && x<=n-1)?(-1):0);\n}\n\nint xoffs[4]={-1,1,0,0};\nint yoffs[4]={0,0,-1,1};\nint check_ban(int ban[8][8],int x,int y)\n{\n  int ban_save[8][8];\n  int ban_new[8][8];\n  int i,j,sum=0,ret,xn,yn,val;\n  \n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      if(ban[i][j])\n\tgoto NEXT;\n  return(-1);\n NEXT:\n  if(x==-1 && y==-1)\n    ret=get_start(&x,&y,ban);\n    if(ret==0)\n      return;\n    //print_ban(ban);\n\n    //printf(\"find:%d %d\\n\",x,y);\n    copy_ban(ban,ban_save);\n    val=ban[x][y];\n    //printf(\"val %d\\n\",val);\n    for(i=0;i<4;i++)\n      {\n\txn = x + xoffs[i];yn = y + yoffs[i];\n\t//printf(\"find:xn=%d yn=%d v=%d\\n\",xn,yn,ban[xn][yn]);\n\tif(check_limit(xn) && check_limit(yn) && \n\t   ban[xn][yn]>0 &&\n\t   ban[xn][yn]+val <=0)\n\t{\n\t  //printf(\"*\");\n\t  ban[xn][yn] += val;\n\t  ban[x][y]=0;\n\t  copy_ban(ban,ban_new);\n\t\n\t  if(ban[xn][yn]==0)\n\t    ret=check_ban(ban_new,-1,-1);\n\t  else\n\t    ret=check_ban(ban_new,xn,yn);\n\t  if(ret)\n\t    return(1);\n\t  copy_ban(ban_save,ban);\n\t}\n\n      }\n \n    return(0);\n}\ncheck_total(int ban[8][8])\n{\n  int i,j,sum=0;\n  for(i=0;i<n;i++)\n    for(j=0;j<n;j++)\n      sum+=ban[i][j];\n  return((sum==0)?-1:0);\n }\nmain()\n{\n  int i,j;\n\n  while(scanf(\"%d\",&n)&&n)\n    {\n      for(i=0;i<n;i++)\n\tfor(j=0;j<n;j++)\n\t  scanf(\"%d\",&board[i][j]);\n      if(!check_total(board))\n\tprintf(\"No\\n\");\n      \n      //else\n      //printf(\"yes\\n\");\n      \n      else if (!check_ban(board,-1,-1))\n\tprintf(\"No\\n\");\n      else\n\tprintf(\"Yes\\n\");\n      \n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void) {\n\tint num,sum,i,temp,flag;\n\twhile (1) {\n\t\tscanf(\"%d\",&num);\n\t\tif (num==0) break;\n\t\tsum=0;\n\t\tfor (i=0; i<num*num; i++) {\n\t\t\tif (i!=0&&i!=num&&i%num==0) {\n\t\t\t\tif (sum*flag<0) {\n\t\t\t\t\tsum=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanf(\"%d\",&temp);\n\t\t\tsum+=temp;\n\t\t\tif (i==num-1) {\n\t\t\t\tflag=sum;\n\t\t\t}\n\t\t}\n\t\tif (sum==0) {\n\t\t\tprintf(\"YES\\n\");\n\t\t} else {\n\t\t\tprintf(\"NO\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int n, sum;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    n = sc.nextInt();\n\t    if(n==0) break;\n\t    sum = 0;\n\t    for(int i=0; i<n*n; i++)\n\t\tsum += sc.nextInt();\n\t    System.out.println(sum==0 ? \"YES\":\"NO\");\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Line Puzzle\npublic class Main{\n\n\tpublic static int n;\n\tpublic static int[][] map;\n\tpublic static boolean[][] used;\n\tpublic static int[][] move = {{1,0},{0,1},{-1,0},{0,-1}};\n\tpublic static int num;// number of circle\n\tpublic static int[][] p;// circle address\n\n\tpublic static boolean dfs(int i, int j, int k, int sum){\n\t\tif(k==num){\n\t\t\tfor(int a=0;a<n;a++){\n\t\t\t\tfor(int b=0;b<n;b++){\n\t\t\t\t\tif(!used[a][b])return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif(sum > 0)return false;\n\t\tif(sum == 0){\n\t\t\ti = p[k+1][0];\n\t\t\tj = p[k+1][1];\n\t\t\treturn dfs(i, j, k+1, map[i][j]);\n\t\t}\n\n\t\tfor(int m=0;m<4;m++){\n\t\t\tint i2 = i + move[m][0];\n\t\t\tint j2 = j + move[m][1];\n\t\t\tif(0<=i2&&i2<n&&0<=j2&&j2<n&&!used[i2][j2]){\n\t\t\t\tused[i2][j2] = true;\n\t\t\t\tif(dfs(i2, j2, k, sum+map[i2][j2]))return true;\n\t\t\t\tused[i2][j2] = false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tmap = new int[n][n];\n\t\t\tused = new boolean[n][n];\n\t\t\tp = new int[n*n][2];\n\t\t\tnum = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t\tif(map[i][j]<0){\n\t\t\t\t\t\tp[num][0] = i;\n\t\t\t\t\t\tp[num][1] = j;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tused[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(p[0][0],p[0][1],0,map[p[0][0]][p[0][1]])?\"YES\":\"NO\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[n][n];\n\t\t\tv = new boolean[n][n];\n\t\t\tm = 0;\n\t\t\tp = new int[2][n * n];\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t\tsum += map[i][j];\n\t\t\t\t\tif (map[i][j] < 0) {\n\t\t\t\t\t\tp[0][m] = i;\n\t\t\t\t\t\tp[1][m++] = j;\n\t\t\t\t\t\tv[i][j] = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tif (sum != 0) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out\n\t\t\t\t\t.println(slove(p[0][0], p[1][0], 0, map[p[0][0]][p[1][0]]) ? \"YES\"\n\t\t\t\t\t\t\t: \"NO\");\n\n\t\t}\n\t}\n\n\tprivate boolean slove(int y, int x, int k, int sum) {\n\t\tif (sum > 0)\n\t\t\treturn false;\n\t\tif (sum == 0) {\n\t\t\tif (++k == m)\n\t\t\t\treturn true;\n\t\t\treturn slove(p[0][k], p[1][k], k, map[p[0][k]][p[1][k]]);\n\t\t}\n\t\tfor (int[] mo : move) {\n\t\t\tint ny = y + mo[0];\n\t\t\tint nx = x + mo[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (v[ny][nx])\n\t\t\t\tcontinue;\n\t\t\tv[ny][nx] = true;\n\t\t\tif (slove(ny, nx, k, sum + map[ny][nx]))\n\t\t\t\treturn true;\n\t\t\tv[ny][nx] = false;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < n && 0 <= nx && nx < n;\n\t}\n\n\tint n, m;\n\tint[][] map;\n\tint[][] p;\n\tboolean[][] v;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[n][n];\n\t\t\tv = new boolean[n][n];\n\t\t\tm = 0;\n\t\t\tp = new int[2][n * n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t\tif (map[i][j] < 0) {\n\t\t\t\t\t\tp[0][m] = i;\n\t\t\t\t\t\tp[1][m++] = j;\n\t\t\t\t\t\tv[i][j] = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tSystem.out\n\t\t\t\t\t.println(slove(p[0][0], p[1][0], 0, map[p[0][0]][p[1][0]]) ? \"YES\"\n\t\t\t\t\t\t\t: \"NO\");\n\n\t\t}\n\t}\n\n\tprivate boolean slove(int y, int x, int k, int sum) {\n\t\tif (sum > 0)\n\t\t\treturn false;\n\t\tif (sum == 0) {\n\t\t\tif (++k == m)\n\t\t\t\treturn true;\n\t\t\treturn slove(p[0][k], p[1][k], k, map[p[0][k]][p[1][k]]);\n\t\t}\n\t\tfor (int[] mo : move) {\n\t\t\tint ny = y + mo[0];\n\t\t\tint nx = x + mo[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (v[ny][nx])\n\t\t\t\tcontinue;\n\t\t\tv[ny][nx] = true;\n\t\t\tif (slove(ny, nx, k, sum + map[ny][nx]))\n\t\t\t\treturn true;\n\t\t\tv[ny][nx] = false;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < n && 0 <= nx && nx < n;\n\t}\n\n\tint n, m;\n\tint[][] map;\n\tint[][] p;\n\tboolean[][] v;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[n][n];\n\t\t\tv = new boolean[n][n];\n\t\t\tm = 0;\n\t\t\tp = new int[2][n * n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t\tif (map[i][j] < 0) {\n\t\t\t\t\t\tp[0][m] = i;\n\t\t\t\t\t\tp[1][m++] = j;\n\t\t\t\t\t\tv[i][j] = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tSystem.out\n\t\t\t\t\t.println(slove(p[0][0], p[1][0], 0, map[p[0][0]][p[1][0]]) ? \"YES\"\n\t\t\t\t\t\t\t: \"NO\");\n\n\t\t}\n\t}\n\n\tprivate boolean slove(int y, int x, int k, int sum) {\n\t\tif (m == k)\n\t\t\treturn true;\n\t\tif (sum > 0)\n\t\t\treturn false;\n\t\tif (sum == 0)\n\t\t\treturn slove(p[0][k + 1], p[1][k + 1], k + 1,\n\t\t\t\t\tmap[p[0][k + 1]][p[1][k + 1]]);\n\t\tfor (int[] mo : move) {\n\t\t\tint ny = y + mo[0];\n\t\t\tint nx = x + mo[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (v[ny][nx])\n\t\t\t\tcontinue;\n\t\t\tv[ny][nx] = true;\n\t\t\tif (slove(ny, nx, k, sum + map[ny][nx]))\n\t\t\t\treturn true;\n\t\t\tv[ny][nx] = false;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < n && 0 <= nx && nx < n;\n\t}\n\n\tint n, m;\n\tint[][] map;\n\tint[][] p;\n\tboolean[][] v;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[n][n];\n\t\t\tv = new boolean[n][n];\n\t\t\tm = 0;\n\t\t\tp = new int[2][n * n];\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt();\n\t\t\t\t\tsum += map[i][j];\n\t\t\t\t\tif (map[i][j] < 0) {\n\t\t\t\t\t\tp[0][m] = i;\n\t\t\t\t\t\tp[1][m++] = j;\n\t\t\t\t\t\tv[i][j] = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tif (sum != 0) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out\n\t\t\t\t\t.println(slove(p[0][0], p[1][0], 0, map[p[0][0]][p[1][0]]) ? \"YES\"\n\t\t\t\t\t\t\t: \"NO\");\n\n\t\t}\n\t}\n\n\tprivate boolean slove(int y, int x, int k, int sum) {\n\t\tif (sum > 0)\n\t\t\treturn false;\n\t\tif (sum == 0) {\n\t\t\tif (++k == m)\n\t\t\t\treturn true;\n\t\t\tint ny = p[0][k];\n\t\t\tint nx = p[1][k];\n\t\t\treturn slove(ny, nx, k, map[ny][nx]);\n\t\t}\n\t\tfor (int[] mo : move) {\n\t\t\tint ny = y + mo[0];\n\t\t\tint nx = x + mo[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (v[ny][nx])\n\t\t\t\tcontinue;\n\t\t\tv[ny][nx] = true;\n\t\t\tif (slove(ny, nx, k, sum + map[ny][nx]))\n\t\t\t\treturn true;\n\t\t\tv[ny][nx] = false;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < n && 0 <= nx && nx < n;\n\t}\n\n\tint n, m;\n\tint[][] map;\n\tint[][] p;\n\tboolean[][] v;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\tstatic int N;\n\tstatic int[][] v = new int[8][8];\n\tstatic ArrayList<Point> axisPos = new ArrayList<Point>();\n\tstatic ArrayList<Integer> axises = new ArrayList<Integer>();\n\n\tstatic boolean dfs(boolean[][] visited, Point pos, int axis, int sum) {\n\t\tif (sum > axises.get(axis)) return false;\n\t\tif (sum == axises.get(axis)) {\n\t\t\t++axis;\n\t\t\tif (axis == axises.size()) return true;\n\t\t\tpos = axisPos.get(axis);\n\t\t\tsum = 0;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint nr = pos.x + DR[i];\n\t\t\tint nc = pos.y + DC[i];\n\t\t\tif (nr < 0 || N <= nr || nc < 0 || N <= nc || visited[nr][nc] || v[nr][nc] < 0) continue;\n\t\t\tvisited[nr][nc] = true;\n\t\t\tif (dfs(visited, new Point(nr, nc), axis, sum + v[nr][nc])) return true;\n\t\t\tvisited[nr][nc] = false;\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic boolean solve() {\n\t\tboolean[][] visited = new boolean[N][N];\n\t\treturn dfs(visited, axisPos.get(0), 0, 0);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint sum = 0;\n\t\t\taxisPos.clear();\n\t\t\taxises.clear();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tv[i][j] = sc.nextInt();\n\t\t\t\t\tsum += v[i][j];\n\t\t\t\t\tif (v[i][j] < 0) {\n\t\t\t\t\t\taxisPos.add(new Point(i, j));\n\t\t\t\t\t\taxises.add(-v[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum == 0 && solve() ? \"YES\" : \"NO\");\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int[][] move_dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\t\n\tpublic static boolean is_ok(int x, int y, final int n){\n\t\tif(x < 0 || x >= n || y < 0 || y >= n){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static boolean dfs(int deep, final int size, final int n, boolean using[][], int[][] map, int x, int y, int cur, \n\t\t\tArrayList<Integer> x_pos, ArrayList<Integer> y_pos, ArrayList<Integer> values, int painted, final int all){\n\t\tfinal int value = values.get(deep);\n\t\t\n\t\t/*\n\t\tSystem.out.println(deep + \" \" + n + \" \" + cur + \"/\" + value);\n\t\t\n\t\tSystem.out.println(\"---------------------------------------\");\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(using[i][j]){\n\t\t\t\t\tSystem.out.print(\"x \");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"---------------------------------------\");\n//\t\t*/\n\t\tif(cur > value){\n\t\t\treturn false;\n\t\t}else if(cur == value){\n\t\t\tif(deep == size - 1 && painted == all){\n\t\t\t\treturn true;\n\t\t\t}else if(deep == size - 1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int nx = x_pos.get(deep + 1);\n\t\t\tfinal int ny = y_pos.get(deep + 1);\n\t\t\t\n\t\t\treturn dfs(deep + 1, size, n, using, map, nx, ny, 0, x_pos, y_pos, values, painted, all);\n\t\t}else{\n\t\t\tfor(int[] move : move_dir){\n\t\t\t\tfinal int nx = x + move[0];\n\t\t\t\tfinal int ny = y + move[1];\n\t\t\t\t\n\t\t\t\tif(!is_ok(nx, ny, n)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(using[ny][nx]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tusing[ny][nx] = true;\n\t\t\t\tif(dfs(deep, size, n, using, map, nx, ny, cur + map[ny][nx], x_pos, y_pos, values, painted + 1, all)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tusing[ny][nx] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] using = new boolean[n][n];\n\t\t\tint[][] map = new int[n][n];\n\t\t\tArrayList<Integer> x_pos = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> y_pos = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> values = new ArrayList<Integer>();\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tfinal int input = sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tif(input < 0){\n\t\t\t\t\t\tusing[i][j] = true;\n\t\t\t\t\t\ty_pos.add(i);\n\t\t\t\t\t\tx_pos.add(j);\n\t\t\t\t\t\tvalues.add(-input);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tmap[i][j] = input;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int size = x_pos.size();\n\t\t\t\n\t\t\tfinal boolean ret = dfs(0, size, n, using, map, x_pos.get(0), y_pos.get(0), 0, x_pos, y_pos, values, 0, count);\n\t\t\t\n\t\t\tSystem.out.println(ret ? \"YES\" : \"NO\");\n\t\t}\n\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    static int[] dx = new int[] { 0, 1, 0, -1 };\n    static int[] dy = new int[] { 1, 0, -1, 0 };\n    static bool OK = false;\n    static int n = 0;\n    public static void Main()\n    {\n        while (true)\n        {\n            n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            OK = false;\n            var map = new int[n, n];\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < n; j++) map[i, j] = int.Parse(line[j]);\n            }\n            var used = new bool[n, n];\n            goDfs(map, used, 0, n * n, 0, 0);\n            Console.WriteLine(OK ? \"YES\" : \"NO\");\n        }\n    }\n    public static void goDfs(int[,] map, bool[,] used, int rest, int rest2, int x, int y)\n    {\n        if (rest2 == 0) { OK = true; return; }\n        if (rest == 0)\n        {\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (map[i, j] < 0 && !used[i, j])\n                    {\n                        used[i, j] = true;\n                        goDfs(map, used, -map[i, j], rest2 - 1, i, j);\n                        used[i, j] = false;\n                        return;\n                    }\n        }\n        else\n            for (int i = 0; i < 4; i++)\n            {\n                var nx = x + dx[i];\n                var ny = y + dy[i];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && map[nx, ny] > 0 && !used[nx, ny] && rest - map[nx, ny] >= 0)\n                {\n                    used[nx, ny] = true;\n                    goDfs(map, used, rest - map[nx, ny], rest2 - 1, nx, ny);\n                    used[nx, ny] = false;\n                }\n            }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol=new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tint n;\n\tint[,] Arr;\n\tList<Point> L;\n\tint state;\n\n\tpublic Sol(int n_){\n\t\tn=n_;\n\t\tL=new List<Point>();\n\t\tstate=0;\n\t\tArr=new int[n+2,n+2];\n\n\t\tint cnt=0;\n\n\t\tfor(int i=0;i<n+2;i++)Arr[0,i]=Arr[n+1,i]=Arr[i,0]=Arr[i,n+1]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Console.ReadLine().Split(' ');\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tArr[i+1,j+1]=int.Parse(d[j]);\n\t\t\t\tif(Arr[i+1,j+1]<0)L.Add(new Point(i+1,j+1,Arr[i+1,j+1]));\n\t\t\t\tcnt+=Arr[i+1,j+1];\n\t\t\t}\n\t\t}\n\t\tif(cnt!=0)state=-99;\n\t}\n\n\tpublic void Solve(){\n\t\tif(state==-99){\n\t\t\tConsole.WriteLine(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//降順でソート（絶対値の小さい順）\n\t\t//L.Sort((x,y)=>x.V>y.V?-1:(x.V<y.V?1:0));\n\t\t\n\t\tstate=0;//dfsで解けたら１\n\t\t\n\t\t//dfs: score：手持ちの数。now:挑戦中の起点 r,c:現在地点\n\t\tint now=0;\n\t\tint score=0;\n//dbg.wArr(Arr);\t\t\n\t\tdfs(now,score,L[now].R,L[now].C);\n\t\t\n\t\tif(state==1){\n\t\t\tConsole.WriteLine(\"YES\");\n\t\t\treturn;\n\t\t}\n\t\tConsole.WriteLine(\"NO\");\n\t}\n\n\tvoid dfs(int now_,int score_,int r_,int c_){\n\t\tint score=score_;\n\t\tint now=now_;\n\t\tint r=r_;\n\t\tint c=c_;\n\t\tscore+=Arr[r,c];\n\t\tint bak=Arr[r,c];\n\t\tArr[r,c]=0;\n//Console.WriteLine(\"score={0},now={1},r={2},c={3},bak={4}\",score,now,r,c,bak);\n//dbg.wArr(Arr);\t\t\n\t\tif(score==0){\n\t\t\tif(now<L.Count-1){\n\t\t\t\tdfs(now+1,score,L[now+1].R,L[now+1].C);\n\t\t\t}\n\t\t\tif(now==L.Count-1){\n\t\t\t\tstate=1;\n\t\t\t}\n\t\t\tscore-=bak;\n\t\t\tArr[r,c]=bak;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tif(Arr[r-1,c]>0 && score+Arr[r-1,c]<=0)dfs(now,score,r-1,c);\n\t\tif(Arr[r+1,c]>0 && score+Arr[r+1,c]<=0)dfs(now,score,r+1,c);\n\t\tif(Arr[r,c-1]>0 && score+Arr[r,c-1]<=0)dfs(now,score,r,c-1);\n\t\tif(Arr[r,c+1]>0 && score+Arr[r,c+1]<=0)dfs(now,score,r,c+1);\n\t\t\n\t\tscore-=bak;\n\t\tArr[r,c]=bak;\n\t\treturn;\n\t}\n}\n\n\n\nclass Point{\n\tpublic int R{get;set;}\n\tpublic int C{get;set;}\n\tpublic int V{get;set;}\n\tpublic Point(int i,int j,int v){\n\t\tthis.R=i;\n\t\tthis.C=j;\n\t\tthis.V=v;\n\t}\n}\n\t\nclass dbg{\n\tpublic static void wArr(int[,] A){\n\t\tConsole.WriteLine(\"--table--\");\n\t\tfor(int i=0;i<A.GetLength(0);i++){\n\t\t\tfor(int j=0;j<A.GetLength(1);j++){\n\t\t\t\tConsole.Write(\"{0}\\t\",A[i,j]);\n\t\t\t}\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t\tConsole.WriteLine(\"--table end--\");\n\t\tConsole.WriteLine(\"\");\n\t}\n\tpublic static void w(String S){\n\t\tConsole.WriteLine(S);\n\t}\n\tpublic static void w(int i){\n\t\tConsole.WriteLine(i);\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol=new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\n\nclass Sol{\n\tint n;\n\tint[,] Arr;\n\tList<Point> L;\n\tint state;\n\n\tpublic Sol(int n_){\n\t\tn=n_;\n\t\tL=new List<Point>();\n\t\tstate=0;\n\t\tArr=new int[n+2,n+2];\n\n\t\tint cnt=0;\n\n\t\tfor(int i=0;i<n+2;i++)Arr[0,i]=Arr[n+1,i]=Arr[i,0]=Arr[i,n+1]=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tvar d=Console.ReadLine().Split(' ');\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tArr[i+1,j+1]=int.Parse(d[j]);\n\t\t\t\tif(Arr[i+1,j+1]<0)L.Add(new Point(i+1,j+1,Arr[i+1,j+1]));\n\t\t\t\tcnt+=Arr[i+1,j+1];\n\t\t\t}\n\t\t}\n\t\tif(cnt!=0)state=-99;\n\t}\n\n\tpublic void Solve(){\n\t\tif(state==-99){\n\t\t\tConsole.WriteLine(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//降順でソート（絶対値の小さい順）\n\t\tL.Sort((x,y)=>x.V>y.V?-1:(x.V<y.V?1:0));\n\t\t\n\t\tstate=0;//dfsで解けたら１\n\t\t\n\t\t//dfs: score：手持ちの数。now:挑戦中の起点 r,c:現在地点\n\t\tint now=0;\n\t\tint score=0;\n//dbg.wArr(Arr);\t\t\n\t\tdfs(now,score,L[now].R,L[now].C);\n\t\t\n\t\tif(state==1){\n\t\t\tConsole.WriteLine(\"YES\");\n\t\t\treturn;\n\t\t}\n\t\tConsole.WriteLine(\"NO\");\n\t}\n\n\tvoid dfs(int now_,int score_,int r_,int c_){\n\t\tint score=score_;\n\t\tint now=now_;\n\t\tint r=r_;\n\t\tint c=c_;\n\t\tscore+=Arr[r,c];\n\t\tint bak=Arr[r,c];\n\t\tArr[r,c]=0;\n//Console.WriteLine(\"score={0},now={1},r={2},c={3},bak={4}\",score,now,r,c,bak);\n//dbg.wArr(Arr);\t\t\n\t\tif(score==0){\n\t\t\tif(now<L.Count-1){\n\t\t\t\tdfs(now+1,score,L[now+1].R,L[now+1].C);\n\t\t\t}\n\t\t\tif(now==L.Count-1){\n\t\t\t\tstate=1;\n\t\t\t}\n\t\t\tscore-=bak;\n\t\t\tArr[r,c]=bak;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tif(Arr[r-1,c]>0 && score+Arr[r-1,c]<=0)dfs(now,score,r-1,c);\n\t\tif(Arr[r+1,c]>0 && score+Arr[r+1,c]<=0)dfs(now,score,r+1,c);\n\t\tif(Arr[r,c-1]>0 && score+Arr[r,c-1]<=0)dfs(now,score,r,c-1);\n\t\tif(Arr[r,c+1]>0 && score+Arr[r,c+1]<=0)dfs(now,score,r,c+1);\n\t\t\n\t\tscore-=bak;\n\t\tArr[r,c]=bak;\n\t\treturn;\n\t}\n}\n\n\n\nclass Point{\n\tpublic int R{get;set;}\n\tpublic int C{get;set;}\n\tpublic int V{get;set;}\n\tpublic Point(int i,int j,int v){\n\t\tthis.R=i;\n\t\tthis.C=j;\n\t\tthis.V=v;\n\t}\n}\n\t\nclass dbg{\n\tpublic static void wArr(int[,] A){\n\t\tConsole.WriteLine(\"--table--\");\n\t\tfor(int i=0;i<A.GetLength(0);i++){\n\t\t\tfor(int j=0;j<A.GetLength(1);j++){\n\t\t\t\tConsole.Write(\"{0}\\t\",A[i,j]);\n\t\t\t}\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t\tConsole.WriteLine(\"--table end--\");\n\t\tConsole.WriteLine(\"\");\n\t}\n\tpublic static void w(String S){\n\t\tConsole.WriteLine(S);\n\t}\n\tpublic static void w(int i){\n\t\tConsole.WriteLine(i);\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1034.rb: Line Puzzle\n#\n\nrequire 'set'\n\n### constant\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### subroutines\n\ndef fl_rec(x, y, sum, set0)\n  if sum == 0\n    return [set0.clone]\n  end\n\n  sets = Set.new\n\n  for dxy in DXYS\n    x0 = x + dxy[0]\n    y0 = y + dxy[1]\n    id0 = y0 * $n + x0\n\n    if x0 >= 0 && x0 < $n && y0 >= 0 && y0 < $n &&\n        ! $used0[id0] && $mtx[id0] <= sum\n      $used0[id0] = true\n      sets += fl_rec(x0, y0, sum - $mtx[id0], set0 + [id0] )\n      $used0[id0] = false\n    end\n  end\n\n  sets\nend\n\ndef find_lines(org)\n  sum = -$mtx[org]\n  x = org % $n\n  y = org / $n\n  $used0 = $used.clone\n\n  fl_rec(x, y, sum, Set.new)\nend\n\ndef check_osets(osets, k)\n  if k >= osets.length\n    return true\n  end\n\n  for set0 in osets[k]\n    set0.each{|id| $used[id] = true}\n    return true if check_osets(osets, k + 1)\n    set0.each{|id| $used[id] = false}\n  end\n\n  false\nend\n\n### main\n\nloop do\n  $n = gets.to_i\n  break if $n == 0\n\n  $mtx = []\n  origins = []\n  sum = 0\n\n  for y in (0...$n)\n    nums = gets.split.map(&:to_i)\n    sum += nums.inject(:+)\n\n    for x in (0...$n)\n      origins << (y * $n + x) if nums[x] < 0\n    end\n\n    $mtx += nums\n  end\n  #p $mtx\n  #p origins\n  #p sum\n\n  if sum != 0\n    puts 'NO'\n    next\n  end\n\n  $used = ($n * $n).times.map{false}\n  origins.each{|i| $used[i] = true}\n  #p $used\n\n  ok = true\n  osets = []\n\n  for org in origins\n    oset = find_lines(org)\n    if oset.empty?\n      ok = false\n      break\n    end\n    osets << oset\n  end\n  #p osets\n\n  if ! ok\n    puts 'NO'\n    next\n  end\n\n  changed = true\n\n  while changed\n    changed = false\n    posets, osets = osets, []\n\n    for poset in posets\n      oset = Set.new\n\n      for set0 in poset\n        if set0.select{|id| $used[id]}.empty?\n          oset << set0\n        else\n          changed = true\n        end\n      end\n\n      if oset.empty?\n        ok = false\n        break\n      end\n\n      if oset.length == 1\n        oset.first.each{|id| $used[id] = true}\n        changed = true\n        next\n      end\n\n      osets << oset\n    end\n\n    break if ! ok\n  end\n\n  if ! ok\n    puts 'NO'\n    next\n  end\n\n  if osets.empty?\n    puts 'YES'\n    next\n  end\n  #osets.each{|oset| p oset}\n  #p $used\n\n  ok = check_osets(osets, 0)\n  puts (ok ? 'YES' : 'NO')\nend"
  },
  {
    "language": "Ruby",
    "code": "Add = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\ndef dfs(map, y, x, cost)\n  return [map] if cost.zero?\n  result = Array.new\n  Add.each do |(dy, dx)|\n    ny = y + dy\n    nx = x + dx\n    next if ny < 0 || map.size <= ny\n    next if nx < 0 || map.size <= nx\n    next if map[ny][nx] <= 0\n    next if cost < map[ny][nx]\n    nm = map.dup.map(&:dup)\n    nm[ny][nx] = 0\n    nc = cost - map[ny][nx]\n    result += dfs(nm, ny, nx, nc)\n  end\n  result\nend\n\nuntil (n = gets.to_i).zero?\n  puzzle = Array.new\n  n.times do puzzle.push(gets.split.map(&:to_i)) end\n\n  queue = [puzzle.dup.map(&:dup)]\n  (0...n).each do |i|\n    (0...n).each do |j|\n      next if puzzle[i][j] >= 0\n      result = Array.new\n      queue.each do |q|\n        q[i][j] = 0\n        result += dfs(q, i, j, -puzzle[i][j])\n      end\n      queue = result\n    end\n  end\n\n  result = false\n  queue.each do |q|\n    ok = true\n    q.each do |line|\n      ok = false unless line.all?(&:zero?)\n    end\n    result = true if ok\n  end\n  puts result ? \"YES\" : \"NO\"\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#\n# 1034.rb: Line Puzzle\n#\n\nrequire 'set'\n\n### constant\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### subroutines\n\ndef fl_rec(x, y, sum, set0)\n  if sum == 0\n    return [set0.clone]\n  end\n\n  sets = Set.new\n\n  for dxy in DXYS\n    x0 = x + dxy[0]\n    y0 = y + dxy[1]\n    id0 = y0 * $n + x0\n\n    if x0 >= 0 && x0 < $n && y0 >= 0 && y0 < $n && \n        ! $used0[id0] && $mtx[id0] <= sum\n      $used0[id0] = true\n      sets += fl_rec(x0, y0, sum - $mtx[id0], set0 + [id0] )\n      $used0[id0] = false\n    end\n  end\n\n  sets\nend\n\ndef find_lines(org)\n  sum = -$mtx[org]\n  x = org % $n\n  y = org / $n\n  $used0 = $used.clone\n\n  fl_rec(x, y, sum, Set.new)\nend\n\ndef check_osets(osets, k)\n  if k >= osets.length\n    return true\n  end\n\n  for set0 in osets[k]\n    set0.each{|id| $used[id] = true}\n    return true if check_osets(osets, k + 1)\n    set0.each{|id| $used[id] = false}\n  end\n\n  false\nend\n\n### main\n\nloop do\n  $n = gets.to_i\n  break if $n == 0\n\n  $mtx = []\n  origins = []\n  sum = 0\n\n  for y in (0...$n)\n    nums = gets.split.map(&:to_i)\n    sum += nums.inject(:+)\n\n    for x in (0...$n)\n      origins << (y * $n + x) if nums[x] < 0\n    end\n\n    $mtx += nums\n  end\n  #p $mtx\n  #p origins\n  #p sum\n\n  if sum != 0\n    puts 'NO'\n    next\n  end\n\n  $used = ($n * $n).times.map{false}\n  origins.each{|i| $used[i] = true}\n  #p $used\n\n  ok = true\n  osets = []\n\n  for org in origins\n    oset = find_lines(org)\n    if oset.empty?\n      ok = false\n      break\n    end\n    osets << oset\n  end\n  #p osets\n\n  if ! ok\n    puts 'NO'\n    next\n  end\n\n  changed = true\n\n  while changed\n    changed = false\n    posets, osets = osets, []\n\n    for poset in posets\n      oset = Set.new\n\n      for set0 in poset\n        if set0.select{|id| $used[id]}.empty?\n          oset << set0\n        else\n          changed = true\n        end\n      end\n\n      if oset.empty?\n        ok = false\n        break\n      end\n\n      if oset.length == 1\n        oset.first.each{|id| $used[id] = true}\n        changed = true\n        next\n      end\n\n      osets << oset\n    end\n\n    break if ! ok\n  end\n\n  if ! ok\n    puts 'NO'\n    next\n  end\n\n  if osets.empty?\n    puts 'YES'\n    next\n  end\n  #osets.each{|oset| p oset}\n  #p $used\n\n  ok = check_osets(osets, 0)\n  puts (ok ? 'YES' : 'NO')\nend"
  },
  {
    "language": "Python",
    "code": "board = []\nused = []\nv = []\nn = 0\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\ndef set_v():\n    global v\n    for y in range(0, n):\n        for x in range(0, n):\n            if board[y][x] < 0:\n                v += [(x, y)]\n                used[y][x] = 1 \n\ndef solve(x, y, rest, s, k):\n    if s == 0:\n        if rest == 0:\n            if k == len(v) - 1:\n                return True\n            return False\n        if k < len(v) - 1:\n            k1 = k + 1\n            xx, yy = v[k1]\n            used[y][x] = 1\n            if solve(xx, yy, rest - 1, - board[yy][xx], k1):\n                return True\n            used[y][x] = 0\n    if s <= 0 or k >= len(v):\n        return False\n    if board[y][x] > 0:\n        used[y][x] = 1\n    for d in range(0, 4):\n        xx = x + dx[d]\n        yy = y + dy[d]\n        if 0 <= xx < n and 0 <= yy < n and used[yy][xx] == 0:\n            if solve(xx, yy, rest - 1, s - board[yy][xx], k):\n                return True\n    if board[y][x] > 0:\n        used[y][x] = 0\n    return False\n\n\n\nwhile True:\n    board = []\n    v = []\n    line = input()\n    n = int(line)\n    if n == 0:\n        break\n    for _ in range(0, n):\n        a = list(map(int, list(input().split())))\n        board.append(a)\n    used = [ [0] * n for _ in range(0, n)]\n    set_v()\n    x, y = v[0]\n    print(\"YES\" if solve(x, y, n * n - 1, - board[y][x], 0) else \"NO\")\n"
  },
  {
    "language": "Python",
    "code": "di=(-1,1,0,0)\ndj=(0,0,-1,1)\n\ndef solve(a,ss,i,j,si,rest,vis):\n  n=len(a)\n  if i<0 or n<=i or j<0 or n<=j or vis[i][j]: return False\n  if a[i][j]<0:\n    if ss[si]!=(i,j): return False\n    vis[i][j]=-1-si\n    for k in range(4):\n      ni,nj=i+di[k],j+dj[k]\n      if solve(a,ss,ni,nj,si,rest,vis): return True\n    vis[i][j]=0\n  else:\n    if rest<a[i][j]: return False\n    vis[i][j]=-1-si\n    rest-=a[i][j]\n    if rest==0:\n      si+=1\n      if si==len(ss): return True\n      ni,nj=ss[si]\n      if solve(a,ss,ni,nj,si,-a[ni][nj],vis): return True\n    else:\n      for k in range(4):\n        ni,nj=i+di[k],j+dj[k]\n        if solve(a,ss,ni,nj,si,rest,vis): return True\n    vis[i][j]=0\n  return False\n\nwhile 1:\n  n=int(input())\n  if n==0: break\n  a=[list(map(int,input().split())) for _ in range(n)]\n\n  if sum(x for row in a for x in row):\n    print(\"NO\")\n    continue\n\n  ss=[(i,j) for i in range(n) for j in range(n) if a[i][j]<0]\n  vis=[[0]*n for _ in range(n)]\n  i,j=ss[0]\n  if solve(a,ss,i,j,0,-a[i][j],vis):\n    print(\"YES\")\n  else:\n    print(\"NO\")"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:break\n  mp = [list(map(int, input().split())) for _ in range(n)]\n  used = [[False] * n for _ in range(n)]\n  \n  inits = []\n  for y in range(n):\n    for x in range(n):\n      if mp[y][x] < 0:\n        inits.append((x, y, mp[y][x]))\n        used[y][x] = True\n  \n  vec = ((0, 1), (-1, 0), (0, -1), (1, 0))\n  \n  def search(x, y, s, index, inits, end):\n    if s == 0 and index == end:\n      return True\n    elif s == 0:\n      x, y, s = inits[index]\n      index += 1\n    \n    ret = False\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if 0 <= nx < n and 0 <= ny < n and not used[ny][nx] and mp[ny][nx] + s <= 0:\n        used[ny][nx] = True\n        ret = ret or search(nx, ny, s + mp[ny][nx], index, inits, end)\n        used[ny][nx] = False\n    return ret\n  \n  if sum([sum(lst) for lst in mp]) != 0:\n    print(\"NO\")\n  else:\n    if search(0, 0, 0, 0, inits, len(inits)):\n      print(\"YES\")\n    else:\n      print(\"NO\")\n"
  },
  {
    "language": "Python",
    "code": "def dfs(a,i,j,rest,vis):\n  if i<0 or len(a)<=i or j<0 or len(a[i])<=j: return False\n  if a[i][j]<0 or rest<a[i][j] or vis[i][j]: return False\n  vis[i][j]=1\n  rest-=a[i][j]\n  if rest==0:\n    if start(a,vis):\n      return True\n  else:\n    for di,dj in zip([-1,1,0,0],[0,0,-1,1]):\n      if dfs(a,i+di,j+dj,rest,vis):\n        return True\n  vis[i][j]=0\n  return False\n\ndef start(a,vis):\n  for i in range(len(a)):\n    for j in range(len(a[i])):\n      if a[i][j]<0 and not vis[i][j]:\n        vis[i][j]=1\n        for di,dj in zip([-1,1,0,0],[0,0,-1,1]):\n          if dfs(a,i+di,j+dj,-a[i][j],vis):\n            return True\n        vis[i][j]=0\n        return False\n  return True\n\nwhile 1:\n  n=int(input())\n  if n==0: break\n  a=[list(map(int,input().split())) for _ in range(n)]\n\n  if sum(x for row in a for x in row):\n    print(\"NO\")\n    continue\n\n  vis=[[0]*n for _ in range(n)]\n  print(\"YES\" if start(a,vis) else \"NO\")"
  },
  {
    "language": "Python",
    "code": "def dfs(a,i,j,ss,si,rest,vis):\n  if i<0 or len(a)<=i or j<0 or len(a[i])<=j or vis[i][j]: return False\n  if a[i][j]<0 and (i,j)==ss[si]:\n    vis[i][j]=1\n    for di,dj in zip([-1,1,0,0],[0,0,-1,1]):\n      if dfs(a,i+di,j+dj,ss,si,-a[i][j],vis):\n        return True\n    vis[i][j]=0\n  elif a[i][j]>0 and rest>=a[i][j]:\n    rest-=a[i][j]\n    vis[i][j]=1\n    if rest==0:\n      if si+1==len(ss): return True\n      ni,nj=ss[si+1]\n      if dfs(a,ni,nj,ss,si+1,-a[i][j],vis):\n        return True\n    else:\n      for di,dj in zip([-1,1,0,0],[0,0,-1,1]):\n        if dfs(a,i+di,j+dj,ss,si,rest,vis):\n          return True\n    vis[i][j]=0\n  return False\n\nwhile 1:\n  n=int(input())\n  if n==0: break\n  a=[list(map(int,input().split())) for _ in range(n)]\n\n  if sum(x for row in a for x in row):\n    print(\"NO\")\n    continue\n\n  ss=[(i,j) for i in range(n) for j in range(n) if a[i][j]<0]\n  vis=[[0]*n for _ in range(n)]\n  i,j=ss[0]\n  print(\"YES\" if dfs(a,i,j,ss,0,-a[i][j],vis) else \"NO\")"
  }
]