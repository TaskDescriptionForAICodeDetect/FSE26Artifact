[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int row;\n    int col;\n    int is_add;\n} Operation;\n\nint n;\nint grid[MAX_N][MAX_N];\nint row_count[MAX_N];\nint col_count[MAX_N];\nOperation operations[MAX_N * MAX_N];\nint op_count = 0;\nint total_cost = 0;\n\nvoid solve() {\n    // Initialize row and column counts\n    for (int i = 0; i < n; i++) {\n        row_count[i] = 0;\n        col_count[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j]) {\n                row_count[i]++;\n                col_count[j]++;\n            }\n        }\n    }\n\n    // Step 1: Remove excess circles in rows and columns\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] && (row_count[i] > 1 || col_count[j] > 1)) {\n                grid[i][j] = 0;\n                operations[op_count].row = i + 1;\n                operations[op_count].col = j + 1;\n                operations[op_count].is_add = 0;\n                op_count++;\n                total_cost += 1; // Assuming cost 1 for removal\n                row_count[i]--;\n                col_count[j]--;\n            }\n        }\n    }\n\n    // Step 2: Add missing circles ensuring one per row and column\n    for (int i = 0; i < n; i++) {\n        if (row_count[i] == 0) {\n            for (int j = 0; j < n; j++) {\n                if (col_count[j] == 0) {\n                    grid[i][j] = 1;\n                    operations[op_count].row = i + 1;\n                    operations[op_count].col = j + 1;\n                    operations[op_count].is_add = 1;\n                    op_count++;\n                    total_cost += 1; // Assuming cost 1 for addition\n                    row_count[i]++;\n                    col_count[j]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Handle remaining rows or columns (if any)\n    for (int i = 0; i < n; i++) {\n        if (row_count[i] == 0) {\n            for (int j = 0; j < n; j++) {\n                if (col_count[j] < 1) {\n                    grid[i][j] = 1;\n                    operations[op_count].row = i + 1;\n                    operations[op_count].col = j + 1;\n                    operations[op_count].is_add = 1;\n                    op_count++;\n                    total_cost += 1;\n                    row_count[i]++;\n                    col_count[j]++;\n                    break;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    solve();\n\n    printf(\"%d\\n\", total_cost);\n    printf(\"%d\\n\", op_count);\n    for (int i = 0; i < op_count; i++) {\n        printf(\"%d %d %s\\n\", operations[i].row, operations[i].col, operations[i].is_add ? \"add\" : \"remove\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:32:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 105;\nconst int INF = INT_MAX;\n\nint n;\nint cost[MAXN][MAXN];\nint lx[MAXN], ly[MAXN], match[MAXN], slack[MAXN];\nbool visx[MAXN], visy[MAXN];\n\nbool dfs(int x, vector<vector<int>>& grid) {\n    visx[x] = true;\n    for (int y = 0; y < n; ++y) {\n        if (visy[y]) continue;\n        int gap = lx[x] + ly[y] - cost[x][y];\n        if (gap == 0) {\n            visy[y] = true;\n            if (match[y] == -1 || dfs(match[y], grid)) {\n                match[y] = x;\n                return true;\n            }\n        } else {\n            slack[y] = min(slack[y], gap);\n        }\n    }\n    return false;\n}\n\nvoid km(vector<vector<int>>& grid) {\n    memset(match, -1, sizeof(match));\n    memset(ly, 0, sizeof(ly));\n    for (int i = 0; i < n; ++i) {\n        lx[i] = -INF;\n        for (int j = 0; j < n; ++j) {\n            lx[i] = max(lx[i], cost[i][j]);\n        }\n    }\n\n    for (int x = 0; x < n; ++x) {\n        fill(slack, slack + n, INF);\n        while (true) {\n            memset(visx, false, sizeof(visx));\n            memset(visy, false, sizeof(visy));\n            if (dfs(x, grid)) break;\n            int d = INF;\n            for (int y = 0; y < n; ++y) {\n                if (!visy[y]) d = min(d, slack[y]);\n            }\n            for (int i = 0; i < n; ++i) {\n                if (visx[i]) lx[i] -= d;\n                if (visy[i]) ly[i] += d;\n                else slack[i] -= d;\n            }\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    vector<vector<int>> grid(n, vector<int>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                cost[i][j] = 0;\n            } else {\n                cost[i][j] = -1;\n            }\n        }\n    }\n\n    km(grid);\n\n    int total_cost = 0;\n    vector<tuple<int, int, char>> operations;\n\n    for (int y = 0; y < n; ++y) {\n        int x = match[y];\n        if (grid[x][y] == 0) {\n            operations.emplace_back(x + 1, y + 1, 'A');\n            total_cost += 1;\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1 && match[j] != i) {\n                operations.emplace_back(i + 1, j + 1, 'D');\n                total_cost += 1;\n            }\n        }\n    }\n\n    cout << total_cost << endl;\n    cout << operations.size() << endl;\n    for (auto& op : operations) {\n        cout << get<0>(op) << \" \" << get<1>(op) << \" \" << get<2>(op) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:33:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GridGame {\n    static class Operation {\n        int row, col;\n        boolean isAdd;\n\n        Operation(int row, int col, boolean isAdd) {\n            this.row = row;\n            this.col = col;\n            this.isAdd = isAdd;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] grid = new int[n][n];\n        int[] rowCount = new int[n];\n        int[] colCount = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = scanner.nextInt();\n                if (grid[i][j] == 1) {\n                    rowCount[i]++;\n                    colCount[j]++;\n                }\n            }\n        }\n\n        List<Operation> operations = new ArrayList<>();\n        int totalCost = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (rowCount[i] > 1 && colCount[j] > 1 && grid[i][j] == 1) {\n                    grid[i][j] = 0;\n                    rowCount[i]--;\n                    colCount[j]--;\n                    operations.add(new Operation(i + 1, j + 1, false));\n                    totalCost++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (rowCount[i] == 0) {\n                for (int j = 0; j < n; j++) {\n                    if (colCount[j] == 0) {\n                        grid[i][j] = 1;\n                        rowCount[i]++;\n                        colCount[j]++;\n                        operations.add(new Operation(i + 1, j + 1, true));\n                        totalCost++;\n                        break;\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (rowCount[i] == 0) {\n                for (int j = 0; j < n; j++) {\n                    if (colCount[j] == 1) {\n                        continue;\n                    }\n                    grid[i][j] = 1;\n                    rowCount[i]++;\n                    colCount[j]++;\n                    operations.add(new Operation(i + 1, j + 1, true));\n                    totalCost++;\n                    break;\n                }\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            if (colCount[j] == 0) {\n                for (int i = 0; i < n; i++) {\n                    if (rowCount[i] == 1) {\n                        continue;\n                    }\n                    grid[i][j] = 1;\n                    rowCount[i]++;\n                    colCount[j]++;\n                    operations.add(new Operation(i + 1, j + 1, true));\n                    totalCost++;\n                    break;\n                }\n            }\n        }\n\n        System.out.println(totalCost);\n        System.out.println(operations.size());\n        for (Operation op : operations) {\n            System.out.println(op.row + \" \" + op.col + \" \" + (op.isAdd ? \"1\" : \"0\"));\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:35:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TarouCircleGame {\n    static final int INF = Integer.MAX_VALUE;\n\n    public static void solve(int n, int[][] costs) {\n        int[][] dp = new int[1 << n][n];\n        int[][] prev = new int[1 << n][n];\n\n        for (int[] row : dp) {\n            Arrays.fill(row, INF);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dp[1 << j][j] = 0;\n        }\n\n        for (int mask = 0; mask < (1 << n); mask++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[mask][j] == INF) continue;\n\n                for (int k = 0; k < n; k++) {\n                    if ((mask & (1 << k)) > 0) continue;\n\n                    int newMask = mask | (1 << k);\n                    int newCost = dp[mask][j] + costs[j][k];\n\n                    if (newCost < dp[newMask][k]) {\n                        dp[newMask][k] = newCost;\n                        prev[newMask][k] = j;\n                    }\n                }\n            }\n        }\n\n        int minCost = INF;\n        int endMask = 0, endPos = 0;\n\n        for (int j = 0; j < n; j++) {\n            if (dp[(1 << n) - 1][j] < minCost) {\n                minCost = dp[(1 << n) - 1][j];\n                endMask = (1 << n) - 1;\n                endPos = j;\n            }\n        }\n\n        List<int[]> operations = new ArrayList<>();\n        int currentMask = endMask;\n        int currentPos = endPos;\n\n        while (currentMask > 0) {\n            int prevPos = prev[currentMask][currentPos];\n            int diffMask = currentMask ^ (1 << currentPos);\n\n            for (int j = 0; j < n; j++) {\n                if ((diffMask & (1 << j)) > 0) {\n                    operations.add(new int[]{prevPos, j, 1});\n                }\n            }\n\n            for (int j = 0; j < n; j++) {\n                if ((currentMask & (1 << j)) > 0 && (prevPos != j)) {\n                    operations.add(new int[]{prevPos, j, 0});\n                }\n            }\n\n            currentMask = diffMask;\n            currentPos = prevPos;\n        }\n\n        System.out.println(minCost);\n        System.out.println(operations.size());\n        for (int[] op : operations) {\n            System.out.println((op[0] + 1) + \" \" + (op[1] + 1) + \" \" + op[2]);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] costs = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                costs[i][j] = scanner.nextInt();\n            }\n        }\n\n        solve(n, costs);\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:35:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 10\n\nint grid[MAX_N][MAX_N];\nint n, add_cost, remove_cost;\nint min_total_cost = INT_MAX;\nint best_grid[MAX_N][MAX_N];\nint operations[MAX_N * MAX_N][3];\nint best_operations[MAX_N * MAX_N][3];\nint operation_count = 0;\nint best_operation_count = 0;\n\nint check_valid_state() {\n    for (int i = 0; i < n; i++) {\n        int row_count = 0;\n        for (int j = 0; j < n; j++) {\n            row_count += grid[i][j];\n        }\n        if (row_count != 1) return 0;\n    }\n\n    for (int j = 0; j < n; j++) {\n        int col_count = 0;\n        for (int i = 0; i < n; i++) {\n            col_count += grid[i][j];\n        }\n        if (col_count != 1) return 0;\n    }\n\n    return 1;\n}\n\nvoid solve(int row, int col, int current_cost) {\n    if (row == n) {\n        if (check_valid_state() && current_cost < min_total_cost) {\n            min_total_cost = current_cost;\n            memcpy(best_grid, grid, sizeof(grid));\n            best_operation_count = operation_count;\n            memcpy(best_operations, operations, sizeof(operations[0]) * operation_count);\n        }\n        return;\n    }\n\n    int next_row = row, next_col = col + 1;\n    if (next_col == n) {\n        next_row++;\n        next_col = 0;\n    }\n\n    // Skip this cell\n    solve(next_row, next_col, current_cost);\n\n    // Add circle\n    if (grid[row][col] == 0) {\n        grid[row][col] = 1;\n        operations[operation_count][0] = row;\n        operations[operation_count][1] = col;\n        operations[operation_count][2] = 1;\n        operation_count++;\n        solve(next_row, next_col, current_cost + add_cost);\n        operation_count--;\n        grid[row][col] = 0;\n    }\n\n    // Remove circle\n    if (grid[row][col] == 1) {\n        grid[row][col] = 0;\n        operations[operation_count][0] = row;\n        operations[operation_count][1] = col;\n        operations[operation_count][2] = 0;\n        operation_count++;\n        solve(next_row, next_col, current_cost + remove_cost);\n        operation_count--;\n        grid[row][col] = 1;\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &add_cost, &remove_cost);\n\n    memset(grid, 0, sizeof(grid));\n    solve(0, 0, 0);\n\n    printf(\"%d\\n\", min_total_cost);\n    printf(\"%d\\n\", best_operation_count);\n\n    for (int i = 0; i < best_operation_count; i++) {\n        printf(\"%d %d %d\\n\", best_operations[i][0], best_operations[i][1], best_operations[i][2]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Operation {\n    int row, col;\n    bool add;\n};\n\nint solve(vector<vector<int>>& grid, vector<int>& rowCost, vector<int>& colCost) {\n    int n = grid.size();\n    vector<Operation> operations;\n    int totalCost = 0;\n\n    for (int r = 0; r < n; r++) {\n        int circleCount = 0;\n        vector<int> candidates;\n\n        for (int c = 0; c < n; c++) {\n            if (grid[r][c] == 1) circleCount++;\n            else candidates.push_back(c);\n        }\n\n        if (circleCount > 1) {\n            for (int i = 1; i < circleCount; i++) {\n                int removeCol = candidates.front();\n                grid[r][removeCol] = 0;\n                operations.push_back({r, removeCol, false});\n                totalCost += colCost[removeCol];\n                candidates.erase(candidates.begin());\n            }\n        } else if (circleCount == 0) {\n            int minCostCol = candidates[0];\n            int minCost = colCost[minCostCol];\n\n            for (int col : candidates) {\n                if (colCost[col] < minCost) {\n                    minCost = colCost[col];\n                    minCostCol = col;\n                }\n            }\n\n            grid[r][minCostCol] = 1;\n            operations.push_back({r, minCostCol, true});\n            totalCost += minCost;\n        }\n    }\n\n    for (int c = 0; c < n; c++) {\n        int circleCount = 0;\n        vector<int> candidates;\n\n        for (int r = 0; r < n; r++) {\n            if (grid[r][c] == 1) circleCount++;\n            else candidates.push_back(r);\n        }\n\n        if (circleCount > 1) {\n            for (int i = 1; i < circleCount; i++) {\n                int removeRow = candidates.front();\n                grid[removeRow][c] = 0;\n                operations.push_back({removeRow, c, false});\n                totalCost += rowCost[removeRow];\n                candidates.erase(candidates.begin());\n            }\n        } else if (circleCount == 0) {\n            int minCostRow = candidates[0];\n            int minCost = rowCost[minCostRow];\n\n            for (int row : candidates) {\n                if (rowCost[row] < minCost) {\n                    minCost = rowCost[row];\n                    minCostRow = row;\n                }\n            }\n\n            grid[minCostRow][c] = 1;\n            operations.push_back({minCostRow, c, true});\n            totalCost += minCost;\n        }\n    }\n\n    cout << totalCost << endl;\n    cout << operations.size() << endl;\n    for (auto& op : operations) {\n        cout << op.row + 1 << \" \" << op.col + 1 << \" \" << (op.add ? 1 : 0) << endl;\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<int> rowCost(n);\n    for (int i = 0; i < n; i++) {\n        cin >> rowCost[i];\n    }\n\n    vector<int> colCost(n);\n    for (int i = 0; i < n; i++) {\n        cin >> colCost[i];\n    }\n\n    solve(grid, rowCost, colCost);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_cost_to_clear_grid(grid, add_cost, remove_cost):\n    n = len(grid)\n    operations = []\n    total_cost = 0\n\n    for i in range(n):\n        row_sum = sum(grid[i])\n        col_sum = sum(grid[j][i] for j in range(n))\n\n        if row_sum != 1:\n            for j in range(n):\n                if grid[i][j] == 1 and row_sum > 1:\n                    operations.append((i, j, \"remove\"))\n                    total_cost += remove_cost\n                    grid[i][j] = 0\n                    row_sum -= 1\n                elif grid[i][j] == 0 and row_sum < 1:\n                    operations.append((i, j, \"add\"))\n                    total_cost += add_cost\n                    grid[i][j] = 1\n                    row_sum += 1\n\n        if col_sum != 1:\n            for j in range(n):\n                if grid[j][i] == 1 and col_sum > 1:\n                    operations.append((j, i, \"remove\"))\n                    total_cost += remove_cost\n                    grid[j][i] = 0\n                    col_sum -= 1\n                elif grid[j][i] == 0 and col_sum < 1:\n                    operations.append((j, i, \"add\"))\n                    total_cost += add_cost\n                    grid[j][i] = 1\n                    col_sum += 1\n\n    print(\"Minimum Cost:\", total_cost)\n    print(\"Number of Operations:\", len(operations))\n    for op in operations:\n        print(f\"Row: {op[0]+1}, Column: {op[1]+1}, Operation: {op[2]}\")\n\n# Example usage\nn = 3\ngrid = [\n    [0, 1, 0],\n    [0, 0, 0],\n    [1, 0, 0]\n]\nadd_cost = 2\nremove_cost = 3\nmin_cost_to_clear_grid(grid, add_cost, remove_cost)",
    "timestamp": "2025-08-13 06:53:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CirclePlacementGame {\n    static class Operation {\n        int row;\n        int col;\n        boolean add; // true means add, false means remove\n        \n        Operation(int row, int col, boolean add) {\n            this.row = row;\n            this.col = col;\n            this.add = add;\n        }\n        \n        @Override\n        public String toString() {\n            return (add ? \"Add\" : \"Remove\") + \" circle at (\" + row + \", \" + col + \")\";\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] grid = new int[n][n];\n        int[][] addCost = new int[n][n];\n        int[][] removeCost = new int[n][n];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = scanner.nextInt();  // 1 if there's a circle, 0 otherwise\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                addCost[i][j] = scanner.nextInt();\n                removeCost[i][j] = scanner.nextInt();\n            }\n        }\n        \n        List<Operation> operations = new ArrayList<>();\n        boolean[] rowHasCircle = new boolean[n];\n        boolean[] colHasCircle = new boolean[n];\n        \n        // Initially mark existing circles\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    rowHasCircle[i] = true;\n                    colHasCircle[j] = true;\n                }\n            }\n        }\n        \n        int totalCost = 0;\n        \n        // Check row by row\n        for (int i = 0; i < n; i++) {\n            if (!rowHasCircle[i]) {\n                // Place circle in this row\n                int minCost = Integer.MAX_VALUE;\n                int bestCol = -1;\n                boolean isAdding = true;\n                \n                for (int j = 0; j < n; j++) {\n                    if (colHasCircle[j]) {\n                        // Remove existing circle\n                        int cost = removeCost[i][j];\n                        if (cost < minCost) {\n                            minCost = cost;\n                            bestCol = j;\n                            isAdding = false;\n                        }\n                    } else {\n                        // Add new circle\n                        int cost = addCost[i][j];\n                        if (cost < minCost) {\n                            minCost = cost;\n                            bestCol = j;\n                            isAdding = true;\n                        }\n                    }\n                }\n                \n                if (isAdding) {\n                    // Adding circle operation\n                    operations.add(new Operation(i, bestCol, true));\n                    totalCost += addCost[i][bestCol];\n                    colHasCircle[bestCol] = true;\n                } else {\n                    // Removing circle operation\n                    operations.add(new Operation(i, bestCol, false));\n                    totalCost += removeCost[i][bestCol];\n                }\n                rowHasCircle[i] = true;\n            }\n        }\n        \n        // Ensure every column has a circle\n        for (int j = 0; j < n; j++) {\n            if (!colHasCircle[j]) {\n                // Add circle to this column\n                int minCost = Integer.MAX_VALUE;\n                int bestRow = -1;\n                \n                for (int i = 0; i < n; i++) {\n                    if (!rowHasCircle[i]) {\n                        int cost = addCost[i][j];\n                        if (cost < minCost) {\n                            minCost = cost;\n                            bestRow = i;\n                        }\n                    }\n                }\n                \n                if (bestRow != -1) {\n                    operations.add(new Operation(bestRow, j, true));\n                    totalCost += addCost[bestRow][j];\n                    rowHasCircle[bestRow] = true;\n                }\n            }\n        }\n        \n        // Print output\n        System.out.println(totalCost);\n        System.out.println(operations.size());\n        for (Operation op : operations) {\n            System.out.println((op.row + 1) + \" \" + (op.col + 1) + \" \" + (op.add ? \"A\" : \"R\"));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 06:54:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 50\n\nint grid[MAXN][MAXN]; // 0: empty, 1: circle present\nint addCost[MAXN][MAXN];\nint removeCost[MAXN][MAXN];\n\ntypedef struct {\n    int row, col;\n    char op; // '+' for adding, '-' for removing\n} Operation;\n\nOperation operations[MAXN * MAXN];\nint opCount;\n\nint minCost, n;\n\nvoid solve(int currentCost) {\n    if (currentCost >= minCost) return;\n\n    int rowCount[MAXN] = {0}, colCount[MAXN] = {0};\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j]) {\n                rowCount[i]++;\n                colCount[j]++;\n            }\n        }\n    }\n\n    int complete = 1;\n    for (int i = 0; i < n; i++) {\n        if (rowCount[i] != 1 || colCount[i] != 1) {\n            complete = 0;\n            break;\n        }\n    }\n\n    if (complete) {\n        if (currentCost < minCost) {\n            minCost = currentCost;\n            opCount = 0;\n        }\n        return;\n    }\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 0 && (rowCount[i] == 0 || colCount[j] == 0)) {\n                operations[opCount++] = (Operation){i, j, '+'};\n                grid[i][j] = 1;\n                solve(currentCost + addCost[i][j]);\n                grid[i][j] = 0;\n                --opCount;\n            } else if (grid[i][j] == 1 && (rowCount[i] > 1 || colCount[j] > 1)) {\n                operations[opCount++] = (Operation){i, j, '-'};\n                grid[i][j] = 0;\n                solve(currentCost + removeCost[i][j]);\n                grid[i][j] = 1;\n                --opCount;\n            }\n        }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            scanf(\"%d\", &grid[i][j]);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            scanf(\"%d\", &addCost[i][j]);\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            scanf(\"%d\", &removeCost[i][j]);\n\n    minCost = INT_MAX;\n    solve(0);\n\n    printf(\"%d\\n\", minCost);\n    printf(\"%d\\n\", opCount);\n    for (int i = 0; i < opCount; i++) {\n        printf(\"%d %d %c\\n\", operations[i].row + 1, operations[i].col + 1, operations[i].op);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:54:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_grid(n, costs):\n    def is_valid_grid(grid):\n        for row in grid:\n            if row.count(1) != 1:\n                return False\n        for col in range(n):\n            if sum(grid[r][col] for r in range(n)) != 1:\n                return False\n        return True\n\n    def dfs(grid, total_cost, operations):\n        nonlocal min_cost, best_operations\n        \n        if is_valid_grid(grid):\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_operations = operations.copy()\n            return\n        \n        for r in range(n):\n            circle_count = sum(grid[r])\n            for c in range(n):\n                if circle_count == 1 and grid[r][c] == 1:\n                    continue\n                \n                # Try adding a circle\n                if grid[r][c] == 0:\n                    grid[r][c] = 1\n                    operations.append((r+1, c+1, '+'))\n                    dfs(grid, total_cost + costs[r][c], operations)\n                    operations.pop()\n                    grid[r][c] = 0\n                \n                # Try removing a circle\n                if grid[r][c] == 1:\n                    grid[r][c] = 0\n                    operations.append((r+1, c+1, '-'))\n                    dfs(grid, total_cost + costs[r][c], operations)\n                    operations.pop()\n                    grid[r][c] = 1\n\n    min_cost = float('inf')\n    best_operations = []\n    grid = [[0]*n for _ in range(n)]\n    dfs(grid, 0, [])\n    \n    print(min_cost)\n    print(len(best_operations))\n    for op in best_operations:\n        print(f\"{op[0]} {op[1]} {op[2]}\")\n\n# Read input\nn = int(input())\ncosts = [list(map(int, input().split())) for _ in range(n)]\n\nsolve_grid(n, costs)",
    "timestamp": "2025-08-13 06:54:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    n = int(sys.stdin.readline())\n    grid = []\n    for _ in range(n):\n        row = list(map(int, sys.stdin.readline().split()))\n        grid.append(row)\n    \n    # Create cost matrix\n    cost_matrix = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            # Cost to have a circle in (i,j): if already a circle, 0; else cost to add\n            cost_matrix[i][j] = grid[i][j]\n    \n    # Convert to numpy array for linear_sum_assignment\n    cost_array = np.array(cost_matrix)\n    row_ind, col_ind = linear_sum_assignment(cost_array)\n    \n    total_cost = cost_array[row_ind, col_ind].sum()\n    \n    operations = []\n    current_grid = [[0]*n for _ in range(n)]\n    \n    # Mark existing circles\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                current_grid[i][j] = 1  # 1 means circle exists (cost 0 to keep)\n    \n    # Determine operations needed\n    for i, j in zip(row_ind, col_ind):\n        if current_grid[i][j] != 1:\n            operations.append((i+1, j+1, 'ADD'))\n    \n    # Check for extra circles to remove\n    for i in range(n):\n        for j in range(n):\n            if current_grid[i][j] == 1 and (i not in row_ind or j != col_ind[list(row_ind).index(i)]):\n                operations.append((i+1, j+1, 'REMOVE'))\n    \n    print(total_cost)\n    print(len(operations))\n    for op in operations:\n        print(op[0], op[1], op[2])\n\nsolve()",
    "timestamp": "2025-08-13 06:58:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nstruct Operation {\n    int row, col;\n    bool add; // true for add circle, false for remove circle\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(n, vector<int>(n));\n    vector<vector<int>> costAdd(n, vector<int>(n)), costRemove(n, vector<int>(n));\n\n    // Read initial grid and costs\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            char cell;\n            cin >> cell;\n            grid[i][j] = (cell == 'o'); // 'o' means there is a circle\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> costAdd[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> costRemove[i][j];\n        }\n    }\n\n    vector<Operation> operations;\n    vector<int> rowCircles(n, -1), colCircles(n, -1);\n    int minCost = 0;\n\n    // Find initial positions of circles in rows and columns\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                rowCircles[i] = j;\n                colCircles[j] = i;\n            }\n        }\n    }\n\n    // Adjust operations to make sure there's exactly one circle per row and per column\n    for (int i = 0; i < n; ++i) {\n        if (rowCircles[i] == -1) {\n            // Find a column without a circle\n            for (int j = 0; j < n; ++j) {\n                if (colCircles[j] == -1) {\n                    minCost += costAdd[i][j];\n                    operations.push_back({i + 1, j + 1, true});\n                    rowCircles[i] = j;\n                    colCircles[j] = i;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Correct any remaining discrepancy\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (rowCircles[i] != j && grid[i][j]) {\n                minCost += costRemove[i][j];\n                operations.push_back({i + 1, j + 1, false});\n            }\n        }\n    }\n\n    cout << minCost << endl;\n    cout << operations.size() << endl;\n    for (const auto &op : operations) {\n        cout << op.row << \" \" << op.col << \" \" << (op.add ? \"Add\" : \"Remove\") << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:34:52"
  }
]