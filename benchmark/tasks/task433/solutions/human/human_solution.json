[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nstruct edge/*{{{*/\n{\n  int to;\n  int capacity;\n  int cost;\n  edge(int i, int c, int d) : to(i), capacity(c), cost(d) {}\n};/*}}}*/\n\npair<int,vector<vector<int> > > primal_dual(const vector<vector<edge> >& g, int source, int sink)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)), flow(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<edge>::const_iterator it = g[i].begin(); it != g[i].end(); ++it) {\n      capacity[i][it->to] += it->capacity;\n      cost[i][it->to] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  static const int INF = 10000000;\n  for (int f = INF; f > 0; ) {\n    vector<int> dist(N, INF);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<edge>::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (capacity[n][it->to] - flow[n][it->to] > 0) {\n          const int c2 = c + cost[n][it->to] + h[n] - h[it->to];\n          if (c2 < dist[it->to]) {\n            dist[it->to] = c2;\n            parent[it->to] = n;\n            q.push(make_pair(-c2, it->to));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return make_pair(total.first, flow);\n}/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > erase(N, vector<int>(N)), write(N, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> erase[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> write[i][j];\n    }\n  }\n  int init = 0;\n  for (int i = 0; i < N; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < N; j++) {\n      if (s[j] == 'o') {\n        init += erase[i][j];\n        write[i][j] = -erase[i][j];\n      }\n    }\n  }\n\n  vector<vector<edge> > g(2*N+2);\n  const int source = 2*N, sink = 2*N+1;\n  for (int i = 0; i < N; i++) {\n    const int row = i, col = N+i;\n    g[source].push_back(edge(row, 1, 0));\n    g[col].push_back(edge(sink, 1, 0));\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      g[row].push_back(edge(col, 1, write[i][j]));\n      g[col].push_back(edge(row, 0, -write[i][j]));\n    }\n  }\n\n  const pair<int,vector<vector<int> > > r = primal_dual(g, source, sink);\n  const int ans = init + r.first;\n  const vector<vector<int> >& flow = r.second;\n  cout << ans << endl;\n  vector<string> steps;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      if (flow[row][col] == 1 && write[i][j] > 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" write\";\n        steps.push_back(oss.str());\n      } else if (flow[row][col] == 0 && write[i][j] < 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" erase\";\n        steps.push_back(oss.str());\n      }\n    }\n  }\n  cout << steps.size() << endl;\n  copy(steps.begin(), steps.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nconst ll inf = 1e14;\n\nclass min_cost_flow{\npublic:\n    int N;\n    struct edge{int to; ll cap,cost; int rev; bool is_rev;};\n    vector<vector<edge>> G;\n    vector<ll> h,dist,prevv,preve;\n    min_cost_flow(int n){\n        N = n;\n        G = vector<vector<edge>>(N);\n        h = dist = prevv = preve = vector<ll>(N,0);\n    }\n    void add_edge(int from,int to,ll cap,ll cost){\n        G[from].push_back((edge){to,cap,cost,(int) G[to].size(),false});\n        G[to].push_back((edge){from,0,-cost,(int) G[from].size()-1,true});\n    }\n    ll answer(int s,int t,ll f){\n        ll res = 0;\n        fill(h.begin(),h.end(),0);\n        while(f>0){\n            priority_queue<P,vector<P>,greater<P>> Q;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            Q.push(P(s,0));\n            while(!Q.empty()){\n                P p = Q.top(); Q.pop();\n                int v = p.second;\n                if(dist[v]<p.first) continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        Q.push(P(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[t]==inf) return -1;\n            for(int v=0;v<N;v++) h[v] += dist[v];\n            ll d = f;\n            for(int v=t;v!=s; v=prevv[v]){\n                d = min(d,G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    vector<vector<ll>> W(N+1,vector<ll>(N+1,0)),E(N+1,vector<ll>(N+1,0));\n    vector<vector<char>> F(N+1,vector<char>(N+1,0));\n    for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) cin >> W[i][j];\n    for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) cin >> E[i][j];\n    min_cost_flow flow(2*N+2);\n    ll sum = 0;\n    for(int i=1;i<=N;i++) for(int j=1;j<=N;j++){\n        cin >> F[i][j];\n        if(F[i][j]=='o'){\n            flow.add_edge(i,N+j,1,-E[i][j]);\n            sum += E[i][j];\n        }else{\n            flow.add_edge(i,N+j,1,W[i][j]);\n        }\n    }\n    for(int i=1;i<=N;i++){\n        flow.add_edge(0,i,1,0);\n        flow.add_edge(i+N,2*N+1,1,0);\n    }\n    ll res = flow.answer(0,2*N+1,N);\n    cout << sum+res << endl;\n    struct operation{\n        int x,y;\n        string op;\n    };\n    vector<operation> ans;\n    for(int i=N+1;i<=2*N;i++){\n        for(auto& x:flow.G[i]){\n            if(x.is_rev){\n                if(x.cost>0 && x.cap==0){\n                    ans.push_back({x.to,i-N,\"erase\"});\n                }else if(x.cost<0 && x.cap==1){\n                    ans.push_back({x.to,i-N,\"write\"});\n                }\n            }\n        }\n    }\n    cout << (int) ans.size() << endl;\n    for(auto& x:ans) cout << x.x << \" \" << x.y << \" \" << x.op << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<numeric>\n#include<limits>\n#include<queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef int weight;\ntypedef vector<vector<int> > matrix;\nint inf = 1000000005;\nweight hungarian(const matrix &a,vector<int> &x,vector<int> &y) {\n  int n = a.size(), p, q;\n  vector<int> fx(n, inf), fy(n, 0);\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      fx[i] = max(fx[i], a[i][j]);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n+1, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == a[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      weight d = inf;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - a[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  weight ret = 0;\n  for (int i = 0; i < n; ++i) ret += a[i][x[i]];\n  return ret;\n}\n\n\nint main(){\n    int n;\n    cin >> n;\n    vector<vector<int> >a(n,vector<int>(n));\n    vector<vector<int> >b(n,vector<int>(n));\n    rep(i,n){\n        rep(j,n){\n            cin >> a[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            cin >> b[i][j];\n        }\n    }\n    vector<string>s(n);\n    rep(i,n){\n        cin >> s[i];\n    }\n    vector<int> x(n, -1), y(n, -1);\n    vector<vector<int> > v(n,vector<int>(n));\n    for(int j=0;j<n;j++){\n        for(int i=0;i<n;i++){\n            int tmp = 0;\n            for(int k=0;k<n;k++){\n                if(i==k&&s[k][j]=='.'){\n                    tmp += a[k][j];\n                }else if(i!=k&&s[k][j]=='o'){\n                    tmp += b[k][j];\n                }\n            }\n            v[i][j] = -tmp;\n        }\n    }\n    int ans = hungarian(v,x,y);\n    cout << -ans << endl;\n    vector<string>t(n);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(j!=x[i]){\n                t[i].push_back('.');\n            }else{\n                t[i].push_back('o');\n            }\n        }\n    }\n    vector<pair<int,int> > ss;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(s[i][j]!=t[i][j]){\n                ss.push_back(make_pair(i,j));\n            }\n        }\n    }\n    cout << ss.size() << endl;\n    for(auto x:ss){\n        if(s[x.first][x.second]=='o'){\n            cout << x.first+1 << \" \" << x.second+1 << \" erase\" << endl;\n        }else{\n            cout << x.first+1 << \" \" << x.second+1 << \" write\" << endl;\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100\n#define MAX_V 1000\n#define INF 1e9\nusing namespace std;\nint n,W[100][100],E[100][100];\nstring F[100];\nint N,K;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;     \n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint Biparite_Matching(){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  int res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(F[i][j]=='o')res+=E[i][j],add_edge(i,N+j,1,-E[i][j]);\n      else add_edge(i,N+j,1,W[i][j]);    \n  return res+min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>W[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>E[i][j];\n  for(int i=0;i<n;i++)cin>>F[i];\n  N=K=n,V=2*n+2;\n  cout<<Biparite_Matching()<<endl;\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')cnt++;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')cnt++;\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" write\"<<endl;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" erase\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            if (v < l+1) {\n            \tused[v] = true;\n\t            for (int i = l+1; i < l+r+2; i++) {\n\t\t\t\t\tif (!flow[v][i-(l+1)] && dist[i] > dist[v] + G[v][i-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] + G[v][i=(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v-(l+1)] && dist[i] > dist[v] - G[i][v-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] - G[i][v-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v-(l+1);\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevv[v] : prevv[v+l+1], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevv[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <limits>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nclass CostFlow\n{\npublic:\n    using Cost = ll;\n    using Ind = int;\n    using Capacity = ll;\n    using T = ll;\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}\n    {\n        edge.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // // Bellman-Ford(Replace this when DAG)\n        // for (int i = 0; i < V; i++) {\n        //     m_potential[i] = INF<T>;\n        // }\n        // m_potential[s] = 0;\n        // bool no_negative_loop = true;\n        // for (int i = 0; i < V; i++) {\n        //     for (int v = 0; v < V; v++) {\n        //         if (m_potential[v] != INF<T>) {\n        //             for (const auto& e : edge[v]) {\n        //                 if (e.capacity <= 0) {\n        //                     continue;\n        //                 }\n        //                 if (m_potential[e.to] > m_potential[v] + e.cost) {\n        //                     m_potential[e.to] = m_potential[v] + e.cost;\n        //                     if (i == V - 1) {\n        //                         m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n        //                         no_negative_loop = false;\n        //                     }\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // if (not no_negative_loop) {\n        //     // ????????¨?????????\n        // }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                //                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> m_dist;\n    vector<Cost> m_potential;\n    vector<Ind> m_prev_v;\n    vector<Ind> m_prev_e;\n};\n\nstruct Ope {\n    bool o;\n    int r;\n    int c;\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<ll>> W(n, vector<ll>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n    vector<vector<ll>> E(n, vector<ll>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    vector<vector<bool>> use(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n; j++) {\n            use[i][j] = (s[j] == 'o');\n        }\n    }\n\n    vector<vector<ll>> c(n, vector<ll>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (not use[i][j]) {\n                c[i][j] = W[i][j];\n            } else {\n                for (int k = 0; k < n; k++) {\n                    if (j == k) {\n                        continue;\n                    }\n                    c[i][k] += E[i][j];\n                }\n                // for (int k = 0; k < n; k++) {\n                //     if (i == k) {\n                //         continue;\n                //     }\n                //     c[k][j] += E[i][j];\n                // }\n            }\n        }\n    }\n\n    CostFlow flow(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            flow.addEdge(i, j + n, 1, c[i][j]);\n        }\n    }\n    const int s = 2 * n;\n    const int t = 2 * n + 1;\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(s, i, 1, 0);\n        flow.addEdge(n + i, t, 1, 0);\n    }\n    cout << flow.minCostFlow(s, t, n) << endl;\n\n    vector<Ope> op;\n    for (int i = 0; i < n; i++) {\n        for (const auto& e : flow.edge[i]) {\n            if (e.is_reverse) {\n                continue;\n            }\n            if (e.flow == 1) {\n                if (not use[i][e.to - n]) {\n                    op.push_back(Ope{false, i, e.to - n});\n                }\n            } else {\n                if (use[i][e.to - n]) {\n                    op.push_back(Ope{true, i, e.to - n});\n                }\n            }\n        }\n    }\n\n    cout << op.size() << endl;\n    for (const auto& o : op) {\n        cout << o.r + 1 << \" \" << o.c + 1 << \" \" << (o.o ? \"erase\" : \"write\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < int(Y);++(X))\n#define peat(X,Y) for (;(X) < int(Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,g[to].size(),cost});\n  g[to].pb((Edge){from,0,g[from].size()-1,-cost});\n}\nCost INF=1e7;\n\n//min-cost,dij\n\ntypedef pair<Cost,int> Que;\n\nint V;\n\n//f流せなければINF\nCost min_cost_flow(Graph &g,int s,int t,int f){\n  int V=g.size(),res=0;\n  vector<Cost> h(V,0),d(V);\n  vector<int> prevv(V),preve(V);\n  while(f>0){\n    priority_queue<Que,vector<Que>,greater<Que> > que;\n    int V=g.size();\n    d.resize(V);\n    fill(all(d),INF);\n    d[s]=0;\n    que.push(Que(0,s));\n    while(!que.empty()){\n      Que p=que.top();que.pop();\n      int v=p.Y;\n      if(d[v]<p.X)continue;\n      rep(i,g[v].size()){\n        Edge &e=g[v][i];\n        if(e.cap>0 && d[e.to]>d[v]+e.cost+h[v]-h[e.to]){\n          d[e.to]=d[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(Que(d[e.to],e.to));\n        }\n      }\n    }\n    if(d[t] == INF){\n      return INF;\n    }\n    rep(v,V)\n      h[v]+=d[v];\n    int flow=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      flow=min(flow,g[prevv[v]][preve[v]].cap);\n    }\n    f-=flow;\n    res+=flow*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      Edge &e=g[prevv[v]][preve[v]];\n      e.cap-=flow;\n      g[v][e.rev].cap+=flow;\n    }\n  }\n  return res;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k,n;\n  cin>>n;\n  vector<vector<int> > w(n,vector<int>(n)),e(n,vector<int>(n));\n  rep(i,n)rep(j,n)\n    cin>>w[i][j];\n  rep(i,n)rep(j,n)\n    cin>>e[i][j];\n  string str,strs[n];\n  Graph g(n*2+2);\n  rep(i,n){\n    cin>>str;\n    strs[i]=str;\n    int sum=0;\n    rep(j,n){\n      if(str[j]=='o'){\n        w[i][j]=-e[i][j];\n        sum+=e[i][j];\n      }\n    }\n    rep(j,n)\n      add_edge(g,i+2,j+n+2,1,sum+w[i][j]);\n    add_edge(g,0,i+2,1,0);\n    add_edge(g,i+n+2,1,1,0);\n  }\n  cout<<min_cost_flow(g,0,1,n)<<endl;\n  vector<pii> er,wr;\n  rep(i,n){\n    int fr;\n    rep(j,g[i+n+2].size()){\n      if(g[i+n+2][j].cap){\n        fr=g[i+n+2][j].to-2;\n        break;\n      }\n    }\n    rep(j,n){\n      if(j==fr){\n        if(strs[i][j]=='.')\n          wr.pb(pii(i,j));\n      }else{\n        if(strs[i][j]=='o')\n          er.pb(pii(i,j));\n      }\n    }\n  }\n  cout<<er.size()+wr.size()<<endl;\n  rep(i,wr.size())\n    cout<<wr[i].X+1<<\" \"<<wr[i].Y+1<<\" write\"<<endl;\n  rep(i,er.size())\n    cout<<er[i].X+1<<\" \"<<er[i].Y+1<<\" erase\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nstruct Edge{\n  int to, cap, cost, rev;\n  Edge(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\n\nconst int MAX_V = 100*5;\nint V;\nvector<Edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back(Edge(to, cap, cost, G[to].size()));\n  G[to].push_back(Edge(from, 0, -cost, G[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  while(f > 0){\n\tfill(dist, dist+V, INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t  update = false;\n\t  for(int v=0;v<V;++v){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(int i=0;i<G[v].size();++i){\n\t\t  Edge& e = G[v][i];\n\t\t  if(e.cap > 0 && dist[v] + e.cost < dist[e.to]){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\n\tif(dist[t] == INF) return -1;\n\n\tint d = f;\n\tfor(int v=t;v!=s;v=prevv[v])\n\t  d = min(d, G[prevv[v]][preve[v]].cap);\n\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t  Edge& e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n  }\n  \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n\n  int N; cin >> N;\n  VVI ws(N, VI(N)), es(N, VI(N));\n  REP(y,N) REP(x,N) cin >> ws[y][x];\n  REP(y,N) REP(x,N) cin >> es[y][x];\n\n  VS vs(N);\n  REP(i,N) cin >> vs[i];\n\n  int S = N*2;\n  int T = S + 1;\n  V = T+1;\n\n  REP(i,N) add_edge(S, i, 1, 0);\n  REP(i,N) add_edge(i+N, T, 1, 0);\n  \n  int bias = 0;\n  REP(y,N) REP(x,N){\n\tif(vs[y][x] == '.'){\n\t  add_edge(y, N+x, 1, ws[y][x]);\n\t}\n\telse{\n\t  add_edge(y, N+x, 1, -es[y][x]);\n\t  bias += es[y][x];\n\t}\n  }\n  int ans = min_cost_flow(S, T, N) + bias;\n\n  cout << ans << endl;\n  vector<pair<PII,string>> qs;\n  REP(y,N){\n\tfor(auto&& e: G[y]){\n\t  int x = e.to - N;\n\t  if(e.cap == 0 && vs[y][x] == '.'){\n\t\tqs.EB(MP(y+1,x+1), \"write\");\n\t  }\n\t  else if(e.cap == 1 && vs[y][x] == 'o'){\n\t\tqs.EB(MP(y+1,x+1), \"erase\");\n\t  }\n\t}\n  }\n\n  cout << SZ(qs) << endl;\n  for(auto&& p: qs){\n\tcout << p.FF << \" \" << p.SS << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct edge{\n\tint to,cap,cost,rev;\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nclass MCF{\t//Minimum Cost Flow\n\tpublic:\n\tint n;\n\tvve G;\n\tvi h,dist,prev,pree;\n\tMCF(int size){\n\t\tn=size;\n\t\tG=vve(n);\n\t\th=dist=prev=pree=vi(n);\n\t}\n\tvoid add_edge(int s,int t,int ca,int co){\n\t\tedge e={t,ca,co,G[t].size()};\n\t\tG[s].pb(e);\n\t\tedge ee={s,0,-co,G[s].size()-1};\n\t\tG[t].pb(ee);\n\t}\n\tint mcf(int s,int t,int f){\n\t\tint out=0;\n\t\th=vi(n);\n\t\twhile(f>0){\t\t\t\n\t\t\tpriority_queue<pii,vector<pii> >q;\n\t\t\tdist=vi(n,inf);\n\t\t\tdist[s]=0;\n\t\t\tq.push(pii(0,s));\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii p=q.top();q.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<-p.first)continue;\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tprev[e.to]=v;\n\t\t\t\t\t\tpree[e.to]=i;\n\t\t\t\t\t\tq.push(pii(-dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf)return -1;\n\t\t\trep(i,n)h[i]+=dist[i];\n\t\t\tint d=f;\n\t\t\tfor(int v=t;v!=s;v=prev[v])d=min(d,G[prev[v]][pree[v]].cap);\n\t\t\tf-=d;\n\t\t\tout+=d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prev[v]){\n\t\t\t\tedge &e=G[prev[v]][pree[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tG[v][e.rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn out;\t\n\t}\n};\n//struct edge{\n//\tint to,cap,cost,rev;\n//};\nint main(){\n\tint n;\n\tcin>>n;\n\tvvi tu(n,vi(n));\n\tvvi ke(n,vi(n));\n\trep(i,n)rep(j,n)cin>>tu[i][j];\n\trep(i,n)rep(j,n)cin>>ke[i][j];\n\tMCF mcf(2*n+2);\n\tint s=2*n,t=s+1;\n\trep(i,n)mcf.add_edge(s,i,1,0);\n\trep(i,n)mcf.add_edge(n+i,t,1,0);\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\trep(i,n)rep(j,n){\n\t\tint sum=0;\n\t\tif(in[i][j]=='.')sum+=tu[i][j]*2;\n\t\trep(k,n)if(i!=k&&in[k][j]=='o')sum+=ke[k][j];\n\t\trep(k,n)if(j!=k&&in[i][k]=='o')sum+=ke[i][k];\n\t\tmcf.add_edge(i,n+j,1,sum);\n\t}\n\tint f=mcf.mcf(s,t,n)/2;\n\tcout<<f<<endl;\n\tvve G=mcf.G;\n\tint co=0;\n\trep(i,n)rep(j,G[i].size()){\n\t\tint to=G[i][j].to-n;\n\t\tbool h=false;\n\t\tif(0<=to&&to<n&&!G[i][j].cap)h=1;\n\t\tif(h&&in[i][to]=='.')co++;\n\t\tif(!h&&in[i][to]=='o')co++;\n\t}\n\tcout<<co<<endl;\n\trep(i,n)rep(j,G[i].size()){\n\t\tint to=G[i][j].to-n;\n\t\tbool h=false;\n\t\tif(0<=to&&to<n&&!G[i][j].cap)h=1;\n\t\tif(h&&in[i][to]=='.')cout<<i+1<<\" \"<<to+1<<\" \"<<\"write\"<<endl;\n\t\tif(!h&&in[i][to]=='o')cout<<i+1<<\" \"<<to+1<<\" \"<<\"erase\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            if (v < l+1) {\n            \tused[v] = true;\n\t            for (int i = l+1; i < l+r+2; i++) {\n\t\t\t\t\tif (!flow[v][i-(l+1)] && dist[i] > dist[v] + G[v][i-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] + G[v][i-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v-(l+1)] && dist[i] > dist[v] - G[i][v-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] - G[i][v-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tfor (int v = l; v != l+r+1 ; v = prevv[v]) {\n\t\t\tif (v < l+1) {\n\t\t\t\tflow[v][prevv[v]-(l+1)] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v]][v-(l+1)] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<complex>\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define pb push_back\n\nusing namespace std;\n\n\nconst int MV = 500;\nconst int INF = 1000000007;\n\nclass edge{\n\tpublic:\n\tint to,cap,cost,rev;\n\tedge(int to, int cap, int cost, int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MV];\nint dist[MV];\nint prevv[MV], preve[MV];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back(edge(to,cap,cost, G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\twhile(f>0){\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<V;v++){\n\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap>0 && dist[e.to] > dist[v]+e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif(dist[t]==INF){\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tint d = f;\n\t\tfor(int v=t; v!=s; v=prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\tres += d*dist[t];\n\t\t\tfor(int v=t; v!=s; v=prevv[v]){\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\n\n\nconst int W = 100;\n\nint n;\nint w[W][W];\nint e[W][W];\n\nvector<string> board;\n\nbool input(){\n\tcin>>n;\n\trep(i,n)rep(j,n)cin>>w[i][j];\n\trep(i,n)rep(j,n)cin>>e[i][j];\n\t\n\tboard.clear();\n\trep(i,n){\n\t\tstring a;\n\t\tcin>>a;\n\t\tboard.pb(a);\n\t}\n\treturn true;\n}\n\nclass P{\n\tpublic:\n\tint i,j;\n\tstring str;\n\tP(int i,int j,string str):i(i),j(j),str(str){}\n};\n\nvoid solve(){\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tint cost = 0;\n\t\t\trep(k,n){\n\t\t\t\tif(j==k){\n\t\t\t\t\tif(board[i][k]=='o'){}\n\t\t\t\t\telse cost += w[i][k];\n\t\t\t\t}else{\n\t\t\t\t\tif(board[i][k]=='o')cost += e[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd_edge(i, n+j, 1, cost);\n\t\t}\n\t}\n\t\n\tV = 2*n+2;\n\tint snum = 2*n;\n\tint tnum = 2*n+1;\n\t\n\trep(i,n){\n\t\tadd_edge(snum, i, 1, 0);\n\t\tadd_edge(i+n, tnum, 1, 0);\n\t}\n\t\n\tint ans = min_cost_flow(snum, tnum, n);\n\t\n\t\n\tint hoge[W][W]={0};\n\t\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tif(G[i][j].cap==0){\n\t\t\t\thoge[i][G[i][j].to-n] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<P> res;\n\tstring wstr = \"write\";\n\tstring estr = \"erase\";\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(hoge[i][j] == 1 && board[i][j]=='.')res.pb(P(i,j,wstr));\n\t\t\tif(hoge[i][j] == 0 && board[i][j]=='o')res.pb(P(i,j,estr));\n\t\t}\n\t}\n\t\n\t\n\tcout<<ans<<endl;\n\tcout<<res.size()<<endl;\n\t\n\trep(i,res.size()){\n\t\tcout<<res[i].i+1<<\" \"<<res[i].j+1<<\" \"<<res[i].str<<endl;\n\t}\n}\n\nint main(){\n\tinput();\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 100000;\nconst Cost INF = numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int d; Flow c, f; Cost w; int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n            :d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = pair<Cost, int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h + n, 0);\n        while (f > 0) {\n            fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)g[v].size(); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) {\n                return -1; // ?????????????????????????????£???\n            }\n\n            // s-t ????????????????????£??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n\n    // ???????????¨???\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n\nint n;\nint W[128][128], E[128][128];\nchar f[128][128];\nint ans[10000][3];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n\n    int C = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (f[i][j] == 'o') {\n                C += E[i][j];\n            }\n        }\n    }\n\n    PrimalDual pd(n * 2 + 2);\n\n    int s = n * 2, t = n * 2 + 1;\n    for (int i = 0; i < n; i++) {\n        pd.add_edge(s, i, 1, 0);\n        pd.add_edge(i + n, t, 1, 0);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            pd.add_edge(i, j + n, 1, f[i][j] == 'o' ? -E[i][j] : W[i][j]);\n        }\n    }\n\n    cout << C + pd.solve(s, t, n) << '\\n';\n\n    int cnt = 0;\n    for (int i = 0; i < pd.g.size(); i++) {\n        for (auto &e : pd.g[i]) {\n            if (e.is_r || e.w == 0) continue;\n            if (f[i][e.d - n] == 'o' && e.f == 0) {\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 0;\n                cnt++;\n            } else if (f[i][e.d - n] == '.' && e.f == 1) {\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 1;\n                cnt++;\n            }\n        }\n    }\n\n    cout << cnt << '\\n';\n    for (int i = 0; i < cnt; i++) {\n        ans[i][0]++;\n        ans[i][1]++;\n        cout << ans[i][0] << ' ' << ans[i][1] << ' ' << (ans[i][2] == 0 ? \"erase\" : \"write\") << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\nstruct PrimalDual {\n    typedef int Capacity;\n    typedef int Cost;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    PrimalDual(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].push_back(Edge(dst, cap, cost, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, -cost, g[src].size() - 1, true));\n    }\n\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        vector<Cost> h(n), dist(n);\n        vector<int> prevv(n), preve(n);\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            dist.assign(n,inf);\n            dist[s] = 0;\n            q.push(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.push(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.min_cost_flow(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n\n    rep(i,mcf.n){\n        rep(j,mcf.n){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            if(f[i][e.dst-n]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=i+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=0;\n            }else if(f[i][e.dst-n]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=i+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(){}\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nstruct ope{\n\tint i, j, type;\n\tope(int a, int b, int c){\n\t\ti = a, j = b, type = c;\n\t}\n};\n\nint n;\nint W[105][105], E[105][105];\nchar F[105][105];\n\nint cost[105][105];\nint S, T;\nvector<edge> G[205];\nint dist[205];\nint prevv[205], preve[205];\nvector<ope> vec;\n\nvoid BellmanFord()\n{\n\tfor(int i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = 0; i <= T; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> W[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> F[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tint sum = 0;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(j == k && F[i][k] == '.') sum += W[i][j];\n\t\t\t\tif(j != k && F[i][k] == 'o') sum += E[i][j];\n\t\t\t}\n\t\t\tcost[i][j] = sum;\n\t\t}\n\t}\n\t\n\tS = 2*n, T = 2*n+1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tadd_edge(i, j+n, 1, cost[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) add_edge(S, i, 1, 0);\n\tfor(int i = 0; i < n; i++) add_edge(i+n, T, 1, 0);\n\t\n\tint f = n, ans = 0;\n\twhile(f > 0){\n\t\tBellmanFord();\n\t\t\n\t\tint p = T, flow = f;\n\t\twhile(prevv[p] != -1){\n\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\tp = prevv[p];\n\t\t}\n\t\t\n\t\tp = T;\n\t\twhile(prevv[p] != -1){\n\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\tp = prevv[p];\n\t\t}\n\t\tf -= flow;\n\t\tans += dist[T] * flow;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].cap > 0) continue;\n\t\t\tint J = G[i][j].to - n;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(J == k && F[i][k] == '.') vec.push_back( ope(i, k, 0) );\n\t\t\t\tif(J != k && F[i][k] == 'o') vec.push_back( ope(i, k, 1) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tcout << vec.size() << endl;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tcout << vec[i].i+1 << \" \" << vec[i].j+1 << \" \";\n\t\tif(vec[i].type) cout << \"erase\" << endl;\n\t\telse cout << \"write\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);++(i))\n\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing i64 = long long;\n\nstruct Graph {\n  struct edge {\n    int to;\n    i64 cap;\n    i64 cost;\n    int rev;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\nstruct Primal_Dual {\n  Graph g;\n  const int n;\n  Primal_Dual(int n_) : g(n_), n(n_) {}\n\n  void add_edge(int from,int to , i64 cost,i64 cap,i64 revcap){\n    g[from].push_back({to, cap, cost , (int)g[to].size()});\n    g[to].push_back({from, revcap, -cost, (int)g[from].size() - 1});\n  }\n\n  i64 minimumCostFlow(int s, int t, i64 f) {\n    using Pi = pair<i64, i64>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    vector<int> prevv(n, -1);\n    vector<int> preve(n, -1);\n    vector<i64> potential(n, 0);\n    i64 res = 0;\n    while (f > 0) {\n      vector<i64> dist(n, 1e9);\n      que.push({0, s});\n      dist[s] = 0;\n      while (!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if (dist[p.second] < p.first)\n          continue;\n        for (int i = 0; i < (int)g[p.second].size(); i++) {\n          auto &e = g[p.second][i];\n          i64 next =\n              dist[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if (e.cap > 0 && dist[e.to] > next) {\n            dist[e.to] = next;\n            prevv[e.to] = p.second;\n            preve[e.to] = i;\n            que.push({dist[e.to], e.to});\n          }\n        }\n      }\n      if (dist[t] == 1e9)\n        return -1;\n      for (int v = 0; v < n; v++) {\n        potential[v] += dist[v];\n      }\n      i64 d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = min(d, g[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * potential[t];\n\n      for (int v = t; v != s; v = prevv[v]) {\n        auto &e = g[prevv[v]][preve[v]];\n        e.cap -= d;\n        g[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nint n;\nint w[101][101];\nint e[101][101];\n\nint fie[101][101];\n\nint main(){\n    cin >> n;\n    rep(i,1,n)rep(j,1,n){\n        cin >> w[i][j];\n    }\n    rep(i,1,n)rep(j,1,n){\n        cin >> e[i][j];\n    }\n    Primal_Dual pd(n * n + 10);\n    int sum = 0;\n    int s = 0;\n    int t = n * n + 9;\n\n    rep(i,1,n){\n      pd.add_edge(s,i,0,1,0);\n      pd.add_edge(i + n,t,0,1,0);\n    }\n    rep(i,1,n){\n        string s;\n        cin >> s;\n        rep(j,1,n){\n            if(s[j - 1] == '.'){\n                pd.add_edge(i,j + n,w[i][j],1,0);\n                fie[i][j] = 0;\n            }\n            else{\n                pd.add_edge(i,j + n,-e[i][j],1,0);\n                fie[i][j] = 1;\n                sum += e[i][j];\n            }\n        }\n    }\n\n    cout << sum + pd.minimumCostFlow(s,t,n) << endl;\n\n    vector<P> write_a ,erase_a;\n    rep(i,1,n){\n      for(auto & e : pd.g[i]){\n        if(e.cap == 0){\n          if(fie[i][e.to - n] == 0){\n            write_a.push_back({i,e.to - n});\n          }\n          else{\n            fie[i][e.to - n] = 0;\n          }\n        }\n      }\n    }\n\n    rep(i,1,n)rep(j,1,n){\n      if(fie[i][j] == 1){\n        erase_a.push_back({i,j});\n      }\n    }\n\n    cout << write_a.size() + erase_a.size() << endl;\n    for(auto & e : write_a){\n      cout << e.first << \" \" << e.second << \" write\" << endl;\n    }\n    for(auto & e : erase_a){\n      cout << e.first << \" \" << e.second << \" erase\" << endl;\n    }\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define inf (int)(1e9)\ntemplate <class T>\nstruct Primal_Dual {\n  using P = pair<T, int>;\n  struct edge {\n    int to;\n    T cap, cost;\n    int rev;\n  };\n  int v;\n  vector<vector<edge>> edges;\n  vector<T> h;\n  vector<T> d;\n  vector<int> prevv, preve;\n  Primal_Dual(int _n = 1) {\n    v = _n;\n    edges.clear();\n    edges.resize(v);\n    h.resize(v);\n    d.resize(v);\n    prevv.resize(v);\n    preve.resize(v);\n  }\n  bool add(int from, int to, T cap, T cost) {\n    edges[from].push_back(\n        (edge){to, cap, cost, (int)edges[to].size()});\n    edges[to].push_back((edge){\n        from, 0, -cost, (int)edges[from].size() - 1});\n    return 1;\n  }\n  T solve(int s, int t, T f) {\n    T res = 0;\n    h.assign(v, 0);\n    while(f > 0) {\n      priority_queue<P, vector<P>, greater<P>> qu;\n      d.assign(v, inf);\n      d[s] = 0;\n      qu.push({0, s});\n      while(!qu.empty()) {\n        P now = qu.top();\n        qu.pop();\n        int nowv = now.second;\n        if(d[nowv] < now.first) continue;\n        for(int i = 0; i < (int)edges[nowv].size(); ++i) {\n          edge &e = edges[nowv][i];\n          if(e.cap > 0 && d[e.to] > d[nowv] + e.cost +\n                                        h[nowv] - h[e.to]) {\n            d[e.to] = d[nowv] + e.cost + h[nowv] - h[e.to];\n            prevv[e.to] = nowv;\n            preve[e.to] = i;\n            qu.push({d[e.to], e.to});\n          }\n        }\n      }\n      if(d[t] == inf) return -1;\n      for(int i = 0; i < v; ++i) h[i] += d[i];\n      T d = f;\n      for(int i = t; i != s; i = prevv[i])\n        d = min(d, edges[prevv[i]][preve[i]].cap);\n      f -= d;\n      res += d * h[t];\n      for(int i = t; i != s; i = prevv[i]) {\n        edge &e = edges[prevv[i]][preve[i]];\n        e.cap -= d;\n        edges[i][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nstruct data {\n  int x, y;\n  bool iswrite;\n};\n\nint n;\nvector<vector<int>> w, e;\nvector<string> f;\nPrimal_Dual<long long> pd;\nvector<data> v;\n\nint main() {\n  cin >> n;\n  w.resize(n, vector<int>(n));\n  e.resize(n, vector<int>(n));\n  f.resize(n);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j) cin >> w[i][j];\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j) cin >> e[i][j];\n  for(int i = 0; i < n; ++i) cin >> f[i];\n  pd = Primal_Dual<long long>(2 * n + 2);\n  for(int i = 0; i < n; ++i) pd.add(2 * n, i, 1, 0);\n  for(int i = 0; i < n; ++i) pd.add(i + n, 2 * n + 1, 1, 0);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < n; ++j) {\n      long long cos = 0;\n      for(int k = 0; k < n; ++k) {\n        if(k != j && f[i][k] != '.') cos += e[i][k];\n        if(k != i && f[k][j] != '.') cos += e[k][j];\n      }\n      if(f[i][j] == '.') cos += 2 * w[i][j];\n      pd.add(i, j + n, 1, cos);\n    }\n  cout << pd.solve(2 * n, 2 * n + 1, n) / 2 << endl;\n  for(int i = 0; i < n; ++i)\n    for(auto e : pd.edges[i])\n      if(e.to >= n && e.to < 2 * n) {\n        if(e.cap == 0 && f[i][e.to - n] == '.')\n          v.push_back({i, e.to - n, 1});\n        if(e.cap == 1 && f[i][e.to - n] != '.')\n          v.push_back({i, e.to - n, 0});\n      }\n  cout << v.size() << endl;\n  for(auto d : v)\n    cout << d.x + 1 << \" \" << d.y + 1 << \" \"\n         << (d.iswrite ? \"write\" : \"erase\") << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 222; // TODO:initialize\nconst int INF = 12345678; // TODO:initialize\nvector<edge> G[MAX_V];\nint h[MAX_V]; // ??????????????£???\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nint min_cost_flow(int s, int t, int f, bool neg = false){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        if(neg)\n        {\n            // bellman-ford??§h?????´??°\n            neg = false;\n            bool update;\n            do{\n                update = false;\n                rep(v,V){\n                    if(dist[v] == INF) continue;\n                    rep(i,G[v].size()){\n                        edge &e = G[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }while(update);\n        }\n        else\n        {\n            // dijkstra??§h?????´??°\n            pq.push(pi(0,s));\n            while(!pq.empty()){\n                pi p = pq.top();\n                pq.pop();\n                int v = p.se;\n                if(p.fi>dist[v]) continue;\n                rep(i,G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        pq.push(pi(dist[e.to],e.to));\n                    }\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n;\n    cin >>n;\n    vector<vector<int>> W(n,vector<int>(n)),E(n,vector<int>(n));\n    vector<string> F(n);\n\n    rep(i,n)rep(j,n) cin >>W[i][j];\n    rep(i,n)rep(j,n) cin >>E[i][j];\n    rep(i,n) cin >>F[i];\n\n    V = 2*n+2;\n    int S = 2*n, T = S+1;\n    rep(i,n)\n    {\n        add_edge(S,i,1,0);\n        add_edge(n+i,T,1,0);\n    }\n\n    rep(i,n)rep(j,n)\n    {\n        int cost = 0;\n        rep(k,n)\n        {\n            if(k==j)\n            {\n                if(F[i][k]!='o') cost += W[i][k];\n            }\n            else\n            {\n                if(F[i][k]!='.') cost += E[i][k];\n            }\n        }\n        add_edge(i,n+j,1,cost);\n    }\n\n    cout << min_cost_flow(S,T,n) << endl;\n\n    vector<int> r,c;\n    vector<string> op;\n    rep(i,n)\n    {\n        int id = 0;\n        for(const auto &e:G[n+i])\n        {\n            if(e.cap>0) id = e.to;\n        }\n        rep(j,n)\n        {\n            if(j==i)\n            {\n                if(F[id][j]!='o')\n                {\n                    r.pb(id+1);\n                    c.pb(j+1);\n                    op.pb(\"write\");\n                }\n            }\n            else\n            {\n                if(F[id][j]!='.')\n                {\n                    r.pb(id+1);\n                    c.pb(j+1);\n                    op.pb(\"erase\");\n                }\n            }\n        }\n    }\n\n    cout << r.size() << endl;\n    rep(i,r.size()) cout << r[i] << \" \" << c[i] << \" \" << op[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<sstream>\n#include<string>\nusing namespace std;\nconst int INF = 1 << 30;\n#define MAX_V 202\ntypedef pair < int , int > Pi;\nint n;\nclass Primal_Dual{\nprivate:\n  struct edge{\n    int to, cap, cost, rev;\n  };\n  int V;\n  vector< edge > info[MAX_V];\n  int h[MAX_V], dist[MAX_V], prevv[MAX_V], preve[MAX_V];\npublic:\n  void add_edge(int from,int to,int cap,int cost){ //from,to,容量,コスト\n    info[from].push_back((edge){to,cap,cost,info[to].size()});\n    info[to].push_back((edge){from,0,-cost,info[from].size()-1});\n  }\n  Primal_Dual(){};\n  Primal_Dual(int size):V(size){};\n  int min_cost_flow(int s,int t,int f){ //sからtへの最小費用流\n    int ret = 0;\n    fill_n( h, V, 0);\n    while(f > 0){\n      priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n      fill_n( dist, V, INF);\n      que.push(Pi(0,s));\n      dist[s] = 0;\n      while(!que.empty()){\n        Pi p = que.top(); que.pop();\n        if(dist[p.second] < p.first) continue;\n        for(int i = 0; i < info[p.second].size(); i++){\n          edge& e = info[p.second][i];\n          if(e.cap > 0 && dist[e.to] > dist[p.second] + e.cost + h[p.second] - h[e.to]){\n            dist[e.to] = dist[p.second] + e.cost + h[p.second] - h[e.to];\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t] == INF) return -1;\n      for(int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for(int v = t; v != s; v = prevv[v]){\n        d = min( d, info[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      ret += d * h[t];\n      for(int v = t; v != s; v = prevv[v]){\n        edge& e = info[prevv[v]][preve[v]];\n        e.cap -= d;\n        info[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n  void dump(char F[][100]){\n    vector< string > ret;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < info[i].size(); j++){\n        if(info[i][j].cap == 0){\n          const int pos = info[i][j].to - n;\n          if(F[i][pos] == '.'){\n            stringstream ss;\n            ss << i + 1 << \" \" <<  pos + 1 << \" write\";\n              ret.push_back(ss.str());\n          }\n          for(int k = 0; k < n; k++){\n            if(k == pos) continue;\n            if(F[i][k] == 'o'){\n              stringstream ss;\n              ss << i + 1 << \" \" << k + 1 << \" erase\";\n              ret.push_back(ss.str());\n            }\n          }\n          break;\n        }\n      }\n    }\n    cout << ret.size() << endl;\n    for(int i = 0 ; i < ret.size(); i++){\n      cout << ret[i] << endl;\n    }\n  }\n};\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  int W[100][100], E[100][100];\n  char F[100][100];\n\n  cin >> n;\n  const int from = n * 2, to = n * 2 + 1;\n  rep(i,n) rep(j,n) cin >> W[i][j];\n  rep(i,n) rep(j,n) cin >> E[i][j];\n  rep(i,n) rep(j,n) cin >> F[i][j];\n\n  Primal_Dual Graph(n * 2 + 2);\n  rep(i,n) {\n    Graph.add_edge( from, i, 1, 0); //各行へ\n    Graph.add_edge( n + i, to, 1, 0); // 吸収\n  }\n\n  rep(i,n) {\n    rep(j,n) {\n      int cost = 0;\n      if(F[i][j] == '.') cost += W[i][j]; //そこに○かくと\n      rep(k,n) {\n        if(j == k) continue;\n        if(F[i][k] == 'o') cost += E[i][k]; //ここの○は消さねば\n      }\n      Graph.add_edge( i, n + j, 1, cost);\n    }\n  }\n  cout << Graph.min_cost_flow(from, to, n) << endl;\n  Graph.dump(F);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> wcost(n+1,vector<int>(n + 1));\n\tvector<vector<int>> ecost(n + 1, vector<int>(n + 1));\n\tvector<vector<bool>> ifwritten(n + 1, vector<bool>(n + 1));\n\tvector<vector<bool>> change(n + 1, vector<bool>(n + 1));\n\tvector<vector<int>> nowcost(n + 1, vector<int>(n + 1));\n\tint cost=0;\n\tint changenum = 0;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcin >> wcost[i][j];\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcin >> ecost[i][j];\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j, n) {\n\t\t\tif (s[j] == 'o') {\n\t\t\t\tifwritten[i][j] = true;\n\t\t\t\tchange[i][j] = true;\n\t\t\t\tnowcost[i][j] = -ecost[i][j];\n\t\t\t\tcost += ecost[i][j];\n\t\t\t\tchangenum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tifwritten[i][j] = false;\n\t\t\t\tchange[i][j] = false;\n\t\t\t\tnowcost[i][j] = wcost[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvector<int> retu(n + 1);\n\tREP(i, n) {\n\t\tretu[i] = i;\n\t\tcost += nowcost[i][i];\n\t\t\tnowcost[i][i] *= -1;\n\t\tif (change[i][i]) {\n\t\t\tchange[i][i] = false;\n\t\t\tchangenum--;\n\t\t}\n\t\telse {\n\t\t\tchange[i][i] = true;\n\t\t\tchangenum++;\n\t\t}\n\t}\n\tFOR(i, 0, n) {\n\t\tFOR(j, i+1, n) {\n\t\t\tif (nowcost[i][retu[i]] + nowcost[j][retu[j]] + nowcost[i][retu[j]] + nowcost[j][retu[i]] < 0) {\n\t\t\t\tcost += nowcost[i][retu[i]] + nowcost[j][retu[j]] + nowcost[i][retu[j]] + nowcost[j][retu[i]];\n\n\t\t\t\tnowcost[i][retu[i]] *= -1;\n\t\t\t\tif (change[i][retu[i]]) {\n\t\t\t\t\tchange[i][retu[i]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[i][retu[i]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tnowcost[i][retu[j]] *= -1;\n\t\t\t\tif (change[i][retu[j]]) {\n\t\t\t\t\tchange[i][retu[j]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[i][retu[j]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\n\t\t\t\tnowcost[j][retu[i]] *= -1;\n\t\t\t\tif (change[j][retu[i]]) {\n\t\t\t\t\tchange[j][retu[i]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[j][retu[i]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tnowcost[j][retu[j]] *= -1;\n\t\t\t\tif (change[j][retu[j]]) {\n\t\t\t\t\tchange[j][retu[j]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[j][retu[j]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tint a = retu[i];\n\t\t\t\tretu[i] = retu[j];\n\t\t\t\tretu[j] = a;\n\t\t\t}\n\t\t}\n\t}\n\tcout << cost << endl;\n\tcout << changenum << endl;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif (change[i][j]) {\n\t\t\t\tif (ifwritten[i][j]) {\n\t\t\t\t\tcout << i +1<< \" \" << j + 1 << \" \" << \"erase\" << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tcout << i + 1 << \" \" << j + 1 << \" \" << \"write\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n   \nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst int INF=1e9+7;\n \nstruct edge{\n    int to, cap, cost, rev;\n};\n\nint n;\nint V;\nvector<edge> g[202];\nint h[202];\nint dist[202];\nint prevv[202], preve[202];\nbool op[100][100];\n \nvoid add_edge(int from, int to, int cap, int cost){\n    edge e;\n    e.to=to, e.cap=cap, e.cost=cost, e.rev=g[to].size();\n    g[from].push_back(e);\n    e.to=from, e.cap=0, e.cost=-cost, e.rev=g[from].size()-1;\n    g[to].push_back(e);\n}\n \nint min_cost_flow(int s, int t, int f){\n    int res=0;\n    fill(h, h+V, 0);\n    while(f>0){\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist+V, INF);\n        dist[s]=0;\n        que.push(P(0, s));\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n            int v=p.second;\n            if(dist[v]<p.first) continue;\n            for(int i=0; i<g[v].size(); i++){\n                edge &e=g[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        for(int v=0; v<V; v++) h[v]+=dist[v];\n        if(dist[t]==INF) return -1;\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]){\n\t\t\tif(prevv[v]<n){\n\t\t\t\tif(g[prevv[v]][preve[v]].cost>0){\n\t\t\t\t\top[prevv[v]][v-n]=1;\n\t\t\t\t}else{\n\t\t\t\t\top[prevv[v]][v-n]=0;\n\t\t\t\t}\n\t\t\t}\n            d=min(d, g[prevv[v]][preve[v]].cap);\n        }\n\t\tf-=d;\n        res+=d*h[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n\tcin>>n;\n\tint w[100][100], e[100][100];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcin>>w[i][j];\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcin>>e[i][j];\n\t\t}\n\t}\n\tstring f[100];\n\tfor(int i=0; i<n; i++) cin>>f[i];\n\tV=2*n+2;\n\tint ans=0;\n\tfor(int i=0; i<n; i++) add_edge(V-2, i, 1, 0);\n\tfor(int j=0; j<n; j++) add_edge(j+n, V-1, 1, 0);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(f[i][j]=='.'){\n\t\t\t\tadd_edge(i, j+n, 1, w[i][j]);\n\t\t\t}else{\n\t\t\t\tadd_edge(i, j+n, 1, -e[i][j]);\n\t\t\t\top[i][j]=1;\n\t\t\t\tans+=e[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans+=min_cost_flow(V-2, V-1, n);\n\tcout<<ans<<endl;\n\tvector<int> r, c, op1;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(op[i][j]){\n\t\t\t\tr.push_back(i+1);\n\t\t\t\tc.push_back(j+1);\n\t\t\t\tif(f[i][j]=='.') op1.push_back(1);\n\t\t\t\telse op1.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<r.size()<<endl;\n\tfor(int i=0; i<r.size(); i++){\n\t\tif(op1[i]) cout<<r[i]<<\" \"<<c[i]<<\" write\"<<endl;\n\t\telse cout<<r[i]<<\" \"<<c[i]<<\" erase\"<<endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (ll (i) = 0 ; (i) < (ll)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n//#define INF (1e10)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\ntemplate<class T> void print(const T& x) { cout << setprecision(16) << x << endl; }\ntemplate<class T, class... A> void print(const T& first, const A& ... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain { PreMain() { cin.tie(0); ios::sync_with_stdio(false); } } premain;\n\n\n#define N_MAX\t(100)\n\n\ntypedef int FLOW;                // フローを表す型、今回は int 型\ntypedef int COST;                // コストを表す型、今回は int 型\nconst int MAX_V = N_MAX*2 + 2;           // グラフの最大ノード数\nconst COST INF = 100000000;      // 十分大きい値\n\n// グラフの辺の構造体\nstruct Edge {\n\tint rev, from, to;\n\tFLOW cap, icap;\n\tCOST cost;\n\tEdge(int r, int f, int t, FLOW ca, COST co) : rev(r), from(f), to(t), cap(ca), icap(ca), cost(co) {}\n};\n\n// グラフ構造体\nstruct Graph {\n\tint V;\n\tvector<Edge> list[MAX_V];\n\n\tGraph(int n = 0) : V(n) { for (int i = 0; i < MAX_V; ++i) list[i].clear(); }\n\tvoid init(int n = 0) { V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear(); }\n\tvoid resize(int n = 0) { V = n; }\n\tvoid reset() { for (int i = 0; i < V; ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n\tinline vector<Edge>& operator [] (int i) { return list[i]; }\n\n\tEdge& redge(Edge& e) {\n\t\tif (e.from != e.to) return list[e.to][e.rev];\n\t\telse return list[e.to][e.rev + 1];\n\t}\n\n\tvoid addedge(int from, int to, FLOW cap, COST cost) {\n\t\tlist[from].push_back(Edge((int)list[to].size(), from, to, cap, cost));\n\t\tlist[to].push_back(Edge((int)list[from].size() - 1, to, from, 0, -cost));\n\t}\n};\n\n// 最小費用流を求める関数\nCOST MinCostFlow(Graph& G, int s, int t, FLOW inif) {\n\tCOST dist[MAX_V];\n\tint prevv[MAX_V] = { 0 };\n\tint preve[MAX_V] = { 0 };\n\n\tCOST res = 0;\n\tFLOW f = inif;\n\twhile (f > 0) {\n\t\tfill(dist, dist + G.V, INF);\n\t\tdist[s] = 0;\n\t\twhile (true) {\n\t\t\tbool update = false;\n\t\t\tfor (int v = 0; v < G.V; ++v) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\t\tEdge& e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!update) break;\n\t\t}\n\n\t\tif (dist[t] == INF) return 0;\n\n\t\tFLOW d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += dist[t] * d;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge& e = G[prevv[v]][preve[v]];\n\t\t\tEdge& re = G.redge(e);\n\t\t\te.cap -= d;\n\t\t\tre.cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tint W[N_MAX][N_MAX];\n\tint E[N_MAX][N_MAX];\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tcin >> W[i][j];\n\t\t}\n\t}\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\n\tstring F[N_MAX];\n\tREP(i, N) {\n\t\tcin >> F[i];\n\t}\n\n\tint base = 0;\n\tGraph G(2 * N + 2);\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tif (F[i][j] == 'o') {\n\t\t\t\tG.addedge(i, j+N, 1, -E[i][j]);\n\t\t\t\tbase += E[i][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG.addedge(i, j+N, 1, W[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint node_start = (2 * N), node_end = (2 * N + 1);\n\tREP(i, N) {\n\t\tG.addedge(node_start, i, 1, 0);\n\t}\n\tREP(j, N) {\n\t\tG.addedge(j+N, node_end, 1, 0);\n\t}\n\n\tauto minCost = MinCostFlow(G, node_start, node_end, N);\n\tprint(base + minCost); \n\n\t//capが0になったedgeかどうか\n\tvector<string> ans;\n\tbool is_zero[N_MAX][N_MAX];\n\tfor (auto &edges : G.list) {\n\t\tfor (auto& edge : edges) {\n\t\t\tif (((2 * N) <= edge.from) || ((2 * N) <= edge.to)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint i = edge.from;\n\t\t\tif (N <= i) {\n\t\t\t\t//i -= N;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = edge.to;\n\t\t\tif (N <= j) {\n\t\t\t\tj -= N;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (edge.cap != edge.icap) {\n\t\t\t\tif (F[i][j] == '.') {\n\t\t\t\t\tans.push_back(string(to_string(i + 1) + \" \" + to_string(j + 1) + \" \" + \"write\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (F[i][j] == 'o') {\n\t\t\t\t\tans.push_back(string(to_string(i + 1) + \" \" + to_string(j + 1) + \" \" + \"erase\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprint(ans.size());\n\tfor (auto& s : ans) {\n\t\tprint(s);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\n#define V 300\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,cost,rev;\n};\n\nvector<edge> e[V];\nint h[V];\nint d[V];\nint prv[V];\nint pre[V];\n\nint min(int a,int b){return a<b?a:b;}\n\nvoid add_edge(int from,int to,int cap,int cost){\n\te[from].push_back((edge){to,cap,cost,e[to].size()});\n\te[to].push_back((edge){from,0,-cost,e[from].size()-1});\n}\n\nint mincost(int n,int s,int t,int f){\n\tint i;\n\tint res=0;\n\tfor(i=0;i<n;i++)h[i]=0;\n\twhile(f>0){\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfor(i=0;i<n;i++)d[i]=INF;\n\t\td[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tint v=p.second;\n\t\t\tif(d[v]<p.first)continue;\n\t\t\tfor(i=0;i<e[v].size();i++){\n\t\t\t\tedge &g=e[v][i];\n\t\t\t\tint u=g.to;\n\t\t\t\tif(g.cap>0&&d[u]>d[v]+g.cost+h[v]-h[u]){\n\t\t\t\t\td[u]=d[v]+g.cost+h[v]-h[u];\n\t\t\t\t\tprv[u]=v;\n\t\t\t\t\tpre[u]=i;\n\t\t\t\t\tque.push(P(d[u],u));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(d[t]==INF)return -1;\n\t\tfor(i=0;i<n;i++)h[i]+=d[i];\n\t\tint q=f;\n\t\tfor(i=t;i!=s;i=prv[i])q=min(q,e[prv[i]][pre[i]].cap);\n\t\tf-=q;\n\t\tres+=q*h[t];\n\t\tfor(i=t;i!=s;i=prv[i]){\n\t\t\tedge &g=e[prv[i]][pre[i]];\n\t\t\tg.cap-=q;\n\t\t\te[i][g.rev].cap+=q;\n\t\t}\n\t}\n\treturn res;\n}\n\nint a[100][100];\nint b[100][100];\nchar f[100][100];\nvector<P> ans;\n\nint main(){\n\tint n,i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++)scanf(\"%d\",&a[i][j]);\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++)scanf(\"%d\",&b[i][j]);\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++)scanf(\" %c\",&f[i][j]);\n\t//0\n\t//1...n\n\t//n+1...n*2\n\t//n*2+1\n\tfor(i=0;i<n;i++){\n\t\tint s=0;\n\t\tfor(j=0;j<n;j++)if(f[i][j]=='o')s+=b[i][j];\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(f[i][j]=='o')add_edge(i+1,n+j+1,1,s-b[i][j]);\n\t\t\telse add_edge(i+1,n+j+1,1,s+a[i][j]);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tadd_edge(0,i+1,1,0);\n\t\tadd_edge(n+i+1,n*2+1,1,0);\n\t}\n\tprintf(\"%d\\n\",mincost(n*2+2,0,n*2+1,n));\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++)if(e[i+1][j].cap==0){\n\t\t\tif(f[i][j]=='o')f[i][j]='+';\n\t\t\telse ans.push_back(P(i,j));\n\t\t}\n\t}\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++)if(f[i][j]=='o')ans.push_back(P(i,j));\n\tprintf(\"%d\\n\",ans.size());\n\tfor(i=0;i<ans.size();i++){\n\t\tint x=ans[i].first;\n\t\tint y=ans[i].second;\n\t\tif(f[x][y]=='o')printf(\"%d %d erase\\n\",x+1,y+1);\n\t\tif(f[x][y]=='.')printf(\"%d %d write\\n\",x+1,y+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1000000007;\n\ntypedef pair<int, int> P;\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[210];\nint h[210];\nint dist[210];\nint prevv[210], preve[210];\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){ to, cap, cost, (int)G[to].size() });\n    G[to].push_back((edge){ from, 0, -cost, (int)G[from].size() - 1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        priority_queue<P, vector<P>, greater<P> > q;\n        fill(dist, dist + V, M);\n        dist[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty()) {\n            P p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < (int)G[v].size(); ++i) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    q.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == M) return -1;\n        for (int v = 0; v < V; ++v)\n            h[v] += dist[v];\n\n        int d = f;\n        for (int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> wc(n, vector<int>(n));\n    vector<vector<int>> ec(n, vector<int>(n));\n    vector<vector<int>> cost(n, vector<int>(n));\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cin >> wc[i][j];\n\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cin >> ec[i][j];\n\n    for (int i = 0; i < n; ++i)\n        cin >> s[i];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int c = (s[i][j] == 'o' ? 0 : wc[i][j]);\n            for (int k = 0; k < n; ++k)\n                if (k != j && s[i][k] == 'o')\n                    c += ec[i][k];\n\n            cost[i][j] = c;\n        }\n    }\n    V = n * 2 + 2;\n    for (int i = 0; i < n; ++i) {\n        add_edge(n * 2, i, 1, 0);\n        add_edge(n + i, n * 2 + 1, 1, 0);\n    }\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            add_edge(i, n + j, 1, cost[i][j]);\n\n    int mc = min_cost_flow(n * 2, n * 2 + 1, n);\n    vector<vector<int>> cir(n, vector<int>(n, 0));\n    for (int i = 0; i < n; ++i)\n        for (edge& e : G[i])\n            if (e.to >= n && e.to < n * 2 && e.cap == 0)\n                cir[i][e.to - n] = 1;\n\n    vector<string> ans;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (s[i][j] == '.' && cir[i][j])\n                ans.push_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" write\\n\");\n            if (s[i][j] == 'o' && !cir[i][j])\n                ans.push_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" erase\\n\");\n        }\n    }\n    cout << mc << \"\\n\" << ans.size() << \"\\n\";\n    for (string i : ans)\n        cout << i;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef int Capacity;\ntypedef int Cost;\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge; bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n    enum : int { MAX_V = 1000000 };\n\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n    }\n\n    int mcf(int s, int t, int f) {\n        int res = 0;\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n        static Cost h[MAX_V], dist[MAX_V];\n        static int prevv[MAX_V], preve[MAX_V];\n        rep(i,n)h[i] = 0;\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            rep(i,n) dist[i] = inf;\n            dist[s] = 0;\n            q.emplace(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.mcf(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\n int main(){\n     cin >> n;\n     N=n*2+2;\n     rep(i,n)rep(j,n)scanf(\"%d\",&W[i][j]);\n     rep(i,n)rep(j,n)scanf(\"%d\",&E[i][j]);\n     rep(i,n)scanf(\"%s\",f[i]);\n     solve();\n }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nint max_n;\nconst int mn = 100000;\nstruct edge {\n\tint to, cap, cost, rev;\n};\nvector<edge> G[mn];\nint par[mn];\nint dist[mn];\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back({ to,cap,cost,(int)G[to].size() });\n\tG[to].push_back({ from,0,-cost,(int)G[from].size() - 1 });\n\tmax_n = max({ max_n, from + 1, to + 1 });\n}\nint minimum_road(int s,int t) {\n\tfill(par, par + max_n, -1);\n\tfill(dist, dist + max_n, mod);\n\tdist[s] = 0;\n\tpriority_queue<P,vector<P>,greater<P>> q; q.push({ 0,s });\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\tif (id == t)continue;\n\t\trep(j, G[id].size()) {\n\t\t\tif (G[id][j].cap > 0) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tint nd = p.first + G[id][j].cost;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tpar[to] = id;\n\t\t\t\t\tq.push({ dist[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cur = t;\n\twhile (cur != s) {\n\t\tint p = par[cur];\n\t\tif (p < 0)return -1;\n\t\trep(j, G[p].size()) {\n\t\t\tif (G[p][j].cap > 0&&G[p][j].to==cur&&dist[p]+G[p][j].cost==dist[cur]) {\n\t\t\t\tG[p][j].cap--;\n\t\t\t\tG[cur][G[p][j].rev].cap++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcur = p;\n\t}\n\treturn dist[t];\n}\nint minimum_cost_flow(int s, int t,int k) {\n\tint ret = 0;\n\trep(i, k) {\n\t\tint z = minimum_road(s,t);\n\t\tif (z < 0)return -1;\n\t\tret += z;\n\t}\n\treturn ret;\n}\nint x[100][100];\nint y[100][100];\nchar mp[100][100];\nbool used[100][100];\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcin >> y[i][j];\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tint sum = 0;\n\t\t\trep(k, n) {\n\t\t\t\tif (j != k)if (mp[i][k] == 'o')sum += y[i][k];\n\t\t\t\tif (i != k)if (mp[k][j] == 'o')sum += y[k][j];\n\t\t\t}\n\t\t\tif (mp[i][j] == '.')sum += 2 * x[i][j];\n\t\t\t//cout << i << \" \" << j << sum << endl;\n\t\t\tadd_edge(i, n + j,1, sum);\n\t\t}\n\t}\n\tint s = 2 * n, t = 2 * n + 1;\n\trep(i, n) {\n\t\tadd_edge(s, i, 1, 0);\n\t\tadd_edge(n + i, t, 1, 0);\n\t}\n\tint ans = minimum_cost_flow(s, t,n);\n\tcout << ans / 2 << endl;\n\trep(i, n) {\n\t\trep(j, G[i].size()) {\n\t\t\tedge &e = G[i][j];\n\t\t\tif (e.to < s) {\n\t\t\t\tif (e.cap == 0) {\n\t\t\t\t\tused[i][e.to - n] = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> era, wri;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (used[i][j] && mp[i][j] == '.') {\n\t\t\t\twri.push_back({ i + 1,j + 1 });\n\t\t\t}\n\t\t\tif (!used[i][j] && mp[i][j] == 'o') {\n\t\t\t\tera.push_back({ i + 1,j + 1 });\n\t\t\t}\n\t\t}\n\t}\n\tcout << wri.size() + era.size() << endl;\n\trep(i, era.size()) {\n\t\tcout << era[i].first << \" \" << era[i].second << \" \" << \"erase\" << endl;\n\t}\n\trep(i, wri.size()) {\n\t\tcout << wri[i].first << \" \" << wri[i].second << \" write\" << endl;\n\t}\n}\nint main() {\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nusing Weight = int;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\nconstexpr int INF = 1000000000;\n\npair<Weight, Array> hungarian(const Matrix &m) {\n  int n = m.size();\n  int p, q;\n  Array fx(n, INF), fy(n, 0);\n  vector<int> x(n, -1), y(n, -1);\n  REP(i,n)REP(j,n) fx[i] = min(fx[i], m[i][j]);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == m[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      Weight d = INF;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - m[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  Weight ret = 0;\n  Array match;\n  for (int i = 0; i < n; ++i) {\n    ret += m[i][x[i]];\n    match.push_back(x[i]);\n  }\n  return make_pair(ret, match);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  Matrix mat(n, Array(n));\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        mat[i][j] = 1000 - e[i][j];\n        cost += e[i][j];\n      } else {\n        mat[i][j] = 1000 + w[i][j];\n      }\n    }\n  }\n  auto res = hungarian(mat);\n  cout << (res.first - n*1000 + cost) << endl;\n  stringstream ss;\n  int count = 0;\n  REP(i,n)REP(j,n) {\n    if (res.second[i] == j) {\n      if (m[i][j] == '.') {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++count;\n      }\n    } else {\n      if (m[i][j] == 'o') {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++count;\n      }\n    }\n  }\n  cout << count << endl;\n  cout << ss.str();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\nstruct edge\n{\n  int to, cap, cost, rev;\n  edge(){}\n  edge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n};\n\n\nstruct PrimalDual\n{\n  vector< vector<edge> > graph;\n  vector<int> mincost;\n\n  PrimalDual(int n):graph(n), mincost(n){}\n  void add_edge(int f, int t, int cap, int cost)\n  {\n    graph[f].push_back(edge(t, cap, cost, graph[t].size()));\n    graph[t].push_back(edge(f, 0, -cost, graph[f].size()-1));\n  }\n  int min_cost_flow(int s, int t, int f)\n  {\n    int ret = 0;\n\n    vector<int> h(graph.size(), 0);\n    vector<int> pv(graph.size(), -1);\n    vector<int> pe(graph.size(), -1);\n\n    while(f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(all(mincost), inf);\n      mincost[s] = 0;\n      que.push(P(0, s));\n      while(!que.empty()) {\n\tP p = que.top(); que.pop();\n\tint v = p.second;\n\tif(mincost[v] < p.first) continue;\n\trep(i, graph[v].size()) {\n\t  edge& e = graph[v][i];\n\t  int cost = mincost[v] + e.cost + h[v] - h[e.to];\n\t  if(e.cap > 0 && cost < mincost[e.to]) {\n\t    mincost[e.to] = cost;\n\t    pv[e.to] = v, pe[e.to] = i;\n\t    que.push(P(mincost[e.to], e.to));\n\t  }\n\t}\n      }\n\n      if(mincost[t] == inf) return -1;\n\t\t\t      \n      rep(i, graph.size()) h[i] += mincost[i];\n      int d = f;\n      for(int v = t; v != s; v = pv[v]) d = min(d, graph[pv[v]][pe[v]].cap);\n      f -= d;\n      ret += h[t] * d;\n      for(int v = t; v != s; v = pv[v]) {\n\tedge& e = graph[pv[v]][pe[v]];\n\te.cap -= d;\n\tgraph[v][e.rev].cap += d;\n      }\n    }\n    \n    return ret;\n  }\n};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n; cin >> n;\n  int W[101][101], E[101][101];\n  char F[101][101];\n  rep(i, n) rep(j, n) cin >> W[i][j];\n  rep(i, n) rep(j, n) cin >> E[i][j];\n  rep(i, n) rep(j, n) cin >> F[i][j];\n\n  int s = 2*n, t = s + 1, v = t + 1;\n  \n  PrimalDual graph(v);\n\n  rep(i, n) {\n    graph.add_edge(s, i, 1, 0);\n    graph.add_edge(n+i, t, 1, 0);\n  }\n\n  rep(i, n) rep(j, n) {\n    int cost = 0;\n    rep(k, n) {\n      if(k == j && F[i][k] == '.') cost += W[i][k];\n      if(k != j && F[i][k] == 'o') cost += E[i][k];\n    }\n    graph.add_edge(i, n + j, 1, cost);\n  }\n\n  int mcf = graph.min_cost_flow(s, t, n);\n  cout << mcf << endl;\n\n  vector< tuple<int, int, string> > ops;\n\n  rep(i, n) {\n    for(edge e : graph.graph[i]) {\n      if(e.cap == 0 && F[i][e.to-n] == '.') ops.emplace_back(i+1, e.to-n+1, \"write\");\n      if(e.cap != 0 && F[i][e.to-n] == 'o') ops.emplace_back(i+1, e.to-n+1, \"erase\");\n    }\n  }\n\n  cout << ops.size() << endl;\n  for(auto o : ops) {\n    int r, c; string op;\n    tie(r, c, op) = o;\n    cout << r << \" \" << c << \" \" << op << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最小費用流\nclass PrimalDual {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    const unsigned long V;       // 頂点数\n    vector<vector<Edge>> graph;  // グラフの隣接リスト表現\n    vector<int> h;               // ポテンシャル\n    vector<int> dist;            // 最短距離\n    vector<int> prevv, preve;    // 直前の頂点と辺\n\npublic:\n    PrimalDual(unsigned long num_of_node) : V(num_of_node) {\n        graph.resize(V);\n        h.resize(V, 0);\n        dist.resize(V);\n        prevv.resize(V);\n        preve.resize(V);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph[from].emplace_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める(流せない場合は-1)\n    // O(F|E|log |V|)かO(F|V|^2)\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n        while (f > 0) {\n            // ダイクストラ法を用いてhを更新する\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n            fill(dist.begin(), dist.end(), INT_MAX);\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while (not que.empty()) {\n                pair<int, int> p = que.top();  // firstは最短距離, secondは頂点の番号\n                que.pop();\n                int v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < graph[v].size(); ++i) {\n                    Edge &e = graph[v][i];\n                    if (e.cap - e.flow > 0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n\n            if (dist[t] == INT_MAX) {\n                // これ以上流せない\n                return -1;\n            }\n            for (int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    // sからtへの流量fの最小費用流(流せない場合は-1)\n    // 負のコストがあってもいい\n    // O(F|V||E|)\n    int min_cost_flow_bellmanford(int s, int t, int f) {\n        int res = 0;\n        while (f > 0) {\n            // ベルマンフォード法により、s-t間最短路を求める\n            fill(dist.begin(), dist.end(), INT_MAX);\n            dist[s] = 0;\n            bool update = true;\n            while (update) {\n                update = false;\n                for (int v = 0; v < V; v++) {\n                    if (dist[v] == INT_MAX) continue;\n                    for (int i = 0; i < graph[v].size(); i++) {\n                        Edge &e = graph[v][i];\n                        int rest = e.cap - e.flow;\n                        if (rest > 0 and dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            // これ以上流せない\n            if (dist[t] == INF) {\n                return -1;\n            }\n\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n\n            f -= d;\n            res += d * dist[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    // 水の流れたエッジを取得する\n    set<pair<int, int>> get_used_edges() {\n        set<pair<int, int>> used_edges;\n        for (int from = 0; from < this->graph.size(); ++from) {\n            for (Edge edge : graph[from]) {\n                int flow = edge.flow;\n                bool is_rev = edge.is_rev;\n\n                if (not is_rev and flow > 0) {\n                    int to = edge.to;\n                    used_edges.insert(make_pair(from , to));\n                }\n            }\n        }\n        return used_edges;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    VV<int> add(N, V<int>(N)), del(N, V<int>(N)), field(N, V<int>(N));\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            cin >> add[i][j];\n        }\n    }\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            cin >> del[i][j];\n        }\n    }\n\n    int cost = 0;\n    FOR(i, 0, N) {\n        string s;\n        cin >> s;\n        FOR(j, 0, N) {\n            field[i][j] = (s[j] == 'o') ? 1 : 0;\n\n            // 全部消す\n            if (field[i][j] == 1) {\n                cost += del[i][j];\n            }\n        }\n    }\n\n    PrimalDual pd(2 * N + 2);\n    const int source = 2 * N;\n    const int sink = source + 1;\n\n    FOR(i, 0, N) {\n        pd.add_edge(source, i, 1, 0);     // 行\n        pd.add_edge(i + N, sink, 1, 0);   // 列\n    }\n\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            if (field[i][j] == 1) {\n                pd.add_edge(i, j + N, 1, -del[i][j]);\n            }\n            else {\n                pd.add_edge(i, j + N, 1, add[i][j]);\n            }\n        }\n    }\n\n    print(cost + pd.min_cost_flow_bellmanford(source, sink, N));\n\n    VV<int> field2(N, V<int>(N, 0));\n    auto used_edges = pd.get_used_edges();\n    FOE(edge, used_edges) {\n        if (edge.first == source or edge.second == sink) { continue; }\n        int y = edge.first;\n        int x = edge.second - N;\n        field2[y][x] = 1;\n    }\n\n    V<string> ans;\n    FOR(y, 0, N) {\n        FOR(x, 0, N) {\n            if (field[y][x] == field2[y][x]) { continue; }\n            if (field[y][x] == 1) {\n                ans.emplace_back(to_string(y + 1) + \" \" + to_string(x + 1) + \" erase\");\n            }\n            else {\n                ans.emplace_back(to_string(y + 1) + \" \" + to_string(x + 1) + \" write\");\n            }\n        }\n    }\n\n    print(ans.size());\n    FOE(s, ans) {\n        print(s);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint to, cap, cost, rev;\n};\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INT_INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tint d = f;\n\t\tfor (int v = 0; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N*2, i, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N+i, N*2+1, 1, 0);\n\t}\n\tf += min_cost_flow(N*2, N*2+1, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n//\n#define MN 10010\nstruct edge{int to;ll cap,cost;int rev;\nedge(int to,ll cap,ll cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}};\nvector<edge> g[MN];\nint V_mcf,prevv[MN],preve[MN];\nll h[MN],dist[MN];\n\nvoid init(int V){\n\tV_mcf=V;\n\trep(i,V)g[i].clear();\n}\n\nvoid add_edge(int from,int to,ll cap,ll cost){\n\tg[from].pb(edge(to,cap,cost,sz(g[to])));\n\tg[to].pb(edge(from,0,-cost,sz(g[from])-1));\n};\n\nll min_cost_flow_neg(int s,int t,ll f){\n\tll res=0;\n\tfill(h,h+V_mcf,0);\n\twhile(f>0){\n\t\tfill(dist,dist+V_mcf,INF);\n\t\tdist[s]=0;\n\t\twhile(1){\n\t\t\tbool update=0;\n\t\t\trep(i,V_mcf)rep(j,sz(g[i])){\n\t\t\t\tedge& e=g[i][j];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[i]+e.cost+h[i]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[i]+e.cost+h[i]-h[e.to];\n\t\t\t\t\tprevv[e.to]=i;\n\t\t\t\t\tpreve[e.to]=j;\n\t\t\t\t\tupdate=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update)break;\n\t\t}\n\t\t\n\t\tif(dist[t]==INF)return INF*INF;\n\t\trep(v,V_mcf)h[v]+=dist[v];\n\t\tll d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,g[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge& e=g[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tg[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n//\n\nint n,W[111][111],E[111][111];\nchar c[111][111];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\trep(i,n)rep(j,n)cin>>W[i][j];\n\trep(i,n)rep(j,n)cin>>E[i][j];\n\trep(i,n)cin>>c[i];\n\tinit(n*2+2);\n\tint s = n*2, t = s+1;\n\trep(i,n){\n\t\tadd_edge(s, i, 1, 0);\n\t\tadd_edge(n+i, t, 1, 0);\n\t}\n\tint ans = 0;\n\trep(i,n)rep(j,n){\n\t\tif(c[i][j] == '.'){\n\t\t\tadd_edge(i, n+j, 1, W[i][j]);\n\t\t}else{\n\t\t\tans += E[i][j];\n\t\t\tadd_edge(i, n+j, 1, -E[i][j]);\n\t\t}\n\t}\n\tans += min_cost_flow_neg(s,t,n);\n\tcout<<ans<<endl;\n\tvector<pair<pi,string>> v;\n\trep(i,n)rep(j,sz(g[i])){\n\t\tint to = g[i][j].to - n;\n\t\tif(!(to >= 0 && to < n))continue;\n\t\tif(c[i][to] == '.' && g[i][j].cap == 0){\n\t\t\tv.pb(mp(mp(i+1,to+1),\"write\"));\n\t\t}\n\t\tif(c[i][to] == 'o' && g[i][j].cap == 1){\n\t\t\tv.pb(mp(mp(i+1,to+1),\"erase\"));\n\t\t}\n\t}\n\tcout<<sz(v)<<endl;\n\trep(i,sz(v)){\n\t\tcout<<v[i].fir.fir<<\" \"<<v[i].fir.sec<<\" \"<<v[i].sec<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nconst int INF = (1<<28);\n\nclass Edge\n{\npublic:\n\tint src,dst,cst,cap,rev;\n\tEdge(int src, int dst, int cst, int cap, int rev)\n\t\t:src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n\tgraph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n\tgraph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n\npair<int,int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n\tint V = graph.size();\n\tvector<int> dist(V), prevv(V), preve(V);\n\n\tint res = 0, fw = 0;\n\n\twhile(1) {\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tdist[S] = 0;\n\t\tbool update = true;\n\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0; v < V; v++) {\n\t\t\t\tif(dist[v] == INF) continue;\n\n\t\t\t\tfor(int i=0; i<graph[v].size(); i++) {\n\t\t\t\t\tEdge& e = graph[v][i];\n\t\t\t\t\tint cost = e.cst;\n\t\t\t\t\tif(graph[e.dst][e.rev].cap != 0) cost = 0;\n\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n\t\t\t\t\t\tdist[e.dst] = dist[e.src] + cost;\n\t\t\t\t\t\tprevv[e.dst] = e.src;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[T] == INF) break;\n\n\t\tint f = INF;\n\t\tfor(int v = T; v != S; v = prevv[v])\n\t\t\tf = min(f, graph[prevv[v]][preve[v]].cap);\n\n\t\tres += dist[T];\n\t\tfw += f;\n\n\t\tfor(int v = T; v != S; v = prevv[v]) {\n\t\t\tEdge& e = graph[prevv[v]][preve[v]];\n\t\t\te.cap -= f;\n\t\t\tgraph[v][e.rev].cap += f;\n\t\t}\n\n\t\tif(fw >= L) break;\n\t}\n\n\treturn make_pair(res, fw);\n}\n\nint ecst[100][100], icst[100][100];\nint main()\n{\n\tint N;\n\twhile(cin >> N, N) {\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tcin >> ecst[j][i];\n\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tcin >> icst[j][i];\n\n\t\tstring field[100];\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\n\t\tint res = 0;\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tif(field[i][j] == 'o') {\n\t\t\t\tres += ecst[j][i];\n\t\t\t}\n\t\t}\n\n\n\t\tGraph graph(N*N+2);\n\t\tfor(int i=0; i<N; i++) {\n\t\t\taddEdge(N*N, i, 1, 0, graph);\n\t\t\taddEdge(N+i, N*N+1, 1, 0, graph);\n\t\t}\n\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tint cst;\n\t\t\tif(field[j][i] == 'o') cst = -ecst[j][i];\n\t\t\telse cst = icst[j][i];\n\n\t\t\taddEdge(j, i+N, 1, cst, graph);\n\t\t}\n\n\t\tpair<int, int> fw = minimumCostFlow(N*N, N*N+1, N, graph);\n\n\n\t\tint ans = res + fw.first;\n\t\tcout << ans << endl;\n\n\t\tif(ans == 0) cout << 0 << endl;\n\n\t\telse {\n\t\t\tint c = 0;\n\t\t\tstringstream ss;\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\t\tEdge& e = graph[i][j];\n\n\t\t\t\t\tif(e.src >= N*N || e.dst >= N*N) continue;\n\n\t\t\t\t\tif(field[e.src][e.dst-N] == 'o' && e.cap == 1) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tss <<  e.src + 1 << \" \" << e.dst + 1 - N << \" erase\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\tif(field[e.src][e.dst-N] == '.' && e.cap == 0) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tss  << e.src + 1 << \" \" << e.dst + 1 - N << \" write\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << c << endl;\n\t\t\tcout << ss.str();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nconst int INF = (1<<28);\n\nclass Edge\n{\npublic:\n\tint src,dst,cst,cap,rev;\n\tEdge(int src, int dst, int cst, int cap, int rev)\n\t\t:src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n\tgraph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n\tgraph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n\npair<int,int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n\tint V = graph.size();\n\tvector<int> dist(V), prevv(V), preve(V);\n\n\tint res = 0, fw = 0;\n\n\twhile(1) {\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tdist[S] = 0;\n\t\tbool update = true;\n\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0; v < V; v++) {\n\t\t\t\tif(dist[v] == INF) continue;\n\n\t\t\t\tfor(int i=0; i<graph[v].size(); i++) {\n\t\t\t\t\tEdge& e = graph[v][i];\n\t\t\t\t\tint cost = e.cst;\n\t\t\t\t\tif(graph[e.dst][e.rev].cap != 0) cost = 0;\n\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n\t\t\t\t\t\tdist[e.dst] = dist[e.src] + cost;\n\t\t\t\t\t\tprevv[e.dst] = e.src;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[T] == INF) break;\n\n\t\tint f = INF;\n\t\tfor(int v = T; v != S; v = prevv[v])\n\t\t\tf = min(f, graph[prevv[v]][preve[v]].cap);\n\n\t\tres += dist[T];\n\t\tfw += f;\n\n\t\tfor(int v = T; v != S; v = prevv[v]) {\n\t\t\tEdge& e = graph[prevv[v]][preve[v]];\n\t\t\te.cap -= f;\n\t\t\tgraph[v][e.rev].cap += f;\n\t\t}\n\n\t\tif(fw >= L) break;\n\t}\n\n\treturn make_pair(res, fw);\n}\n\nint ecst[100][100], icst[100][100];\nint main()\n{\n\tint N;\n\tcin >> N;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> ecst[j][i];\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> icst[j][i];\n\n\tstring field[100];\n\tfor(int i=0; i<N; i++)\n\t\tcin >> field[i];\n\n\n\tint res = 0;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tif(field[i][j] == 'o') {\n\t\t\tres += ecst[j][i];\n\t\t}\n\t}\n\n\n\tGraph graph(N*N+2);\n\tfor(int i=0; i<N; i++) {\n\t\taddEdge(N*N, i, 1, 0, graph);\n\t\taddEdge(N+i, N*N+1, 1, 0, graph);\n\t}\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tint cst;\n\t\tif(field[j][i] == 'o') cst = -ecst[j][i];\n\t\telse cst = icst[j][i];\n\n\t\taddEdge(j, i+N, 1, cst, graph);\n\t}\n\n\tpair<int, int> fw = minimumCostFlow(N*N, N*N+1, N, graph);\n\n\n\tint ans = res + fw.first;\n\tcout << ans << endl;\n\n\tif(ans == 0) cout << 0 << endl;\n\n\telse {\n\t\tint c = 0;\n\t\tstringstream ss;\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\tEdge& e = graph[i][j];\n\n\t\t\t\tif(e.src >= N*N || e.dst >= N*N) continue;\n\n\t\t\t\tif(e.src > e.dst) continue;\n\n\t\t\t\tif(field[e.src][e.dst-N] == 'o' && e.cap == 1) {\n\t\t\t\t\tc++;\n\t\t\t\t\tss <<  e.src + 1 << \" \" << e.dst + 1 - N << \" erase\" << endl;\n\t\t\t\t}\n\t\t\t\tif(field[e.src][e.dst-N] == '.' && e.cap == 0) {\n\t\t\t\t\tc++;\n\t\t\t\t\tss  << e.src + 1 << \" \" << e.dst + 1 - N << \" write\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << c << endl;\n\t\tcout << ss.str();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(const auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n \nusing namespace std;\n \ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n \ntypedef pair<int, int> P;\ntypedef pair<ll,ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n \nconst int MAX_N = 100005;\n \ntemplate<typename T>\nclass Hungarian\n{\nprivate:\n    const int U, V;\n    vector<vector<int> > graph;\n    vector<T> dual;\n    vector<int> alloc, rev_alloc, prev;\n    const vector<vector<T> >& cost;\n    int matching_size;\n    T diff(const int i, const int j){\n        return cost[i][j] - dual[i] - dual[U + j];\n    }\n    void init_feasible_dual(){\n        for(int i = 0; i < U; ++i){\n            dual[i] = 0;\n            for(int j = 0; j < V; ++j){\n                dual[U + j] = min(dual[U + j], cost[i][j]);\n            }\n        }\n    }\n    void construct_graph(){\n        for(int i = 0; i < U; ++i){\n            for(int j = 0; j < V; ++j){\n                graph[i][j] = (diff(i, j) == 0 && rev_alloc[j] != i);\n            }\n        }\n    }\n    bool find_augmenting_path(const int cur, const int prv, int& pos){\n        prev[cur] = prv;\n        if(cur >= U){\n            if(rev_alloc[cur - U] < 0) return true;\n            if(find_augmenting_path(rev_alloc[cur - U], cur, pos)){\n                graph[rev_alloc[cur - U]][cur - U] = 1;\n                return true;\n            }\n        }else{\n            const int MX = (alloc[cur] < 0 && pos == U) ? U : V;\n            for(int i = 0; i < MX; ++i){\n                if(graph[cur][i] && prev[U + i] < 0 && find_augmenting_path(U + i, cur, pos)){\n                    graph[cur][i] = 0, alloc[cur] = i, rev_alloc[i] = cur;\n                    return true;\n                }\n            }\n            if(alloc[cur] < 0 && pos < U){\n                graph[cur][pos] = 0, alloc[cur] = pos, rev_alloc[pos] = cur, prev[U + pos] = cur;\n                return ++pos, true;\n            }\n        }\n        return false;\n    }\n    void update_dual(const T delta){\n        for(int i = 0; i < U; ++i) if(prev[i] >= 0) dual[i] += delta;\n        for(int i = U; i < U + V; ++i) if(prev[i] >= 0) dual[i] -= delta;\n    }\n    void maximum_matching(bool initial=false){\n        int pos = initial ? V : U;\n        for(bool update = false;; update = false){\n            fill(prev.begin(), prev.end(), -1);\n            for(int i = 0; i < U; ++i){\n                if(alloc[i] < 0 && find_augmenting_path(i, 2 * U, pos)){\n                    update = true, ++matching_size;\n                    break;\n                }\n            }\n            if(!update) break;\n        }\n    }\n    int dfs(const int cur, const int prv, vector<int>& new_ver){\n        prev[cur] = prv;\n        if(cur >= U){\n            if(rev_alloc[cur - U] < 0) return cur;\n            else return dfs(rev_alloc[cur - U], cur, new_ver);\n        }else{\n            new_ver.push_back(cur);\n            for(int i = 0; i < V; ++i){\n                if(graph[cur][i] && prev[U + i] < 0){\n                    const int res = dfs(U + i, cur, new_ver);\n                    if(res >= U) return res;\n                }\n            }\n        }\n        return -1;\n    }\n    int increase_matching(const vector<pair<int, int> >& vec, vector<int>& new_ver){\n        for(const auto& e : vec){\n            if(prev[e.first] < 0){\n                const int res = dfs(e.first, e.second, new_ver);\n                if(res >= U) return res;\n            }\n        }\n        return -1;\n    }\n    void hint_increment(int cur){\n        while(prev[cur] != 2 * U){\n            if(cur >= U){\n                graph[prev[cur]][cur - U] = 0, alloc[prev[cur]] = cur - U, rev_alloc[cur - U] = prev[cur];\n            }else{\n                graph[cur][prev[cur] - U] = 1;\n            }\n            cur = prev[cur];\n        }\n    }\npublic:\n    Hungarian(const vector<vector<T> >& _cost)\n         : U((int)_cost.size()), V((int)_cost[0].size()), graph(U, vector<int>(U, 1)), dual(U + V, numeric_limits<T>::max()),\n            alloc(U, -1), rev_alloc(U, -1), prev(2 * U), cost{_cost}, matching_size(0){\n        assert(U >= V);\n    }\n    pair<T, vector<int> > solve(){\n        init_feasible_dual(), construct_graph();\n        bool end = false;\n        maximum_matching(true);\n        while(matching_size < U){\n            vector<pair<T, int> > cand(V, {numeric_limits<T>::max(), numeric_limits<int>::max()});\n            for(int i = 0; i < U; ++i){\n                if(prev[i] < 0) continue;\n                for(int j = 0; j < V; ++j){\n                    if(prev[U + j] >= 0) continue;\n                    cand[j] = min(cand[j], {diff(i, j), i});\n                }\n            }\n            while(true){\n                T delta = numeric_limits<T>::max();\n                for(int i = 0; i < V; ++i){\n                    if(prev[U + i] >= 0) continue;\n                    delta = min(delta, cand[i].first);\n                }\n                update_dual(delta);\n                vector<pair<int, int> > vec;\n                vector<int> new_ver;\n                for(int i = 0; i < V; ++i){\n                    if(prev[U + i] >= 0) continue;\n                    if((cand[i].first -= delta) == 0) vec.emplace_back(U + i, cand[i].second);\n                }\n                int res = increase_matching(vec, new_ver);\n                if(res >= U){\n                    hint_increment(res);\n                    if(++matching_size == U) end = true;\n                    else construct_graph();\n                    break;\n                }else{\n                    for(const int v : new_ver){\n                        for(int i = 0; i < V; ++i){\n                            if(prev[U + i] >= 0) continue;\n                            cand[i] = min(cand[i], {diff(v, i), v});\n                        }\n                    }\n                }\n            }\n            if(!end) maximum_matching();\n        }\n        T total_cost = 0;\n        for(int i = 0; i < U; ++i){\n            if(alloc[i] < V) total_cost += cost[i][alloc[i]];\n            else alloc[i] = -1;\n        }\n        return make_pair(total_cost, alloc);\n    }\n};\n \nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vvi w(n, vi(n)), e(n, vi(n)), vec(n, vi(n));\n    rep(i,n){\n        rep(j,n){\n            cin >> w[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            cin >> e[i][j];\n        }\n    }\n    vs s(n);\n    rep(i,n){\n        cin >> s[i];\n        int sm = 0;\n        rep(j,n){\n            if(s[i][j] == 'o') sm += e[i][j];\n        }\n        rep(j,n){\n            if(s[i][j] == 'o'){\n                vec[i][j] = sm-e[i][j];\n            }else{\n                vec[i][j] = sm+w[i][j];\n            }\n        }\n    }\n    Hungarian<int> h(vec);\n    auto ans = h.solve();\n    cout << ans.fi << \"\\n\";\n    vp res;\n    rep(i,n){\n        rep(j,n){\n            if(j == ans.se[i]){\n                if(s[i][j] == '.'){\n                    res.pb(P(i+1, j+1));\n                }\n            }else{\n                if(s[i][j] == 'o'){\n                    res.pb(P(-(i+1), j+1));\n                }\n            }\n        }\n    }\n    cout << len(res) << \"\\n\";\n    each(p,res){\n        if(p.fi < 0){\n            cout << -p.fi << \" \" << p.se << \" erase\\n\";\n        }else{\n            cout << p.fi << \" \" << p.se << \" write\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            int dist2 = 0;\n            int flag;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist2)){\n                    v = i;\n                    dist2 = dist[i];\n                }\n            }\n            /*\n            for (int i = 0; i < r+1; i++) {\n                if (!used[i+l+1] && (v == -1 || dist[i+l+1] < dist2)){\n                    v = i;\n                    dist2 = dist[i+l+1];\n                    flag = false;\n                }\n            }*/\n            if (v == -1) break;\n            flag = (v < l+1);\n            if (v >= l+1) {\n                v -= l+1;\n            }\n            if (flag) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && dist[i+l+1] > dist[v] + G[v][i] + h[v] - h[i+l+1]) {\n\t\t\t\t\t\tdist[i+l+1] = dist[v] + G[v][i] + h[v] - h[i+l+1];\n\t\t\t\t\t\tprevv[i+l+1] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v+l+1] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v] && dist[i] > dist[v+l+1] - G[i][v] + h[v+l+1] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v+l+1] - G[i][v] + h[v+l+1] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevv[v] : prevv[v+l+1], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevv[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define INF 100000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cost,cap,rev;\n\tedge(){}\n\tedge(int tt,int ca,int cc,int rr){\n\t\tto=tt;\n\t\tcost=cc;\n\t\tcap=ca;\n\t\trev=rr;\n\t}\n};\n\nint V;\nvector<edge> G[501];\nint h[501];\nint dist[501];\nint prevv[501],preve[501];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(que.size()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first)continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF)return -1;\n\t\tfor(int v=0;v<V;v++){\n\t\t\th[v]+=dist[v];\n\t\t}\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint n;\nint w[101][101],e[101][101];\nint fie[101][101];\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\"%d\",&w[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tscanf(\"%d\",&e[i][j]);\n\t\t}\n\t}\n\tint sum=0;\n\tV=n*2+2;\n\tint s=n*2,t=s+1;\n\tfor(int i=0;i<n;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tadd_edge(s,i,1,0);\n\t\tadd_edge(n+i,t,1,0);\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(str[j]=='o'){\n\t\t\t\tsum+=e[i][j];\n\t\t\t\tadd_edge(i,n+j,1,1000-e[i][j]);\n\t\t\t\tfie[i][j]=1;\n\t\t\t}else{\n\t\t\t\tadd_edge(i,n+j,1,1000+w[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum+min_cost_flow(s,t,n)-1000*n);\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tif(G[i][j].to<n || G[i][j].to>=n*2)continue;\n\t\t\tif(G[i][j].cap==0 && fie[i][G[i][j].to-n]==0){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(G[i][j].cap==1 && fie[i][G[i][j].to-n]==1){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",cnt);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tif(G[i][j].to<n || G[i][j].to>=n*2)continue;\n\t\t\tif(G[i][j].cap==0 && fie[i][G[i][j].to-n]==0){\n\t\t\t\tprintf(\"%d %d write\\n\",i+1,G[i][j].to-n+1);\n\t\t\t}\n\t\t\tif(G[i][j].cap==1 && fie[i][G[i][j].to-n]==1){\n\t\t\t\tprintf(\"%d %d erase\\n\",i+1,G[i][j].to-n+1);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n#define MAX_V 10000\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V], prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].PB({to, cap, cost, (int)G[to].size()});\n  G[to].PB({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  while(f > 0) {\n    fill(dist, dist+V, INF);\n    dist[s] = 0;\n    bool update = true;\n    while(update) {\n      update = false;\n      REP(v, V) {\n        if(dist[v] == INF) continue;\n        REP(i, G[v].size()) {\n          edge &e = G[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n            dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]) {\n      chmin(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * dist[t];\n    for(int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint w[105][105], e[105][105];\nstring s[105], t[105];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n) REP(j, n) cin >> w[i][j];\n  REP(i, n) REP(j, n) cin >> e[i][j];\n  REP(i, n) cin >> s[i];\n  REP(i, n) t[i] = string(n, '.');\n\n  // 'o'????????????erase???????????????????±???????\n  int sum = 0;\n  REP(i, n) REP(j, n) if(s[i][j] == 'o') sum += e[i][j];\n\n  // supersource:0, supersink:1, ???:2??????n+1, ???:n+2??????2*n+1\n  V = 2*n+2;\n  REP(i, n) add_edge(0, i+2, 1, 0);\n  REP(i, n) add_edge(n+2+i, 1, 1, 0);\n  REP(i, n) REP(j, n) {\n    if(s[i][j] == 'o') {\n      add_edge(i+2, j+n+2, 1, -e[i][j]);\n    } else {\n      add_edge(i+2, j+n+2, 1, w[i][j]);\n    }\n  }\n\n  cout << sum + min_cost_flow(0, 1, n) << endl;\n\n  // cap???0??????????????¨??????????????????????????¢??§'o'\n  FOR(i, 2, n+2) for(edge e: G[i]) {\n    if(e.cap == 0 && n+2 <= e.to && e.to < 2*n+2) {\n      t[i-2][e.to-n-2] = 'o';\n    }\n  }\n\n  // ??????????????¢??????????????????????????°????????§?¨??????????????????????\n  vector<PII> ans;\n  REP(i, n) REP(j, n) {\n    if(s[i][j] == t[i][j]) continue;\n    ans.PB({i, j});\n  }\n\n  cout << ans.size() << endl;\n  for(auto i: ans) {\n    cout << i.first+1 << \" \" << i.second+1;\n    if(s[i.first][i.second] == '.') {\n      cout << \" write\" << endl;\n    } else {\n      cout << \" erase\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 100\n#define MAX_E 1000\nusing namespace std;\ntypedef pair<int, int> P;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to_, int cap_, int cost_, int rev_)\n\t\t: to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid AddEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\n\nint MinimumCostFlow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\th[v] += dist[v];\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tV = n * 2 + 2;\n\tvector<vector<int>> W(n, vector<int>(n)), E(n, vector<int>(n));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> W[i][j];\n\t\t}\n\t\tAddEdge(n * 2, i, 1, 0);\n\t\tAddEdge(n + i, n * 2 + 1, 1, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tvector<string> s(n);\n\tint def = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tAddEdge(i, n + j, 1, W[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAddEdge(i, n + j, 1, -E[i][j]);\n\t\t\t\tdef += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << MinimumCostFlow(n * 2, n * 2 + 1, n) + def << endl;\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" erase\" << endl;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nedge G[MAX_V][MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from][to] = (edge){1, cost};\n\tG[to][from] = (edge){0, -cost};\n}\n\nint bit_matching_cost(int s, int t, int &f) {\n\tf = 0;\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (true) {\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[s] = 0;\n\n        fill_n(used, V, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < V; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            used[v] = true;\n\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t}\n\t\t\t}\n        }\n\t\tif (dist[t] == INT_INF) {\n\t\t\treturn res;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tf++;\n\t\tres += h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][v];\n\t\t\te.cap -= 1;\n\t\t\tG[v][prevv[v]].cap += 1;\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N*2, i, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N+i, N*2+1, 1, 0);\n\t}\n\tint f1 = 0;\n\tf += bit_matching_cost(N*2, N*2+1, f1);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][N+j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < int(Y);++(X))\n#define peat(X,Y) for (;(X) < int(Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,g[to].size(),cost});\n  g[to].pb((Edge){from,0,g[from].size()-1,-cost});\n}\nCost INF=1e7;\n\n//min-cost,dij\n\ntypedef pair<Cost,int> Que;\n\ndouble min_cost_flow(Graph &g,int s,int t,int f){\n  int V=g.size();\n  vector<Cost> dist(V);\n  vector<int> used(V),prevv(V),preve(V);\n  double res=0;\n  int v,i;\n  while(f>0){\n    fill(all(dist),INF);\n    dist[s]=0;\n    bool upd=1;\n    while(upd){\n      upd=0;\n      rep(v,V){\n        if(dist[v]==INF)continue;\n        rep(i,g[v].size()){\n          Edge &e=g[v][i];\n          if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            upd=1;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)\n      return -1;\n    int d=f;\n    for(v=t;v!=s;v=prevv[v]){\n      d=min(d,g[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*dist[t];\n    for(v=t;v!=s;v=prevv[v]){\n      Edge &e=g[prevv[v]][preve[v]];\n      e.cap-=d;\n      g[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k,n;\n  cin>>n;\n  vector<vector<int> > w(n,vector<int>(n)),e(n,vector<int>(n));\n  rep(i,n)rep(j,n)\n    cin>>w[i][j];\n  rep(i,n)rep(j,n)\n    cin>>e[i][j];\n  string str,strs[n];\n  Graph g(n*2+2);\n  rep(i,n){\n    cin>>str;\n    strs[i]=str;\n    int sum=0;\n    rep(j,n){\n      if(str[j]=='o'){\n        w[i][j]=-e[i][j];\n        sum+=e[i][j];\n      }\n    }\n    rep(j,n)\n      add_edge(g,i+2,j+n+2,1,sum+w[i][j]);\n    add_edge(g,0,i+2,1,0);\n    add_edge(g,i+n+2,1,1,0);\n  }\n  cout<<min_cost_flow(g,0,1,n)<<endl;\n  vector<pii> er,wr;\n  rep(i,n){\n    int fr=-1;\n    rep(j,g[i+n+2].size()){\n      if(g[i+n+2][j].cap){\n        fr=g[i+n+2][j].to-2;\n        break;\n      }\n    }\n    rep(j,n){\n      if(j==i){\n        if(strs[fr][j]=='.')\n          wr.pb(pii(fr,j));\n      }else{\n        if(strs[fr][j]=='o')\n          er.pb(pii(fr,j));\n      }\n    }\n  }\n  cout<<er.size()+wr.size()<<endl;\n  rep(i,er.size())\n    cout<<er[i].X+1<<\" \"<<er[i].Y+1<<\" erase\"<<endl;\n  rep(i,wr.size())\n    cout<<wr[i].X+1<<\" \"<<wr[i].Y+1<<\" write\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 2000\n#define INF (1<<26)\ntypedef pair<int,int > P;\nstruct edge{int to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n  \n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint t[200][200],u[200][200];\nchar a[200][200],b[200][200];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>u[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>a[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      b[i][j]='.';\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int sum=0;\n      if(a[i][j]=='.'){\n\tsum+=t[i][j]*2;\n\tfor(int k=0;k<n;k++){\n\t  if(a[i][k]=='o')sum+=u[i][k];\n\t  if(a[k][j]=='o')sum+=u[k][j];\n\t}\n      }else{\n\tfor(int k=0;k<n;k++){\n\t  if(k!=j&&a[i][k]=='o')sum+=u[i][k];\n\t  if(k!=i&&a[k][j]=='o')sum+=u[k][j];\n\t}\t\n      }\n      add_edge(i,n+j,1,sum);\n    }\n  }\n  for(int i=0;i<n;i++){\n    add_edge(n+n,i,1,0);\n    add_edge(n+i,n+n+1,1,0);\n  }\n  V=n+n+2;\n  cout<<min_cost_flow(n+n,n+n+1,n)/2<<endl;\n\n\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      edge e=G[i][j];\n      \n      if(e.cap==0&&n<=e.to&&e.to<n+n){\n\tb[i][e.to-n]='o';\n      }\n    }\n  }\n\n\n  vector<P> ans;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i][j]==b[i][j])continue;\n      ans.push_back(P(i,j));\n    }\n  }\n  \n  cout<<ans.size()<<endl;\n  for(int i=0;i<(int)ans.size();i++){\n    P p=ans[i];\n    if(a[p.first][p.second]=='.'){\n      cout<<p.first+1<<\" \"<<p.second+1<<\" write\"<<endl;\n    }else{\n      cout<<p.first+1<<\" \"<<p.second+1<<\" erase\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 100000;\nconst Cost INF = numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int d; Flow c, f; Cost w; int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n            :d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = pair<Cost, int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h + n, 0);\n        while (f > 0) {\n            fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)g[v].size(); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) {\n                return -1; // ?????????????????????????????£???\n            }\n\n            // s-t ????????????????????£??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n\n    // ???????????¨???\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n\nint n;\nint W[128][128], E[128][128];\nchar f[128][128];\nint ans[10000][3];\n\nint main() {\n    cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n\n    int C = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (f[i][j] == 'o') {\n                C += E[i][j];\n            }\n        }\n    }\n\n    PrimalDual pd(n * 2 + 2);\n\n    int s = n * 2, t = n * 2 + 1;\n    for (int i = 0; i < n; i++) {\n        pd.add_edge(s, i, 1, 0);\n        pd.add_edge(i + n, t, 1, 0);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            pd.add_edge(i, j + n, 1, f[i][j] == 'o' ? -E[i][j] : W[i][j]);\n        }\n    }\n\n    cout << C + pd.solve(s, t, n) << '\\n';\n\n    int cnt = 0;\n    for (int i = 0; i < pd.g.size(); i++) {\n        for (auto &e : pd.g[i]) {\n            if (e.is_r || e.w == 0) continue;\n            if (f[i][e.d - n] == 'o' && e.f == 0) {\n                cnt++;\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 0;\n            } else if (f[i][e.d - n] == '.' && e.f == 1) {\n                cnt++;\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 1;\n            }\n        }\n    }\n\n    cout << cnt << '\\n';\n    for (int i = 0; i < cnt; i++) {\n        ans[i][0]++;\n        ans[i][1]++;\n        cout << ans[i][0] << ' ' << ans[i][1] << ' ' << (ans[i][2] == 0 ? \"erase\" : \"write\") << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\n\n// http://www.cse.ust.hk/~golin/COMP572/Notes/Matching.pdf\n\nvector<int> min_cost_match(vector< vector<int> > a) {\n\tint n=a.size(),m=a[0].size();\n\tvector<int> left(n,-1), right(m,-1);\n\tvector<int> ofsleft(n,0), ofsright(m,0);\n\tauto cost=[&](int i,int j){ return a[i][j]+ofsleft[i]+ofsright[j];};\n\n\trep(r,n){\n\t\tvector<bool> s(n,false),t(m,false);\n\t\tvector<int> trace(m,-1), edge(m,r);\n\t\ts[r]=true;\n\n\t\tint b=-1;\n\t\twhile(1){\n\t\t\tint d=numeric_limits<int>::max();\n\t\t\trep(j,m) if(!t[j]) d=min(d,cost(edge[j],j));\n\t\t\trep(i,n) if(s[i]) ofsleft[i]-=d;\n\t\t\trep(j,m) if(t[j]) ofsright[j]+=d;\n\n\t\t\trep(j,m) if(!t[j]&&cost(edge[j],j)==0) b=j;\n\t\t\ttrace[b]=edge[b];\n\t\t\tint c=right[b];\n\t\t\tif(c<0) break;\n\t\t\ts[c]=t[b]=true;\n\t\t\trep(j,m) if(cost(c,j)<cost(edge[j],j)) edge[j]=c;\n\t\t}\n\t\twhile(b>=0){\n\t\t\tint a=trace[b],nb=left[a];\n\t\t\tright[b]=a,left[a]=b,b=nb;\n\t\t}\n\t}\n\treturn left;\n}\n\nint n;\n\nint w[110][110],e[110][110];\nstring s[110];\nbool op[110][110];\n\nint row[110],col[110];\n\nvoid output(int i,int j,int type){\n\tcout << i+1 << \" \" << j+1 << \" \";\n\tif(type)\n\t\tcout << \"write\" << endl;\n\telse\n\t\tcout << \"erase\" << endl;\n\treturn;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n)rep(j,n) cin >> w[i][j];\n\trep(i,n)rep(j,n) cin >> e[i][j];\n\trep(i,n) cin >> s[i];\n\n\trep(i,n){\n\t\trow[i]=0,col[i]=0;\n\t\trep(j,n) if(s[i][j]=='o') row[i]+=e[i][j];\n\t\trep(j,n) if(s[j][i]=='o') col[i]+=e[j][i];\n\t}\n\n\tvector<vector<int>> cost(n,vector<int>(n,0));\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='o')\n\t\t\tcost[i][j]=row[i]+col[j]-2*e[i][j];\n\t\telse\n\t\t\tcost[i][j]=row[i]+col[j]+2*w[i][j];\n\t}\n\n\tvector<int> match=min_cost_match(cost);\n\trep(i,n) op[i][match[i]]=true;\n\n\tint mincost=0,cnt=0;\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='.'&&op[i][j]==true) mincost+=w[i][j],cnt++;\n\t\tif(s[i][j]=='o'&&op[i][j]==false) mincost+=e[i][j],cnt++;\n\t}\n\tcout << mincost << endl;\n\tcout << cnt << endl;\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='.'&&op[i][j]==true) output(i,j,1);\n\t\tif(s[i][j]=='o'&&op[i][j]==false) output(i,j,0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MinCostFlow {\npublic:\n  struct edge { int to, cap, cost, rev; };\n\n  const int INF = 1 << 28;\n  int N;\n  vector<vector<edge>> E;\n  vector<int> h, dist, prevv, preve;\n\n  MinCostFlow(int N): N(N), E(N), h(N, 0), dist(N), prevv(N), preve(N) {}\n\n  void add_directed_edge(int from, int to, int cap, int cost) {\n    E[from].push_back((edge) { to, cap, cost, (int) E[to].size() });\n    E[to].push_back((edge) { from, 0, -cost, (int) E[from].size() - 1 });\n  }\n\n  int min_cost_flow(int s, int t, int f) {\n    int ret = 0;\n    while (f > 0) {\n      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n      for (int i = 0; i < N; i++) dist[i] = INF;\n      dist[s] = 0;\n      q.push(make_pair(0, s));\n      while (!q.empty()) {\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < E[v].size(); i++) {\n          edge &e = E[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            q.push(make_pair(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) return -1;\n      for (int v = 0; v < N; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) d = min(d, E[prevv[v]][preve[v]].cap);\n      f -= d;\n      ret += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = E[prevv[v]][preve[v]];\n        e.cap -= d;\n        E[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n};\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<vector<ll>> W(N, vector<ll>(N)), E(N, vector<ll>(N));\n  vector<string> F(N);\n  REP(i, 0, N) REP(j, 0, N) cin >> W[i][j];\n  REP(i, 0, N) REP(j, 0, N) cin >> E[i][j];\n  REP(i, 0, N) cin >> F[i];\n\n  MinCostFlow mcf(N * 2 + 2);\n\n  ll s = N * 2, t = N * 2 + 1;\n  vector<ll> row(N), col(N);\n  REP(i, 0, N) row[i] = i;\n  REP(i, 0, N) col[i] = N + i;\n\n  REP(i, 0, N) mcf.add_directed_edge(s, row[i], 1, 0);\n  REP(i, 0, N) mcf.add_directed_edge(col[i], t, 1, 0);\n\n  REP(i, 0, N) {\n    REP(j, 0, N) {\n      ll cost = 0;\n      REP(k, 0, N) {\n        if (k == j) {\n          if (F[i][k] == '.') cost += W[i][k];\n        } else {\n          if (F[i][k] == 'o') cost += E[i][k];\n        }\n      }\n      mcf.add_directed_edge(row[i], col[j], 1, cost);\n    }\n  }\n\n  ll min_cost = mcf.min_cost_flow(s, t, N);\n\n  struct operation {\n    ll row, col;\n    bool circle;\n  };\n  vector<operation> op;\n  REP(i, 0, N) {\n    REP(j, 0, N) {\n      if (mcf.E[i][j + 1].cap != 0) continue;\n      REP(k, 0, N) {\n        if (k == j) {\n          if (F[i][k] == '.') op.push_back({ i, k, true });\n        } else {\n          if (F[i][k] == 'o') op.push_back({ i, k, false });\n        }\n      }\n    }\n  }\n\n  cout << min_cost << endl;\n  cout << op.size() << endl;\n  REP(i, 0, op.size()) {\n    cout << op[i].row + 1 << \" \" << op[i].col + 1 << \" \" << (op[i].circle ? \"write\" : \"erase\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(){}\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\nstruct ope{\n\tint i, j, type;\n\tope(int a, int b, int c){\n\t\ti = a, j = b, type = c;\n\t}\n};\n\nint n;\nint W[105][105], E[105][105];\nchar F[105][105];\n\nint cost[105][105];\nint S, T;\nvector<edge> G[205];\nint dist[205];\nint prevv[205], preve[205];\nvector<ope> vec;\n\nvoid BellmanFord()\n{\n\tfor(int i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = 0; i <= T; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> W[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcin >> F[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tint sum = 0;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(j == k && F[i][k] == '.') sum += W[i][k];\n\t\t\t\tif(j != k && F[i][k] == 'o') sum += E[i][k];\n\t\t\t}\n\t\t\tcost[i][j] = sum;\n\t\t}\n\t}\n\t\n\tS = 2*n, T = 2*n+1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tadd_edge(i, j+n, 1, cost[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) add_edge(S, i, 1, 0);\n\tfor(int i = 0; i < n; i++) add_edge(i+n, T, 1, 0);\n\t\n\tint f = n, ans = 0;\n\twhile(f > 0){\n\t\tBellmanFord();\n\t\t\n\t\tint p = T, flow = f;\n\t\twhile(prevv[p] != -1){\n\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\tp = prevv[p];\n\t\t}\n\t\t\n\t\tp = T;\n\t\twhile(prevv[p] != -1){\n\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\tp = prevv[p];\n\t\t}\n\t\tf -= flow;\n\t\tans += dist[T] * flow;\n\t}\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].cap > 0) continue;\n\t\t\tint J = G[i][j].to - n;\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(J == k && F[i][k] == '.') vec.push_back( ope(i, k, 0) );\n\t\t\t\tif(J != k && F[i][k] == 'o') vec.push_back( ope(i, k, 1) );\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\tcout << vec.size() << endl;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tcout << vec[i].i+1 << \" \" << vec[i].j+1 << \" \";\n\t\tif(vec[i].type) cout << \"erase\" << endl;\n\t\telse cout << \"write\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\n\nint G[MAX_V][MAX_V];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevvl[MAX_V], prevvr[MAX_V];\nbool used[MAX_V*2+2];\nbool flow[MAX_V][MAX_V] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            int dist2 = 0;\n            int flag;\n            for (int i = 0; i < l+1; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist2)){\n                    v = i;\n                    dist2 = dist[i];\n                    flag = true;\n                }\n            }\n            for (int i = 0; i < r+1; i++) {\n                if (!used[i+l+1] && (v == -1 || dist[i+l+1] < dist2)){\n                    v = i;\n                    dist2 = dist[i+l+1];\n                    flag = false;\n                }\n            }\n            if (v == -1) break;\n            if (flag) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && dist[i+l+1] > dist[v] + G[v][i] + h[v] - h[i+l+1]) {\n\t\t\t\t\t\tdist[i+l+1] = dist[v] + G[v][i] + h[v] - h[i+l+1];\n\t\t\t\t\t\tprevvr[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v+l+1] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v] && dist[i] > dist[v+l+1] - G[i][v] + h[v+l+1] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v+l+1] - G[i][v] + h[v+l+1] - h[i];\n\t\t\t\t\t\tprevvl[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+1; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tfor (int v = 0; v < r+1; v++) {\n\t\t\th[v+l+1] += dist[v+l+1];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevvl[v] : prevvr[v], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevvl[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevvr[v]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<29);\n\nstruct edge{int to, cap, cost, rev;};\n \nint V;\nvector<edge> G[300];\nint h[300];\nint dist[300];\nint prevv[300],preve[300];\n  \nvoid init(){\n  for(int i = 0 ; i < 300 ; i++){\n    G[i].clear();\n  }\n}\n  \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n  \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n  \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < (int)G[v].size() ; i++){\n        edge &e = G[v][i];\n          \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n  \n    if(dist[t] == INF){\n      return -1;\n    }\n  \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n        \n    int d = f;\n  \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n \nstruct result{\n  int x,y;\n  string s;\n};\n\nint N;\nint W[111][111];\nint E[111][111];\nchar M[111][111];\n\nint cost[111][111];\n\nvector<result> ans;\nvoid writer(int x,int y){\n  for(int k=0;k<N;k++){\n    if( x == k ){\n      if( M[k][y] == '.' )\n\tans.push_back( (result){k,y,\"write\"} );      \n    } else\n      if( M[k][y] == 'o' )\n\tans.push_back( (result){k,y,\"erase\"} );\n  }\n}\n \nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> W[j][i];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> E[j][i];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> M[j][i];\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      for(int k=0;k<N;k++){\n\tif( j == k ){\n\t  if( M[k][i] == '.' ) cost[j][i] += W[k][i];\n\t} else\n\t  if( M[k][i] == 'o' ) cost[j][i] += E[k][i];\n      }\n    }\n  }\n\n  for(int x=0;x<N;x++)\n    for(int y=0;y<N;y++)\n      add_edge(x,y+N,1,cost[x][y]);\n\n  for(int i=N;i<N+N;i++)\n    add_edge(i,N+N+1,1,0);\n  for(int i=0;i<N;i++)\n    add_edge(N+N,i,1,0);\n\n  V = N + N + 2;\n\n  cout << min_cost_flow(N+N,N+N+1,N) << endl;\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if( N <= G[i][j].to && G[i][j].to < N+N )\n\tif( G[i][j].cap == 0 )\n\t  writer(i,G[i][j].to-N);\n    }\n  }\n\n  cout << ans.size() << endl;\n  for(int i=0;i<(int)ans.size();i++){\n    cout << ans[i].y+1 << \" \" << ans[i].x+1 <<\" \" << ans[i].s<< endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n \nconst int INF = (1<<28);\n \nclass Edge\n{\npublic:\n    int src,dst,cst,cap,rev;\n    Edge(int src, int dst, int cst, int cap, int rev)\n        :src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n    {}\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n    graph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n    graph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n \npair<int, int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n  int V = graph.size();\n  vector<int> dist(V), prevv(V), preve(V);\n \n  int res = 0, fw = 0;\n  while(1) {\n    fill(dist.begin(), dist.end(), INF);\n    dist[S] = 0;\n    bool update = true;\n \n    while(update) {\n      update = false;\n      for(int v = 0; v < V; v++) {\n        if(dist[v] == INF) continue;\n \n        for(int i=0; i<graph[v].size(); i++) {\n          Edge& e = graph[v][i];\n          int cost = e.cst;\n          if(graph[e.dst][e.rev].cap != 0) cost = 0;\n \n          if(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n            dist[e.dst] = dist[e.src] + cost;\n            prevv[e.dst] = e.src;\n            preve[e.dst] = i;\n            update = true;\n          }\n        }\n      }\n    }\n \n    if(dist[T] == INF) break;\n \n    int f = INF;\n    for(int v = T; v != S; v = prevv[v])\n      f = min(f, graph[prevv[v]][preve[v]].cap);\n \n    res += dist[T];\n    fw += f;\n \n    for(int v = T; v != S; v = prevv[v]) {\n      Edge& e = graph[prevv[v]][preve[v]];\n      e.cap -= f;\n      graph[v][e.rev].cap += f;\n    }\n \n    if(fw >= L) break;\n  }\n \n  return make_pair(res, fw);\n}\n \nint ecst[100][100], icst[100][100];\nint main()\n{\n    int N;\n    cin >> N;\n    for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n        cin >> ecst[i][j];\n \n    for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n        cin >> icst[i][j];\n \n    string field[100];\n    for(int i=0; i<N; i++)\n        cin >> field[i];\n \n    Graph graph(N*2+2);\n    for(int i=0; i<N; i++) {\n        addEdge(N*2, i, 1, 0, graph);\n        addEdge(N+i, N*2+1, 1, 0, graph);\n    }\n \n    for(int i=0; i<N; i++) \n\tfor(int j=0; j<N; j++) {\n\t\tint cst = 0;\n\t\tfor(int k=0; k<N; k++) {\n\t\t\tif(field[k][j] == 'o') cst += ecst[k][j];\n\t\t\tif(field[i][k] == 'o') cst += ecst[i][k];\n\t\t}\n\n\t\tif(field[i][j] == 'o') cst -= 2*ecst[i][j];\n\t\tif(field[i][j] == '.') cst += 2*icst[i][j];\n \n        addEdge(j, i+N, 1, cst, graph);\n    }\n \n    pair<int, int> fw = minimumCostFlow(N*2, N*2+1, N, graph);\n \n\n    cout << fw.first/2 << endl;\n \n    int c = 0;\n    stringstream ss;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<graph[i].size(); j++) {\n            Edge& e = graph[i][j];\n \n            if(e.dst < N || e.dst >= N*2) continue;\n \n            if(field[e.dst-N][e.src] == 'o' && e.cap == 1) {\n                c++;\n                ss << e.dst + 1 - N << \" \" << e.src + 1 << \" erase\" << endl;\n            }\n            if(field[e.dst-N][e.src] == '.' && e.cap == 0) {\n                c++;\n                ss << e.dst + 1 - N << \" \" << e.src + 1 << \" write\" << endl;\n            }\n        }\n    }\n \n    cout << c << endl;\n    cout << ss.str();\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nvector<int> min_cost_match(vector<vector<int>> a) {\n\tint n=a.size(),m=a[0].size();\n\tvector<int> left(n,-1), right(m,-1);\n\tvector<int> ofsleft(n,0), ofsright(m,0);\n\tauto cost=[&](int i,int j){ return a[i][j]+ofsleft[i]+ofsright[j];};\n\n\trep(r,n){\n\t\tvector<bool> s(n,false),t(m,false);\n\t\tvector<int> trace(m,-1), edge(m,r);\n\t\ts[r]=true;\n\n\t\tint b=-1;\n\t\twhile(1){\n\t\t\tint d=numeric_limits<int>::max();\n\t\t\trep(j,m) if(!t[j]) d=min(d,cost(edge[j],j));\n\t\t\trep(i,n) if(s[i]) ofsleft[i]-=d;\n\t\t\trep(j,m) if(t[j]) ofsright[j]+=d;\n\n\t\t\trep(j,m) if(!t[j]&&cost(edge[j],j)==0) b=j;\n\t\t\ttrace[b]=edge[b];\n\t\t\tint c=right[b];\n\t\t\tif(c<0) break;\n\n\t\t\ts[c]=t[b]=true;\n\t\t\trep(j,m) if(cost(c,j)<cost(edge[j],j)) edge[j]=c;\n\t\t}\n\t\twhile(b>=0){\n\t\t\tint a=trace[b],nb=left[a];\n\t\t\tright[b]=a,left[a]=b,b=nb;\n\t\t}\n\t}\n\treturn left;\n}\n\nint n;\nint w[110][110],e[110][110];\nstring s[110];\nbool op[110][110];\n\nint row[110],col[110];\n\nint main(void){\n\tcin >> n;\n\trep(i,n)rep(j,n) cin >> w[i][j];\n\trep(i,n)rep(j,n) cin >> e[i][j];\n\trep(i,n) cin >> s[i];\n\n\trep(i,n){\n\t\trow[i]=0,col[i]=0;\n\t\trep(j,n) if(s[i][j]=='o') row[i]+=e[i][j];\n\t\trep(j,n) if(s[j][i]=='o') col[i]+=e[j][i];\n\t}\n\n\tvector<vector<int>> cost(n,vector<int>(n,0));\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='o')\n\t\t\tcost[i][j]=row[i]+col[j]-2*e[i][j];\n\t\telse\n\t\t\tcost[i][j]=row[i]+col[j]+2*w[i][j];\n\t}\n\tvector<int> match=min_cost_match(cost);\n\trep(i,n) op[i][match[i]]=true;\n\n\tint mincost=0,cnt=0;\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='.'&&op[i][j]==true) mincost+=w[i][j],cnt++;\n\t\tif(s[i][j]=='o'&&op[i][j]==false) mincost+=e[i][j],cnt++;\n\t}\n\tcout << mincost << endl;\n\tcout << cnt << endl;\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='.'&&op[i][j]==true) printf(\"%d %d write\\n\",i+1,j+1);\n\t\tif(s[i][j]=='o'&&op[i][j]==false) printf(\"%d %d erase\\n\",i+1,j+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\nstruct PrimalDual {\n    typedef int Capacity;\n    typedef int Cost;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n\n    struct Edge {\n        const int dst;\n        Capacity cap;\n        const Capacity cap_orig;\n        const Cost cost;\n        const int revEdge;\n        const bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    PrimalDual(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].push_back(Edge(dst, cap, cost, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, -cost, g[src].size() - 1, true));\n    }\n\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        vector<Cost> h(g.size()), dist(g.size());\n        vector<int> prevv(g.size()), preve(g.size());\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            dist.assign(n,inf);\n            dist[s] = 0;\n            q.push(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.push(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.min_cost_flow(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\nusing Weight = int;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\nconstexpr int INF = 1000000000;\n\n\npair<Weight, Array> hungarian(const Matrix &m) {\n  int n = m.size();\n  int p, q;\n  Array fx(n, INF), fy(n, 0);\n  vector<int> x(n, -1), y(n, -1);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n+1, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == m[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      Weight d = INF;\n      for (int k = 0; k <= q; ++k)\n        REP(j,n)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - m[s[k]][j]);\n      REP(j,n) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  Weight ret = 0;\n  REP(i,n) ret += m[i][x[i]];\n  return make_pair(ret, x);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  Matrix mat(n, Array(n));\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        mat[i][j] = 1000 + e[i][j];\n        cost += e[i][j];\n      } else {\n        mat[i][j] = 1000 - w[i][j];\n      }\n    }\n  }\n  auto res = hungarian(mat);\n  cout << (n*1000 - res.first + cost) << endl;\n  int cnt = 0;\n  stringstream ss;\n  REP(i,n)REP(j,n) {\n    if (m[i][j] == 'o') {\n      if (res.second[i] != j) {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++cnt;\n      }\n    } else {\n      if (res.second[i] == j) {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++cnt;\n      }\n    }\n  }\n  cout << cnt << endl;\n  cout << ss.str() << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 514\n#define INF (1<<29)\n\nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int cost, int rev) :\n        to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\nint V;\nvector<Edge> G[MAX_V];\nint dist[MAX_V], prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f)\n{\n    int res = 0;\n    while (f > 0) {\n\tfill(dist, dist + V, INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile (update) {\n\t    update = false;\n\t    for (int v = 0; v < V; v++) {\n\t\tif (dist[v] == INF) continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t    Edge &e = G[v][i];\n\t\t    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (dist[t] == INF) return -1;\n\tint d = f;\n\tfor (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\t}\n        f -= d;\n\tres += d * dist[t];\n\tfor (int v = t; v != s; v = prevv[v]) {\n\t    Edge &e = G[prevv[v]][preve[v]];            \n\t    e.cap -= d;\n\t    G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<vector<int>> W(N, vector<int>(N)), E(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> W[i][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> E[i][j];\n        }\n    }\n    \n    int sum = 0;\n    vector<vector<char>> F(N, vector<char>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> F[i][j];\n            if (F[i][j] == 'o') {\n                sum += E[i][j];\n            }\n        }\n    }\n\n    int S = 2 * N, T = S + 1;\n    V = T + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(S, i, 1, 0);\n        add_edge(N+i, T, 1, 0);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (F[i][j] == 'o') {\n                add_edge(i, j + N, 1, -E[i][j]);\n            } else {\n                add_edge(i, j + N, 1, W[i][j]);\n            }\n        }\n    }\n    \n    cout << min_cost_flow(S, T, N) + sum << endl;\n    vector<int> r, c, op;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int k = G[i][j].to - N;\n            if (G[i][j].cap == 0 && F[i][k] == '.' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(0);\n            }\n            if (G[i][j].cap > 0 && F[i][k] == 'o' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(1);\n            }\n        }\n    }\n\n    cout << r.size() << endl;\n    for (int i = 0; i < (int)r.size(); i++) {\n        cout << r[i] << \" \" << c[i] << \" \";\n        cout << (op[i] == 0 ? \"write\" : \"erase\") << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint W[100][100];\nint E[100][100];\nchar C[100][100];\nint INF = 1e9;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Weight capacity;\n \n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n  Edge(int src, int dst, Weight capacity, Weight weight) : \n    src(src), dst(dst), capacity(capacity), weight(weight){ }\n  Edge(int src, int dst) :\n    src(src), dst(dst){weight=1;}\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\nset< pair<int,int> > er;\nset< pair<int,int> > ad;\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\npair<Weight, Weight> minimumCostFlow(Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  REP(u,n) FOR(e,g[u]) {\n    capacity[e->src][e->dst] += e->capacity;\n    cost[e->src][e->dst] += e->weight;\n  }\n  pair<Weight, Weight> total; // (cost, flow)\n  vector<Weight> h(n,INF);\n  h[s] = 0;\n  for(int k = 0 ; k <= g.size() ; k++){\n\t  int flag = 0;\n\t  for(int i = 0 ; i < g.size() ; i++){\n\t\tfor( auto &e : g[i] ){\n\t\t\tif( e.capacity == 0 ) continue;\n\t\t\tif( h[e.dst] > h[e.src]+e.weight ){\n\t\t\t\th[e.dst] = h[e.src]+e.weight;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t  }\n\t  if(!flag) break;\n  }\n  for (Weight F = INF; F > 0; ) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.cost > f.cost\"\n    for (Q.push(Edge(-2, s)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      FOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n        if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n          d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n          Q.push( Edge(f->src, f->dst, 0, d[f->dst]) );\n        }\n      }\n    }\n    if (p[t] == -1) break;\n\n    Weight f = F;\n    for (int u = t; u != s; u = p[u])\n      f = min(f, RESIDUE(p[u], u));\n    for (int u = t; u != s; u = p[u]) {\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u, n) h[u] += d[u];\n  }\n \tint M = (g.size()-2)/2;\n\tfor(int i = 0 ; i < M ; i++){\n\t\tfor(int j = M ; j < 2*M ; j++){\n\t\t  if( !flow[i][j] ) continue;\n\t\t  int cst = cost[i][j];\n\t\t  if( cst < 0 ){\n\t\t\ter.erase({i,j});\n\t\t  }else if( cst > 0 ){\n\t\t\tad.insert({i,j});\n\t\t  }\n\t\t}\n\t}\n  return total;\n}\n\n\nvoid addEdge(Graph &g,int a,int b,int cap,int cost){\n\tg[a].push_back(Edge(a,b,cap,cost));\n\tg[b].push_back(Edge(b,a,0,-cost));\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tcin >> W[i][j];\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tcin >> E[i][j];\n\t\t\t\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tcin >> C[i][j];\n\t\t\tif( C[i][j] == 'o' ){\n\t\t\t\tans += E[i][j];\n\t\t\t\ter.insert({i,n+j});\n\t\t\t}\n\t\t}\n\t}\n\tGraph g(2*n+2);\n\tint s = g.size()-1;\n\tint t = g.size()-2;\n\tfor(int i = 0 ; i < n ; i++){\n\t\taddEdge(g,s,i,1,0);\n\t\taddEdge(g,n+i,t,1,0);\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tif( C[i][j] == 'o' ){\n\t\t\t\taddEdge(g,i,n+j,1,-E[i][j]);\n\t\t\t}else{\n\t\t\t\taddEdge(g,i,n+j,1,W[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans+minimumCostFlow(g,s,t).first << endl;\n\tcout << ad.size()+er.size() << endl;\n\tfor( auto a : er ){\n\t\tcout << a.first+1 << \" \" << a.second-n+1 << \" erase\" << endl;\n\t}\n\tfor( auto a : ad ){\n\t\tcout << a.first+1 << \" \" << a.second-n+1 << \" write\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n\ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n     G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f, bool negative = false){\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 10000000;\n\n  if(negative){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n\n    bool update = true;\n\n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n        if(dist[v] == inf) continue;\n        for(int i = 0; i < (int)g[v].size(); i++){\n          E &e = g[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to]  = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update      = true;\n          }\n        }\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n      h[i] = dist[i];\n  }\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n        E &e = g[v][i];\n\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == inf){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint w[100][100];\nint e[100][100];\nint f[100][100];\nint c[100][100];\n\nint main(){\n  const int n = getInt();\n\n  REP(i,n) REP(j,n)\n    w[i][j] = getInt();\n  REP(i,n) REP(j,n)\n    e[i][j] = getInt();\n\n  REP(i,n){\n    char b[128]; scanf(\"%s\", b);\n    REP(j,n) f[i][j] = (b[j] == 'o' ? 1 : 0);\n  }\n\n  REP(i,n){\n    REP(j,n){\n      int cc = 0;\n\n      REP(k,n){\n        if(f[i][k]  && k != j) cc += e[i][k];\n        if(!f[i][k] && k == j) cc += w[i][k];\n      }\n\n      c[i][j] = cc;\n    }\n  }\n\n  Graph<CostEdge> g(2 + 2 * n);\n  const int start = 2 * n;\n  const int goal  = 2 * n + 1;\n\n  REP(i,n) REP(j,n){\n    g.addEdge(i, n + j, 1, c[i][j]);\n  }\n\n  REP(i,n){\n    g.addEdge(start, i, 1, 0);\n    g.addEdge(n + i, goal, 1, 0);\n  }\n\n  int cost = minCostFlow(g, start, goal, n);\n\n  printf(\"%d\\n\", cost);\n\n  vector<string> ans;\n  const Graph<CostEdge>::G &gg = g.getRowGraph();\n  REP(i,n){\n    int dst = -1;\n    REP(j,n){\n      if(gg[i][j].cap == 0){\n        dst = gg[i][j].to - n;\n      }\n    }\n\n    REP(j,n){\n      char buff[256];\n      if(f[i][j] && dst != j){\n        sprintf(buff, \"%d %d erase\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n      if(!f[i][j] && dst == j){\n        sprintf(buff, \"%d %d write\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans.size());\n  REP(i,ans.size())\n    printf(\"%s\\n\", ans[i].c_str());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n\n        MinCostFlow solver(N * N + 2);\n        int Source = N * N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    count++;\n                }\n            }\n        }\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 300\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint can[MAX_V][MAX_V]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j , 1, can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  int W[101][101],E[101][101];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>W[i][j];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>E[i][j];\n  \n  string mp[101];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  int sumW[101]={},sumH[101]={},sum=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]=='o'){\n\tsumW[i]+=E[i][j];\n\tsumH[j]+=E[i][j];\n\tsum+=E[i][j];\n      }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      can[i][j]=mp[i][j]=='o'? -E[i][j]:W[i][j];\n\n  cout<<sum+Biparite_Matching(n,n)<<endl;\n  int cnt=0;\n  ostringstream ans[10001],tmp;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++) {\n      int h=i,w=G[i][j].to-n,cap=G[i][j].cap;\n      if(cap<=0&&mp[h][w]=='.')ans[cnt++]<<h+1<<\" \"<<w+1<<\" write\"<<endl;\n      if(cap>0&&mp[h][w]=='o')ans[cnt++]<<h+1<<\" \"<<w+1<<\" erase\"<<endl;\n    }\n  cout<<cnt<<endl;\n  for(int i=0;i<cnt;i++)cout<<ans[i].str();  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct edge {\n    ll to, cap, cost, rev;\n};\n\n// dijkstra\nstruct Mincostflow {\n    vector<vector<edge>> G;\n    VL h, dist, prev, pree;\n    ll N;\n\n    Mincostflow(ll size) : N(size) { init(size); };\n\n    void init(ll size) {\n        G.resize(N);\n        prev.resize(N);\n        pree.resize(N);\n    }\n\n    void add_edge(ll from, ll to, ll cap, ll cost) {\n        G[from].push_back({to, cap, cost, (ll)G[to].size()});\n        G[to].push_back({from, 0, -cost, (ll)G[from].size() - 1});\n    }\n\n    ll min_cost_flow(ll s, ll t, ll f) {\n        ll res = 0;\n        h.assign(N, 0);\n        while(f > 0) {\n            PQG<PL> pq;\n            dist.assign(N, LINF);\n            dist[s] = 0;\n            pq.emplace(dist[s], s);\n            while(!pq.empty()) {\n                PL p = pq.top();\n                pq.pop();\n                ll v = p.se;\n                REP(i, G[v].size()) {\n                    edge &e = G[v][i];\n                    if(e.cap > 0 &&\n                       dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prev[e.to] = v;\n                        pree[e.to] = i;\n                        pq.emplace(dist[e.to], e.to);\n                    }\n                }\n            }\n            if(dist[t] == LINF) return -1;\n            REP(v, N) h[v] += dist[v];\n            ll d = f;\n            for(int v = t; v != s; v = prev[v]) {\n                d = min(d, G[prev[v]][pree[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prev[v]) {\n                edge &e = G[prev[v]][pree[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nll W[100][100];\nll E[100][100];\nstring F[100];\n\nstruct Ope {\n    ll r, c;\n    string ope;\n};\n\nsigned main() {\n    LCIN(n);\n    REP(i, n) REP(j, n) cin >> W[i][j];\n    REP(i, n) REP(j, n) cin >> E[i][j];\n    REP(i, n) cin >> F[i];\n    ll mi = 0, f = 0;\n    REP(i, n) REP(j, n) {\n        if(F[i][j] == 'o') {\n            mi = min(mi, -E[i][j]);\n            f += E[i][j];\n        }\n    }\n    Mincostflow mf(2 * n + 2);\n    REP(i, n) REP(j, n) {\n        if(F[i][j] == 'o') {\n            mf.add_edge(i, n + j, 1, -E[i][j] - mi);\n        } else {\n            mf.add_edge(i, n + j, 1, W[i][j] - mi);\n        }\n    }\n    REP(i, n) mf.add_edge(2 * n, i, 1, 0);\n    REP(i, n) mf.add_edge(n + i, 2 * n + 1, 1, 0);\n    f += mf.min_cost_flow(2 * n, 2 * n + 1, n);\n    f += mi * n;\n    ll cnt = 0;\n    vector<Ope> ans;\n    REP(i, n) REP(j, n) {\n        if((F[i][j] == 'o') == mf.G[i][j].cap) {\n            ans.push_back({i + 1, j + 1, F[i][j] == 'o' ? \"erase\" : \"write\"});\n            cnt++;\n        }\n    }\n    cout << f << \"\\n\";\n    cout << cnt << \"\\n\";\n    FOREACH(a, ans) cout << a.r << \" \" << a.c << \" \" << a.ope << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef int Capacity;\ntypedef int Cost;\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge; bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n    enum : int { MAX_V = 1000000 };\n\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n    }\n\n    int mcf(int s, int t, int f) {\n        int res = 0;\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n        static Cost h[MAX_V], dist[MAX_V];\n        static int prevv[MAX_V], preve[MAX_V];\n        rep(i,n)h[i] = 0;\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            rep(i,n) dist[i] = inf;\n            dist[s] = 0;\n            q.emplace(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.mcf(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\nconst int INF = 2147483647;\nconst long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight capacity;\n\tWeight cost;\n\tEdge(int src, int dst, Weight acap, Weight acost) :\n\t\tsrc(src), dst(dst), capacity(acap), cost(acost) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.cost > f.cost;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n\n//??°?????????????????§???????????????????????¨?????????\nMatrix m;\n//Graph &ag\n//????????§???????????????(u, v, capacity, cost) ??????????????????(u, v, 0, -cost) ???????????°????????????????????¶?????????????????§????´???°????????§???????????°???????????????\n//int s, int t\n//?????????????§??????¨?????????\n//?????????\n//?????¨??¨????????????????????????\npair<Weight, Weight> minimumCostFlow(const Graph &ag, int s, int t) {\n//check???????´???°??????????????£???????????????\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, 0, -ag[i][j].cost));\n\t\t\t}\n\t\t}\n\t}\n\tconst int n = g.size();\n\tMatrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) {\n\t\tcapacity[e->src][e->dst] += e->capacity;\n\t\tcost[e->src][e->dst] += e->cost;\n\t}\n\tpair<Weight, Weight> total; // (cost, flow)\n\tvector<Weight> h(n);\n\n\tfor (Weight F = INF; F > 0; ) { // residual flow\n\t\tvector<Weight> d(n, INF); d[s] = 0;\n\t\tvector<int> p(n, -1);\n\t\tpriority_queue<Edge> Q; // \"e < f\" <=> \"e.cost > f.cost\"\n\t\tfor (Q.push(Edge(-2, s, 0, 0)); !Q.empty(); ) {\n\t\t\tEdge e = Q.top(); Q.pop();\n\t\t\tif (p[e.dst] != -1) continue;\n\t\t\tp[e.dst] = e.src;\n\t\t\tFOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n\t\t\t\tif (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n\t\t\t\t\td[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n\t\t\t\t\tQ.push(Edge(f->src, f->dst, 0, d[f->dst]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p[t] == -1) break;\n\n\t\tWeight f = F;\n\t\tfor (int u = t; u != s; u = p[u])\n\t\t\tf = min(f, RESIDUE(p[u], u));\n\t\tfor (int u = t; u != s; u = p[u]) {\n\t\t\ttotal.first += f * cost[p[u]][u];\n\t\t\tflow[p[u]][u] += f; flow[u][p[u]] -= f;\n\t\t}\n\t\tF -= f;\n\t\ttotal.second += f;\n\t\tREP(u, n) h[u] += d[u];\n\t}\n\tm = flow;\n\treturn total;\n}\nstruct operate {\n\tint y;\n\tint x;\n\tbool erase;\n};\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int>>wcosts(N, vector<int>(N));\n\tvector<vector<int>>ecosts(N, vector<int>(N));\n\tvector<vector<int>>circle(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tint wcost; cin >> wcost;\n\t\t\twcosts[i][j] = wcost;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tint ecost; cin >> ecost;\n\t\t\tecosts[i][j] = ecost;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (st[j] == 'o')circle[i][j] = 1;\n\t\t}\n\t}\n\tGraph g(2 * N + 2);\n\tconst int Start = 0;\n\tconst int From = 1;\n\tconst int To = From + N;\n\tconst int Goal = To + N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tg[Start].push_back(Edge(Start, From + i, 1, 0));\n\t}\n\tfor (int f = 0; f < N; ++f) {\n\t\tfor (int t = 0; t < N; ++t) {\n\t\t\tint ncost = 0;\n\t\t\tfor (int y = 0; y < N; ++y) {\n\t\t\t\tif (y == t&&!circle[f][y])ncost += wcosts[f][y];\n\t\t\t\telse if (y != t&&circle[f][y])ncost += ecosts[f][y];\n\t\t\t}\n\t\t\tg[From + f].push_back(Edge(From + f, To + t, 1, ncost));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tg[To+i].push_back(Edge(To + i, Goal, 1, 0));\n\t}\n\tconst pair<Weight, Weight>ans=minimumCostFlow(g, Start, Goal);\n\tvector<int>fincircles;\n\tfor (int f = 0; f < N; ++f) {\n\t\tfor (int t = 0; t < N; ++t) {\n\t\t\tif (m[From + f][To + t]) {\n\t\t\t\tfincircles.push_back(t);\n\t\t\t}\n\t\t}\n\t}\n\tvector<operate>ops;\n\tfor (int f = 0; f < N; ++f) {\n\t\tfor (int t = 0; t < N; ++t) {\n\t\t\tif (circle[f][t]) {\n\t\t\t\tif (fincircles[f] != t)ops.push_back(operate{ t + 1,f + 1,true });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (fincircles[f] == t)ops.push_back(operate{ t + 1,f + 1,false });\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans.first << endl;\n\tcout << ops.size() << endl;\n\tfor (auto o : ops) {\n\t\tcout << o.x << \" \" << o.y << \" \";\n\t\tif (o.erase)cout << \"erase\" << endl;\n\t\telse cout << \"write\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cap,cost,rev;};\nvector<edge> G[100010];\nbool used[100010];\nint h[100010],dist[100010],prevv[100010],preve[100010];\nint V;//Vは頂点数\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back( (edge){to,cap,cost,(ll)G[to].size()} );\n\t\tG[to].push_back( (edge){from,0,-cost,(ll)G[from].size()-1 });\n}\n\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue <P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,inf);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile( !que.empty() ){\n\t\t\tP p=que.top();que.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t}\n\t}\n\tif(dist[t]==inf) return -1;\n\tfor(int v=0;v<V;v++)h[v] += dist[v];\n\tint d=f;\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t}\n\tf -= d;\n\tres += d*h[t];\n\tfor(int v=t; v!=s;v=prevv[v]){\n\t\tedge &e =G[prevv[v]][preve[v]];\n\t\te.cap -=d;\n\t\tG[v][e.rev].cap +=d;\n\t}\n}\nreturn res;\n}\nvector<pa> ans;\nint w[100][110],e[110][110],a[110][110];\n   signed main(){\nint n;\n   \tcin>>n;\nV=300;\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>w[i][j];\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>e[i][j];\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \tstring s;\n   \t\tcin>>s;\n   \t\t\n   \t\ts=\"q\"+s;\n   \t\tfor(int j=1;j<=n;j++){\n   \t\t\tif(s[j]=='o')a[i][j]=1;\n   \t\t\telse a[i][j]=0;\n   \t\t}\n   \t\n   \t\n   \t}\n   \t\n   \t\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n   \tint gosa=0;\n   \t\tfor(int k=1;k<=n;k++)if(k!=j){\n   \t\t\tif(a[i][k]==1)gosa+=e[i][k];\n   \t\t}\n   \t\tif(a[i][j]==0) gosa+=w[i][j];\n   \t\t\n   \t\tadd_edge(i,n+j,1 ,gosa);\n   \t\n   \t}\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \t\tadd_edge(0,i,1,0);\n   \t\tadd_edge(n+i,2*n+1,1,0);\n   \t}\n   \t\n   \tcout<<min_cost_flow(0,2*n+1,n)<<endl;\n   \tfor(int i=1;i<n+1;i++)for(auto e:G[i]){\n   \t\tif(e.to==0 ) continue;\n   \t\tif(e.cap==1 && a[i][e.to-n]==1) ans.pb(mp(i,e.to));\n   \t\tif(e.cap==0 && a[i][e.to-n]==0) ans.pb(mp(i,e.to));\n   \t}\n   \tcout<<ans.size()<<endl;\n   \tfor(auto v:ans){\n   \t\tif(a[v.first][v.second-n])cout<<v.first<<\" \" <<v.second-n<<\" erase\"<<endl;\n   \t\telse cout<<v.first<<\" \" <<v.second-n<<\" write\"<<endl;\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 300\n#define INF 1e9\nusing namespace std;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;\n\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint can[MAX_V][MAX_V];\nint Biparite_Matching(int N,int K){\n   int s = N+K, t = s+1;\n   for(int i=0; i<N; i++) add_edge(s,i,1,0);\n   for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n\n   for(int i=0;i<N;i++)\n     for(int j=0;j<K;j++)add_edge(i, N+j , 1, can[i][j]);\n   V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int W[101][101],E[101][101];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>W[i][j];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>E[i][j];\n  \n  string mp[101];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  int sumW[101]={},sumH[101]={},sum=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]=='o'){\n\tsumW[i]+=E[i][j];\n\tsumH[j]+=E[i][j];\n\tsum+=E[i][j];\n      }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)can[i][j]=mp[i][j]=='o'? -E[i][j]:W[i][j];\n\n  cout<<sum+Biparite_Matching(n,n)<<endl;\n  int cnt=0;\n  ostringstream ans[10001],tmp;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++) {\n      int h=i,w=G[i][j].to-n,cap=G[i][j].cap;\n      if(cap<=0&&mp[h][w]=='.')ans[cnt++]<<h+1<<\" \"<<w+1<<\" write\";\n      if(cap> 0&&mp[h][w]=='o')ans[cnt++]<<h+1<<\" \"<<w+1<<\" erase\";\n    }\n  cout<<cnt<<endl;\n  for(int i=0;i<cnt;i++)cout<<ans[i].str()<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\ntypedef pair<int, int> P;\n\nclass edge {\npublic:\n\tbool is_rev;\n\tint to, cap, cost, rev;\n\tedge(int t, int ca, int co, int r, bool i):to(t), cap(ca), cost(co), rev(r), is_rev(i){};\n};\n\nstruct operation {\n\tint x, y;\n\tstring name;\n\toperation(int x, int y, string n):x(x), y(y), name(n){}\n};\n\nostream& operator<<(ostream& os, const operation& o) {\n\tos << o.x << \" \" << o.y << \" \" << o.name;\n\treturn os;\n}\n\nvector<vector<edge> > G;\n\nvoid init(int n) {\n\tG.clear();\n\tG.resize(n);\n}\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size(), true));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1, false));\n}\n\nint min_cost_flow(int s, int t, int f) {\n\tint n = G.size();\n\tint res = 0;\n\tvector<int> h(n, 0), prevv(n), preve(n);\n\twhile(f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<int> dist(n, INT_MAX);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile(!que.empty()) {\n\t\t\tP p = que.top();\n\t\t\tque.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first)\n\t\t\t\tcontinue;\n\n\t\t\tfor(int i = 0; i < G[v].size(); ++i) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INT_MAX)\n\t\t\treturn -1;\n\n\t\tfor(int v = 0; v < n; ++v)\n\t\t\th[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v])\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int> > w(n, vector<int>(n)), e(n, vector<int>(n));\n\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tcin >> w[i][j];\n\n\tfor(int i = 0; i < n; ++i)\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tcin >> e[i][j];\n\n\tvector<string> board(n);\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> board[i];\n\n\tinit(n + n + 2);\n\tconst int from = n + n, to = n + n + 1;\n\tfor(int i = 0; i < n; ++i) {\n\t\tadd_edge(from, i, 1, 0);\n\t\tadd_edge(n + i, to, 1, 0);\n\t}\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint sum = 0;\n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tif(board[i][j] == 'o')\n\t\t\t\tsum += e[i][j];\n\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tconst int cost = sum + (board[i][j] == 'o' ? -e[i][j] : w[i][j]);\n\t\t\tadd_edge(i, j + n, 1, cost);\n\t\t}\n\t}\n\n\tcout << min_cost_flow(from, to, n) << endl;\n\n\tvector<operation> ans;\n\tfor(int i = 0; i < n; ++i) {\n\t\tint pos = -1;\n\t\tfor(int j = 0; j < (int)G[i].size(); ++j) {\n\t\t\tif(G[i][j].cap == 0) {\n\t\t\t\tpos = G[i][j].to - n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(board[i][pos] == '.')\n\t\t\tans.push_back(operation(i + 1, pos + 1, \"write\"));\n\n\t\tfor(int j  = 0; j < n; ++j)\n\t\t\tif(j != pos && board[i][j] == 'o')\n\t\t\t\tans.push_back(operation(i + 1, j + 1, \"erase\"));\n\t}\n\n\tcout << ans.size() << endl;\n\tfor(int i = 0; i < (int)ans.size(); ++i)\n\t\tcout << ans[i] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 300\n#define INF 1e9\nusing namespace std;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;\n\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint can[MAX_V][MAX_V];\nint Biparite_Matching(int N,int K){\n   int s = N+K, t = s+1;\n   for(int i=0; i<N; i++) add_edge(s,i,1,0);\n   for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n\n   for(int i=0;i<N;i++)\n     for(int j=0;j<K;j++)add_edge(i, N+j , 1, can[i][j]);\n   V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\nint main(){\n  int n;\n  cin>>n;\n  int W[101][101],E[101][101];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>W[i][j];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>E[i][j];\n  \n  string mp[101];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  int sumW[101]={},sumH[101]={},sum=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]=='o'){\n\tsumW[i]+=E[i][j];\n\tsumH[j]+=E[i][j];\n\tsum+=E[i][j];\n      }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)can[i][j]=mp[i][j]=='o'? -E[i][j]:W[i][j];\n\n  cout<<sum+Biparite_Matching(n,n)<<endl;\n  int cnt=0;\n  ostringstream ans[10001],tmp;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++) {\n      int h=i,w=G[i][j].to-n,cap=G[i][j].cap;\n      if(cap<=0&&mp[h][w]=='.')ans[cnt++]<<h+1<<\" \"<<w+1<<\" write\";\n      if(cap> 0&&mp[h][w]=='o')ans[cnt++]<<h+1<<\" \"<<w+1<<\" erase\";\n    }\n  cout<<cnt<<endl;\n  for(int i=0;i<cnt;i++)cout<<ans[i].str()<<endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n// checked by  http://codeforces.com/contest/237/submission/4710047\n//                  http://codeforces.com/contest/277/submission/4710018\n\nnamespace MinCostFlows{\ntypedef int Flow;typedef ll Cost;\nconst Flow FINF=1<<30;\nconst Cost CINF=1<<30,EPS =0;\nclass MinCostFlow{\nprivate:\n    bool EQ(Cost a,Cost b){return abs(a-b)<EPS;}\n    int V;\n    struct Edge{\n        int from,to;Flow cap;Cost cost;int rev;\n        Edge(int from,int to,Flow cap,Cost cost,int rev):from(from),to(to),cap(cap),cost(cost),rev(rev){}\n    };\n    using  Graph=vector<vector<Edge>>;\n    vector<Cost> dist,h;vector<int> prevv,preve;\n    using pci=pair<Cost,int>;\npublic:\n    Graph G;\n    \n    MinCostFlow(int V):V(V){\n        G=Graph(V);\n        dist=vector<Cost>(V);h=vector<Cost>(V);\n        prevv=vector<int>(V);preve=vector<int>(V);\n    }\n    void add_edge(int from,int to,Flow cap,Cost cost){\n        G[from].push_back(Edge(from,to,cap,cost,G[to].size()));\n        G[to].push_back(Edge(to,from,0,-cost,G[from].size()-1));\n    }\n    // void clearGraph(){\n    //     REP(i,V)G[i].clear();\n    // }\n\n    //primal Dual O(V^2*U*C)\n    pair<Cost,Flow> mincostflow(int s,int t,Flow f){\n        pair<Cost,Flow> res(0,0);\n        fill(ALL(h),0);\n        while(f > 0){\n            fill(ALL(dist),FINF);dist[s] = 0;\n\n            priority_queue<pci,vector<pci>,greater<pci> > que;\n            que.push(pci(0,s));\n            while(!que.empty()){\n                pci p = que.top();que.pop();\n                int v = p.second;\n                if(dist[v] < p.first)continue;\n                REP(i,(int)G[v].size()){\n                    Edge &e = G[v][i];\n                    if(e.cap<=0)continue;\n                    if(dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;preve[e.to] = i;\n                        que.push(pci(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(EQ(dist[t],FINF))break;\n\n            REP(i,V)h[i] += dist[i];\n            Flow d = f;\n            for(int v = t; v != s; v = prevv[v])d = min(d,G[prevv[v]][preve[v]].cap);\n            f -= d;res.first += d*h[t];res.second+=d;\n\n            for(int v = t; v != s; v = prevv[v]){\n                Edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n}\nusing namespace MinCostFlows;\n\n\nclass Main{\npublic:\n\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tMinCostFlow mcf(n+n+2);\n\t\tint S=n+n,T=n+n+1;\n\n\t\tvector<vector<int>> ws(n,vector<int>(n));\n\t\tREP(y,n)REP(x,n)cin >> ws[y][x];\n\t\tvector<vector<int>> es(n,vector<int>(n));\n\t\tREP(y,n)REP(x,n)cin >> es[y][x];\n\n\t\tvector<string> board(n);\n\t\tREP(i,n)cin >> board[i];\n\n\t\tREP(y,n)mcf.add_edge(S,y,1,0);\n\t\tREP(x,n)mcf.add_edge(n+x,T,1,0);\n\t\tREP(y,n)REP(x,n){\n\t\t\tint c=0;\n\t\t\t//cost 差分\n\t\t\tif(board[y][x]=='.')c+=2*ws[y][x];\n\t\t\tREP(y1,n)if(y!=y1)if(board[y1][x]=='o')c+=es[y1][x];\n\t\t\tREP(x1,n)if(x!=x1)if(board[y][x1]=='o')c+=es[y][x1];\n\t\t\tmcf.add_edge(y,n+x,1,c);\n\t\t}\n\n\t\tCost c=mcf.mincostflow(S,T,n).first/2;\n\n\t\tint num=0;\n\t\tvector<vector<int> > wboard(n,vector<int>(n));\n\t\tvector<vector<int> > eboard(n,vector<int>(n));\n\t\t\n\t\tREP(i,n+n+2){\n\t\t\tEACH(e,mcf.G[i]){\n\t\t\t\tif(IN(0,e->from,n) && IN(n,e->to,n+n)){\n\t\t\t\t\tif(e->cap==0 && board[e->from][e->to-n]=='.'){\n\t\t\t\t\t\tnum++;wboard[e->from][e->to-n]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(e->cap==1 && board[e->from][e->to-n]=='o'){\n\t\t\t\t\t\tnum++;eboard[e->from][e->to-n]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c <<endl;\n\t\tcout << num <<endl;\n\t\tREP(y, n)REP(x,n)if(wboard[y][x]){\n\t\t\tcout <<y+1 <<\" \"<< x+1 << \" write\" << endl; \n\t\t}\n\t\tREP(y, n)REP(x,n)if(eboard[y][x]){\n\t\t\tcout <<y+1 <<\" \"<< x+1 << \" erase\" << endl; \n\t\t}\n\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\n\nint G[MAX_V][MAX_V];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V][MAX_V] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            int dist2 = 0;\n            int flag;\n            for (int i = 0; i < l+1; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist2)){\n                    v = i;\n                    dist2 = dist[i];\n                    flag = true;\n                }\n            }\n            for (int i = 0; i < r+1; i++) {\n                if (!used[i+l+1] && (v == -1 || dist[i+l+1] < dist2)){\n                    v = i;\n                    dist2 = dist[i+l+1];\n                    flag = false;\n                }\n            }\n            if (v == -1) break;\n            if (flag) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && dist[i+l+1] > dist[v] + G[v][i] + h[v] - h[i+l+1]) {\n\t\t\t\t\t\tdist[i+l+1] = dist[v] + G[v][i] + h[v] - h[i+l+1];\n\t\t\t\t\t\tprevv[i+l+1] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v+l+1] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v] && dist[i] > dist[v+l+1] - G[i][v] + h[v+l+1] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v+l+1] - G[i][v] + h[v+l+1] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevv[v] : prevv[v+l+1], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevv[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n  int src, dst, capacity, cost, rev;\n  Edge(int src, int dst, int capacity, int cost)\n    : src(src), dst(dst), capacity(capacity), cost(cost) {}\n  Edge(int src, int dst, int capacity, int cost, int rev)\n    : src(src), dst(dst), capacity(capacity), cost(cost), rev(rev) {}\n};\nbool operator<(const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<int> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, int cost, int cap) {\n  g[s].push_back(Edge(s,d,cap,cost));\n  g[d].push_back(Edge(d,s,0,-cost));\n  //cout<<s<<\" \"<<d<<\" \"<<cost<<\" \"<<cap<<endl;\n}\n\n#define RESIDUE(u,v) (capacity[u][v]-flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n\nint sum;\npair<int, int> minimumCostFlow(Graph &g, int s, int t) {\n  const int n = g.size();\n  const int inf = 1<<29;\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  for (int u=0; u<n; ++u) {\n    for (Edges::iterator e = g[u].begin(); e != g[u].end(); ++e) {\n      capacity[e->src][e->dst] += e->capacity;\n      cost[e->src][e->dst] += e->cost;\n    }\n  }\n\n  pair<int,int> total = make_pair(0,0);\n  vector<int> h(n, inf);\n  h[s] = 0;\n  for (int k=0; k<n; ++k)\n    for (int i=0; i<n; ++i)\n      for (Edges::iterator e=g[i].begin(); e!=g[i].end(); ++e)\n        if (capacity[e->src][e->dst])\n          h[e->dst] = min(h[e->dst], h[e->src] + cost[e->src][e->dst]);\n\n  for (int F = inf; F > 0; ) {\n    vector<int> d(n, inf); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q;\n    for (Q.push(Edge(-2,s,0,0)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      for (Edges::iterator f=g[e.dst].begin(); f != g[e.dst].end(); ++f) {\n        if (RESIDUE(f->src, f->dst) > 0) {\n          if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n            d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n            Q.push(Edge(f->src, f->dst, 0, d[f->dst]));\n          }\n        }\n      }\n    }\n\n    if (p[t] == -1) break;\n    int f = F;\n    for (int u=t; u!=s; u=p[u]) f = min(f, RESIDUE(p[u], u));\n    for (int u=t; u!=s; u=p[u]) {\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    for(int u=0; u<n; ++u) if (h[u] != inf) h[u] += d[u];\n  }\n  cout<<total.first+sum<<endl;\n  int cnt = 0;\n  int nn = (n-2)/2;\n  vector<pair<int,pair<int,int> > > v;\n  for (int i=0; i<nn; ++i) {\n    for (int j=0; j<nn; ++j) {\n      if (flow[i][j+nn] > 0 && cost[i][j+nn] > 0) {\n        cnt++;\n        v.push_back(make_pair(1, make_pair(i+1,j+1)));\n      }\n      if (flow[i][j+nn] == 0 && cost[i][j+nn] < 0) {\n        cnt++;\n        v.push_back(make_pair(0, make_pair(i+1,j+1)));\n      }\n    }\n  }\n  cout<<cnt<<endl;\n  for (int i=0; i<v.size(); ++i) {\n    cout<<v[i].second.second<<\" \"<<v[i].second.first<<\" \";\n    if (v[i].first) cout<<\"write\"<<endl;\n    else cout<<\"erase\"<<endl;\n  }\n  return total;\n}\n\nint w[101][101], e[101][101];\nstring f[101];\n\nint main() {\n  int n;\n  while(cin>>n) {\n    for (int i=0; i<n; ++i) for(int j=0; j<n; ++j) cin>>w[i][j];\n    for (int i=0; i<n; ++i) for(int j=0; j<n; ++j) cin>>e[i][j];\n    for (int i=0; i<n; ++i) cin>>f[i];\n    Graph g(n*2+2);\n    sum = 0;\n    for (int i=0; i<n; ++i) add_edge(g, n*2, i, 0, 1);\n    for (int i=0; i<n; ++i) add_edge(g, i+n, n*2+1, 0, 1);\n    for (int x=0; x<n; ++x) {\n      for (int y=0; y<n; ++y) {\n        if (f[y][x] == 'o') {\n          add_edge(g, x, y+n, -e[y][x], 1);\n          sum += e[y][x];\n        } else {\n          add_edge(g, x, y+n, w[y][x], 1);\n        }\n      }\n    }\n\n    pair<int,int> ans = minimumCostFlow(g, n*2, n*2+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.first);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nstruct edge { int to, cap, rev, cost,mf; };\n\nconstexpr int MAX_V = 2000;\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap,(int) G[to].size(),cost,cap });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,cap });\n}\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tint f;\n\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\ntypedef pair<int, int> P;\nint V=MAX_V;\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, numeric_limits<int>::max());\n\t\tdist[s] = 0;\n\t\tque.push({ 0,s });\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<vi> w(n, vi(n, 0)),e(w);\n\tvector<string> f(n);\n\trep(i, n)rep(j, n)cin >> w[i][j];\n\trep(i, n)rep(j, n)cin >> e[i][j];\n\trep(i, n) cin >> f[i];\n\tvi a[2] = { vi(n),vi(n) };\n\tint flow = n;\n\tint offset = 0;\n\trep(i, n) {\n\t\tadd_edge(2 * n, i, 1);\n\t\tadd_edge(n + i, 2 * n + 1,  1);\n\t\trep(j, n) {\n\t\t\tif (f[i][j] == '.') {\n\t\t\t\tadd_edge(i, n + j, 1, w[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(n+j, i, 1, e[i][j]);\n\t\t\t\toffset += e[i][j];\n\t\t\t\ta[0][i]++; a[1][j]++;\n\t\t\t\tflow++;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (a[0][i] > 0)add_edge(i, 2*n+1, a[0][i]);\n\t\tif (a[1][i] > 0)add_edge(2*n, n+i, a[1][i]);\n\t}\n\tV = 2 * n + 2;\n\tcout << min_cost_flow(2 * n, 2 * n + 1, flow) << endl;\n\tint cnt = 0;\n\trep(i, n) {\n\t\tfor (auto& x : G[i]) {\n\t\t\tif (!x.cap&&x.to >= n&&x.to < 2 * n&&f[i][x.to - n] == '.')cnt++;\n\t\t\telse if (x.cap&&x.to >= n&&x.to<2 * n && (f[i][x.to - n] != '.'))cnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\trep(i, n) {\n\t\tfor (auto& x : G[i]) {\n\t\t\tif (!x.cap&&x.to >= n&&x.to<2 * n&&f[i][x.to - n] == '.')cout << i + 1 << \" \" << x.to - n + 1 << \"write\" << endl;\n\t\t\telse if (x.cap&&x.to >= n&&x.to<2 * n && (f[i][x.to - n] != '.'))cout << i + 1 << \" \" << x.to - n + 1 << \"erase\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nstruct edge{\n\tint to,cap,cost,rev;\n};\n\nclass Network{\n\tprivate:\n\tint V;\n\tvi h,d,pv,pe;\n\tpublic:\n\tvector<vector<edge> > g;\n\tNetwork(int v){\n\t\tV=v;\n\t\tg=vector<vector<edge> >(v);\n\t}\n\tvoid add_edge(int s,int t,int cap,int cost){\n\t\tg[s].push_back(edge{t,cap,cost,(int)g[t].size()});\n\t\tg[t].push_back(edge{s,0,-cost,(int)g[s].size()-1});\n\t}\n\tint min_cost_flow(int s,int t,int f){\n\t\tint res=0;\n\t\th=pv=pe=vi(V);\n\t\twhile(f>0){\n\t\t\tpriority_queue<P> q;\n\t\t\td=vi(V,inf);\n\t\t\td[s]=0;\n\t\t\tq.push({0,s});\n\t\t\twhile(!q.empty()){\n\t\t\t\tP p=q.top();\n\t\t\t\tq.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(d[v]<-p.first) continue;\n\t\t\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\t\t\tedge &e=g[v][i];\n\t\t\t\t\tif(e.cap>0&&d[e.to]>d[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\td[e.to]=d[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tpv[e.to]=v;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t\tq.push({-d[e.to],e.to});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==inf) return -1;\n\t\t\tfor(int i=0;i<V;i++) h[i]+=d[i];\n\t\t\tint D=f;\n\t\t\tfor(int i=t;i!=s;i=pv[i]) D=min(D,g[pv[i]][pe[i]].cap);\n\t\t\tf-=D;\n\t\t\tres+=D*h[t];\n\t\t\tfor(int i=t;i!=s;i=pv[i]){\n\t\t\t\tedge &e=g[pv[i]][pe[i]];\n\t\t\t\te.cap-=D;\n\t\t\t\tg[i][e.rev].cap+=D;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n;\nvvi a,b;\n\nint main(){\n\tcin>>n;\n\tNetwork nt(2*n+2);\n\ta=b=vvi(n,vi(n));\n\tint res=0;\n\tvvi d(n,vi(n));\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) cin>>a[i][j];\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) cin>>b[i][j];\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='.') nt.add_edge(i+1,n+j+1,1,a[i][j]);\n\t\telse{\n\t\t\tres+=b[i][j];\n\t\t\td[i][j]=-1;\n\t\t\tnt.add_edge(i+1,n+j+1,1,-b[i][j]);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) nt.add_edge(0,i+1,1,0);\n\tfor(int i=0;i<n;i++) nt.add_edge(n+i+1,2*n+1,1,0);\n\tcout<<res+nt.min_cost_flow(0,2*n+1,n)<<endl;\n\tint cnt=0;\n\tvi x,y;\n\tvs s;\n\tfor(int i=1;i<=n;i++) for(int j=0;j<nt.g[i].size();j++){\n\t\tedge &e=nt.g[i][j];\n\t\tif(e.to){\n\t\t\tint tmp=e.to-n-1,v=d[i-1][tmp];\n\t\t\tif(!e.cap){\n\t\t\t\tif(!v) v=1;\n\t\t\t\tif(v==-1) v=0;\n\t\t\t}\n\t\t\tif(v!=0){\n\t\t\t\tcnt++;\n\t\t\t\tx.push_back(i);\n\t\t\t\ty.push_back(tmp+1);\n\t\t\t\tif(v==1) s.push_back(\"write\");\n\t\t\t\telse s.push_back(\"erase\");\n\t\t\t}\n\t\t}\n\t}\n\tcout<<cnt<<endl;\n\tfor(int i=0;i<cnt;i++) cout<<x[i]<<' '<<y[i]<<' '<<s[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n// checked by  http://codeforces.com/contest/237/submission/4710047\n//                  http://codeforces.com/contest/277/submission/4710018\n\nnamespace MinCostFlows{\ntypedef int Flow;typedef ll Cost;\nconst Flow FINF=1<<30;\nconst Cost CINF=1<<30,EPS =0;\nclass MinCostFlow{\nprivate:\n    bool EQ(Cost a,Cost b){return abs(a-b)<EPS;}\n    int V;\n    struct Edge{\n        int from,to;Flow cap;Cost cost;int rev;\n        Edge(int from,int to,Flow cap,Cost cost,int rev):from(from),to(to),cap(cap),cost(cost),rev(rev){}\n    };\n    typedef vector<vector<Edge>> Graph;\n    vector<Cost> dist,h;vector<int> prevv,preve;\n    typedef pair<Cost,int> pci;\npublic:\n    Graph G;\n    \n    MinCostFlow(int V):V(V){\n        G=Graph(V);\n        dist=vector<Cost>(V);h=vector<Cost>(V);\n        prevv=vector<int>(V);preve=vector<int>(V);\n    }\n    void add_edge(int from,int to,Flow cap,Cost cost){\n        G[from].push_back(Edge(from,to,cap,cost,G[to].size()));\n        G[to].push_back(Edge(to,from,0,-cost,G[from].size()-1));\n    }\n    // void clearGraph(){\n    //     REP(i,V)G[i].clear();\n    // }\n\n    //primal Dual O(V^2*U*C)\n    pair<Cost,Flow> mincostflow(int s,int t,Flow f){\n        pair<Cost,Flow> res(0,0);\n        fill(ALL(h),0);\n        while(f > 0){\n            fill(ALL(dist),FINF);dist[s] = 0;\n\n            priority_queue<pci,vector<pci>,greater<pci> > que;\n            que.push(pci(0,s));\n            while(!que.empty()){\n                pci p = que.top();que.pop();\n                int v = p.second;\n                if(dist[v] < p.first)continue;\n                REP(i,(int)G[v].size()){\n                    Edge &e = G[v][i];\n                    if(e.cap<=0)continue;\n                    if(dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;preve[e.to] = i;\n                        que.push(pci(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(EQ(dist[t],FINF))break;\n\n            REP(i,V)h[i] += dist[i];\n            Flow d = f;\n            for(int v = t; v != s; v = prevv[v])d = min(d,G[prevv[v]][preve[v]].cap);\n            f -= d;res.first += d*h[t];res.second+=d;\n\n            for(int v = t; v != s; v = prevv[v]){\n                Edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n}\nusing namespace MinCostFlows;\n\n\nclass Main{\npublic:\n\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tMinCostFlow mcf(n+n+2);\n\t\tint S=n+n,T=n+n+1;\n\n\t\tvector<vector<int>> ws(n,vector<int>(n));\n\t\tREP(y,n)REP(x,n)cin >> ws[y][x];\n\t\tvector<vector<int>> es(n,vector<int>(n));\n\t\tREP(y,n)REP(x,n)cin >> es[y][x];\n\n\t\tvector<string> board(n);\n\t\tREP(i,n)cin >> board[i];\n\n\t\tREP(y,n)mcf.add_edge(S,y,1,0);\n\t\tREP(x,n)mcf.add_edge(n+x,T,1,0);\n\t\tREP(y,n)REP(x,n){\n\t\t\tint c=0;\n\t\t\t//cost 差分\n\t\t\tif(board[y][x]=='.')c+=2*ws[y][x];\n\t\t\tREP(y1,n)if(y!=y1)if(board[y1][x]=='o')c+=es[y1][x];\n\t\t\tREP(x1,n)if(x!=x1)if(board[y][x1]=='o')c+=es[y][x1];\n\t\t\tmcf.add_edge(y,n+x,1,c);\n\t\t}\n\n\t\tCost c=mcf.mincostflow(S,T,n).first/2;\n\n\t\tint num=0;\n\t\tvector<vector<int> > wboard(n,vector<int>(n));\n\t\tvector<vector<int> > eboard(n,vector<int>(n));\n\t\t\n\t\tREP(i,n+n+2){\n\t\t\tEACH(e,mcf.G[i]){\n\t\t\t\tif(IN(0,e->from,n) && IN(n,e->to,n+n)){\n\t\t\t\t\tif(e->cap==0 && board[e->from][e->to-n]=='.'){\n\t\t\t\t\t\tnum++;wboard[e->from][e->to-n]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(e->cap==1 && board[e->from][e->to-n]=='o'){\n\t\t\t\t\t\tnum++;eboard[e->from][e->to-n]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c <<endl;\n\t\tcout << num <<endl;\n\t\tREP(y, n)REP(x,n)if(wboard[y][x]){\n\t\t\tcout <<y+1 <<\" \"<< x+1 << \" write\" << endl; \n\t\t}\n\t\tREP(y, n)REP(x,n)if(eboard[y][x]){\n\t\t\tcout <<y+1 <<\" \"<< x+1 << \" erase\" << endl; \n\t\t}\n\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 300\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint can[MAX_V][MAX_V]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n\n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j , 1, can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  int W[101][101],E[101][101];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>W[i][j];\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>E[i][j];\n  \n  string mp[101];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  int sumW[101]={},sumH[101]={};\n  int sum=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      if(mp[i][j]=='o') sumW[i]+=E[i][j],sum+=E[i][j];\n      if(mp[j][i]=='o') sumH[i]+=E[j][i];\n    }\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cost=sumH[j]+sumW[i];\n      if(mp[i][j]=='o') cost-=2*E[i][j];\n      if(mp[i][j]=='.') cost+=W[i][j];\n      can[i][j]=cost;\n      \n    }\n  int mincost=Biparite_Matching(n,n);\n  \n  bool used[101][101]={};\n  for(int i=0;i<n;i++) \n    for(int j=0;j<G[i].size();j++)\n      if(G[i][j].cap<=0) {\n\tsum-=E[i][G[i][j].to-n];\n\tused[i][G[i][j].to-n]=1;\n      }\n\n  cout<<mincost-sum<<endl;\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) \n      if(used[i][j]&&mp[i][j]=='.')cnt++;\n      else if(!used[i][j]&&mp[i][j]=='o')cnt++;\n\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) \n      if(used[i][j]&&mp[i][j]=='.')cout<<i+1<<\" \"<<j+1<<\" write\"<<endl;\n      else if(!used[i][j]&&mp[i][j]=='o')cout<<i+1<<\" \"<<j+1<<\" erase\"<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint W[100][100];\nint E[100][100];\nchar C[100][100];\nint INF = 1e9;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Weight capacity;\n \n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n  Edge(int src, int dst, Weight capacity, Weight weight) : \n    src(src), dst(dst), capacity(capacity), weight(weight){ }\n  Edge(int src, int dst) :\n    src(src), dst(dst){weight=1;}\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\nset< pair<int,int> > er;\nset< pair<int,int> > ad;\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\npair<Weight, Weight> minimumCostFlow(Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  REP(u,n) FOR(e,g[u]) {\n    capacity[e->src][e->dst] += e->capacity;\n    cost[e->src][e->dst] += e->weight;\n  }\n  pair<Weight, Weight> total; // (cost, flow)\n  vector<Weight> h(n,INF);\n  h[s] = 0;\n  for(int k = 0 ; k <= g.size() ; k++){\n\t  int flag = 0;\n\t  for(int i = 0 ; i < g.size() ; i++){\n\t\tfor( auto &e : g[i] ){\n\t\t\tif( e.capacity == 0 ) continue;\n\t\t\tif( h[e.dst] > h[e.src]+e.weight ){\n\t\t\t\th[e.dst] = h[e.src]+e.weight;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t  }\n\t  if(!flag) break;\n  }\n  for (Weight F = INF; F > 0; ) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.cost > f.cost\"\n    for (Q.push(Edge(-2, s)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      FOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n        if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n          d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n          Q.push( Edge(f->src, f->dst, 0, d[f->dst]) );\n        }\n      }\n    }\n    if (p[t] == -1) break;\n\n    Weight f = F;\n    for (int u = t; u != s; u = p[u])\n      f = min(f, RESIDUE(p[u], u));\n    for (int u = t; u != s; u = p[u]) {\n\t  if( cost[p[u]][u] < 0 ){\n\t\ter.erase({p[u],u});\n\t  }else if( cost[p[u]][u] > 0 ){\n\t\tad.insert({p[u],u});\n\t  }\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u, n) h[u] += d[u];\n  }\n  return total;\n}\n\n\nvoid addEdge(Graph &g,int a,int b,int cap,int cost){\n\tg[a].push_back(Edge(a,b,cap,cost));\n\tg[b].push_back(Edge(b,a,0,-cost));\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tcin >> W[i][j];\n\tfor(int i = 0 ; i < n ; i++)\n\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\tcin >> E[i][j];\n\t\t\t\n\tint ans = 0;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tcin >> C[i][j];\n\t\t\tif( C[i][j] == 'o' ){\n\t\t\t\tans += E[i][j];\n\t\t\t\ter.insert({i,n+j});\n\t\t\t}\n\t\t}\n\t}\n\tGraph g(2*n+2);\n\tint s = g.size()-1;\n\tint t = g.size()-2;\n\tfor(int i = 0 ; i < n ; i++){\n\t\taddEdge(g,s,i,1,0);\n\t\taddEdge(g,n+i,t,1,0);\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tif( C[i][j] == 'o' ){\n\t\t\t\taddEdge(g,i,n+j,1,-E[i][j]);\n\t\t\t}else{\n\t\t\t\taddEdge(g,i,n+j,1,W[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans+minimumCostFlow(g,s,t).first << endl;\n\tcout << ad.size()+er.size() << endl;\n\tfor( auto a : er ){\n\t\tcout << a.first+1 << \" \" << a.second-n+1 << \" erase\" << endl;\n\t}\n\tfor( auto a : ad ){\n\t\tcout << a.first+1 << \" \" << a.second-n+1 << \" write\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cap,cost,rev;};\nvector<edge> G[50010];\nbool used[50010];\nint h[50010],dist[50010],prevv[50010],preve[50010];\nint V;//Vは頂点数\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back( (edge){to,cap,cost,(ll)G[to].size()} );\n\t\tG[to].push_back( (edge){from,0,-cost,(ll)G[from].size()-1 });\n}\n\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue <P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,inf);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile( !que.empty() ){\n\t\t\tP p=que.top();que.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t}\n\t}\n\tif(dist[t]==inf) return -1;\n\tfor(int v=0;v<V;v++)h[v] += dist[v];\n\tint d=f;\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t}\n\tf -= d;\n\tres += d*h[t];\n\tfor(int v=t; v!=s;v=prevv[v]){\n\t\tedge &e =G[prevv[v]][preve[v]];\n\t\te.cap -=d;\n\t\tG[v][e.rev].cap +=d;\n\t}\n}\nreturn res;\n}\nvector<pa> ans;\nint w[100][110],e[110][110],a[110][110];\n   signed main(){\nint n;\n   \tcin>>n;\nV=300;\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>w[i][j];\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>e[i][j];\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \tstring s;\n   \t\tcin>>s;\n   \t\t\n   \t\ts=\"q\"+s;\n   \t\tfor(int j=1;j<=n;j++){\n   \t\t\tif(s[j]=='o')a[i][j]=1;\n   \t\t\telse a[i][j]=0;\n   \t\t}\n   \t\n   \t\n   \t}\n   \t\n   \t\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n   \tint gosa=0;\n   \t\tfor(int k=1;k<=n;k++)if(k!=j){\n   \t\t\tif(a[i][k]==1)gosa+=e[i][k];\n   \t\t}\n   \t\tif(a[i][j]==0) gosa+=w[i][j];\n   \t\t\n   \t\tadd_edge(i,n+j,1 ,gosa);\n   \t\n   \t}\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \t\tadd_edge(0,i,1,0);\n   \t\tadd_edge(n+i,2*n+1,1,0);\n   \t}\n   \t\n   \tcout<<min_cost_flow(0,2*n+1,n)<<endl;\n   \tfor(int i=1;i<n+1;i++)for(auto e:G[i]){\n   \t\tif(e.to==0 ) continue;\n   \t\tif(e.cap==1 && a[i][e.to-n]==1) ans.pb(mp(i,e.to));\n   \t\tif(e.cap==0 && a[i][e.to-n]==0) ans.pb(mp(i,e.to));\n   \t}\n   \tcout<<ans.size()<<endl;\n   \tfor(auto v:ans){\n   \t\tif(a[v.first][v.second-n])cout<<v.first<<\" \" <<v.second-n<<\" erase\"<<endl;\n   \t\telse cout<<v.first<<\" \" <<v.second-n<<\" write\"<<endl;\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef int Capacity;\ntypedef int Cost;\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge; bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n    enum : int { MAX_V = 1000000 };\n\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].push_back(Edge(dst, cap, cost, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, -cost, g[src].size() - 1, true));\n    }\n\n    int mcf(int s, int t, int f) {\n        int res = 0;\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n        static Cost h[MAX_V], dist[MAX_V];\n        static int prevv[MAX_V], preve[MAX_V];\n        rep(i,n)h[i] = 0;\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            rep(i,n) dist[i] = inf;\n            dist[s] = 0;\n            q.push(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.push(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.mcf(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    const int INF = INT_MAX / 2;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to, cap, cost;\n        Edge* rev;\n        Edge(int from, int to, int cap, int cost) : from(from), to(to), cap(cap), cost(cost) {}\n    };\n    vector<vector<Edge*>> G;\n\n    void addEdge(int from, int to, int cap, int cost) {\n        assert(from != to);\n        Edge* e = new Edge(from, to, cap, cost);\n        Edge* r = new Edge(to, from, 0, -cost);\n        e->rev = r;\n        r->rev = e;\n        G[from].push_back(e);\n        G[to].push_back(r);\n    }\n\n    int minCostFlow(int s, int t, int f) {\n        const int N = G.size();\n        int ret = 0;\n        vector<Edge*> prev(N, nullptr);\n        while (f > 0) {\n            // Bellman Ford\n            vector<int> D(N, INF);\n            D[s] = 0;\n            bool updated = true;\n            while (updated) {\n                updated = false;\n                for (int v = 0; v < N; v++) {\n                    if (D[v] == INF) continue;\n                    for (auto e : G[v]) {\n                        if (e->cap == 0) continue;\n                        int ncost = D[v] + e->cost;\n                        if (D[e->to] > ncost) {\n                            D[e->to] = ncost;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n\n            if (D[t] == INF) return -1; // ?°???¶?????¶????????????????????????s?????????t??????????????¨?????????????????????????????±?????????\n            int d = f;\n            for (Edge* p = prev[t]; p != nullptr; p = prev[p->from]) {\n                d = min(d, p->cap);\n            }\n\n            f -= d;\n            ret += d * D[t];\n            for (Edge* p = prev[t]; p != nullptr; p = prev[p->from]) {\n                p->cap -= d;\n                p->rev->cap += d;\n            }\n        }\n        return ret;\n    }\n    \n\n    int N;\n    vector<vector<int>> W, E;\n    vector<string> F;\n\n    void input() {\n        cin >> N;\n        W.resize(N, vector<int>(N, 0)); cin >> W;\n        E.resize(N, vector<int>(N, 0)); cin >> E;\n        F.resize(N); cin >> F;\n    }\n\n    void solve() {\n        G.clear(); G.resize(2 + 2 * N);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int cost = 0;\n                for (int k = 0; k < N; k++) {\n                    if (F[i][k] == 'o') {\n                        cost += (j == k ? 0 : E[i][k]);\n                    } else {\n                        cost += (j == k ? W[i][k] : 0);\n                    }\n                }\n                addEdge(1 + i, 1 + N + j, 1, cost);\n            }\n            addEdge(0, 1 + i, 1, 0);\n            addEdge(1 + N + i, 1 + 2 * N, 1, 0);\n        }\n        cout << minCostFlow(0, 1 + 2 * N, N) << endl;\n\n        vector<string> X(N, string(N, '.'));\n        for (int i = 1; i <= N; i++) {\n            for (auto e : G[i]) {\n                if (e->cap == 0) {\n                    X[e->from - 1][e->to - (N + 1)] = 'o';\n                }\n            }\n        }\n        int c = 0;\n        ostringstream os;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (F[i][j] == X[i][j]) continue;\n                c++;\n                os << i + 1 << \" \" << j + 1 << \" \" << (F[i][j] == 'o' ? \"erase\" : \"write\") << endl;\n            }\n        }\n        cout << os.str() << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\n\nstruct edge{\n  int to,cap,cost,rev;\n};\n\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint h[MAX_V]; // ポテンシャル\n\n// 直前の頂点と辺\nint prevv[MAX_V];\nint preve[MAX_V];\n\nconst int INF = 1000000000;\n// firstは最短距離、secondは頂点の番号\ntypedef pair<int,int> P;\n// fromからtoへむかう容量cap,コストcostの辺をグラフに追加する。\nvoid add_edge(int from,int to,int cap,int cost){\t\n  edge e;\n  e.to = to,e.cap = cap,e.cost = cost,e.rev = G[to].size();\n  G[from].push_back(e);\n\n  e.to = from,e.cap = 0,e.cost = -cost,e.rev = G[from].size()-1;\n  G[to].push_back(e);\n}\n\n// sからtへの流量fの最小費用流を求める\n// ながせない場合は-1を返す\nint min_cost_flow(int s,int t,int f,int V){\n  int res = 0;\n  fill(h,h+V,0);\n  // 流量が限界に達するまで流す\n  while(f > 0){\n    // ダイクストラ法で、最短距離を検索\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top();\n      que.pop();\n      int v = p.second;\n      if(dist[v] < p.first)\n\tcontinue;\n      for(int i = 0; i < G[v].size(); i++){\n\tedge &e = G[v][i];\n\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t  dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  preve[e.to] = i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t] == INF)\n      return -1;\n    for(int i = 0; i < V; i++)\n      h[i] += dist[i];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint n;\nint W[101][101];\nint E[101][101];\nbool field[101][101];\nbool fin[101][101];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>W[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>E[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      char ch;\n      cin>>ch;\n      if(ch=='o')field[i][j]=true;\n      else field[i][j]=false;\n    }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int cost=0;\n      for(int k=0;k<n;k++){\n\tif(k!=j){\n\t  if(field[i][k])\n\t    cost+=E[i][k];\n\t}\n      }\n      for(int k=0;k<n;k++){\n\tif(k!=i){\n\t  if(field[k][j])\n\t    cost+=E[k][j];\n\t}\n      }\n      if(!field[i][j])cost+=2*W[i][j];\n      add_edge(i,j+n,1,cost);\n    }\n  }\n  const int s=2*n;\n  const int t=2*n+1;\n  for(int i=0;i<n;i++)add_edge(s,i,1,0);\n  for(int i=0;i<n;i++)add_edge(i+n,t,1,0);\n  int a=min_cost_flow(s,t,n,2*n+2);\n  cout<<a/2<<endl;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      edge &e=G[i][j];\n      if(e.to>=n&&e.to<2*n){\n\tif(e.cap==0)fin[i][e.to-n]=true;\n\telse fin[i][e.to-n]=false;\n      }\n    }\n  }\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(field[i][j]^fin[i][j])cnt++;\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(field[i][j]&&!fin[i][j])\n\tcout<<i+1<<\" \"<<j+1<<\" erase\"<<endl;\n      else if(!field[i][j]&&fin[i][j])\n\tcout<<i+1<<\" \"<<j+1<<\" write\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int index, capacity, cost;\n    Edge(int i, int c, int d) : index(i), capacity(c), cost(d) {}\n};\n\nstruct Command {\n    int r, c;\n    string cmd;\n    Command(int r, int c, const string &cmd) : r(r), c(c), cmd(cmd) {}\n};\n\n// O(V^2 U C) where\n//  U = sum of capacity\n//  C = sum of cost\npair<int,int> primal_dual(const vector<vector<Edge> >& g, int source, int sink, int total_flow, vector<vector<int> > &flow)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)); \n  flow = vector<vector<int> >(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<Edge>::const_iterator it(g[i].begin()); it != g[i].end(); ++it) {\n      capacity[i][it->index] = it->capacity;\n      cost[i][it->index] = it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  for (int f = total_flow; f > 0; ) {\n    vector<int> dist(N, 1000000);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<Edge>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (capacity[n][it->index] - flow[n][it->index] > 0) {\n          const int c2 = c + cost[n][it->index] + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = n;\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return total;\n}/*}}}*/\n\nint write_cost[128][128];\nint erase_cost[128][128];\nchar field[128][128];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            cin >> write_cost[i][j];\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            cin >> erase_cost[i][j];\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        cin >> &field[i][0];\n    }\n\n    // 0..N-1: Row\n    // N..2N-1: Col\n    // 2N: Source\n    // 2N+1: Sink\n    vector<vector<Edge> > graph(2*N+2);\n    for(int r = 0; r < N; ++r) {\n        int sum = 0;\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o') sum += erase_cost[r][c];\n        }\n        for(int c = 0; c < N; ++c) {\n            int cost = sum;\n            if(field[r][c] == 'o') cost -= erase_cost[r][c];\n            else cost += write_cost[r][c];\n            graph[r].push_back(Edge(N+c, 1, cost));\n            graph[N+c].push_back(Edge(r, 0, -cost));\n        }\n    }\n    for(int r = 0; r < N; ++r) {\n        graph[2*N].push_back(Edge(r, 1, 0));\n    }\n    for(int c = 0; c < N; ++c) {\n        graph[N+c].push_back(Edge(2*N+1, 1, 0));\n    }\n    vector<vector<int> > flow;\n    pair<int,int> result = primal_dual(graph, 2*N, 2*N+1, N, flow);\n    vector<Command> commands;\n    for(int r = 0; r < N; ++r) {\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o' && flow[r][N+c] == 0)\n                commands.push_back(Command(r+1, c+1, \"erase\"));\n            else if(field[r][c] == '.' && flow[r][N+c] > 0)\n                commands.push_back(Command(r+1, c+1, \"write\"));\n        }\n    }\n    cout << result.first << endl;\n    cout << commands.size() << endl;\n    for(vector<Command>::const_iterator it = commands.begin(); it != commands.end(); ++it) {\n        cout << it->r << ' ' << it->c << ' ' << it->cmd << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n\n        MinCostFlow solver(N * N + 2);\n        int Source = N * N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    count++;\n                }\n            }\n        }\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str();\n        cout.flush();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P; //cap,cost\ntypedef tuple<int,int,string> T;//R,C,w/e\nmap<int,P> G[100*100+200+2];\n\nint main(){\n    int n;\n    cin>>n;\n    int W[n][n];\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++) cin>>W[i][j];\n    int E[n][n];\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++) cin>>E[i][j];\n    vector<string> F(n),ANS(n,string(n,'.'));\n    for(auto &f:F) cin>>f;\n    int C[n][n];\n    int mincost = 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(F[i][j]=='o'){\n                C[i][j]=-E[i][j];\n                mincost+=E[i][j];\n            }else{\n                C[i][j]=W[i][j];\n            }\n        }\n    }\n    int row[n],col[n];\n    for(int i=0;i<n;i++){\n        row[i]=n*n+i;\n        col[i]=n*n+n+i;\n    }\n    int s=n*n+2*n, t=n*n+2*n+1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            G[row[i]][i*n+j]=P(1,C[i][j]);\n            G[i*n+j][row[i]]=P(0,-C[i][j]);\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            G[i*n+j][col[j]]=P(1,0);\n            G[col[j]][i*n+j]=P(0,0);\n        }\n    }\n    for(int i=0;i<n;i++){\n        G[s][row[i]]=P(1,0);\n        G[row[i]][s]=P(0,0);\n\n    }\n    for(int j=0;j<n;j++){\n        G[col[j]][t]=P(1,0);\n        G[t][col[j]]=P(0,0);\n    }\n    int V=n*n+2*n+2;\n    int dist[V],prev[V];\n    for(int f=0;f<n;f++){\n        fill(dist,dist+V,10000000);\n        fill(prev,prev+V,-1);\n        dist[s]=0;\n        bool update=true;\n        while(update){\n            update=false;\n            for(int v=0;v<V;v++){\n                if(dist[v]==10000000) continue;\n                for(auto e:G[v]){\n                    int to,cap,cost;\n                    to=e.first;\n                    tie(cap,cost)=e.second;\n                    if(!cap) continue;\n                    if(dist[to]>dist[v]+cost){\n                        dist[to]=dist[v]+cost;\n                        prev[to]=v;\n                        update=true;\n                    }\n                }\n            }\n        }\n        mincost+=dist[t];\n        for(int v=t;v!=s;v=prev[v]){\n            G[prev[v]][v].first=0;\n            G[v][prev[v]].first=1;\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(!G[row[i]][i*n+j].first){\n                ANS[i][j]='o';\n            }\n        }\n    }\n    // for(int i=0;i<n;i++)cout<<F[i]<<endl;\n    // cout<<endl;\n    // for(int i=0;i<n;i++)cout<<ANS[i]<<endl;\n    // cout<<endl;\n    vector<T> O;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(F[i][j]=='o'&&ANS[i][j]=='.'){\n                O.emplace_back(i,j,\"erase\");\n            }\n            if(F[i][j]=='.'&&ANS[i][j]=='o'){\n                O.emplace_back(i,j,\"write\");\n            }\n        }\n    }\n    cout<<mincost<<endl;\n    cout<<O.size()<<endl;\n    for(auto o:O){\n        int r,c;\n        string we;\n        tie(r,c,we)=o;\n        cout<<r<<' '<<c<<' '<<we<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n  int src, dst, capacity, cost, rev;\n  Edge(int src, int dst, int capacity, int cost)\n    : src(src), dst(dst), capacity(capacity), cost(cost) {}\n  Edge(int src, int dst, int capacity, int cost, int rev)\n    : src(src), dst(dst), capacity(capacity), cost(cost), rev(rev) {}\n};\nbool operator<(const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<int> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, int cost, int cap) {\n  g[s].push_back(Edge(s,d,cap,cost));\n  g[d].push_back(Edge(d,s,0,-cost));\n  //cout<<s<<\" \"<<d<<\" \"<<cost<<\" \"<<cap<<endl;\n}\n\n#define RESIDUE(u,v) (capacity[u][v]-flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n\nint sum;\npair<int, int> minimumCostFlow(Graph &g, int s, int t) {\n  const int n = g.size();\n  const int inf = 1<<29;\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  for (int u=0; u<n; ++u) {\n    for (Edges::iterator e = g[u].begin(); e != g[u].end(); ++e) {\n      capacity[e->src][e->dst] += e->capacity;\n      cost[e->src][e->dst] += e->cost;\n    }\n  }\n\n  pair<int,int> total = make_pair(0,0);\n  vector<int> h(n, inf);\n  h[s] = 0;\n  for (int k=0; k<n; ++k)\n    for (int i=0; i<n; ++i)\n      for (Edges::iterator e=g[i].begin(); e!=g[i].end(); ++e)\n        if (capacity[e->src][e->dst])\n          h[e->dst] = min(h[e->dst], h[e->src] + cost[e->src][e->dst]);\n\n  for (int F = inf; F > 0; ) {\n    vector<int> d(n, inf); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q;\n    for (Q.push(Edge(-2,s,0,0)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      for (Edges::iterator f=g[e.dst].begin(); f != g[e.dst].end(); ++f) {\n        if (RESIDUE(f->src, f->dst) > 0) {\n          if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n            d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n            Q.push(Edge(f->src, f->dst, 0, d[f->dst]));\n          }\n        }\n      }\n    }\n\n    if (p[t] == -1) break;\n    int f = F;\n    for (int u=t; u!=s; u=p[u]) f = min(f, RESIDUE(p[u], u));\n    for (int u=t; u!=s; u=p[u]) {\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    for(int u=0; u<n; ++u) if (h[u] != inf) h[u] += d[u];\n  }\n  cout<<total.first+sum<<endl;\n  int cnt = 0;\n  int nn = (n-2)/2;\n  vector<pair<int,pair<int,int> > > v;\n  for (int i=0; i<nn; ++i) {\n    for (int j=0; j<nn; ++j) {\n      if (flow[i][j+nn] > 0 && cost[i][j+nn] > 0) {\n        cnt++;\n        v.push_back(make_pair(1, make_pair(i+1,j+1)));\n      }\n      if (flow[i][j+nn] == 0 && cost[i][j+nn] < 0) {\n        cnt++;\n        v.push_back(make_pair(0, make_pair(i+1,j+1)));\n      }\n    }\n  }\n  cout<<cnt<<endl;\n  for (int i=0; i<v.size(); ++i) {\n    if (v[i].first) cout<<\"write \"<<v[i].second.first<<\" \"<<v[i].second.second<<endl;\n    else cout<<\"erase \"<<v[i].second.first<<\" \"<<v[i].second.second<<endl;\n  }\n  return total;\n}\n\nint w[101][101], e[101][101];\nstring f[101];\n\nint main() {\n  int n;\n  while(cin>>n) {\n    for (int i=0; i<n; ++i) for(int j=0; j<n; ++j) cin>>w[i][j];\n    for (int i=0; i<n; ++i) for(int j=0; j<n; ++j) cin>>e[i][j];\n    for (int i=0; i<n; ++i) cin>>f[i];\n    Graph g(n*2+2);\n    sum = 0;\n    for (int i=0; i<n; ++i) add_edge(g, n*2, i, 0, 1);\n    for (int i=0; i<n; ++i) add_edge(g, i+n, n*2+1, 0, 1);\n    for (int x=0; x<n; ++x) {\n      for (int y=0; y<n; ++y) {\n        if (f[y][x] == 'o') {\n          add_edge(g, x, y+n, -e[y][x], 1);\n          sum += e[y][x];\n        } else {\n          add_edge(g, x, y+n, w[y][x], 1);\n        }\n      }\n    }\n\n    pair<int,int> ans = minimumCostFlow(g, n*2, n*2+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            if (v < l+1) {\n            \tused[v] = true;\n\t            for (int i = l+1; i < l+r+2; i++) {\n\t\t\t\t\tif (!flow[v][i-(l+1)] && dist[i] > dist[v] + G[v][i-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] + G[v][i-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v-(l+1)] && dist[i] > dist[v] - G[i][v-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] - G[i][v-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tfor (int v = l; v != l+r+1 ; v = prevv[v]) {\n\t\t\tif (v < l+1) {\n\t\t\t\tflow[v][prevv[v]-(l+1)] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    const int INF = INT_MAX / 2;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to, cap, cost;\n        Edge* rev;\n        Edge(int from, int to, int cap, int cost) : from(from), to(to), cap(cap), cost(cost) {}\n    };\n    vector<vector<Edge*>> G;\n\n    void addEdge(int from, int to, int cap, int cost) {\n        assert(from != to);\n        Edge* e = new Edge(from, to, cap, cost);\n        Edge* r = new Edge(to, from, 0, -cost);\n        e->rev = r;\n        r->rev = e;\n        G[from].push_back(e);\n        G[to].push_back(r);\n    }\n\n    int minCostFlow(int s, int t, int f) {\n        const int N = G.size();\n        int ret = 0;\n        vector<Edge*> prev(N, nullptr);\n        while (f > 0) {\n            // Bellman Ford\n            vector<int> D(N, INF);\n            D[s] = 0;\n            bool updated = true;\n            while (updated) {\n                updated = false;\n                for (int v = 0; v < N; v++) {\n                    if (D[v] == INF) continue;\n                    for (auto e : G[v]) {\n                        if (e->cap == 0) continue;\n                        int ncost = D[v] + e->cost;\n                        if (D[e->to] > ncost) {\n                            D[e->to] = ncost;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n\n            if (D[t] == INF) return -1; // ?°???¶?????¶????????????????????????s?????????t??????????????¨?????????????????????????????±?????????\n            int d = f;\n            for (Edge* p = prev[t]; p != nullptr; p = prev[p->from]) {\n                d = min(d, p->cap);\n            }\n\n            f -= d;\n            ret += d * D[t];\n            for (Edge* p = prev[t]; p != nullptr; p = prev[p->from]) {\n                p->cap -= d;\n                p->rev->cap += d;\n            }\n        }\n        return ret;\n    }\n    \n\n    int N;\n    vector<vector<int>> W, E;\n    vector<string> F;\n\n    void input() {\n        cin >> N;\n        W.resize(N, vector<int>(N, 0)); cin >> W;\n        E.resize(N, vector<int>(N, 0)); cin >> E;\n        F.resize(N); cin >> F;\n    }\n\n    void solve() {\n        G.clear(); G.resize(2 + 2 * N);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int cost = 0;\n                for (int k = 0; k < N; k++) {\n                    if (F[i][k] == 'o') {\n                        cost += (j == k ? 0 : E[i][k]);\n                    } else {\n                        cost += (j == k ? W[i][k] : 0);\n                    }\n                }\n                addEdge(1 + i, 1 + N + j, 1, cost);\n            }\n            addEdge(0, 1 + i, 1, 0);\n            addEdge(1 + N + i, 1 + 2 * N, 1, 0);\n        }\n        cout << minCostFlow(0, 1 + 2 * N, N) << endl;\n\n        vector<string> X(N, string(N, '.'));\n        for (int i = 1; i <= N; i++) {\n            for (auto e : G[i]) {\n                if (e->cap == 0) {\n                    if (e->to <= N || e->to > 2*N) continue;\n                    X[e->from - 1][e->to - (N + 1)] = 'o';\n                }\n            }\n        }\n        int c = 0;\n        ostringstream os;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (F[i][j] == X[i][j]) continue;\n                c++;\n                os << i + 1 << \" \" << j + 1 << \" \" << (F[i][j] == 'o' ? \"erase\" : \"write\") << endl;\n            }\n        }\n        cout << c << endl;\n        cout << os.str() << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nedge G[MAX_V][MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from][to] = (edge){cap, cost};\n\tG[to][from] = (edge){0, -cost};\n}\n\nint bit_matching_cost(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[s] = 0;\n\n        fill_n(used, V, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < V; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            used[v] = true;\n\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t}\n\t\t\t}\n        }\n        /*\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\tque.push(P(dist[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tif (dist[t] == INT_INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tint d = f;\n\t\tfor (int v = 0; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][v].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][v];\n\t\t\te.cap -= d;\n\t\t\tG[v][prevv[v]].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N*2, i, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N+i, N*2+1, 1, 0);\n\t}\n\tf += bit_matching_cost(N*2, N*2+1, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][N+j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 300\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint can[MAX_V][MAX_V]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n\n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j , 1, can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  int W[101][101],E[101][101];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>W[i][j];\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>E[i][j];\n  \n  string mp[101];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  int sumW[101]={},sumH[101]={},sum=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      if(mp[i][j]=='o') sumW[i]+=E[i][j],sum+=E[i][j];\n      if(mp[j][i]=='o') sumH[i]+=E[j][i];\n    }\n\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cost=sumH[j]+sumW[i];\n      //if(mp[i][j]=='o') cost-=2*E[i][j];\n      //if(mp[i][j]=='.') cost+=W[i][j];\n      if(mp[i][j]=='o') cost=-E[i][j];\n      if(mp[i][j]=='.') cost=W[i][j];\n      can[i][j]=cost;\n\n    }\n  cout<<sum+Biparite_Matching(n,n)<<endl;\n  \n  bool used[101][101]={};\n  for(int i=0;i<n;i++) \n    for(int j=0;j<G[i].size();j++)\n      if(G[i][j].cap<=0)used[i][G[i][j].to-n]=1;\n  \n\n  int mincost=0,cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) \n      if(used[i][j]&&mp[i][j]=='.')cnt++,mincost+=W[i][j];\n      else if(!used[i][j]&&mp[i][j]=='o')cnt++,mincost+=E[i][j];\n\n  //  cout<<mincost<<endl;\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) \n      if(used[i][j]&&mp[i][j]=='.')cout<<i+1<<\" \"<<j+1<<\" write\"<<endl;\n      else if(!used[i][j]&&mp[i][j]=='o')cout<<i+1<<\" \"<<j+1<<\" erase\"<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint n;\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n  void output(vector<P> &v) {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        if(!(1 <= i && i <= n)) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        if(!rev_e.cap) continue;\n        v.push_back({i-1, e.to-n-1});\n      }\n    }\n  }\n};\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  vvi w(n, vi(n)), e(n, vi(n));\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      cin >> w[i][j];\n    }\n  }\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      cin >> e[i][j];\n    }\n  }\n  vector<string> s(n);\n  for(int i=0;i<n;++i) {\n    cin >> s[i];\n  }\n  PrimalDual<ll, ll> flow(2*n+2);\n  for(int i=0;i<n;++i) {\n    flow.add_edge(0, i+1, 1, 0);\n  }\n  for(int i=0;i<n;++i) {\n    flow.add_edge(n+1+i, 2*n+1, 1, 0);\n  }\n  ll ans = 0;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      if(s[i][j] == 'o') {\n        ans += e[i][j];\n        flow.add_edge(i+1, n+1+j, 1, -e[i][j]);\n      } else {\n        flow.add_edge(i+1, n+1+j, 1, w[i][j]);\n      }\n    }\n  }\n  cout << ans + flow.min_cost_flow(0, 2*n+1, n) << endl;\n  vector<P> v;\n  flow.output(v);\n  map<P, bool> sel;\n  for(int i=0;i<(int)(v.size());++i) {\n    sel[v[i]] = true;\n  }\n  vector<P> sousa;\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<n;++j) {\n      if(s[i][j] == 'o' && !sel[{i, j}]) {\n        sousa.push_back({i, j});\n      } else if(s[i][j] == '.' && sel[{i, j}]) {\n        sousa.push_back({i, j});\n      }\n    }\n  }\n  cout << (int)(sousa.size()) << endl;\n  for(int i=0;i<(int)(sousa.size());++i) {\n    int j = sousa[i].first, k = sousa[i].second;\n    if(s[j][k] == 'o') {\n      cout << j+1 << \" \" << k+1 << \" \" << \"erase\" << endl;\n    } else {\n      cout << j+1 << \" \" << k+1 << \" \" << \"write\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<sstream>\n#include<string>\nusing namespace std;\nconst int INF = 1 << 30;\n#define MAX_V 100000\ntypedef pair < int , int > Pi;\nint n;\nclass Primal_Dual{\nprivate:\n  struct edge{\n    int to, cap, cost, rev;\n  };\n  int V;\n  vector< edge > info[MAX_V];\n  int h[MAX_V], dist[MAX_V], prevv[MAX_V], preve[MAX_V];\npublic:\n  void add_edge(int from,int to,int cap,int cost){ //from,to,容量,コスト\n    info[from].push_back((edge){to,cap,cost,info[to].size()});\n    info[to].push_back((edge){from,0,-cost,info[from].size()-1});\n  }\n  Primal_Dual(){};\n  Primal_Dual(int size):V(size){};\n  int min_cost_flow(int s,int t,int f){ //sからtへの最小費用流\n    int ret = 0;\n    fill_n( h, V, 0);\n    while(f > 0){\n      priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n      fill_n( dist, V, INF);\n      que.push(Pi(0,s));\n      dist[s] = 0;\n      while(!que.empty()){\n        Pi p = que.top(); que.pop();\n        if(dist[p.second] < p.first) continue;\n        for(int i = 0; i < info[p.second].size(); i++){\n          edge& e = info[p.second][i];\n          if(e.cap > 0 && dist[e.to] > dist[p.second] + e.cost + h[p.second] - h[e.to]){\n            dist[e.to] = dist[p.second] + e.cost + h[p.second] - h[e.to];\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t] == INF) return -1;\n      for(int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for(int v = t; v != s; v = prevv[v]){\n        d = min( d, info[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      ret += d * h[t];\n      for(int v = t; v != s; v = prevv[v]){\n        edge& e = info[prevv[v]][preve[v]];\n        e.cap -= d;\n        info[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n  void dump(char F[][100]){\n    vector< string > ret;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < info[i].size(); j++){\n        if(info[i][j].cap == 0){\n          const int pos = info[i][j].to - n;\n          if(F[i][pos] == '.'){\n            stringstream ss;\n            ss << i + 1 << \" \" <<  pos + 1 << \" write\";\n            ret.push_back(ss.str());\n          }\n          for(int k = 0; k < n; k++){\n            if(k == pos) continue;\n            if(F[i][k] == 'o'){\n              stringstream ss;\n              ss << i + 1 << \" \" << k + 1 << \" erase\";\n              ret.push_back(ss.str());\n            }\n          }\n          break;\n        }\n      }\n    }\n    cout << ret.size() << endl;\n    for(int i = 0 ; i < ret.size(); i++){\n      cout << ret[i] << endl;\n    }\n  }\n};\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  int W[100][100], E[100][100];\n  char F[100][100];\n\n#define from n * 2\n#define to n * 2 + 1\n\n  cin >> n;\n  rep(i,n) rep(j,n) cin >> W[i][j];\n  rep(i,n) rep(j,n) cin >> E[i][j];\n  rep(i,n) rep(j,n) cin >> F[i][j];\n\n  Primal_Dual Graph(n * 2 + 2);\n  rep(i,n) {\n    Graph.add_edge( from, i, 1, 0); //各行へ\n    Graph.add_edge( n + i, to, 1, 0); // 吸収\n  }\n  rep(i,n) {\n    rep(j,n) {\n      int cost = 0;\n      if(F[i][j] == '.') cost += W[i][j]; //そこに○かくと\n      rep(k,n) {\n        if(j == k) continue;\n        if(F[i][k] == 'o') cost += E[i][j]; //ここの○は消さねば\n      }\n      Graph.add_edge( i, n + j, 1, cost);\n    }\n  }\n  cout << Graph.min_cost_flow(from, to, n) << endl;\n  Graph.dump(F);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n \nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n \n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n \n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n \n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n \nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n \nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 100000;\nconst Cost INF = numeric_limits<Cost>::max() / 8;\n \nstruct PrimalDual {\n    struct Edge {\n        int d; Flow c, f; Cost w; int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n            :d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n \n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n \n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n \n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n \n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n \n        using pcv = pair<Cost, int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h + n, 0);\n        while (f > 0) {\n            fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)g[v].size(); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n \n            if (dist[t] == INF) {\n                return -1; // ?????????????????????????????テつ」???\n            }\n \n            // s-t ????????????????????テつ」??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n \n    Flow residue(const Edge &e) { return e.c - e.f; }\n \n    // ???????????テつィ???\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n \nint n;\nint W[128][128], E[128][128];\nchar f[128][128];\nint ans[10000][3];\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n \n    cin >> n;\n     \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n \n    int C = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (f[i][j] == 'o') {\n                C += E[i][j];\n            }\n        }\n    }\n \n    PrimalDual pd(n * 2 + 2);\n \n    int s = n * 2, t = n * 2 + 1;\n    for (int i = 0; i < n; i++) {\n        pd.add_edge(s, i, 1, 0);\n        pd.add_edge(i + n, t, 1, 0);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            pd.add_edge(i, j + n, 1, f[i][j] == 'o' ? -E[i][j] : W[i][j]);\n        }\n    }\n \n    cout << C + pd.solve(s, t, n) << '\\n';\n \n    int cnt = 0;\n    for (int i = 0; i < pd.g.size(); i++) {\n        for (auto &e : pd.g[i]) {\n            if (e.is_r || e.w == 0) continue;\n            if (f[i][e.d - n] == 'o' && e.f == 0) {\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 0;\n                cnt++;\n            } else if (f[i][e.d - n] == '.' && e.f == 1) {\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 1;\n                cnt++;\n            }\n        }\n    }\n \n    cout << cnt << '\\n';\n    for (int i = 0; i < cnt; i++) {\n        ans[i][0]++;\n        ans[i][1]++;\n        cout << ans[i][0] << ' ' << ans[i][1] << (ans[i][2] == 0 ? \" erase\\n\" : \" write\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>PP;\n\nstruct edge{\n    int to,cap,cost,rev; //?????????,??????,?????¨,??????\n};\n\nconst int MAX_N = 102;\nconst int MAX_V = 205;\n\nint n;\nint W[MAX_N][MAX_N];\nint E[MAX_N][MAX_N];\nint mp[MAX_N][MAX_N];\nvector<edge> G[MAX_V];\nint memo[MAX_V][MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(const int vcnt,const int s,const int t,int f)\n{\n\tint res =0;\n\tint dist[MAX_V];\n\tint prevv[MAX_V];\n\tint preve[MAX_V];\n\twhile(f>0){\n\t\tfill(dist,dist+vcnt,INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v=0;v<vcnt;v++){\n\t\t\t\tif(dist[v] == INF)\tcontinue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\t//??????????????????????¨???¶\n\t\t\t\t\t\tpreve[e.to] = i;\t//????????????????¨???¶\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\n\t\tint d = f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n            memo[prevv[v]][e.to] = 1;\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n    cin >> n;\n    int sm = 0;\n    rep(i,n){\n        rep(j,n){\n            cin >> W[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            cin >> E[i][j];\n        }\n    }\n\n    rep(i,n){\n        char c;\n        cin >> c;\n        rep(j,n){\n            cin >> c;\n            if(c == 'o'){\n                mp[i][j] = 1;\n            }else{\n                mp[i][j] = 0;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(mp[i][j] == 1){\n                add_edge(i+1,j+n+1,INF,-E[i][j]);\n                sm += E[i][j];\n            }else{\n                add_edge(i+1,j+n+1,INF,W[i][j]);\n            }\n        }\n    }\n    rep(i,n){\n        add_edge(0,i+1,1,0);\n        add_edge(i+n+1,2*n+1,1,0);\n    }\n    cout << sm + min_cost_flow(2*n+2,0,2*n+1,n) << \"\\n\";\n    vector<PP> ans;\n    rep(i,n){\n        rep(j,n){\n            if(mp[i][j] == 1 && memo[i+1][j+n+1] != 1){\n                ans.pb(PP(P(i+1,j+1),0));\n            }else if(mp[i][j] == 0 && memo[i+1][j+n+1] == 1){\n                ans.pb(PP(P(i+1,j+1),1));\n            }\n        }\n    }\n    cout << ans.size() << \"\\n\";\n    rep(i,ans.size()){\n        if(ans[i].se == 0){\n            cout << (ans[i].fi).fi << \" \" << (ans[i].fi).se << \"erase\\n\";\n        }else{\n            cout << (ans[i].fi).fi << \" \" << (ans[i].fi).se << \"write\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\ntypedef long long  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\nconst int V = 4000;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nWeight h[V];                //テ」ツδ敕」ツδ?」ツδウテ」ツつキテ」ツδ」テ」ツδォ\nWeight dist[V];             //テヲツ慊?ァツ淞ュティツキツ敕ゥツ崢「\nint prevv[V], preve[V];  //テァツ崢エテ・ツ可催」ツ?ョティツセツコテ」ツ?ィテゥツ?づァツつケ\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst Weight INF = 2147483647;\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n\tWeight res = 0;\n\tmemset(h, 0, sizeof(h));\n\ttypedef pair<Weight, int> P;\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest]) {\n\t\t\t\t\tdist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\tque.push(P(dist[e.dest], e.dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tREP(v, V) h[v] =h[v]+ dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres = res+d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct ope {\n\tint x;\n\tint y;\n\tbool write;\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int>>ws(N, vector<int>(N)), ds(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> ws[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> ds[i][j];\n\t\t}\n\t}\n\tvector<vector<int>>field(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfield[i][j] = st[j] == 'o';\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int l = start+1;\n\tconst int u = l + N;\n\tconst int goal = u + N;\n\tGraph g(goal + 1);\n\tfor (int i = 0; i <N; ++i) {\n\t\tadd_edge(g, start, l + i, 1, 0);\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tint cost = 0;\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (j == k) {\n\t\t\t\t\tif (!field[i][k])cost += ws[i][k];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[i][k])cost += ds[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd_edge(g, l + i, u + j, 1, cost);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tadd_edge(g, u + i, goal, 1, 0);\n\t}\n\tvector<ope>opes;\n\tint ans = min_cost_flow(g, start, goal,N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (auto e : g[l + i]) {\n\t\t\tif (e.dest) {\n\t\t\t\tint x = e.dest - u;\n\n\t\t\t\t//テ「ツ猟?\n\t\t\t\tif (e.cap == 0) {\n\t\t\t\t\tif (!field[i][x]) {\n\t\t\t\t\t\topes.push_back(ope{ x,i,true });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[i][x]) {\n\t\t\t\t\t\topes.push_back(ope{ x,i,false });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << opes.size() << endl;\n\tfor (auto o : opes) {\n\t\tcout << o.y + 1 << \" \" << o.x+ 1 << \" \";\n\t\tif (o.write)cout << \"write\" << endl;\n\t\telse cout << \"erase\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\ntypedef long long  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\nconst int V = 4000;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nWeight h[V];                //テ」ツδ敕」ツδ?」ツδウテ」ツつキテ」ツδ」テ」ツδォ\nWeight dist[V];             //テヲツ慊?ァツ淞ュティツキツ敕ゥツ崢「\nint prevv[V], preve[V];  //テァツ崢エテ・ツ可催」ツ?ョティツセツコテ」ツ?ィテゥツ?づァツつケ\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst Weight INF = 2147483647;\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n\tWeight res = 0;\n\tmemset(h, 0, sizeof(h));\n\ttypedef pair<Weight, int> P;\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest]) {\n\t\t\t\t\tdist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\tque.push(P(dist[e.dest], e.dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tREP(v, V) h[v] =h[v]+ dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres = res+d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct ope {\n\tint x;\n\tint y;\n\tbool write;\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int>>ws(N, vector<int>(N)), ds(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> ws[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> ds[i][j];\n\t\t}\n\t}\n\tvector<vector<int>>field(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfield[i][j] = st[j] == 'o';\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int l = start+1;\n\tconst int u = l + N;\n\tconst int goal = u + N;\n\tGraph g(goal + 1);\n\tfor (int i = 0; i <N; ++i) {\n\t\tadd_edge(g, start, l + i, 1, 0);\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tint cost = 0;\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (j == k) {\n\t\t\t\t\tif (!field[i][k])cost += ws[i][k];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[i][k])cost += ws[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd_edge(g, l + i, u + j, 1, cost);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tadd_edge(g, u + i, goal, 1, 0);\n\t}\n\tvector<ope>opes;\n\tint ans = min_cost_flow(g, start, goal,N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (auto e : g[l + i]) {\n\t\t\tif (e.dest) {\n\t\t\t\tint x = e.dest - u;\n\n\t\t\t\t//テ「ツ猟?\n\t\t\t\tif (e.cap == 0) {\n\t\t\t\t\tif (!field[i][x]) {\n\t\t\t\t\t\topes.push_back(ope{ x,i,true });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[i][x]) {\n\t\t\t\t\t\topes.push_back(ope{ x,i,false });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << opes.size() << endl;\n\tfor (auto o : opes) {\n\t\tcout << o.y + 1 << \" \" << o.x+ 1 << \" \";\n\t\tif (o.write)cout << \"write\" << endl;\n\t\telse cout << \"erase\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n// checked by  http://codeforces.com/contest/237/submission/4710047\n//                  http://codeforces.com/contest/277/submission/4710018\n\nnamespace MinCostFlows{\nusing Flow=int;using Cost=ll;\nconst Flow FINF=1<<30;\nconst Cost CINF=1<<30,EPS =0;\nclass MinCostFlow{\nprivate:\n    bool EQ(Cost a,Cost b){return abs(a-b)<EPS;}\n    int V;\n    struct Edge{\n        int from,to;Flow cap;Cost cost;int rev;\n        Edge(int from,int to,Flow cap,Cost cost,int rev):from(from),to(to),cap(cap),cost(cost),rev(rev){}\n    };\n    using  Graph=vector<vector<Edge>>;\n    vector<Cost> dist,h;vector<int> prevv,preve;\n    using pci=pair<Cost,int>;\npublic:\n    Graph G;\n    \n    MinCostFlow(int V):V(V){\n        G=Graph(V);\n        dist=vector<Cost>(V);h=vector<Cost>(V);\n        prevv=vector<int>(V);preve=vector<int>(V);\n    }\n    void add_edge(int from,int to,Flow cap,Cost cost){\n        G[from].push_back(Edge(from,to,cap,cost,G[to].size()));\n        G[to].push_back(Edge(to,from,0,-cost,G[from].size()-1));\n    }\n    // void clearGraph(){\n    //     REP(i,V)G[i].clear();\n    // }\n\n    //primal Dual O(V^2*U*C)\n    pair<Cost,Flow> mincostflow(int s,int t,Flow f){\n        pair<Cost,Flow> res(0,0);\n        fill(ALL(h),0);\n        while(f > 0){\n            fill(ALL(dist),FINF);dist[s] = 0;\n\n            priority_queue<pci,vector<pci>,greater<pci> > que;\n            que.push(pci(0,s));\n            while(!que.empty()){\n                pci p = que.top();que.pop();\n                int v = p.second;\n                if(dist[v] < p.first)continue;\n                REP(i,(int)G[v].size()){\n                    Edge &e = G[v][i];\n                    if(e.cap<=0)continue;\n                    if(dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;preve[e.to] = i;\n                        que.push(pci(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(EQ(dist[t],FINF))break;\n\n            REP(i,V)h[i] += dist[i];\n            Flow d = f;\n            for(int v = t; v != s; v = prevv[v])d = min(d,G[prevv[v]][preve[v]].cap);\n            f -= d;res.first += d*h[t];res.second+=d;\n\n            for(int v = t; v != s; v = prevv[v]){\n                Edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n}\nusing namespace MinCostFlows;\n\n\nclass Main{\npublic:\n\n\tvoid run(){\n\t\tint n;cin >> n;\n\t\tMinCostFlow mcf(n+n+2);\n\t\tint S=n+n,T=n+n+1;\n\n\t\tvector<vector<int>> ws(n,vector<int>(n));\n\t\tREP(y,n)REP(x,n)cin >> ws[y][x];\n\t\tvector<vector<int>> es(n,vector<int>(n));\n\t\tREP(y,n)REP(x,n)cin >> es[y][x];\n\n\t\tvector<string> board(n);\n\t\tREP(i,n)cin >> board[i];\n\n\t\tREP(y,n)mcf.add_edge(S,y,1,0);\n\t\tREP(x,n)mcf.add_edge(n+x,T,1,0);\n\t\tREP(y,n)REP(x,n){\n\t\t\tint c=0;\n\t\t\t//cost 差分\n\t\t\tif(board[y][x]=='.')c+=2*ws[y][x];\n\t\t\tREP(y1,n)if(y!=y1)if(board[y1][x]=='o')c+=es[y1][x];\n\t\t\tREP(x1,n)if(x!=x1)if(board[y][x1]=='o')c+=es[y][x1];\n\t\t\tmcf.add_edge(y,n+x,1,c);\n\t\t}\n\n\t\tCost c=mcf.mincostflow(S,T,n).first/2;\n\n\t\tint num=0;\n\t\tvector<vector<int> > wboard(n,vector<int>(n));\n\t\tvector<vector<int> > eboard(n,vector<int>(n));\n\t\t\n\t\tREP(i,n+n+2){\n\t\t\tEACH(e,mcf.G[i]){\n\t\t\t\tif(IN(0,e->from,n) && IN(n,e->to,n+n)){\n\t\t\t\t\tif(e->cap==0 && board[e->from][e->to-n]=='.'){\n\t\t\t\t\t\tnum++;wboard[e->from][e->to-n]=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(e->cap==1 && board[e->from][e->to-n]=='o'){\n\t\t\t\t\t\tnum++;eboard[e->from][e->to-n]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << c <<endl;\n\t\tcout << num <<endl;\n\t\tREP(y, n)REP(x,n)if(wboard[y][x]){\n\t\t\tcout <<y+1 <<\" \"<< x+1 << \" write\" << endl; \n\t\t}\n\t\tREP(y, n)REP(x,n)if(eboard[y][x]){\n\t\t\tcout <<y+1 <<\" \"<< x+1 << \" erase\" << endl; \n\t\t}\n\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            if (v < l+1) {\n            \tused[v] = true;\n\t            for (int i = l+1; i < l+r+2; i++) {\n\t\t\t\t\tif (!flow[v][i-(l+1)] && dist[i] > dist[v] + G[v][i-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] + G[v][i-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v-(l+1)] && dist[i] > dist[v] - G[i][v-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] - G[i][v-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v-(l+1);\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevv[v] : prevv[v+l+1], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevv[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual {\n    // O(FElogV)\n    struct edge {\n        int to, rev;\n        flow_t cap;\n        cost_t cost;\n        edge(int to, flow_t cap, cost_t cost, int rev) :\n                to(to), cap(cap), cost(cost), rev(rev) {}\n    };\n\n    vector<vector<edge>> g;\n    const int sz;\n    const cost_t INF;\n\n    PrimalDual(int V) : g(V), sz(V), INF(numeric_limits<cost_t>::max()) {}\n\n    void add_edge(int s, int t, flow_t cap, cost_t cost) {\n        g[s].emplace_back(t, cap,  cost, (int)g[t].size());\n        g[t].emplace_back(s,   0, -cost, (int)g[s].size() - 1);\n    }\n\n    void dijkstra(\n            vector<cost_t>& dist,\n            vector<int>& prevv,\n            vector<int>& preve,\n            const vector<int>& potential, int s)\n    {\n        dist.assign(sz, INF);\n        prevv.assign(sz, -1);\n        preve.assign(sz, -1);\n        using Pi = pair<cost_t, int>;\n        priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n        que.emplace(0, s);\n        dist[s] = 0;\n        while (!que.empty()) {\n            cost_t cost; int v;\n            std::tie(cost, v) = que.top();\n            que.pop();\n            if (dist[v] < cost) continue;\n            for (int i = 0; i < g[v].size(); ++i) {\n                edge &e = g[v][i];\n                cost_t nextCost =\n                        dist[v] + e.cost + potential[v] - potential[e.to];\n                if (e.cap > 0 and dist[e.to] > nextCost) {\n                    dist[e.to] = nextCost;\n                    prevv[e.to] = v, preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        cost_t ret = 0;\n        vector<cost_t> potential(sz, 0);\n\n        while (f > 0)\n        {\n            vector<cost_t> dist;\n            vector<int> prevv, preve;\n            dijkstra(dist, prevv, preve, potential, s);\n\n            if (dist[t] == INF) return -1;\n\n            for (int v = 0; v < sz; ++v) potential[v] += dist[v];\n\n            flow_t diff = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                diff = min(diff, g[prevv[v]][preve[v]].cap);\n            }\n            f -= diff;\n            ret += diff * potential[t];\n\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = g[prevv[v]][preve[v]];\n                e.cap -= diff;\n                g[v][e.rev].cap += diff;\n            }\n        }\n\n        return ret;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n; cin >> n;\n    vvi W(n, vi(n)), E(n, vi(n));\n    REP(i, n) {\n        REP(j, n) {\n            cin >> W[i][j];\n        }\n    }\n    REP(i, n) {\n        REP(j, n) {\n            cin >> E[i][j];\n        }\n    }\n    vector<string> F(n);\n    REP(i, n) cin >> F[i];\n\n    PrimalDual<int,int> flow(2*n+2);\n\n    vi row(n), col(n);\n    REP(i, n) {\n        REP(j, n) {\n            if (F[i][j] == 'o') {\n                row[i] += E[i][j];\n                col[j] += E[i][j];\n            }\n        }\n    }\n\n    REP(i, n) {\n        REP(j, n) {\n            int cost = row[i] + col[j];\n            if (F[i][j] == 'o') {\n                cost -= 2 * E[i][j];\n            } else {\n                cost += 2 * W[i][j];\n            }\n            flow.add_edge(i, n+j, 1, cost);\n        }\n    }\n    REP(i, n) {\n        flow.add_edge(2*n, i, 1, 0);\n        flow.add_edge(n+i, 2*n+1, 1, 0);\n    }\n\n    int ans = flow.min_cost_flow(2*n, 2*n+1, n);\n\n    vi match(n, -1);\n    REP(i, n) {\n        for (auto& e : flow.g[i]) {\n            int j = e.to - n;\n            if (j < 0 or n <= j) continue;\n            if (e.cap == 0) {\n                match[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<P> erase, write;\n    REP(i, n) {\n        REP(j, n) {\n            if (F[i][j] == 'o' and match[i] != j) {\n                erase.emplace_back(i+1, j+1);\n            }\n            if (F[i][j] == '.' and match[i] == j) {\n                write.emplace_back(i+1, j+1);\n            }\n        }\n    }\n\n    cout << ans / 2 << endl;\n    cout << erase.size() + write.size() << endl;\n    for (auto& tp : erase) {\n        cout << tp.first << \" \" << tp.second << \" erase\" << endl;\n    }\n    for (auto& tp : write) {\n        cout << tp.first << \" \" << tp.second << \" write\" << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef int Capacity;\ntypedef int Cost;\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge; bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n    enum : int { MAX_V = 202 };\n\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n    }\n\n    int mcf(int s, int t, int f) {\n        int res = 0;\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n        static Cost h[MAX_V], dist[MAX_V];\n        static int prevv[MAX_V], preve[MAX_V];\n        rep(i,n)h[i] = 0;\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            rep(i,n) dist[i] = inf;\n            dist[s] = 0;\n            q.emplace(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.mcf(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\n int main(){\n     cin >> n;\n     N=n*2+2;\n     rep(i,n)rep(j,n)scanf(\"%d\",&W[i][j]);\n     rep(i,n)rep(j,n)scanf(\"%d\",&E[i][j]);\n     rep(i,n)scanf(\"%s\",f[i]);\n     solve();\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nedge G[MAX_V][MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from][to] = (edge){cap, cost};\n\tG[to][from] = (edge){0, -cost};\n}\n\nint bit_matching_cost(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\tque.push(P(dist[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INT_INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tint d = f;\n\t\tfor (int v = 0; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][v].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][v];\n\t\t\te.cap -= d;\n\t\t\tG[v][prevv[v]].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N*2, i, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N+i, N*2+1, 1, 0);\n\t}\n\tf += bit_matching_cost(N*2, N*2+1, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][N+j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n\nconst int MAX_V = 500;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tCost h[MAX_V], dist[MAX_V];\n\tint prevv[MAX_V], preve[MAX_V];\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // テヲツ慊嘉・ツ青妥ィツセツコ\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t テゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// テヲツオツ?」ツつ古」ツ?淌」ツδ陛」ツδュテ」ツδシ=テ・ツ?ε」ツ??」ツ?ョテ・ツョツケテゥツ??テァツ渉セテ・ツ慊ィテ」ツ?ョテ・ツョツケテゥツ?湘」ツつ津ィツ。ツィテァツ、ツコ\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint n;\nint W[100][100];\nint E[100][100];\nchar F[100][100];\nchar R[100][100];\n\nstruct Command {\n\tint i, j;\n\tstring s;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcin >> W[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcin >> E[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcin >> F[i][j];\n\t\t\t}\n\t\t}\n\n\t\tPrimalDual pd(2 * n + 2);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tif(F[i][j] == '.') sum += W[i][j];\n\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tif(F[i][k] == 'o') sum += E[i][k];\n\t\t\t\t}\n\t\t\t\tpd.add_edge(i, n + j, 1, sum);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpd.add_edge(2 * n, i, 1, 0);\n\t\t\tpd.add_edge(n + i, 2 * n + 1, 1, 0);\n\t\t}\n\n\t\tint res = pd.solve(2 * n, 2 * n + 1, n);\n\t\tcout << res << endl;\n\t\t//pd.view();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tR[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < pd.g[i].size(); j++) {\n\t\t\t\tif(!pd.g[i][j].isRev) {\n\t\t\t\t\tEdge& e = pd.g[i][j];\n\t\t\t\t\tif(e.cap_orig - e.cap == 1) {\n\t\t\t\t\t\tR[i][e.dst - n] = 'o';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcout << R[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n\n\t\tvector<Command> v;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(F[i][j] != R[i][j]) {\n\t\t\t\t\tif(F[i][j] == '.') v.push_back(Command{ i + 1, j + 1, \"write\" });\n\t\t\t\t\telse v.push_back(Command{ i + 1, j + 1, \"erase\" });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << v.size() << endl;\n\t\tfor(Command c : v) {\n\t\t\tcout << c.i << \" \" << c.j << \" \" << c.s << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nstruct edge/*{{{*/\n{\n  int to;\n  int capacity;\n  int cost;\n  edge(int i, int c, int d) : to(i), capacity(c), cost(d) {}\n};/*}}}*/\n\npair<int,vector<vector<int> > > primal_dual(const vector<vector<edge> >& g, int source, int sink)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)), flow(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<edge>::const_iterator it = g[i].begin(); it != g[i].end(); ++it) {\n      capacity[i][it->to] += it->capacity;\n      cost[i][it->to] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  static const int INF = 10000000;\n  for (int f = INF; f > 0; ) {\n    vector<int> dist(N, INF);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n\n    // bellman ford\n    bool updated = true;\n    for (int k = 0; k < N && updated; k++) {\n      updated = false;\n      for (int n = 0; n < N; n++) {\n        for (vector<edge>::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n          if (capacity[n][it->to] - flow[n][it->to] > 0) {\n            const int c = dist[n] + cost[n][it->to] + h[n] - h[it->to];\n            if (c < dist[it->to]) {\n              updated = true;\n              dist[it->to] = c;\n              parent[it->to] = n;\n            }\n          }\n        }\n      }\n    }\n\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return make_pair(total.first, flow);\n}/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > erase(N, vector<int>(N)), write(N, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> erase[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> write[i][j];\n    }\n  }\n  int init = 0;\n  for (int i = 0; i < N; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < N; j++) {\n      if (s[j] == 'o') {\n        init += erase[i][j];\n        write[i][j] = -erase[i][j];\n      }\n    }\n  }\n\n  vector<vector<edge> > g(2*N+2);\n  const int source = 2*N, sink = 2*N+1;\n  for (int i = 0; i < N; i++) {\n    const int row = i, col = N+i;\n    g[source].push_back(edge(row, 1, 0));\n    g[col].push_back(edge(sink, 1, 0));\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      g[row].push_back(edge(col, 1, write[i][j]));\n    }\n  }\n\n  const pair<int,vector<vector<int> > > r = primal_dual(g, source, sink);\n  const int ans = init + r.first;\n  const vector<vector<int> >& flow = r.second;\n  cout << ans << endl;\n  vector<string> steps;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      if (flow[row][col] == 1 && write[i][j] > 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" write\";\n        steps.push_back(oss.str());\n      } else if (flow[row][col] == 0 && write[i][j] < 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" erase\";\n        steps.push_back(oss.str());\n      }\n    }\n  }\n  cout << steps.size() << endl;\n  copy(steps.begin(), steps.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntemplate<class T>struct costflowGraph{\n\ttypedef pair<T, int> P;\n\tstruct edge{\n\t\tint to, cap, rev;\n\t\tT cost;\n\t\tedge(int to, int cap, T cost, int rev) :\n\t\t\tto(to), cap(cap), cost(cost), rev(rev){\n\t\t\t}\n\t};\n\t\n\tint n, *prevv, *preve;\n\tT *dist;\n\tvector<vector<edge> > G;\n\t\n\tcostflowGraph(int sz) : n(sz){\n\t\tG.resize(n);\n\t\tdist = new T[n];\n\t\tprevv = new int[n]; preve = new int[n];\n\t}\n\t~costflowGraph(){\n\t\tdelete dist;\n\t\tdelete prevv; delete preve;\n\t}\n\t\n\tint add(int s, int t, int cap, T cost){\n\t\tG[s].pb(edge(t, cap, cost, G[t].size()));\n\t\tG[t].pb(edge(s, 0, -cost, G[s].size() - 1));\n\t\treturn G[s].size() - 1;\n\t}\n\tT min_cost_flow(int s, int t, int f){\n\t\tT res = 0;\n\t\twhile(f > 0){\n\t\t\tfill(dist, dist + n, inf);\n\t\t\tdist[s] = 0;\n\t\t\twhile(1){\n\t\t\t\tbool update = 0;\n\t\t\t\trep(v, n){\n\t\t\t\t\tif(dist[v] == inf) continue;\n\t\t\t\t\trep(i, G[v].size()){\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + EPS){\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!update) break;\n\t\t\t}\n\t\t\tif(dist[t] == inf) return -1;\n\t\t\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint n, w[100][100], e[100][100], id[100][100];\nchar c[100][101];\n\nint main(){\n\tcin >> n;\n\trep(i, n) rep(j, n) cin >> w[i][j], w[i][j];\n\trep(i, n) rep(j, n) cin >> e[i][j], e[i][j];\n\trep(i, n) cin >> c[i];\n\t\n\tint ans = 0;\n\tint s = n * n + 2 * n, t = s + 1;\n\tcostflowGraph<int> g(t + 1);\n\trep(i, n) rep(j, n){\n\t\tint co;\n\t\tif(c[i][j] == 'o') co = -e[i][j], ans += e[i][j];\n\t\telse co = w[i][j];\n\t\tid[i][j] = g.add(n * n + i, i * n + j, 1, co);\n\t\tg.add(i * n + j, n * n + n + j, 1, 0);\n\t}\n\trep(i, n){\n\t\tg.add(s, n * n + i, 1, 0);\n\t\tg.add(n * n + n + i, t, 1, 0);\n\t}\n\tcout << ans + g.min_cost_flow(s, t, n) << endl;\n\tvector<pi> v;\n\trep(i, n) rep(j, n){\n\t\tif((g.G[n * n + i][id[i][j]].cap == 0) != (c[i][j] == 'o')){\n\t\t\tv.pb(mp(i, j));\n\t\t}\n\t}\n\tcout << v.size() << endl;\n\trep(i, v.size()) cout << v[i].first + 1 << \" \" << v[i].second + 1 << \" \" <<\n\t(c[v[i].first][v[i].second] == 'o' ? \"erase\" : \"write\") << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\nint const inf = 1<<28;\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight cap, cost;\n    int rev; bool is_rev;\n    Edge(int src, int dst, Weight cap, Weight cost, int rev, bool is_rev=false) :\n        src(src), dst(dst), cap(cap), cost(cost), rev(rev), is_rev(is_rev) {}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph & g, int src, int dst, int cap, int cost) {\n    g[src].emplace_back(src, dst, cap, cost, g[dst].size(), false);\n    g[dst].emplace_back(dst, src, 0, -cost, g[src].size() - 1, true); // rev\n}\n\nstruct State {\n    int v,dist;\n    State(int v, int dist)\n        :v(v), dist(dist) {}\n    bool operator<(State const & s)const{\n        return dist>s.dist;\n    }\n};\n\n// s 縺九ｉ t 縺ク縺ョ豬・? f 縺ョ譛&#128;蟆剰イサ逕ィ豬√ｒ豎ゅａ繧・// 豬√○縺ェ縺・&#63728;エ蜷医・ -1 繧定ソ斐☆\nint primal_dual(Graph & g, int s, int t, Weight f) {\n    int n=g.size();\n    Array h(n), pv(n), pe(n);\n    Weight res = 0;\n    while (f > 0) {\n        priority_queue<State> q;\n        Array dist(n,inf);\n        dist[s] = 0;\n        q.push(State(s, 0));\n        while (q.size()) {\n            State p = q.top(); q.pop();\n            int v = p.v;\n            if (dist[v] < p.dist) continue;\n            iter(e,g[v]){\n                if (e->cap > 0 && dist[e->dst] > dist[v] + e->cost + h[v] - h[e->dst]) {\n                    dist[e->dst] = dist[v] + e->cost + h[v] - h[e->dst];\n                    pv[e->dst] = v;\n                    pe[e->dst] = e-g[v].begin();\n                    q.push(State(e->dst, dist[e->dst]));\n                }\n            }\n        }\n        if (dist[t] == inf) {\n            return -1;\n        }\n        rep(v,n) h[v]+=dist[v];\n        int d = f;\n        for (int v = t; v != s; v = pv[v]) {\n            d = min(d, g[pv[v]][pe[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = pv[v]) {\n            Edge &e = g[pv[v]][pe[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint n;\nWeight W[128][128], E[128][128];\nchar f[128][128];\n\nvoid solve(){\n    Weight C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n\n    Graph g(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        add_edge(g,s,i,1,0);\n        add_edge(g,i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            add_edge(g,i,j+n,1,-E[i][j]);\n        }else{\n            add_edge(g,i,j+n,1,W[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\",C+primal_dual(g,s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n\n    rep(i,g.size()){\n        rep(j,g[i].size()){\n            auto & e=g[i][j];\n            if(e.is_rev || e.cost==0) continue;\n            if(f[e.src][e.dst-n]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=e.src+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=0;\n            }else if(f[e.src][e.dst-n]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=e.src+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,n)rep(j,n){\n        scanf(\"%d\",&W[i][j]);\n    }\n    rep(i,n)rep(j,n){\n        scanf(\"%d\",&E[i][j]);\n    }\n    rep(i,n){\n        scanf(\"%s\",f[i]);\n    }\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nstruct edge/*{{{*/\n{\n  int to;\n  int capacity;\n  int cost;\n  edge(int i, int c, int d) : to(i), capacity(c), cost(d) {}\n};/*}}}*/\n\npair<int,vector<vector<int> > > primal_dual(const vector<vector<edge> >& g, int source, int sink, int max_flow)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)), flow(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<edge>::const_iterator it = g[i].begin(); it != g[i].end(); ++it) {\n      capacity[i][it->to] += it->capacity;\n      cost[i][it->to] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  for (int f = max_flow; f > 0; ) {\n    vector<int> dist(N, 10000000);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<edge>::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (capacity[n][it->to] - flow[n][it->to] > 0) {\n          const int c2 = c + cost[n][it->to] + h[n] - h[it->to];\n          if (c2 < dist[it->to]) {\n            dist[it->to] = c2;\n            parent[it->to] = n;\n            q.push(make_pair(-c2, it->to));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return make_pair(total.first, flow);\n}/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > erase(N, vector<int>(N)), write(N, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> erase[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> write[i][j];\n    }\n  }\n  vector<string> grid(N);\n  for (int i = 0; i < N; i++) {\n    cin >> grid[i];\n    int sum = 0;\n    for (int j = 0; j < N; j++) {\n      if (grid[i][j] == 'o') {\n        sum += erase[i][j];\n      }\n    }\n    for (int j = 0; j < N; j++) {\n      if (grid[i][j] == 'o') {\n        write[i][j] = sum - erase[i][j];\n      } else {\n        write[i][j] += sum;\n      }\n    }\n  }\n\n  vector<vector<edge> > g(2*N+2);\n  const int source = 2*N, sink = 2*N+1;\n  for (int i = 0; i < N; i++) {\n    const int row = i, col = N+i;\n    g[source].push_back(edge(row, 1, 0));\n    g[col].push_back(edge(sink, 1, 0));\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      g[row].push_back(edge(col, 1, write[i][j]));\n      g[col].push_back(edge(row, 0, -write[i][j]));\n    }\n  }\n\n  const pair<int,vector<vector<int> > > r = primal_dual(g, source, sink, N);\n  cout << r.first << endl;\n  const vector<vector<int> >& flow = r.second;\n  vector<string> steps;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      if (flow[row][col] == 1 && grid[i][j] == '.') {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" write\";\n        steps.push_back(oss.str());\n      } else if (flow[row][col] == 0 && grid[i][j] == 'o') {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" erase\";\n        steps.push_back(oss.str());\n      }\n    }\n  }\n  cout << steps.size() << endl;\n  copy(steps.begin(), steps.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nstruct edge/*{{{*/\n{\n  int to;\n  int capacity;\n  int cost;\n  edge(int i, int c, int d) : to(i), capacity(c), cost(d) {}\n};/*}}}*/\n\npair<int,vector<vector<int> > > primal_dual(const vector<vector<edge> >& g, int source, int sink)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)), flow(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<edge>::const_iterator it = g[i].begin(); it != g[i].end(); ++it) {\n      capacity[i][it->to] += it->capacity;\n      cost[i][it->to] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  static const int INF = 10000000;\n  for (int f = INF; f > 0; ) {\n    vector<int> dist(N, INF);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<edge>::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (capacity[n][it->to] - flow[n][it->to] > 0) {\n          const int c2 = c + cost[n][it->to] + h[n] - h[it->to];\n          if (c2 < dist[it->to]) {\n            dist[it->to] = c2;\n            parent[it->to] = n;\n            q.push(make_pair(-c2, it->to));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return make_pair(total.first, flow);\n}/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > erase(N, vector<int>(N)), write(N, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> erase[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> write[i][j];\n    }\n  }\n  int init = 0;\n  for (int i = 0; i < N; i++) {\n    string s;\n    cin >> s;\n    for (int j = 0; j < N; j++) {\n      if (s[j] == 'o') {\n        init += erase[i][j];\n        write[i][j] = -erase[i][j];\n      }\n    }\n  }\n\n  vector<vector<edge> > g(2*N+2);\n  const int source = 2*N, sink = 2*N+1;\n  for (int i = 0; i < N; i++) {\n    const int row = i, col = N+i;\n    g[source].push_back(edge(row, 1, 0));\n    g[col].push_back(edge(sink, 1, 0));\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      g[row].push_back(edge(col, 1, write[i][j]));\n    }\n  }\n\n  const pair<int,vector<vector<int> > > r = primal_dual(g, source, sink);\n  const int ans = init + r.first;\n  const vector<vector<int> >& flow = r.second;\n  cout << ans << endl;\n  vector<string> steps;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      if (flow[row][col] == 1 && write[i][j] > 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" write\";\n        steps.push_back(oss.str());\n      } else if (flow[row][col] == 0 && write[i][j] < 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" erase\";\n        steps.push_back(oss.str());\n      }\n    }\n  }\n  cout << steps.size() << endl;\n  copy(steps.begin(), steps.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n \nconst int INF = (1<<28);\n \nclass Edge\n{\npublic:\n    int src,dst,cst,cap,rev;\n    Edge(int src, int dst, int cst, int cap, int rev)\n        :src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n    {}\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n    graph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n    graph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n \npair<int, int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n  int V = graph.size();\n  vector<int> dist(V), prevv(V), preve(V);\n \n  int res = 0, fw = 0;\n  while(1) {\n    fill(dist.begin(), dist.end(), INF);\n    dist[S] = 0;\n    bool update = true;\n \n    while(update) {\n      update = false;\n      for(int v = 0; v < V; v++) {\n        if(dist[v] == INF) continue;\n \n        for(int i=0; i<graph[v].size(); i++) {\n          Edge& e = graph[v][i];\n          int cost = e.cst;\n          if(graph[e.dst][e.rev].cap != 0) cost = 0;\n \n          if(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n            dist[e.dst] = dist[e.src] + cost;\n            prevv[e.dst] = e.src;\n            preve[e.dst] = i;\n            update = true;\n          }\n        }\n      }\n    }\n \n    if(dist[T] == INF) break;\n \n    int f = INF;\n    for(int v = T; v != S; v = prevv[v])\n      f = min(f, graph[prevv[v]][preve[v]].cap);\n \n    res += dist[T];\n    fw += f;\n \n    for(int v = T; v != S; v = prevv[v]) {\n      Edge& e = graph[prevv[v]][preve[v]];\n      e.cap -= f;\n      graph[v][e.rev].cap += f;\n    }\n \n    if(fw >= L) break;\n  }\n \n  return make_pair(res, fw);\n}\n \nint ecst[100][100], icst[100][100];\nint main()\n{\n    int N;\n    cin >> N;\n    for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n        cin >> ecst[i][j];\n \n    for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n        cin >> icst[i][j];\n \n    string field[100];\n    for(int i=0; i<N; i++)\n        cin >> field[i];\n \n    Graph graph(N*2+2);\n    for(int i=0; i<N; i++) {\n        addEdge(N*2, i, 1, 0, graph);\n        addEdge(N+i, N*2+1, 1, 0, graph);\n    }\n \n    for(int i=0; i<N; i++) \n\tfor(int j=0; j<N; j++) {\n\t\tint cst = 0;\n\t\tfor(int k=0; k<N; k++) {\n\t\t\tif(field[k][j] == 'o') cst += ecst[k][j];\n\t\t\tif(field[i][k] == 'o') cst += ecst[i][k];\n\t\t}\n\n\t\tif(field[i][j] == 'o') cst -= 2*ecst[i][j];\n\t\tif(field[i][j] == '.') cst += 2*icst[i][j];\n \n        addEdge(j, i+N, 1, cst, graph);\n    }\n \n    pair<int, int> fw = minimumCostFlow(N*2, N*2+1, N, graph);\n \n\n    cout << fw.first/2 << endl;\n \n    int c = 0;\n    stringstream ss;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<graph[i].size(); j++) {\n            Edge& e = graph[i][j];\n \n            if(e.dst >= N*2) continue;\n            if(e.src >= N) continue;\n \n            if(field[e.dst-N][e.src] == 'o' && e.cap == 1) {\n                c++;\n                ss << e.dst + 1 - N << \" \" << e.src + 1 << \" erase\" << endl;\n            }\n            if(field[e.dst-N][e.src] == '.' && e.cap == 0) {\n                c++;\n                ss << e.dst + 1 - N << \" \" << e.src + 1 << \" write\" << endl;\n            }\n        }\n    }\n \n    cout << c << endl;\n    cout << ss.str();\n \n    //system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n\n        MinCostFlow solver(N + N + 2);\n        int Source = N + N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                //printf(\"%d -> %d : %d\\n\", y, sx, cost);\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        int cost = 0;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    cost += W[y][x];\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    cost += E[y][x];\n                    count++;\n                }\n            }\n        }\n        //assert(mincost == cost);\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100\n#define MAX_V 1000\n#define INF 1e9\nusing namespace std;\nint n,W[100][100],E[100][100];\nstring F[100];\nint N,K;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;     \n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint Biparite_Matching(){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  int res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(F[i][j]=='o')res+=E[i][j],add_edge(i,N+j,1,-E[i][j]);\n      else add_edge(i,N+j,1,W[i][j]);    \n  return res+min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>W[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>E[i][j];\n  for(int i=0;i<n;i++)cin>>F[i];\n  N=K=n,V=2*n+2;\n  cout<<Biparite_Matching()<<endl;\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')cnt++;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')cnt++;\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" write\"<<endl;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" erase\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cap,cost,rev;\n  edge(){}\n  edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nstruct ope{\n  int x,y,d;\n  ope(){}\n  ope(int x,int y,int d):x(x),y(y),d(d){}\n};\n\nint main(){\n  int n;\n  cin>>n;\n  int c[2][n][n];\n  for(int k=0;k<2;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcin>>c[k][i][j];\n  \n  string str[n];\n  for(int i=0;i<n;i++) cin>>str[i];\n\n  V=n*2+2;\n  int s=n*2,t=n*2+1;\n  for(int i=0;i<n;i++){\n    add_edge(s,i,1,0);\n    add_edge(n+i,t,1,0);\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int r=0;\n      for(int k=0;k<n;k++){\n\tif(k==j){\n\t  if(str[i][k]=='.') r+=c[0][i][k];\n\t}else{\n\t  if(str[i][k]=='o') r+=c[1][i][k];\n\t}\n      }\n      add_edge(i,n+j,1,r);\n    }\n  }\n  cout<<min_cost_flow(s,t,n)<<endl;\n  vector<ope> v;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j].cap) continue;\n      for(int k=0;k<n;k++){\n\tif(n+k==G[i][j].to){\n\t  if(str[i][k]=='.') v.push_back(ope(i+1,k+1,0));\n\t}else{\n\t  if(str[i][k]=='o') v.push_back(ope(i+1,k+1,1));\n\t}\n      }\n    }\n  }\n  cout<<v.size()<<endl;\n  for(int i=0;i<(int)v.size();i++)\n    cout<<v[i].x<<\" \"<<v[i].y<<\" \"<<(v[i].d?\"erase\":\"write\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-8;\nconst int INF = 1e8;\nconst D PI = acos(-1);\n\nstruct edge{\n  int from,to,cost,cap,rev;\n  bool operator<(const edge x)const{return cost<x.cost;}\n};\n\nconst int V = 210;\n\nvector<edge> G[V];  //グラフの隣接リスト\n//辺の追加。２つ目の辺の追加はフローアルゴリズムの残余グラフ用。\nvoid AddEdge(int s,int g,int c,int p){\n  G[s].pb((edge){s,g,c,p,G[g].sz});\n  G[g].pb((edge){g,s,-c,0,G[s].sz-1});  //for Max-Flow\n}\n\nint v; //グラフの頂点数\nint d[V];\nint pv[V],pe[V];  //直前の頂点と辺\n\nint primal_dual(int s,int t, int f){\n  int res = 0;\n  while(f>0){\n    fill(d,d+v,INF);\n    d[s] = 0;\n    bool update = true;\n    while(update){\n      update = false;\n      rep(u,v){\n        if(d[u]==INF)continue;\n        rep(i,G[u].sz){\n          edge &e = G[u][i];\n          if(e.cap > 0 && d[e.to] > d[u] + e.cost){\n            d[e.to] = d[u] + e.cost;\n            pv[e.to] = u; pe[e.to] = i;\n            update = true;\n          }\n        }\n      }\n    }\n    \n    if(d[t] ==INF)return -1;\n    \n    int x = f;\n    for(int u=t;u!=s;u=pv[u]){\n      x = min(x,G[pv[u]][pe[u]].cap);\n    }\n    f -= x;\n    res += x*d[t];\n    for(int u=t;u!=s;u=pv[u]){\n      edge &e = G[pv[u]][pe[u]];\n      e.cap -= x;\n      G[u][e.rev].cap += x;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  int w[110][110], e[110][110];\n  string f[110];\n\n  cin >> n;\n  rep(i,n)rep(j,n)cin >> w[i][j];\n  rep(i,n)rep(j,n)cin >> e[i][j];\n  rep(i,n)cin >> f[i];\n\n  v = 2*n + 2;\n\n  int base = 0;\n  rep(i,n){\n    AddEdge(v-2,i,0,1);\n    AddEdge(i+n,v-1,0,1);\n\n    rep(j,n){\n      if(f[i][j] == 'o')AddEdge(i,n+j,-e[i][j],1), base += e[i][j];\n      else AddEdge(i,n+j,w[i][j],1);\n    }\n  }\n\n  cout << primal_dual(v-2,v-1,n) + base << endl;\n\n  int op = 0;\n  rep(i,n){\n    rep(j,G[i].sz){\n      int from = G[i][j].from, to = G[i][j].to - n, cap = G[i][j].cap;\n      if(f[from][to] == 'o' && cap)op++;\n      if(f[from][to] == '.' && !cap)op++;\n    }\n  }\n  cout << op << endl;\n\n  rep(i,n){\n    rep(j,G[i].sz){\n      int from = G[i][j].from, to = G[i][j].to - n, cap = G[i][j].cap;\n      if(f[from][to] == 'o' && cap){\n\tcout << from+1 << \" \" << to+1 << \" erase\" << endl;\n      }\n      if(f[from][to] == '.' && !cap){\n\tcout << from+1 << \" \" << to+1 << \" write\" << endl;\n      }\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight capacity, cost;\n  int rev;\n  Edge(int src, int dst, Weight capacity, Weight cost) :\n    src(src), dst(dst), capacity(capacity), cost(cost) { }\n  Edge(int src, int dst, Weight capacity, Weight cost, int rev) :\n    src(src), dst(dst), capacity(capacity), cost(cost), rev(rev) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, Weight cap, Weight cost) {\n  g[s].push_back(Edge(s,d,cap,cost));\n  g[d].push_back(Edge(d,s,0,-cost));\n}\n\n#define RESIDUE(u,v) (capacity[u][v] - flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n\nint ans[100][100];\nint W[100][100];\nint E[100][100];\nstring F[100];\nint n,N;\n\nint SOURCE() { return n*2; }\nint SINK() { return n*2+1; }\nint ROW(int i) { return i; }\nint COL(int i) {return n+i; }\n\n\n// Dijkstra\npair<Weight, Weight> minimumCostFlow(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  REP(u,n) FOR(e,g[u]) {\n    capacity[e->src][e->dst] += e->capacity;\n    cost[e->src][e->dst] += e->cost;\n  }\n  pair<Weight, Weight> total; // (cost, flow)\n  vector<Weight> h(n, INF);\n  h[s] = 0;\n  // ベルマンフォードでポテンシャルを求めて負辺に対応\n  REP(k, n) REP(i, n) FOR(e,g[i]) if (capacity[e->src][e->dst])\n    h[e->dst] = min(h[e->dst], h[e->src] + cost[e->src][e->dst]);\n  \n  for (Weight F = INF; F > 0; ) { // residual flow\n    vector<Weight> d(n, INF); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q;\n    for (Q.push(Edge(-2, s, 0, 0)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      FOR(f, g[e.dst]) if (RESIDUE(f->src, f->dst) > 0) {\n        if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n          d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n          Q.push( Edge(f->src, f->dst, 0, d[f->dst]) );\n        }\n      }\n    }\n    if (p[t] == -1) break;    \n    Weight f = F;\n    for (int u = t; u != s; u = p[u])\n      f = min(f, RESIDUE(p[u], u));\n    for (int u = t; u != s; u = p[u]) {\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    REP(u, n) if (h[u] != INF) h[u] += d[u]; // ifいらない？\n  }\n  REP(i,N) REP(j,N) ans[i][j] = flow[ROW(i)][COL(j)];\n  return total;\n}\n\nint cost[100][100];\nint main() {\n  cin >> n;\n  N = n;\n  REP(i,n)REP(j,n)cin>>W[i][j];\n  REP(i,n)REP(j,n)cin>>E[i][j];\n  REP(i,n) cin >> F[i];\n  Graph g(n+n+2);\n  REP(i,n) {\n    REP(j,n) {\n      // cout << i << \" \" << j << \" \" << E[i][j] << \" \" << W[i][j] << endl;\n      if (F[i][j] == 'o') {\n        REP(k,n) {\n          if (k==j) continue;\n          cost[i][k] += E[i][j];\n        }\n      } else {\n        cost[i][j] += W[i][j];\n      }\n    }\n  }\n  \n  REP(i,n) REP(j,n) add_edge(g,ROW(i),COL(j),1,cost[i][j]);\n\n  // REP(i,n) {\n  //   REP(j,n) cout << cost[i][j] << \" \" ;\n  //   cout << endl;\n  // }\n  \n  REP(i,n) add_edge(g,SOURCE(),ROW(i),1,0);\n  REP(i,n) add_edge(g,COL(i),SINK(),1,0);\n  pii res = minimumCostFlow(g,SOURCE(),SINK());\n  \n  cout << res.first << endl;\n  vector<pii> ans2;\n  REP(i,n) {\n    REP(j,n) {\n      if (ans[i][j] ^ (F[i][j]=='o')) {\n        ans2.push_back(pii(i,j));\n      }\n    }\n  }\n  sort(ALL(ans2));\n  cout << ans2.size() << endl;\n  FOR(it, ans2) {\n    cout << it->first+1 << \" \" << it->second+1 << \" \";\n    if(F[it->first][it->second]=='o') cout << \"erase\";\n    else cout << \"write\";\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<vector<int>> W(n, vector<int>(n));\n\trep(i, 0, n) rep(j, 0, n) { cin >> W[i][j]; }\n\tvector<vector<int>> E(n, vector<int>(n));\n\trep(i, 0, n) rep(j, 0, n) { cin >> E[i][j]; }\n\tint ans = 0;\n\tMinimumCostFlow mcf(n*n + 2);\n\tint s = n*n, t = s + 1;\n\tvector<vector<char>> F(n, vector<char>(n));\n\trep(i, 0, n) rep(j, 0, n) { cin >> F[i][j]; }\n\trep(i, 0, n)rep(j, 0, n) {\n\t\tif (F[i][j] == 'o') {\n\t\t\tans += E[i][j];\n\t\t\tmcf.addArc(i, n + j, 1, -E[i][j]);\n\t\t}\n\t\telse {\n\t\t\tmcf.addArc(i, n + j, 1, W[i][j]);\n\t\t}\n\t}\n\trep(i, 0, n) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(i + n, t, 1, 0);\n\t}\n\tans += mcf.minimumCostFlow(s, t, n);\n\tcout << ans << endl;\n\tvector<string> op;\n\trep(i, 0, n) {\n\t\tfor (auto &e : mcf.g[i]) {\n\t\t\tint j = e.to - n;\n\t\t\tif (j >= n)continue;\n\t\t\tif (e.cap == 1 && F[i][j] == 'o') {\n\t\t\t\top.emplace_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" erase\");\n\t\t\t}\n\t\t\telse if (e.cap == 0 && F[i][j] == '.') {\n\t\t\t\top.emplace_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" write\");\n\t\t\t}\n\t\t}\n\t}\n\tcout << op.size() << endl;\n\trep(i, 0, op.size()) { cout << op[i] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge{\npublic:\n    int to, cap, cost, rev;\n    Edge(){};\n    Edge(int to0, int cap0, int cost0){to = to0; cap = cap0, cost = cost0;}\n    Edge(int to0, int cap0, int cost0, int rev0){to = to0; cap = cap0; cost = cost0; rev = rev0;}\n};\n\nint minCostFlow(const vector<vector<Edge> >& edges0, int source, int sink, int flow, vector<int>& select)\n{\n    int n = edges0.size();\n    vector<vector<Edge> > edges(n);\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge& e = edges0[i][j];\n            edges[i].push_back(Edge(e.to, e.cap, e.cost, edges[e.to].size()));\n            edges[e.to].push_back(Edge(i, 0, -e.cost, edges[i].size()-1));\n        }\n    }\n\n    vector<int> h(n, 0);\n    vector<int> prevV(n);\n    vector<int> prevE(n);\n\n    int ret = 0;\n    while(flow > 0){\n        vector<int> dist(n, INT_MAX);\n        dist[source] = 0;\n        priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n        q.push(make_pair(0, source));\n\n        while(!q.empty()){\n            pair<int, int> p = q.top();\n            q.pop();\n            int v = p.second;\n            if(dist[v] < p.first)\n                continue;\n            for(unsigned i=0; i<edges[v].size(); ++i){\n                Edge e = edges[v][i];\n                if(e.cap > 0 && dist[v] + e.cost + h[v] - h[e.to] < dist[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevV[e.to] = v;\n                    prevE[e.to] = i;\n                    q.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[sink] == INT_MAX){\n            return -1;\n        }\n        for(int i=0; i<n; ++i)\n            h[i] += dist[i];\n\n        int g = flow;\n        for(int i=sink; i!=source; i=prevV[i])\n            g = min(g, edges[prevV[i]][prevE[i]].cap);\n        for(int i=sink; i!=source; i=prevV[i]){\n            Edge& e = edges[prevV[i]][prevE[i]];\n            e.cap -= g;\n            edges[i][e.rev].cap += g;\n        }\n        flow -= g;\n        ret += g * h[sink];\n    }\n\n    n = n / 2 - 1;\n    select.resize(n);\n    for(int i=0; i<n; ++i){\n        int j = 1;\n        while(edges[i+1][j].cap == 1)\n            ++ j;\n        select[i] = j-1;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    vector<vector<int> > w(n, vector<int>(n));\n    vector<vector<int> > e(n, vector<int>(n));\n    for(int i=0; i<n*n; ++i)\n        cin >> w[i/n][i%n];\n    for(int i=0; i<n*n; ++i)\n        cin >> e[i/n][i%n];\n\n    vector<string> s(n);\n    for(int i=0; i<n; ++i)\n        cin >> s[i];\n\n    vector<vector<Edge> > edges(2*n+2);\n    for(int i=0; i<n; ++i){\n        edges[0].push_back(Edge(i+1, 1, 0));\n        edges[n+1+i].push_back(Edge(2*n+1, 1, 0));\n    }\n\n    for(int i=0; i<n; ++i){\n        int cost = 0;\n        for(int j=0; j<n; ++j){\n            if(s[i][j] == 'o')\n                cost += e[i][j];\n        }\n\n        for(int j=0; j<n; ++j){\n            int cost2 = cost;\n            if(s[i][j] == 'o')\n                cost2 -= e[i][j];\n            else\n                cost2 += w[i][j];\n            edges[i+1].push_back(Edge(n+1+j, 1, cost2));\n        }\n    }\n\n    vector<int> select;\n    cout << minCostFlow(edges, 0, 2*n+1, n, select) << endl;\n\n    int cnt = 0;\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            if((s[i][j] == 'o') ^ (j == select[i]))\n                ++ cnt;\n        }\n    }\n    cout << cnt << endl;\n\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<n; ++j){\n            if(s[i][j] == 'o' && j != select[i])\n                cout << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n            else if(s[i][j] != 'o' && j == select[i])\n                cout << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  int to,cap,cost,rev;\n};\n\nint V;\nvector<edge> G[202];\nint dist[202];\nint prevv[202],preve[202];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back({to,cap,cost,(int)G[to].size()});\n  G[to].push_back({from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  const int INF=1<<29;\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n\tif(dist[v]==INF)continue;\n\tfor(int i=0;i<G[v].size();i++){\n\t  edge &e=G[v][i];\n\t  if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t    dist[e.to]=dist[v]+e.cost;\n\t    prevv[e.to]=v;\n\t    preve[e.to]=i;\n\t    update=true;\n\t  }\n\t}\n      }\n    }\n    f--;\n    res+=dist[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap--;\n      G[v][e.rev].cap++;\n    }\n  }\n  return res;\n}\n    \n\nint main(){\n  int n;\n  cin>>n;\n  int W[100][100],E[100][100];\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      cin>>W[i][j];\n    }\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      cin>>E[i][j];\n    }\n  }\n  char F[100][101];\n  int ec=0;\n  for(int i=0;i<n;i++){\n    cin>>F[i];\n    for(int j=0;j<n;j++){\n      if(F[i][j]=='o'){\n\tec+=E[i][j];\n      }\n      add_edge(i,n+j,1,(F[i][j]=='o')?-E[i][j]:W[i][j]);\n    }\n    add_edge(2*n,i,1,0);\n    add_edge(n+i,2*n+1,1,0);\n  }\n  V=n*2+2;\n  ec+=min_cost_flow(n*2,n*2+1,n);\n  vector<int> w,e;\n  for(int i=0;i<n;i++){\n    for(auto f:G[i]){\n      int t=f.to-n;\n      if(0<=t&&t<n){\n\tif(F[i][t]=='o'^f.cap==0){\n\t  if(F[i][t]=='o'){\n\t    e.push_back(i*n+t);\n\t  }else{\n\t    w.push_back(i*n+t);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<ec<<endl;\n  cout<<e.size()+w.size()<<endl;\n  for(auto f:e){\n    cout<<f/n+1<<' '<<f%n+1<<' '<<\"erase\"<<endl;\n  }\n  for(auto f:w){\n    cout<<f/n+1<<' '<<f%n+1<<' '<<\"write\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\n#define MAX_V 10000\nint V;\n\ntypedef int Weight;\nconst Weight INF = 1000000000;\n// const Weight eps = 1e-8;\n\nstruct Edge{\n  int src, dest;\n  int cap, rev;\n  Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight h[MAX_V];                // potential\nWeight dist[MAX_V];             // minimum distance\nint prevv[MAX_V], preve[MAX_V]; // previous vertex and edge\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n  g[src].push_back((Edge){src, dest, cap, (int)g[dest].size(), weight});\n  g[dest].push_back((Edge){dest, src, 0, (int)g[src].size() - 1, -weight});\n}\n\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n  Weight res = 0; V = g.size();\n  memset(h, 0, sizeof(h));\n  typedef pair<Weight, int> P;\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second; \n      if (dist[v] < p.first) continue;\n      REP(i, g[v].size()) {\n        Edge &e = g[v][i];\n        if (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest] /* + eps */) {\n          dist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n          prevv[e.dest] = v;\n          preve[e.dest] = i;\n          que.push(P(dist[e.dest], e.dest));\n        }\n      }\n    }\n    if (dist[t] == INF) return -1;\n    REP(v, V) h[v] += dist[v];\n\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      Edge &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  //Matrix mat(n, Array(n));\n  Graph g(2*n+2);\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        //mat[i][j] = 1000 - e[i][j];\n        add_edge(g, i, n+j, 1, 1000 - e[i][j]);\n        cost += e[i][j];\n      } else {\n        //mat[i][j] = 1000 + w[i][j];\n        add_edge(g, i, n+j, 1, 1000 + w[i][j]);\n      }\n    }\n  }\n  REP(i,n) {\n    add_edge(g, n+i, 2*n+1, 1, 0);\n    add_edge(g, 2*n, i, 1, 0);\n  }\n  //auto res = hungarian(mat);\n  auto resc = min_cost_flow(g, 2*n, 2*n+1, n);\n  cout << (resc - n*1000 + cost) << endl;\n  \n  stringstream ss;\n  int count = 0;\n  REP(i,n)REP(j,n) {\n    if (g[i][j].cap == 0) {\n      if (m[i][j] == '.') {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++count;\n      }\n    } else {\n      if (m[i][j] == 'o') {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++count;\n      }\n    }\n  }\n  cout << count << endl;\n  cout << ss.str() << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n// ????°??????¨???(Min Cost Flow)\n\ntemplate <class T> class MinCostFlow{\npublic:\n  void addEdge(int from, int dest, int capacity, T cost);\n  void terminateNegativeLoop(); // This requires all negative loops to be touched.\n  T minCostFlow(int flow_source, int flow_target, int flow);\n \n  MinCostFlow(int vertex_num);\n  MinCostFlow(){}\n \nprivate:\n  class Edge{\n  public:\n    int dest;\n    int capacity;\n    int reversed_index;\n    T cost;\n    \n    Edge(int dest, int capacity, int reversed_index, T cost){\n      this->dest = dest;\n      this->capacity = capacity;\n      this->reversed_index = reversed_index;\n      this->cost = cost;\n    }\n  };\n  T negative_loop_cost;\npublic:\n  int vertex_num;\n  std::vector<std::vector<Edge>> edges;\n};\n \ntemplate <class T>\ninline MinCostFlow<T>::MinCostFlow(int vertex_num){\n  this->vertex_num = vertex_num;\n  negative_loop_cost = 0;\n  edges = std::vector<std::vector<Edge>>(vertex_num);\n}\n \ntemplate <class T>\ninline void MinCostFlow<T>::addEdge(int from, int dest, int capacity, T cost){\n  Edge e0(dest, capacity, edges[dest].size(),  cost);\n  Edge e1(from,        0, edges[from].size(), -cost);\n  edges[from].push_back(e0);\n  edges[dest].push_back(e1);\n}\n \ntemplate <class T>\ninline T MinCostFlow<T>::minCostFlow(int flow_source, int flow_target, int flow){\n  std::vector<std::tuple<T, bool>> costs(vertex_num);\n  T total = 0;\n  std::vector<int> pre_v(vertex_num);\n  std::vector<int> pre_e(vertex_num);\n  while(0 < flow){\n    for(int vertex = 0; vertex < vertex_num; ++vertex) costs[vertex] = std::make_tuple(0, false);\n    costs[flow_source] = std::make_tuple(0, true);\n    for(bool updated = true; updated;){\n      updated = false;\n      for(int vertex = 0; vertex < vertex_num; ++vertex){\n        if(!std::get<1>(costs[vertex])) continue;\n        for(int edge_index = 0; edge_index < edges[vertex].size(); ++edge_index){\n          Edge &e = edges[vertex][edge_index];\n          if(e.capacity == 0) continue;\n          if(std::get<1>(costs[e.dest]) && std::get<0>(costs[e.dest]) <= std::get<0>(costs[vertex]) + e.cost) continue;\n          costs[e.dest] = std::make_tuple(std::get<0>(costs[vertex]) + e.cost, true);\n          pre_v[e.dest] = vertex;\n          pre_e[e.dest] = edge_index;\n          updated = true;\n        }\n      }\n    }\n    if(!std::get<1>(costs[flow_target])) return -1;\n    int minimum_flow = flow;\n    for(int vertex = flow_target; vertex != flow_source; vertex = pre_v[vertex]){\n      minimum_flow = std::min(minimum_flow, edges[pre_v[vertex]][pre_e[vertex]].capacity);\n    }\n    flow -= minimum_flow;\n    \n    total += minimum_flow * std::get<0>(costs[flow_target]);\n    for(int vertex = flow_target; vertex != flow_source; vertex = pre_v[vertex]){\n      Edge &e = edges[pre_v[vertex]][pre_e[vertex]];\n      e.capacity -= minimum_flow;\n      edges[vertex][e.reversed_index].capacity += minimum_flow;\n    }\n  }\n  return total + negative_loop_cost;\n}\n \ntemplate <class T> \nvoid MinCostFlow<T>::terminateNegativeLoop(){\n  std::vector<int> pre_v(vertex_num);\n  std::vector<int> pre_e(vertex_num);\n  std::vector<int> used(vertex_num);\n  std::vector<T> distances(vertex_num);\n \n  while(true){\n    int vertex_in_loop = -1;\n    for(int i = 0; i < vertex_num; i++) used[i] = distances[i] = 0;\n    for(int step = 0; step <= vertex_num; ++step){\n      bool updated=false;\n      for(int vertex = 0; vertex < vertex_num; ++vertex){\n        for(int edge_index = 0; edge_index < edges[vertex].size(); ++edge_index){\n          Edge &e = edges[vertex][edge_index];\n          if(e.capacity == 0 || distances[e.dest] <= distances[vertex] + e.cost) continue;\n          distances[e.dest] = distances[vertex] + e.cost;\n          pre_v[e.dest] = vertex;\n          pre_e[e.dest] = edge_index;\n          vertex_in_loop = e.dest;\n          updated = true;\n        }\n      }\n      if(!updated) return;\n    }\n \n    for(; !used[vertex_in_loop]; vertex_in_loop = pre_v[vertex_in_loop]) used[vertex_in_loop] = true;\n    \n    T total_cost = 0;\n    int minimum_capacity = edges[pre_v[vertex_in_loop]][pre_e[vertex_in_loop]].capacity;\n    int cur = vertex_in_loop;\n    do{\n      total_cost += edges[pre_v[cur]][pre_e[cur]].cost;\n      minimum_capacity = std::min(minimum_capacity, edges[pre_v[cur]][pre_e[cur]].capacity);\n      cur = pre_v[cur];\n    }while(cur != vertex_in_loop);\n \n    negative_loop_cost += total_cost * minimum_capacity;\n    \n    cur = vertex_in_loop;\n    do{\n      Edge &e = edges[pre_v[cur]][pre_e[cur]];\n      e.capacity -= minimum_capacity;\n      edges[cur][e.reversed_index].capacity += minimum_capacity;\n      cur = pre_v[cur];\n    }while(cur != vertex_in_loop);\n  }\n}\nvoid mainmain(){\n    int n;\n    cin>>n;\n    vvint wcost,ecost;\n    initvv(ecost,n,n);\n    initvv(wcost,n,n);\n    rep(i,n) rep(j,n) cin>>wcost[i][j];\n    rep(i,n) rep(j,n) cin>>ecost[i][j];\n    vector<string> vs(n);\n    rep(i,n) cin>>vs[i];\n    MinCostFlow<int> mf(300);\n    int start=2*n+1;\n    int goal=2*n+2;\n    rep(i,n){\n        mf.addEdge(start,i,1,0);\n        mf.addEdge(n+i,goal,1,0);\n    }\n    rep(i,n){\n        int tt=0;\n        rep(j,n) if(vs[i][j]=='o') tt+=ecost[i][j];\n        rep(j,n){\n            int t;\n            if(vs[i][j]=='o'){\n                t=tt-ecost[i][j];\n            }\n            else{\n                t=tt+wcost[i][j];\n            }\n            // cout<<i<<\" \"<<j<<\" \"<<t<<endl;\n            mf.addEdge(i,n+j,1,t);\n        }\n    }\n    int ans=mf.minCostFlow(start,goal,n);\n    vector<pair<pii,string>> tmp;\n    rep(i,n){\n        rep(j,n){\n            bool f=false;\n            for(auto x:mf.edges[i]){\n                if(x.capacity==0&&x.dest==j+n) f=true;\n            }\n            if(vs[i][j]=='o'&&!f){\n                tmp.PB(mkp(pii(i+1,j+1),\"erase\"));\n            }\n            if(vs[i][j]=='.'&&f){\n                tmp.PB(mkp(pii(i+1,j+1),\"write\"));\n            }\n        }\n    }\n    cout<<ans<<endl;\n    cout<<tmp.size()<<endl;\n    rep(i,tmp.size()){\n        cout<<tmp[i].F.F<<\" \"<<tmp[i].F.S<<\" \"<<tmp[i].S<<endl;\n    }\n    // cout<<mf.minCostFlow(start,goal,n)<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cout<<fixed<<setprecision(0);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define INF 1e9\n#define N 105\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint wcost[N][N],ecost[N][N];\nstring s[N];\nint n,cost[N][N];\n\nint make_cost(int y,int x){\n  int res=0,cnt=0;\n  for(int i=0;i<n;i++)\n    if(i!=x&&s[y][i]=='o')res+=ecost[y][i],cnt++;\n  if(s[y][x]=='.')res+=wcost[y][x],cnt++;\n  cost[y][x]=cnt;\n  return res;\n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>wcost[i][j];\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>ecost[i][j];\n\n  for(int i=0;i<n;i++) cin>>s[i];\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      add_edge(i,j+n,1,make_cost(i,j));\n\n  int S=n*2,T=S+1;\n  for(int i=0;i<n;i++){\n    add_edge(S,i,1,0);\n    add_edge(i+n,T,1,0);\n  }\n\n  V=n*2+2;\n  cout<<min_cost_flow(S,T,n)<<endl;\n\n  int cnt=0;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(!G[i][j].cap)cnt+=cost[i][G[i][j].to-n];\n  \n  cout<<cnt<<endl;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(!G[i][j].cap){\n\tif(s[i][G[i][j].to-n]=='.')\n\t  cout<<i+1<<' '<<G[i][j].to-n+1<<' '<<\"write\"<<endl;\n\tfor(int k=0;k<n;k++)\n\t  if(G[i][j].to-n!=k&&s[i][k]=='o')\n\t    cout<<i+1<<' '<<k+1<<' '<<\"erase\"<<endl;\n      }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 2000\n#define INF (1<<26)\ntypedef pair<int,int > P;\nstruct edge{int to,cap,cost,rev;};\n \nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n      dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n      prevv[e.to]=v;\n      preve[e.to]=i;\n      que.push(P(dist[e.to],e.to));\n    }\n      }\n    }\n   \n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n \nint n;\nint t[200][200],u[200][200];\nchar a[200][200],b[200][200];\n \nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>u[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>a[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      b[i][j]='.';\n \n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int sum=0;\n      if(a[i][j]=='.'){\n    sum+=t[i][j]*2;\n    for(int k=0;k<n;k++){\n      if(a[i][k]=='o')sum+=u[i][k];\n      if(a[k][j]=='o')sum+=u[k][j];\n    }\n      }else{\n    for(int k=0;k<n;k++){\n      if(k!=j&&a[i][k]=='o')sum+=u[i][k];\n      if(k!=i&&a[k][j]=='o')sum+=u[k][j];\n    }   \n      }\n      add_edge(i,n+j,1,sum);\n    }\n  }\n  for(int i=0;i<n;i++){\n    add_edge(n+n,i,1,0);\n    add_edge(n+i,n+n+1,1,0);\n  }\n  V=n+n+2;\n  cout<<min_cost_flow(n+n,n+n+1,n)/2<<endl;\n \n \n   \n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      edge e=G[i][j];\n       \n      if(e.cap==0&&n<=e.to&&e.to<n+n){\n    b[i][e.to-n]='o';\n      }\n    }\n  }\n \n \n  vector<P> ans;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i][j]==b[i][j])continue;\n      ans.push_back(P(i,j));\n    }\n  }\n   \n  cout<<ans.size()<<endl;\n  for(int i=0;i<(int)ans.size();i++){\n    P p=ans[i];\n    if(a[p.first][p.second]=='.'){\n      cout<<p.first+1<<\" \"<<p.second+1<<\" write\"<<endl;\n    }else{\n      cout<<p.first+1<<\" \"<<p.second+1<<\" erase\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\n\nint G[MAX_V][MAX_V];\nint hl[MAX_V], hr[MAX_V], dist[MAX_V*2+2];\nint prevvl[MAX_V], prevvr[MAX_V];\nbool used[MAX_V*2+2];\nbool flow[MAX_V][MAX_V] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(hl, l+1, 0);\n\tfill_n(hr, r+1, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            int dist2 = 0;\n            int flag;\n            for (int i = 0; i < l+1; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist2)){\n                    v = i;\n                    dist2 = dist[i];\n                    flag = true;\n                }\n            }\n            for (int i = 0; i < r+1; i++) {\n                if (!used[i+l+1] && (v == -1 || dist[i+l+1] < dist2)){\n                    v = i;\n                    dist2 = dist[i+l+1];\n                    flag = false;\n                }\n            }\n            if (v == -1) break;\n            if (flag) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && dist[i+l+1] > dist[v] + G[v][i] + hl[v] - hr[i]) {\n\t\t\t\t\t\tdist[i+l+1] = dist[v] + G[v][i] + hl[v] - hr[i];\n\t\t\t\t\t\tprevvr[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v+l+1] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v] && dist[i] > dist[v+l+1] - G[i][v] + hr[v] - hl[i]) {\n\t\t\t\t\t\tdist[i] = dist[v+l+1] - G[i][v] + hr[v] - hl[i];\n\t\t\t\t\t\tprevvl[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+1; v++) {\n\t\t\thl[v] += dist[v];\n\t\t}\n\t\tfor (int v = 0; v < r+1; v++) {\n\t\t\thr[v] += dist[v+l+1];\n\t\t}\n\t\tres += hl[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevvl[v] : prevvr[v], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevvl[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevvr[v]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\nconst int INF=99999999;\n#define MAX_V 100*2+2\nstruct edge{\n\tint to,cap,cost,rev;\n\tedge(int to,int cap=0,int cost=0,int rev=-1):\n\tto(to),cap(cap),cost(cost),rev(rev)\n{}\n};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\n//to から dst へ向かう容量 cap,コストcost の辺をグラフに追加する\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back( edge(to,cap,cost,G[to].size()) );\n\tG[to].push_back( edge(from,0,-cost,G[from].size()-1) );\n}\n// s から t への流量 f の最小費用流を求める\n// 流せない場合は-1を返す\n// 流量がdouble の場合は誤差死に注意\nint n;\nchar c[100][100];\n\nint min_cost_flow(int s,int t,int f){\n\tint res = 0;\n\twhile(f>0){\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v=0;v<V;v++){\n\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\tfor(int i=0;i<G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF) return -1;\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]) d=min(d, G[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres += d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t//\tif(n<=v && v<2*n){\n\t\t//\t\tc[prevv[v]][v-n] = 'o';\n\t\t//\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstring Map[100];\nint E[100][100];\nint W[100][100];\nmain(){\n\tint i,j,ans=0;\n\tcin >> n;\n\tV = 2*n+2;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tcin >> W[i][j];\n\t\t\tc[i][j] = '.';\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tcin >> Map[i];\n\t}\n\tfor(i=0;i<n;i++){\n\t\tadd_edge(2*n, i, 1, 0);\n\t\tadd_edge(i+n, 2*n+1, 1, 0);\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(Map[i][j] == 'o'){\n\t\t\t\tans += E[i][j];\n\t\t\t\tadd_edge(i, n+j, 1, 1000-E[i][j]);\n\t\t\t}else{\n\t\t\t\tadd_edge(i, n+j, 1, 1000+W[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans + min_cost_flow(2*n, 2*n+1, n) - 1000*n << endl;\n\n\tint cnt = 0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<G[i].size();j++){\n\t\t\tint to = G[i][j].to;\n\t\t\tif(G[i][j].cap || 2*n<=to) continue;\n\t\t\tc[i][to-n] = 'o';\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(Map[i][j] != c[i][j]) cnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(c[i][j] != Map[i][j]){\n\t\t\t\tif(Map[i][j] == 'o') cout << i+1 << \" \" << j+1 << \" erase\" << endl;\n\t\t\t\telse cout << i+1 << \" \" << j+1 << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n\n        MinCostFlow solver(N * N + 2);\n        int Source = N * N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    count++;\n                }\n            }\n        }\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<vector<int>> W(n, vector<int>(n));\n\trep(i, 0, n) rep(j, 0, n) { cin >> W[i][j]; }\n\tvector<vector<int>> E(n, vector<int>(n));\n\trep(i, 0, n) rep(j, 0, n) { cin >> E[i][j]; }\n\tint ans = 0;\n\tMinimumCostFlow mcf(n + n + 2);\n\tint s = n + n, t = s + 1;\n\tvector<vector<char>> F(n, vector<char>(n));\n\trep(i, 0, n) rep(j, 0, n) { cin >> F[i][j]; }\n\trep(i, 0, n)rep(j, 0, n) {\n\t\tif (F[i][j] == 'o') {\n\t\t\tans += E[i][j];\n\t\t\tmcf.addArc(i, n + j, 1, -E[i][j]);\n\t\t}\n\t\telse {\n\t\t\tmcf.addArc(i, n + j, 1, W[i][j]);\n\t\t}\n\t}\n\trep(i, 0, n) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(i + n, t, 1, 0);\n\t}\n\tans += mcf.minimumCostFlow(s, t, n);\n\tcout << ans << endl;\n\tvector<string> op;\n\trep(i, 0, n) {\n\t\tfor (auto &e : mcf.g[i]) {\n\t\t\tint j = e.to - n;\n\t\t\tif (j >= n)continue;\n\t\t\tif (e.cap == 1 && F[i][j] == 'o') {\n\t\t\t\top.emplace_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" erase\");\n\t\t\t}\n\t\t\telse if (e.cap == 0 && F[i][j] == '.') {\n\t\t\t\top.emplace_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" write\");\n\t\t\t}\n\t\t}\n\t}\n\tcout << op.size() << endl;\n\trep(i, 0, op.size()) { cout << op[i] << endl; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 2000\n#define INF (1<<26)\ntypedef pair<int,int > P;\nstruct edge{int to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n  \n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint t[200][200],u[200][200];\nchar a[200][200],b[200][200];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>u[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>a[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      b[i][j]='.';\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int sum=0;\n      if(a[i][j]=='.'){\n\tsum+=t[i][j]*2;\n\tfor(int k=0;k<n;k++){\n\t  if(a[i][k]=='o')sum+=u[i][k];\n\t  if(a[k][j]=='o')sum+=u[k][j];\n\t}\n      }else{\n\tfor(int k=0;k<n;k++){\n\t  if(k!=j&&a[i][k]=='o')sum+=u[i][k];\n\t  if(k!=i&&a[k][j]=='o')sum+=u[k][j];\n\t}\t\n      }\n      add_edge(i,n+j,1,sum);\n    }\n  }\n  for(int i=0;i<n;i++){\n    add_edge(n*n,i,1,0);\n    add_edge(n+i,n*n+1,1,0);\n  }\n  V=n*n+2;\n  cout<<min_cost_flow(n*n,n*n+1,n)/2<<endl;\n\n\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      edge e=G[i][j];\n      \n      if(e.cap==0&&n<=e.to&&e.to<n*n){\n\tb[i][e.to-n]='o';\n      }\n    }\n  }\n\n\n  vector<P> ans;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i][j]==b[i][j])continue;\n      ans.push_back(P(i,j));\n    }\n  }\n  \n  cout<<ans.size()<<endl;\n  for(int i=0;i<(int)ans.size();i++){\n    P p=ans[i];\n    if(a[p.first][p.second]=='.'){\n      cout<<p.first+1<<\" \"<<p.second+1<<\" write\"<<endl;\n    }else{\n      cout<<p.first+1<<\" \"<<p.second+1<<\" erase\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\n\nint G[MAX_V][MAX_V];\nint hl[MAX_V], hr[MAX_V], distl[MAX_V], distr[MAX_V];\nint prevvl[MAX_V], prevvr[MAX_V];\nbool usedl[MAX_V], usedr[MAX_V];\nbool flow[MAX_V][MAX_V] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(hl, l+1, 0);\n\tfill_n(hr, r+1, 0);\n\twhile (true) {\n\t\tfill_n(distl, l+1, INT_INF);\n\t\tfill_n(distr, r+1, INT_INF);\n\t\tdistr[r] = 0;\n        fill_n(usedl, l+1, false);\n        fill_n(usedr, r+1, false);\n        while (true) {\n            int v = -1;\n            int dist = 0;\n            int flag;\n            for (int i = 0; i < l+1; i++) {\n                if (!usedl[i] && (v == -1 || distl[i] < dist)){\n                    v = i;\n                    dist = distl[i];\n                    flag = true;\n                }\n            }\n            for (int i = 0; i < r+1; i++) {\n                if (!usedr[i] && (v == -1 || distr[i] < dist)){\n                    v = i;\n                    dist = distr[i];\n                    flag = false;\n                }\n            }\n            if (v == -1) break;\n            if (flag) {\n            \tusedl[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && distr[i] > distl[v] + G[v][i] + hl[v] - hr[i]) {\n\t\t\t\t\t\tdistr[i] = distl[v] + G[v][i] + hl[v] - hr[i];\n\t\t\t\t\t\tprevvr[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tusedr[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v] && distl[i] > distr[v] - G[i][v] + hr[v] - hl[i]) {\n\t\t\t\t\t\tdistl[i] = distr[v] - G[i][v] + hr[v] - hl[i];\n\t\t\t\t\t\tprevvl[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (distl[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+1; v++) {\n\t\t\thl[v] += distl[v];\n\t\t}\n\t\tfor (int v = 0; v < r+1; v++) {\n\t\t\thr[v] += distr[v];\n\t\t}\n\t\tres += hl[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevvl[v] : prevvr[v], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevvl[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevvr[v]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef int Capacity;\ntypedef int Cost;\nstruct PrimalDual {\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge; bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n    enum : int { MAX_V = 1000000 };\n\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n        g[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n    }\n\n    int mcf(int s, int t, int f) {\n        int res = 0;\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n        static Cost h[MAX_V], dist[MAX_V];\n        static int prevv[MAX_V], preve[MAX_V];\n        rep(i,n)h[i] = 0;\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            rep(i,n) dist[i] = inf;\n            dist[s] = 0;\n            q.emplace(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.emplace(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.mcf(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\n int main(){\n     N=n*2+2;\n     rep(i,n)rep(j,n)scanf(\"%d\",&W[i][j]);\n     rep(i,n)rep(j,n)scanf(\"%d\",&E[i][j]);\n     rep(i,n)scanf(\"%s\",f[i]);\n     solve();\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 514\n#define INF (1<<29)\n\nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int cost, int rev) :\n        to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\nint V;\nvector<Edge> G[MAX_V];\nint dist[MAX_V], prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f)\n{\n    int res = 0;\n    while (f > 0) {\n\tfill(dist, dist + V, INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile (update) {\n\t    update = false;\n\t    for (int v = 0; v < V; v++) {\n\t\tif (dist[v] == INF) continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t    Edge &e = G[v][i];\n\t\t    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (dist[t] == INF) return -1;\n\tint d = f;\n\tfor (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\t}\n        f -= d;\n\tres += d * dist[t];\n\tfor (int v = t; v != s; v = prevv[v]) {\n\t    Edge &e = G[prevv[v]][preve[v]];            \n\t    e.cap -= d;\n\t    G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<vector<int>> W(N, vector<int>(N)), E(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> W[i][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> E[i][j];\n        }\n    }\n    \n    int sum = 0;\n    vector<vector<char>> F(N, vector<char>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> F[i][j];\n            if (F[i][j] == 'o') {\n                sum += E[i][j];\n            }\n        }\n    }\n\n    int S = 2 * N, T = S + 1;\n    V = T + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(S, i, 1, 0);\n        add_edge(N+i, T, 1, 0);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (F[i][j] == 'o') {\n                add_edge(i, j + N, 1, -E[i][j]);\n            } else {\n                add_edge(i, j + N, 1, W[i][j]);\n            }\n        }\n    }\n    \n    cout << min_cost_flow(S, T, N) + sum << endl;\n    vector<int> r, c, op;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int k = G[i][j].to - N;\n            if (G[i][j].cap == 0 && F[i][k] == '.' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(0);\n            }\n            if (G[i][j].cap > 0 && F[i][k] == 'o' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(1);\n            }\n        }\n    }\n\n    cout << r.size() << endl;\n    for (int i = 0; i < (int)r.size(); i++) {\n        cout << r[i] << \" \" << c[i] << \" \";\n        cout << (op[i] == 0 ? \"write\" : \"erase\") << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=(b-1);i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\n#define MAX_V 210\n#define INF 1000000000000000000LL\n\ntypedef pair<long long, long long> P;\nstruct edge{long long to, cap, cost, rev;};\nvector<edge> G[MAX_V];\nlong long h[MAX_V];\nlong long dist[MAX_V];\nlong long prevv[MAX_V];\nlong long preve[MAX_V];\n\nvoid ae(long long from, long long to, long long cap, long long cost){\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nlong long minCostFlow(long long s, long long t, long long f, long long V){\n  long long res = 0;\n  memset(h,0,sizeof(h));\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    for(long long i = 0; i < V; i++){\n      dist[i] = INF;\n    }\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      long long v = p.second;\n      if(dist[v] < p.first)continue;\n      for(long long i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == INF){\n      return -1;\n    }\n    for(long long v = 0; v < V; v++){\n      h[v] += dist[v];\n    }\n    long long d = f;\n    for(long long v = t; v != s; v = prevv[v]){\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(long long v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nll dw[110][110];\nll de[110][110];\nvector<string> vs;\n\nint main(){\n    ll n;\n    cin>>n;\n    rep(y,0,n){\n        rep(x,0,n){\n            ll a;\n            cin>>a;\n            dw[y][x] = a;\n        }\n    }\n    rep(y,0,n){\n        rep(x,0,n){\n            ll a;\n            cin>>a;\n            de[y][x] = a;\n        }\n    }\n    rep(i,0,n){\n        string s;\n        cin>>s;\n        vs.pb(s);\n    }\n    rep(y,0,n){\n        rep(x,0,n){\n            ll c = 0;\n            if(vs[y][x] == '.')c += dw[y][x];\n            rep(i,0,n){\n                if(i==x)continue;\n                if(vs[y][i]=='o')c += de[y][i];\n            }\n            ae(y,n+x,1,c);\n        }\n    }\n    ll start = 2*n;\n    ll end = 2*n+1;\n    rep(i,0,n){\n        ae(start,i,1,0);\n    }\n    rep(i,0,n){\n        ae(n+i,end,1,0);\n    } \n    ll ans = minCostFlow(start,end,n,2*n+2);\n    ll dd[110][110];\n    clr(dd,0);\n    rep(y,0,n){\n        rep(x,0,n){\n            rep(i,0,G[y].sz){\n                edge e = G[y][i];\n                if(e.cap==0){\n                    dd[y][e.to-n] = 1;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    ll c = 0;\n    rep(y,0,n){\n        rep(x,0,n){\n            if(vs[y][x]=='o'&&dd[y][x]==0){\n                c++;\n            }\n            if(vs[y][x]=='.'&&dd[y][x]==1){\n                c++; \n            }\n        }\n    }\n    cout << c << endl;\n    rep(y,0,n){\n        rep(x,0,n){\n            if(vs[y][x]=='o'&&dd[y][x]==0){\n                cout << \"erase \" << y+1 << \" \" << x+1 << endl; \n            }\n            if(vs[y][x]=='.'&&dd[y][x]==1){\n                cout << \"write \" << y+1 << \" \" << x+1 << endl; \n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nstruct edge/*{{{*/\n{\n  int to;\n  int capacity;\n  int cost;\n  edge(int i, int c, int d) : to(i), capacity(c), cost(d) {}\n};/*}}}*/\n\npair<int,vector<vector<int> > > primal_dual(const vector<vector<edge> >& g, int source, int sink)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)), flow(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<edge>::const_iterator it = g[i].begin(); it != g[i].end(); ++it) {\n      capacity[i][it->to] += it->capacity;\n      cost[i][it->to] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  static const int INF = 10000000;\n  for (int f = INF; f > 0; ) {\n    vector<int> dist(N, INF);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<edge>::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (capacity[n][it->to] - flow[n][it->to] > 0) {\n          const int c2 = c + cost[n][it->to] + h[n] - h[it->to];\n          if (c2 < dist[it->to]) {\n            dist[it->to] = c2;\n            parent[it->to] = n;\n            q.push(make_pair(-c2, it->to));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return make_pair(total.first, flow);\n}/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > erase(N, vector<int>(N)), write(N, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> erase[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> write[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    string s;\n    cin >> s;\n    int sum = 0;\n    for (int j = 0; j < N; j++) {\n      if (s[j] == 'o') {\n        sum += erase[i][j];\n      }\n    }\n    for (int j = 0; j < N; j++) {\n      if (s[j] == 'o') {\n        write[i][j] = sum - erase[i][j];\n        erase[i][j] = 0;\n      } else {\n        write[i][j] += sum;\n      }\n    }\n  }\n\n  vector<vector<edge> > g(2*N+2);\n  const int source = 2*N, sink = 2*N+1;\n  for (int i = 0; i < N; i++) {\n    const int row = i, col = N+i;\n    g[source].push_back(edge(row, 1, 0));\n    g[col].push_back(edge(sink, 1, 0));\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      g[row].push_back(edge(col, 1, write[i][j]));\n      g[col].push_back(edge(row, 0, -write[i][j]));\n    }\n  }\n\n  const pair<int,vector<vector<int> > > r = primal_dual(g, source, sink);\n  cout << r.first << endl;\n  const vector<vector<int> >& flow = r.second;\n  vector<string> steps;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      if (flow[row][col] == 1 && erase[i][j] > 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" write\";\n        steps.push_back(oss.str());\n    } else if (flow[row][col] == 0 && erase[i][j] == 0) {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" erase\";\n        steps.push_back(oss.str());\n      }\n    }\n  }\n  cout << steps.size() << endl;\n  copy(steps.begin(), steps.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define BiSearchRangeNum(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y)\n#define deg_to_rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad_to_deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\nstatic const int INF = (1<<30);\n\nstruct PrimalDual {\n  struct edge {\n    int to, cap, icap, cost, rev;\n  };\n\n  vector<vector<edge>> G;\n  vector<int> potential, min_cost;\n  vector<int> prevv, preve;\n\n  PrimalDual(int V): G(V) {}\n\n  void add_edge(int from ,int to, int cap, int cost) {\n    G[from].pb((edge) { to, cap, cap, cost, (int) G[to].size() });\n    // capそのままでcostをマイナスにする\n    G[to].pb((edge) { from, 0, 0, -cost, (int) G[from].size()-1 });\n  }\n\n  int min_cost_flow(int s, int t, int f) {\n    int V = (int) G.size();\n    int ret = 0;\n    // <cost, node番号>\n    using Pi = pair<int, int>;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    // potentialを0で初期化\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while (f > 0) {\n      min_cost.assign(V, INF);\n      // 始点追加\n      que.push(make_pair(0, s));\n      min_cost[s] = 0;\n      while (!que.empty())  {\n        Pi p = que.top();\n        que.pop();\n        // 次のノード番号までのコストがそもそもp.firstより小さいのでskip\n        if (min_cost[p.second] < p.first) continue;\n        // 次のノードから出ている全エッジに対して\n        rep(i, 0, G[p.second].size()) {\n          edge &e = G[p.second][i];\n          // このエッジを採用した時のノードe.toへのコスト\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if (e.cap > 0 && min_cost[e.to] > nextCost) {\n            // 最小コストをupdate\n            min_cost[e.to] = nextCost;\n            // e.toの一つ前のノードはp.second\n            prevv[e.to] = p.second;\n            // e.toへのエッジはp.secondのi番目のエッジ\n            preve[e.to] = i;\n            // G[prevv[e.to]][preve[e.to]]でe.toに至るエッジを検出可\n            // <次のnodeまでのcost, 次のnode番号>をpush\n            que.push(make_pair(min_cost[e.to], e.to));\n          }\n        }\n      }\n      // そもそも与えられたフローでtへ到達不能-1を返す\n      if (min_cost[t] == INF) return -1;\n\n      rep(v, 0, V) {\n        potential[v] += min_cost[v];\n      }\n      int add_flow = f;\n      // sからtまでの中で最小の容量のエッジを検出\n      for (int v = t; v != s; v = prevv[v]) {\n        add_flow = min(add_flow, G[prevv[v]][preve[v]].cap);\n      }\n      f -= add_flow;\n      ret += add_flow * potential[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= add_flow;\n        G[v][e.rev].cap += add_flow;\n      }\n    }\n\n    return ret;\n  }\n};\n\n// AOJ marukaite\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int>> W(n, vector<int> (n));\n  vector<vector<int>> E(n, vector<int> (n));\n  vector<vector<char>> F(n, vector<char> (n));\n  rep(i, 0, n) {\n    rep(j, 0, n) {\n      scanf(\"%d\", &W[i][j]);\n    }\n  }\n  rep(i, 0, n) {\n    rep(j, 0, n) {\n      scanf(\"%d\", &E[i][j]);\n    }\n  }\n\n  int S = 2 * n;\n  int T = 2 * n + 1;\n  int B = 1000;\n  int ans = 0;\n\n  struct PrimalDual pd(2 * n + 2);\n\n  rep(i, 0, n) {\n    string s;\n    cin >> s;\n    rep(j, 0, n) {\n      F[i][j] = s[j];\n      // costを0ではなくmaxのB(=1000)を基準にする\n      if (F[i][j] == 'o') {\n        pd.add_edge(i, n + j, 1, B - E[i][j]);\n        ans += E[i][j]; // 後ほど調節のため\n      } else {\n        pd.add_edge(i, n + j , 1, B + W[i][j]);\n      }\n    }\n  }\n\n  rep(i, 0, n) {\n    pd.add_edge(S, i, 1, 0);\n    pd.add_edge(i + n , T, 1, 0);\n  }\n\n  int res = pd.min_cost_flow(S, T, n);\n  ans = ans + res - n * B;\n\n  vector<pair<int, int>> query;\n  rep(i, 0, n) {\n    rep(j, 0, n) {\n      // oに選ばれた\n      if (pd.G[i][j].cap == 0 && pd.G[i][j].icap == 1) {\n        if (F[i][j] == '.') {\n          query.pb({ i, j });\n        }\n      } else { // xに選ばれた\n        if (F[i][j] == 'o') {\n          query.pb({ i, j});\n        }\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n  printf(\"%d\\n\", (int) query.size());\n  rep(i, 0, query.size()) {\n    int y = query[i].first;\n    int x = query[i].second;\n\n    printf(\"%d %d\", y+1, x+1);\n    if (F[y][x] == 'o') puts(\"erase\");\n    if (F[y][x] == '.') puts(\"write\");\n  }\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <limits>\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nclass CostFlow\n{\npublic:\n    using Cost = int;\n    using Ind = int;\n    using Capacity = int;\n    using T = int;\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}\n    {\n        edge.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // // Bellman-Ford(Replace this when DAG)\n        // for (int i = 0; i < V; i++) {\n        //     m_potential[i] = INF<T>;\n        // }\n        // m_potential[s] = 0;\n        // bool no_negative_loop = true;\n        // for (int i = 0; i < V; i++) {\n        //     for (int v = 0; v < V; v++) {\n        //         if (m_potential[v] != INF<T>) {\n        //             for (const auto& e : edge[v]) {\n        //                 if (e.capacity <= 0) {\n        //                     continue;\n        //                 }\n        //                 if (m_potential[e.to] > m_potential[v] + e.cost) {\n        //                     m_potential[e.to] = m_potential[v] + e.cost;\n        //                     if (i == V - 1) {\n        //                         m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n        //                         no_negative_loop = false;\n        //                     }\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // if (not no_negative_loop) {\n        //     // ????????¨?????????\n        // }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                //                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> m_dist;\n    vector<Cost> m_potential;\n    vector<Ind> m_prev_v;\n    vector<Ind> m_prev_e;\n};\n\nstruct Ope {\n    bool o;\n    int r;\n    int c;\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> W(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n    vector<vector<int>> E(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    vector<vector<bool>> use(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n; j++) {\n            use[i][j] = (s[j] == 'o');\n        }\n    }\n\n    vector<vector<int>> c(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (not use[i][j]) {\n                c[i][j] = W[i][j];\n            } else {\n                for (int k = 0; k < n; k++) {\n                    if (j == k) {\n                        continue;\n                    }\n                    c[i][k] += E[i][j];\n                }\n                for (int k = 0; k < n; k++) {\n                    if (i == k) {\n                        continue;\n                    }\n                    c[k][j] += E[i][j];\n                }\n            }\n        }\n    }\n\n    CostFlow flow(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            flow.addEdge(i, j + n, 1, c[i][j]);\n        }\n    }\n    const int s = 2 * n;\n    const int t = 2 * n + 1;\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(s, i, 1, 0);\n        flow.addEdge(n + i, t, 1, 0);\n    }\n    cout << flow.minCostFlow(s, t, n) << endl;\n\n    set<int> node;\n    node.insert(s);\n    vector<Ope> op;\n    for (int i = 0; i < n; i++) {\n        for (const auto& e : flow.edge[i]) {\n            if (e.is_reverse) {\n                continue;\n            }\n            if (e.flow == 1) {\n                if (not use[i][e.to - n]) {\n                    op.push_back(Ope{false, i, e.to - n});\n                }\n            } else {\n                if (use[i][e.to - n]) {\n                    op.push_back(Ope{true, i, e.to - n});\n                }\n            }\n        }\n    }\n\n    cout << op.size() << endl;\n    for (const auto& o : op) {\n        cout << o.r + 1 << \" \" << o.c + 1 << \" \" << (o.o ? \"erase\" : \"write\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n\nconst int INF = 1e9;\n\nclass Edge{\n\tpublic:\n\t\t//行き先、容量、コスト、逆辺\n\t\tint to, cap, cost, rev;\n\t\tEdge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nclass MinCostFlow {\n\tint v;\n\tvector<vector<Edge>> G;\n\tvector<int> h; //ポテンシャル\n\tvector<int> dist; //最短距離\n\tvector<int> prev_v, prev_e; //直前の頂点と辺\n\n\tpublic:\n\tMinCostFlow(int n = 500) : v(n), G(n), h(n), dist(n), prev_v(n), prev_e(n) { }\n\tvoid output(int n, vector<string>& s){\n\t\tvector<pair<int, int>> p;\n\t\tvector<string> st;\n\t\trep(i,n){\n\t\t\tfor(auto j : G[i]){\n\t\t\t\tif(j.cap == 0){\n\t\t\t\t\tif(s[i][j.to - n] == '.'){\n\t\t\t\t\t\tp.emplace_back(i,j.to - n);\n\t\t\t\t\t\tst.emplace_back(\"write\");\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(s[i][j.to - n] == 'o'){\n\t\t\t\t\t\tp.emplace_back(i,j.to - n);\n\t\t\t\t\t\tst.emplace_back(\"erase\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p.size() << endl;\n\t\trep(i,p.size()){\n\t\t\tcout << p[i].first + 1 << ' ' << p[i].second + 1 << ' ' << st[i] << endl;\n\t\t}\n\t}\n\tvoid addEdge(int from, int to, int cap, int cost){\n\t\t//cout << from << ' ' << to << ' ' << cap << ' ' << cost << endl;\n\t\tG[from].emplace_back(Edge(to, cap, cost, static_cast<int>(G[to].size())));\n\t\tG[to].emplace_back(Edge(from, 0, -cost, static_cast<int>(G[from].size() - 1)));\n\t}\n\tint bellmanFord(int s, int t, int f){\n\t\tint res = 0;\n\t\twhile(f > 0){\n\t\t\tdist = vector<int>(v,INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile(update){\n\t\t\t\tupdate = false;\n\t\t\t\trep(i,v){\n\t\t\t\t\tif(dist[i] == INF) continue;\n\t\t\t\t\trep(j,G[i].size()){\n\t\t\t\t\t\tEdge &e = G[i][j];\n\t\t\t\t\t\tif(e.cap > 0 and dist[e.to] > dist[i] + e.cost){\n\t\t\t\t\t\t\tdist[e.to] = dist[i] + e.cost;\n\t\t\t\t\t\t\tprev_v[e.to] = i;\n\t\t\t\t\t\t\tprev_e[e.to] = j;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == INF){\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor(int u = t; u != s; u = prev_v[u]){\n\t\t\t\td = min(d, G[prev_v[u]][prev_e[u]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor(int u = t; u != s; u = prev_v[u]){\n\t\t\t\tEdge &e = G[prev_v[u]][prev_e[u]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[u][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tint dijkstra(int s, int t, int f){\n\t\tint res = 0;\n\t\th = vector<int>(v, 0);\n\t\twhile(f > 0){\n\t\t\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\t\t\tdist = vector<int>(v,INF);\n\t\t\tdist[s] = 0;\n\t\t\tq.push(make_pair(0, s));\n\t\t\twhile(not q.empty()){\n\t\t\t\tpair<int, int> p = q.top(); q.pop();\n\t\t\t\tint u = p.second;\n\t\t\t\tif(dist[u] < p.first) continue;\n\t\t\t\trep(i,G[u].size()){\n\t\t\t\t\tEdge &e = G[u][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[u] + e.cost + h[u] - h[e.to]){\n\t\t\t\t\t\tdist[e.to] = dist[u] + e.cost + h[u] - h[e.to];\n\t\t\t\t\t\tprev_v[e.to] = u;\n\t\t\t\t\t\tprev_e[e.to] = i;\n\t\t\t\t\t\tq.push(make_pair(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == INF){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\trep(i,v) h[i] += dist[i];\n\n\t\t\tint d = f;\n\t\t\tfor(int u = t; u != s; u = prev_v[u]){\n\t\t\t\td = min(d, G[prev_v[u]][prev_e[u]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int u = t; u != s; u = prev_v[u]){\n\t\t\t\tEdge &e = G[prev_v[u]][prev_e[u]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[u][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> w(n, vector<int>(n)), e(n, vector<int>(n));\n\tvector<string> s(n);\n\trep(i,n) cin >> w[i];\n\trep(i,n) cin >> e[i];\n\trep(i,n) cin >> s[i];\n\n\tvector<vector<int>> d(n, vector<int>(n,0));\n\tint sum = 0;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(s[i][j] == 'o'){\n\t\t\t\tsum += e[i][j];\n\t\t\t\td[i][j] = -e[i][j];\n\t\t\t}else{\n\t\t\t\td[i][j] = w[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tMinCostFlow f;\n\tint S = n + n, T = S + 1;\n\trep(i,n) f.addEdge(S, i, 1, 0);\n\trep(i,n) f.addEdge(i + n, T, 1, 0);\n\trep(i,n) rep(j,n){\n\t\tf.addEdge(i, j + n, 1, d[i][j]);\n\t}\n\n\tcout << sum + f.bellmanFord(S, T, n) << endl;\n\tf.output(n,s);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <utility>\n#include <queue>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int index, capacity, cost;\n    Edge(int i, int c, int d) : index(i), capacity(c), cost(d) {}\n};\n\nstruct Command {\n    int r, c;\n    string cmd;\n    Command(int r, int c, const string &cmd) : r(r), c(c), cmd(cmd) {}\n};\n\n// O(V^2 U C) where\n//  U = sum of capacity\n//  C = sum of cost\npair<int,int> primal_dual(const vector<vector<Edge> >& g, int source, int sink, int total_flow, vector<vector<int> > &flow)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)); \n  flow = vector<vector<int> >(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<Edge>::const_iterator it(g[i].begin()); it != g[i].end(); ++it) {\n      capacity[i][it->index] += it->capacity;\n      cost[i][it->index] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  for (int f = total_flow; f > 0; ) {\n    vector<int> dist(N, 1000000);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<Edge>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (capacity[n][it->index] - flow[n][it->index] > 0) {\n          const int c2 = c + cost[n][it->index] + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = n;\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return total;\n}/*}}}*/\n\nint write_cost[128][128];\nint erase_cost[128][128];\nchar field[128][128];\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            scanf(\"%d\", &write_cost[i][j]);\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            scanf(\"%d\", &erase_cost[i][j]);\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        scanf(\"%s\", &field[i][0]);\n    }\n\n    // 0..N-1: Row\n    // N..2N-1: Col\n    // 2N: Source\n    // 2N+1: Sink\n    vector<vector<Edge> > graph(2*N+2);\n    for(int r = 0; r < N; ++r) {\n        int sum = 0;\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o') sum += erase_cost[r][c];\n        }\n        for(int c = 0; c < N; ++c) {\n            int cost = sum;\n            if(field[r][c] == 'o') cost -= erase_cost[r][c];\n            else cost += write_cost[r][c];\n            graph[r].push_back(Edge(N+c, 1, cost));\n        }\n    }\n    for(int r = 0; r < N; ++r) {\n        graph[2*N].push_back(Edge(r, 1, 0));\n    }\n    for(int c = 0; c < N; ++c) {\n        graph[N+c].push_back(Edge(2*N+1, 1, 0));\n    }\n    vector<vector<int> > flow;\n    pair<int,int> result = primal_dual(graph, 2*N, 2*N+1, N, flow);\n    vector<Command> commands;\n    for(int r = 0; r < N; ++r) {\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o' && flow[r][N+c] == 0)\n                commands.push_back(Command(r+1, c+1, \"erase\"));\n            else if(field[r][c] == '.' && flow[r][N+c] > 0)\n                commands.push_back(Command(r+1, c+1, \"write\"));\n        }\n    }\n    cout << result.first << endl;\n    cout << commands.size() << endl;\n    for(vector<Command>::const_iterator it = commands.begin(); it != commands.end(); ++it) {\n        cout << it->r << ' ' << it->c << ' ' << it->cmd << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<typeinfo>\n#include<functional>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nclass CFlow{\npublic:\n    struct edge{\n        ll to;\n        ll cap;\n        ll rev;\n        ll cost;\n    };\n    \n    struct node{\n        ll cost;\n        ll flow;\n        ll number;\n        ll from;\n        ll edge;\n        \n        //cost::smaller flow::bigger\n        bool operator < (const node &a) const {\n            if(a.cost<this->cost){return true;}\n            else if(a.cost==this->cost && a.flow>this->flow){return true;}\n            return false;\n        }\n    };\n    \n    ll INF;\n    ll v;\n    vector<vector<edge>> e;\n    \n\n    CFlow(ll v):v(v){\n        e.resize(v);\n        INF=1e18+7;\n    }\n    \n    void add_edge(ll from,ll to,ll cap,ll cost){\n        e[from].push_back((edge){to,cap,(ll)e[to].size(),cost});\n        e[to].push_back((edge){from,0,(ll)e[from].size()-1,-1*cost});\n    }\n    \n    pll min_cost(ll s,ll t,ll flow){\n        ll cost=0;\n        ll D=flow;\n        vector<ll> h(v,0);\n        while(flow>0){\n            priority_queue<node> q;\n            vector<node> V(v,{INF,0,-1,-1,-1});\n            V[s]={0,flow,s,s,-1};\n            q.push({0,flow,s,s,-1});\n            while(!q.empty()){\n                node N=q.top(); q.pop();\n                ll w=N.number;\n                if(N<V[w]){continue;}\n                for(int i=0;i<e[w].size();i++){\n                    edge &E=e[w][i];\n                    node New={V[w].cost+E.cost+h[w]-h[E.to],min(N.flow,E.cap),E.to,w,i};\n                    if(E.cap>0 && V[E.to]<New){\n                        V[E.to]=New;\n                        q.push(New);\n                    }\n                }\n            }\n            if(V[t].flow==0){break;}\n            for(int i=0;i<v;i++){h[i]+=V[i].cost;}\n            flow-=V[t].flow;\n            ll w=t;\n            while(w!=s){\n                ll to=w;\n                w=V[w].from;\n                edge &E=e[w][V[to].edge];\n                E.cap-=V[t].flow;\n                e[E.to][E.rev].cap+=V[t].flow;\n                cost+=V[t].flow*E.cost;\n            }\n            if(flow==0){break;}\n        }\n        return {D-flow,cost};\n    }\n};\n\n\n\n    \nint main(){\n    ll n;\n    cin>>n;\n    vector<vector<ll>> w(n,vector<ll>(n));\n    vector<vector<ll>> e(n,vector<ll>(n));\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){cin>>w[i][t];}\n    }\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){cin>>e[i][t];}\n    }\n    vector<string> o(n);\n    for(int i=0;i<n;i++){cin>>o[i];}\n    CFlow F(2*n+10);\n    ll g=2*n+9;\n    ll s=g-1;\n    for(int i=0;i<n;i++){\n        F.add_edge(s,i,1,0);\n        F.add_edge(i+n,g,1,0);\n    }\n    vector<ll> R(n,0);\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(o[i][t]=='o'){R[i]+=e[i][t];}\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int t=0;t<n;t++){\n            if(o[i][t]=='o'){\n                F.add_edge(i,n+t,1,R[i]-e[i][t]);\n            }\n            else{\n                F.add_edge(i,n+t,1,R[i]+w[i][t]);\n            }\n        }\n    }\n    cout<<F.min_cost(s,g,n).S<<endl;\n    vector<pll> ans;\n    ll count=0;\n    for(int i=0;i<n;i++){\n        for(int t=1;t<=n;t++){\n            if(F.e[i][t].cap==0){\n                ans.push_back({i,F.e[i][t].to-n});\n            }\n        }\n    }\n    for(int i=0;i<n;i++){\n        if(o[ans[i].F][ans[i].S]=='.'){count++;}\n        for(int t=0;t<n;t++){\n            if(t==ans[i].S){continue;}\n            if(o[ans[i].F][t]=='o'){count++;}\n        }\n    }\n    cout<<count<<endl;\n    for(int i=0;i<n;i++){\n        //cout<<ans[i].F<<\" \"<<ans[i].S<<endl;\n        if(o[ans[i].F][ans[i].S]=='.'){\n            cout<<ans[i].F+1<<\" \"<<ans[i].S+1<<\" write\"<<endl;\n        }\n        for(int t=0;t<n;t++){\n            if(t==ans[i].S){continue;}\n            if(o[ans[i].F][t]=='o'){\n                cout<<ans[i].F+1<<\" \"<<t+1<<\" erase\"<<endl;\n            }\n        }\n    }\n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nedge G[MAX_V][MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from][to] = (edge){cap, cost};\n\tG[to][from] = (edge){0, -cost};\n}\n\nint bit_matching_cost(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[s] = 0;\n\n        fill_n(used, V, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < V; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            used[v] = true;\n\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t}\n\t\t\t}\n        }\n        /*\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\tque.push(P(dist[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tif (dist[t] == INT_INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tint d = 1;\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][v];\n\t\t\te.cap -= d;\n\t\t\tG[v][prevv[v]].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N*2, i, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N+i, N*2+1, 1, 0);\n\t}\n\tf += bit_matching_cost(N*2, N*2+1, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][N+j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nconst int INF = (1<<28);\n\nclass Edge\n{\npublic:\n\tint src,dst,cst,cap,rev;\n\tEdge(int src, int dst, int cst, int cap, int rev)\n\t\t:src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n\tgraph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n\tgraph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n\npair<int,int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n\tint V = graph.size();\n\tvector<int> dist(V), prevv(V), preve(V);\n\n\tint res = 0, fw = 0;\n\n\twhile(1) {\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tdist[S] = 0;\n\t\tbool update = true;\n\n\t\twhile(update) {\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0; v < V; v++) {\n\t\t\t\tif(dist[v] == INF) continue;\n\n\t\t\t\tfor(int i=0; i<graph[v].size(); i++) {\n\t\t\t\t\tEdge& e = graph[v][i];\n\t\t\t\t\tint cost = e.cst;\n\t\t\t\t\tif(graph[e.dst][e.rev].cap != 0) cost = 0;\n\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n\t\t\t\t\t\tdist[e.dst] = dist[e.src] + cost;\n\t\t\t\t\t\tprevv[e.dst] = e.src;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[T] == INF) break;\n\n\t\tint f = INF;\n\t\tfor(int v = T; v != S; v = prevv[v])\n\t\t\tf = min(f, graph[prevv[v]][preve[v]].cap);\n\n\t\tres += dist[T];\n\t\tfw += f;\n\n\t\tfor(int v = T; v != S; v = prevv[v]) {\n\t\t\tEdge& e = graph[prevv[v]][preve[v]];\n\t\t\te.cap -= f;\n\t\t\tgraph[v][e.rev].cap += f;\n\t\t}\n\n\t\tif(fw >= L) break;\n\t}\n\n\treturn make_pair(res, fw);\n}\n\nint ecst[100][100], icst[100][100];\nint main()\n{\n\tint N;\n\tcin >> N;\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tcin >> ecst[j][i];\n\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t\tcin >> icst[j][i];\n\n\t\tstring field[100];\n\t\tfor(int i=0; i<N; i++)\n\t\t\tcin >> field[i];\n\n\n\t\tint res = 0;\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tif(field[i][j] == 'o') {\n\t\t\t\tres += ecst[j][i];\n\t\t\t}\n\t\t}\n\n\n\t\tGraph graph(N*N+2);\n\t\tfor(int i=0; i<N; i++) {\n\t\t\taddEdge(N*N, i, 1, 0, graph);\n\t\t\taddEdge(N+i, N*N+1, 1, 0, graph);\n\t\t}\n\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++) {\n\t\t\tint cst;\n\t\t\tif(field[j][i] == 'o') cst = -ecst[j][i];\n\t\t\telse cst = icst[j][i];\n\n\t\t\taddEdge(j, i+N, 1, cst, graph);\n\t\t}\n\n\t\tpair<int, int> fw = minimumCostFlow(N*N, N*N+1, N, graph);\n\n\n\t\tint ans = res + fw.first;\n\t\tcout << ans << endl;\n\n\t\tif(ans == 0) cout << 0 << endl;\n\n\t\telse {\n\t\t\tint c = 0;\n\t\t\tstringstream ss;\n\t\t\tfor(int i=0; i<N; i++) {\n\t\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\t\tEdge& e = graph[i][j];\n\n\t\t\t\t\tif(e.src >= N*N || e.dst >= N*N) continue;\n\n\t\t\t\t\tif(field[e.src][e.dst-N] == 'o' && e.cap == 1) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tss <<  e.src + 1 << \" \" << e.dst + 1 - N << \" erase\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\tif(field[e.src][e.dst-N] == '.' && e.cap == 0) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tss  << e.src + 1 << \" \" << e.dst + 1 - N << \" write\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << c << endl;\n\t\t\tcout << ss.str();\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cap,cost,rev;\n  edge(){}\n  edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nstruct ope{\n  int x,y,d;\n  ope(){}\n  ope(int x,int y,int d):x(x),y(y),d(d){}\n};\n\nint main(){\n  int n;\n  cin>>n;\n  int c[2][n][n];\n  for(int k=0;k<2;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcin>>c[k][i][j];\n  \n  string str[n];\n  for(int i=0;i<n;i++) cin>>str[i];\n\n  V=n*2+2;\n  int s=n*2,t=n*2+1;\n  for(int i=0;i<n;i++){\n    add_edge(s,i,1,0);\n    add_edge(n+i,t,1,0);\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int r=0;\n      for(int k=0;k<n;k++){\n\tif(k==j){\n\t  if(str[i][k]=='.') r+=c[0][i][k];\n\t}else{\n\t  if(str[i][k]=='o') r+=c[1][i][k];\n\t}\n      }\n      add_edge(j,n+i,1,r);\n    }\n  }\n  cout<<min_cost_flow(s,t,n)<<endl;\n  vector<ope> v;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j].cap) continue;\n      for(int k=0;k<n;k++){\n\tif(n+k==G[i][j].to){\n\t  if(str[i][k]=='.') v.push_back(ope(k+1,i+1,0));\n\t}else{\n\t  if(str[i][k]=='o') v.push_back(ope(k+1,i+1,1));\n\t}\n      }\n    }\n  }\n  cout<<v.size()<<endl;\n  for(int i=0;i<(int)v.size();i++)\n    cout<<v[i].x<<\" \"<<v[i].y<<\" \"<<(v[i].d?\"erase\":\"write\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cap,cost,rev;};\nvector<edge> G[50010];\nbool used[50010];\nint h[50010],dist[50010],prevv[50010],preve[50010];\nint V;//Vは頂点数\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back( (edge){to,cap,cost,(ll)G[to].size()} );\n\t\tG[to].push_back( (edge){from,0,-cost,(ll)G[from].size()-1 });\n}\n\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\t\n\t\tpriority_queue <P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,inf);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile( !que.empty() ){\n\t\t\tP p=que.top();que.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t}\n\t}\n\tif(dist[t]==inf) return -1;\n\tfor(int v=0;v<V;v++)h[v] += dist[v];\n\tint d=f;\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t}\n\tf -= d;\n\tres += d*h[t];\n\tfor(int v=t; v!=s;v=prevv[v]){\n\t\tedge &e =G[prevv[v]][preve[v]];\n\t\te.cap -=d;\n\t\tG[v][e.rev].cap +=d;\n\t}\n}\nreturn res;\n}\nvector<pa> ans;\nint w[101][110],e[110][110],a[110][110];\n   signed main(){\nint n;\n   \tcin>>n;\nV=300;\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>w[i][j];\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>e[i][j];\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \tstring s;\n   \t\tcin>>s;\n   \t\t\n   \t\ts=\"q\"+s;\n   \t\tfor(int j=1;j<=n;j++){\n   \t\t\tif(s[j]=='o')a[i][j]=1;\n   \t\t\telse a[i][j]=0;\n   \t\t}\n   \t\n   \t\n   \t}\n   \t\n   \t\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n   \tint gosa=0;\n   \t\tfor(int k=1;k<=n;k++)if(k!=j){\n   \t\t\tif(a[i][k]==1)gosa+=e[i][k];\n   \t\t}\n   \t\tif(a[i][j]==0) gosa+=w[i][j];\n   \t\t\n   \t\tadd_edge(i,n+j,1 ,gosa);\n   \t\n   \t}\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \t\tadd_edge(0,i,1,0);\n   \t\tadd_edge(n+i,2*n+1,1,0);\n   \t}\n   \t\n   \tcout<<min_cost_flow(0,2*n+1,n)<<endl;\n   \tfor(int i=1;i<n+1;i++)for(auto e:G[i]){\n   \t\tif(e.to==0 ) continue;\n   \t\tif(e.cap==1 && a[i][e.to-n]==1) ans.pb(mp(i,e.to));\n   \t\tif(e.cap==0 && a[i][e.to-n]==0) ans.pb(mp(i,e.to));\n   \t}\n   \tcout<<ans.size()<<endl;\n   \tfor(auto v:ans){\n   \t\tif(a[v.first][v.second-n])cout<<v.first<<\" \" <<v.second-n<<\" erase\"<<endl;\n   \t\telse cout<<v.first<<\" \" <<v.second-n<<\" write\"<<endl;\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nstruct edge/*{{{*/\n{\n  int to;\n  int capacity;\n  int cost;\n  edge(int i, int c, int d) : to(i), capacity(c), cost(d) {}\n};/*}}}*/\n\npair<int,vector<vector<int> > > primal_dual(const vector<vector<edge> >& g, int source, int sink)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)), flow(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<edge>::const_iterator it = g[i].begin(); it != g[i].end(); ++it) {\n      capacity[i][it->to] += it->capacity;\n      cost[i][it->to] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  static const int INF = 10000000;\n  for (int f = INF; f > 0; ) {\n    vector<int> dist(N, INF);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<edge>::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (capacity[n][it->to] - flow[n][it->to] > 0) {\n          const int c2 = c + cost[n][it->to] + h[n] - h[it->to];\n          if (c2 < dist[it->to]) {\n            dist[it->to] = c2;\n            parent[it->to] = n;\n            q.push(make_pair(-c2, it->to));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return make_pair(total.first, flow);\n}/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > erase(N, vector<int>(N)), write(N, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> write[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> erase[i][j];\n    }\n  }\n  vector<string> grid(N);\n  for (int i = 0; i < N; i++) {\n    cin >> grid[i];\n    int sum = 0;\n    for (int j = 0; j < N; j++) {\n      if (grid[i][j] == 'o') {\n        sum += erase[i][j];\n      }\n    }\n    for (int j = 0; j < N; j++) {\n      if (grid[i][j] == 'o') {\n        write[i][j] = sum - erase[i][j];\n      } else {\n        write[i][j] += sum;\n      }\n    }\n  }\n\n  vector<vector<edge> > g(2*N+2);\n  const int source = 2*N, sink = 2*N+1;\n  for (int i = 0; i < N; i++) {\n    const int row = i, col = N+i;\n    g[source].push_back(edge(row, 1, 0));\n    g[col].push_back(edge(sink, 1, 0));\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      g[row].push_back(edge(col, 1, write[i][j]));\n      g[col].push_back(edge(row, 0, -write[i][j]));\n    }\n  }\n\n  const pair<int,vector<vector<int> > > r = primal_dual(g, source, sink);\n  cout << r.first << endl;\n  const vector<vector<int> >& flow = r.second;\n  vector<string> steps;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      if (flow[row][col] == 1 && grid[i][j] == '.') {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" write\";\n        steps.push_back(oss.str());\n      } else if (flow[row][col] == 0 && grid[i][j] == 'o') {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" erase\";\n        steps.push_back(oss.str());\n      }\n    }\n  }\n  cout << steps.size() << endl;\n  copy(steps.begin(), steps.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n\ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n     G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f, bool negative = fal\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 10000000;\n\n  if(negative){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n\n    bool update = true;\n\n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n        if(dist[v] == inf) continue;\n        for(int i = 0; i < (int)g[v].size(); i++){\n          E &e = g[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to]  = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update      = true;\n          }\n        }\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n      h[i] = dist[i];\n  }\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n        E &e = g[v][i];\n\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == inf){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint w[100][100];\nint e[100][100];\nint f[100][100];\nint c[100][100];\n\nint main(){\n  const int n = getInt();\n\n  REP(i,n) REP(j,n)\n    w[i][j] = getInt();\n  REP(i,n) REP(j,n)\n    e[i][j] = getInt();\n\n  REP(i,n){\n    char b[128]; scanf(\"%s\", b);\n    REP(j,n) f[i][j] = (b[j] == 'o' ? 1 : 0);\n  }\n\n  REP(i,n){\n    REP(j,n){\n      int cc = 0;\n\n      REP(k,n){\n        if(f[i][k]  && k != j) cc += e[i][j];\n        if(!f[i][k] && k == j) cc += w[i][j];\n      }\n\n      c[i][j] = cc;\n    }\n  }\n\n  Graph<CostEdge> g(2 + 2 * n);\n  const int start = 2 * n;\n  const int goal  = 2 * n + 1;\n\n  REP(i,n) REP(j,n){\n    g.addEdge(i, n + j, 1, c[i][j]);\n  }\n\n  REP(i,n){\n    g.addEdge(start, i, 1, 0);\n    g.addEdge(n + i, goal, 1, 0);\n  }\n\n  int cost = minCostFlow(g, start, goal, n);\n\n  printf(\"%d\\n\", cost);\n\n  vector<string> ans;\n  const Graph<CostEdge>::G &gg = g.getRowGraph();\n  REP(i,n){\n    int dst = -1;\n    REP(j,n){\n      if(gg[i][j].cap == 0){\n        dst = gg[i][j].to - n;\n      }\n    }\n    while(dst == -1) ;\n    REP(j,n){\n      char buff[256];\n      if(f[i][j] && dst != j){\n        sprintf(buff, \"%d %d erase\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n      if(!f[i][j] && dst == j){\n        sprintf(buff, \"%d %d write\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans.size());\n  REP(i,ans.size())\n    printf(\"%s\\n\", ans[i].c_str());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge{int to,cap,cost,rev;};\nconst int MAX_V=202,INF=1e9;\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V],dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n\tedge e1={to,cap,cost,G[to].size()},e2={from,0,-cost,G[from].size()};\n\tG[from].pb(e1),G[to].pb(e2);\n}\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.sc;\n\t\t\tif(dist[v]<p.fs) continue;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\trep(v,V) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tchmin(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint N;\n\tint w[100][100],e[100][100];\n\tstring s[100];\n\tcin>>N;\n\trep(i,N) rep(j,N) cin>>w[i][j];\n\trep(i,N) rep(j,N) cin>>e[i][j];\n\trep(i,N) cin>>s[i];\n\tint S=2*N,T=2*N+1;\n\tV=2*N+2;\n\trep(i,N) add_edge(S,i,1,0);\n\trep(i,N) add_edge(N+i,T,1,0);\n\trep(i,N) rep(j,N){\n\t\tint c=0;\n\t\trep(k,N){\n\t\t\tif(k==j){\n\t\t\t\tif(s[i][k]=='.') c+=w[i][k];\n\t\t\t}else{\n\t\t\t\tif(s[i][k]=='o') c+=e[i][k];\n\t\t\t}\n\t\t}\n\t\tadd_edge(i,N+j,1,c);\n\t}\n\tint f=min_cost_flow(S,T,N);\n\tcout<<f<<endl;\n\tbool is[100][100]={};\n\trep(v,N){\n\t\tfor(edge e:G[v]){\n\t\t\tint u=e.to;\n\t\t\tif(u<2*N){\n\t\t\t\tis[v][u-N]=(e.cap==0);\n\t\t\t}\n\t\t}\n\t}\n\tint c=0;\n\trep(i,N) rep(j,N) if((s[i][j]=='o')^is[i][j]) c++;\n\tcout<<c<<endl;\n\trep(i,N) rep(j,N){\n\t\tif((s[i][j]=='o')&&!is[i][j]) printf(\"%d %d erase\\n\",i+1,j+1);\n\t\tif((s[i][j]=='.')&&is[i][j]) printf(\"%d %d write\\n\",i+1,j+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 301\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstruct edge{ int to,cap,cost,rev; };\n \nint v;\nvector<edge> e[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  e[from].push_back((edge){to,cap,cost,(int)e[to].size()});\n  e[to].push_back((edge){from,0,-cost,(int)e[from].size()-1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+v,0);\n  fill(prevv,prevv+MAX,0);\n  fill(preve,preve+MAX,0);\n  while(f>0){\n    priority_queue<pii,vector<pii>,greater<pii> > pq;\n    fill(dist,dist+v,inf);\n    dist[s]=0;\n    pq.push(pii(0,s));\n    while(pq.size()){\n      pii p=pq.top();\n      pq.pop();\n      int u=p.second;\n      if(dist[u]<p.first)continue;\n      for(int i=0;i<e[u].size();i++){\n        edge &E=e[u][i];\n        if(E.cap>0 && dist[E.to]>dist[u]+E.cost+h[u]-h[E.to]){\n          dist[E.to]=dist[u]+E.cost+h[u]-h[E.to];\n          prevv[E.to]=u;\n          preve[E.to]=i;\n          pq.push(pii(dist[E.to],E.to));\n        }\n      }\n    }\n    if(dist[t]==inf)return -1;\n    for(int i=0;i<v;i++)h[i]+=dist[i];\n \n    int d=f;\n    for(int u=t;u!=s;u=prevv[u]){\n      d=min(d,e[prevv[u]][preve[u]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int u=t;u!=s;u=prevv[u]){\n      edge &E=e[prevv[u]][preve[u]];\n      E.cap-=d;\n      e[u][E.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint W[MAX][MAX],E[MAX][MAX];\nstring F[MAX];\nint used[MAX][MAX];\n\nvoid solve(){\n  int sum = 0,cnt = 0;\n  FOR(i,0,n)fill(used[i],used[i]+n,0);\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(F[i][j]=='.')add_edge(i,j+n,1,W[i][j]);\n      else {\n        sum+=E[i][j];\n        cnt++;\n        used[i][j]=1;\n        add_edge(i,j+n,1,-E[i][j]);\n      }\n    }\n  }\n  int s=n+n,t=s+1;\n  v=t+1;\n  FOR(i,0,n)add_edge(s,i,1,0);\n  FOR(i,0,n)add_edge(i+n,t,1,0);\n  int ans = min_cost_flow(s,t,n);\n  cout<<sum+ans<<endl;\n  vector<pair<string,pair<int,int> > > op;\n  FOR(i,0,n){\n    FOR(j,0,e[i].size()){\n      edge a=e[i][j];\n      if(a.cap!=0)continue;\n      if(a.cost<1){\n        cnt-=1;\n        used[i][j]=0;\n      }\n      else {\n        cnt+=1;\n        used[i][j]=2;\n      }\n    }\n  }\n  cout<<cnt<<endl;\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(used[i][j]==1)cout<<i+1<<\" \"<<j+1<<\" erase\"<<endl;\n      if(used[i][j]==2)cout<<i+1<<\" \"<<j+1<<\" write\"<<endl;\n    }\n  }\n}\n\nint main()\n{\n  cin>>n;\n  FOR(i,0,n)FOR(j,0,n)cin>>W[i][j];\n  FOR(i,0,n)FOR(j,0,n)cin>>E[i][j];\n  FOR(i,0,n)cin>>F[i];\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cstring>\n#include <string>\n#include <cstdlib>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\ntypedef int Weight;\nconst Weight INF=99999999;\n#define MAX_V 100*2+2\nstruct edge{\n\tint to,cap,cost,rev;\n\tedge(int to,int cap=0,int cost=0,int rev=-1):\n\tto(to),cap(cap),cost(cost),rev(rev)\n{}\n};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\n//to から dst へ向かう容量 cap,コストcost の辺をグラフに追加する\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back( edge(to,cap,cost,G[to].size()) );\n\tG[to].push_back( edge(from,0,-cost,G[from].size()-1) );\n}\n// s から t への流量 f の最小費用流を求める\n// 流せない場合は-1を返す\n// 流量がdouble の場合は誤差死に注意\nint n;\nchar c[100][100];\n\nint min_cost_flow(int s,int t,int f){\n\tint res = 0;\n\twhile(f>0){\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v=0;v<V;v++){\n\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\tfor(int i=0;i<G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF) return -1;\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]) d=min(d, G[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres += d*dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t\tif(n<=v && v<2*n){\n\t\t\t\tc[prevv[v]][v-n] = 'o';\n//\t\t\t\tprintf(\"[%d][%d] = o\\n\", prevv[v], v-n);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nstring Map[100];\nint E[100][100];\nint W[100][100];\nmain(){\n\tint i,j,ans=0,maxe=0;\n\tcin >> n;\n\tV = 2*n+2;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tcin >> W[i][j];\n\t\t\tc[i][j] = '.';\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tcin >> E[i][j];\n\t\t\tmaxe=max(maxe, E[i][j]);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tcin >> Map[i];\n\t}\n\tfor(i=0;i<n;i++){\n\t\tadd_edge(2*n, i, 1, 0);\n\t\tadd_edge(i+n, 2*n+1, 1, 0);\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(Map[i][j] == 'o'){\n\t\t\t\tans += E[i][j];\n\t\t\t\tadd_edge(i, n+j, 1, maxe-E[i][j]);\n\t\t\t}else{\n\t\t\t\tadd_edge(i, n+j, 1, maxe+W[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans + min_cost_flow(2*n, 2*n+1, n) - maxe*n << endl;\n\n\tint cnt = 0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(c[i][j] != Map[i][j]) cnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(c[i][j] != Map[i][j]){\n\t\t\t\tif(Map[i][j] == 'o') cout << i+1 << \" \" << j+1 << \" erase\" << endl;\n\t\t\t\telse cout << i+1 << \" \" << j+1 << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  void init(ll n) {\n    par.resize(n); rank.resize(n);\n    fill(par.begin(), par.end(), 1); fill(rank.begin(), rank.end(), 0);\n  }\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true) {\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf;\n    uf.init(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\ntemplate<typename T>\nclass Flow {\n  struct edge {\n    ll to; T cap; ll rev;\n  };\n\n  vector<vector<edge> > G;\n  vector<ll> level, iter;\n  bool isDirected;\npublic:\n  Flow(ll n, bool _isDirected = true) : G(n), level(n), iter(n), isDirected(_isDirected) {}\n\n  void add_edge(ll from, ll to, T cap) {\n    G[from].emplace_back((edge){to, cap, (ll)G[to].size()});\n    G[to].emplace_back((edge){from, isDirected ? 0LL : cap, (ll)G[from].size()-1});\n    //return G[to].back().rev;\n  }\n\n  void bfs(ll s) {\n    fill(level.begin(), level.end(), -1);\n    queue<ll> que;\n    level[s] = 0;\n    que.emplace(s);\n    while (!que.empty()) {\n      ll v=que.front(); que.pop();\n      for (ll i=0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v]+1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n\n  T dfs(ll v, ll t, T f) {\n    if (v == t) return f;\n    for (ll &i = iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        T d = dfs(e.to, t, min(f, e.cap));\n        if (d == 0) continue;\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n    return 0;\n  }\n\n  T maxflow(ll s, ll t, T lim = INF) {\n    T fl = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0 || lim == 0) break;\n      fill(iter.begin(), iter.end(), 0);\n      while(1) {\n        T f = dfs(s, t, lim);\n        if(f == 0) break;\n        fl += f;\n        lim -= f;\n      }\n    }\n    return fl;\n  }\n};\n\nclass BipartiteMatching {\n  vector<ll> pre, root;\n  vector<vector<ll>> to;\n  vector<ll> p, q;\n  ll n, m;\npublic:\n  BipartiteMatching(ll n, ll m) : pre(n, -1), root(n, -1), to(n), p(n, -1), q(m, -1), n(n), m(m){}\n  void add_edge(ll a, ll b) { to[a].push_back(b);}\n  ll solve() {\n    ll res = 0;\n    bool upd = true;\n    while (upd) {\n      upd = false;\n      queue<ll> s;\n      for (ll i = 0; i < n; ++i) {\n        if (!~p[i]) {\n          root[i] = i;\n          s.push(i);\n        }\n      }\n      while (!s.empty()) {\n        ll v = s.front(); s.pop();\n        if (~p[root[v]]) continue;\n        for (ll i = 0; i < (ll)to[v].size(); ++i) {\n          ll u = to[v][i];\n          if (!~q[u]) {\n            while (~u) {\n              q[u] = v;\n              swap(p[v],u);\n              v = pre[v];\n            }\n            upd = true;\n            ++res;\n            break;\n          }\n          u = q[u];\n          if (~pre[u]) continue;\n          pre[u] = v; root[u] = root[v];\n          s.push(u);\n        }\n      }\n      if (upd) fill(pre.begin(),pre.end(),-1), fill(root.begin(),root.end(),-1);\n    }\n    return res;\n  }\n};\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  ll add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    return (ll)graph[from].size() - 1;\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nll n, w[100][100], e[100][100];\nchar f[100][101], d[100][101];\n\nint main() {\n  scanf(\"%lld\", &n);\n  for (ll i = 0; i < n; i++) for (ll j = 0; j < n; j++) scanf(\"%lld\", &w[i][j]);\n  for (ll i = 0; i < n; i++) for (ll j = 0; j < n; j++) scanf(\"%lld\", &e[i][j]);\n  for (ll i = 0; i < n; i++) scanf(\"%s\", f[i]);\n  PrimalDual<ll, ll> flow(2*n+2);\n  ll ans = 0;\n  vector<P> v;\n  for (ll i = 0; i < n; i++) for (ll j = 0; j < n; j++) {\n    if (f[i][j] == '.') v.push_back(P(i, flow.add_edge(i, j+n, 1, w[i][j])));\n    else v.push_back(P(i, flow.add_edge(i, j+n, 1, -e[i][j]))), ans += e[i][j];\n  }\n  for (ll i = 0; i < n; i++) flow.add_edge(2*n, i, 1, 0), flow.add_edge(i+n, 2*n+1, 1, 0);\n  ans += flow.min_cost_flow(2*n, 2*n+1, n);\n  for (const P& p : v) d[p.first][p.second] = (flow.graph[p.first][p.second].cap == 0) ? 'o' : '.';\n  ll counter = 0;\n  for (ll i = 0; i < n; i++) for (ll j = 0; j < n; j++) if (f[i][j] != d[i][j]) counter++;\n  printf(\"%lld\\n%lld\\n\", ans, counter);\n  for (ll i = 0; i < n; i++) for (ll j = 0; j < n; j++) if (f[i][j] != d[i][j]) {\n    if (f[i][j] == '.') printf(\"%lld %lld write\\n\", i+1, j+1);\n    else printf(\"%lld %lld erase\\n\", i+1, j+1);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            int dist2 = 0;\n            int flag;\n            for (int i = 0; i < l+r+1; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist2)){\n                    v = i;\n                    dist2 = dist[i];\n                }\n            }\n            /*\n            for (int i = 0; i < r+1; i++) {\n                if (!used[i+l+1] && (v == -1 || dist[i+l+1] < dist2)){\n                    v = i;\n                    dist2 = dist[i+l+1];\n                    flag = false;\n                }\n            }*/\n            if (v == -1) break;\n            flag = (v < l+1);\n            if (v >= l+1) {\n                v -= l+1;\n            }\n            if (flag) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && dist[i+l+1] > dist[v] + G[v][i] + h[v] - h[i+l+1]) {\n\t\t\t\t\t\tdist[i+l+1] = dist[v] + G[v][i] + h[v] - h[i+l+1];\n\t\t\t\t\t\tprevv[i+l+1] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v+l+1] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v] && dist[i] > dist[v+l+1] - G[i][v] + h[v+l+1] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v+l+1] - G[i][v] + h[v+l+1] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevv[v] : prevv[v+l+1], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevv[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int INF = (1<<29);\n\nstruct edge{int to, cap, cost, rev;};\n \nint V;\nvector<edge> G[300];\nint h[300];\nint dist[300];\nint prevv[300],preve[300];\n  \nvoid init(){\n  for(int i = 0 ; i < 300 ; i++){\n    G[i].clear();\n  }\n}\n  \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n  \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  fill(h,h+V,0);\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,INF);\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n  \n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < (int)G[v].size() ; i++){\n        edge &e = G[v][i];\n          \n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n  \n    if(dist[t] == INF){\n      return -1;\n    }\n  \n    for(int v = 0 ; v < V ; v++) h[v] += dist[v];\n        \n    int d = f;\n  \n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n \nstruct result{\n  int x,y;\n  string s;\n};\n\nint N;\nint W[111][111];\nint E[111][111];\nchar M[111][111];\n\nint cost[111][111];\n\nvector<result> ans;\nvoid writer(int x,int y){\n  for(int k=0;k<N;k++){\n    if( x == k ){\n      if( M[k][y] == '.' )\n\tans.push_back( (result){k,y,\"write\"} );      \n    } else\n      if( M[k][y] == 'o' )\n\tans.push_back( (result){k,y,\"erase\"} );\n  }\n}\n \nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> W[j][i];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> E[j][i];\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) cin >> M[j][i];\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      for(int k=0;k<N;k++){\n\tif( j == k ){\n\t  if( M[k][i] == '.' ) cost[j][i] += W[k][i];\n\t} else\n\t  if( M[k][i] == 'o' ) cost[j][i] += E[k][i];\n      }\n    }\n  }\n\n  for(int x=0;x<N;x++)\n    for(int y=0;y<N;y++)\n      add_edge(x,y+N,1,cost[x][y]);\n\n  for(int i=N;i<N+N;i++)\n    add_edge(i,N+N+1,1,0);\n  for(int i=0;i<N;i++)\n    add_edge(N+N,i,1,0);\n\n  V = N + N + 2;\n\n  cout << min_cost_flow(N+N,N+N+1,N) << endl;\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if( N <= G[i][j].to && G[i][j].to < N+N )\n\tif( G[i][j].cap == 0 )\n\t  writer(i,G[i][j].to-N);\n    }\n  }\n\n  cout << ans.size() << endl;\n  for(int i=0;i<(int)ans.size();i++){\n    cout << ans[i].x+1 << \" \" << ans[i].y+1 <<\" \" << ans[i].s<< endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\n//const int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n#define MAX_V 10000\nint V;\n\ntypedef int Weight;\nconst Weight INF = 1000000000;\n// const Weight eps = 1e-8;\n\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight h[MAX_V];                // potential\nWeight dist[MAX_V];             // minimum distance\nint prevv[MAX_V], preve[MAX_V]; // previous vertex and edge\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n\tWeight res = 0; V = g.size();\n\tmemset(h, 0, sizeof(h));\n\ttypedef pair<Weight, int> P;\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest] /* + eps */) {\n\t\t\t\t\tdist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\tque.push(P(dist[e.dest], e.dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tREP(v, V) h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct op { int x, y, z; };\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tMatrix erase(n), write(n);\n\tREP(i, n)REP(j, n)\n\t{\n\t\tint a; cin >> a;\n\t\twrite[i].push_back(a);\n\t}\n\tREP(i, n)REP(j, n)\n\t{\n\t\tint a; cin >> a;\n\t\terase[i].push_back(a);\n\t}\n\tvs fld(n);\n\tREP(i, n) cin >> fld[i];\n\tGraph g(2*n + 2);\n\tREP(i, n)REP(j, n)\n\t{\n\t\tWeight w = 0;\n\t\tREP(k, n)\n\t\t{\n\t\t\tif (k == j) w += (fld[i][k] == 'o' ? 0 : write[i][k]);\n\t\t\telse w+= (fld[i][k] == '.' ? 0 : erase[i][k]);\n\t\t}\n\t\tadd_edge(g, i, n+j, 1, w);\n\t}\n\tREP(i, n)\n\t{\n\t\tadd_edge(g, 2 * n, i, 1, 0);\n\t\tadd_edge(g, n + i, 2 * n + 1, 1, 0);\n\t}\n\tint ans = min_cost_flow(g, 2 * n, 2 * n + 1, n);\n\tcout << ans << endl;\n\tvi v;\n\tREP(i, n)\n\t{\n\t\tREP(j, g[i].size())\n\t\t{\n\t\t\tif (g[i][j].cap == 0) v.push_back(j);\n\t\t}\n\t}\n\tvector<op> ansv;\n\tREP(i, n)\n\t{\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (v[i] == j&&fld[i][j] == '.') ansv.push_back(op{ i, j, 0 });\n\t\t\telse if (v[i] != j&&fld[i][j] == 'o') ansv.push_back(op{ i, j, 1 });\n\t\t}\n\t}\n\tcout << ansv.size() << endl;\n\tREP(i, ansv.size())\n\t{\n\t\tcout << ansv[i].x + 1 << \" \" << ansv[i].y + 1 << \" \" << (ansv[i].z == 0 ? \"write\\n\" : \"erase\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nint G[MAX_V][MAX_V];\nint hl[MAX_V], hr[MAX_V], distl[MAX_V], distr[MAX_V];\nint prevvl[MAX_V], prevvr[MAX_V];\nbool usedl[MAX_V], usedr[MAX_V];\nbool flow[MAX_V][MAX_V];\n\nint bit_matching_cost(int l, int r) {\n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n\tint res = 0;\n\tfill_n(hl, l+1, 0);\n\tfill_n(hr, r+1, 0);\n\twhile (true) {\n\t\tfill_n(distl, l+1, INT_INF);\n\t\tfill_n(distr, r+1, INT_INF);\n\t\tdistr[r] = 0;\n        fill_n(usedl, l+1, false);\n        fill_n(usedr, r+1, false);\n        while (true) {\n            int v = -1;\n            int dist = 0;\n            int flag;\n            for (int i = 0; i < l; i++) {\n                if (!usedl[i] && (v == -1 || dist < distl[v])){\n                    v = i;\n                    dist = distl[i];\n                    flag = true;\n                }\n            }\n            for (int i = 0; i < r; i++) {\n                if (!usedr[i] && (v == -1 || dist < distr[v])){\n                    v = i;\n                    dist = distr[i];\n                    flag = false;\n                }\n            }\n            if (v == -1) break;\n            if (flag) {\n            \tusedl[v] = true;\n\t            for (int i = 0; i < r; i++) {\n\t\t\t\t\tif (!flow[v][i] && distr[i] > distl[v] + G[v][i] + hl[v] - hr[i]) {\n\t\t\t\t\t\tdistr[i] = distl[v] + G[v][i] + hl[v] - hr[i];\n\t\t\t\t\t\tprevvr[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tusedr[v] = true;\n\t            for (int i = 0; i < l; i++) {\n\t\t\t\t\tif (flow[i][v] && distl[i] > distr[v] - G[v][i] + hr[v] - hl[i]) {\n\t\t\t\t\t\tdistl[i] = distr[v] - G[v][i] + hr[v] - hl[i];\n\t\t\t\t\t\tprevvl[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\n\t\tif (distl[l] == INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l; v++) {\n\t\t\thl[v] += distl[v];\n\t\t}\n\t\tfor (int v = 0; v < r; v++) {\n\t\t\thr[v] += distr[v];\n\t\t}\n\t\tres += hl[l];\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevvl[v] : prevvr[v], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevvl[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevvr[v]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j]+min_f;\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j]+min_f;\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100\n#define MAX_V 1000\n#define INF 1e9\nusing namespace std;\nint n,W[100][100],E[100][100];\nstring F[100];\nint N,K;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;     \n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint Biparite_Matching(){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  int res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(F[i][j]=='o')res+=E[i][j],add_edge(i,N+j,1,-E[i][j]);\n      else add_edge(i,N+j,1,W[i][j]);    \n  return res+min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>W[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>E[i][j];\n  for(int i=0;i<n;i++)cin>>F[i];\n  N=K=n,V=2*n+2;\n  cout<<Biparite_Matching()<<endl;\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')cnt++;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')cnt++;\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" write\"<<endl;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" erase\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cap,cost,rev;\n  edge(){}\n  edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nstruct ope{\n  int x,y,d;\n  ope(){}\n  ope(int x,int y,int d):x(x),y(y),d(d){}\n};\n\nint main(){\n  int n;\n  cin>>n;\n  int c[2][n][n];\n  for(int k=0;k<2;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcin>>c[k][i][j];\n  \n  string str[n];\n  for(int i=0;i<n;i++) cin>>str[i];\n\n  V=n*2+2;\n  int s=n*2,t=n*2+1;\n  for(int i=0;i<n;i++){\n    add_edge(s,i,1,0);\n    add_edge(n+i,t,1,0);\n  }\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int r=0;\n      for(int k=0;k<n;k++){\n\tif(k==j){\n\t  if(str[i][k]=='.') r+=c[0][i][k];\n\t}else{\n\t  if(str[i][k]=='o') r+=c[1][i][k];\n\t}\n      }\n      add_edge(i,n+j,1,r);\n    }\n  }\n  cout<<min_cost_flow(s,t,n)<<endl;\n  vector<ope> v;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j].cap) continue;\n      for(int k=0;k<n;k++){\n\tif(n+k==G[i][j].to){\n\t  if(str[i][k]=='.') v.push_back(ope(k+1,i+1,0));\n\t}else{\n\t  if(str[i][k]=='o') v.push_back(ope(k+1,i+1,1));\n\t}\n      }\n    }\n  }\n  cout<<v.size()<<endl;\n  for(int i=0;i<(int)v.size();i++)\n    cout<<v[i].x<<\" \"<<v[i].y<<\" \"<<(v[i].d?\"erase\":\"write\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\nstruct PrimalDual {\n    typedef int Capacity;\n    typedef int Cost;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<Cost> h,dist;\n    vector<int> prevv, preve;\n    enum : Cost { inf = 1<<29 };\n\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    PrimalDual(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)), h(n_), dist(n_), prevv(n_), preve(n_){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].push_back(Edge(dst, cap, cost, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, -cost, g[src].size() - 1, true));\n    }\n\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        h.assign(n,0);\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            dist.assign(n,inf);\n            dist[s] = 0;\n            q.push(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.push(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.min_cost_flow(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n\n    rep(i,mcf.n){\n        rep(j,mcf.n){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            if(f[i][e.dst-n]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=i+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=0;\n            }else if(f[i][e.dst-n]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=i+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>PP;\n\nstruct edge{\n    int to,cap,cost,rev; //?????????,??????,?????¨,??????\n};\n\nconst int MAX_N = 102;\nconst int MAX_V = 205;\n\nint n;\nint W[MAX_N][MAX_N];\nint E[MAX_N][MAX_N];\nint mp[MAX_N][MAX_N];\nvector<edge> G[MAX_V];\nint memo[MAX_V][MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(const int vcnt,const int s,const int t,int f)\n{\n\tint res =0;\n\tint dist[MAX_V];\n\tint prevv[MAX_V];\n\tint preve[MAX_V];\n\twhile(f>0){\n\t\tfill(dist,dist+vcnt,INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v=0;v<vcnt;v++){\n\t\t\t\tif(dist[v] == INF)\tcontinue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\t//??????????????????????¨???¶\n\t\t\t\t\t\tpreve[e.to] = i;\t//????????????????¨???¶\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\n\t\tint d = f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n            memo[prevv[v]][e.to] = 1;\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n    cin >> n;\n    int sm = 0;\n    rep(i,n){\n        rep(j,n){\n            cin >> W[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            cin >> E[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            char c;\n            cin >> c;\n            if(c == 'o'){\n                mp[i][j] = 1;\n            }else{\n                mp[i][j] = 0;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(mp[i][j] == 1){\n                add_edge(i+1,j+n+1,INF,-E[i][j]);\n                sm += E[i][j];\n            }else{\n                add_edge(i+1,j+n+1,INF,W[i][j]);\n            }\n        }\n    }\n    rep(i,n){\n        add_edge(0,i+1,1,0);\n        add_edge(i+n+1,2*n+1,1,0);\n    }\n    cout << sm + min_cost_flow(2*n+2,0,2*n+1,n) << \"\\n\";\n    vector<PP> ans;\n    rep(i,n){\n        rep(j,n){\n            if(mp[i][j] == 1 && memo[i+1][j+n+1] != 1){\n                ans.pb(PP(P(i+1,j+1),0));\n            }else if(mp[i][j] == 0 && memo[i+1][j+n+1] == 1){\n                ans.pb(PP(P(i+1,j+1),1));\n            }\n        }\n    }\n    cout << ans.size() << \"\\n\";\n    rep(i,ans.size()){\n        if(ans[i].se == 0){\n            cout << (ans[i].fi).fi << \" \" << (ans[i].fi).se << \"erase\\n\";\n        }else{\n            cout << (ans[i].fi).fi << \" \" << (ans[i].fi).se << \"write\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define rrep(i,n) for (int i = (n)-1; i >= 0; i--)\n#define rep2(i,s,n) for (int i = (s); i < (n); ++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vs vector<string>\n#define vc vector<char>\n#define vb vector<bool>\n#define vp vector<P>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing LP = pair<ll,ll>;\ntemplate<class T> istream& operator>>(istream& is,vector<T>& v) { for(T& t:v){is>>t;} return is; }\ntemplate<class T> ostream& operator<<(ostream& os,const vector<T>& v) { for(T t:v){os<<t<<\" \";} os<<\"\\n\"; return os; }\nvoid Yes(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YES(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate<class T> inline bool chmin(T& a,T b) {if(a > b){a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a,T b) {if(a < b){a = b; return true;} return false;}\nconst int inf = 1001001001;\nconst ll linf = 1001001001001001001;\n\ntemplate<typename T>\nclass Mincostflow {\n    using TP = pair<T,int>;\n    struct edge {\n        int to,cap,rev;\n        T cost;\n        edge(int to,int cap,T cost,int rev):to(to),cap(cap),cost(cost),rev(rev) {}\n    };\n    T tinf;\n    int n;\n    vector<vector<edge>> G;\n    vector<T> pot,dist;\n    vi prevv,preve;\n    // potential\n    void tinf_init(int x) { tinf = inf; }\n    void tinf_init(ll x) { tinf = linf; }\n\npublic:\n    explicit Mincostflow(int n):n(n),G(n),pot(n),dist(n),prevv(n),preve(n) {\n        T x = 0; tinf_init(x);\n    }\n    void add_edge(int from,int to,T cap,int cost) {\n        G[from].eb(to,cap,cost,G[to].size());\n        G[to].eb(from,0,-cost,G[from].size()-1);\n    }\n    // return -1 if impossible\n    // this must not be called more than once\n    T min_cost_flow(int s,int t,int f) {\n        T res = 0;\n        pot.assign(n,0);\n        while(f > 0) {\n            // use dijkstra to update pot\n            priority_queue<TP,vector<TP>,greater<TP>> q;\n            dist.assign(n,tinf);\n            dist[s] = 0;\n            q.emplace(0,s);\n            while(!q.empty()) {\n                T np = q.top().first;\n                int v = q.top().second;\n                q.pop();\n                if(dist[v] < np) continue;\n                rep(i,G[v].size()) {\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost+pot[v]-pot[e.to]) {\n                        dist[e.to] = dist[v]+e.cost+pot[v]-pot[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        q.emplace(dist[e.to],e.to);\n                    }\n                }\n            }\n            if(dist[t] == tinf) return -1;\n            rep(i,n) pot[i] += dist[i];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                chmin(d,G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*pot[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    };\n    bool used(int i,int j) {\n        for(edge e : G[i]) {\n            if(e.to != j) continue;\n            return e.cap == 0;\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int n;\n    cin >> n;\n    vvi w(n,vi(n));\n    auto e = w;\n    vs f(n);\n    cin >> w >> e >> f;\n    Mincostflow<int> fl(n*2+2);\n    rep(i,n) {\n        fl.add_edge(n*2,i,1,0);\n        fl.add_edge(n+i,n*2+1,1,0);\n    }\n    int ans = 0;\n    rep(i,n) rep(j,n) {\n        if(f[i][j] == 'o') {\n            ans += e[i][j];\n            fl.add_edge(i,n+j,1,-e[i][j]);\n        } else fl.add_edge(i,n+j,1,w[i][j]);\n    }\n    cout << ans+fl.min_cost_flow(n*2,n*2+1,n) << endl;\n    vp v;\n    rep(i,n) rep(j,n) {\n        bool b = fl.used(i,n+j);\n        if (f[i][j] == 'o' == !b) v.eb(i, j);\n    }\n    cout << v.size() << endl;\n    for(auto p : v) {\n        cout << p.first+1 << \" \" << p.second+1 << \" \";\n        cout << (f[p.first][p.second] == 'o' ? \"erase\" : \"write\") << \"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nconst int INF = (1<<28);\n\nclass Edge\n{\npublic:\n\tint src,dst,cst,cap,rev;\n\tEdge(int src, int dst, int cst, int cap, int rev)\n\t\t:src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n\tgraph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n\tgraph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n\npair<int, int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n  int V = graph.size();\n  vector<int> dist(V), prevv(V), preve(V);\n\n  int res = 0, fw = 0;\n  while(1) {\n    fill(dist.begin(), dist.end(), INF);\n    dist[S] = 0;\n    bool update = true;\n\n    while(update) {\n      update = false;\n      for(int v = 0; v < V; v++) {\n        if(dist[v] == INF) continue;\n\n        for(int i=0; i<graph[v].size(); i++) {\n          Edge& e = graph[v][i];\n          int cost = e.cst;\n          if(graph[e.dst][e.rev].cap != 0) cost = 0;\n\n          if(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n            dist[e.dst] = dist[e.src] + cost;\n            prevv[e.dst] = e.src;\n            preve[e.dst] = i;\n            update = true;\n          }\n        }\n      }\n    }\n\n    if(dist[T] == INF) break;\n\n    int f = INF;\n    for(int v = T; v != S; v = prevv[v])\n      f = min(f, graph[prevv[v]][preve[v]].cap);\n\n    res += dist[T];\n    fw += f;\n\n    for(int v = T; v != S; v = prevv[v]) {\n      Edge& e = graph[prevv[v]][preve[v]];\n      e.cap -= f;\n      graph[v][e.rev].cap += f;\n    }\n\n\tif(fw >= L) break;\n  }\n\n  return make_pair(res, fw);\n}\n\nint ecst[100][100], icst[100][100];\nint main()\n{\n\tint N;\n\tcin >> N;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> ecst[j][i];\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> icst[j][i];\n\n\tstring field[100];\n\tfor(int i=0; i<N; i++)\n\t\tcin >> field[i];\n\n\n\tint res = 0;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tif(field[i][j] == 'o') {\n\t\t\tres += ecst[j][i];\n\t\t}\n\t}\n\n\n\tGraph graph(N*N+2);\n\tfor(int i=0; i<N; i++) {\n\t\taddEdge(N*N, i, 1, 0, graph);\n\t\taddEdge(N+i, N*N+1, 1, 0, graph);\n\t}\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tint cst;\n\t\tif(field[i][j] == 'o') cst = -ecst[j][i];\n\t\telse cst = icst[j][i];\n\n\t\taddEdge(j, i+N, 1, cst, graph);\n\t}\n\n\tpair<int, int> fw = minimumCostFlow(N*N, N*N+1, N, graph);\n\n\n\tint ans = res + fw.first;\n\tcout << ans << endl;\n\n\tint c = 0;\n\tstringstream ss;\n\tfor(int i=0; i<N; i++) {\n\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\tEdge& e = graph[i][j];\n\n\t\t\tif(e.dst >= N*N) continue;\n\t\t\tif(e.src >= N) continue;\n\n\t\t\tif(field[e.dst-N][e.src] == 'o' && e.cap == 1) {\n\t\t\t\tc++;\n\t\t\t\tss << e.src + 1 << \" \" << e.dst + 1 - N << \" erase\" << endl;\n\t\t\t}\n\t\t\tif(field[e.dst-N][e.src] == '.' && e.cap == 0) {\n\t\t\t\tc++;\n\t\t\t\tss << e.src + 1 << \" \" << e.dst + 1 - N << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << c << endl;\n\tcout << ss.str();\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < int(Y);++(X))\n#define peat(X,Y) for (;(X) < int(Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,g[to].size(),cost});\n  g[to].pb((Edge){from,0,g[from].size()-1,-cost});\n}\nCost INF=1e7;\n\n//min-cost,dij\n\ntypedef pair<Cost,int> Que;\n\nint V;\n\n//f流せなければINF\nCost min_cost_flow(Graph &g,int s,int t,int f){\n  int V=g.size(),res=0;\n  vector<Cost> h(V,0),d(V);\n  vector<int> prevv(V),preve(V);\n  while(f>0){\n    priority_queue<Que,vector<Que>,greater<Que> > que;\n    int V=g.size();\n    d.resize(V);\n    fill(all(d),INF);\n    d[s]=0;\n    que.push(Que(0,s));\n    while(!que.empty()){\n      Que p=que.top();que.pop();\n      int v=p.Y;\n      if(d[v]<p.X)continue;\n      rep(i,g[v].size()){\n        Edge &e=g[v][i];\n        if(e.cap>0 && d[e.to]>d[v]+e.cost+h[v]-h[e.to]){\n          d[e.to]=d[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(Que(d[e.to],e.to));\n        }\n      }\n    }\n    if(d[t] == INF){\n      return INF;\n    }\n    rep(v,V)\n      h[v]+=d[v];\n    int flow=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      flow=min(flow,g[prevv[v]][preve[v]].cap);\n    }\n    f-=flow;\n    res+=flow*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      Edge &e=g[prevv[v]][preve[v]];\n      e.cap-=flow;\n      g[v][e.rev].cap+=flow;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k,n;\n  cin>>n;\n  vector<vector<int> > w(n,vector<int>(n)),e(n,vector<int>(n));\n  rep(i,n)rep(j,n)\n    cin>>w[i][j];\n  rep(i,n)rep(j,n)\n    cin>>e[i][j];\n  string str,strs[n];\n  Graph g(n*2+2);\n  rep(i,n){\n    cin>>str;\n    strs[i]=str;\n    int sum=0;\n    rep(j,n){\n      if(str[j]=='o'){\n        w[i][j]=-e[i][j];\n        sum+=e[i][j];\n      }\n    }\n    rep(j,n)\n      add_edge(g,i+2,j+n+2,1,sum+w[i][j]);\n    add_edge(g,0,i+2,1,0);\n    add_edge(g,i+n+2,1,1,0);\n  }\n  cout<<min_cost_flow(g,0,1,n)<<endl;\n  vector<pii> er,wr;\n  rep(i,n){\n    int fr=-1;\n    rep(j,g[i+n+2].size()){\n      if(g[i+n+2][j].cap){\n        fr=g[i+n+2][j].to-2;\n        break;\n      }\n    }\n    rep(j,n){\n      if(j==i){\n        if(strs[fr][j]=='.')\n          wr.pb(pii(fr,j));\n      }else{\n        if(strs[fr][j]=='o')\n          er.pb(pii(fr,j));\n      }\n    }\n  }\n  cout<<er.size()+wr.size()<<endl;\n  rep(i,er.size())\n    cout<<er[i].X+1<<\" \"<<er[i].Y+1<<\" erase\"<<endl;\n  rep(i,wr.size())\n    cout<<wr[i].X+1<<\" \"<<wr[i].Y+1<<\" write\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <utility>\n#include <queue>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int index, capacity, cost;\n    Edge(int i, int c, int d) : index(i), capacity(c), cost(d) {}\n};\n\nstruct Command {\n    int r, c;\n    string cmd;\n    Command(int r, int c, const string &cmd) : r(r), c(c), cmd(cmd) {}\n};\n\n// O(V^2 U C) where\n//  U = sum of capacity\n//  C = sum of cost\npair<int,int> primal_dual(const vector<vector<Edge> >& g, int source, int sink, vector<vector<int> > &flow)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)); \n  flow = vector<vector<int> >(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<Edge>::const_iterator it(g[i].begin()); it != g[i].end(); ++it) {\n      capacity[i][it->index] += it->capacity;\n      cost[i][it->index] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  for (int f = numeric_limits<int>::max(); f > 0; ) {\n    vector<int> dist(N, 1000000);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<Edge>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (capacity[n][it->index] - flow[n][it->index] > 0) {\n          const int c2 = c + cost[n][it->index] + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = n;\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return total;\n}/*}}}*/\n\nint write_cost[128][128];\nint erase_cost[128][128];\nchar field[128][128];\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            scanf(\"%d\", &write_cost[i][j]);\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            scanf(\"%d\", &erase_cost[i][j]);\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        scanf(\"%s\", &field[i][0]);\n    }\n\n    // 0..N-1: Row\n    // N..2N-1: Col\n    // 2N: Source\n    // 2N+1: Sink\n    vector<vector<Edge> > graph(2*N+2);\n    for(int r = 0; r < N; ++r) {\n        int sum = 0;\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o') sum += erase_cost[r][c];\n        }\n        for(int c = 0; c < N; ++c) {\n            int cost = sum;\n            if(field[r][c] == 'o') cost -= erase_cost[r][c];\n            else cost += write_cost[r][c];\n            graph[r].push_back(Edge(N+c, 1, cost));\n        }\n    }\n    for(int r = 0; r < N; ++r) {\n        graph[2*N].push_back(Edge(r, 1, 0));\n    }\n    for(int c = 0; c < N; ++c) {\n        graph[N+c].push_back(Edge(2*N+1, 1, 0));\n    }\n    vector<vector<int> > flow;\n    pair<int,int> result = primal_dual(graph, 2*N, 2*N+1, flow);\n    vector<Command> commands;\n    for(int r = 0; r < N; ++r) {\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o' && flow[r][N+c] == 0)\n                commands.push_back(Command(r+1, c+1, \"erase\"));\n            else if(field[r][c] == '.' && flow[r][N+c] > 0)\n                commands.push_back(Command(r+1, c+1, \"write\"));\n        }\n    }\n    cout << result.first << endl;\n    cout << commands.size() << endl;\n    for(vector<Command>::const_iterator it = commands.begin(); it != commands.end(); ++it) {\n        cout << it->r << ' ' << it->c << ' ' << it->cmd << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n\n        MinCostFlow solver(N * N + 2);\n        int Source = N * N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    count++;\n                }\n            }\n        }\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF) return -1;\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n\nint a[111][111],b[111][111],n,ans,cnt;\nstring s[111];\nsigned main(){\n  vector<P>er,wr;\n  set<P>used;\n  cin>>n;\n  PrimalDual p(n*2+2);\n  int x=n*2,y=n*2+1;\n  r(i,n)r(j,n)cin>>a[i][j];\n  r(i,n)r(j,n)cin>>b[i][j];\n  r(i,n)cin>>s[i];\n  r(i,n)r(j,n){\n    if(s[i][j]=='o'){\n      p.add_edge(i,n+j,1,-b[i][j]);\n      ans+=b[i][j];\n      er.push_back(P(i,j));\n    }\n    else p.add_edge(i,n+j,1,a[i][j]);\n  }\n  r(i,n)p.add_edge(x,i,1,0);\n  r(i,n)p.add_edge(i+n,y,1,0);\n  cout<<ans+p.flow(x,y,n)<<endl;\n  r(i,n){\n    vector<edge>v=p.G[i];\n    r(j,n){\n      if(v[j].cap==0){\n        if(v[j].cost<0)used.insert(P(i,j));\n        else wr.push_back(P(i,j));\n      }\n    }\n  }\n  r(i,er.size()){\n    if(used.count(er[i]))continue;\n    cnt++;\n  }\n  cout<<cnt+wr.size()<<endl;\n  r(i,er.size()){\n    if(used.count(er[i]))continue;\n    cout<<er[i].first+1<<' '<<er[i].second+1<<' '<<\"erase\"<<endl;\n  }\n  r(i,wr.size()){\n    cout<<wr[i].first+1<<' '<<wr[i].second+1<<' '<<\"write\"<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> wcost(n+1,vector<int>(n + 1));\n\tvector<vector<int>> ecost(n + 1, vector<int>(n + 1));\n\tvector<vector<bool>> ifwritten(n + 1, vector<bool>(n + 1));\n\tvector<vector<bool>> change(n + 1, vector<bool>(n + 1));\n\tvector<vector<int>> nowcost(n + 1, vector<int>(n + 1));\n\tint cost=0;\n\tint changenum = 0;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcin >> wcost[i][j];\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcin >> ecost[i][j];\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j, n) {\n\t\t\tif (s[j] == 'o') {\n\t\t\t\tifwritten[i][j] = true;\n\t\t\t\tchange[i][j] = true;\n\t\t\t\tnowcost[i][j] = -ecost[i][j];\n\t\t\t\tcost += ecost[i][j];\n\t\t\t\tchangenum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tifwritten[i][j] = false;\n\t\t\t\tchange[i][j] = false;\n\t\t\t\tnowcost[i][j] = wcost[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvector<int> retu(n + 1);\n\tREP(i, n) {\n\t\tretu[i] = i;\n\t\tcost += nowcost[i][i];\n\t\t\tnowcost[i][i] *= -1;\n\t\tif (change[i][i]) {\n\t\t\tchange[i][i] = false;\n\t\t\tchangenum--;\n\t\t}\n\t\telse {\n\t\t\tchange[i][i] = true;\n\t\t\tchangenum++;\n\t\t}\n\t}\n\tFOR(i, 0, n) {\n\t\tFOR(j, i+1, n) {\n\t\t\tif (nowcost[i][retu[i]] + nowcost[j][retu[j]] + nowcost[i][retu[j]] + nowcost[j][retu[i]] < 0) {\n\t\t\t\tcost += nowcost[i][retu[i]] + nowcost[j][retu[j]] + nowcost[i][retu[j]] + nowcost[j][retu[i]];\n\n\t\t\t\tnowcost[i][retu[i]] *= -1;\n\t\t\t\tif (change[i][retu[i]]) {\n\t\t\t\t\tchange[i][retu[i]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[i][retu[i]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tnowcost[i][retu[j]] *= -1;\n\t\t\t\tif (change[i][retu[j]]) {\n\t\t\t\t\tchange[i][retu[j]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[i][retu[j]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\n\t\t\t\tnowcost[j][retu[i]] *= -1;\n\t\t\t\tif (change[j][retu[i]]) {\n\t\t\t\t\tchange[j][retu[i]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[j][retu[i]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tnowcost[j][retu[j]] *= -1;\n\t\t\t\tif (change[j][retu[j]]) {\n\t\t\t\t\tchange[j][retu[j]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[j][retu[j]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tint a = retu[i];\n\t\t\t\tretu[i] = retu[j];\n\t\t\t\tretu[j] = a;\n\t\t\t}\n\t\t}\n\t}\n\tcout << cost << endl;\n\tcout << changenum << endl;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif (change[i][j]) {\n\t\t\t\tif (ifwritten[i][j]) {\n\t\t\t\t\tcout << i +1<< \" \" << j + 1 << \" \" << \"erase\" << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tcout << i + 1 << \" \" << j + 1 << \" \" << \"write\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\n// typedef pair<int, int> Pii;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nconst int INF = 99999999;\nconst int MAX_V = 210;\n\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];                   // potential\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // privious vertex, edge\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n\n// get min cost flow from s to t\n// if we cannot flow f, then return -1\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        // update h by dijkstra\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            rep(i, G[v].size()) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // no more flow\n            return -1;\n        }\n        rep(v, V) h[v] += dist[v];\n\n        // flow as much as possible along the minimum path from s to t\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, (int)G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    cin >> n;\n    V = 2 * n + 2;\n    vvi write(n, vi(n));\n    rep(i, n) rep(j, n) cin >> write[i][j];\n    vvi erase(n, vi(n));\n    rep(i, n) rep(j, n) cin >> erase[i][j];\n    vector<string> field(n);\n    rep(i, n) cin >> field[i];\n\n    const int s = 2 * n;\n    const int t = s + 1;\n    rep(i, n) {\n        add_edge(s, i, 1, 0);\n    }\n    rep(j, n) {\n        add_edge(j + n, t, 1, 0);\n    }\n\n    rep(i, n) {\n        rep(j, n) {\n            int cost = 0;\n            if (field[i][j] == '.') cost += write[i][j];\n            rep(k, n) {\n                if (k == j) continue;\n                if (field[i][k] == 'o') cost += erase[i][j];\n            }\n            add_edge(i, j + n, 1, cost);\n        }\n    }\n\n    int mincost = min_cost_flow(s, t, n);\n    vector<string> ans;\n    vector<int> selected(n, false);\n    rep(i, n) {\n        for (auto e : G[i]) {\n            if (n <= e.to && e.to < 2 * n && e.cap == 0) {\n                int j = e.to - n;\n                selected[i] = j;\n                if (field[i][j] == '.') {\n                    ans.emplace_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" write\");\n                }\n            }\n        }\n    }\n\n    rep(i, n) {\n        rep(j, n) {\n            if (field[i][j] == 'o' && j != selected[i]) {\n                ans.emplace_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" erase\");\n            }\n        }\n    }\n\n    cout << mincost << endl;\n    cout << ans.size() << endl;\n    for (auto str : ans) {\n        cout << str << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\nstruct PrimalDual {\n    typedef int Capacity;\n    typedef int Cost;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost {\n        inf = 1<<29,\n        MAX_V = 1000000\n    };\n\n    struct Edge {\n        int dst;\n        Capacity cap;\n        Capacity cap_orig;\n        Cost cost;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    PrimalDual(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].push_back(Edge(dst, cap, cost, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, -cost, g[src].size() - 1, true));\n    }\n\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n        static Cost h[MAX_V];\n        static Cost dist[MAX_V];\n        static Cost prevv[MAX_V];\n        static Cost preve[MAX_V];\n        rep(i,g.size())h[i] = 0;\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            rep(i,g.size()) dist[i] = inf;\n            dist[s] = 0;\n            q.push(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.push(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.min_cost_flow(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nedge G[MAX_V][MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from][to] = (edge){1, cost};\n\tG[to][from] = (edge){0, -cost};\n}\n\nint bit_matching_cost(int l, int r) {\n\tfor (int i = 0; i < l; i++) {\n\t\tadd_edge(l+r, i, 1, 0);\n\t}\n\tfor (int i = l; i < l+r; i++) {\n\t\tadd_edge(i, l+r+1, 1, 0);\n\t}\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (true) {\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[l+r] = 0;\n\n        fill_n(used, V, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < V; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            used[v] = true;\n\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t}\n\t\t\t}\n        }\n\t\tif (dist[l+r+1] == INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l+r+1];\n\t\tfor (int v = l+r+1; v != l+r; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][v];\n\t\t\te.cap -= 1;\n\t\t\tG[v][prevv[v]].cap += 1;\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][N+j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nstruct min_cost_max_flow {\n    struct edge {\n        int to;\n        ll cap, cost;\n        int rev;\n        bool isrev;\n    };\n\n    int n, s, t;\n    ll neg;\n    vector<vector<edge>> g;\n    vector<ll> d, h, dist, prevv, preve;\n\n    ll flow(vector<ll> d0) {\n        ll res = 0;\n        priority_queue<PII, vector<PII>, greater<PII>> que;\n        h.assign(n, 0);\n        preve.assign(n, -1);\n        prevv.assign(n, -1);\n        ll f = 0;\n        REP(i, d.size()) {\n            if(i < (ll)d0.size()) d[i] += d0[i];\n            if(d[i] > 0) add_edge(s, i, d[i], 0), f += d[i];\n            else if(d[i] < 0) add_edge(i, t, -d[i], 0);\n        }\n        while(f > 0) {\n            dist.assign(n, INF);\n            dist[s] = 0;\n            que.push({0, s});\n            while(que.size()) {\n                PII p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                REP(i, g[v].size()) {\n                    edge &e = g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push({dist[e.to], e.to});\n                    }\n                }\n            }\n            if(dist[t] == INF) return -1;\n            REP(v, n) h[v] += dist[v];\n            ll d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                chmin(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d; res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.rev].cap += d;\n            }\n        }\n        return neg + res;\n    }\n\n    min_cost_max_flow(int n0) : n(n0+2), s(n0), t(n0+1), neg(0), g(n0+2), d(n0+2) {}\n\n    void add_edge(int from, int to, ll cap, ll cost) {\n        if(cost >= 0) {\n            g[from].push_back({to, cap, cost, (int)g[to].size(), false});\n            g[to].push_back({from, 0, -cost, (int)g[from].size()-1, true});\n        } else {\n            d[from] -= cap;\n            d[to] += cap;\n            neg += cap * cost;\n            add_edge(to, from, cap, -cost);\n        }\n    }\n    // SからTに流量fを流す 流せないなら-1\n    // F'を負辺の容量の和とすると O((f+F')ElogV) \n    ll flow(int S, int T, ll f) {\n        vector<ll> d0(n);\n        d0[S] = f, d0[T] = -f;\n        return flow(d0);\n    }\n\n    friend ostream &operator <<(ostream& out, const min_cost_max_flow& a){\n        out << endl;\n        for(int i = 0; i < (int)a.g.size(); i++) {\n            for(auto &e : a.g[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = a.g[e.to][e.rev];\n                out << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \") cost:\" << e.cost << endl;\n            }\n        }\n        return out;\n    }\n};\n\nint main(void) {\n    ll n;\n    cin >> n;\n    vector<vector<ll>> w(n, vector<ll>(n)), e(n, vector<ll>(n));\n    vector<string> f(n);\n    REP(i, n) REP(j, n) cin >> w[i][j];\n    REP(i, n) REP(j, n) cin >> e[i][j];\n    REP(i, n) cin >> f[i];\n\n    ll ret = 0;\n    min_cost_max_flow graph(2*n+2);\n    ll s = 2*n, t = s+1;\n\n    REP(i, n) {\n        graph.add_edge(s, i, 1, 0);\n        graph.add_edge(n+i, t, 1, 0);\n    }\n    REP(i, n) REP(j, n) {\n        if(f[i][j] == 'o') {\n            ret += e[i][j];\n            graph.add_edge(i, n+j, 1, -e[i][j]);\n        } else {\n            graph.add_edge(i, n+j, 1, w[i][j]);\n        }\n    }\n    cout << ret + graph.flow(s, t, n) << endl;\n\n    // 復元\n    vector<string> g(n, string(n, '.'));\n    REP(i, n) for(auto e: graph.g[i]) {\n        if(e.cap == 0 && n <= e.to && e.to < 2*n) {\n            g[i][e.to-n] = 'o';\n        }\n    }\n    vector<PII> ans;\n    REP(i, n) REP(j, n) if(f[i][j]!=g[i][j]) ans.push_back({i, j});\n    cout << ans.size() << endl;\n    for(auto i: ans) {\n        cout << i.first+1 << \" \" << i.second+1;\n        if(f[i.first][i.second] == '.') cout << \" write\" << endl;\n        else cout << \" erase\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    const int INF = INT_MAX / 2;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to, cap, cost;\n        Edge* rev;\n        Edge(int from, int to, int cap, int cost) : from(from), to(to), cap(cap), cost(cost) {}\n    };\n    vector<vector<Edge*>> G;\n\n    void addEdge(int from, int to, int cap, int cost) {\n        assert(from != to);\n        Edge* e = new Edge(from, to, cap, cost);\n        Edge* r = new Edge(to, from, 0, -cost);\n        e->rev = r;\n        r->rev = e;\n        G[from].push_back(e);\n        G[to].push_back(r);\n    }\n\n    int minCostFlow(int s, int t, int f) {\n        const int N = G.size();\n        int ret = 0;\n        vector<Edge*> prev(N, nullptr);\n        while (f > 0) {\n            // Bellman Ford\n            vector<int> D(N, INF);\n            D[s] = 0;\n            bool updated = true;\n            while (updated) {\n                updated = false;\n                for (int v = 0; v < N; v++) {\n                    if (D[v] == INF) continue;\n                    for (auto e : G[v]) {\n                        if (e->cap == 0) continue;\n                        int ncost = D[v] + e->cost;\n                        if (D[e->to] > ncost) {\n                            D[e->to] = ncost;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n\n            if (D[t] == INF) return -1; // ?°???¶?????¶????????????????????????s?????????t??????????????¨?????????????????????????????±?????????\n            int d = f;\n            for (Edge* p = prev[t]; p != nullptr; p = prev[p->from]) {\n                d = min(d, p->cap);\n            }\n\n            f -= d;\n            ret += d * D[t];\n            for (Edge* p = prev[t]; p != nullptr; p = prev[p->from]) {\n                p->cap -= d;\n                p->rev->cap += d;\n            }\n        }\n        return ret;\n    }\n    \n\n    int N;\n    vector<vector<int>> W, E;\n    vector<string> F;\n\n    void input() {\n        cin >> N;\n        W.resize(N, vector<int>(N, 0)); cin >> W;\n        E.resize(N, vector<int>(N, 0)); cin >> E;\n        F.resize(N); cin >> F;\n    }\n\n    void solve() {\n        G.clear(); G.resize(2 + 2 * N);\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int cost = 0;\n                for (int k = 0; k < N; k++) {\n                    if (F[i][k] == 'o') {\n                        cost += (j == k ? 0 : E[i][k]);\n                    } else {\n                        cost += (j == k ? W[i][k] : 0);\n                    }\n                }\n                addEdge(1 + i, 1 + N + j, 1, cost);\n            }\n            addEdge(0, 1 + i, 1, 0);\n            addEdge(1 + N + i, 1 + 2 * N, 1, 0);\n        }\n        cout << minCostFlow(0, 1 + 2 * N, N) << endl;\n\n        vector<string> X(N, string(N, '.'));\n        for (int i = 1; i <= N; i++) {\n            for (auto e : G[i]) {\n                if (e->cap == 0) {\n                    if (e->to <= N || e->to > 2*N) continue;\n                    X[e->from - 1][e->to - (N + 1)] = 'o';\n                }\n            }\n        }\n        int c = 0;\n        ostringstream os;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (F[i][j] == X[i][j]) continue;\n                c++;\n                os << i + 1 << \" \" << j + 1 << \" \" << (F[i][j] == 'o' ? \"erase\" : \"write\") << endl;\n            }\n        }\n        cout << os.str() << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <fstream>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nclass CostFlow\n{\npublic:\n    using Cost = ll;\n    using Ind = int;\n    using Capacity = ll;\n    using T = ll;\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}\n    {\n        edge.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // // Bellman-Ford(Replace this when DAG)\n        // for (int i = 0; i < V; i++) {\n        //     m_potential[i] = INF<T>;\n        // }\n        // m_potential[s] = 0;\n        // bool no_negative_loop = true;\n        // for (int i = 0; i < V; i++) {\n        //     for (int v = 0; v < V; v++) {\n        //         if (m_potential[v] != INF<T>) {\n        //             for (const auto& e : edge[v]) {\n        //                 if (e.capacity <= 0) {\n        //                     continue;\n        //                 }\n        //                 if (m_potential[e.to] > m_potential[v] + e.cost) {\n        //                     m_potential[e.to] = m_potential[v] + e.cost;\n        //                     if (i == V - 1) {\n        //                         m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n        //                         no_negative_loop = false;\n        //                     }\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // if (not no_negative_loop) {\n        //     // ????????¨?????????\n        // }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                //                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> m_dist;\n    vector<Cost> m_potential;\n    vector<Ind> m_prev_v;\n    vector<Ind> m_prev_e;\n};\n\nstruct Ope {\n    bool o;\n    int r;\n    int c;\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<ll>> W(n, vector<ll>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n    vector<vector<ll>> E(n, vector<ll>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    vector<vector<bool>> use(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n; j++) {\n            use[i][j] = (s[j] == 'o');\n        }\n    }\n\n    vector<vector<ll>> c(n, vector<ll>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (not use[i][j]) {\n                c[i][j] = W[i][j];\n            } else {\n                for (int k = 0; k < n; k++) {\n                    if (j == k) {\n                        continue;\n                    }\n                    c[i][k] += E[i][j];\n                }\n                // for (int k = 0; k < n; k++) {\n                //     if (i == k) {\n                //         continue;\n                //     }\n                //     c[k][j] += E[i][j];\n                // }\n            }\n        }\n    }\n\n    CostFlow flow(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            flow.addEdge(i, j + n, 1, c[i][j]);\n        }\n    }\n    const int s = 2 * n;\n    const int t = 2 * n + 1;\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(s, i, 1, 0);\n        flow.addEdge(n + i, t, 1, 0);\n    }\n    cout << flow.minCostFlow(s, t, n) << endl;\n\n    vector<Ope> op;\n    for (int i = 0; i < n; i++) {\n        for (const auto& e : flow.edge[i]) {\n            if (e.is_reverse) {\n                continue;\n            }\n            if (e.flow == 1) {\n                if (not use[i][e.to - n]) {\n                    op.push_back(Ope{false, i, e.to - n});\n                }\n            } else {\n                if (use[i][e.to - n]) {\n                    op.push_back(Ope{true, i, e.to - n});\n                }\n            }\n        }\n    }\n\n    cout << op.size() << endl;\n    for (const auto& o : op) {\n        cout << o.r + 1 << \" \" << o.c + 1 << \" \" << (o.o ? \"erase\" : \"write\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cap,cost,rev;};\nvector<edge> G[100010];\nbool used[100010];\nint h[100010],dist[100010],prevv[100010],preve[100010];\nint V;//Vは頂点数\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back( (edge){to,cap,cost,(ll)G[to].size()} );\n\t\tG[to].push_back( (edge){from,0,-cost,(ll)G[from].size()-1 });\n}\n\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue <P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,inf);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile( !que.empty() ){\n\t\t\tP p=que.top();que.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t}\n\t}\n\tif(dist[t]==inf) return -1;\n\tfor(int v=0;v<V;v++)h[v] += dist[v];\n\tint d=f;\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t}\n\tf -= d;\n\tres += d*h[t];\n\tfor(int v=t; v!=s;v=prevv[v]){\n\t\tedge &e =G[prevv[v]][preve[v]];\n\t\te.cap -=d;\n\t\tG[v][e.rev].cap +=d;\n\t}\n}\nreturn res;\n}\nvector<pa> ans;\nint w[100][110],e[110][110],a[110][110];\n   signed main(){\nint n;\n   \tcin>>n;\nV=300;\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>w[i][j];\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)cin>>e[i][j];\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \tstring s;\n   \t\tcin>>s;\n   \t\t\n   \t\ts=\"q\"+s;\n   \t\tfor(int j=1;j<=n;j++){\n   \t\t\tif(s[j]=='o')a[i][j]=1;\n   \t\t\telse a[i][j]=0;\n   \t\t}\n   \t\n   \t\n   \t}\n   \t\n   \t\n   \tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n   \tint gosa=0;\n   \t\tfor(int k=1;k<=n;k++)if(k!=j){\n   \t\t\tif(a[i][k]==1)gosa+=e[i][k];\n   \t\t}\n   \t\tif(a[i][j]==0) gosa+=w[i][j];\n   \t\t\n   \t\tadd_edge(i,n+j,1 ,gosa);\n   \t\n   \t}\n   \t\n   \tfor(int i=1;i<=n;i++){\n   \t\tadd_edge(0,i,1,0);\n   \t\tadd_edge(n+i,2*n+1,1,0);\n   \t}\n   \t\n   \tcout<<min_cost_flow(0,2*n+1,n)<<endl;\n   \tfor(int i=1;i<n+1;i++)for(auto e:G[i]){\n   \t\tif(e.to==0 ) continue;\n   \t\tif(e.cap==1 && a[i][e.to-n]==1) ans.pb(mp(i,e.to));\n   \t\tif(e.cap==0 && a[i][e.to-n]==0) ans.pb(mp(i,e.to));\n   \t}\n   \tcout<<ans.size()<<endl;\n   \tfor(auto v:ans){\n   \t\tif(a[v.first][v.second-n])cout<<v.first<<\" \" <<v.second-n<<\" erase\"<<endl;\n   \t\telse cout<<v.first<<\" \" <<v.second-n<<\" write\"<<endl;\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nedge G[MAX_V][MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from][to] = (edge){1, cost};\n\tG[to][from] = (edge){0, -cost};\n}\n\nint bit_matching_cost(int l, int r) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (true) {\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[l+r] = 0;\n\n        fill_n(used, V, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < V; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            used[v] = true;\n\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t}\n\t\t\t}\n        }\n\t\tif (dist[l+r+1] == INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l+r+1];\n\t\tfor (int v = l+r+1; v != l+r; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][v];\n\t\t\te.cap -= 1;\n\t\t\tG[v][prevv[v]].cap += 1;\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N*2, i, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N+i, N*2+1, 1, 0);\n\t}\n\tf += bit_matching_cost(N, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][N+j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nusing Weight = int;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\nconstexpr int INF = 1000000000;\n\npair<Weight, Array> hungarian(const Matrix &m) {\n  int n = m.size();\n  int p, q;\n  Array fx(n, INF), fy(n, 0);\n  vector<int> x(n, -1), y(n, -1);\n  REP(i,n)REP(j,n) fx[i] = min(fx[i], m[i][j]);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == m[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      Weight d = INF;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - m[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  Weight ret = 0;\n  Array match;\n  for (int i = 0; i < n; ++i) {\n    ret += m[i][x[i]];\n    match.push_back(x[i]);\n  }\n  return make_pair(ret, match);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  Matrix mat(n, Array(n));\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        mat[i][j] = 1000 - e[i][j];\n        cost += e[i][j];\n      } else {\n        mat[i][j] = 1000 + w[i][j];\n      }\n    }\n  }\n  auto res = hungarian(mat);\n  cout << (res.first - n*1000 + cost) << endl;\n  stringstream ss;\n  int count = 0;\n  REP(i,n)REP(j,n) {\n    if (res.second[i] == j) {\n      if (m[i][j] == '.') {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++count;\n      }\n    } else {\n      if (m[i][j] == 'o') {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++count;\n      }\n    }\n  }\n  cout << count << endl;\n  cout << ss.str() << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(c) (c).begin(), (c).end()\n#define rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define per(i,a,b) for(ll i=(b-1);i>=(a);--i)\n#define clr(a, b) memset((a), (b) ,sizeof(a))\n#define ctos(c) string(1,c)\n#define print(x) cout<<#x<<\" = \"<<x<<endl;\n\n#define MOD 1000000007\n\n#define MAX_V 210\n#define INF 1000000000000000000LL\n\ntypedef pair<long long, long long> P;\nstruct edge{long long to, cap, cost, rev;};\nvector<edge> G[MAX_V];\nlong long h[MAX_V];\nlong long dist[MAX_V];\nlong long prevv[MAX_V];\nlong long preve[MAX_V];\n\nvoid ae(long long from, long long to, long long cap, long long cost){\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nlong long minCostFlow(long long s, long long t, long long f, long long V){\n  long long res = 0;\n  memset(h,0,sizeof(h));\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    for(long long i = 0; i < V; i++){\n      dist[i] = INF;\n    }\n    dist[s] = 0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      long long v = p.second;\n      if(dist[v] < p.first)continue;\n      for(long long i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == INF){\n      return -1;\n    }\n    for(long long v = 0; v < V; v++){\n      h[v] += dist[v];\n    }\n    long long d = f;\n    for(long long v = t; v != s; v = prevv[v]){\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for(long long v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nll dw[110][110];\nll de[110][110];\nvector<string> vs;\n\nint main(){\n    ll n;\n    cin>>n;\n    rep(y,0,n){\n        rep(x,0,n){\n            ll a;\n            cin>>a;\n            dw[y][x] = a;\n        }\n    }\n    rep(y,0,n){\n        rep(x,0,n){\n            ll a;\n            cin>>a;\n            de[y][x] = a;\n        }\n    }\n    rep(i,0,n){\n        string s;\n        cin>>s;\n        vs.pb(s);\n    }\n    rep(y,0,n){\n        rep(x,0,n){\n            ll c = 0;\n            if(vs[y][x] == '.')c += dw[y][x];\n            rep(i,0,n){\n                if(i==x)continue;\n                if(vs[y][i]=='o')c += de[y][i];\n            }\n            ae(y,n+x,1,c);\n        }\n    }\n    ll start = 2*n;\n    ll end = 2*n+1;\n    rep(i,0,n){\n        ae(start,i,1,0);\n    }\n    rep(i,0,n){\n        ae(n+i,end,1,0);\n    } \n    ll ans = minCostFlow(start,end,n,2*n+2);\n    ll dd[110][110];\n    clr(dd,0);\n    rep(y,0,n){\n        rep(x,0,n){\n            rep(i,0,G[y].sz){\n                edge e = G[y][i];\n                if(e.cap==0){\n                    dd[y][e.to-n] = 1;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    ll c = 0;\n    rep(y,0,n){\n        rep(x,0,n){\n            if(vs[y][x]=='o'&&dd[y][x]==0){\n                c++;\n            }\n            if(vs[y][x]=='.'&&dd[y][x]==1){\n                c++; \n            }\n        }\n    }\n    cout << c << endl;\n    rep(y,0,n){\n        rep(x,0,n){\n            if(vs[y][x]=='o'&&dd[y][x]==0){\n                cout << y+1 << \" \" << x+1 << \" erase\" << endl; \n            }\n            if(vs[y][x]=='.'&&dd[y][x]==1){\n                cout << y+1 << \" \" << x+1 << \" write\" << endl; \n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 514\n#define INF (1<<29)\n\nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int cost, int rev) :\n        to(to), cap(cap), cost(cost), rev(rev) {}\n};\n\nint V;\nvector<Edge> G[MAX_V];\nint dist[MAX_V], prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f)\n{\n    int res = 0;\n    while (f > 0) {\n\tfill(dist, dist + V, INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile (update) {\n\t    update = false;\n\t    for (int v = 0; v < V; v++) {\n\t\tif (dist[v] == INF) continue;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t    Edge &e = G[v][i];\n\t\t    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (dist[t] == INF) return -1;\n\tint d = f;\n\tfor (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n\t}\n        f -= d;\n\tres += d * dist[t];\n\tfor (int v = t; v != s; v = prevv[v]) {\n\t    Edge &e = G[prevv[v]][preve[v]];            \n\t    e.cap -= d;\n\t    G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<vector<int>> W(N, vector<int>(N)), E(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> W[i][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> E[i][j];\n        }\n    }\n    \n    int sum = 0;\n    vector<vector<char>> F(N, vector<char>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> F[i][j];\n            if (F[i][j] == 'o') {\n                sum += E[i][j];\n            }\n        }\n    }\n\n    int S = N * N, T = S + 1;\n    V = T + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(S, i, 1, 0);\n        add_edge(N+i, T, 1, 0);\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (F[i][j] == 'o') {\n                add_edge(i, j + N, 1, -E[i][j]);\n            } else {\n                add_edge(i, j + N, 1, W[i][j]);\n            }\n        }\n    }\n    \n    cout << min_cost_flow(S, T, N) + sum << endl;\n    vector<int> r, c, op;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int k = G[i][j].to - N;\n            if (G[i][j].cap == 0 && F[i][k] == '.' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(0);\n            }\n            if (G[i][j].cap > 0 && F[i][k] == 'o' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(1);\n            }\n        }\n    }\n\n    cout << r.size() << endl;\n    for (int i = 0; i < (int)r.size(); i++) {\n        cout << r[i] << \" \" << c[i] << \" \";\n        cout << (op[i] == 0 ? \"write\" : \"erase\") << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        assert(N == 3);\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        REP(y, N) REP(x, N) assert(W[y][x] == 1);\n        REP(y, N) REP(x, N) assert(E[y][x] == 1);\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n        REP(y, N) REP(x, N){\n            string s[3] = {\"o.o\", \"...\", \".o.\"};\n            assert(s[y][x] == grid[y][x]);\n        }\n\n        MinCostFlow solver(N * N + 2);\n        int Source = N * N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    count++;\n                }\n            }\n        }\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nstruct edge/*{{{*/\n{\n  int to;\n  int capacity;\n  int cost;\n  edge(int i, int c, int d) : to(i), capacity(c), cost(d) {}\n};/*}}}*/\n\npair<int,vector<vector<int> > > primal_dual(const vector<vector<edge> >& g, int source, int sink)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)), flow(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<edge>::const_iterator it = g[i].begin(); it != g[i].end(); ++it) {\n      capacity[i][it->to] += it->capacity;\n      cost[i][it->to] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  static const int INF = 10000000;\n  for (int f = INF; f > 0; ) {\n    vector<int> dist(N, INF);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<edge>::const_iterator it = g[n].begin(); it != g[n].end(); ++it) {\n        if (capacity[n][it->to] - flow[n][it->to] > 0) {\n          const int c2 = c + cost[n][it->to] + h[n] - h[it->to];\n          if (c2 < dist[it->to]) {\n            dist[it->to] = c2;\n            parent[it->to] = n;\n            q.push(make_pair(-c2, it->to));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return make_pair(total.first, flow);\n}/*}}}*/\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > erase(N, vector<int>(N)), write(N, vector<int>(N));\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> erase[i][j];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cin >> write[i][j];\n    }\n  }\n  vector<string> grid(N);\n  for (int i = 0; i < N; i++) {\n    cin >> grid[i];\n    int sum = 0;\n    for (int j = 0; j < N; j++) {\n      if (grid[i][j] == 'o') {\n        sum += erase[i][j];\n      }\n    }\n    for (int j = 0; j < N; j++) {\n      if (grid[i][j] == 'o') {\n        write[i][j] = sum - erase[i][j];\n      } else {\n        write[i][j] += sum;\n      }\n    }\n  }\n\n  vector<vector<edge> > g(2*N+2);\n  const int source = 2*N, sink = 2*N+1;\n  for (int i = 0; i < N; i++) {\n    const int row = i, col = N+i;\n    g[source].push_back(edge(row, 1, 0));\n    g[col].push_back(edge(sink, 1, 0));\n  }\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      g[row].push_back(edge(col, 1, write[i][j]));\n      g[col].push_back(edge(row, 0, -write[i][j]));\n    }\n  }\n\n  const pair<int,vector<vector<int> > > r = primal_dual(g, source, sink);\n  cout << r.first << endl;\n  const vector<vector<int> >& flow = r.second;\n  vector<string> steps;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      const int row = i, col = N+j;\n      if (flow[row][col] == 1 && grid[i][j] == '.') {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" write\";\n        steps.push_back(oss.str());\n      } else if (flow[row][col] == 0 && grid[i][j] == 'o') {\n        ostringstream oss;\n        oss << i+1 << \" \" << j+1 << \" erase\";\n        steps.push_back(oss.str());\n      }\n    }\n  }\n  cout << steps.size() << endl;\n  copy(steps.begin(), steps.end(), ostream_iterator<string>(cout, \"\\n\"));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nusing Weight = int;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\nconstexpr int INF = 1000000000;\n\npair<Weight, Array> hungarian(const Matrix &m) {\n  int n = m.size();\n  int p, q;\n  Array fx(n, INF), fy(n, 0);\n  vector<int> x(n, -1), y(n, -1);\n  REP(i,n)REP(j,n) fx[i] = min(fx[i], m[i][j]);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == m[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      Weight d = INF;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - m[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  Weight ret = 0;\n  Array match;\n  for (int i = 0; i < n; ++i) {\n    ret += m[i][x[i]];\n    match.push_back(x[i]);\n  }\n  return make_pair(ret, match);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  Matrix mat(n, Array(n));\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        mat[i][j] = 1000 - e[i][j];\n        cost += e[i][j];\n      } else {\n        mat[i][j] = 1000 + w[i][j];\n      }\n    }\n  }\n  auto res = hungarian(mat);\n  stringstream ss;\n  int count = 0;\n  REP(i,n)REP(j,n) {\n    if (res.second[i] == j) {\n      if (m[i][j] == '.') {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++count;\n      }\n    } else {\n      if (m[i][j] == 'o') {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++count;\n      }\n    }\n  }\n  cout << (res.first - count*1000 + cost) << endl;\n  cout << count << endl;\n  cout << ss.str() << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\nusing Weight = int;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\nconstexpr int INF = 1000000000;\n\n\npair<Weight, Array> hungarian(const Matrix &m) {\n  int n = m.size();\n  int p, q;\n  Array fx(n, INF), fy(n, 0);\n  vector<int> x(n, -1), y(n, -1);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n+1, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == m[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      Weight d = INF;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - m[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  Weight ret = 0;\n  REP(i,n) ret += m[i][x[i]];\n  return make_pair(ret, x);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  Matrix mat(n, Array(n));\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        mat[i][j] = 1000 + e[i][j];\n        cost += e[i][j];\n      } else {\n        mat[i][j] = 1000 - w[i][j];\n      }\n    }\n  }\n  auto res = hungarian(mat);\n  cout << (n*1000 - res.first + cost) << endl;\n  int cnt = 0;\n  stringstream ss;\n  REP(i,n)REP(j,n) {\n    if (m[i][j] == 'o') {\n      if (res.second[i] != j) {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++cnt;\n      }\n    } else {\n      if (res.second[i] == j) {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++cnt;\n      }\n    }\n  }\n  cout << cnt << endl;\n  cout << ss.str() << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            if (v < l+1) {\n            \tused[v] = true;\n\t            for (int i = l+1; i < l+r+2; i++) {\n\t\t\t\t\tif (!flow[v][i-(l+1)] && dist[i] > dist[v] + G[v][i-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] + G[v][i-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v-(l+1)] && dist[i] > dist[v] - G[i][v-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] - G[i][v-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tfor (int v = l; v != l+r+1 ; v = prevv[v]) {\n\t\t\tif (v < l+1) {\n\t\t\t\tflow[v][prevv[v]-(l+1)] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v-(l+1)] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge{int to,cap,cost,rev;};\nconst int MAX_V=202,INF=1e9;\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V],dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n\tedge e1=edge{to,cap,cost,G[to].size()},e2=edge{from,0,-cost,G[from].size()};\n\tG[from].pb(e1),G[to].pb(e2);\n}\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.sc;\n\t\t\tif(dist[v]<p.fs) continue;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\trep(v,V) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tchmin(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint N;\n\tint w[100][100],e[100][100];\n\tstring s[100];\n\tcin>>N;\n\trep(i,N) rep(j,N) cin>>w[i][j];\n\trep(i,N) rep(j,N) cin>>e[i][j];\n\trep(i,N) cin>>s[i];\n\tint S=2*N,T=2*N+1;\n\tV=2*N+2;\n\trep(i,N) add_edge(S,i,1,0);\n\trep(i,N) add_edge(N+i,T,1,0);\n\trep(i,N) rep(j,N){\n\t\tint c=0;\n\t\trep(k,N){\n\t\t\tif(k==j){\n\t\t\t\tif(s[i][k]=='.') c+=w[i][k];\n\t\t\t}else{\n\t\t\t\tif(s[i][k]=='o') c+=e[i][k];\n\t\t\t}\n\t\t}\n\t\tadd_edge(i,N+j,1,c);\n\t}\n\tint f=min_cost_flow(S,T,N);\n\tcout<<f<<endl;\n\tbool is[100][100]={};\n\trep(v,N){\n\t\tfor(edge e:G[v]){\n\t\t\tint u=e.to;\n\t\t\tif(u<2*N){\n\t\t\t\tis[v][u-N]=(e.cap==0);\n\t\t\t}\n\t\t}\n\t}\n\tint c=0;\n\trep(i,N) rep(j,N) if((s[i][j]=='o')^is[i][j]) c++;\n\tcout<<c<<endl;\n\trep(i,N) rep(j,N){\n\t\tif((s[i][j]=='o')&&!is[i][j]) printf(\"%d %d erase\\n\",i+1,j+1);\n\t\tif((s[i][j]=='.')&&is[i][j]) printf(\"%d %d write\\n\",i+1,j+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nconst int M = 1000000007;\n \ntypedef pair<int, int> P;\nstruct edge { int to, cap, cost, rev; };\n \nint V;\nvector<edge> G[210];\nint h[210];\nint dist[210];\nint prevv[210], preve[210];\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){ to, cap, cost, (int)G[to].size() });\n    G[to].push_back((edge){ from, 0, -cost, (int)G[from].size() - 1 });\n}\n \nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        priority_queue<P, vector<P>, greater<P> > q;\n        fill(dist, dist + V, M);\n        dist[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty()) {\n            P p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < (int)G[v].size(); ++i) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    q.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == M) return -1;\n        for (int v = 0; v < V; ++v)\n            h[v] += dist[v];\n \n        int d = f;\n        for (int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n \n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n \n \nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> wc(n, vector<int>(n));\n    vector<vector<int>> ec(n, vector<int>(n));\n    vector<vector<int>> cost(n, vector<int>(n));\n    vector<string> s(n);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cin >> wc[i][j];\n \n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            cin >> ec[i][j];\n \n    for (int i = 0; i < n; ++i)\n        cin >> s[i];\n \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int c = (s[i][j] == 'o' ? 0 : wc[i][j]);\n            for (int k = 0; k < n; ++k)\n                if (k != j && s[i][k] == 'o')\n                    c += ec[i][k];\n \n            cost[i][j] = c;\n        }\n    }\n    V = n * 2 + 2;\n    for (int i = 0; i < n; ++i) {\n        add_edge(n * 2, i, 1, 0);\n        add_edge(n + i, n * 2 + 1, 1, 0);\n    }\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            add_edge(i, n + j, 1, cost[i][j]);\n \n    int mc = min_cost_flow(n * 2, n * 2 + 1, n);\n    vector<vector<int>> cir(n, vector<int>(n, 0));\n    for (int i = 0; i < n; ++i)\n        for (edge& e : G[i])\n            if (e.to >= n && e.to < n * 2 && e.cap == 0)\n                cir[i][e.to - n] = 1;\n \n    vector<string> ans;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (s[i][j] == '.' && cir[i][j])\n                ans.push_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" write\\n\");\n            if (s[i][j] == 'o' && !cir[i][j])\n                ans.push_back(to_string(i + 1) + \" \" + to_string(j + 1) + \" erase\\n\");\n        }\n    }\n    cout << mc << \"\\n\" << ans.size() << \"\\n\";\n    for (string i : ans)\n        cout << i;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\n\nstruct Edge {\n    int to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(int from, int to, int cap, int cost) {\n    if (from < 0 || to < 0) return;\n    G[from].push_back({to, cap, cost, (int)G[to].size()});\n    G[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint dist[21000], h[21000] = {0}, prevV[21000], prevE[21000];\nll min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    while (f > 0) {\n        fill(&dist[0], &dist[0]+21000, inf); dist[s] = 0;\n        priority_queue<P, vector<P>, greater<P> > Q; Q.push({0, s});\n        while ( !Q.empty() ) {\n            P p = Q.top(); Q.pop();\n            int v = p.second;\n            if (p.first > dist[v]) continue;\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge& e = G[v][i];\n                if (e.cap > 0 && dist[v]+e.cost+h[v]-h[e.to] < dist[e.to]) {\n                    dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                    prevV[e.to] = v;\n                    prevE[e.to] = i;\n                    Q.push({dist[e.to], e.to});\n                }\n            }\n        }\n        for (int i = 0; i < G.size(); ++i) h[i] += dist[i];\n\n        if (dist[t] == inf) {\n            cout << \"ERROR\" << endl;\n            exit(1);\n        }\n\n        int d = f;\n        for (int v = t; v != s; v = prevV[v]) {\n            d = min(d, G[prevV[v]][prevE[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevV[v]) {\n            Edge& e = G[prevV[v]][prevE[v]];\n            e.cap -= d;\n            G[e.to][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n; cin >> n;\n    vector< vector<int> > O(n, vector<int>(n)); cin >> O;\n    vector< vector<int> > X(n, vector<int>(n)); cin >> X;\n    vector<string> m(n); cin >> m;\n    vector<int> row(n), col(n);\n    REP(i, n) row[i] = i;\n    REP(i, n) col[i] = n+i;\n    int s = n*2, t = s+1;\n    G.clear(); G.resize(t+1);\n    REP(i, n) REP(j, n) {\n        int cost = 0;\n        // col\n        REP(k, n) {\n            char c = i == k ? 'o' : '.';\n            if (m[k][j] != c) {\n                cost += c == 'o' ? O[k][j] : X[k][j];\n            }\n        }\n        // row\n        REP(k, n) {\n            char c = j == k ? 'o' : '.';\n            if (m[i][k] != c) {\n                cost += c == 'o' ? O[i][k] : X[i][k];\n            }\n        }\n        // cout << i << \" \" << j << \" \" << cost << endl;\n        add_edge(row[i], col[j], 1, cost);\n    }\n    REP(i, n) add_edge(s, row[i], 1, 0);\n    REP(i, n) add_edge(col[i], t, 1, 0);\n    int ans = min_cost_flow(s, t, n)/2;\n    vector< vector<char> > am(n, vector<char>(n, '.'));\n    REP(i, n) {\n        EACH(e, G[i]) {\n            if (i != s && e.to != t && e.to > i && e.cap == 0) {\n                int y = i, x = e.to-n;\n                am[y][x] = 'o';\n            }\n        }\n    }\n    map<char, string> we = {\n        {'o', \"write\"},\n        {'.', \"erase\"},\n    };\n    cout << ans << endl;\n    int cnt = 0;\n    REP(i, n) REP(j, n) {\n        if (am[i][j] != m[i][j]) {\n            ++cnt;\n        }\n    }\n    cout << cnt << endl;\n    REP(i, n) REP(j, n) {\n        if (am[i][j] != m[i][j]) {\n            cout << i+1 << \" \" << j+1 << \" \" << we[am[i][j]] << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最小費用流\nclass PrimalDual {\n    struct Edge {\n        const int to;         // 行き先のノードid\n        int flow;             // 流量\n        const int cap;        // 容量\n        const int cost;       // コスト\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, int flow, int cap, int cost, int rev, bool is_rev) : to(to), flow(flow), cost(cost), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    // s-tまでの最短経路\n    struct Route {\n        vector<int> dist;     // 最短距離\n        vector<int> prevv;    // 前の頂点\n        vector<int> preve;    // 直前の辺\n        vector<int> h;        // ポテンシャル\n        Route(vector<int> &dist, vector<int> &prevv, vector<int> &preve, vector<int> &h) : dist(dist), prevv(prevv), preve(preve), h(h) {}\n    };\n\n    const unsigned long V;       // 頂点数\n    vector<vector<Edge>> graph;  // グラフの隣接リスト表現\n\n\npublic:\n    PrimalDual(unsigned long num_of_node) : V(num_of_node) {\n        graph.resize(V);\n    }\n\n    // fromからtoへ向かう容量cap、コストcostの辺をグラフに追加する\n    void add_edge(int from, int to, int cap, int cost) {\n        graph[from].emplace_back(Edge(to, 0, cap, cost, graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, -cost, graph[from].size() - 1, true));\n    }\n\n    // sからtへの流量fの最小費用流を求める(流せない場合は-1)\n    // O(F|E|log |V|)かO(F|V|^2)\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n        while (f > 0) {\n            Route route = dijkstra(s, t);\n            vector<int> dist = route.dist;\n            vector<int> prevv = route.prevv;\n            vector<int> preve = route.preve;\n            vector<int> h = route.h;\n\n            if (dist[t] == INT_MAX) {\n                // これ以上流せない\n                return -1;\n            }\n\n            for (int v = 0; v < V; v++) {\n                h[v] += dist[v];\n            }\n\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    // sからtへの流量fの最小費用流(流せない場合は-1)\n    // 負のコストがあってもいい\n    // O(F|V||E|)\n    int min_cost_flow_bellmanford(int s, int t, int f) {\n        int res = 0;\n        while (f > 0) {\n            Route route = bellmanford(s, t);\n            vector<int> dist = route.dist;\n            vector<int> prevv = route.prevv;\n            vector<int> preve = route.preve;\n\n            // これ以上流せない\n            if (dist[t] == INT_MAX) {\n                return -1;\n            }\n\n            // s-t間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                int rest = graph[prevv[v]][preve[v]].cap - graph[prevv[v]][preve[v]].flow;\n                d = min(d, rest);\n            }\n\n            f -= d;\n            res += d * dist[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = graph[prevv[v]][preve[v]];\n                e.flow += d;\n                graph[v][e.rev].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    // 水の流れたエッジを取得する\n    set<pair<int, int>> get_used_edges() {\n        set<pair<int, int>> used_edges;\n        for (int from = 0; from < this->graph.size(); ++from) {\n            for (Edge edge : graph[from]) {\n                int flow = edge.flow;\n                bool is_rev = edge.is_rev;\n\n                if (not is_rev and flow > 0) {\n                    int to = edge.to;\n                    used_edges.insert(make_pair(from , to));\n                }\n            }\n        }\n        return used_edges;\n    }\n\nprivate:\n    // dijkstraでsからtへの最短ルートを求める\n    Route dijkstra(int s, int t) {\n        vector<int> dist(V, INT_MAX), prevv(V, 0), preve(V, 0), h(V, 0);\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;\n        dist[s] = 0;\n        que.push(make_pair(0, s));\n        while (not que.empty()) {\n            pair<int, int> p = que.top();  // firstは最短距離, secondは頂点の番号\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) {\n                continue;\n            }\n            for (int i = 0; i < graph[v].size(); ++i) {\n                Edge &e = graph[v][i];\n                if (e.cap - e.flow > 0 and dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n\n                    preve[e.to] = i;\n                    que.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n\n        return Route(dist, prevv, preve, h);\n    }\n\n    // bellmanfordでsからtへの最短ルートを求める\n    Route bellmanford(int s, int t) {\n        vector<int> dist(V, INT_MAX), prevv(V, 0), preve(V, 0), h(V, 0);\n\n        // ベルマンフォード法により、s-t間最短路を求める\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; v++) {\n                if (dist[v] == INT_MAX) continue;\n                for (int i = 0; i < graph[v].size(); i++) {\n                    Edge &e = graph[v][i];\n                    int rest = e.cap - e.flow;\n                    int new_cost = dist[v] + e.cost;\n                    if (rest > 0 and dist[e.to] > new_cost) {\n                        dist[e.to] = new_cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n\n        return Route(dist, prevv, preve, h);\n    }\n\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    VV<int> add(N, V<int>(N)), del(N, V<int>(N)), field(N, V<int>(N));\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            cin >> add[i][j];\n        }\n    }\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            cin >> del[i][j];\n        }\n    }\n\n    int cost = 0;\n    FOR(i, 0, N) {\n        string s;\n        cin >> s;\n        FOR(j, 0, N) {\n            field[i][j] = (s[j] == 'o') ? 1 : 0;\n\n            // 全部消す\n            if (field[i][j] == 1) {\n                cost += del[i][j];\n            }\n        }\n    }\n\n    PrimalDual pd(2 * N + 2);\n    const int source = 2 * N;\n    const int sink = source + 1;\n\n    FOR(i, 0, N) {\n        pd.add_edge(source, i, 1, 0);     // 行\n        pd.add_edge(i + N, sink, 1, 0);   // 列\n    }\n\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            if (field[i][j] == 1) {\n                pd.add_edge(i, j + N, 1, -del[i][j]);\n            }\n            else {\n                pd.add_edge(i, j + N, 1, add[i][j]);\n            }\n        }\n    }\n\n    print(cost + pd.min_cost_flow_bellmanford(source, sink, N));\n\n    VV<int> field2(N, V<int>(N, 0));\n    auto used_edges = pd.get_used_edges();\n    FOE(edge, used_edges) {\n        if (edge.first == source or edge.second == sink) { continue; }\n        int y = edge.first;\n        int x = edge.second - N;\n        field2[y][x] = 1;\n    }\n\n    V<string> ans;\n    FOR(y, 0, N) {\n        FOR(x, 0, N) {\n            if (field[y][x] == field2[y][x]) { continue; }\n            if (field[y][x] == 1) {\n                ans.emplace_back(to_string(y + 1) + \" \" + to_string(x + 1) + \" erase\");\n            }\n            else {\n                ans.emplace_back(to_string(y + 1) + \" \" + to_string(x + 1) + \" write\");\n            }\n        }\n    }\n\n    print(ans.size());\n    FOE(s, ans) {\n        print(s);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 110\n\n/* Minimum Cost Flow */\n\nstruct MinimumCostFlow{\n\n  typedef pair<int,int> P;\n\n  struct edge {\n    int to, cap, cost, rev;\n    edge(int a, int b, int c, int d):to(a), cap(b), cost(c), rev(d) {}\n  };\n\n  vector<vector<edge>> G;\n  vector<int> h, dist, prevv, preve;\n  int V;\n\n  MinimumCostFlow(int v):\n    G(v, vector<edge>()), prevv(v, 0), preve(v, 0), V(v) {}\n\n  int add_edge(int from, int to, int cap, int cost){\n    int id = G[from].size();\n\n    G[from].push_back(edge(to, cap, cost, G[to].size()));\n    G[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n\n    return id;\n  }\n\n  int solve(int s, int t, int f){\n    int res = 0;\n    h.assign(V,0);\n    while(f > 0){\n      priority_queue<P, vector<P>, greater<P>> pq;\n      dist.assign(V, INF);\n      dist[s] = 0;\n      pq.push(P(0, s));\n      while(pq.size()){\n        P p = pq.top(); pq.pop();\n        int v = p.second;\n        if(dist[v] < p.first) continue;\n\n        for(int i = 0; i < (int)G[v].size(); i++){\n          edge &e = G[v][i];\n          int d = dist[v] + e.cost + h[v] - h[e.to];\n          if(e.cap > 0 && dist[e.to] > d){\n            dist[e.to] = d;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            pq.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if(dist[t] == INF) return -1;\n\n      for(int v = 0; v < V; v++) h[v] += dist[v];\n\n      int d = f;\n      for(int v = t; v != s; v = prevv[v])\n        d = min(d, G[prevv[v]][preve[v]].cap);\n\n      f -= d;\n      res += d * h[t];\n\n      for(int v = t; v != s; v = prevv[v]){\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n\n    return res;\n  }\n};\n\n\nint main(){\n  int N, W[SIZE][SIZE], E[SIZE][SIZE], id[SIZE][SIZE];\n  char F[SIZE][SIZE];\n\n  scanf(\"%d\", &N);\n\n  for (int i=0; i<N; i++)\n    for (int j=0; j<N; j++)\n      scanf(\"%d\", W[i]+j);\n\n  for (int i=0; i<N; i++)\n    for (int j=0; j<N; j++)\n      scanf(\"%d\", E[i]+j);\n\n\n  int S = 2 * N;\n  int T = 2 * N + 1;\n\n  int B = 1000;\n  int ans = 0;\n\n  MinimumCostFlow flow(2 * N + 2);\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%s\", F[i]);\n\n    for (int j=0; j<N; j++) {\n      if (F[i][j] == 'o') {\n        id[i][j] = flow.add_edge(i, N + j, 1, B - E[i][j]);\n        ans += E[i][j];\n      } else {\n        id[i][j] = flow.add_edge(i, N + j, 1, B + W[i][j]);\n      }\n    }\n  }\n\n  for (int i=0; i<N; i++) {\n    flow.add_edge(S, i, 1, 0);\n    flow.add_edge(i + N, T, 1, 0);\n  }\n\n  int res = flow.solve(S, T, N);\n\n  assert(res >= 0);\n  ans = ans + res - N * B;\n\n  debug(ans);\n\n  vector<pair<int,int>> query;\n\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (flow.G[i][id[i][j]].cap == 0) {\n        if (F[i][j] == '.') query.push_back({i, j});\n      } else {\n        if (F[i][j] == 'o') query.push_back({i, j});\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n  printf(\"%d\\n\", (int)query.size());\n\n  for (int i=0; i<query.size(); i++) {\n    int y = query[i].first;\n    int x = query[i].second;\n\n    printf(\"%d %d \", y+1, x+1);\n\n    if (F[y][x] == 'o') puts(\"erase\");\n    if (F[y][x] == '.') puts(\"write\");\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 300\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint can[MAX_V][MAX_V]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n\n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j , 1, can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  int W[101][101],E[101][101];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>W[i][j];\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>E[i][j];\n  \n  string mp[101];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  int sumW[101]={},sumH[101]={};\n  int sum=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      if(mp[i][j]=='o') sumW[i]+=E[i][j],sum+=E[i][j];\n      if(mp[j][i]=='o') sumH[i]+=E[j][i];\n    }\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++){\n      int cost=sumH[j]+sumW[i];\n      if(mp[i][j]=='o') cost-=2*E[i][j];\n      if(mp[i][j]=='.') cost+=W[i][j];\n      can[i][j]=cost;\n      \n    }\n  Biparite_Matching(n,n);\n  \n  bool used[101][101]={};\n  for(int i=0;i<n;i++) \n    for(int j=0;j<G[i].size();j++)\n      if(G[i][j].cap<=0)used[i][G[i][j].to-n]=1;\n  \n\n  int mincost=0,cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) \n      if(used[i][j]&&mp[i][j]=='.')cnt++,mincost+=W[i][j];\n      else if(!used[i][j]&&mp[i][j]=='o')cnt++,mincost+=E[i][j];\n\n  cout<<mincost<<endl;\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) \n      if(used[i][j]&&mp[i][j]=='.')cout<<i+1<<\" \"<<j+1<<\" write\"<<endl;\n      else if(!used[i][j]&&mp[i][j]=='o')cout<<i+1<<\" \"<<j+1<<\" erase\"<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\n\nint G[MAX_V][MAX_V];\nint hl[MAX_V], hr[MAX_V], distl[MAX_V], distr[MAX_V];\nint prevvl[MAX_V], prevvr[MAX_V];\nbool used[MAX_V*2+2];\nbool flow[MAX_V][MAX_V] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(hl, l+1, 0);\n\tfill_n(hr, r+1, 0);\n\twhile (true) {\n\t\tfill_n(distl, l+1, INT_INF);\n\t\tfill_n(distr, r+1, INT_INF);\n\t\tdistr[r] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            int dist = 0;\n            int flag;\n            for (int i = 0; i < l+1; i++) {\n                if (!used[i] && (v == -1 || distl[i] < dist)){\n                    v = i;\n                    dist = distl[i];\n                    flag = true;\n                }\n            }\n            for (int i = 0; i < r+1; i++) {\n                if (!used[i+l+1] && (v == -1 || distr[i] < dist)){\n                    v = i;\n                    dist = distr[i];\n                    flag = false;\n                }\n            }\n            if (v == -1) break;\n            if (flag) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && distr[i] > distl[v] + G[v][i] + hl[v] - hr[i]) {\n\t\t\t\t\t\tdistr[i] = distl[v] + G[v][i] + hl[v] - hr[i];\n\t\t\t\t\t\tprevvr[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v+l+1] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v] && distl[i] > distr[v] - G[i][v] + hr[v] - hl[i]) {\n\t\t\t\t\t\tdistl[i] = distr[v] - G[i][v] + hr[v] - hl[i];\n\t\t\t\t\t\tprevvl[i] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (distl[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+1; v++) {\n\t\t\thl[v] += distl[v];\n\t\t}\n\t\tfor (int v = 0; v < r+1; v++) {\n\t\t\thr[v] += distr[v];\n\t\t}\n\t\tres += hl[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevvl[v] : prevvr[v], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevvl[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevvr[v]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int index, capacity, cost;\n    Edge(int i, int c, int d) : index(i), capacity(c), cost(d) {}\n};\n\nstruct Command {\n    int r, c;\n    string cmd;\n    Command(int r, int c, const string &cmd) : r(r), c(c), cmd(cmd) {}\n};\n\n// O(V^2 U C) where\n//  U = sum of capacity\n//  C = sum of cost\npair<int,int> primal_dual(const vector<vector<Edge> >& g, int source, int sink, int total_flow, vector<vector<int> > &flow)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)); \n  flow = vector<vector<int> >(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<Edge>::const_iterator it(g[i].begin()); it != g[i].end(); ++it) {\n      capacity[i][it->index] += it->capacity;\n      cost[i][it->index] += it->cost;\n      cost[it->index][i] -= it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  for (int f = total_flow; f > 0; ) {\n    vector<int> dist(N, 1000000);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<Edge>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (capacity[n][it->index] - flow[n][it->index] > 0) {\n          const int c2 = c + cost[n][it->index] + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = n;\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return total;\n}/*}}}*/\n\nint write_cost[128][128];\nint erase_cost[128][128];\nchar field[128][128];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            cin >> write_cost[i][j];\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            cin >> erase_cost[i][j];\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        cin >> &field[i][0];\n    }\n\n    // 0..N-1: Row\n    // N..2N-1: Col\n    // 2N: Source\n    // 2N+1: Sink\n    vector<vector<Edge> > graph(2*N+2);\n    for(int r = 0; r < N; ++r) {\n        int sum = 0;\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o') sum += erase_cost[r][c];\n        }\n        for(int c = 0; c < N; ++c) {\n            int cost = sum;\n            if(field[r][c] == 'o') cost -= erase_cost[r][c];\n            else cost += write_cost[r][c];\n            graph[r].push_back(Edge(N+c, 1, cost));\n        }\n    }\n    for(int r = 0; r < N; ++r) {\n        graph[2*N].push_back(Edge(r, 1, 0));\n    }\n    for(int c = 0; c < N; ++c) {\n        graph[N+c].push_back(Edge(2*N+1, 1, 0));\n    }\n    vector<vector<int> > flow;\n    pair<int,int> result = primal_dual(graph, 2*N, 2*N+1, N, flow);\n    vector<Command> commands;\n    for(int r = 0; r < N; ++r) {\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o' && flow[r][N+c] == 0)\n                commands.push_back(Command(r+1, c+1, \"erase\"));\n            else if(field[r][c] == '.' && flow[r][N+c] > 0)\n                commands.push_back(Command(r+1, c+1, \"write\"));\n        }\n    }\n    cout << result.first << endl;\n    cout << commands.size() << endl;\n    for(vector<Command>::const_iterator it = commands.begin(); it != commands.end(); ++it) {\n        cout << it->r << ' ' << it->c << ' ' << it->cmd << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 2000\n#define INF (1<<26)\ntypedef pair<int,int > P;\nstruct edge{int to,cap,cost,rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n  \n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint t[200][200],u[200][200];\nchar a[200][200],b[200][200];\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>t[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>u[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      cin>>a[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      b[i][j]='.';\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int sum=0;\n      if(a[i][j]=='.'){\n\tsum+=t[i][j]*2;\n\tfor(int k=0;k<n;k++){\n\t  if(a[i][k]=='o')sum+=u[i][k];\n\t  if(a[k][j]=='o')sum+=u[k][j];\n\t}\n      }else{\n\tfor(int k=0;k<n;k++){\n\t  if(k!=j&&a[i][k]=='o')sum+=u[i][k];\n\t  if(k!=i&&a[k][j]=='o')sum+=u[k][j];\n\t}\t\n      }\n      add_edge(i,n+j,1,sum);\n    }\n  }\n  for(int i=0;i<n;i++){\n    add_edge(n+n,i,1,0);\n    add_edge(n+i,n+n+1,1,0);\n  }\n  V=n+n+2;\n  cout<<min_cost_flow(n+n,n+n+1,n)/2<<endl;\n\n\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      edge e=G[i][j];\n      \n      if(e.cap==0&&n<=e.to&&e.to<n*n){\n\tb[i][e.to-n]='o';\n      }\n    }\n  }\n\n\n  vector<P> ans;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(a[i][j]==b[i][j])continue;\n      ans.push_back(P(i,j));\n    }\n  }\n  \n  cout<<ans.size()<<endl;\n  for(int i=0;i<(int)ans.size();i++){\n    P p=ans[i];\n    if(a[p.first][p.second]=='.'){\n      cout<<p.first+1<<\" \"<<p.second+1<<\" write\"<<endl;\n    }else{\n      cout<<p.first+1<<\" \"<<p.second+1<<\" erase\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x <= b)\n\nconst int MAX_V = 202;\n\nstruct edge{\n    int to, cap, cost, rev;\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];    // 頂点にflowを1流すときのコストの総和\nint prevv[MAX_V], preve[MAX_V]; // prev_vertex, prev_edge\nconst int INF = 1<<30;\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nbool maru[100][100] = {};\n\n// flow from s to t, the amount of that is f\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    while(f > 0){\n        for(int i = 0; i < V; i++)  dist[i] = INF;\n        dist[s] = 0;\n        bool update = true;\n        // bellman-ford\n        while(update){\n            update = false;\n            for(int v = 0; v < V; v++){\n                if(dist[v] == INF)  continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t] == INF){\n            return -1;\n        }\n        int d = f;\n        // 辺を逆に辿る、流せるだけ流す\n        for(int v = t; v != s; v = prevv[v]){\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d; // 順方向に流したので-\n            G[v][e.rev].cap += d;   // 逆方向に流したので+\n            if(inRange(prevv[v],0,99)&&inRange(v-100,0,99)) maru[prevv[v]][v-100] = true;\n            if(inRange(prevv[v]-100,0,99)&&inRange(v,0,99)) maru[v][prevv[v]-100] = false;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    V = 202;\n    int w[n][n], e[n][n];\n    for(int i = 0; i < n*n; i++)    cin >> w[i/n][i%n];\n    for(int i = 0; i < n*n; i++)    cin >> e[i/n][i%n];\n    char c[n][n];\n    int score = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            cin >> c[i][j];\n            if(c[i][j] == 'o'){\n                score += e[i][j];\n                w[i][j] = -e[i][j];\n            }\n        }\n    }\n    int SOURCE = 200, SINK = 201;\n    for(int i = 0; i < n; i++){\n        add_edge(SOURCE, i, 1, 0);\n        add_edge(100+i, SINK, 1, 0);\n        for(int j = 0; j < n; j++){\n            add_edge(i, 100+j, 1, w[i][j]);\n        }\n    }\n    cout << score + min_cost_flow(SOURCE, SINK, n) << endl;\n\n    vector<int> x, y, z;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(maru[i][j] == (c[i][j]=='o'))    continue;\n            x.push_back(i+1);\n            y.push_back(j+1);\n            z.push_back(c[i][j]=='o');\n        }\n    }\n    string s[2] = {\"write\", \"erase\"};\n    cout << x.size() << endl;\n    for(int i = 0; i < x.size(); i++){\n        cout << x[i] << \" \" << y[i] << \" \" << s[z[i]] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\nstruct PrimalDual {\n    typedef int Capacity;\n    typedef int Cost;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    enum : Cost { inf = 1<<29 };\n\n    struct Edge {\n        int dst;\n        Capacity cap;\n        Capacity cap_orig;\n        Cost cost;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    PrimalDual(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].push_back(Edge(dst, cap, cost, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, -cost, g[src].size() - 1, true));\n    }\n\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        vector<Cost> h(g.size()), dist(g.size());\n        vector<int> prevv(g.size()), preve(g.size());\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            dist.assign(n,inf);\n            dist[s] = 0;\n            q.push(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.push(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.min_cost_flow(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n\n    rep(i,mcf.g.size()){\n        rep(j,mcf.g[i].size()){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            int r = i, c = e.dst-n;\n            if(f[r][c]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=0;\n            }else if(f[r][c]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=r+1;\n                ans[cnt][1]=c+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 100\n#define MAX_E 1000\nusing namespace std;\ntypedef pair<int, int> P;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to_, int cap_, int cost_, int rev_)\n\t\t: to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid AddEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\n\nint MinimumCostFlow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\th[v] += dist[v];\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tV = n * 2 + 2;\n\tvector<vector<int>> W(n, vector<int>(n)), E(n, vector<int>(n));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> W[i][j];\n\t\t}\n\t\tAddEdge(n * 2, i, 1, 0);\n\t\tAddEdge(n + i, n * 2 + 1, 1, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tvector<string> s(n);\n\tint def = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tAddEdge(i, n + j, 1, W[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAddEdge(i, n + j, 1, -E[i][j]);\n\t\t\t\tdef += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << MinimumCostFlow(n * 2, n * 2 + 1, n) + def << endl;\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" erase\" << endl;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist[v])){\n                    v = i;\n                }\n            }\n            if (v == -1) break;\n            if (v < l+1) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && dist[i+l+1] > dist[v] + G[v][i] + h[v] - h[i+l+1]) {\n\t\t\t\t\t\tdist[i+l+1] = dist[v] + G[v][i] + h[v] - h[i+l+1];\n\t\t\t\t\t\tprevv[i+l+1] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v-(l+1)] && dist[i] > dist[v] - G[i][v-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] - G[i][v-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v-(l+1);\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevv[v] : prevv[v+l+1], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevv[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// Ford-Fulkerson テヲツウツ陛」ツ?ォテ」ツつ暗」ツつ?テヲツ慊?・ツ、ツァテヲツオツ?O( F |E| )\n// Bellman-Ford テヲツウツ陛」ツ?ォテ」ツつ暗」ツつ?テヲツ慊?・ツーツ湘ィツイツサテァツ板ィテヲツオツ?O( F |V| |E| )\n// Verified: AOJ GRL_6_A (Maximum Flow)\n\n// ティツ。ツ古」ツ?催・ツ?暗」ツ?ィテ・ツョツケテゥツ?湘」ツ?ィテゥツ??ィツセツコテ」ツ?ョテ」ツつ、テ」ツδウテ」ツδ?」ツδε」ツつッテ」ツつケテ」ツつ津ィツィツ佚ゥツ個イテ」ツ?凖」ツつ凝ヲツァツ凝ゥツ??、ツスツ?\n// テゥツ?堙・ツクツクテ」ツ?ョテ」ツつーテ」ツδゥテ」ツδ陛」ツ?ョティツセツコテ」ツ?ョテヲツァツ凝ゥツ??、ツスツ禿」ツ?ィテァツ閉ーテ」ツ?ェテ」ツつ凝」ツ?淌」ツつ?ヲツウツィテヲツ??\n\n// テヲツ慊?・ツーツ湘ィツイツサテァツ板ィテヲツオツ?」ツ?ッテ」ツつづ」ツ??・ツーツ妥」ツ?療ゥツ?淌」ツ?湘」ツ?ァテ」ツ?催」ツつ凝」ツ?ョテ」ツ?ァテ」ツ??ヲツ板ケティツ可ッテ」ツ?療」ツ?セテ」ツ?療」ツつ?」ツ??\n// テ「ツ??テ」ツδ?」ツつ、テ」ツつッテ」ツつケテ」ツδ暗」ツδゥテ」ツ?古、ツスツソテ」ツ?暗」ツつ凝」ツつ暗」ツ??」ツ?ォテ」ツδ敕」ツδ?」ツδウテ」ツつキテ」ツδ」テ」ツδォテ」ツつ津・ツーツ偲・ツ?・テ」ツ?療」ツつ暗」ツ??\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nstruct Flow {\n    vector< vector< Edge<T> > > G;\n    const T MAXC = 1 << 30;\n    int n;\n    vector<bool> used;\n    vector<int> prevv, preve, dist;\n    Flow(int _n) : G(_n), n(_n), used(_n, false), \n        prevv(n), preve(n), dist(n, MAXC) {}\n\n    // G[e.to][e.rev] テ」ツ?ァテゥツ??ィツセツコテ」ツつ津ヲツ督催、ツスツ愿」ツ?ァテ」ツ?催」ツつ?\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge<T>(to, cap, G[to].size()));\n        G[to].push_back(Edge<T>(from, 0, G[from].size() - 1));\n    }\n    void add_edge(int from, int to, T cap, T cost) {\n        G[from].push_back(Edge<T>(to, cap, cost, G[to].size()));\n        G[to].push_back(Edge<T>(from, 0, -cost, G[from].size() - 1));\n    }\n\n    T dfs(int v, int t, T f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(int i=0; i < G[v].size(); i++) {\n            Edge<T> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), false);\n            T f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    T mincost_flow(int s, int t, T f) {\n        T res = 0;\n        T ma = MAXC;\n        while(f > 0) {\n            fill(dist.begin(), dist.end(), ma);\n            dist[s] = 0;\n            bool update = true;\n            while(update) {\n                update = false;\n                for(int v = 0; v < n; v++) {\n                    if(dist[v] == ma) continue;\n                    for(int i=0; i<G[v].size(); i++) {\n                        Edge<T> &e = G[v][i];\n                        if(e.cap>0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            if(dist[t] == ma) return -1;\n            T d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * dist[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                Edge<T> &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint N, W[110][110], E[110][110];\nbool used[110][110];\nchar board[110][110];\n\nstruct Elem {\n    int from, to, ope;\n};\n\nsigned main() {\n    cin >> N;\n    rep(i,0,N) rep(j,0,N) cin >> W[i][j];\n    rep(i,0,N) rep(j,0,N) cin >> E[i][j];\n    rep(i,0,N) rep(j,0,N) cin >> board[i][j];\n\n    Flow<int> fl(2*N+2);\n    int source = 2*N, sink = source + 1;\n    rep(i,0,N) fl.add_edge(source, i, 1, 0);\n    rep(i,0,N) fl.add_edge(N+i, sink, 1, 0);\n\n    int S = 0, cnt = 0;\n    rep(i,0,N) rep(j,0,N) {\n        if(board[i][j] == 'o') {\n            fl.add_edge(i, N+j, 1, -E[i][j]);\n            S += E[i][j];\n            cnt++;\n        }\n        else fl.add_edge(i, N+j, 1, W[i][j]);\n    }\n\n    cout << fl.mincost_flow(source, sink, N) + S << endl;\n    rep(i,0,N) {\n        for(auto e : fl.G[i]) {\n            if(e.cap == 0) {\n                used[i][e.to-N] = true;\n                if(board[i][e.to-N] == 'o') cnt--;\n                else cnt++;\n            }\n        }\n    }\n    \n    cout << cnt << endl;\n    rep(i,0,N) rep(j,0,N) {\n        if(board[i][j] == 'o' && !used[i][j]) printf(\"%lld %lld erase\\n\", i+1, j+1);\n        if(board[i][j] == '.' &&  used[i][j]) printf(\"%lld %lld write\\n\", i+1, j+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\nusing Weight = int;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\nconstexpr int INF = 1000000000;\n\n\npair<Weight, Array> hungarian(const Matrix &m) {\n  int n = m.size();\n  int p, q;\n  Array fx(n, INF), fy(n, 0);\n  vector<int> x(n, -1), y(n, -1);\n  REP(i,n)REP(j,n) fx[i] = max(fx[i], m[i][j]);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n+1, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == m[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      Weight d = INF;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - m[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  Weight ret = 0;\n  for (int i = 0; i < n; ++i) ret += m[i][x[i]];\n  return make_pair(ret, x);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  Matrix mat(n, Array(n));\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        mat[i][j] = 1000 + e[i][j];\n        cost += e[i][j];\n      } else {\n        mat[i][j] = 1000 - w[i][j];\n      }\n    }\n  }\n  auto res = hungarian(mat);\n  cout << (n*1000 - res.first + cost) << endl;\n  int cnt = 0;\n  stringstream ss;\n  REP(i,n)REP(j,n) {\n    if (m[i][j] == 'o') {\n      if (res.second[i] != j) {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++cnt;\n      }\n    } else {\n      if (res.second[i] == j) {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++cnt;\n      }\n    }\n  }\n  cout << cnt << endl;\n  cout << ss.str() << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nconst int MAX_V = 10005;\n\nclass Edge{\n\tpublic:\n\t\t//???????????????????????????????????????\n\t\tint to, cap, cost, rev;\n\t\tEdge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nvector<vector<Edge>> G(MAX_V);\nint h[MAX_V]; //??????????????£???\nint dist[MAX_V]; //???????????¢\nint prev_v[MAX_V], prev_e[MAX_V]; //??´??????????????¨???\n\nvoid addEdge(int from, int to, int cap, int cost){\n\tG[from].emplace_back(Edge(to, cap, cost, static_cast<int>(G[to].size())));\n\tG[to].emplace_back(Edge(from, 0, -cost, static_cast<int>(G[from].size() - 1)));\n}\n\nint minCostFlow(int v, int s, int t, int f){\n\tint res = 0;\n\tfill(h, h + v, 0);\n\twhile(f > 0){\n\t\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\t\tfill(dist, dist + v, INF);\n\t\tdist[s] = 0;\n\t\tq.push(make_pair(0, s));\n\t\twhile(not q.empty()){\n\t\t\tpair<int, int> p = q.top(); q.pop();\n\t\t\tint u = p.second;\n\t\t\tif(dist[u] < p.first) continue;\n\t\t\trep(i,G[u].size()){\n\t\t\t\tEdge &e = G[u][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[u] + e.cost + h[u] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[u] + e.cost + h[u] - h[e.to];\n\t\t\t\t\tprev_v[e.to] = u;\n\t\t\t\t\tprev_e[e.to] = i;\n\t\t\t\t\tq.push(make_pair(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\trep(i,v) h[i] += dist[i];\n\n\t\tint d = f;\n\t\tfor(int u = t; u != s; u = prev_v[u]){\n\t\t\td = min(d, G[prev_v[u]][prev_e[u]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int u = t; u != s; u = prev_v[u]){\n\t\t\tEdge &e = G[prev_v[u]][prev_e[u]];\n\t\t\te.cap -= d;\n\t\t\tG[u][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tint w[105][105], e[105][105];\n\trep(i,n) rep(j,n) cin >> w[i][j];\n\trep(i,n) rep(j,n) cin >> e[i][j];\n\n\t\tint t[105][105];\n\t\tstring s[105];\n\t\trep(i,n) cin >> s[i];\n\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tint sum = 0;\n\t\t\t\tif(s[i][j] == '.'){\n\t\t\t\t\tsum += w[i][j] * 2;\n\t\t\t\t}\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(k == j) continue;\n\t\t\t\t\tif(s[i][k] == 'o'){\n\t\t\t\t\t\tsum += e[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(k == i) continue;\n\t\t\t\t\tif(s[k][j] == 'o'){\n\t\t\t\t\t\tsum += e[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt[i][j] = sum;\n\t\t\t}\n\t\t}\n\n\t//rep(i,n){ rep(j,n){ cout << t[i][j] << ' '; } cout << endl; }\n\n\tconst int MID = 0;\n\tconst int LEFT = n * n + n;\n\tconst int RIGHT = n * n;\n\n\tint S = n * n + 2 * n + 1;\n\tint T = S - 1;\n\trep(i,n){\n\t\taddEdge(S, LEFT + i, 1, 0);\n\t\t//cout << S << ' ' << LEFT + i << endl;\n\t}\n\trep(i,n){\n\t\trep(j,n){\n\t\t\taddEdge(LEFT + i, MID + n * j + i, 1, 0);\n\t\t\t//cout << LEFT + i << ' ' << MID + n * j + i << endl;\n\t\t}\n\t}\n\trep(i,n * n){\n\t\taddEdge(MID + i, RIGHT + i / n, 1, t[i / n][i % n]);\n\t\t//cout << MID + i << ' ' << RIGHT + i / n << endl;\n\t}\n\trep(i,n){\n\t\taddEdge(RIGHT + i, T, 1, 0);\n\t\t//cout << RIGHT + i << ' ' << T << endl;\n\t}\n\tcout << minCostFlow(S, S, T, n) / 2 << endl;\n\n\tint cnt = 0;\n\trep(i,n * n){\n\t\tif(G[i][0].cap == 1){\n\t\t\tif(s[i / n][i % n] == '.'){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}else{\n\t\t\tif(s[i / n][i % n] == 'o'){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << cnt << endl;\n\n\trep(i,n * n){\n\t\tif(G[i][0].cap == 1){\n\t\t\tif(s[i / n][i % n] == '.'){\n\t\t\t\tcout << i / n + 1 << ' ' << i % n + 1 << ' ' << \"write\" << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tif(s[i / n][i % n] == 'o'){\n\t\t\t\tcout << i / n + 1 << ' ' << i % n + 1 << ' ' << \"erase\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while(f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if(min_cost[p.second] < p.first) continue;\n                for(int i = 0; i < graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if(e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if(min_cost[t] == INF) return -1;\n            for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n       }\n       return ret;\n    }\n\n    void output() {\n        for(int i = 0; i < graph.size(); i++) {\n            for(auto &e : graph[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nll N;\nll W[1000][1000];\nll E[1000][1000];\nstring field[1000];\nstring result[1000];\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll ans = 0;\n    cin >> N;\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cin >> W[i][j];\n        }\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            cin >> E[i][j];\n        }\n    }\n    for(int i = 0; i < N; i++) {\n        cin >> field[i];\n        for(int j = 0; j < N; j++) {\n            result[i].push_back('.');\n        }\n    }\n    PrimalDual<ll, ll> graph(2 * N * N + 5);\n    int s = 2 * N * N + 3;\n    int g = 2 * N * N + 4;\n    for(int i = 0; i < N; i++) {\n        graph.add_edge(s, N*N+i, 1, 0);\n        graph.add_edge(N*N+N+i, g, 1, 0);\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            if(field[i][j] == 'o') {\n                ans += E[i][j];\n                graph.add_edge(N*N+i, N*N+N+j, 1, -E[i][j]);\n            } else {\n                graph.add_edge(N*N+i, N*N+N+j, 1, W[i][j]);\n            }\n        }\n    }\n    cout << ans + graph.min_cost_flow(s, g, N) << endl;\n    vector<int> v;\n    for(int i = 0; i < N; i++) {\n        for(auto e : graph.graph[N*N+i]) {\n            if(e.isrev) continue;\n            if(e.cap == 0) {\n                int from = i;\n                int to = e.to - N * N - N;\n                //cerr << from << \" \" << to << endl;\n                result[from][to] = 'o';\n            }\n        }\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < N; j++) {\n            if(field[i][j] != result[i][j]) v.push_back(i * N + j);\n        }\n    }\n    cout << v.size() << endl;\n    for(auto pos : v) {\n        cout << pos / N + 1 << \" \" << (pos % N) + 1 << \" \";\n        if(field[pos/N][pos%N] == '.') cout << \"write\" << endl;\n        else cout << \"erase\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing weight = int;\nusing P = std::pair<int, int>;\nusing pii = pair<int, int>;\n\nconstexpr weight INF = 1e9;\n\nstruct edge {\n    int to, cap;\n    weight cost;\n    int rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cap, weight cost) {\n    g[from].push_back(edge{to, cap, cost, (int)g[to].size()});\n    g[to].push_back(edge{from, 0, -cost, (int)g[from].size()-1});\n}\n\n// verified\nweight min_cost_flow(graph& g, int s, int t, weight f) {\n    weight res = 0;\n    std::vector<weight> h(g.size(), 0);\n    std::vector<weight> dist(g.size());\n    std::vector<int> prevv(g.size()), preve(g.size());\n    std::fill(h.begin(), h.end(), 0);\n    while(f > 0) {\n        std::priority_queue<P, std::vector<P>, std::greater<P>> que;\n        std::fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        que.push(P{0, s});\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) {\n                continue;\n            }\n            for(int i=0; i<g[v].size(); ++i) {\n                edge& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P{dist[e.to], e.to});\n                }\n            }\n        }\n        if(dist[t] == INF) {\n            return -1;\n        }\n        for(int v=0; v<g.size(); ++v) {\n            h[v] += dist[v];\n        }\n\n        weight d = f;\n        for(int v=t; v!=s; v=prevv[v]) {\n            d = min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int v=t; v!=s; v=prevv[v]) {\n            edge& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> W(n, vector<int>(n));\n    vector<vector<int>> E(n, vector<int>(n));\n    vector<string> F(n);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            cin >> W[i][j];\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            cin >> E[i][j];\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        cin >> F[i];\n    }\n\n    graph g(n + n + 2);\n    int const source = n + n;\n    int const sink = n + n + 1;\n    int min_cost = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            int cost = 0;\n            if(F[i][j] == 'o') {\n                min_cost += E[i][j];\n                cost -= E[i][j];\n            } else {\n                cost += W[i][j];\n            }\n            add_edge(g, i, j + n, 1, cost);\n        }\n    }\n    for(int i = 0; i < n; ++i) {\n        add_edge(g, source, i, 1, 0);\n        add_edge(g, i + n, sink, 1, 0);\n    }\n\n    min_cost += min_cost_flow(g, source, sink, n);\n\n    vector<pii> erased;\n    vector<pii> wrote;\n    for(int i = 0; i < n; ++i) {\n        for(auto& e : g[i]) {\n            if(e.cap == 0) {\n                if(F[i][e.to - n] == '.') {\n                    wrote.emplace_back(i + 1, e.to - n + 1);\n                }\n            } else {\n                if(F[i][e.to - n] == 'o') {\n                    erased.emplace_back(i + 1, e.to - n + 1);\n                }\n            }\n        }\n    }\n\n    cout << min_cost << endl;\n    cout << erased.size() + wrote.size() << endl;\n    for(auto& p : erased) {\n        cout << p.first << ' ' << p.second << \" erase\" << endl;\n    }\n    for(auto& p : wrote) {\n        cout << p.first << ' ' << p.second << \" write\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬?????? (????°????)\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\n// Ford-Fulkerson ???????????? ?????§??? O( F |E| )\n// Bellman-Ford ???????????? ????°??????¨??? O( F |V| |E| )\n// Verified: AOJ GRL_6_A (Maximum Flow)\n\n// ???????????¨????????¨???????????????????????????????¨???????????§???????\n// ???????????°????????????????§?????????¨??°??????????????¨???\n\n// ????°??????¨?????????????°????????????§???????????§????????????????????????\n// ??? ?????????????????????????????????????????????????????£???????°???\\?????????\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nstruct Flow {\n    vector< vector< Edge<T> > > G;\n    const T MAXC = 1 << 30;\n    int n;\n    vector<bool> used;\n    vector<int> prevv, preve, dist;\n    Flow(int _n) : G(_n), n(_n), used(_n, false), \n        prevv(n), preve(n), dist(n, MAXC) {}\n\n    // G[e.to][e.rev] ??§?????????????????§??????\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge<T>(to, cap, G[to].size()));\n        G[to].push_back(Edge<T>(from, 0, G[from].size() - 1));\n    }\n    void add_edge(int from, int to, T cap, T cost) {\n        G[from].push_back(Edge<T>(to, cap, cost, G[to].size()));\n        G[to].push_back(Edge<T>(from, 0, -cost, G[from].size() - 1));\n    }\n\n    T dfs(int v, int t, T f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(int i=0; i < G[v].size(); i++) {\n            Edge<T> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), false);\n            T f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    T mincost_flow(int s, int t, T f) {\n        T res = 0;\n        T ma = MAXC;\n        while(f > 0) {\n            fill(dist.begin(), dist.end(), ma);\n            dist[s] = 0;\n            bool update = true;\n            while(update) {\n                update = false;\n                for(int v = 0; v < n; v++) {\n                    if(dist[v] == ma) continue;\n                    for(int i=0; i<G[v].size(); i++) {\n                        Edge<T> &e = G[v][i];\n                        if(e.cap>0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            if(dist[t] == ma) return -1;\n            T d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * dist[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                Edge<T> &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint N, W[110][110], E[110][110];\nbool used[110][110];\nchar board[110][110];\n\nstruct Elem {\n    int from, to, ope;\n};\n\nsigned main() {\n    cin >> N;\n    rep(i,0,N) rep(j,0,N) cin >> W[i][j];\n    rep(i,0,N) rep(j,0,N) cin >> E[i][j];\n    rep(i,0,N) rep(j,0,N) cin >> board[i][j];\n\n    Flow<int> fl(2*N+2);\n    int source = 2*N, sink = source + 1;\n    rep(i,0,N) fl.add_edge(source, i, 1, 0);\n    rep(i,0,N) fl.add_edge(N+i, sink, 1, 0);\n\n    int S = 0, cnt = 0;\n    rep(i,0,N) rep(j,0,N) {\n        if(board[i][j] == 'o') {\n            fl.add_edge(i, N+j, 1, -E[i][j]);\n            S += E[i][j];\n            cnt++;\n        }\n        else fl.add_edge(i, N+j, 1, W[i][j]);\n    }\n\n    cout << fl.mincost_flow(source, sink, N) + S << endl;\n    rep(i,0,N) {\n        for(auto e : fl.G[i]) {\n            if(e.cap == 0) {\n                used[i][e.to-N] = true;\n                if(board[i][e.to-N] == 'o') cnt--;\n                else cnt++;\n            }\n        }\n    }\n    \n    cout << cnt << endl;\n    rep(i,0,N) rep(j,0,N) {\n        if(board[i][j] == 'o' && !used[i][j]) printf(\"%lld %lld erase\\n\", i+1, j+1);\n        if(board[i][j] == '.' &&  used[i][j]) printf(\"%lld %lld write\\n\", i+1, j+1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n\ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n     G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f, bool negative = false){\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 10000000;\n\n  if(negative){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n\n    bool update = true;\n\n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n        if(dist[v] == inf) continue;\n        for(int i = 0; i < (int)g[v].size(); i++){\n          E &e = g[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to]  = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update      = true;\n          }\n        }\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n      h[i] = dist[i];\n  }\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n        E &e = g[v][i];\n\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == inf){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint w[100][100];\nint e[100][100];\nint f[100][100];\nint c[100][100];\n\nint main(){\n  const int n = getInt();\n\n  REP(i,n) REP(j,n)\n    w[i][j] = getInt();\n  REP(i,n) REP(j,n)\n    e[i][j] = getInt();\n\n  REP(i,n){\n    char b[128]; scanf(\"%s\", b);\n    REP(j,n) f[i][j] = (b[j] == 'o' ? 1 : 0);\n  }\n\n  REP(i,n){\n    REP(j,n){\n      int cc = 0;\n\n      REP(k,n){\n        if(f[i][k]  && k != j) cc += e[i][j];\n        if(!f[i][k] && k == j) cc += w[i][j];\n      }\n\n      c[i][j] = cc;\n    }\n  }\n\n  Graph<CostEdge> g(2 + 2 * n);\n  const int start = 2 * n;\n  const int goal  = 2 * n + 1;\n\n  REP(i,n) REP(j,n){\n    g.addEdge(i, n + j, 1, c[i][j]);\n  }\n\n  REP(i,n){\n    g.addEdge(start, i, 1, 0);\n    g.addEdge(n + i, goal, 1, 0);\n  }\n\n  int cost = minCostFlow(g, start, goal, n);\n\n  printf(\"%d\\n\", cost);\n\n  vector<string> ans;\n  const Graph<CostEdge>::G &gg = g.getRowGraph();\n  REP(i,n){\n    int dst = -1;\n    REP(j,n){\n      if(gg[i][j].cap == 0){\n        dst = gg[i][j].to - n;\n      }\n    }\n    while(dst == -1) ;\n    REP(j,n){\n      char buff[256];\n      if(f[i][j] && dst != j){\n        sprintf(buff, \"%d %d erase\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n      if(!f[i][j] && dst == j){\n        sprintf(buff, \"%d %d write\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans.size());\n  REP(i,ans.size())\n    printf(\"%s\\n\", ans[i].c_str());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define pb push_back\ntypedef long long Int;\n\nstruct MinCostFlow {\n    typedef Int cost_t;\n    int n, m, s, t;\n    vector<int> head, u, v, capa, rev, next, flow, prev;\n    cost_t r;\n    vector<cost_t> cost, h, dist;\n    MinCostFlow(int _n)\n        : n(_n), m(0), s(-1), head(_n, -1), prev(_n), h(_n), dist(_n)  {}\n    void add(int _u, int _v, int ca, cost_t co) {\n        u.pb(_u); v.pb(_v); capa.pb(ca); cost.pb(co);\n        rev.pb(m+1); next.pb(head[u[m]]); head[u[m]]=m; m++;\n        u.pb(_v); v.pb(_u); capa.pb(0); cost.pb(-co);\n        rev.pb(m-1); next.pb(head[u[m]]); head[u[m]]=m; m++;\n    }\n    void standby(int _s, int _t) {\n        s = _s; t = _t; r = 0;\n        flow = vector<int>(m, 0);\n        fill(h.begin(), h.end(), 0);\n    }\n    cost_t min_cost() { return r; }\n    bool pour(int f) {\n        const cost_t inf = 1<<28;\n        assert(s>=0);\n        while(f>0) {\n            priority_queue<pair<cost_t, int> > q;\n            std::fill(dist.begin(), dist.end(), inf);\n            dist[s] = 0;\n            q.push(mp(0, s));\n            while(!q.empty()) {\n                pair<cost_t, int> z(q.top());\n                q.pop();\n                int cur=z.second;\n                if(dist[cur]<-z.first) continue;\n                for(int x=head[cur]; x!=-1; x=next[x]) if(capa[x]-flow[x]>0) {\n                    if(dist[v[x]]>dist[cur]+cost[x]+h[cur]-h[v[x]]) {\n                        dist[v[x]] = dist[cur]+cost[x]+h[cur]-h[v[x]];\n                        prev[v[x]] = x;\n                        q.push(mp(-dist[v[x]], v[x]));\n                    }\n                }\n            }\n            if(dist[t]==inf) return false;\n            rep(i, n) h[i] += dist[i];\n            int d=f;\n            for(int cur=t; cur!=s; cur=u[prev[cur]]) {\n                d = min(d, capa[prev[cur]]-flow[prev[cur]]);\n            }\n            f -= d;\n            r += d*h[t];\n            for(int cur=t; cur!=s; cur=u[prev[cur]]) {\n                flow[prev[cur]]+=d;\n                flow[rev[prev[cur]]]-=d;\n            }\n        }\n        return true;\n    }\n};\n\nint n;\nint W[128][128], E[128][128];\nchar f[128][128];\n\nint main() {\n    scanf(\"%d\", &n);\n    rep (i, n) rep (j, n) scanf(\"%d\", W[i]+j);\n    rep (i, n) rep (j, n) scanf(\"%d\", E[i]+j);\n    rep (i, n) rep (j, n) scanf(\" %c\", f[i]+j);\n    MinCostFlow mcf(2*n+2);\n    Int base = 0, offset = 0;\n    rep (i, n) rep (j, n) if (f[i][j] == 'o') {\n        base += E[i][j];\n        offset = max(offset, (Int)E[i][j]);\n    }\n    rep (i, n) rep (j, n) {\n        if (f[i][j] == 'o') mcf.add(2+i, 2+n+j, 1, offset-E[i][j]);\n        else mcf.add(2+i, 2+n+j, 1, offset+W[i][j]);\n    }\n    rep (i, n) mcf.add(0, 2+i, 1, 0);\n    rep (i, n) mcf.add(2+n+i, 1, 1, 0);\n    mcf.standby(0, 1);\n    mcf.pour(n);\n    Int ans = base + mcf.min_cost() - offset * n;\n    printf(\"%d\\n\", (int)ans);\n    int c = 0;\n    rep (i, n) rep (j, n) {\n        if (mcf.flow[2*(i*n+j)] && f[i][j] == '.') c++;\n        if (!mcf.flow[2*(i*n+j)] && f[i][j] == 'o') c++;\n    }\n    printf(\"%d\\n\", c);\n    rep (i, n) rep (j, n) {\n        if (mcf.flow[2*(i*n+j)] && f[i][j] == '.') {\n            printf(\"%d %d write\\n\", i+1, j+1);\n        }\n        if (!mcf.flow[2*(i*n+j)] && f[i][j] == 'o') {\n            printf(\"%d %d erase\\n\", i+1, j+1);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <fstream>\n#include <set>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nclass CostFlow\n{\npublic:\n    using Cost = int;\n    using Ind = int;\n    using Capacity = int;\n    using T = int;\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}\n    {\n        edge.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // // Bellman-Ford(Replace this when DAG)\n        // for (int i = 0; i < V; i++) {\n        //     m_potential[i] = INF<T>;\n        // }\n        // m_potential[s] = 0;\n        // bool no_negative_loop = true;\n        // for (int i = 0; i < V; i++) {\n        //     for (int v = 0; v < V; v++) {\n        //         if (m_potential[v] != INF<T>) {\n        //             for (const auto& e : edge[v]) {\n        //                 if (e.capacity <= 0) {\n        //                     continue;\n        //                 }\n        //                 if (m_potential[e.to] > m_potential[v] + e.cost) {\n        //                     m_potential[e.to] = m_potential[v] + e.cost;\n        //                     if (i == V - 1) {\n        //                         m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n        //                         no_negative_loop = false;\n        //                     }\n        //                 }\n        //             }\n        //         }\n        //     }\n        // }\n        // if (not no_negative_loop) {\n        //     // ????????¨?????????\n        // }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                //                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> m_dist;\n    vector<Cost> m_potential;\n    vector<Ind> m_prev_v;\n    vector<Ind> m_prev_e;\n};\n\nstruct Ope {\n    bool o;\n    int r;\n    int c;\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<int>> W(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n    vector<vector<int>> E(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    vector<vector<bool>> use(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n; j++) {\n            use[i][j] = (s[j] == 'o');\n        }\n    }\n\n    vector<vector<int>> c(n, vector<int>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (not use[i][j]) {\n                c[i][j] = W[i][j];\n            } else {\n                for (int k = 0; k < n; k++) {\n                    if (j == k) {\n                        continue;\n                    }\n                    c[i][k] += E[i][j];\n                }\n                for (int k = 0; k < n; k++) {\n                    if (i == k) {\n                        continue;\n                    }\n                    c[k][j] += E[i][j];\n                }\n            }\n        }\n    }\n\n    CostFlow flow(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            flow.addEdge(i, j + n, 1, c[i][j]);\n        }\n    }\n    const int s = 2 * n;\n    const int t = 2 * n + 1;\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(s, i, 1, 0);\n        flow.addEdge(n + i, t, 1, 0);\n    }\n    cout << flow.minCostFlow(s, t, n) << endl;\n\n    set<int> node;\n    node.insert(s);\n    vector<Ope> op;\n    for (int i = 0; i < n; i++) {\n        for (const auto& e : flow.edge[i]) {\n            if (e.is_reverse) {\n                continue;\n            }\n            if (e.flow == 1) {\n                if (not use[i][e.to - n]) {\n                    op.push_back(Ope{false, i, e.to - n});\n                }\n            } else {\n                if (use[i][e.to - n]) {\n                    op.push_back(Ope{true, i, e.to - n});\n                }\n            }\n        }\n    }\n\n    cout << op.size() << endl;\n    for (const auto& o : op) {\n        cout << o.r + 1 << \" \" << o.c + 1 << \" \" << (o.o ? \"erase\" : \"write\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 110;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint G[MAX_V+1][MAX_V+1];\nint h[MAX_V*2+2], dist[MAX_V*2+2];\nint prevv[MAX_V*2+2];\nbool used[MAX_V*2+2];\nbool flow[MAX_V+1][MAX_V+1] = {};\n\nint bit_matching_cost(int l, int r) {\n    int min_f = 0;\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            min_f = min(min_f, G[i][j]);\n        }\n    }\n    for (int i = 0; i < l; i++) {\n        for (int j = 0; j < r; j++) {\n            G[i][j] -= min_f;\n        }\n    }    \n\tfor (int i = 0; i < l; i++) {\n\t\tG[i][r] = 0;\n\t\tflow[i][r] = true;\n\t}\n\tfor (int i = 0; i < r; i++) {\n\t\tG[l][i] = 0;\n\t\tflow[l][i] = true;\n\t}\n    G[l][r] = INT_INF;\n    flow[l][r] = false;\n\tint res = 0;\n\tfill_n(h, l+r+2, 0);\n\twhile (true) {\n\t\tfill_n(dist, l+r+2, INT_INF);\n\t\tdist[l+r+1] = 0;\n        fill_n(used, l+r+2, false);\n        while (true) {\n            int v = -1;\n            int dist2 = 0;\n            int flag;\n            for (int i = 0; i < l+r+2; i++) {\n                if (!used[i] && (v == -1 || dist[i] < dist2)){\n                    v = i;\n                    dist2 = dist[i];\n                }\n            }\n            if (v == -1) break;\n            flag = (v < l+1);\n            if (flag) {\n            \tused[v] = true;\n\t            for (int i = 0; i < r+1; i++) {\n\t\t\t\t\tif (!flow[v][i] && dist[i+l+1] > dist[v] + G[v][i] + h[v] - h[i+l+1]) {\n\t\t\t\t\t\tdist[i+l+1] = dist[v] + G[v][i] + h[v] - h[i+l+1];\n\t\t\t\t\t\tprevv[i+l+1] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n            } else {\n            \tused[v] = true;\n\t            for (int i = 0; i < l+1; i++) {\n\t\t\t\t\tif (flow[i][v-(l+1)] && dist[i] > dist[v] - G[i][v-(l+1)] + h[v] - h[i]) {\n\t\t\t\t\t\tdist[i] = dist[v] - G[i][v-(l+1)] + h[v] - h[i];\n\t\t\t\t\t\tprevv[i] = v-(l+1);\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tif (dist[l] >= INT_INF) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int v = 0; v < l+r+2; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tres += h[l];\n        res += min_f;\n\t\tbool flag = true;\n\t\tfor (int v = l; !(v == r && !flag) ; v = (flag) ? prevv[v] : prevv[v+l+1], flag = !flag) {\n\t\t\tif (flag) {\n\t\t\t\tflow[v][prevv[v]] = false;\n\t\t\t} else {\n\t\t\t\tflow[prevv[v+l+1]][v] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t}\n\t}\n\n    int f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tG[i][j] = -E[i][j];\n                f += E[i][j];\n\t\t\t} else {\n\t\t\t\tG[i][j] = W[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tf += bit_matching_cost(N, N);\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] != flow[i][j]) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64=int_fast64_t;\nusing pii=pair<int,int>;\ntemplate <class T> using minheap=priority_queue<T,vector<T>,greater<T>>;\n#define fir first\n#define sec second\n#define mkp make_pair\n#define all(v) begin(v),end(v)\n\nint n;\nint w[120][120],e[120][120];\nint cost[120][120];\nstring f[120];\nvector<tuple<int,int,int,int>> adj[250];\nvector<tuple<int,int,string>> ope[120][120];\n\nvoid add_edge(int x,int y,int cap,int cos) {\n    int xx=adj[x].size();\n    int yy=adj[y].size();\n    adj[x].emplace_back(y,cap,cos,yy);\n    adj[y].emplace_back(x,0,-cos,xx);\n}\n\nint dist[250];\ni64 h[250];\npii _prev[250];\nint findway(int s,int t) {\n    memset(_prev,0,sizeof(_prev));\n    fill(dist,dist+250,1e9);\n    dist[s]=0;\n    minheap<tuple<int,int>> mhp;\n    mhp.emplace(0,s);\n    while(!mhp.empty()) {\n        int v,c; tie(c,v)=mhp.top(); mhp.pop();\n        if(c>dist[v]) continue;\n        int eid=0;\n        for(auto &e:adj[v]) {\n            int u,rev,cp,cs;\n            tie(u,cp,cs,rev)=e;\n            if(cp>0) {\n                if(dist[u]+h[u]>cs+dist[v]+h[v]) {\n                    _prev[u]={v,eid};\n                    mhp.emplace(dist[u]=dist[v]+h[v]+cs-h[u],u);\n                }\n            }\n            eid++;\n        }\n    }\n    for(int i=0; i<250; ++i) {\n        h[i]+=dist[i];\n    }\n    for(int v=t; v!=s; v=_prev[v].fir) {\n        int x,y; tie(x,y)=_prev[v];\n        get<1>(adj[x][y])--;\n        get<1>(adj[v][get<3>(adj[x][y])])++;\n    }\n    return h[t];\n}\n\nint mincostflow(int s,int t,int f) {\n    int ret=0;\n    for(int i=0; i<f; ++i) {\n        ret+=findway(s,t);\n    }\n    return ret;\n}\n\n\nint row(int x) {\n    return 2+x;\n}\n\nint col(int x) {\n    return n+2+x;\n}\n\nsigned main() {\n    #ifdef LOCAL\n    freopen(\"stdout.txt\",\"wt\",stdout);\n    #endif\n    cin>>n;\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            cin>>w[i][j];\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            cin>>e[i][j];\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        cin>>f[i];\n        for(int j=0; j<n; ++j) {\n            int &c=cost[i][j];\n            for(int k=0; k<n; ++k) {\n                if(k!=j) {\n                    if(f[i][k]!='.') {\n                        c+=e[i][k];\n                        ope[i][j].emplace_back(i+1,k+1,\"erase\");\n                    }\n                } else {\n                    if(f[i][k]!='o') {\n                        c+=w[i][k];\n                        ope[i][j].emplace_back(i+1,k+1,\"write\");\n                    }\n                }\n            }\n            add_edge(row(i),col(j),1,c);\n        }\n    }\n    int s=0,t=1;\n    for(int i=0; i<n; ++i) {\n        add_edge(s,row(i),1,0);\n        add_edge(col(i),t,1,0);\n    } \n    int mcos=mincostflow(s,t,n);\n    cout<<mcos<<\"\\n\";\n    vector<tuple<int,int,string>> ans;\n    for(int i=0; i<n; ++i) {\n        for(auto &e:adj[row(i)]) {\n            int j,cap;\n            tie(j,cap,ignore,ignore)=e;\n            j-=n+2;\n            if(cap==0) {\n                for(auto &x:ope[i][j]) {\n                    ans.emplace_back(x);\n                }\n                break;\n            }\n        }\n    }\n    cout<<ans.size()<<endl;\n    for(auto &e:ans) {\n        int p,q; string r;\n        tie(p,q,r)=e;\n        cout<<p<<\" \"<<q<<\" \"<<r<<\"\\n\";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\nconst int MAX_V= 1002;\n \nstruct edge{\n  int to,cap,cost,rev;\n  edge(int to,int cap,int cost,int rev) :\n    to(to),cap(cap),cost(cost),rev(rev) {}\n};\n  \nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n  \nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n  \nint min_cost_flow(int s,int t,int f){\n  int res = 0;\n  while(f>0){\n    fill(dist,dist+MAX_V,MAX); dist[s] = 0;\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0; v<MAX_V; v++){\n        if(dist[v]==MAX) continue;\n        for(int i=0; i<(int)G[v].size(); i++){\n          edge &e=G[v][i];\n          if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v; preve[e.to]=i; update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]==MAX) return -1;\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;res+=d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  R n;\n  int w[n][n],e[n][n];\n  rep(i,n)rep(j,n) R w[i][j];\n  rep(i,n)rep(j,n) R e[i][j];\n  string s[n],t[n];\n  rep(i,n) {\n    R s[i];\n    rep(j,n) t[i]+='.';\n  }\n  rep(i,n) {\n    add_edge(201,i,1,0);\n    add_edge(100+i,202,1,0);\n    rep(j,n) {\n      int sum=0;\n      if(s[i][j]=='.') {\n\tsum+=w[i][j]*2;\n\trep(k,n) if(s[i][k]=='o') sum+=e[i][k];\n\trep(k,n) if(s[k][j]=='o') sum+=e[k][j];\n      } else {\n\trep(k,n) {\n\t  if(k==j) continue;\n\t  if(s[i][k]=='o') sum+=e[i][k];\n\t}\n\trep(k,n) {\n\t  if(k==i) continue;\n\t  if(s[k][j]=='o') sum+=e[k][j];\n\t}\n      }\n      add_edge(i,j+100,1,sum);\n    }\n  }\n  pr(min_cost_flow(201,202,n)/2);\n  rep(i,n) {\n    rep(j,G[i].size()) {\n      edge p=G[i][j];\n      if(!p.cap && p.to>=100 && p.to<200) t[i][p.to-100]='o';\n     }\n  }\n  int cnt=0;\n  rep(i,n) {\n    rep(j,n) {\n      if(s[i][j]!=t[i][j]) cnt++;\n    }\n  }\n  pr(cnt);\n  rep(i,n) {\n    rep(j,n) {\n      if(s[i][j]==t[i][j]) continue;\n      cout << i+1 << \" \" << j+1;\n      if(t[i][j]=='o') cout << \" write\" << endl;\n      else cout << \" erase\" << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tif (from < 0 || to < 0) return;\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\nint dist[21000], h[21000] = {0}, prevV[21000], prevE[21000];\nll min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+21000, inf); dist[s] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > Q; Q.push({0, s});\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.top(); Q.pop();\n\t\t\tint v = p.second;\n\t\t\tif (p.first > dist[v]) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\tEdge& e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[v]+e.cost+h[v]-h[e.to] < dist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevV[e.to] = v;\n\t\t\t\t\tprevE[e.to] = i;\n\t\t\t\t\tQ.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < G.size(); ++i) h[i] += dist[i];\n\n\t\tif (dist[t] == inf) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tint N; cin >> N;\n\tvector< vector<int> > W(N, vector<int>(N)); cin >> W;\n\tvector< vector<int> > E(N, vector<int>(N)); cin >> E;\n\tvector<string> m(N); cin >> m;\n\tint s = N*2, t = s+1;\n\tG.resize(t+1);\n\tREP(y, N) REP(x, N) {\n\t\tll cost = m[y][x] == '.' ? W[y][x]*2 : 0;\n\t\tREP(Y, N) {\n\t\t\tif (Y == y) continue;\n\t\t\tif (m[Y][x] == 'o') {\n\t\t\t\tcost += E[Y][x];\n\t\t\t}\n\t\t}\n\t\tREP(X, N) {\n\t\t\tif (X == x) continue;\n\t\t\tif (m[y][X] == 'o') {\n\t\t\t\tcost += E[y][X];\n\t\t\t}\n\t\t}\n\t\tadd_edge(y, N+x, 1, cost);\n\t}\n\tREP(y, N) add_edge(s, y, 1, 0);\n\tREP(x, N) add_edge(N+x, t, 1, 0);\n\tint cost = min_cost_flow(s, t, N)/2;\n\tvector<int> v(N, -1);\n\tREP(i, N) {\n\t\tEACH(e, G[i]) {\n\t\t\tif (e.cap == 0) {\n\t\t\t\tv[i] = e.to-N;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<string> mm;\n\tREP(i, N) {\n\t\tstring str = \"\";\n\t\tREP(j, N) {\n\t\t\tif (j == v[i]) str += \"o\";\n\t\t\telse str += \".\";\n\t\t}\n\t\tmm.pb(str);\n\t}\n\tint cnt = 0;\n\tREP(y, N) REP(x, N) {\n\t\tif (m[y][x] != mm[y][x]) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\tcout << cost << endl;\n\tcout << cnt << endl;\n\tREP(y, N) REP(x, N) {\n\t\tif (m[y][x] != mm[y][x]) {\n\t\t\tcout << y+1 << \" \" << x+1 << \" \";\n\t\t\tif (m[y][x] == '.') {\n\t\t\t\tcout << \"write\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"erase\" << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n \nconst int INF = (1<<28);\n \nclass Edge\n{\npublic:\n    int src,dst,cst,cap,rev;\n    Edge(int src, int dst, int cst, int cap, int rev)\n        :src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n    {}\n};\n \ntypedef vector<vector<Edge> > Graph;\n \nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n    graph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n    graph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n \npair<int, int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n  int V = graph.size();\n  vector<int> dist(V), prevv(V), preve(V);\n \n  int res = 0, fw = 0;\n  while(1) {\n    fill(dist.begin(), dist.end(), INF);\n    dist[S] = 0;\n    bool update = true;\n \n    while(update) {\n      update = false;\n      for(int v = 0; v < V; v++) {\n        if(dist[v] == INF) continue;\n \n        for(int i=0; i<graph[v].size(); i++) {\n          Edge& e = graph[v][i];\n          int cost = e.cst;\n          if(graph[e.dst][e.rev].cap != 0) cost = 0;\n \n          if(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n            dist[e.dst] = dist[e.src] + cost;\n            prevv[e.dst] = e.src;\n            preve[e.dst] = i;\n            update = true;\n          }\n        }\n      }\n    }\n \n    if(dist[T] == INF) break;\n \n    int f = INF;\n    for(int v = T; v != S; v = prevv[v])\n      f = min(f, graph[prevv[v]][preve[v]].cap);\n \n    res += dist[T];\n    fw += f;\n \n    for(int v = T; v != S; v = prevv[v]) {\n      Edge& e = graph[prevv[v]][preve[v]];\n      e.cap -= f;\n      graph[v][e.rev].cap += f;\n    }\n \n    if(fw >= L) break;\n  }\n \n  return make_pair(res, fw);\n}\n \nint ecst[100][100], icst[100][100];\nint main()\n{\n    int N;\n    cin >> N;\n    for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n        cin >> icst[i][j];\n \n    for(int i=0; i<N; i++)\n    for(int j=0; j<N; j++)\n        cin >> ecst[i][j];\n \n    string field[100];\n    for(int i=0; i<N; i++)\n        cin >> field[i];\n \n    Graph graph(N*2+2);\n    for(int i=0; i<N; i++) {\n        addEdge(N*2, i, 1, 0, graph);\n        addEdge(N+i, N*2+1, 1, 0, graph);\n    }\n \n    for(int i=0; i<N; i++) \n\tfor(int j=0; j<N; j++) {\n\t\tint cst = 0;\n\t\tfor(int k=0; k<N; k++) {\n\t\t\tif(field[k][j] == 'o') cst += ecst[k][j];\n\t\t\tif(field[i][k] == 'o') cst += ecst[i][k];\n\t\t}\n\n\t\tif(field[i][j] == 'o') cst -= 2*ecst[i][j];\n\t\tif(field[i][j] == '.') cst += 2*icst[i][j];\n \n        addEdge(j, i+N, 1, cst, graph);\n    }\n \n    pair<int, int> fw = minimumCostFlow(N*2, N*2+1, N, graph);\n \n\n    cout << fw.first/2 << endl;\n \n    int c = 0;\n    stringstream ss;\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<graph[i].size(); j++) {\n            Edge& e = graph[i][j];\n \n            if(e.dst < N || e.dst >= N*2) continue;\n \n            if(field[e.dst-N][e.src] == 'o' && e.cap == 1) {\n                c++;\n                ss << e.dst + 1 - N << \" \" << e.src + 1 << \" erase\" << endl;\n            }\n            if(field[e.dst-N][e.src] == '.' && e.cap == 0) {\n                c++;\n                ss << e.dst + 1 - N << \" \" << e.src + 1 << \" write\" << endl;\n            }\n        }\n    }\n \n    cout << c << endl;\n    cout << ss.str();\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e9;\n\ntemplate<typename flow_t, typename cost_t>\nstruct Flow {\n\tconst cost_t INF = pow(10, 18);\n\tstruct edge {\n\t\tlint to;\n\t\tflow_t cap;\n\t\tcost_t cost;\n\t\tlint rev;\n\t\tbool isrev;\n\t};\n\tvector<vector<edge> > Graph;\n\tvector<cost_t> potential, min_cost;\n\tvector<lint> prevv, preve;\n\tvector<lint> level;\n\tvector<lint> iter;\n\n\tFlow(lint V) :Graph(V) {}\n\n\tvoid add_edge(lint from, lint to, flow_t cap, cost_t cost = 0) {\n\t\tGraph[from].push_back({ to, cap, cost, SZ(Graph[to]), false });\n\t\tGraph[to].push_back({ from, 0, -cost, SZ(Graph[from]) - 1, true });\n\t}\n\n\tvoid bfs(lint s) {\n\t\tlint V = SZ(Graph);\n\t\tlevel.assign(V, -1);\n\t\tqueue<lint> que;\n\t\tque.push(s);\n\t\tlevel[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tlint v = que.front(); que.pop();\n\t\t\tREP(i, SZ(Graph[v])) {\n\t\t\t\tedge& e = Graph[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tflow_t dfs(lint v, lint t, flow_t f) {\n\t\tif (v == t) return f;\n\t\tfor (lint& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tflow_t d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tflow_t max_flow(lint s, lint t) {\n\t\tflow_t flow = 0;\n\t\tlint V = SZ(Graph);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\titer.assign(V, 0);\n\t\t\tflow_t f;\n\t\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\n\tlint min_cost_flow(lint s, lint t, lint f) {\n\t\tcost_t res = 0;\n\t\tlint V = SZ(Graph);\n\n\t\tpotential.assign(V, 0);\n\t\tprevv.assign(V, -1);\n\t\tpreve.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<pair<cost_t, lint>, vector<pair<cost_t, lint> >, greater<pair<cost_t, lint> > > que;\n\t\t\tmin_cost.assign(V, INF);\n\t\t\tmin_cost[s] = 0;\n\t\t\tque.push({ 0, s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpair<cost_t, lint> p = que.top(); que.pop();\n\t\t\t\tlint v = p.second;\n\t\t\t\tif (min_cost[v] < p.first) continue;\n\t\t\t\tREP(i, SZ(Graph[v])) {\n\t\t\t\t\tedge& e = Graph[v][i];\n\t\t\t\t\tcost_t nextCost = min_cost[v] + e.cost + potential[v] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ min_cost[e.to], e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tREP(v, V) potential[v] += min_cost[v];\n\n\t\t\tflow_t addflow = f;\n\t\t\tfor (lint v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, Graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tres += addflow * potential[t];\n\t\t\tfor (lint v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge& e = Graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tGraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<plint> output(lint N) {\n\t\tvector<plint> vec;\n\t\tREP(i, SZ(Graph)){\n\t\t\tfor (edge& e : Graph[i]) {\n\t\t\t\tif (e.isrev) continue;\n\t\t\t\tedge& rev_e = Graph[e.to][e.rev];\n\t\t\t\tif (i == N * 2 || e.to == N * 2 + 1) continue;\n\t\t\t\tif (rev_e.cap == 1) vec.push_back({ i % N, e.to % N });\n\t\t\t}\n\t\t}\n\t\treturn vec;\n\t}\n};\nlint N;\nlint W[100][100], E[100][100];\nchar char_map[100][100];\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\tcin >> N;\n\tlint s = N * 2, t = s + 1;\n\tFlow<lint, lint> g(t + 1);\n\tlint Init_cost = 0;\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tcin >> W[i][j];\n\t\t}\n\t}\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tcin >> char_map[i][j];\n\t\t\tif (char_map[i][j] == 'o') Init_cost += E[i][j];\n\t\t}\n\t}\n\tREP(i, N) {\n\t\tg.add_edge(s, i, 1, 0);\n\t\tg.add_edge(i + N, t, 1, 0);\n\t}\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tif (char_map[i][j] == 'o') g.add_edge(i, j + N, 1, -E[i][j]);\n\t\t\telse g.add_edge(i, j + N, 1, W[i][j]);\n\t\t}\n\t}\n\tcout << Init_cost + g.min_cost_flow(s, t, N) << endl;\n\tauto vec = g.output(N);\n\ttypedef pair<plint, string> Pi;\n\tvector<Pi> ans;\n\tREP(i, SZ(vec)) {\n\t\tif (char_map[vec[i].first][vec[i].second] == 'o') {\n\t\t\tchar_map[vec[i].first][vec[i].second] = '.';\n\t\t}\n\t\telse {\n\t\t\tans.push_back({ vec[i], \"write\" });\n\t\t}\n\t}\n\tREP(i, N) {\n\t\tREP(j, N) {\n\t\t\tif (char_map[i][j] == 'o') ans.push_back({ {i, j}, \"erase\" });\n\t\t}\n\t}\n\tcout << SZ(ans) << endl;\n\tREP(i, SZ(ans)) {\n\t\tcout << to_string(ans[i].first.first + 1) + \" \" + to_string(ans[i].first.second + 1) + \" \" + ans[i].second << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n\n        MinCostFlow solver(N + N + 2);\n        int Source = N * N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                //printf(\"%d -> %d : %d\\n\", y, sx, cost);\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        int cost = 0;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    cost += W[y][x];\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    cost += E[y][x];\n                    count++;\n                }\n            }\n        }\n        //assert(mincost == cost);\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\n//typedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nconst int INF = 1e7;\n\ntemplate <typename T>\nstruct MinCostFlow {\n  struct Edge {\n    int to, rev; T cap, cost;\n    Edge(int to, int rev, T cap, T cost) : to(to), rev(rev), cap(cap), cost(cost) { }\n  };\n\n  struct Node {\n    int v; T dist;\n    Node(int v, T dist) : v(v), dist(dist) { };\n    bool operator < (const Node &n) const {\n      return dist > n.dist; // reverse\n    }\n  };\n\n  typedef vector<Edge> Edges;\n  vector<Edges> G;\n  int V;\n  vector<int> dist, h, prevv, preve;\n\n  MinCostFlow(int V) : V(V) { G.resize(V); }\n\n  void add_edge(int from, int to, T cap, T cost) {\n    G[from].emplace_back(to, G[to].size(), cap, cost);\n    G[to].emplace_back(from, (int)G[from].size()-1, 0, -cost);\n  }\n\n  T run(int source, int sink, T f) {\n    T res = 0;\n    h.resize(V, 0);\n    prevv.resize(V), preve.resize(V);\n    while (f > 0) {\n      priority_queue<Node> pque;\n      dist.assign(V, INF);\n      dist[source] = 0;\n      pque.emplace(source, 0);\n      while (not pque.empty()) {\n        Node n = pque.top(); pque.pop();\n        int v = n.v; T cost = n.dist;\n        if (dist[v] < cost) continue;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n          Edge e = G[v][i];\n          if (e.cap > 0 and dist[v] - h[e.to] < dist[e.to] - e.cost - h[v]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v, preve[e.to] = i;\n            pque.emplace(e.to, dist[e.to]);\n          }\n        }\n      }\n      if (dist[sink] == INF) return -1;\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n\n      T d = f;\n      for (int v = sink; v != source; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[sink];\n      for (int v = sink; v != source; v = prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nint N;\n\nint row_idx(int r) { return r; }\nint col_idx(int c) { return N + c; }\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> N;\n  MinCostFlow<int> mcf(2 * N + 2);\n  int source = 2 * N, sink = source + 1;\n\n  vector<vector<int>> W(N, vector<int>(N)), E(N, vector<int>(N)), board(N, vector<int>(N));\n  REP(i, N) REP(j, N) cin >> W[i][j];\n  REP(i, N) REP(j, N) cin >> E[i][j];\n  REP(i, N) {\n    string row; cin >> row;\n    REP(j, N) board[i][j] = row[j] == 'o';\n  }\n\n  ll ans = 0;\n  REP(i, N) REP(j, N) if (board[i][j]) ans += E[i][j];\n\n  REP(i, N) mcf.add_edge(source, row_idx(i), 1, 0);\n\n  ll geta = 1000;\n  REP(i, N) REP(j, N) {\n    if (board[i][j]) {\n      mcf.add_edge(row_idx(i), col_idx(j), 1, -E[i][j] + geta);\n    } else {\n      mcf.add_edge(row_idx(i), col_idx(j), 1, W[i][j] + geta);\n    }\n  }\n\n  REP(i, N) mcf.add_edge(col_idx(i), sink, 1, 0);\n\n  ll cost = mcf.run(source, sink, N) - N * geta;\n  ans += cost;\n  cout << ans << endl;\n\n  vector<tuple<int, int, string>> proc;\n  REP(i, N) REP(j, N) {\n    if (board[i][j]) {\n      if (mcf.G[row_idx(i)][j+1].cap == 1) proc.emplace_back(i+1, j+1, \"erase\");\n    } else {\n      if (mcf.G[row_idx(i)][j+1].cap == 0) proc.emplace_back(i+1, j+1, \"write\");\n    }\n  }\n\n  cout << proc.size() << endl;\n  for (auto t : proc) {\n    int i, j; string p; tie(i, j, p) = t;\n    cout << i << ' ' << j << ' ' << p << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 100000;\nconst Cost INF = numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int d; Flow c, f; Cost w; int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n            :d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = pair<Cost, int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h + n, 0);\n        while (f > 0) {\n            fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)g[v].size(); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) {\n                return -1; // ?????????????????????????????£???\n            }\n\n            // s-t ????????????????????£??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n\n    // ???????????¨???\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n\nint n;\nint W[128][128], E[128][128];\nchar f[128][128];\nint ans[10000][3];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n\n    int C = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (f[i][j] == 'o') {\n                C += E[i][j];\n            }\n        }\n    }\n\n    PrimalDual pd(n * 2 + 2);\n\n    int s = n * 2, t = n * 2 + 1;\n    for (int i = 0; i < n; i++) {\n        pd.add_edge(s, i, 1, 0);\n        pd.add_edge(i + n, t, 1, 0);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            pd.add_edge(i, j + n, 1, f[i][j] == 'o' ? -E[i][j] : W[i][j]);\n        }\n    }\n\n    cout << C + pd.solve(s, t, n) << '\\n';\n\n    int cnt = 0;\n    for (int i = 0; i < pd.g.size(); i++) {\n        for (auto &e : pd.g[i]) {\n            if (e.is_r || e.w == 0) continue;\n            if (f[i][e.d - n] == 'o' && e.f == 0) {\n                cnt++;\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 0;\n            } else if (f[i][e.d - n] == '.' && e.f == 1) {\n                cnt++;\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 1;\n            }\n        }\n    }\n\n    cout << cnt << '\\n';\n    for (int i = 0; i < cnt; i++) {\n        ans[i][0]++;\n        ans[i][1]++;\n        cout << ans[i][0] << ' ' << ans[i][1] << ' ' << (ans[i][2] == 0 ? \"erase\" : \"write\") << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 100000;\nconst Cost INF = numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int d; Flow c, f; Cost w; int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n            :d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    vector<vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) { // ?????????\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // vector<Cost> h(g.size()), dist(g.size());\n        // vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = pair<Cost, int>;\n        priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n        fill(h, h + n, 0);\n        while (f > 0) {\n            fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd; int v;\n                tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)g[v].size(); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) {\n                return -1; // ?????????????????????????????£???\n            }\n\n            // s-t ????????????????????£??????????????????\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n\n    // ???????????¨???\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n\nint n;\nint W[128][128], E[128][128];\nchar f[128][128];\nint ans[10000][3];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    cin >> n;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> f[i];\n    }\n\n    int C = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (f[i][j] == 'o') {\n                C += E[i][j];\n            }\n        }\n    }\n\n    PrimalDual pd(n * 2 + 2);\n\n    int s = n * 2, t = n * 2 + 1;\n    for (int i = 0; i < n; i++) {\n        pd.add_edge(s, i, 1, 0);\n        pd.add_edge(i + n, t, 1, 0);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            pd.add_edge(i, j + n, 1, f[i][j] == 'o' ? -E[i][j] : W[i][j]);\n        }\n    }\n\n    cout << C + pd.solve(s, t, n) << '\\n';\n\n    int cnt = 0;\n    for (int i = 0; i < pd.g.size(); i++) {\n        for (auto &e : pd.g[i]) {\n            if (e.is_r || e.w == 0) continue;\n            if (f[i][e.d - n] == 'o' && e.f == 0) {\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 0;\n                cnt++;\n            } else if (f[i][e.d - n] == '.' && e.f == 1) {\n                ans[cnt][0] = i;\n                ans[cnt][1] = e.d - n;\n                ans[cnt][2] = 1;\n                cnt++;\n            }\n        }\n    }\n\n    cout << cnt << '\\n';\n    for (int i = 0; i < cnt; i++) {\n        ans[i][0]++;\n        ans[i][1]++;\n        cout << ans[i][0] << ' ' << ans[i][1] << (ans[i][2] == 0 ? \" erase\\n\" : \" write\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <functional>\nusing namespace std;\n\nstatic const int INF = 1e9;\nstruct MinCostFlow {\n\tstruct E {\n\t\t//to,??????,?????????,?????????index\n\t\tint to, cap, cost, rev;\n\t\tE(int t, int ca, int co, int r) {\n\t\t\tto = t;\n\t\t\tcap = ca;\n\t\t\tcost = co;\n\t\t\trev = r;\n\t\t}\n\t};\n\n\t//?????§????????°\n\tint V;\n\tvector<vector<E>>G;\n\tMinCostFlow(int v) {\n\t\tV = v;\n\t\tG.resize(V);\n\t}\n\n\t//?????????\n\tinline void add_edge(int from, int to, int cap, int cost) {\n\t\tif (from == to)return;\n\t\tE e = E(to, cap, cost, G[to].size());\n\t\tE ee = E(from, 0, -cost, G[from].size());\n\t\tG[from].push_back(e);\n\t\tG[to].push_back(ee);\n\t}\n\n\t//?????????????????¢??¨??????\n\t//?????????,????°??????????\n\tvector<int>dist, mindist;\n\t//??????????????¨\n\tvector<int>pre_v, pre_i;\n\n\t//?§????????????????????????§???????°??????????\n\tvoid dijkstra(int s) {\n\t\tpriority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > que;\n\t\tdist.assign(V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(pair<int, int>(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, int> p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tE &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + mindist[v] - mindist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + mindist[v] - mindist[e.to];\n\t\t\t\t\tpre_v[e.to] = v;\n\t\t\t\t\tpre_i[e.to] = i;\n\t\t\t\t\tque.push(pair<int, int>(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//????°??????¨?????????\n\tint min_cost_flow(int s, int t, int flow) {\n\t\tint cost = 0;\n\t\tmindist.resize(V);\n\t\tpre_v.resize(V);\n\t\tpre_i.resize(V);\n\n\t\t//????????????????????????????????§\n\t\twhile (flow > 0) {\n\t\t\tdijkstra(s);\n\t\t\t//????????????????????£??????\n\t\t\tif (dist[t] == INF)return -1;\n\n\t\t\t//????°???????????????´??°\n\t\t\tfor (int v = 0; v < V; v++)mindist[v] += dist[v];\n\n\t\t\t//????°???????????????????????????§???\n\t\t\tint f = flow;\n\t\t\tfor (int v = t; v != s; v = pre_v[v]) {\n\t\t\t\tf = min(f, G[pre_v[v]][pre_i[v]].cap);\n\t\t\t}\n\t\t\tflow -= f;\n\n\t\t\t//?????¨?????´??°\n\t\t\tcost += f * mindist[t];\n\n\t\t\t//???????????´??°\n\t\t\tfor (int v = t; v != s; v = pre_v[v]) {\n\t\t\t\tE& e = G[pre_v[v]][pre_i[v]];\n\t\t\t\tE& ee = G[v][e.rev];\n\t\t\t\te.cap -= f;\n\t\t\t\tee.cap += f;\n\t\t\t}\n\t\t}\n\n\t\treturn cost;\n\t}\n};\n\nint main()\n{\n\tint n; cin >> n;\n\tvector<vector<int>>W(n), E(n);\n\tvector<vector<int>>F(n);\n\tvector<vector<int>>we(n);\n\tint C = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tW[i].resize(n);\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> W[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tE[i].resize(n);\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tF[i].resize(n);\n\t\twe[i].resize(n);\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'o') {\n\t\t\t\tC += E[i][j];\n\t\t\t\tF[i][j] = -E[i][j];\n\t\t\t\twe[i][j]--;\n\t\t\t}\n\t\t\telse F[i][j] = W[i][j];\n\t\t}\n\t}\n\n\tMinCostFlow mcf(2*n+2);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tmcf.add_edge(0,i+1,1,0);\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tmcf.add_edge(i + 1, n + j + 1, 1, F[i][j]);\n\t\t}\n\t\tmcf.add_edge(n + i + 1, 2 * n + 1, 1, 0);\n\t}\n\n\tint ans = mcf.min_cost_flow(0, 2 * n + 1, n);\n\n\tcout << C+ans << endl;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 1; j < n+1; j++) {\n\t\t\tif (mcf.G[i + 1][j].cap == 0) {\n\t\t\t\twe[i][mcf.G[i + 1][j].to - n - 1]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (we[i][j] != 0)cnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (we[i][j] == 1)cout << i+1 << \" \" << j+1 << \" \" << \"write\" << endl;\n\t\t\telse if(we[i][j]==-1)cout << i+1 << \" \" << j+1 << \" \" << \"erase\" << endl;\n\t\t}\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define MAX_V 222\n\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cap,cost,rev;\n};\n\nint V;\nvector<edge> g[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init(int v){\n  V=v;\n  for(int i=0;i<MAX_V;i++){\n    g[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,int cap,int cost){\n  g[from].push_back((edge){to,cap,cost,(int)g[to].size()});\n  g[to].push_back((edge){from,0,-cost,(int)g[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  memset(h,0,sizeof(h));\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(que.size()){\n      P p=que.top(); que.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<g[v].size();i++){\n        edge e=g[v][i];\n        if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if(dist[t]==INF)return -1;\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,g[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=g[prevv[v]][preve[v]];\n      e.cap-=d;\n      g[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nint w[111][111],e[111][111];\nstring s[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n;\n  rep(i,n)rep(j,n)cin>>w[i][j];\n  rep(i,n)rep(j,n)cin>>e[i][j];\n  rep(i,n)cin>>s[i];\n  init(2*n+2);\n  rep(i,n)rep(j,n){\n    int cost=s[i][j]=='o'?0:w[i][j];\n    rep(k,n){\n      if(i==k)continue;\n      if(s[k][j]=='o'){\n        cost+=e[k][j];\n      }\n    }\n    add_edge(i,j+n,1,cost);\n  }\n  rep(i,n){\n    add_edge(2*n,i,1,0);\n    add_edge(i+n,2*n+1,1,0);\n  }\n  cout<<min_cost_flow(2*n,2*n+1,n)<<endl;\n  vector<P> ps;\n  rep(i,n){\n    rep(j,g[i].size()){\n      if(g[i][j].cap==0){\n        ps.push_back(P(i,g[i][j].to-n));\n      }\n    }\n  }\n  set<string> qs;\n  rep(l,ps.size()){\n    int i=ps[l].fi,j=ps[l].se;\n    if(s[i][j]=='.'){\n      string tmp=to_string(i+1)+\" \"+to_string(j+1)+\" write\";\n      qs.insert(tmp);\n    }\n    rep(k,n){\n      if(i==k)continue;\n      if(s[k][j]=='o'){\n        string tmp=to_string(k+1)+\" \"+to_string(j+1)+\" erase\";\n        qs.insert(tmp);\n      }\n    }\n    rep(k,n){\n      if(j==k)continue;\n      if(s[i][k]=='o'){\n        string tmp=to_string(i+1)+\" \"+to_string(k+1)+\" erase\";\n        qs.insert(tmp);\n      }\n    }\n  }\n  cout<<qs.size()<<endl;\n  for(string ss : qs){\n    cout<<ss<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 202\nusing namespace std;\ntypedef pair<int, int> P;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to_, int cap_, int cost_, int rev_)\n\t\t: to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid AddEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\n\nint MinimumCostFlow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\th[v] += dist[v];\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tV = n * 2 + 2;\n\tvector<vector<int>> W(n, vector<int>(n)), E(n, vector<int>(n));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> W[i][j];\n\t\t}\n\t\tAddEdge(n * 2, i, 1, 0);\n\t\tAddEdge(n + i, n * 2 + 1, 1, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tvector<string> s(n);\n\tint def = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tAddEdge(i, n + j, 1, W[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAddEdge(i, n + j, 1, -E[i][j]);\n\t\t\t\tdef += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << MinimumCostFlow(n * 2, n * 2 + 1, n) + def << endl;\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" erase\" << endl;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//--------------------\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,g[to].size(),cost});\n  g[to].pb((Edge){from,0,g[from].size()-1,-cost});\n}\nCost INF=1e7;\n\n//max_flow\n\nvector<int> used;\n\nint dfs(Graph &g,int v,int t,int f){\n  if(v==t) return f;\n  used[v]=1;\n  int re,i,j,k;\n  for(i=0;i<=g[v].size();i++){\n    edge &e=g[v][i];\n    if(e.cap<=0||used[e.to])continue;\n    int d=dfs(g,eto, t, ,min(f,e.cap));\n   // used[p]=0;\n    if(d>0){\n      e.cap-=d;\n      g[e.to][e.rev].cap+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint max_flow(Graph &g,int s,int t){\n  int sum=0,f,V=g.size();\n  while(1){\n    used.resize(V);\n    fill(all(used),0);\n    sum+=f=dfs(g,s,t,INF);\n    if(!f)return sum;\n  }\n}\n\n//min_cost,bf\n\ndouble min_cost_flow(Graph &g,int s,int t,int f){\n  int V=g.size();\n  vector<Cost> dist(V);\n  vector<int> used(V),prevv(V),preve(V);\n  double res=0;\n  int v,i;\n  while(f>0){\n    fill(all(dist),INF);\n    dist[s]=0;\n    bool upd=1;\n    while(upd){\n      upd=0;\n      rep(v,V){\n        if(dist[v]==INF)continue;\n        rep(i,g[v].size()){\n          Edge &e=g[v][i];\n          if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            upd=1;\n          }\n        }\n      }\n    }\n    if(dist[t]==INF)\n      return -1;\n    int d=f;\n    for(v=t;v!=s;v=prevv[v]){\n      d=min(d,g[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*dist[t];\n    for(v=t;v!=s;v=prevv[v]){\n      Edge &e=g[prevv[v]][preve[v]];\n      e.cap-=d;\n      g[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\n\n//min-cost,dij\n//aoj2429\n\ntypedef pair<Cost,int> Que;\n\n//f流せなければINF\nCost min_cost_flow(Graph &g,int s,int t,int f){\n  int V=g.size(),res=0;\n  vector<Cost> h(V,0),d(V);\n  vector<int> prevv(V),preve(V);\n  while(f>0){\n    priority_queue<Que,vector<Que>,greater<Que> > que;\n    int V=g.size();\n    d.resize(V);\n    fill(all(d),INF);\n    d[s]=0;\n    que.push(Que(0,s));\n    while(!que.empty()){\n      Que p=que.top();que.pop();\n      int v=p.Y;\n      if(d[v]<p.X)continue;\n      rep(i,g[v].size()){\n        Edge &e=g[v][i];\n        if(e.cap>0 && d[e.to]>d[v]+e.cost+h[v]-h[e.to]){\n          d[e.to]=d[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(Que(d[e.to],e.to));\n        }\n      }\n    }\n    if(d[t] == INF){\n      return INF;\n    }\n    rep(v,V)\n      h[v]+=d[v];\n    int flow=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      flow=min(flow,g[prevv[v]][preve[v]].cap);\n    }\n    f-=flow;\n    res+=flow*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      Edge &e=g[prevv[v]][preve[v]];\n      e.cap-=flow;\n      g[v][e.rev].cap+=flow;\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef int Weight;\nconst Weight INF=99999999;\n\nstruct Edge{\n\tint dst,cap;Weight cost,rev;\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\n\n//srcからdstへ向かう容量cap,コストcostの辺をグラフに追加する\nvoid add_edge(Graph &G,int src,int dst,Weight cap,Weight cost){\n\tG[src].push_back((Edge){dst,cap,cost,G[dst].size()});\n\tG[dst].push_back((Edge){src,0,-cost,G[src].size()-1});\n}\n\n//sからtへの流量fの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(Graph &G,int s,int t,int f){\n\ttypedef pair<int,int> P;\n\tint res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\t\n\twhile(f>0){\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tvector<Weight> dist(V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first)continue;\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tEdge &e=G[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.cost+h[v]-h[e.dst]){\n\t\t\t\t\tdist[e.dst]=dist[v]+e.cost+h[v]-h[e.dst];\n\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\t\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\nint E[100][100];\nint W[100][100];\nchar str[100][102];\nint D[100][100];\nint R[10000];\nint C[10000];\nchar ope[10001];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tscanf(\"%d\",&W[i][j]);\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tscanf(\"%d\",&E[i][j]);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tGraph g(2+a*2);\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(g,a*2,i,1,0);\n\t\tadd_edge(g,i+a,a*2+1,1,0);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(str[i][j]=='.')D[i][j]+=W[i][j];\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(j!=k&&str[i][k]=='o')D[i][j]+=E[i][k];\n\t\t\t}\n\t//\t\tprintf(\"%d \",D[i][j]);\n\t\t}//printf(\"\\n\");\n\t}\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++)\n\t\t\tadd_edge(g,i,a+j,1,D[i][j]);\n\tint ret=min_cost_flow(g,a*2,a*2+1,a);\n\tprintf(\"%d\\n\",ret);\n\tint n=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tif(g[i][j].dst<a*2){\n\t\t\t\tif(g[i][j].cap==0&&str[i][g[i][j].dst-a]=='.'){\n\t\t\t\t\tR[n]=i;\n\t\t\t\t\tC[n]=g[i][j].dst-a;\n\t\t\t\t\tope[n++]='w';\n\t\t\t\t}\n\t\t\t\tif(g[i][j].cap&&str[i][g[i][j].dst-a]=='o'){\n\t\t\t\t\tR[n]=i;\n\t\t\t\t\tC[n]=g[i][j].dst-a;\n\t\t\t\t\tope[n++]='e';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",n);\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d %d \",R[i]+1,C[i]+1);\n\t\tif(ope[i]=='e')printf(\"erase\\n\");\n\t\telse printf(\"write\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n  int src, dst, capacity, cost, rev;\n  Edge(int src, int dst, int capacity, int cost)\n    : src(src), dst(dst), capacity(capacity), cost(cost) {}\n  Edge(int src, int dst, int capacity, int cost, int rev)\n    : src(src), dst(dst), capacity(capacity), cost(cost), rev(rev) {}\n};\nbool operator<(const Edge &e, const Edge &f) {\n  return e.cost != f.cost ? e.cost > f.cost :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<int> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int s, int d, int cost, int cap) {\n  g[s].push_back(Edge(s,d,cap,cost));\n  g[d].push_back(Edge(d,s,0,-cost));\n  //cout<<s<<\" \"<<d<<\" \"<<cost<<\" \"<<cap<<endl;\n}\n\n#define RESIDUE(u,v) (capacity[u][v]-flow[u][v])\n#define RCOST(u,v) (cost[u][v] + h[u] - h[v])\n\nint sum;\npair<int, int> minimumCostFlow(Graph &g, int s, int t) {\n  const int n = g.size();\n  const int inf = 1<<29;\n  Matrix capacity(n, Array(n)), cost(n, Array(n)), flow(n, Array(n));\n  for (int u=0; u<n; ++u) {\n    for (Edges::iterator e = g[u].begin(); e != g[u].end(); ++e) {\n      capacity[e->src][e->dst] += e->capacity;\n      cost[e->src][e->dst] += e->cost;\n    }\n  }\n\n  pair<int,int> total = make_pair(0,0);\n  vector<int> h(n, inf);\n  h[s] = 0;\n  for (int k=0; k<n; ++k)\n    for (int i=0; i<n; ++i)\n      for (Edges::iterator e=g[i].begin(); e!=g[i].end(); ++e)\n        if (capacity[e->src][e->dst])\n          h[e->dst] = min(h[e->dst], h[e->src] + cost[e->src][e->dst]);\n\n  for (int F = inf; F > 0; ) {\n    vector<int> d(n, inf); d[s] = 0;\n    vector<int> p(n, -1);\n    priority_queue<Edge> Q;\n    for (Q.push(Edge(-2,s,0,0)); !Q.empty(); ) {\n      Edge e = Q.top(); Q.pop();\n      if (p[e.dst] != -1) continue;\n      p[e.dst] = e.src;\n      for (Edges::iterator f=g[e.dst].begin(); f != g[e.dst].end(); ++f) {\n        if (RESIDUE(f->src, f->dst) > 0) {\n          if (d[f->dst] > d[f->src] + RCOST(f->src, f->dst)) {\n            d[f->dst] = d[f->src] + RCOST(f->src, f->dst);\n            Q.push(Edge(f->src, f->dst, 0, d[f->dst]));\n          }\n        }\n      }\n    }\n\n    if (p[t] == -1) break;\n    int f = F;\n    for (int u=t; u!=s; u=p[u]) f = min(f, RESIDUE(p[u], u));\n    for (int u=t; u!=s; u=p[u]) {\n      total.first += f * cost[p[u]][u];\n      flow[p[u]][u] += f; flow[u][p[u]] -= f;\n    }\n    F -= f;\n    total.second += f;\n    for(int u=0; u<n; ++u) if (h[u] != inf) h[u] += d[u];\n  }\n  cout<<total.first+sum<<endl;\n  int cnt = 0;\n  int nn = (n-2)/2;\n  vector<pair<int,pair<int,int> > > v;\n  for (int i=0; i<nn; ++i) {\n    for (int j=0; j<nn; ++j) {\n      if (flow[i][j+nn] > 0 && cost[i][j+nn] > 0) {\n        cnt++;\n        v.push_back(make_pair(1, make_pair(i+1,j+1)));\n      }\n      if (flow[i][j+nn] == 0 && cost[i][j+nn] < 0) {\n        cnt++;\n        v.push_back(make_pair(0, make_pair(i+1,j+1)));\n      }\n    }\n  }\n  cout<<cnt<<endl;\n  for (int i=0; i<v.size(); ++i) {\n    if (v[i].first) cout<<\"write \";\n    else cout<<\"erase \";\n    cout<<v[i].second.second<<\" \"<<v[i].second.first<<endl;\n  }\n  return total;\n}\n\nint w[101][101], e[101][101];\nstring f[101];\n\nint main() {\n  int n;\n  while(cin>>n) {\n    for (int i=0; i<n; ++i) for(int j=0; j<n; ++j) cin>>w[i][j];\n    for (int i=0; i<n; ++i) for(int j=0; j<n; ++j) cin>>e[i][j];\n    for (int i=0; i<n; ++i) cin>>f[i];\n    Graph g(n*2+2);\n    sum = 0;\n    for (int i=0; i<n; ++i) add_edge(g, n*2, i, 0, 1);\n    for (int i=0; i<n; ++i) add_edge(g, i+n, n*2+1, 0, 1);\n    for (int x=0; x<n; ++x) {\n      for (int y=0; y<n; ++y) {\n        if (f[y][x] == 'o') {\n          add_edge(g, x, y+n, -e[y][x], 1);\n          sum += e[y][x];\n        } else {\n          add_edge(g, x, y+n, w[y][x], 1);\n        }\n      }\n    }\n\n    pair<int,int> ans = minimumCostFlow(g, n*2, n*2+1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429\nstruct PrimalDual {\n    typedef int Capacity;\n    typedef int Cost;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<Cost> h,dist;\n    vector<int> prevv, preve;\n    const Cost inf = 1<<29;\n\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        Cost cost;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n            :dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    PrimalDual(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)), h(n_), dist(n_), prevv(n_), preve(n_){}\n\n    void add_edge(int src, int dst, Capacity cap, Cost cost) {\n        g[src].push_back(Edge(dst, cap, cost, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, -cost, g[src].size() - 1, true));\n    }\n\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n        h.assign(n,0);\n        while (f > 0) {\n            typedef pair<Cost,int> pcv;\n            priority_queue<pcv, vector<pcv>, greater<pcv> > q;\n            dist.assign(n,inf);\n            dist[s] = 0;\n            q.push(pcv(0, s));\n            while (q.size()) {\n                pcv p = q.top(); q.pop();\n                int v = p.second;\n                if (dist[v] < p.first) continue;\n                rep(i,g[v].size()){\n                    Edge &e = g[v][i];\n                    if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n                        dist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        q.push(pcv(dist[e.dst], e.dst));\n                    }\n                }\n            }\n            if (dist[t] == inf) {\n                return -1;\n            }\n            rep(v,n) h[v] += dist[v];\n            // s-t 間最短路に沿って目一杯流す\n            int d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = min(d, g[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.cap -= d;\n                g[v][e.revEdge].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view(){\n        rep(i,g.size()){\n            rep(j,g[i].size())if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint W[111][111], E[111][111];\nchar f[111][111];\nint n;\nint N;\n\nvoid solve(){\n    int C=0;\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o')C+=E[i][j];\n    }\n    PrimalDual mcf(n*2+2);\n    int s=n*2, t=n*2+1;\n    rep(i,n){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+n,t,1,0);\n    }\n    rep(i,n)rep(j,n){\n        if(f[i][j]=='o'){\n            mcf.add_edge(i,j+n,1,-E[i][j]);\n        }else{\n            mcf.add_edge(i,j+n,1,W[i][j]);\n        }\n    }\n    printf(\"%d\\n\",C+mcf.min_cost_flow(s,t,n));\n    static int ans[10000][3];\n    int cnt=0;\n\n    rep(i,mcf.n){\n        rep(j,mcf.n){\n            auto & e=mcf.g[i][j];\n            if(e.isRev || e.cost==0) continue;\n            if(f[i][e.dst-n]=='o' && e.cap!=0){\n                cnt++;\n                ans[cnt][0]=i+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=0;\n            }else if(f[i][e.dst-n]=='.' && e.cap==0){\n                cnt++;\n                ans[cnt][0]=i+1;\n                ans[cnt][1]=e.dst-n+1;\n                ans[cnt][2]=1;\n            }\n        }\n    }\n    printf(\"%d\\n\",cnt);\n    rep(i,cnt){\n        printf(\"%d %d %s\\n\",ans[i][0],ans[i][1],ans[i][2]==0 ? \"erase\" : \"write\");\n    }\n}\n\nint main(){\n    while(cin >> n){\n        N=n*2+2;\n        rep(i,n)rep(j,n)cin>>W[i][j];\n        rep(i,n)rep(j,n)cin>>E[i][j];\n        rep(i,n)cin>>f[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n\n\n// 最小費用流\n// O(F E log V)\n// 与えられるもの\n// 有向グラフ G = (V, E)\n// 各辺 e に対して, 容量 u(e) >= 0\n// 各辺 e に対して, 費用 c(e) (負でも ok)\n\n// 使い方\n// PrimalDual(V) (コンストラクタ)\n// add_edge(int from, int to, flow_t cap, cost_t cost)\n// veryfied : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual{\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector<vector<edge>> graph;\n    vector<cost_t> potential, min_cost;\n    vector<int> prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()){}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost){\n        graph[from].emplace_back((edge) {to, cap, cost, (int)graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int)graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f){\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while(f > 0){\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()){\n                Pi p = que.top();\n                que.pop();\n                if(min_cost[p.second] < p.first) continue;\n                for(int i = 0; i < graph[p.second].size(); i++){\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if(e.cap > 0 && min_cost[e.to] > nextCost){\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if(min_cost[t] == INF) return -1;\n            for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for(int v = t; v != s; v = prevv[v]){\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for(int v = t; v != s; v = prevv[v]){\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n\n    void output(vector<pair<pair<int, int>, int>> &ans){\n        for(int i = 0; i < graph.size(); i++){\n            for(auto &e : graph[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nsigned main(){\n    \n    int n; cin >> n;\n    vector<vector<int>> W(n, vector<int> (n));\n    vector<vector<int>> E(n, vector<int> (n));\n    vector<vector<char>> F(n, vector<char> (n));\n    \n    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) cin >> W[i][j];\n    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) cin >> E[i][j];\n    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) cin >> F[i][j];\n    \n    int tmpCost = 0;\n    for(int i = 0; i < n; i++){\n       for(int j = 0; j < n; j++){\n            if(F[i][j] == 'o') tmpCost += E[i][j];\n        }\n    }\n\n    int V = 2 * n + 2;\n    PrimalDual<int, int> pd(V);\n\n    // 0 := s, 2 * n + 1 := t とする\n\n    // s から (1, 0) をはる\n    for(int i = 1; i <= n; i++){\n        pd.add_edge(0, i, 1, 0);\n    }\n\n    // t へ (1, 0) をはる\n    for(int i = n + 1; i <= 2 * n; i++){\n        pd.add_edge(i, 2 * n + 1, 1, 0);\n    }\n\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            int from = i + 1;\n            int to = j + 1 + n;\n            int cap = 1;\n            int cost = (F[i][j] == '.') ? W[i][j] : -E[i][j];\n            pd.add_edge(from, to, cap, cost);\n        }\n    }\n\n    cout << pd.min_cost_flow(0, 2 * n + 1, n) + tmpCost << endl;\n    vector<pair<pair<int, int>, string>> ans;\n    for(int i = 0; i < pd.graph.size(); i++){\n        for(auto &e : pd.graph[i]) {\n            if(e.isrev) continue;\n            auto &rev_e = pd.graph[e.to][e.rev];\n            if(i == 0) continue;\n            if(e.to == 2 * n + 1) continue;\n            int from = i - 1;\n            int to = e.to - 1 - n;\n            if(rev_e.cap == 1 and F[from][to] == '.') ans.push_back({{from + 1, to + 1}, \"write\"});\n            if(rev_e.cap == 0 and F[from][to] == 'o') ans.push_back({{from + 1, to + 1}, \"erase\"});\n            \n        }\n    }\n    cout << ans.size() << endl;\n    for(int i = 0; i < ans.size(); i++) cout << ans[i].first.first << \" \" << ans[i].first.second << \" \" << ans[i].second << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <utility>\n#include <queue>\n#include <string>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int index, capacity, cost;\n    Edge(int i, int c, int d) : index(i), capacity(c), cost(d) {}\n};\n\nstruct Command {\n    int r, c;\n    string cmd;\n    Command(int r, int c, const string &cmd) : r(r), c(c), cmd(cmd) {}\n};\n\n// O(V^2 U C) where\n//  U = sum of capacity\n//  C = sum of cost\npair<int,int> primal_dual(const vector<vector<Edge> >& g, int source, int sink, int total_flow, vector<vector<int> > &flow)/*{{{*/\n{\n  const int N = g.size();\n  vector<vector<int> > capacity(N, vector<int>(N, 0)), cost(N, vector<int>(N, 0)); \n  flow = vector<vector<int> >(N, vector<int>(N, 0));\n  for (int i = 0; i < N; i++) {\n    for (vector<Edge>::const_iterator it(g[i].begin()); it != g[i].end(); ++it) {\n      capacity[i][it->index] += it->capacity;\n      cost[i][it->index] += it->cost;\n    }\n  }\n  pair<int,int> total;  // (cost, flow)\n  vector<int> h(N, 0);\n  for (int f = total_flow; f > 0; ) {\n    vector<int> dist(N, 1000000);\n    dist[source] = 0;\n    vector<int> parent(N, -1);\n    priority_queue<pair<int,int> > q;\n    q.push(make_pair(0, source));\n    while (!q.empty()) {\n      const int n = q.top().second;\n      const int c = -q.top().first;\n      q.pop();\n      for (vector<Edge>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n        if (capacity[n][it->index] - flow[n][it->index] > 0) {\n          const int c2 = c + cost[n][it->index] + h[n] - h[it->index];\n          if (c2 < dist[it->index]) {\n            dist[it->index] = c2;\n            parent[it->index] = n;\n            q.push(make_pair(-c2, it->index));\n          }\n        }\n      }\n    }\n    if (parent[sink] == -1) {\n      break;\n    }\n\n    int e = f;\n    for (int i = sink; i != source; i = parent[i]) {\n      e = min(e, capacity[parent[i]][i] - flow[parent[i]][i]);\n    }\n    for (int i = sink; i != source; i = parent[i]) {\n      total.first += e * cost[parent[i]][i];\n      flow[parent[i]][i] += e;\n      flow[i][parent[i]] -= e;\n    }\n    f -= e;\n    total.second += e;\n    for (int i = 0; i < N; i++) {\n      h[i] += dist[i];\n    }\n  }\n  return total;\n}/*}}}*/\n\nint write_cost[128][128];\nint erase_cost[128][128];\nchar field[128][128];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            cin >> write_cost[i][j];\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            cin >> erase_cost[i][j];\n        }\n    }\n    for(int i = 0; i < N; ++i) {\n        cin >> &field[i][0];\n    }\n\n    // 0..N-1: Row\n    // N..2N-1: Col\n    // 2N: Source\n    // 2N+1: Sink\n    vector<vector<Edge> > graph(2*N+2);\n    for(int r = 0; r < N; ++r) {\n        int sum = 0;\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o') sum += erase_cost[r][c];\n        }\n        for(int c = 0; c < N; ++c) {\n            int cost = sum;\n            if(field[r][c] == 'o') cost -= erase_cost[r][c];\n            else cost += write_cost[r][c];\n            graph[r].push_back(Edge(N+c, 1, cost));\n        }\n    }\n    for(int r = 0; r < N; ++r) {\n        graph[2*N].push_back(Edge(r, 1, 0));\n    }\n    for(int c = 0; c < N; ++c) {\n        graph[N+c].push_back(Edge(2*N+1, 1, 0));\n    }\n    vector<vector<int> > flow;\n    pair<int,int> result = primal_dual(graph, 2*N, 2*N+1, N, flow);\n    vector<Command> commands;\n    for(int r = 0; r < N; ++r) {\n        for(int c = 0; c < N; ++c) {\n            if(field[r][c] == 'o' && flow[r][N+c] == 0)\n                commands.push_back(Command(r+1, c+1, \"erase\"));\n            else if(field[r][c] == '.' && flow[r][N+c] > 0)\n                commands.push_back(Command(r+1, c+1, \"write\"));\n        }\n    }\n    cout << result.first << endl;\n    cout << commands.size() << endl;\n    for(vector<Command>::const_iterator it = commands.begin(); it != commands.end(); ++it) {\n        cout << it->r << ' ' << it->c << ' ' << it->cmd << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P; //cap,cost\ntypedef tuple<int,int,string> T;//R,C,w/e\nmap<int,P> G[100*100+200+2];\n\nint main(){\n    int n;\n    cin>>n;\n    int W[n][n];\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++) cin>>W[i][j];\n    int E[n][n];\n    for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++) cin>>E[i][j];\n    vector<string> F(n),ANS(n,string(n,'.'));\n    for(auto &f:F) cin>>f;\n    int C[n][n];\n    int mincost = 0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(F[i][j]=='o'){\n                C[i][j]=-E[i][j];\n                mincost+=E[i][j];\n            }else{\n                C[i][j]=W[i][j];\n            }\n        }\n    }\n    int row[n],col[n];\n    for(int i=0;i<n;i++){\n        row[i]=n*n+i;\n        col[i]=n*n+n+i;\n    }\n    int s=n*n+2*n, t=n*n+2*n+1;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            G[row[i]][i*n+j]=P(1,C[i][j]);\n            G[i*n+j][row[i]]=P(0,-C[i][j]);\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            G[i*n+j][col[j]]=P(1,0);\n            G[col[j]][i*n+j]=P(0,0);\n        }\n    }\n    for(int i=0;i<n;i++){\n        G[s][row[i]]=P(1,0);\n        G[row[i]][s]=P(0,0);\n\n    }\n    for(int j=0;j<n;j++){\n        G[col[j]][t]=P(1,0);\n        G[t][col[j]]=P(0,0);\n    }\n    int V=n*n+2*n+2;\n    int dist[V],prev[V];\n    for(int f=0;f<n;f++){\n        fill(dist,dist+V,10000000);\n        fill(prev,prev+V,-1);\n        dist[s]=0;\n        bool update=true;\n        while(update){\n            update=false;\n            for(int v=0;v<V;v++){\n                if(dist[v]==10000000) continue;\n                for(auto e:G[v]){\n                    int to,cap,cost;\n                    to=e.first;\n                    tie(cap,cost)=e.second;\n                    if(!cap) continue;\n                    if(dist[to]>dist[v]+cost){\n                        dist[to]=dist[v]+cost;\n                        prev[to]=v;\n                        update=true;\n                    }\n                }\n            }\n        }\n        mincost+=dist[t];\n        for(int v=t;v!=s;v=prev[v]){\n            G[prev[v]][v].first=0;\n            G[v][prev[v]].first=1;\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(!G[row[i]][i*n+j].first){\n                ANS[i][j]='o';\n            }\n        }\n    }\n    // for(int i=0;i<n;i++)cout<<F[i]<<endl;\n    // cout<<endl;\n    // for(int i=0;i<n;i++)cout<<ANS[i]<<endl;\n    // cout<<endl;\n    vector<T> O;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(F[i][j]=='o'&&ANS[i][j]=='.'){\n                O.emplace_back(i,j,\"erase\");\n            }\n            if(F[i][j]=='.'&&ANS[i][j]=='o'){\n                O.emplace_back(i,j,\"write\");\n            }\n        }\n    }\n    cout<<mincost<<endl;\n    cout<<O.size()<<endl;\n    for(auto o:O){\n        int r,c;\n        string we;\n        tie(r,c,we)=o;\n        cout<<r+1<<' '<<c+1<<' '<<we<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,flow,cap,cost;\n\tEdge(){}\n\tEdge(int s,int d,int f,int ca,int co):src(s),dst(d),flow(f),cap(ca),cost(co){}\n};\ntypedef vector<vector<Edge>> Graph;\n\npair<int,vector<Edge>> MinCostFlow(const Graph& _g,int tap,int sink,int flow)\n{\n\tint n=_g.size();\n\tGraph g(n);\n\tvvi rev(n);\n\trep(i,n) for(auto e:_g[i]){\n\t\tg[i].push_back(e);\n\t\tg[e.dst].emplace_back(e.dst,e.src,0,0,-e.cost);\n\t\trev[i].push_back(g[e.dst].size()-1);\n\t\trev[e.dst].push_back(g[i].size()-1);\n\t}\n\t\n\tint res=0;\n\tvi pots(n);\n\twhile(flow){\n\t\tvi dist(n,INF);\n\t\tvector<pii> prev(n,mp(-1,-1));\n\t\tpriority_queue<pii,vector<pii>,greater<pii>> pq;\n\t\tpq.emplace(0,tap);\n\t\tdist[tap]=0;\n\t\twhile(pq.size()){\n\t\t\tint d,u; tie(d,u)=pq.top(); pq.pop();\n\t\t\tif(dist[u]<d) continue;\n\t\t\trep(i,g[u].size()){\n\t\t\t\tEdge e=g[u][i];\n\t\t\t\tif(e.cap-e.flow==0) continue;\n\t\t\t\tint nd=dist[e.src]+e.cost+pots[e.src]-pots[e.dst];\n\t\t\t\tif(dist[e.dst]>nd){\n\t\t\t\t\tdist[e.dst]=nd;\n\t\t\t\t\tprev[e.dst]=mp(e.src,i);\n\t\t\t\t\tpq.emplace(nd,e.dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(prev[sink].first==-1) return mp(INF,vector<Edge>());\n\t\trep(i,n) pots[i]+=dist[i];\n\t\t\n\t\tint aug=flow;\n\t\tfor(int v=sink;v!=tap;v=prev[v].first){\n\t\t\tEdge e=g[prev[v].first][prev[v].second];\n\t\t\taug=min(aug,e.cap-e.flow);\n\t\t}\n\t\tfor(int v=sink;v!=tap;v=prev[v].first){\n\t\t\tint i=prev[v].first,j=prev[v].second;\n\t\t\tg[i][j].flow+=aug;\n\t\t\tg[g[i][j].dst][rev[i][j]].flow-=aug;\n\t\t}\n\t\tflow-=aug;\n\t\tres+=aug*pots[sink];\n\t}\n\tvector<Edge> es;\n\trep(i,n) for(auto e:g[i]) es.push_back(e);\n\treturn mp(res,es);\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvvi wcost(n,vi(n)),ecost(n,vi(n));\n\t\trep(i,n) rep(j,n) cin>>wcost[i][j];\n\t\trep(i,n) rep(j,n) cin>>ecost[i][j];\n\t\tvs grid(n);\n\t\trep(i,n) cin>>grid[i];\n\t\t\n\t\tint sum=0;\n\t\tGraph g(n+n+2);\n\t\trep(i,n) rep(j,n){\n\t\t\tif(grid[i][j]=='o'){\n\t\t\t\tsum+=ecost[i][j];\n\t\t\t\tg[i].emplace_back(i,n+j,0,1,-ecost[i][j]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg[i].emplace_back(i,n+j,0,1,wcost[i][j]);\n\t\t\t}\n\t\t}\n\t\tint tap=n+n,sink=tap+1;\n\t\trep(i,n){\n\t\t\tg[tap].emplace_back(tap,i,0,1,0);\n\t\t\tg[n+i].emplace_back(n+i,sink,0,1,0);\n\t\t}\n\t\t\n\t\tint res; vector<Edge> es;\n\t\ttie(res,es)=MinCostFlow(g,tap,sink,n);\n\t\t\n\t\tvs last(n,string(n,'.'));\n\t\tfor(auto e:es) if(e.src!=tap && e.dst!=sink && e.flow>0)\n\t\t\tlast[e.src][e.dst-n]='o';\n\t\t\n\t\tint cnt=0;\n\t\trep(i,n) rep(j,n) cnt+=grid[i][j]!=last[i][j];\n\t\t\n\t\tcout<<sum+res<<'\\n'<<cnt<<'\\n';\n\t\trep(i,n) rep(j,n){\n\t\t\tif(grid[i][j]=='o' && last[i][j]=='.')\n\t\t\t\tcout<<i+1<<' '<<j+1<<\" erase\"<<endl;\n\t\t\tif(grid[i][j]=='.' && last[i][j]=='o')\n\t\t\t\tcout<<i+1<<' '<<j+1<<\" write\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\ntypedef long long  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\nconst int V = 4000;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nWeight h[V];                //??????????????£???\nWeight dist[V];             //???????????¢\nint prevv[V], preve[V];  //??´???????????¨??????\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst Weight INF = 2147483647;\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n\tWeight res = 0;\n\tmemset(h, 0, sizeof(h));\n\ttypedef pair<Weight, int> P;\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest]) {\n\t\t\t\t\tdist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\tque.push(P(dist[e.dest], e.dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tREP(v, V) h[v] =h[v]+ dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres = res+d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nstruct ope {\n\tint x;\n\tint y;\n\tbool write;\n};\n\nint main() {\n\tint N; cin >> N;\n\tvector<vector<int>>ws(N, vector<int>(N)), ds(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> ws[i][j];\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> ds[i][j];\n\t\t}\n\t}\n\tvector<vector<int>>field(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tfield[i][j] = st[j] == 'o';\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int l = start+1;\n\tconst int u = l + N;\n\tconst int goal = u + N;\n\tGraph g(goal + 1);\n\tfor (int i = 0; i <N; ++i) {\n\t\tadd_edge(g, start, l + i, 1, 0);\n\t}\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tint cost = 0;\n\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\tif (j == k) {\n\t\t\t\t\tif (!field[i][k])cost += ws[i][k];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[i][k])cost += ds[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd_edge(g, l + i, u + j, 1, cost);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tadd_edge(g, u + i, goal, 1, 0);\n\t}\n\tvector<ope>opes;\n\tint ans = min_cost_flow(g, start, goal,N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (auto e : g[l + i]) {\n\t\t\tif (e.dest) {\n\t\t\t\tint x = e.dest - u;\n\n\t\t\t\t//???\n\t\t\t\tif (e.cap == 0) {\n\t\t\t\t\tif (!field[i][x]) {\n\t\t\t\t\t\topes.push_back(ope{ x,i,true });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (field[i][x]) {\n\t\t\t\t\t\topes.push_back(ope{ x,i,false });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcout << opes.size() << endl;\n\tfor (auto o : opes) {\n\t\tcout << o.y + 1 << \" \" << o.x+ 1 << \" \";\n\t\tif (o.write)cout << \"write\" << endl;\n\t\telse cout << \"erase\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>PP;\n\nstruct edge{\n    int to,cap,cost,rev; //?????????,??????,?????¨,??????\n};\n\nconst int MAX_N = 102;\nconst int MAX_V = 205;\n\nint n;\nint W[MAX_N][MAX_N];\nint E[MAX_N][MAX_N];\nint mp[MAX_N][MAX_N];\nvector<edge> G[MAX_V];\nint memo[MAX_V][MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(const int vcnt,const int s,const int t,int f)\n{\n\tint res =0;\n\tint dist[MAX_V];\n\tint prevv[MAX_V];\n\tint preve[MAX_V];\n\twhile(f>0){\n\t\tfill(dist,dist+vcnt,INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v=0;v<vcnt;v++){\n\t\t\t\tif(dist[v] == INF)\tcontinue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\t//??????????????????????¨???¶\n\t\t\t\t\t\tpreve[e.to] = i;\t//????????????????¨???¶\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\n\t\tint d = f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td = min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n            memo[prevv[v]][e.to] = 1;\n\t\t\te.cap -= d;\n            memo[e.to][prevv[v]] = 0;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n    cin >> n;\n    int sm = 0;\n    rep(i,n){\n        rep(j,n){\n            cin >> W[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            cin >> E[i][j];\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            char c;\n            cin >> c;\n            if(c == 'o'){\n                mp[i][j] = 1;\n            }else{\n                mp[i][j] = 0;\n            }\n        }\n    }\n    rep(i,n){\n        rep(j,n){\n            if(mp[i][j] == 1){\n                add_edge(i+1,j+n+1,INF,-E[i][j]);\n                sm += E[i][j];\n            }else{\n                add_edge(i+1,j+n+1,INF,W[i][j]);\n            }\n        }\n    }\n    rep(i,n){\n        add_edge(0,i+1,1,0);\n        add_edge(i+n+1,2*n+1,1,0);\n    }\n    cout << sm + min_cost_flow(2*n+2,0,2*n+1,n) << \"\\n\";\n    vector<PP> ans;\n    rep(i,n){\n        rep(j,n){\n            if(mp[i][j] == 1 && memo[i+1][j+n+1] != 1){\n                ans.pb(PP(P(i+1,j+1),0));\n            }else if(mp[i][j] == 0 && memo[i+1][j+n+1] == 1){\n                ans.pb(PP(P(i+1,j+1),1));\n            }\n        }\n    }\n    cout << ans.size() << \"\\n\";\n    rep(i,ans.size()){\n        if(ans[i].se == 0){\n            cout << (ans[i].fi).fi << \" \" << (ans[i].fi).se << \" erase\\n\";\n        }else{\n            cout << (ans[i].fi).fi << \" \" << (ans[i].fi).se << \" write\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n\nconst int MAX_V = 500;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tCost h[MAX_V], dist[MAX_V];\n\tint prevv[MAX_V], preve[MAX_V];\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // テヲツ慊嘉・ツ青妥ィツセツコ\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t テゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// テヲツオツ?」ツつ古」ツ?淌」ツδ陛」ツδュテ」ツδシ=テ・ツ?ε」ツ??」ツ?ョテ・ツョツケテゥツ??テァツ渉セテ・ツ慊ィテ」ツ?ョテ・ツョツケテゥツ?湘」ツつ津ィツ。ツィテァツ、ツコ\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint n;\nint W[100][100];\nint E[100][100];\nchar F[100][100];\nchar R[100][100];\n\nstruct Command {\n\tint i, j;\n\tstring s;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcin >> W[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcin >> E[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tcin >> F[i][j];\n\t\t\t}\n\t\t}\n\n\t\tPrimalDual pd(2 * n + 2);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tif(F[i][j] == '.') sum += W[i][j];\n\t\t\t\tfor(int k = 0; k < n; k++) {\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tif(F[i][k] == 'o') sum += E[i][k];\n\t\t\t\t}\n\t\t\t\tpd.add_edge(i, n + j, 1, sum);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpd.add_edge(2 * n, i, 1, 0);\n\t\t\tpd.add_edge(n + i, 2 * n + 1, 1, 0);\n\t\t}\n\n\t\tint res = pd.solve(2 * n, 2 * n + 1, n);\n\t\tcout << res << endl;\n\t\t//pd.view();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tR[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < pd.g.size(); i++) {\n\t\t\tfor(int j = 0; j < pd.g[i].size(); j++) {\n\t\t\t\tif(!pd.g[i][j].isRev) {\n\t\t\t\t\tEdge& e = pd.g[i][j];\n\t\t\t\t\tif(e.cap_orig - e.cap == 1) {\n\t\t\t\t\t\tR[i][e.dst - n] = 'o';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\tcout << R[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t}*/\n\n\t\tvector<Command> v;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(F[i][j] != R[i][j]) {\n\t\t\t\t\tif(F[i][j] == '.') v.push_back(Command{ i + 1, j + 1, \"write\" });\n\t\t\t\t\telse v.push_back(Command{ i + 1, j + 1, \"erase\" });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << v.size() << endl;\n\t\tfor(Command c : v) {\n\t\t\tcout << c.i << \" \" << c.j << \" \" << c.s << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<typename T>\nstruct Min_Cost_Flow{\n    struct edge{\n        int to; T cap, cost; int rev;\n        edge(int to, T cap, T cost, int rev) : to(to), cap(cap), cost(cost), rev(rev) {} \n    };\n\n    vector<vector<edge>> es;\n    vector<T> d;\n    vector<int> pre_v, pre_e;\n    const T INF_T;\n\n    Min_Cost_Flow(int n) : INF_T(numeric_limits<T>::max()){\n        es.resize(n), d.resize(n), pre_v.resize(n), pre_e.resize(n);\n    }\n\n    int add_edge(int from, int to, T cap, T cost){\n        es[from].eb(to, cap, cost, sz(es[to]));\n        es[to].eb(from, 0, -cost, sz(es[from])-1);\n        return sz(es[from])-1;\n    }\n\n    void bellman_ford(int s){\n        fill(all(d), INF_T);\n        d[s] = 0;\n        while(true){\n            bool update = false;\n            rep(i, sz(es)){\n                if(d[i] == INF_T) continue;\n                rep(j, sz(es[i])){\n                    edge &e = es[i][j];\n                    if(e.cap > 0 && chmin(d[e.to], d[i]+e.cost)){\n                        pre_v[e.to] = i, pre_e[e.to] = j;\n                        update = true;\n                    }\n                }\n            }\n            if(!update) break;\n        }\n    }\n\n    T min_cost_flow(int s, int t, T flow){\n        T ret = 0;\n        while(flow > 0){\n            bellman_ford(s);\n            if(d[t] == INF_T) return ret;\n            T f = flow;\n            for(int now = t; now != s; now = pre_v[now]){\n                chmin(f, es[pre_v[now]][pre_e[now]].cap);\n            }\n            ret += f*d[t], flow -= f;\n            for(int now = t; now != s; now = pre_v[now]){\n                edge &e = es[pre_v[now]][pre_e[now]];\n                e.cap -= f, es[now][e.rev].cap += f;\n            }\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    int W[N][N], E[N][N];\n    rep(i, N){\n        rep(j, N) cin >> W[i][j];\n    }\n    rep(i, N){\n        rep(j, N) cin >> E[i][j];\n    }\n    string S[N];\n    rep(i, N) cin >> S[i];\n    Min_Cost_Flow<int> G(2*N+2);\n    int s = 2*N, t = 2*N+1;\n    int ans = 0;\n    rep(i, N) G.add_edge(s, i, 1, 0);\n    rep(i, N) G.add_edge(N+i, t, 1, 0);\n    int id[N][N];\n    rep(i, N){\n        rep(j, N){\n            if(S[i][j] == '.'){\n                id[i][j] = G.add_edge(i, N+j, 1, W[i][j]);\n            }\n            else{\n                ans += E[i][j];\n                id[i][j] = G.add_edge(i, N+j, 1, -E[i][j]);\n            }\n        }\n    }\n    ans += G.min_cost_flow(s, t, N);\n    cout << ans << endl;\n    vector<pii> used;\n    rep(i, N){\n        rep(j, N){\n            if((S[i][j] == '.') ^ (G.es[i][id[i][j]].cap > 0)) used.eb(i, j);\n        }\n    }\n    cout << sz(used) << endl;\n    for(auto &e: used){\n        int i, j;\n        tie(i, j) = e;\n        cout << i+1 << ' ' << j+1 << ' ' << (S[i][j] == '.'? \"write\" : \"erase\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n\nclass Hungarian {\n\npublic:\n\n    vector<int> x;\n    int hungarian(const vector<vector<int>> &a) {\n        int n = a.size(), p, q;\n\n        vector<int> fx(n, INF), fy(n, 0);\n        vector<int> y(n, -1);\n        x.resize(n, -1);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                fx[i] = max(fx[i], a[i][j]);\n            }\n        }\n\n        for (int i = 0; i < n;) {\n            vector<int> t(n, -1), s(n + 1, i);\n            for (p = q = 0; p <= q && x[i] < 0; ++p) {\n                for (int k = s[p], j = 0; j < n && x[i] < 0; ++j) {\n                    if (fx[k] + fy[j] == a[k][j] && t[j] < 0) {\n                        s[++q] = y[j], t[j] = k;\n                        if (s[q] < 0) {\n                            for (p = j; p >= 0; j = p) {\n                                y[j] = k = t[j], p = x[k], x[k] = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if (x[i] < 0) {\n                int d = INF;\n                for (int k = 0; k <= q; ++k) {\n                    for (int j = 0; j < n; ++j) {\n                        if (t[j] < 0) {\n                            d = min(d, fx[s[k]] + fy[j] - a[s[k]][j]);\n                        }\n                    }\n                }\n                for (int j = 0; j < n; ++j) {\n                    fy[j] += (t[j] < 0 ? 0 : d);\n                }\n                for (int k = 0; k <= q; ++k) {\n                    fx[s[k]] -= d;\n                }\n            } else {\n                ++i;\n            }\n        }\n\n        int ret = 0;\n        for (int i = 0; i < n; ++i) {\n            ret += a[i][x[i]];\n        }\n        return ret;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    VV<int> add(N, V<int>(N)), del(N, V<int>(N)), field(N, V<int>(N));\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            cin >> add[i][j];\n        }\n    }\n    FOR(i, 0, N) {\n        FOR(j, 0, N) {\n            cin >> del[i][j];\n        }\n    }\n\n    int ans = 0;\n    VV<int> cost(N, V<int>(N));\n    FOR(i, 0, N) {\n        string s;\n        cin >> s;\n        FOR(j, 0, N) {\n            field[i][j] = (s[j] == 'o') ? 1 : 0;\n\n            // 全部消す\n            if (field[i][j] == 1) {\n                ans -= del[i][j];\n                cost[i][j] += del[i][j];\n            }\n            else {\n                cost[i][j] = -add[i][j];\n            }\n        }\n    }\n\n    Hungarian hg;\n    print(-(ans + hg.hungarian(cost)));\n\n    VV<int> field2(N, V<int>(N, 0));\n    V<string> a;\n    FOR(y, 0, N) {\n        FOR(x, 0, N) {\n            bool m = (hg.x[y] == x);\n            if (m and field[y][x] == 1 or not m and field[y][x] == 0) { continue; }\n\n            if (field[y][x] == 1) {\n                a.emplace_back(to_string(y + 1) + \" \" + to_string(x + 1) + \" erase\");\n            }\n            else {\n                a.emplace_back(to_string(y + 1) + \" \" + to_string(x + 1) + \" write\");\n            }\n        }\n    }\n\n    print(a.size());\n    FOE(s, a) {\n        print(s);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n/*----------------------------------------------*/\n/**\n *  mod による操作ライブラリ\n */\n#define ANS_MOD (1000000007)\n\nclass MODINT {\n    static SQWORD MOD;\n    SQWORD m_x;\n\npublic:\n    MODINT(SQWORD val) {\n        m_x = (val % MOD + MOD) % MOD;\n    };\n    MODINT() {\n        m_x = 0;\n    }\n    static void Init(SQWORD sqMod) {\n        MOD = sqMod;\n    }\n\n\tMODINT& operator+= (const MODINT a)\n    {\n        m_x = (m_x + a.m_x) % MOD; \n        return *this;\n    };\n\tMODINT& operator-= (const MODINT a)\n    { \n        m_x = (m_x - a.m_x + MOD) % MOD; \n        return *this;\n    };\n\tMODINT& operator*= (const MODINT a)\n    {\n        m_x = (m_x * a.m_x) % MOD;\n        return *this;\n    };\n    MODINT pow(SQWORD t) const {\n        if (!t) return 1;\n        MODINT a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\tMODINT operator+ (const MODINT a) const {\n\t\tMODINT res(*this);\n\t\treturn (res += a);\n\t}\n\tMODINT operator- (const MODINT a) const {\n\t\tMODINT res(*this);\n\t\treturn (res -= a);\n\t}\n\tMODINT operator* (const MODINT a) const {\n\t\tMODINT res(*this);\n\t\treturn (res *= a);\n\t}\n\tMODINT operator/ (const MODINT a) const {\n\t\tMODINT res(*this);\n\t\treturn (res /= a);\n\t}\n\n    /* 逆元 */\n    MODINT inv() const {\n        return pow(MOD-2);\n    }\n\n    /* 除算 */\n    MODINT& operator/=(const MODINT a) {\n        return (*this) *= a.inv();\n    } \n\n    /* 整数版 */\n\tMODINT& operator+= (const SQWORD a) {*this += MODINT(a); return *this;};\n\tMODINT& operator-= (const SQWORD a) {*this -= MODINT(a); return *this;};\n\tMODINT& operator*= (const SQWORD a) {*this *= MODINT(a); return *this;};\n\tMODINT& operator/= (const SQWORD a) {*this /= MODINT(a); return *this;};\n\n    SQWORD getVal() { return m_x; };\n};\nSQWORD MODINT::MOD = ANS_MOD;\n\n\n/*----------------------------------------------*/\n\nstruct ST_EDGE {\n    SDWORD lTo;\n    SQWORD sqCap;\n    SQWORD sqMaxCap;\n    SQWORD sqCost;\n    SDWORD lRev;\n    bool bIsFwd;\n\n    ST_EDGE(SDWORD to, SQWORD cap, SQWORD cost, SDWORD rev, bool bFwd)\n    {\n        lTo = to;\n        sqCap = cap;\n        sqMaxCap = cap;\n        sqCost = cost;\n        lRev = rev;\n        bIsFwd = bFwd;\n    };\n};\n\n#define MAX_V   (20002)\n\nstruct Flow {\nprivate:\n    vector<ST_EDGE> avGraph[MAX_V];\n    SQWORD  sqEdgeNum;\n    SQWORD  asqDist[MAX_V];\n    SDWORD  alPrevV[MAX_V];   \n    SDWORD  alPrevEdge[MAX_V];      /*直前の頂点と辺 */\n\n    SDWORD  alDinic_Level[MAX_V];\n    SDWORD  alDinic_Iter[MAX_V];\n\npublic:\n    void addEdge(SDWORD lFrom, SDWORD lTo, SQWORD sqCap, SQWORD sqCost) {\n//        printf(\"%d ----[%lld] ----> %d\\n\", lFrom, sqCap, lTo);\n\n        avGraph[lFrom].emplace_back(lTo, sqCap, sqCost, (SDWORD)(avGraph[lTo].size()), true);\n        avGraph[lTo].emplace_back(lFrom, 0, -sqCost, (SDWORD)(avGraph[lFrom].size() - 1), false);\n    }\n\n    SDWORD minCostFlow(SDWORD lStart, SDWORD lTarget, SQWORD sqFlow)\n    {\n        SQWORD sqRes = 0;\n        SQWORD sqFlowRest = sqFlow;\n        while (0 < sqFlowRest) {\n            /* Bellman-Ford Method */\n            fill(asqDist, asqDist + ArrayLength(asqDist), MAX_SDWORD);\n            asqDist[lStart] = 0;\n            bool bIsUpdate = true;\n            while (bIsUpdate) {\n                bIsUpdate = false;\n                for (SDWORD lV = 0; lV < MAX_V; lV++) {\n                    for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                        ST_EDGE &stE = avGraph[lV][lIdx];\n                        if ((asqDist[lV] != MAX_SDWORD)\n                                && (0 < stE.sqCap)\n                                && (asqDist[lV] + stE.sqCost < asqDist[stE.lTo])) {\n                            asqDist[stE.lTo] = asqDist[lV] + stE.sqCost;\n                            alPrevV[stE.lTo] = lV;\n                            alPrevEdge[stE.lTo] = lIdx;\n                            bIsUpdate = true;\n                        }\n                    }\n                }\n            }\n            if (asqDist[lTarget] == MAX_SDWORD) {\n                return -1;\n            }\n\n            SQWORD sqAddFlow = MAX_SQWORD;\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                sqAddFlow = min(sqAddFlow, avGraph[alPrevV[lV]][alPrevEdge[lV]].sqCap);\n            }\n            sqFlowRest -= sqAddFlow;\n            sqRes += sqAddFlow * asqDist[lTarget];      // 後で目的変数は書き換える\n            for (SDWORD lV = lTarget; lV != lStart; lV = alPrevV[lV]) {\n                ST_EDGE &stE = avGraph[alPrevV[lV]][alPrevEdge[lV]];\n                stE.sqCap -= sqAddFlow;\n                avGraph[lV][stE.lRev].sqCap += sqAddFlow;\n            }\n        }\n        return sqRes;\n    }\n\nprivate:\n    SQWORD maxFlowDinicBfs(SDWORD lS)\n    {\n        memset(alDinic_Level, -1, sizeof(alDinic_Level));\n        queue<SDWORD> queSearch;\n        alDinic_Level[lS] = 0;\n        queSearch.push(lS);\n        while (!queSearch.empty()) {\n            SDWORD lV = queSearch.front();\n            queSearch.pop();\n            for (SDWORD lIdx = 0; lIdx < avGraph[lV].size(); lIdx++) {\n                ST_EDGE &stE = avGraph[lV][lIdx];\n                if ((0 < stE.sqCap) && (alDinic_Level[stE.lTo] < 0)) {\n                    alDinic_Level[stE.lTo] = alDinic_Level[lV] + 1;\n                    queSearch.push(stE.lTo);\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    SQWORD maxFlowDinicDfs(SDWORD lV, SDWORD lT, SQWORD sqF)\n    {\n        if (lV == lT) {\n            return sqF;\n        }\n        for (SDWORD &lI = alDinic_Iter[lV]; lI < avGraph[lV].size(); lI++) {\n            ST_EDGE &stE = avGraph[lV][lI];\n            if ((0 < stE.sqCap) && (alDinic_Level[lV] < alDinic_Level[stE.lTo])) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(stE.lTo, lT, min(sqF, stE.sqCap));\n                if (0 < sqDiffFlow) {\n                    stE.sqCap -= sqDiffFlow;\n                    avGraph[stE.lTo][stE.lRev].sqCap += sqDiffFlow;\n                    return sqDiffFlow;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    SQWORD MaxFlow(SDWORD lStart, SDWORD lTarget)\n    {\n        SQWORD sqFlow = 0LL;\n        for (;;) {\n            maxFlowDinicBfs(lStart);\n            if (alDinic_Level[lTarget] < 0) {\n                return sqFlow;\n            }\n            memset(alDinic_Iter, 0, sizeof(alDinic_Iter));\n            while (1) {\n                SQWORD sqDiffFlow = maxFlowDinicDfs(lStart, lTarget, MAX_SQWORD);\n                sqFlow += sqDiffFlow;\n                if (0LL == sqDiffFlow) {\n                    break;\n                }\n            }\n        }\n    }\n\n    SQWORD GetNodeFlow(SDWORD lNode)\n    {\n        SQWORD sqFlow = 0;\n        for (auto e: avGraph[lNode]) {\n            if (e.bIsFwd) {\n                sqFlow += (e.sqMaxCap - e.sqCap);\n            }\n        }\n        return sqFlow;\n    }\n};\n\n/*----------------------------------------------*/\n\n#define PNT_NO_START    (10200)\n#define PNT_NO_TARGET   (10201)\n#define PNT_NO_OFS_ROW  (10000)\n#define PNT_NO_OFS_COL  (10100)\n#define MAX_N           (100)\n\nint main(void)\n{\n    SQWORD sqN = inputSQWORD();\n\n    Flow solverFlow;\n\n    SQWORD s_aasqW[MAX_N][MAX_N];\n    SQWORD s_aasqE[MAX_N][MAX_N];\n    bool s_aabOrgState[MAX_N][MAX_N];\n\n    for (SQWORD sqRowIdx = 0; sqRowIdx < sqN; sqRowIdx++) {\n        for (SQWORD sqColIdx = 0; sqColIdx < sqN; sqColIdx++) {\n            SQWORD sqW = inputSQWORD();\n            s_aasqW[sqRowIdx][sqColIdx] = sqW;\n        }\n    }\n    for (SQWORD sqRowIdx = 0; sqRowIdx < sqN; sqRowIdx++) {\n        for (SQWORD sqColIdx = 0; sqColIdx < sqN; sqColIdx++) {\n            SQWORD sqE = inputSQWORD();\n            s_aasqE[sqRowIdx][sqColIdx] = sqE;\n        }\n    }\n\n    /* \n    *   (N) ----->  10000 <row0> -----> [0, 0] ---->    10100 <col0>     -----> (N)\n    *               10001 <row1>        [0, 1]          10101 <col1>\n    *               10002 <row2>        [0, 2]          10102 <col2>\n    *               10003 <row3>        [0, 3]          10103 <col3>\n    *                                   [1, 0]\n    *                                   [1, 1]\n    */\n\n    for (SQWORD sqRowIdx = 0; sqRowIdx < sqN; sqRowIdx++) {\n        string str;\n        cin >> str;\n        for (SQWORD sqRestCol = 0; sqRestCol < sqN; sqRestCol++) {\n            if ('o' == str[sqRestCol]) {\n                s_aabOrgState[sqRowIdx][sqRestCol] = true;\n            } else {\n                s_aabOrgState[sqRowIdx][sqRestCol] = false;\n            }\n\n            /* col番目だけを o にするコストを求める */\n            SQWORD sqCost = 0;\n            for (SQWORD sqColCur = 0; sqColCur < sqN; sqColCur++) {\n                if (sqRestCol == sqColCur) {\n                    if ('.' == str[sqColCur]) {\n                        sqCost += s_aasqW[sqRowIdx][sqColCur];\n                    }\n                } else {\n                    if ('o' == str[sqColCur]) {\n                        sqCost += s_aasqE[sqRowIdx][sqColCur];\n                    }\n                }\n            }\n            SQWORD sqPntNoCell = sqRowIdx * sqN + sqRestCol;\n            solverFlow.addEdge(PNT_NO_OFS_ROW + sqRowIdx, sqPntNoCell,                1, sqCost);\n            solverFlow.addEdge(sqPntNoCell,               PNT_NO_OFS_COL + sqRestCol, 1, 0);\n        }\n    }\n    for (SQWORD sqRow = 0; sqRow < sqN; sqRow++) {\n        solverFlow.addEdge(PNT_NO_START, PNT_NO_OFS_ROW + sqRow, 1, 0);\n    }\n    for (SQWORD sqCol = 0; sqCol < sqN; sqCol++) {\n        solverFlow.addEdge(PNT_NO_OFS_COL + sqCol, PNT_NO_TARGET, 1, 0);\n    }\n\n    SQWORD sqMinCost = solverFlow.minCostFlow(PNT_NO_START, PNT_NO_TARGET, sqN);\n\n    /* minimum cost */\n    printf(\"%lld\\n\", sqMinCost);\n\n    vector<pair<SQWORD, SQWORD>> vecErasePair;\n    vector<pair<SQWORD, SQWORD>> vecWritePair;\n\n    for (SQWORD sqRowIdx = 0; sqRowIdx < sqN; sqRowIdx++) {\n        for (SQWORD sqColIdx = 0; sqColIdx < sqN; sqColIdx++) {\n            SQWORD sqPntNoCell = sqRowIdx * sqN + sqColIdx;\n            SQWORD sqNodeFlow = solverFlow.GetNodeFlow(sqPntNoCell);\n\n            if (0 == sqNodeFlow) {\n                if (s_aabOrgState[sqRowIdx][sqColIdx]) {\n                    vecErasePair.emplace_back(make_pair(sqRowIdx + 1, sqColIdx + 1));\n                }\n            } else {\n                if (!(s_aabOrgState[sqRowIdx][sqColIdx])) {\n                    vecWritePair.emplace_back(make_pair(sqRowIdx + 1, sqColIdx + 1));\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", vecErasePair.size() + vecWritePair.size());\n    for (auto e: vecErasePair) {\n        printf(\"%lld %lld erase\\n\", e.first, e.second);\n    }\n    for (auto w: vecWritePair) {\n        printf(\"%lld %lld write\\n\", w.first, w.second);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nconst int INF = (1<<28);\n\nclass Edge\n{\npublic:\n\tint src,dst,cst,cap,rev;\n\tEdge(int src, int dst, int cst, int cap, int rev)\n\t\t:src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n\tgraph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n\tgraph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n\npair<int, int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n  int V = graph.size();\n  vector<int> dist(V), prevv(V), preve(V);\n\n  int res = 0, fw = 0;\n  while(1) {\n    fill(dist.begin(), dist.end(), INF);\n    dist[S] = 0;\n    bool update = true;\n\n    while(update) {\n      update = false;\n      for(int v = 0; v < V; v++) {\n        if(dist[v] == INF) continue;\n\n        for(int i=0; i<graph[v].size(); i++) {\n          Edge& e = graph[v][i];\n          int cost = e.cst;\n          if(graph[e.dst][e.rev].cap != 0) cost = 0;\n\n          if(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n            dist[e.dst] = dist[e.src] + cost;\n            prevv[e.dst] = e.src;\n            preve[e.dst] = i;\n            update = true;\n          }\n        }\n      }\n    }\n\n    if(dist[T] == INF) break;\n\n    int f = INF;\n    for(int v = T; v != S; v = prevv[v])\n      f = min(f, graph[prevv[v]][preve[v]].cap);\n\n    res += dist[T];\n    fw += f;\n\n    for(int v = T; v != S; v = prevv[v]) {\n      Edge& e = graph[prevv[v]][preve[v]];\n      e.cap -= f;\n      graph[v][e.rev].cap += f;\n    }\n\n\tif(fw >= L) break;\n  }\n\n  return make_pair(res, fw);\n}\n\nint ecst[100][100], icst[100][100];\nint main()\n{\n\tint N;\n\tcin >> N;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> ecst[j][i];\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> icst[j][i];\n\n\tstring field[100];\n\tfor(int i=0; i<N; i++)\n\t\tcin >> field[i];\n\n\n\tint res = 0;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tif(field[i][j] == 'o') {\n\t\t\tres += ecst[j][i];\n\t\t}\n\t}\n\n\n\tGraph graph(N*N+2);\n\tfor(int i=0; i<N; i++) {\n\t\taddEdge(N*N, i, 1, 0, graph);\n\t\taddEdge(N+i, N*N+1, 1, 0, graph);\n\t}\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tint cst;\n\t\tif(field[i][j] == 'o') cst = -ecst[j][i];\n\t\telse cst = icst[j][i];\n\n\t\taddEdge(j, i+N, 1, cst, graph);\n\t}\n\n\tpair<int, int> fw = minimumCostFlow(N*N, N*N+1, N, graph);\n\n\n\tint ans = res + fw.first;\n\tcout << ans << endl;\n\n\tint c = 0;\n\tstringstream ss;\n\tfor(int i=0; i<N; i++) {\n\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\tEdge& e = graph[i][j];\n\n\t\t\tif(e.dst >= N*N) continue;\n\n\t\t\tif(field[e.dst-N][e.src] == 'o' && e.cap == 1) {\n\t\t\t\tc++;\n\t\t\t\tss << e.src + 1 << \" \" << e.dst + 1 - N << \" erase\" << endl;\n\t\t\t}\n\t\t\tif(field[e.dst-N][e.src] == '.' && e.cap == 0) {\n\t\t\t\tc++;\n\t\t\t\tss << e.src + 1 << \" \" << e.dst + 1 - N << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << c << endl;\n\tcout << ss.str();\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nstruct edge{\n    int to, cost, cap, rev;\n    edge(int to, int cost, int cap, int rev)\n        :to(to),cost(cost),cap(cap),rev(rev){}\n    edge(){}\n};\n \nint min_cost_flow(int s, int g, int f, vector<vector<edge> > &adj){\n    int n = adj.size();\n    int res = 0;\n    while(f > 0){\n        vector<int> prevv(n), preve(n);\n        vector<int> mincost(n, inf);\n        mincost[s] = 0;\n        while(1){\n            bool update = false;\n            for(int i=0; i<n; i++){\n                if(mincost[i] == inf) continue;\n                for(int j=0; j<(int)adj[i].size(); j++){\n                    edge &e = adj[i][j];\n                    if(e.cap>0 && mincost[i] +e.cost < mincost[e.to]){\n                        mincost[e.to] = mincost[i] +e.cost;\n                        prevv[e.to] = i;\n                        preve[e.to] = j;\n                        update = true;\n                    }\n                }\n            }\n            if(!update) break;\n        }\n        if(mincost[g] == inf){\n            return -1;\n        }\n         \n        int d = f;\n        for(int v=g; v!=s; v=prevv[v]){\n            d = min(d, adj[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d*mincost[g];\n        for(int v=g; v!=s; v=prevv[v]){\n            edge &e = adj[prevv[v]][preve[v]];\n            e.cap -= d;\n            adj[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    int writecost[100][100], erasecost[100][100];\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            cin >> writecost[i][j];\n        }\n    }\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            cin >> erasecost[i][j];\n        }\n    }\n    vector<string> initial(n);\n    for(int i=0; i<n; i++){\n        cin >> initial[i];\n    }\n    int initialcost = 0;\n    int change[100][100] = {};\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            if(initial[i][j] == 'o'){\n                change[i][j] = 1;\n                initialcost += erasecost[i][j];\n            }\n        }\n    }\n    \n    int s=0, g=2*n+1;\n    vector<vector<edge>> adj(2*n+2);\n    for(int i=1; i<n+1; i++){\n        adj[s].emplace_back(i, 0, 1, adj[i].size());\n        adj[i].emplace_back(s, 0, 0, adj[0].size()-1);\n        adj[g].emplace_back(n+i, 0, 0, adj[n+i].size());\n        adj[n+i].emplace_back(g, 0, 1, adj[g].size()-1);\n    }\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            int cost = (change[i][j]==0)? writecost[i][j]: -erasecost[i][j];\n            int from=1+i, to=n+1+j;\n            adj[from].emplace_back(to, cost, 1, adj[to].size());\n            adj[to].emplace_back(from, -cost, 0, adj[from].size()-1);\n        }\n    }\n    \n    int ans = initialcost +min_cost_flow(0, 2*n+1, n, adj);\n    cout << ans << endl;\n    int count = 0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            if(adj[1+i][1+j].cap == 0){\n                change[i][j] = 1-change[i][j];\n            }\n            if(change[i][j] == 1){\n                count++;\n            }\n        }\n    }\n    cout << count << endl;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            if(change[i][j] == 1){\n                cout << i+1 << \" \" << j+1 << \" \";\n                if(initial[i][j] == '.') cout << \"write\" << endl;\n                else cout << \"erase\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cassert>\n#include<map>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 500\nusing namespace std;\ntypedef pair<int,int> ii;\n\n// library start\nstruct edge\n{\n  int to,cap,cost,rev;\n  edge(int to=-inf,int cap=-inf,int cost=-inf,int rev=-inf):to(to),cap(cap),cost(cost),rev(rev){}\n};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f)\n{\n  int res = 0;\n  while(f > 0)\n    {\n      rep(i,MAX_V)dist[i] = inf;\n      dist[s] = 0;\n      bool update = true;\n      while(update)\n\t{\n\t  update = false;\n\t  rep(v,V)\n\t    {\n\t      if(dist[v] == inf)continue;\n\t      rep(i,G[v].size())\n\t\t{\n\t\t  edge &e = G[v][i];\n\t\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost)\n\t\t    {\n\t\t      dist[e.to] = dist[v] + e.cost;\n\t\t      prevv[e.to] = v;\n\t\t      preve[e.to] = i;\n\t\t      update = true;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      if(dist[t] == inf)break;\n\n      int d = f;\n\n      for(int v = t;v != s;v = prevv[v])d = min(d,G[prevv[v]][preve[v]].cap);\n\n      f -= d;\n      res += d*dist[t];\n      for(int v=t;v!=s;v=prevv[v])\n\t{\n\t  edge &e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n    }\n  return res;\n}\n// library end\n\nint n;\nshort W[MAX_V][MAX_V];\nshort E[MAX_V][MAX_V];\nchar  F[MAX_V][MAX_V];\n\nint main()\n{\n  while(cin >> n)\n    {\n      rep(i,n)rep(j,n)cin >> W[i][j];\n      rep(i,n)rep(j,n)cin >> E[i][j];\n      int cost = 0;\n      rep(i,n)rep(j,n)\n\t{\n\t  cin >> F[i][j];\n\t  if(F[i][j] == 'o')cost += E[i][j];\n\t}\n\n      V = n*2 + 3;\n      int source = 2*n+1,sink = 2*n+2;\n      const int diff = 10000;\n\n      rep(y,n)add_edge(source,y,1,0);\n\n      rep(y,n)\n\t{\n\t  rep(x,n)\n\t    {\n\t      add_edge(y,n+x,1,(F[y][x]=='o'?-E[y][x]+diff:W[y][x]+diff));\n\t    }\n\t}\n\n      rep(x,n)add_edge(n+x,sink,1,0);\n\n      /*\n      rep(i,V)\n\t{\n\t  cout << \"from \" << i << endl;\n\t  rep(j,G[i].size())\n\t    {\n\t      edge e = G[i][j];\n\t      cout << e.to << \",\" << e.cost << \",\" << e.cap << endl;\n\t    }\n\t  cout << endl;\n\t}\n      */\n      cost += min_cost_flow(source,sink,inf)-n*diff;\n\n      cout << cost << endl;\n      int cnt = 0;\n      map<ii,bool> found;\n      rep(y,n)\n\t{\n\t  for(int x=0;x<G[y].size();x++)\n\t    {\n\t      if(G[y][x].cap == 0 && G[y][x].to != source && G[y][x].to != sink)\n\t\t{\n\t\t  //cout << \"(\" << y << \",\" << G[y][x].to << \")\" << endl;\n\t\t  if(F[y][G[y][x].to-n] == '.')\n\t\t    {\n\t\t      cnt++;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      found[ii(G[y][x].to-n,y)] = true;\n\t\t    }\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n\n      rep(y,n)rep(x,n)if(!found[ii(x,y)] && F[y][x] == 'o')cnt++;\n\n      cout << cnt << endl;\n\n      rep(y,n)\n\t{\n\t  for(int x=0;x<G[y].size();x++)\n\t    {\n\t      if(G[y][x].cap == 0 && G[y][x].to != source && G[y][x].to != sink)\n\t\t{\n\t\t  if(F[y][G[y][x].to-n] == '.')\n\t\t    {\n\t\t      cout << y+1 << \" \" << G[y][x].to-n+1 << \" write\" << endl;\n\t\t    }\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n\n      rep(y,n)rep(x,n)if(!found[ii(x,y)] && F[y][x] == 'o')\n\t{\n\t  cout << y+1 << \" \" << x+1 << \" erase\" << endl;\n\t}\n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nstruct Edge {\n    int rev, from, to, cap, icap, cost;\n    Edge(int r, int f, int t, int ca, int co) : rev(r), from(f), to(t), cap(ca), icap(ca), cost(co) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ',' << E.cost << ')';\n        else return s;\n    }\n};\n\nconst int MAX_V = 1000;\nconst int INF = 1<<29;\n\nstruct Graph {\n    int V;\n    vector<Edge> list[MAX_V];\n    \n    Graph(int n = 0) : V(n) {for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n    void init(int n = 0) {V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n\tvoid resize(int n = 0) {V = n;}\n    void reset() {for (int i = 0; i < V; ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap;}\n    inline vector<Edge>& operator [] (int i) {return list[i];}\n    \n    Edge &redge(Edge e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev+1];\n    }\n    \n    void addedge(int from, int to, int cap, int cost) {\n        list[from].push_back(Edge(list[to].size(), from, to, cap, cost));\n        list[to].push_back(Edge(list[from].size()-1, to, from, 0, -cost));\n    }\n    \n    void addbiedge(int from, int to, int cap, int cost) {\n        list[from].push_back(Edge(list[to].size(), from, to, cap, cost));\n        list[to].push_back(Edge(list[from].size()-1, to, from, cap, cost));\n    }\n    \n    friend ostream& operator << (ostream& s, const Graph& G) {\n        for (int i = 0; i < G.V; ++i) {s << i << \" : \" << G.list[i];}\n        return s;\n    }\n};\n\nGraph G;\n\nint pot[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V];\nint preve[MAX_V];\n\nint MinCost(Graph &G, int s, int t, int f) {\n    int res = 0;\n    fill(pot, pot+G.V, 0);\n    while (f > 0) {\n        priority_queue<pair<int,int>, vector<pair<int,int> >, greater<pair<int,int> > > que; \n        fill(dist, dist+G.V, INF);\n        dist[s] = 0;\n        que.push(make_pair(0,s));\n        while(!que.empty()) {\n            pair<int,int> p = que.top();\n            que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + pot[v] - pot[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + pot[v] - pot[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n        \n        if (dist[t] == INF) return -1;\n        \n        for (int v = 0; v < G.V; ++v) pot[v] += dist[v];\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * pot[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            Edge &e = G[prevv[v]][preve[v]];\n            Edge &re = G.redge(e);\n            e.cap -= d;\n            re.cap += d;\n        }\n    }\n    return res;\n}\n\n\nint n;\nint W[150][150], E[150][150];\nstring S[150];\n\nint main() {\n    while (cin >> n) {\n        for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) cin >> W[i][j];\n        for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) cin >> E[i][j];\n        for (int i = 0; i < n; ++i) cin >> S[i];\n        \n        G.init(2*n+2);\n        int s = 2*n, t = 2*n+1;\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                \n                int tot = 0;\n                for (int k = 0; k < n; ++k) {\n                    if (k == j) {\n                        if (S[i][k] == '.') tot += W[i][k];\n                    }\n                    else {\n                        if (S[i][k] == 'o') tot += E[i][k];\n                    }\n                }\n                \n                G.addedge(i, n+j, 1, tot);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            G.addedge(s, i, 1, 0);\n            G.addedge(n+i, t, 1, 0);\n        }\n        \n        int res = MinCost(G, s, t, n);\n        \n        vector<pair<pint,string> > ans;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (S[i][j] == '.' && G[i][j].cap == 0) ans.PB(MP(pint(i,j), \"write\"));\n                if (S[i][j] == 'o' && G[i][j].cap == 1) ans.PB(MP(pint(i,j), \"erase\"));\n            }\n        }\n        \n        cout << res << endl;\n        cout << ans.size() << endl;\n        for (int i = 0; i < ans.size(); ++i) {\n            cout << ans[i].first.first+1 << \" \" << ans[i].first.second+1 << \" \" << ans[i].second << endl;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int MAX_V = 210;\nconst int INT_INF = 1<<30;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nstruct edge {\n\tint cap, cost;\n};\nint V;\n\nedge G[MAX_V][MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from][to] = (edge){cap, cost};\n\tG[to][from] = (edge){0, -cost};\n}\n\nint bit_matching_cost(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, INT_INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[i] > dist[v] + e.cost + h[v] - h[i]) {\n\t\t\t\t\tdist[i] = dist[v] + e.cost + h[v] - h[i];\n\t\t\t\t\tprevv[i] = v;\n\t\t\t\t\tpreve[i] = i;\n\t\t\t\t\tque.push(P(dist[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INT_INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\t\tint d = f;\n\t\tfor (int v = 0; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][preve[v]].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint cost[MAX_V][MAX_V];\n\n\nconst int MAX_N = 105;\nint N;\nint W[MAX_N][MAX_N], E[MAX_N][MAX_N];\nbool F[MAX_N][MAX_N], F2[MAX_N][MAX_N];\n\nint main(int argc, char *argv[]) {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(W[i][j]));\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tscanf(\"%d\", &(E[i][j]));\n\t\t}\n\t}\n\tint min_f = 0, f = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tF[i][j] = (s[j] == 'o');\n\t\t\tif (F[i][j]) {\n\t\t\t\tmin_f = min(min_f, -E[i][j]);\n\t\t\t\tf += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tmin_f *= -1;\n\tV = (N+1)*2;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j]) {\n\t\t\t\tadd_edge(i, N+j, 1, -E[i][j]+min_f);\n\t\t\t} else {\n\t\t\t\tadd_edge(i, N+j, 1, W[i][j]+min_f);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N*2, i, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(N+i, N*2+1, 1, 0);\n\t}\n\tf += bit_matching_cost(N*2, N*2+1, N);\n\tf -= min_f*N;\n\tint c = 0;\n\tvector<T> q;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (F[i][j] == G[i][j].cap) {\n\t\t\t\tc++;\n\t\t\t\tq.push_back(T(i, j, F[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n%d\\n\", f, c);\n\tfor (T t: q) {\n\t\tprintf(\"%d %d %s\\n\", get<0>(t)+1, get<1>(t)+1, get<2>(t) ? \"erase\" : \"write\");\n\t} \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2429>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n \n ================================================================\n */\n\n#define MAX_V 500\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(int v=0; v<V ;v++){\n                if(dist[v]==INF) continue;\n                for(int i=0; i<G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF) return -1;\n        \n        int d = f;\n        for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*dist[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nvoid solve(){\n    int n; cin >> n;\n    vector<vector<int>> W(n,vector<int>(n));\n    vector<vector<int>> E(n,vector<int>(n));\n    vector<vector<char>> F(n,vector<char>(n));\n    for(auto& vec:W)for(auto& in:vec) cin >> in;\n    for(auto& vec:E)for(auto& in:vec) cin >> in;\n    for(auto& vec:F)for(auto& in:vec) cin >> in;\n    \n    int Sum = 0;\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n;j++){\n            if(F[i][j] == 'o') Sum += E[i][j];\n        }\n    }\n    \n    \n    V = 2*n+2;\n    int S = 2*n, T = 2*n+1;\n    for(int i = 0; i < n;i++){\n        add_edge(S,i,1,0);\n        add_edge(i+n,T,1,0);\n    }\n    \n    for(int i = 0; i < n;i++){\n        for(int j = 0; j < n;j++){\n            if(F[i][j] == 'o'){\n                add_edge(i,j+n,1,-E[i][j]);\n            }else{\n                add_edge(i,j+n,1,W[i][j]);\n            }\n        }\n    }\n    \n    cout << Sum + min_cost_flow(S,T,n) << endl;\n    using Items = tuple<int,int,string>;\n    queue<Items> q;\n    for(int i = 0; i < n;i++){\n        for(auto& e : G[i]){\n            if(e.to == S || e.to == T) continue;\n            if(e.cap == 0){\n                if(F[i][e.to-n] == '.'){\n                    q.push(Items(i,e.to-n,\"write\"));\n                }\n            }else{\n                if(F[i][e.to-n] == 'o'){\n                    q.push(Items(i,e.to-n,\"erase\"));\n                }\n            }\n        }\n    }\n    cout << q.size() << endl;\n    while(q.size()){\n        int i,j; string query;\n        tie(i,j,query) = q.front(); q.pop();\n        cout << i+1 << \" \" << j+1 << \" \" << query << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <queue>\n#include <limits>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\nclass CostFlow\n{\npublic:\n    using Cost = ll;\n    using Ind = int;\n    using Capacity = ll;\n    using T = ll;\n\n    struct Edge {\n        Edge(const Ind from_, const Ind to_, const Ind reverse_, const Capacity capacity_, const Cost cost_, bool is_reverse_ = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, cost{cost_}, is_reverse{is_reverse_} {}\n        Ind from;\n        Ind to;\n        Ind reverse;\n        Capacity capacity;\n        Capacity flow;\n        Cost cost;\n        bool is_reverse;\n    };\n\n    CostFlow(const Ind v) : V{v}\n    {\n        edge.resize(v);\n        m_dist.resize(v);\n        m_potential.resize(v);\n        m_prev_v.resize(v);\n        m_prev_e.resize(v);\n    }\n\n    void addEdge(const Ind from, const Ind to, const Capacity capacity, const Cost cost)\n    {\n        edge[from].push_back(Edge{from, to, (Ind)edge[to].size(), (Capacity)capacity, (Cost)cost, false});\n        edge[to].push_back(Edge{to, from, (Ind)(edge[from].size() - 1), (Capacity)0, (Cost)(-cost), true});\n    }\n\n    T minCostFlow(const Ind s, const Ind t, T f)\n    {\n        using P = pair<Cost, Ind>;\n        T res = 0;\n        fill(m_potential.begin(), m_potential.end(), 0);\n\n        // Bellman-Ford(Replace this when DAG)\n        for (int i = 0; i < V; i++) {\n            m_potential[i] = INF<T>;\n        }\n        m_potential[s] = 0;\n        bool no_negative_loop = true;\n        for (int i = 0; i < V; i++) {\n            for (int v = 0; v < V; v++) {\n                if (m_potential[v] != INF<T>) {\n                    for (const auto& e : edge[v]) {\n                        if (e.capacity <= 0) {\n                            continue;\n                        }\n                        if (m_potential[e.to] > m_potential[v] + e.cost) {\n                            m_potential[e.to] = m_potential[v] + e.cost;\n                            if (i == V - 1) {\n                                m_potential[e.to] = -INF<T>;  // Confirm \" -INF < min(possible_cost) * V \"\n                                no_negative_loop = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (not no_negative_loop) {\n            // ????????¨?????????\n        }\n        ////show(m_potential)\n\n        while (f > 0) {\n            // Dijkstra\n            priority_queue<P, vector<P>, greater<P>> q;\n            fill(m_dist.begin(), m_dist.end(), INF<T>);\n            m_dist[s] = 0;\n            q.push(make_pair(0, s));\n            while (not q.empty()) {\n                const P p = q.top();\n                q.pop();\n                const Ind v = p.second;\n                if (m_dist[v] < p.first) {\n                    continue;\n                }\n                for (Ind i = 0; i < edge[v].size(); i++) {\n                    const auto& e = edge[v][i];\n                    if (e.capacity > e.flow and m_dist[e.to] > m_dist[v] + e.cost + m_potential[v] - m_potential[e.to]) {\n                        m_dist[e.to] = m_dist[v] + e.cost + m_potential[v] - m_potential[e.to];\n                        m_prev_v[e.to] = v;\n                        m_prev_e[e.to] = i;\n                        q.push(make_pair(m_dist[e.to], e.to));\n                    }\n                }\n            }\n            if (m_dist[t] == INF<T>) {\n                //                return -1;\n                return res;\n            }\n            for (Ind v = 0; v < V; v++) {\n                m_potential[v] += m_dist[v];\n            }\n\n            T d = f;\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                const auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                d = min(d, (T)(e.capacity - e.flow));\n            }\n            f -= d;\n            res += d * m_potential[t];\n            for (Ind v = t; v != s; v = m_prev_v[v]) {\n                auto& e = edge[m_prev_v[v]][m_prev_e[v]];\n                e.flow += d;\n                edge[v][e.reverse].flow -= d;\n            }\n        }\n        return res;\n    }\n\n    const Ind V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    vector<Cost> m_dist;\n    vector<Cost> m_potential;\n    vector<Ind> m_prev_v;\n    vector<Ind> m_prev_e;\n};\n\nstruct Ope {\n    bool o;\n    int r;\n    int c;\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    vector<vector<ll>> W(n, vector<ll>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> W[i][j];\n        }\n    }\n    vector<vector<ll>> E(n, vector<ll>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> E[i][j];\n        }\n    }\n\n    vector<vector<bool>> use(n, vector<bool>(n, false));\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n; j++) {\n            use[i][j] = (s[j] == 'o');\n        }\n    }\n\n    ll sum = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            sum += (use[i][j] ? E[i][j] : 0);\n        }\n    }\n\n    CostFlow flow(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            flow.addEdge(i, j + n, 1, (use[i][j] ? -E[i][j] : W[i][j]));\n        }\n    }\n    const int s = 2 * n;\n    const int t = 2 * n + 1;\n    for (int i = 0; i < n; i++) {\n        flow.addEdge(s, i, 1, 0);\n        flow.addEdge(n + i, t, 1, 0);\n    }\n    cout << sum + flow.minCostFlow(s, t, n) << endl;\n\n    vector<Ope> op;\n    for (int i = 0; i < n; i++) {\n        for (const auto& e : flow.edge[i]) {\n            if (e.is_reverse) {\n                continue;\n            }\n            if (e.flow == 1) {\n                if (not use[i][e.to - n]) {\n                    op.push_back(Ope{false, i, e.to - n});\n                }\n            } else {\n                if (use[i][e.to - n]) {\n                    op.push_back(Ope{true, i, e.to - n});\n                }\n            }\n        }\n    }\n\n    cout << op.size() << endl;\n    for (const auto& o : op) {\n        cout << o.r + 1 << \" \" << o.c + 1 << \" \" << (o.o ? \"erase\" : \"write\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < int(Y);++(X))\n#define peat(X,Y) for (;(X) < int(Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define int ll\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  g[from].pb((Edge){to,cap,g[to].size(),cost});\n  g[to].pb((Edge){from,0,g[from].size()-1,-cost});\n}\nCost INF=1e7;\n\n//min-cost,dij\n\ntypedef pair<Cost,int> Que;\n\nint V;\n\n//f流せなければINF\nCost min_cost_flow(Graph &g,int s,int t,int f){\n  int V=g.size(),res=0;\n  vector<Cost> h(V,0),d(V);\n  vector<int> prevv(V),preve(V);\n  while(f>0){\n    priority_queue<Que,vector<Que>,greater<Que> > que;\n    int V=g.size();\n    d.resize(V);\n    fill(all(d),INF);\n    d[s]=0;\n    que.push(Que(0,s));\n    while(!que.empty()){\n      Que p=que.top();que.pop();\n      int v=p.Y;\n      if(d[v]<p.X)continue;\n      rep(i,g[v].size()){\n        Edge &e=g[v][i];\n        if(e.cap>0 && d[e.to]>d[v]+e.cost+h[v]-h[e.to]){\n          d[e.to]=d[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(Que(d[e.to],e.to));\n        }\n      }\n    }\n    if(d[t] == INF){\n      return INF;\n    }\n    rep(v,V)\n      h[v]+=d[v];\n    int flow=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      flow=min(flow,g[prevv[v]][preve[v]].cap);\n    }\n    f-=flow;\n    res+=flow*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      Edge &e=g[prevv[v]][preve[v]];\n      e.cap-=flow;\n      g[v][e.rev].cap+=flow;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k,n;\n  cin>>n;\n  vector<vector<int> > w(n,vector<int>(n)),e(n,vector<int>(n));\n  rep(i,n)rep(j,n)\n    cin>>w[i][j];\n  rep(i,n)rep(j,n)\n    cin>>e[i][j];\n  string str,strs[n];\n  Graph g(n*2+2);\n  rep(i,n){\n    cin>>str;\n    strs[i]=str;\n    int sum=0;\n    rep(j,n){\n      if(str[j]=='o'){\n        w[i][j]=-e[i][j];\n        sum+=e[i][j];\n      }\n    }\n    rep(j,n)\n      add_edge(g,i+2,j+n+2,1,sum+w[i][j]);\n    add_edge(g,0,i+2,1,0);\n    add_edge(g,i+n+2,1,1,0);\n  }\n  cout<<min_cost_flow(g,0,1,n)<<endl;\n  vector<pii> er,wr;\n  rep(i,n){\n    int fr;\n    rep(j,g[i+n+2].size()){\n      if(g[i+n+2][j].cap){\n        fr=g[i+n+2][j].to-2;\n        break;\n      }\n    }\n    rep(j,n){\n      if(j==fr){\n        if(strs[i][j]=='.')\n          wr.pb(pii(i,j));\n      }else{\n        if(strs[i][j]=='o')\n          er.pb(pii(i,j));\n      }\n    }\n  }\n  cout<<er.size()+wr.size()<<endl;\n  rep(i,wr.size())\n    cout<<wr[i].X+1<<\" \"<<wr[i].Y+1<<\" write\"<<endl;\n  rep(i,er.size())\n    cout<<er[i].X+1<<\" \"<<er[i].Y+1<<\" erase\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    const ll INF = 1LL<<58;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N;\n    vector<vector<int>> W, E;\n    vector<string> F;\n\n    void input() {\n        cin >> N;\n        W.resize(N, vector<int>(N, 0)); cin >> W;\n        E.resize(N, vector<int>(N, 0)); cin >> E;\n        F.resize(N); cin >> F;\n    }\n\n    void solve() {\n        ll init_cost = 0;\n        vector<vector<int>> C(N, vector<int>(N));\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (F[i][j] == 'o') {\n                    init_cost += E[i][j];\n                    C[i][j] = -E[i][j];\n                } else {\n                    C[i][j] = W[i][j];\n                }\n            }\n        }\n        vector<vector<int>> js(N, vector<int>(N));\n        for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) js[i][j] = j;\n        for (int i = 0; i < N; i++) {\n            sort(whole(js[i]), [&](int a, int b) { return C[i][a] < C[i][b]; });\n        }\n\n        ll cur_ans = INF;\n        typedef pair<int,int> P;\n        vector<P> cur_ws;\n        function<void(int, vector<bool>&, ll, vector<P>&)> dfs = [&](int i, vector<bool>& used, ll cur_cost, vector<P>& ws) {\n            if (i == N) {\n                if (cur_ans > cur_cost) {\n                    cur_ans = cur_cost;\n                    cur_ws = ws;\n                }\n                return;\n            }\n            if (cur_cost >= cur_ans) return;\n            for (auto j : js[i]) {\n                if (used[j]) continue;\n                used[j] = true;\n                ws.emplace_back(i, j);\n                dfs(i + 1, used, cur_cost + C[i][j], ws);\n                ws.pop_back();\n                used[j] = false;\n            }\n        };\n        vector<bool> used(N, false);\n        vector<P> ws;\n        dfs(0, used, init_cost, ws);\n        cout << cur_ans << endl;\n        vector<string> G(N, string(N, '.'));\n        for (auto w : cur_ws) {\n            G[w.first][w.second] = 'o';\n        }\n        int c = 0;\n        ostringstream os;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (F[i][j] == G[i][j]) continue;\n                c++;\n                if (F[i][j] == 'o') {\n                    os << i + 1 << \" \" << j + 1 << \" erase\" << endl;\n                } else {\n                    os << i + 1 << \" \" << j + 1 << \" write\" << endl;\n                }\n            }\n        }\n        cout << c << endl;\n        cout << os.str() << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Weight=long long;\n\nstruct Edge{\n    int to;\n    Weight cap,rev;\n    Weight cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nclass Flow{\n    const Weight INF=1e9+7;\n    const bool isNegative=false;\n    int N;\n    vector<int> level;\n    vector<int> iter;\n    void bfs(int s);\n    Weight dfs(int v,int t,Weight f);\n    public:\n    Graph g;\n    Flow(int N):N(N),g(N){};\n    void addEdge(int from,int to,Weight cap);\n    void addEdge(int from,int to,Weight cap,Weight cost);\n    Weight maxFlow(int s,int t);\n    Weight minCostFlow(int s,int t,Weight f);\n};\n\nint main(){\n    int n;\n    cin>>n;\n    Flow flow(2*n+2);\n    vector<vector<int>> w(n,vector<int>(n));\n    vector<vector<int>> e(n,vector<int>(n));\n    vector<string> f(n);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            cin>>w[i][j];\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            cin>>e[i][j];\n        }\n    }\n    for(int i=0;i<n;i++) cin>>f[i];\n    vector<vector<int>> c(n,vector<int>(n));\n    int res=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(f[i][j]=='o'){\n                res+=e[i][j];\n                c[i][j]=-e[i][j];\n            }\n            else{\n                c[i][j]=w[i][j];\n            }\n        }\n    }\n    \n    for(int i=0;i<n;i++){\n        flow.addEdge(0,i+1,1,0);\n        flow.addEdge(n+1+i,2*n+1,1,0);\n        for(int j=0;j<n;j++){\n            flow.addEdge(i+1,n+1+j,1,c[i][j]+1000);\n        }\n    }\n    res+=flow.minCostFlow(0,2*n+1,n)-1000*n;\n    cout<<res<<endl;\n    vector<vector<char>> last(n,vector<char>(n,'.'));\n    for(int i=0;i<n;i++){\n        auto edges=flow.g[i+1];\n        for(int j=0;j<edges.size();j++){\n            if(edges[j].cap==0 && edges[j].to!=0){\n                last[i][edges[j].to-1-n]='o';\n            }\n        }\n    }\n    vector<pair<int,int>> ans;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(last[i][j]!=f[i][j]) ans.push_back(make_pair(i,j));\n        }\n    }\n    cout<<ans.size()<<endl;\n    for(int i=0;i<ans.size();i++){\n        int h=ans[i].first,w=ans[i].second;\n        cout<<h+1<<\" \"<<w+1<<\" \";\n        if(f[h][w]=='o'){\n            cout<<\"erase\"<<endl;\n        }\n        else{\n            cout<<\"write\"<<endl;\n        }\n    }\n    return 0;\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap){\n    g[from].push_back({to,cap,int(g[to].size()),0});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,0});\n}\n\nvoid Flow::addEdge(int from,int to,Weight cap,Weight cost){\n    g[from].push_back({to,cap,int(g[to].size()),cost});\n    g[to].push_back({from,Weight(0),int(g[from].size())-1,-cost});\n}\nWeight Flow::maxFlow(int s,int t){\n    Weight flow=0;\n    while(true){\n        bfs(s);\n        if(level[t]<0) return flow;\n        iter.assign(N,0);\n        Weight f;\n        while((f=dfs(s,t,INF))>0){\n            flow+=f;\n        }\n    }\n}\nvoid Flow::bfs(int s){\n    level.assign(N,-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            Edge &e=g[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to]=level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nWeight Flow::dfs(int v,int t,Weight f){\n    if(v==t) return f;\n    for(int& i=iter[v];i<g[v].size();i++){\n        Edge& e=g[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            Weight d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nWeight Flow::minCostFlow(int s,int t,Weight f){\n    using P=pair<Weight,int>;\n    Weight res=0;\n    vector<Weight> h(N,0);\n    vector<int> used(N),preve(N),prevv(N);\n    vector<Weight> dist(N);\n    while(f>0){    \n        fill(dist.begin(),dist.end(),INF);\n        dist[s]=0;\n        if(!isNegative){\n            //Dijkstra\n            fill(used.begin(),used.end(),0);\n            priority_queue<P,vector<P>,greater<P>> que;\n            que.push(make_pair(Weight(0),s));\n            while(!que.empty()){\n                P p=que.top(); que.pop();\n                int v=p.second;\n                if(used[v]) continue;\n                used[v]=true;\n                for(int i=0;i<g[v].size();i++){\n                    Edge &e=g[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        que.push(make_pair(dist[e.to],e.to));\n                    }\n                }\n            }\n        }else{\n            //Bermanford\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<N;v++){\n                    if(dist[v]==INF) continue;\n                    for(int i=0;i<g[v].size();i++){\n                        Edge &e=g[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to]=v;\n                            preve[e.to]=i;\n                            update=true;\n                        }\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==INF){\n            return -1;\n        }\n        if(!isNegative){\n            for(int v=0;v<N;v++) h[v]+=dist[v];\n        }\n        Weight d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        if(!isNegative){\n            res+=d*h[t];\n        }else{\n            res+=d*dist[t];\n        }\n        for(int v=t;v!=s;v=prevv[v]){\n            Edge& e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 300\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint can[MAX_V][MAX_V]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(int N,int K){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j , 1, can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  int n;\n  cin>>n;\n  int W[101][101],E[101][101];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>W[i][j];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++) cin>>E[i][j];\n  \n  string mp[101];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  int sumW[101]={},sumH[101]={},sum=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(mp[i][j]=='o'){\n\tsumW[i]+=E[i][j];\n\tsumH[j]+=E[i][j];\n\tsum+=E[i][j];\n      }\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      can[i][j]=sumH[j]+sumW[i]+(mp[i][j]=='o'? -E[i][j]:W[i][j]);\n\n  cout<<sum+Biparite_Matching(n,n)<<endl;\n  int cnt=0;\n  ostringstream ans[10001],tmp;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++) {\n      int h=i,w=G[i][j].to-n,cap=G[i][j].cap;\n      if(cap<=0&&mp[h][w]=='.')ans[cnt++]<<h+1<<\" \"<<w+1<<\" write\"<<endl;\n      if(cap>0&&mp[h][w]=='o')ans[cnt++]<<h+1<<\" \"<<w+1<<\" erase\"<<endl;\n    }\n  cout<<cnt<<endl;\n  for(int i=0;i<cnt;i++)cout<<ans[i].str();  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Weight;\ntypedef int Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int from, int to, Flow cap, Weight cost)\n{\n\tg[from].push_back(Edge(from, to, (int)g[to].size(), cap, cost));\n\tg[to].push_back(Edge(to, from, (int)g[from].size() - 1, 0, -cost));\n}\n\nWeight mincost_flow(Graph &g, int s, int t, Flow f)\n{\n\tconst int n = g.size();\n\tWeight res = 0;\n\tArray dist(n);\n\tvi prevv(n), preve(n);\n\twhile (f > 0)\n\t{\n\t\tREP(i, n) dist[i] = (i == s) ? 0 : INF;\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tfor (int v = 0; v < n; v++)\n\t\t\t{\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\tREP(i, g[v].size())\n\t\t\t\t{\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.dest] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1; // cannot flow\n\t\tFlow d = f;\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint N;\nvector<vi> W, E;\nvs f;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> N;\n\tW.resize(N, vi(N));\n\tE.resize(N, vi(N));\n\tf.resize(N);\n\tREP(i, N)REP(j, N) cin >> W[i][j];\n\tREP(i, N)REP(j, N) cin >> E[i][j];\n\tREP(i, N) cin >> f[i];\n\tGraph g(N * 2 + 2);\n\tint src = N * 2, sink = N * 2 + 1;\n\tREP(i, N)\n\t{\n\t\tadd_edge(g, src, i, 1, 0);\n\t\tadd_edge(g, N + i, sink, 1, 0);\n\t}\n\tREP(i, N)REP(j, N)\n\t{\n\t\tint cost = 0;\n\t\tREP(k, N)\n\t\t{\n\t\t\tif (k == j && f[i][k] == '.') cost += W[i][k];\n\t\t\tif (k != j && f[i][k] == 'o') cost += E[i][k];\n\t\t}\n\t\tadd_edge(g, i, N + j, 1, cost);\n\t}\n\tcout << mincost_flow(g, src, sink, N) << endl;\n\tvs res(N, string(N, '.'));\n\tREP(i, N)\n\t{\n\t\tREP(j, g[i].size())\n\t\t{\n\t\t\tif (g[i][j].dest != src && g[i][j].cap == 0)\n\t\t\t{\n\t\t\t\tres[i][g[i][j].dest - N] = 'o';\n\t\t\t}\n\t\t}\n\t}\n\tvector<tuple<int, int, int>> ans;\n\tREP(i, N)REP(j, N)\n\t{\n\t\tif (f[i][j] == '.' && res[i][j] == 'o') ans.emplace_back(0, i, j);\n\t\tif (f[i][j] == 'o' && res[i][j] == '.') ans.emplace_back(1, i, j);\n\t}\n\tcout << ans.size() << endl;\n\tfor (auto t : ans)\n\t{\n\t\tint a, i, j;\n\t\ttie(a, i, j) = t;\n\t\tif (a == 0) cout << i + 1 << \" \" << j + 1 << \" write\" << endl;\n\t\tif (a == 1) cout << i + 1 << \" \" << j + 1 << \" erase\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nconst int INF = (1<<28);\n\nclass Edge\n{\npublic:\n\tint src,dst,cst,cap,rev;\n\tEdge(int src, int dst, int cst, int cap, int rev)\n\t\t:src(src),dst(dst),cst(cst),cap(cap),rev(rev)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int u, int v, int cap, int cost, Graph& graph)\n{\n\tgraph[u].push_back(Edge(u, v, cost, cap, graph[v].size()));\n\tgraph[v].push_back(Edge(v, u, -cost, 0, graph[u].size()-1));\n}\n\npair<int, int> minimumCostFlow(int S, int T, int L, Graph& graph)\n{\n  int V = graph.size();\n  vector<int> dist(V), prevv(V), preve(V);\n\n  int res = 0, fw = 0;\n  while(1) {\n    fill(dist.begin(), dist.end(), INF);\n    dist[S] = 0;\n    bool update = true;\n\n    while(update) {\n      update = false;\n      for(int v = 0; v < V; v++) {\n        if(dist[v] == INF) continue;\n\n        for(int i=0; i<graph[v].size(); i++) {\n          Edge& e = graph[v][i];\n          int cost = e.cst;\n          if(graph[e.dst][e.rev].cap != 0) cost = 0;\n\n          if(e.cap > 0 && dist[e.dst] > dist[e.src] + cost) {\n            dist[e.dst] = dist[e.src] + cost;\n            prevv[e.dst] = e.src;\n            preve[e.dst] = i;\n            update = true;\n          }\n        }\n      }\n    }\n\n    if(dist[T] == INF) break;\n\n    int f = INF;\n    for(int v = T; v != S; v = prevv[v])\n      f = min(f, graph[prevv[v]][preve[v]].cap);\n\n    res += dist[T];\n    fw += f;\n\n    for(int v = T; v != S; v = prevv[v]) {\n      Edge& e = graph[prevv[v]][preve[v]];\n      e.cap -= f;\n      graph[v][e.rev].cap += f;\n    }\n\n\tif(fw >= L) break;\n  }\n\n  return make_pair(res, fw);\n}\n\nint ecst[100][100], icst[100][100];\nint main()\n{\n\tint N;\n\tcin >> N;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> ecst[j][i];\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++)\n\t\tcin >> icst[j][i];\n\n\tstring field[100];\n\tfor(int i=0; i<N; i++)\n\t\tcin >> field[i];\n\n\n\tint res = 0;\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tif(field[i][j] == 'o') {\n\t\t\tres += ecst[j][i];\n\t\t}\n\t}\n\n\n\tGraph graph(N*N+2);\n\tfor(int i=0; i<N; i++) {\n\t\taddEdge(N*N, i, 1, 0, graph);\n\t\taddEdge(N+i, N*N+1, 1, 0, graph);\n\t}\n\n\tfor(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t\tint cst;\n\t\tif(field[i][j] == 'o') cst = -ecst[j][i];\n\t\telse cst = icst[j][i];\n\n\t\taddEdge(j, i+N, 1, cst, graph);\n\t}\n\n\tpair<int, int> fw = minimumCostFlow(N*N, N*N+1, N, graph);\n\n\n\tint ans = res + fw.first;\n\tcout << ans << endl;\n\n\tint c = 0;\n\tstringstream ss;\n\tfor(int i=0; i<N; i++) {\n\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\tEdge& e = graph[i][j];\n\n\t\t\tif(e.dst >= N*N) continue;\n\n\t\t\tif(field[e.dst-N][e.src] == 'o' && e.cap == 1) {\n\t\t\t\tc++;\n\t\t\t\tss << e.dst + 1 - N << \" \" <<   e.src + 1 << \" erase\" << endl;\n\t\t\t}\n\t\t\tif(field[e.dst-N][e.src] == '.' && e.cap == 0) {\n\t\t\t\tc++;\n\t\t\t\tss << e.dst + 1 - N << \" \" <<   e.src + 1 << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << c << endl;\n\tcout << ss.str();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> wcost(n,vector<int>(n ));\n\tvector<vector<int>> ecost(n , vector<int>(n));\n\tvector<vector<bool>> ifwritten(n , vector<bool>(n));\n\tvector<vector<bool>> change(n , vector<bool>(n ));\n\tvector<vector<int>> nowcost(n , vector<int>(n ));\n\tint cost=0;\n\tint changenum = 0;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcin >> wcost[i][j];\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tcin >> ecost[i][j];\n\t\t}\n\t}\n\n\tREP(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tREP(j, n) {\n\t\t\tif (s[j] == 'o') {\n\t\t\t\tifwritten[i][j] = true;\n\t\t\t\tchange[i][j] = true;\n\t\t\t\tnowcost[i][j] = -ecost[i][j];\n\t\t\t\tcost += ecost[i][j];\n\t\t\t\tchangenum++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tifwritten[i][j] = false;\n\t\t\t\tchange[i][j] = false;\n\t\t\t\tnowcost[i][j] = wcost[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvector<int> retu(n);\n\tREP(i, n) {\n\t\tretu[i] = i;\n\t\tcost += nowcost[i][i];\n\t\t\tnowcost[i][i] *= -1;\n\t\tif (change[i][i]) {\n\t\t\tchange[i][i] = false;\n\t\t\tchangenum--;\n\t\t}\n\t\telse {\n\t\t\tchange[i][i] = true;\n\t\t\tchangenum++;\n\t\t}\n\t}\n\tFOR(i, 0, n) {\n\t\tFOR(j, i+1, n) {\n\t\t\tif (nowcost[i][retu[i]] + nowcost[j][retu[j]] + nowcost[i][retu[j]] + nowcost[j][retu[i]] < 0) {\n\t\t\t\tcost += nowcost[i][retu[i]] + nowcost[j][retu[j]] + nowcost[i][retu[j]] + nowcost[j][retu[i]];\n\n\t\t\t\tnowcost[i][retu[i]] *= -1;\n\t\t\t\tif (change[i][retu[i]]) {\n\t\t\t\t\tchange[i][retu[i]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[i][retu[i]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tnowcost[i][retu[j]] *= -1;\n\t\t\t\tif (change[i][retu[j]]) {\n\t\t\t\t\tchange[i][retu[j]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[i][retu[j]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\n\t\t\t\tnowcost[j][retu[i]] *= -1;\n\t\t\t\tif (change[j][retu[i]]) {\n\t\t\t\t\tchange[j][retu[i]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[j][retu[i]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tnowcost[j][retu[j]] *= -1;\n\t\t\t\tif (change[j][retu[j]]) {\n\t\t\t\t\tchange[j][retu[j]] = false;\n\t\t\t\t\tchangenum--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchange[j][retu[j]] = true;\n\t\t\t\t\tchangenum++;\n\t\t\t\t}\n\t\t\t\tint a = retu[i];\n\t\t\t\tretu[i] = retu[j];\n\t\t\t\tretu[j] = a;\n\t\t\t}\n\t\t}\n\t}\n\tcout << cost << endl;\n\tcout << changenum << endl;\n\tREP(i, n) {\n\t\tREP(j, n) {\n\t\t\tif (change[i][j]) {\n\t\t\t\tif (ifwritten[i][j]) {\n\t\t\t\t\tcout << i +1<< \" \" << j + 1 << \" \" << \"erase\" << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tcout << i + 1 << \" \" << j + 1 << \" \" << \"write\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <bits/stdc++.h>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n// ????°??????¨???(Min Cost Flow)\n\ntemplate <class T> class MinCostFlow {\npublic:\n    // struct edge { int to, capacity; T cost;int reve;};\n    class edge{\n    public:\n        int to;\n        int capacity;\n        T cost;\n        int reve;\n    \n        edge(int _to, int _capacity, int _reve, T _cost){\n          this->to = _to;\n          this->capacity = _capacity;\n          this->reve = _reve;\n          this->cost = _cost;\n        }\n    };\n    static const int MV = 300;//????????°\n    vector<edge> E[MV];\n    T dist[MV];\n    int prev_v[MV], prev_e[MV], NV;\n    \n    MinCostFlow() { init(MV); }\n    void init(int NV=MV) { this->NV=NV; for(int i=0;i<MV;i++) E[i].clear();}\n    void addEdge(int x,int y, int cap, T cost) {\n        E[x].push_back(edge(y,cap,E[y].size(),cost));\n        E[y].push_back(edge(x,0,E[x].size()-1,-cost)); /* rev edge */\n    }\n    \n    T minCost(int from, int to, int flow) {\n        T res=0;\n        T inf=std::numeric_limits<T>::max()/2;\n        memset(prev_v,0,sizeof(prev_v));\n        memset(prev_e,0,sizeof(prev_e));\n        while(flow>0) {\n            fill(dist, dist+NV, inf);\n            dist[from]=0;\n            bool up=true;\n            while(up) {\n                up=false;\n                for(int v=0;v<NV;++v) {\n                    if(dist[v]==inf) continue;\n                    for(int i=0;i<E[v].size();++i) {\n                        edge &e=E[v][i];\n                        if(e.capacity>0 && dist[e.to]>dist[v]+e.cost) {\n                            dist[e.to]=dist[v]+e.cost;\n                            prev_v[e.to]=v;\n                            prev_e[e.to]=i;\n                            up=true;\n                        }\n                    }\n                }\n            }\n            if(dist[to]==inf) return -1;\n            int lc=flow;\n            for(int v=to;v!=from;v=prev_v[v]){\n                lc = min(lc, E[prev_v[v]][prev_e[v]].capacity);\n            }\n            flow -= lc;\n            res += lc*dist[to];\n            for(int v=to;v!=from;v=prev_v[v]) {\n                edge &e=E[prev_v[v]][prev_e[v]];\n                e.capacity -= lc;\n                E[v][e.reve].capacity += lc;\n            }\n        }\n        return res;\n    }\n};\nvoid mainmain(){\n    int n;\n    cin>>n;\n    vvint wcost,ecost;\n    initvv(ecost,n,n);\n    initvv(wcost,n,n);\n    rep(i,n) rep(j,n) cin>>wcost[i][j];\n    rep(i,n) rep(j,n) cin>>ecost[i][j];\n    vector<string> vs(n);\n    rep(i,n) cin>>vs[i];\n    MinCostFlow<int> mf;\n    int start=2*n+1;\n    int goal=2*n+2;\n    rep(i,n){\n        mf.addEdge(start,i,1,0);\n        mf.addEdge(n+i,goal,1,0);\n    }\n    rep(i,n){\n        int tt=0;\n        rep(j,n) if(vs[i][j]=='o') tt+=ecost[i][j];\n        rep(j,n){\n            int t;\n            if(vs[i][j]=='o'){\n                t=tt-ecost[i][j];\n            }\n            else{\n                t=tt+wcost[i][j];\n            }\n            mf.addEdge(i,n+j,1,t);\n        }\n    }\n    int ans=mf.minCost(start,goal,n);\n    vector<pair<pii,string>> tmp;\n    rep(i,n){\n        rep(j,n){\n            bool f=false;\n            for(auto x:mf.E[i]){\n                if(x.capacity==0&&x.to==j+n) f=true;\n            }\n            if(vs[i][j]=='o'&&!f){\n                tmp.PB(mkp(pii(i+1,j+1),\"erase\"));\n            }\n            if(vs[i][j]=='.'&&f){\n                tmp.PB(mkp(pii(i+1,j+1),\"write\"));\n            }\n        }\n    }\n    cout<<ans<<endl;\n    cout<<tmp.size()<<endl;\n    rep(i,tmp.size()){\n        cout<<tmp[i].F.F<<\" \"<<tmp[i].F.S<<\" \"<<tmp[i].S<<endl;\n    }\n    // cout<<mf.minCostFlow(start,goal,n)<<endl;\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cout<<fixed<<setprecision(0);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "// aribon3-5_d\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF ((1 << 29)-1)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain;\n\n\nstruct MinCostFlow {\n    struct edge {int to, cap, cost, rev;};\n    vector<vector<edge>> G;\n    int v_num;\n\n    MinCostFlow(int n): v_num(n), G(n) {}\n\n    void add_edge(int from, int to, int cap, int cost) {\n        G[from].emplace_back((edge){to, cap, cost, (int)G[to].size()});\n        G[to].emplace_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n    }\n\n    int min_cost_flow(int s, int t, int f) {\n        int res = 0;\n\n\n        while (f > 0) {\n\n            vector<int> dist(v_num, INF);\n            vector<int> prev_v(v_num, 0), prev_e(v_num, 0);\n            dist[s] = 0;\n\n            // Bellman-Ford\n            bool update = true;\n            while (update) {\n                update = false;\n                REP(v, v_num) {\n                    if (dist[v] == INF) continue;\n\n                    REP(i, G[v].size()) {\n                        edge &e = G[v][i];\n                        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            //\n            if (dist[t] == INF){\n                return  -1;\n            }\n\n            // 最短経路に流す\n            int d = f;\n            for (int v = t; v != s; v = prev_v[v]){\n                d = min(d, G[prev_v[v]][prev_e[v]].cap);\n            }\n\n            f -= d;\n            res += d * dist[t];\n            for (int v = t; v != s; v = prev_v[v]){\n                edge &e = G[prev_v[v]][prev_e[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"../arg.txt\"); cin.rdbuf(in.rdbuf());\n#endif\n\n    int N;\n    cin >> N;\n\n    vector<vector<int>> W, E;\n    W.assign(N, vector<int>(N, 0));\n    E.assign(N, vector<int>(N, 0));\n    vector<string> F(N);\n\n    REP(i, N) REP(j, N) cin >> W[i][j];\n    REP(i, N) REP(j, N) cin >> E[i][j];\n    REP(i, N) cin >> F[i];\n\n    // 最初からoがついてるやつは、全部消してその分のコストを足しておく\n    // もしいるなら、-Eで書き直す\n    // 最初から空白の奴はWかかる\n    int s = 2 * N, t = s + 1;\n    auto g = MinCostFlow(2*N+2);\n    int ans = 0;\n\n    REP(i, N) g.add_edge(s, i, 1, 0);\n    REP(i, N) g.add_edge(N+i, t, 1, 0);\n    REP(i, N) REP(j, N){\n        if (F[i][j] == 'o'){\n            ans += E[i][j];\n            g.add_edge(i, N+j, 1, -E[i][j]);\n        } else {\n            g.add_edge(i, N+j, 1, W[i][j]);\n        }\n    }\n\n    ans += g.min_cost_flow(s, t, N);\n    print(ans);\n\n    vector<tuple<int, int, string>> info;\n    REP(i, N) {\n        REP(j, N){\n            if (F[i][j] == 'o' && g.G[i][j+1].cap == 1) {\n                info.emplace_back(i+1, j+1, \"erase\");\n            } else if (F[i][j] != 'o' && g.G[i][j+1].cap == 0) {\n                info.emplace_back(i+1, j+1, \"write\");\n            }\n        }\n    }\n    print(info.size());\n    for (auto e: info){\n        print(get<0>(e), get<1>(e), get<2>(e));\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge{\n\tint to,cap,cost,rev;\n\tedge(int to,int cap,int cost,int rev) :to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=202,INF=1e9;\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V],dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n\tedge e1=edge(to,cap,cost,G[to].size()),e2=edge(from,0,-cost,G[from].size());\n\tG[from].pb(e1),G[to].pb(e2);\n}\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.sc;\n\t\t\tif(dist[v]<p.fs) continue;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF) return -1;\n\t\trep(v,V) h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tchmin(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint N;\n\tint w[100][100],e[100][100];\n\tstring s[100];\n\tcin>>N;\n\trep(i,N) rep(j,N) cin>>w[i][j];\n\trep(i,N) rep(j,N) cin>>e[i][j];\n\trep(i,N) cin>>s[i];\n\tint S=2*N,T=2*N+1;\n\tV=2*N+2;\n\trep(i,N) add_edge(S,i,1,0);\n\trep(i,N) add_edge(N+i,T,1,0);\n\trep(i,N) rep(j,N){\n\t\tint c=0;\n\t\trep(k,N){\n\t\t\tif(k==j){\n\t\t\t\tif(s[i][k]=='.') c+=w[i][k];\n\t\t\t}else{\n\t\t\t\tif(s[i][k]=='o') c+=e[i][k];\n\t\t\t}\n\t\t}\n\t\tadd_edge(i,N+j,1,c);\n\t}\n\tint f=min_cost_flow(S,T,N);\n\tcout<<f<<endl;\n\tbool is[100][100]={};\n\trep(v,N){\n\t\tfor(edge e:G[v]){\n\t\t\tint u=e.to;\n\t\t\tif(u<2*N){\n\t\t\t\tis[v][u-N]=(e.cap==0);\n\t\t\t}\n\t\t}\n\t}\n\tint c=0;\n\trep(i,N) rep(j,N) if((s[i][j]=='o')^is[i][j]) c++;\n\tcout<<c<<endl;\n\trep(i,N) rep(j,N){\n\t\tif((s[i][j]=='o')&&!is[i][j]) printf(\"%d %d erase\\n\",i+1,j+1);\n\t\tif((s[i][j]=='.')&&is[i][j]) printf(\"%d %d write\\n\",i+1,j+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\n    struct Edge{\n        int src, dst, cap, cost, rev;\n        Edge() {}\n        Edge(int s, int d, int c, int cs, int r) : \n            src(s), dst(d), cap(c), cost(cs), rev(r) {}\n    };\n\nstruct MinCostFlow{\n    typedef pair<int, int> P;\n    static const int INF = 100000000; \n\n    typedef vector<Edge> Node;\n    typedef vector<Node> Graph;\n\n    Graph G;\n\n    MinCostFlow(int N) : G(N) {}\n\n    void add_edge(int src, int dst, int cap, int cost){\n        G[src].push_back(Edge(src, dst, cap, cost, G[dst].size()));\n        G[dst].push_back(Edge(dst, src, 0, -cost, G[src].size() - 1));\n    }\n\n    int min_cost_flow(int s, int t, int f){\n        int V = G.size();\n        vector<int> h(V);\n        vector<int> prevv(V), preve(V);\n        int res = 0;\n        while(f > 0){\n            priority_queue<P, vector<P>, greater<P>> que;\n            vector<int> dist(V, INF);\n            dist[s] = 0;\n            que.push(P(0, s));\n\n            while(!que.empty()){\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i = 0; i < G[v].size(); i++){\n                    Edge& e = G[v][i];\n                    int ndist = dist[v] + e.cost + h[v] - h[e.dst];\n                    if(e.cap > 0 && dist[e.dst] > ndist){\n                        dist[e.dst] = ndist;\n                        prevv[e.dst] = v;\n                        preve[e.dst] = i;\n                        que.push(P(ndist, e.dst));\n                    }\n                }\n            }\n\n            if(dist[t] == INF){\n                return -1;\n            }\n\n            for(int v = 0; v < V; v++) h[v] += dist[v];\n\n            int d = f;\n            for(int v = t; v != s; v = prevv[v]){\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n\n            f -= d;\n            res += d * h[t];\n            for(int v = t; v != s; v = prevv[v]){\n                Edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    vector<Edge> flow_edges(){\n        vector<Edge> res;\n        for(int i = 0; i < G.size(); i++){\n            for(const auto& e : G[i]){\n                if(e.cap == 0){\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int N;\n    while(cin >> N){\n        int W[100][100];\n        int E[100][100];\n        REP(y, N) REP(x, N) cin >> W[y][x];\n        REP(y, N) REP(x, N) cin >> E[y][x];\n        string grid[100];\n        REP(y, N) cin >> grid[y];\n\n        MinCostFlow solver(N * N + 2);\n        int Source = N * N;\n        int Dist = Source + 1;\n        REP(y, N) solver.add_edge(Source, y, 1, 0);\n        REP(x, N) solver.add_edge(x + N, Dist, 1, 0);\n\n        for(int y = 0; y < N; y++){\n            for(int sx = 0; sx < N; sx++){\n                int cost = 0;\n                if(grid[y][sx] == '.'){\n                    cost += W[y][sx];\n                }\n                for(int x = 0; x < N; x++){\n                    if(x != sx && grid[y][x] == 'o'){\n                        cost += E[y][x];\n                    }\n                }\n                //printf(\"%d -> %d : %d\\n\", y, sx, cost);\n                solver.add_edge(y, sx + N, 1, cost);\n            }\n        }\n\n        int mincost = solver.min_cost_flow(Source, Dist, N);\n        vector<Edge> edges = solver.flow_edges();\n        vector<int> select(N);\n        for(Edge e : edges){\n            if(e.src < N){\n                select[e.src] = e.dst - N;\n            }\n        }\n        int count = 0;\n        stringstream ss;\n        int cost = 0;\n        for(int y = 0; y < N; y++){\n            for(int x = 0; x < N; x++){\n                if(select[y] == x && grid[y][x] == '.'){\n                    ss << y + 1 << \" \" << x + 1 << \" write\" << endl;\n                    cost += W[y][x];\n                    count++;\n                }\n                if(select[y] != x && grid[y][x] == 'o'){\n                    ss << y + 1 << \" \" << x + 1 << \" erase\" << endl;\n                    cost += E[y][x];\n                    count++;\n                }\n            }\n        }\n        assert(mincost == cost);\n        cout << mincost << endl;\n        cout << count << endl;\n        cout << ss.str();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int N_MAX=100;\n\nint match[2][N_MAX];\n#define slack(u,v) (lbl[0][u]+lbl[1][v]+a[u][v])\ntemplate<class cost_t>\ncost_t Kuhn_Munkres(int n,const cost_t a[N_MAX][N_MAX]){\n\tconst cost_t COST_INF=1<<29;\n\n\tstatic cost_t lbl[2][N_MAX];\n\trep(i,2) rep(u,n) match[i][u]=-1, lbl[i][u]=0;\n\n\trep(root,n){\n\t\tstatic bool S[N_MAX],T[N_MAX];\n\t\tstatic int pre[N_MAX],u_min[N_MAX];\n\t\trep(u,n) S[u]=false;\n\t\trep(v,n) T[v]=false, pre[v]=-1, u_min[v]=root;\n\t\tS[root]=true;\n\n\t\twhile(1){\n\t\t\tcost_t d=COST_INF;\n\t\t\trep(v,n) if(!T[v]) d=min(d,slack(u_min[v],v));\n\t\t\trep(u,n) if( S[u]) lbl[0][u]-=d;\n\t\t\trep(v,n) if( T[v]) lbl[1][v]+=d;\n\n\t\t\tint x,y;\n\t\t\trep(v,n) if(!T[v] && slack(u_min[v],v)==0) { y=v; break; }\n\t\t\tx=match[1][y];\n\t\t\tpre[y]=u_min[y];\n\n\t\t\tif(x==-1){\n\t\t\t\twhile(y!=-1){\n\t\t\t\t\tint w=pre[y];\n\t\t\t\t\tint z=match[0][w];\n\t\t\t\t\tmatch[1][y]=w;\n\t\t\t\t\tmatch[0][w]=y;\n\t\t\t\t\ty=z;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tS[x]=T[y]=true;\n\t\t\trep(v,n) if(slack(x,v)<slack(u_min[v],v)) u_min[v]=x;\n\t\t}\n\t}\n\n\tcost_t res=0;\n\trep(u,n) res+=a[u][match[0][u]];\n\treturn res;\n}\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tint W[100][100],E[100][100];\n\trep(i,n) rep(j,n) scanf(\"%d\",W[i]+j);\n\trep(i,n) rep(j,n) scanf(\"%d\",E[i]+j);\n\n\tchar B[100][101];\n\trep(i,n) scanf(\"%s\",B[i]);\n\n\tint ans=0;\n\trep(i,n) rep(j,n) if(B[i][j]=='o') ans+=E[i][j];\n\n\tint A[100][100];\n\trep(i,n) rep(j,n) {\n\t\tif(B[i][j]=='o'){\n\t\t\tA[i][j]=-E[i][j];\n\t\t}\n\t\telse{\n\t\t\tA[i][j]=W[i][j];\n\t\t}\n\t}\n\tans+=Kuhn_Munkres(n,A);\n\n\tbool kesanai[100][100]={};\n\tvector< pair<int,int> > ans_w,ans_e;\n\trep(u,n){\n\t\tint v=match[0][u];\n\t\tif(B[u][v]=='.') ans_w.push_back(make_pair(u,v));\n\t\telse{\n\t\t\tkesanai[u][v]=true;\n\t\t}\n\t}\n\trep(u,n) rep(v,n) if(B[u][v]=='o' && !kesanai[u][v]) ans_e.push_back(make_pair(u,v));\n\n\tprintf(\"%d\\n\",ans);\n\tprintf(\"%d\\n\",ans_w.size()+ans_e.size());\n\trep(i,ans_w.size()) printf(\"%d %d write\\n\",ans_w[i].first+1,ans_w[i].second+1);\n\trep(i,ans_e.size()) printf(\"%d %d erase\\n\",ans_e[i].first+1,ans_e[i].second+1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_V = 111*2;\n\ntypedef pair<int,int> P;\nstruct D {\n  int x,y,t;\n};\nstruct edge {\n  int to,cap,cost,rev,f;\n  D d;\n};\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nconst int inf = 1<<28;\n \nvoid add_edge(int f,int t,int cap,int cost,D d)\n{\n  G[f].push_back((edge){t,cap,cost,(int)G[t].size(),1,d});\n  G[t].push_back((edge){f,0,-cost,(int)G[f].size()-1,0,d});\n}\n\nint min_cost_flow(int s,int t,int f)\n{\n  int res = 0;\n  fill(h,h+V,0);\n  //printf(\"%d %d %d\\n\",s,t,f);\n  while( f > 0 ) {\n    priority_queue<P,vector<P>,greater<P> > q;\n    fill(dist,dist+V,inf);\n    dist[s]=0;\n    q.push(P(0,s));\n    while(!q.empty()) {\n      P p = q.top(); q.pop();\n      int v = p.second;\n      if( dist[v] < p.first ) continue;\n      for( int i = 0; i < int(G[v].size()); i++ ) {\n        edge& e = G[v][i];\n        if( e.cap > 0 && dist[e.to] > dist[v]+e.cost+h[v]-h[e.to] ) {\n          dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          q.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if( dist[t] == inf ) {\n      return -1;\n    }\n    for( int v = 0; v < V; v++ ) h[v] += dist[v];\n    int d = f;\n    for( int v = t; v != s; v = prevv[v] ) {\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    //printf(\"%d %d\\n\",d,f);\n    res += d*h[t];\n    for( int v = t; v != s; v = prevv[v] ) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint n,w[111][111],e[111][111];\nchar f[111][111];\n\nint main(void)\n{\n  scanf(\"%d\",&n);\n  for( int i = 0; i < n; i++ ) {\n    for( int j = 0; j < n; j++ ) scanf(\"%d\",w[i]+j);\n  }\n  for( int i = 0; i < n; i++ ) {\n    for( int j = 0; j < n; j++ ) scanf(\"%d\",e[i]+j);\n  }\n  for( int i = 0; i < n; i++ ) {\n    for( int j = 0; j < n; j++ ) scanf(\" %c\",f[i]+j);\n  }\n  for( int i = 0; i < n; i++ ) {\n    add_edge(n+n,i,1,0,(D){-1,-1,-1});\n    add_edge(n+i,n+n+1,1,0,(D){-1,-1,-1});\n    for( int j = 0; j < n; j++ ) {\n      int s = 0;\n      if( f[i][j] == '.' ) s += w[i][j];\n      for( int jj = 0; jj < n; jj++ ) {\n        if( jj != j && f[i][jj] == 'o' ) {\n          s += e[i][jj];\n        }\n      }\n      for( int ii = 0; ii < n; ii++ ) {\n        if( ii != i && f[ii][j] == 'o' ) {\n          s += e[ii][j];\n          s -= e[ii][j];\n        }\n      }\n      //printf(\"%d \",s);\n      add_edge(i,n+j,1,s,(D){j,i,f[i][j]=='.'});\n    }\n    //puts(\"\");\n  }\n  V=n+n+2;\n  int res = min_cost_flow(n+n,n+n+1,n);\n  printf(\"%d\\n\",res);\n  vector<string> vv;\n  char buf[222];\n  static bool done[111][111] = {};\n  for( int i = 0; i < n+n; i++ ) {\n    for( int j = 0; j < int(G[i].size()); j++ ) {\n      edge &e = G[i][j];\n      if( e.f && e.cap == 0 && e.d.x>=0 ) {\n        //printf(\"%d %d %d\\n\",e.d.x,e.d.y,e.d.t);\n        if( f[e.d.y][e.d.x] == '.' ) {\n          sprintf(buf,\"%d %d write\\n\",e.d.y+1,e.d.x+1);\n          vv.push_back(buf);\n        }\n        done[e.d.y][e.d.x] = true;\n        for( int ii = 0; ii < n; ii++ ) {\n          if( !done[e.d.y][ii] && f[e.d.y][ii] == 'o' ) {\n            done[e.d.y][ii] = true;\n            sprintf(buf,\"%d %d erase\\n\",e.d.y+1,ii+1);\n            vv.push_back(buf);\n          }\n          if( !done[ii][e.d.x] && f[ii][e.d.x] == 'o' ) {\n            done[ii][e.d.x] = true;\n            sprintf(buf,\"%d %d erase\\n\",ii+1,e.d.x+1);\n            vv.push_back(buf);\n          }\n        }\n        //printf(\"%d %d write\\n\",e.d.x+1,e.d.y+1,e.d.t?\"erase\":\"write\");\n      }\n    }\n  }\n  printf(\"%d\\n\",vv.size());\n  for( int i = 0; i < int(vv.size()); i++ ) printf(\"%s\",vv[i].c_str());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100\n#define MAX_V 1000\n#define INF 1e9\nusing namespace std;\nint n,W[100][100],E[100][100];\nstring F[100];\nint N,K;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;     \n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint Biparite_Matching(){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n  int res=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(F[i][j]=='o')res+=E[i][j],add_edge(i,N+j,1,-E[i][j]);\n      else add_edge(i,N+j,1,W[i][j]);    \n  return res+min_cost_flow(s,t,N);\n}\n\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>W[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)cin>>E[i][j];\n  for(int i=0;i<n;i++)cin>>F[i];\n  N=K=n,V=2*n+2;\n  cout<<Biparite_Matching()<<endl;\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')cnt++;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')cnt++;\n  cout<<cnt<<endl;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++)\n      if(G[i][j].cap<=0&&F[i][G[i][j].to-n]=='.')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" write\"<<endl;\n      else if(G[i][j].cap>0&&F[i][G[i][j].to-n]=='o')\n\tcout<<i+1<<\" \"<<G[i][j].to-n+1<<\" erase\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 202\nusing namespace std;\ntypedef pair<int, int> P;\nstruct edge {\n\tint to, cap, cost, rev;\n\tedge(int to_, int cap_, int cost_, int rev_)\n\t\t: to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid AddEdge(int from, int to, int cap, int cost) {\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\n\nint MinimumCostFlow(int s, int t, int f) {\n\tint res = 0;\n\tfill(h, h + V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\th[v] += dist[v];\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tV = n * 2 + 2;\n\tvector<vector<int>> W(n, vector<int>(n)), E(n, vector<int>(n));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> W[i][j];\n\t\t}\n\t\tAddEdge(n * 2, i, 1, 0);\n\t\tAddEdge(n + i, n * 2 + 1, 1, 0);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcin >> E[i][j];\n\t\t}\n\t}\n\tvector<string> s(n);\n\tint def = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (s[i][j] == '.') {\n\t\t\t\tAddEdge(i, n + j, 1, W[i][j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tAddEdge(i, n + j, 1, -E[i][j]);\n\t\t\t\tdef += E[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << MinimumCostFlow(n * 2, n * 2 + 1, n) + def << endl;\n\tint res = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto & e : G[i]) {\n\t\t\tif (e.cap == 1 && e.to - n < n && s[i][e.to - n] != '.') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" erase\" << endl;\n\t\t\t}\n\t\t\telse if (e.cap == 0 && e.to - n < n && s[i][e.to - n] != 'o') {\n\t\t\t\tcout << i + 1 << ' ' << e.to - n + 1 << \" write\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 220\n\nenum Type{\n\tADD,\n\tDELETE,\n};\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,Type arg_type){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttype = arg_type;\n\t}\n\tint row,col;\n\tType type;\n};\n\n\nint V;\nvector<Edge> G[NUM];\nint dist[NUM];\nint pre_node[NUM],pre_edge[NUM];\nint N;\nint W[NUM][NUM],E[NUM][NUM];\nint row_index[NUM],col_index[NUM];\nchar table[NUM][NUM+1];\n\n\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\n\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\twhile(flow > 0){\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(dist[node_id] == BIG_NUM)continue;\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost;\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\treturn -1;\n\t\t}\n\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*dist[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++)scanf(\"%d\",&W[row][col]);\n\t}\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++)scanf(\"%d\",&E[row][col]);\n\n\t}\n\n\tint sum_cost = 0;\n\tfor(int row = 0; row < N; row++){\n\t\tscanf(\"%s\",table[row]);\n\t\tfor(int col = 0; col < N; col++){\n\t\t\tif(table[row][col] == 'o'){\n\t\t\t\tsum_cost += E[row][col];\n\t\t\t}\n\t\t}\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\tfor(int i = 0; i < N; i++){\n\t\trow_index[i] = index;\n\t\tadd_edge(source,row_index[i],1,0);\n\t\tindex++;\n\t}\n\tfor(int i = 0; i < N; i++){\n\t\tcol_index[i] = index;\n\t\tadd_edge(col_index[i],sink,1,0);\n\t\tindex++;\n\t}\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int col = 0; col < N; col++){\n\t\t\tif(table[row][col] == 'o'){\n\t\t\t\tadd_edge(row_index[row],col_index[col],1,-E[row][col]);\n\t\t\t}else{\n\t\t\t\tadd_edge(row_index[row],col_index[col],1,W[row][col]);\n\t\t\t}\n\t\t}\n\t}\n\n\tV = index;\n\n\tint add_cost = min_cost_flow(source,sink,N);\n\n\tprintf(\"%d\\n\",sum_cost+add_cost);\n\n\tint count = 0;\n\n\tqueue<Info> Q;\n\n\tint col;\n\n\tfor(int row = 0; row < N; row++){\n\t\tfor(int i = 0; i < G[row_index[row]].size(); i++){\n\t\t\tcol = G[row_index[row]][i].to-col_index[0];\n\t\t\tif(col < 0)continue;\n\t\t\tif(table[row][col] == 'o' && G[row_index[row]][i].capacity == 1){\n\t\t\t\tQ.push(Info(row,col,DELETE));\n\t\t\t\tcount++;\n\t\t\t}else if(table[row][col] == '.' && G[row_index[row]][i].capacity == 0){\n\t\t\t\tQ.push(Info(row,col,ADD));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",count);\n\n\twhile(!Q.empty()){\n\n\t\tprintf(\"%d %d \",Q.front().row+1,Q.front().col+1);\n\t\tif(Q.front().type == ADD){\n\t\t\tprintf(\"write\\n\");\n\t\t}else{\n\t\t\tprintf(\"erase\\n\");\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n\ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n     G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f, bool negative = false){\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 10000000;\n\n  if(negative){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n\n    bool update = true;\n\n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n        if(dist[v] == inf) continue;\n        for(int i = 0; i < (int)g[v].size(); i++){\n          E &e = g[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n            dist[e.to]  = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update      = true;\n          }\n        }\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n      h[i] = dist[i];\n  }\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n        E &e = g[v][i];\n\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if(dist[t] == inf){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint w[100][100];\nint e[100][100];\nint f[100][100];\nint c[100][100];\n\nint main(){\n  const int n = getInt();\n\n  REP(i,n) REP(j,n)\n    w[i][j] = getInt();\n  REP(i,n) REP(j,n)\n    e[i][j] = getInt();\n\n  REP(i,n){\n    char b[128]; scanf(\"%s\", b);\n    REP(j,n) f[i][j] = (b[j] == 'o' ? 1 : 0);\n  }\n\n  REP(i,n){\n    REP(j,n){\n      int cc = 0;\n\n      REP(k,n){\n        if(f[i][k]  && k != j) cc += e[i][j];\n        if(!f[i][k] && k == j) cc += w[i][j];\n      }\n\n      c[i][j] = cc;\n    }\n  }\n\n  Graph<CostEdge> g(2 + 2 * n);\n  const int start = 2 * n;\n  const int goal  = 2 * n + 1;\n\n  REP(i,n) REP(j,n){\n    g.addEdge(i, n + j, 1, c[i][j]);\n  }\n\n  REP(i,n){\n    g.addEdge(start, i, 1, 0);\n    g.addEdge(n + i, goal, 1, 0);\n  }\n\n  int cost = minCostFlow(g, start, goal, n);\n\n  printf(\"%d\\n\", cost);\n\n  vector<string> ans;\n  const Graph<CostEdge>::G &gg = g.getRowGraph();\n  REP(i,n){\n    int dst = 0;\n    REP(j,n){\n      if(gg[i][j].cap == 0){\n        dst = gg[i][j].to - n;\n      }\n    }\n    REP(j,n){\n      char buff[256];\n      if(f[i][j] && dst != j){\n        sprintf(buff, \"%d %d erase\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n      if(!f[i][j] && dst == j){\n        sprintf(buff, \"%d %d write\", i + 1, j + 1);\n        ans.push_back(buff);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", ans.size());\n  REP(i,ans.size())\n    printf(\"%s\\n\", ans[i].c_str());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_V 514\n#define INF (1<<29)\n \nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int cost, int rev) :\n        to(to), cap(cap), cost(cost), rev(rev) {}\n};\n \nint V;\nvector<Edge> G[MAX_V];\nint dist[MAX_V], prevv[MAX_V], preve[MAX_V];\n \nvoid add_edge(int from, int to, int cap, int cost)\n{\n    G[from].push_back(Edge(to, cap, cost, G[to].size()));\n    G[to].push_back(Edge(from, 0, -cost, G[from].size()-1));\n}\n \nint min_cost_flow(int s, int t, int f)\n{\n    int res = 0;\n    while (f > 0) {\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    bool update = true;\n    while (update) {\n        update = false;\n        for (int v = 0; v < V; v++) {\n        if (dist[v] == INF) continue;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            update = true;\n            }\n        }\n        }\n    }\n    if (dist[t] == INF) return -1;\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n        f -= d;\n    res += d * dist[t];\n    for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = G[prevv[v]][preve[v]];            \n        e.cap -= d;\n        G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n \nint main()\n{\n    int N;\n    cin >> N;\n    vector<vector<int>> W(N, vector<int>(N)), E(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> W[i][j];\n        }\n    }\n \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> E[i][j];\n        }\n    }\n     \n    int sum = 0;\n    vector<vector<char>> F(N, vector<char>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> F[i][j];\n            if (F[i][j] == 'o') {\n                sum += E[i][j];\n            }\n        }\n    }\n \n    int S = 2 * N, T = S + 1;\n    V = T + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(S, i, 1, 0);\n        add_edge(N+i, T, 1, 0);\n    }\n \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (F[i][j] == 'o') {\n                add_edge(i, j + N, 1, -E[i][j]);\n            } else {\n                add_edge(i, j + N, 1, W[i][j]);\n            }\n        }\n    }\n     \n    cout << min_cost_flow(S, T, N) + sum << endl;\n    vector<int> r, c, op;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int k = G[i][j].to - N;\n            if (G[i][j].cap == 0 && F[i][k] == '.' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(0);\n            }\n            if (G[i][j].cap > 0 && F[i][k] == 'o' && G[i][j].to < S) {\n                r.push_back(i+1); c.push_back(k+1); op.push_back(1);\n            }\n        }\n    }\n \n    cout << r.size() << endl;\n    for (int i = 0; i < (int)r.size(); i++) {\n        cout << r[i] << \" \" << c[i] << \" \";\n        cout << (op[i] == 0 ? \"write\" : \"erase\") << endl;\n    }    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\n\n// http://www.cse.ust.hk/~golin/COMP572/Notes/Matching.pdf\n\nvector<int> min_cost_match(vector< vector<int> > a) {\n\tint n=a.size(),m=a[0].size();\n\tvector<int> left(n,-1), right(m,-1);\n\tvector<int> ofsleft(n,0), ofsright(m,0);\n\tauto cost=[&](int i,int j){ return a[i][j]+ofsleft[i]+ofsright[j];};\n\n\trep(r,n){\n\t\tvector<bool> s(n,false),t(m,false);\n\t\tvector<int> trace(m,-1), edge(m,r);\n\t\ts[r]=true;\n\n\t\tint b=-1;\n\t\twhile(1){\n\t\t\tint d=numeric_limits<int>::max();\n\t\t\trep(j,m) if(!t[j]) d=min(d,cost(edge[j],j));\n\t\t\trep(i,n) if(s[i]) ofsleft[i]-=d;\n\t\t\trep(j,m) if(t[j]) ofsright[j]+=d;\n\n\t\t\trep(j,m) if(!t[j]&&cost(edge[j],j)==0) b=j;\n\t\t\ttrace[b]=edge[b];\n\t\t\tint c=right[b];\n\t\t\tif(c<0) break;\n\t\t\ts[c]=t[b]=true;\n\t\t\trep(j,m) if(cost(c,j)<cost(edge[j],j)) edge[j]=c;\n\t\t}\n\t\twhile(b>=0){\n\t\t\tint a=trace[b],nb=left[a];\n\t\t\tright[b]=a,left[a]=b,b=nb;\n\t\t}\n\t}\n\treturn left;\n}\n\nint n;\n\nint w[110][110],e[110][110];\nstring s[110];\nbool op[110][110];\n\nint row[110],col[110];\n\nvoid output(int i,int j,int type){\n\tcout << i+1 << \" \" << j+1 << \" \";\n\tif(type)\n\t\tcout << \"write\" << endl;\n\telse\n\t\tcout << \"erase\" << endl;\n\treturn;\n}\n\nint main(void){\n\tcin >> n;\n\trep(i,n)rep(j,n) cin >> w[i][j];\n\trep(i,n)rep(j,n) cin >> e[i][j];\n\trep(i,n) cin >> s[i];\n\n\trep(i,n){\n\t\trow[i]=0,col[i]=0;\n\t\trep(j,n) if(s[i][j]=='o') row[i]+=e[i][j];\n\t\trep(j,n) if(s[j][i]=='o') col[i]+=e[j][i];\n\t}\n\n\tvector<vector<int>> cost(n,vector<int>(n,0));\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='o')\n\t\t\tcost[i][j]=row[i]+col[j]-2*e[i][j];\n\t\telse\n\t\t\tcost[i][j]=row[i]+row[j]+2*w[i][j];\n\t}\n\n\tvector<int> match=min_cost_match(cost);\n\trep(i,n) op[i][match[i]]=true;\n\n\tint mincost=0,cnt=0;\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='.'&&op[i][j]==true) mincost+=w[i][j],cnt++;\n\t\tif(s[i][j]=='o'&&op[i][j]==false) mincost+=e[i][j],cnt++;\n\t}\n\tcout << mincost << endl;\n\tcout << cnt << endl;\n\trep(i,n)rep(j,n){\n\t\tif(s[i][j]=='.'&&op[i][j]==true) output(i,j,1);\n\t\tif(s[i][j]=='o'&&op[i][j]==false) output(i,j,0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\nusing namespace std;\nusing Weight = int;\nusing Array = vector<int>;\nusing Matrix = vector<Array>;\nconstexpr int INF = 1000000000;\n\n\npair<Weight, Array> hungarian(const Matrix &m) {\n  int n = m.size();\n  int p, q;\n  Array fx(n, INF), fy(n, 0);\n  vector<int> x(n, -1), y(n, -1);\n  //REP(i,n)REP(j,n) fx[i] = max(fx[i], m[i][j]);\n  for (int i = 0; i < n; ) {\n    vector<int> t(n, -1), s(n+1, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == m[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p)\n              y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      Weight d = INF;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - m[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else ++i;\n  }\n  Weight ret = 0;\n  for (int i = 0; i < n; ++i) ret += m[i][x[i]];\n  return make_pair(ret, x);\n}\n\nint main() {\n  int n;\n  cin>>n;\n  Matrix w(n, Array(n));\n  REP(i,n)REP(j,n) cin >> w[i][j];\n  Matrix e(n, Array(n));\n  REP(i,n)REP(j,n) cin >> e[i][j];\n  vector<string> m(n);\n  Matrix mat(n, Array(n));\n  int cost = 0;\n  REP(i,n) {\n    cin>>m[i];\n    REP(j,n) {\n      if (m[i][j] == 'o') {\n        mat[i][j] = 1000 + e[i][j];\n        cost += e[i][j];\n      } else {\n        mat[i][j] = 1000 - w[i][j];\n      }\n    }\n  }\n  auto res = hungarian(mat);\n  cout << (n*1000 - res.first + cost) << endl;\n  int cnt = 0;\n  stringstream ss;\n  REP(i,n)REP(j,n) {\n    if (m[i][j] == 'o') {\n      if (res.second[i] != j) {\n        ss << (i+1) << ' ' << (j+1) << \" erase\" << endl;\n        ++cnt;\n      }\n    } else {\n      if (res.second[i] == j) {\n        ss << (i+1) << ' ' << (j+1) << \" write\" << endl;\n        ++cnt;\n      }\n    }\n  }\n  cout << cnt << endl;\n  cout << ss.str() << flush;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n   \nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nconst int INF=1e9+7;\n \nstruct edge{\n    int to, cap, cost, rev;\n};\n\nint n;\nint V;\nvector<edge> g[202];\nint h[202];\nint dist[202];\nint prevv[202], preve[202];\n \nvoid add_edge(int from, int to, int cap, int cost){\n    edge e;\n    e.to=to, e.cap=cap, e.cost=cost, e.rev=g[to].size();\n    g[from].push_back(e);\n    e.to=from, e.cap=0, e.cost=-cost, e.rev=g[from].size()-1;\n    g[to].push_back(e);\n}\n \nint min_cost_flow(int s, int t, int f){\n    int res=0;\n    fill(h, h+V, 0);\n    while(f>0){\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist+V, INF);\n        dist[s]=0;\n        que.push(P(0, s));\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n            int v=p.second;\n            if(dist[v]<p.first) continue;\n            for(int i=0; i<g[v].size(); i++){\n                edge &e=g[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        for(int v=0; v<V; v++) h[v]+=dist[v];\n        if(dist[t]==INF) return -1;\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]){\n            d=min(d, g[prevv[v]][preve[v]].cap);\n        }\n\t\tf-=d;\n        res+=d*h[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n\tcin>>n;\n\tint w[100][100], e[100][100];\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcin>>w[i][j];\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tcin>>e[i][j];\n\t\t}\n\t}\n\tstring f[100];\n\tfor(int i=0; i<n; i++) cin>>f[i];\n\tV=2*n+2;\n\tint ans=0;\n\tfor(int i=0; i<n; i++) add_edge(V-2, i, 1, 0);\n\tfor(int j=0; j<n; j++) add_edge(j+n, V-1, 1, 0);\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(f[i][j]=='.'){\n\t\t\t\tadd_edge(i, j+n, 1, w[i][j]);\n\t\t\t}else{\n\t\t\t\tadd_edge(i, j+n, 1, -e[i][j]);\n\t\t\t\tans+=e[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tans+=min_cost_flow(V-2, V-1, n);\n\tcout<<ans<<endl;\n\tvector<int> r, c, op;\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<g[i].size(); j++){\n\t\t\tif(g[i][j].to>=2*n) continue;\n\t\t\tif((g[i][j].cap==0 && f[i][g[i][j].to-n]=='.') || (g[i][j].cap>0 && f[i][g[i][j].to-n]=='o')){\n\t\t\t\tr.push_back(i+1);\n\t\t\t\tc.push_back(g[i][j].to-n+1);\n\t\t\t\tif(f[i][g[i][j].to-n]=='.') op.push_back(1);\n\t\t\t\telse op.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<r.size()<<endl;\n\tfor(int i=0; i<r.size(); i++){\n\t\tif(op[i]) cout<<r[i]<<\" \"<<c[i]<<\" write\"<<endl;\n\t\telse cout<<r[i]<<\" \"<<c[i]<<\" erase\"<<endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2429 Attack the Moles\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 2000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x01010101\n#define MAX 210\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE *edge[MAX]; int hi[MAX], lim[MAX];\nint V;\t\t\t\t// 頂点数\nint potential[MAX], min_cost[MAX], prevv[MAX], preve[MAX];\n\nvoid check_lim(int a)\n{\n\tif (hi[a] < lim[a]) return;\n\tif (lim[a] == 0) {\n\t\tlim[a] = 4, hi[a] = 0;\n\t\tedge[a] = malloc(sizeof(EDGE) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tint k = lim[a];\n\t\tif (k > 512) k = 512;\n\t\tlim[a] += k;\n\t\tedge[a] = realloc(edge[a], sizeof(EDGE) *lim[a]);\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tcheck_lim(from), check_lim(to);\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int S, int T, int F)\n{\n\tint i, s, ns, t, nt, ret;\n\tEDGE *ep;\n\n\tret = 0;\n//\tmemset(potential, 0, V << 2);\n  \n\twhile (F > 0) {\n\t\tmemset(min_cost, INF, V << 2);\n\t\tqsize = 0;\n\t\tenq(S, 0), min_cost[S] = 0;\n  \n\t\twhile (qsize) {\n\t\t\ts = que[0].s, t = que[0].t, deq();\n\t\t\tif (min_cost[s] < t) continue;\n\n\t\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\t\tep = &edge[s][i], ns = ep->to;\n\t\t\t\tnt = t + ep->cost + potential[s] - potential[ns];\n\t\t\t\tif(ep->cap > 0 && min_cost[ns] > nt) {\n\t\t\t\t\tmin_cost[ns] = nt;\n\t\t\t\t\tprevv[ns] = s, preve[ns] = i;\n\t\t\t\t\tenq(ns, nt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (min_cost[T] == INF) return -1;\n\t\tfor (s = 0; s < V; s++) potential[s] += min_cost[s];\n\n\t\tt = F;\n\t\tfor (s = T; s != S; s = prevv[s]) {\n\t\t\tep = &edge[prevv[s]][preve[s]];\n\t\t\tif (t > ep->cap) t = ep->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * potential[T];\n\t\tfor (s = T; s != S; s = prevv[s]) {\n\t\t\tep = &edge[prevv[s]][preve[s]];\n\t\t\tep->cap -= t;\n\t\t\tedge[s][ep->rev].cap += t;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\nwhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint  W[105][105], E[105][105]; \nchar F[105][105], G[105][105];\nint  ans[10002][2];\n\nint main()\n{\n\tint n, r, c, s, i;\n\tint source, sink;\n\tEDGE *ep;\n\n\tn = in();\n\tfor (r = 0; r < n; r++) for (c = 0; c < n; c++) W[r][c] = in();\n\tfor (r = 0; r < n; r++) for (c = 0; c < n; c++) E[r][c] = in();\n\ts = 0; for (r = 0; r < n; r++) {\n\t\tfgets(F[r], 105, stdin);\n\t\tfor (c = 0; c < n; c++) if (F[r][c] == 'o') s += E[r][c];\n\t}\n\n\tsource = n+n, sink = source+1, V = sink+1;\n\n\tfor (r = 0; r < n; r++) add_edge(source, r, 1, 0), add_edge(r+n, sink, 1, 0);\n\tfor (r = 0; r < n; r++) for (c = 0; c < n; c++) {\n\t\tif (F[r][c] == 'o') add_edge(r, c+n, 1, -E[r][c]);\n\t\telse                add_edge(r, c+n, 1, W[r][c]);\n\t}\n \n\tprintf(\"%d\\n\", minCostFlow(source, sink, n) + s);\n\n\tmemset(G, '.', sizeof(G));\n\tfor (r = 0; r < n; r++) {\n\t\tfor (i = 0; i < hi[r]; i++) {\n\t\t\tep = &edge[r][i];\n\t\t\tif (ep->cap == 0 && ep->to >= n && ep->to < 2*n) G[r][ep->to - n] = 'o';\n\t\t}\n\t}\n\n\ts = 0;\n\tfor (r = 0; r < n; r++) for (c = 0; c < n; c++) {\n\t\tif (F[r][c] != G[r][c]) ans[s][0] = r, ans[s++][1] = c;\n\t}\n\n\tprintf(\"%d\\n\", s);\n\tfor (i = 0; i < s; i++) {\n\t\tr = ans[i][0], c = ans[i][1];\n\t\tif (F[r][c] == 'o') printf(\"%d %d erase\\n\", r+1, c+1);\n\t\telse                printf(\"%d %d write\\n\", r+1, c+1);\n\t}\n\treturn 0;\n}\n \n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\nimport kotlin.collections.ArrayList\n\n\nclass Edge(val to: Int, val pair: Int, val cost: Int, var hasFlow: Boolean)\nfun Array<ArrayList<Edge>>.addEdge(from: Int, to: Int, cost: Int): Unit {\n    this[from].add(Edge(to, this[to].size, cost, true))\n    this[to].add(Edge(from, this[from].size - 1, -cost, false))\n}\nfun bellmanFord(nodes: Array<out List<Edge>>, start: Int): IntArray {\n    val memo = IntArray(nodes.size){Int.MAX_VALUE shr 1}.also{it[start] = 0}\n    repeat(nodes.size) {\n        for (i in nodes.indices) {\n            for (next in nodes[i]) if (next.hasFlow) {\n                if (memo[next.to] > memo[i] + next.cost) {\n                    memo[next.to] = memo[i] + next.cost\n                }\n            }\n        }\n    }\n    return memo\n}\nfun minCostMatching(writeCosts: List<List<Int>>, eraseCosts: List<List<Int>>, currentState: List<String>): Pair<Int, List<String>> {\n    val nodes = Array(writeCosts.size + writeCosts.first().size + 2){ArrayList<Edge>()}\n    val start = nodes.size - 2\n    val goal = nodes.size - 1\n    for (i in writeCosts.indices) {\n        for (j in writeCosts[i].indices) {\n            when (currentState[i][j]) {\n                'o' -> {\n                    nodes.addEdge(i, j + writeCosts.size, -eraseCosts[i][j])\n                }\n                '.' -> {\n                    nodes.addEdge(i, j + writeCosts.size, writeCosts[i][j])\n                }\n                else -> TODO()\n            }\n        }\n    }\n    for (i in writeCosts.indices) {\n        nodes.addEdge(start, i, 0)\n    }\n    for (j in writeCosts.first().indices) {\n        nodes.addEdge(j + writeCosts.size, goal, 0)\n    }\n    val potential = bellmanFord(nodes, start).also{it[goal] = 0}\n    val minCost = IntArray(nodes.size){Int.MAX_VALUE}\n    val queue = PriorityQueue<Pair<Int, Int>>(compareBy(Pair<*, Int>::second))\n    val prevEdge = Array(nodes.size){nodes.first().first()}\n    var result = eraseCosts.indices.sumBy{i -> eraseCosts[i].indices.filter{j -> currentState[i][j] == 'o'}.sumBy{j -> eraseCosts[i][j]}}\n    repeat(writeCosts.size) {\n        minCost.run{\n            fill(Int.MAX_VALUE)\n            this[start] = 0\n        }\n        queue.run{\n            clear()\n            add(start to 0)\n        }\n        while (queue.isNotEmpty()) {\n            val (current, cost) = queue.poll()\n            for (e in nodes[current]) if (e.hasFlow) {\n                if (minCost[e.to] > potential[current] + e.cost - potential[e.to] + cost) {\n                    minCost[e.to] = potential[current] + e.cost - potential[e.to] + cost\n                    queue.add(e.to to minCost[e.to])\n                    prevEdge[e.to] = e\n                }\n            }\n        }\n        result += minCost[goal]\n        var last = goal\n        while(last != start) {\n            val edge = prevEdge[last]\n            edge.hasFlow = false\n            nodes[edge.to][edge.pair].hasFlow = true\n            last = nodes[edge.to][edge.pair].to\n        }\n        for (i in 0 until start) {\n            potential[i] += minCost[i]\n        }\n    }\n    val state = List(currentState.size){CharArray(currentState.first().length){'.'}}\n    for (i in 0 until currentState.size) {\n        state[i][nodes[i].find{ !it.hasFlow }!!.to - currentState.size] = 'o'\n    }\n    return result to state.map{it.joinToString(\"\")}\n}\n\nfun main(args: Array<String>?): Unit {\n    val n = readLine()!!.trim().toInt()\n    val writeCosts = List(n){ readLine()!!.trim().split(' ').map(String::toInt)}\n    val eraseCosts = List(n){ readLine()!!.trim().split(' ').map(String::toInt)}\n    val currentState = List(n){ readLine()!!.trim()}\n    val (minCost, distState) = minCostMatching(writeCosts, eraseCosts, currentState)\n    println(minCost)\n    (0 until n).flatMap{i -> (0 until n).filter{j -> currentState[i][j] != distState[i][j]}.map{i to it}}.let{\n        println(it.size)\n        for ((i, j) in it) {\n            when(currentState[i][j]) {\n                'o' -> println(\"${i + 1} ${j + 1} erase\")\n                '.' -> println(\"${i + 1} ${j + 1} write\")\n                else -> TODO()\n            }\n        }\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tint[][] W = new int[N][N];\n\t\tint[][] E = new int[N][N];\n\t\tboolean[][] F = new boolean[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tW[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tE[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar[] line = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tF[i][j] = line[j] == 'o';\n\t\t\t}\n\t\t}\n\t\tMinCostFlow mcf = new MinCostFlow(2 * N + 2);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmcf.addEdge(0, i + 1, 0, 1);\n\t\t\tmcf.addEdge(N + 1 + i, 2 * N + 1, 0, 1);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint cost = F[i][j] ? 0 : 2 * W[i][j];\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (k != j && F[i][k]) cost += E[i][k];\n\t\t\t\t\tif (k != i && F[k][j]) cost += E[k][j];\n\t\t\t\t}\n\t\t\t\tmcf.addEdge(i + 1, N + 1 + j, cost, 1);\n\t\t\t}\n\t\t}\n\t\tint flow = mcf.calc(N);\n\t\tSystem.out.println(flow / 2);\n\t\tArrayList<Integer> op = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (mcf.cap[i + 1][N + 1 + j] == 0) {\n\t\t\t\t\tif (!F[i][j]) op.add((i << 8) + j);\n\t\t\t\t} else {\n\t\t\t\t\tif (F[i][j]) op.add((i << 8) + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(op.size());\n\t\tfor (int p : op) {\n\t\t\tint r = p >> 8;\n\t\t\tint c = p & 0xFF;\n\t\t\tSystem.out.println((r+1) + \" \" + (c+1) + \" \" + (F[r][c] ? \"erase\" : \"write\"));\n\t\t}\n\t}\n\n\tstatic class MinCostFlow {\n\t\tint size;\n\t\tint[][] cost;\n\t\tint[][] cap;\n\n\t\tMinCostFlow(int size) {\n\t\t\tthis.size = size;\n\t\t\tcost = new int[size][size];\n\t\t\tcap = new int[size][size];\n\t\t}\n\n\t\tvoid addEdge(int from, int to, int c, int capacity) {\n\t\t\tcost[from][to] = c;\n\t\t\tcap[from][to] = capacity;\n\t\t\tcost[to][from] = -c;\n\t\t}\n\n\t\tint calc(int flow) {\n\t\t\tfinal int INF = 1 << 25;\n\t\t\tint total = 0;\n\t\t\tint[] h = new int[size];\n\t\t\tArrays.fill(h, 0);\n\t\t\tint[] prev = new int[size];\n\t\t\twhile (flow > 0) {\n\t\t\t\tint[] dist = new int[size];\n\t\t\t\tArrays.fill(dist, INF);\n\t\t\t\tdist[0] = 0;\n\t\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\t\tq.add(new State(0, dist[0]));\n\t\t\t\twhile (!q.isEmpty()) {\n\t\t\t\t\tState st = q.poll();\n\t\t\t\t\tif (st.cost > dist[st.v]) continue;\n\t\t\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\t\t\tif (cap[st.v][i] == 0) continue;\n\t\t\t\t\t\tint nCost = dist[st.v] + cost[st.v][i] + h[st.v] - h[i];\n\t\t\t\t\t\tif (dist[i] > nCost) {\n\t\t\t\t\t\t\tdist[i] = nCost;\n\t\t\t\t\t\t\tq.add(new State(i, nCost));\n\t\t\t\t\t\t\tprev[i] = st.v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dist[size - 1] == INF) break;\n\t\t\t\tfor (int i = 0; i < size; ++i) {\n\t\t\t\t\th[i] += dist[i];\n\t\t\t\t}\n\t\t\t\tint f = Integer.MAX_VALUE;\n\t\t\t\tfor (int pos = size - 1; pos != 0; pos = prev[pos]) {\n\t\t\t\t\tf = Math.min(f, cap[prev[pos]][pos]);\n\t\t\t\t}\n\t\t\t\tfor (int pos = size - 1; pos != 0; pos = prev[pos]) {\n\t\t\t\t\tcap[prev[pos]][pos] -= f;\n\t\t\t\t\tcap[pos][prev[pos]] += f;\n\t\t\t\t}\n\t\t\t\ttotal += h[size - 1] * f;\n\t\t\t\tflow -= f;\n\t\t\t}\n\t\t\treturn total;\n\t\t}\n\n\t\tstatic class State implements Comparable<State> {\n\t\t\tint v;\n\t\t\tint cost;\n\n\t\t\tpublic State(int v, int cost) {\n\t\t\t\tthis.v = v;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\n\t\t\tpublic int compareTo(State o) {\n\t\t\t\treturn this.cost - o.cost;\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// marukaite\n// 2012/10/02\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[][] w, e;\n\tint[][] a;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tw=new int[n][n];\n\t\te=new int[n][n];\n\t\ta=new int[n][n];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tw[j][i]=sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\te[j][i]=sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ta[j][i]=s.charAt(i)=='o'?1:0;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tV s=new V(-1), t=new V(-1);\n\t\tV[] us=new V[n]; // x\n\t\tV[] vs=new V[n]; // y\n\t\tfor(int i=0; i<n; i++){\n\t\t\tus[i]=new V(i);\n\t\t\tvs[i]=new V(i);\n\t\t}\n\n\t\tint erase=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\terase+=e[j][i];\n\t\t\t\t\tw[j][i]=-e[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tus[i].add(vs[j], 1, w[j][i]);\n\t\t\t}\n\t\t\ts.add(us[i], 1, 0);\n\t\t\tvs[i].add(t, 1, 0);\n\t\t}\n\t\tArrayList<V> list=new ArrayList<V>();\n\t\tlist.add(s);\n\t\tlist.add(t);\n\t\tlist.addAll(asList(us));\n\t\tlist.addAll(asList(vs));\n\n\t\tint mcf=minCostFlow(list.toArray(new V[0]), s, t, n);\n\n\t\tint[][] b=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(E e : us[i].es){\n\t\t\t\tif(e.cap==0){\n\t\t\t\t\t// write\n\t\t\t\t\tb[e.to.id][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb=new StringBuilder();\n\t\tint count=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(a[j][i]==0&&b[j][i]==1){\n\t\t\t\t\tsb.append(j+1);\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t\tsb.append(i+1);\n\t\t\t\t\tsb.append(\" write\\n\");\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tif(a[j][i]==1&&b[j][i]==0){\n\t\t\t\t\tsb.append(j+1);\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t\tsb.append(i+1);\n\t\t\t\t\tsb.append(\" erase\\n\");\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln((erase+mcf)+\"\");\n\t\tprintln(count+\"\");\n\t\tprint(sb.toString());\n\t}\n\n\tint minCostFlow(V[] vs, V s, V t, int flow){\n\t\tint res=0;\n\t\twhile(flow>0){\n\t\t\tfor(V v : vs)\n\t\t\t\tv.min=INF;\n\t\t\tPriorityQueue<E> que=new PriorityQueue<E>();\n\t\t\ts.min=0;\n\t\t\tque.offer(new E(s, 0, 0));\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tE crt=que.poll();\n\t\t\t\tif(crt.cost==crt.to.min){\n\t\t\t\t\tfor(E e : crt.to.es){\n\t\t\t\t\t\tint tmp=crt.cost+e.cost+crt.to.h-e.to.h;\n\t\t\t\t\t\tif(e.cap>0&&e.to.min>tmp){\n\t\t\t\t\t\t\te.to.min=tmp;\n\t\t\t\t\t\t\te.to.prev=e;\n\t\t\t\t\t\t\tque.offer(new E(e.to, 0, e.to.min));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.min==INF)\n\t\t\t\treturn -1;\n\t\t\tint d=flow;\n\t\t\tfor(E e=t.prev; e!=null; e=e.rev.to.prev){\n\t\t\t\td=min(d, e.cap);\n\t\t\t}\n\t\t\tfor(E e=t.prev; e!=null; e=e.rev.to.prev){\n\t\t\t\tres+=d*e.cost;\n\t\t\t\te.cap-=d;\n\t\t\t\te.rev.cap+=d;\n\t\t\t}\n\t\t\tflow-=d;\n\t\t\tfor(V v : vs)\n\t\t\t\tv.h+=v.min;\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass V{\n\t\tArrayList<E> es=new ArrayList<E>();\n\t\tE prev;\n\t\tint min, h;\n\t\tint id;\n\n\t\tV(int id){\n\t\t\tthis.id=id;\n\t\t}\n\n\t\tvoid add(V to, int cap, int cost){\n\t\t\tE e=new E(to, cap, cost), rev=new E(this, 0, -cost);\n\t\t\te.rev=rev;\n\t\t\trev.rev=e;\n\t\t\tes.add(e);\n\t\t\tto.es.add(rev);\n\t\t}\n\t}\n\n\tclass E implements Comparable<E>{\n\t\tV to;\n\t\tE rev;\n\t\tint cap, cost;\n\n\t\tE(V to, int cap, int cost){\n\t\t\tthis.to=to;\n\t\t\tthis.cap=cap;\n\t\t\tthis.cost=cost;\n\t\t}\n\n\t\tpublic int compareTo(E o){\n\t\t\treturn cost-o.cost;\n\t\t}\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[][] w, e;\n\tint[][] a;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tw=new int[n][n];\n\t\te=new int[n][n];\n\t\ta=new int[n][n];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tw[j][i]=sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\te[j][i]=sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tString s=sc.next();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\ta[j][i]=s.charAt(i)=='o'?1:0;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tV s=new V(-1), t=new V(-1);\n\t\tV[] us=new V[n]; // x\n\t\tV[] vs=new V[n]; // y\n\t\tfor(int i=0; i<n; i++){\n\t\t\tus[i]=new V(i);\n\t\t\tvs[i]=new V(i);\n\t\t}\n\t\t// とりあえずぜんぶけす\n\t\tint erase=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(a[j][i]==1){\n\t\t\t\t\terase+=e[j][i];\n\t\t\t\t\tw[j][i]=-e[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tus[i].add(vs[j], 1, w[j][i]);\n\t\t\t}\n\t\t\t// s->us\n\t\t\ts.add(us[i], 1, 0);\n\t\t\tvs[i].add(t, 1, 0);\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n//\t\t\t\tdebug(i, j, us[i].es.size());\n\t\t\t}\n\t\t}\n\t\tArrayList<V> list=new ArrayList<V>();\n\t\tlist.add(s);\n\t\tlist.add(t);\n\t\tlist.addAll(asList(us));\n\t\tlist.addAll(asList(vs));\n//\t\tdebug(\"erase\", erase);\n\t\tint mcf=minCostFlow(list.toArray(new V[0]), s, t, n);\n\t\tint[][]b=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t// us[i]\n\t\t\tfor(E e : us[i].es){\n\t\t\t\tif(e.cap==0){\n\t\t\t\t\t// 書いた\n\t\t\t\t\tb[e.to.id][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb=new StringBuilder();\n\t\tint count=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(a[j][i]==0&&b[j][i]==1){\n\t\t\t\t\tsb.append(j+1);\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t\tsb.append(i+1);\n\t\t\t\t\tsb.append(\" write\\n\");\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tif(a[j][i]==1&&b[j][i]==0){\n\t\t\t\t\tsb.append(j+1);\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t\tsb.append(i+1);\n\t\t\t\t\tsb.append(\" erase\\n\");\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n//\t\t\tdebug(i,b[i]);\n\t\t}\n\t\tprintln((erase+mcf)+\"\");\n\t\tprintln(count+\"\");\n\t\tprint(sb.toString());\n\t}\n\n\tint minCostFlow(V[] vs, V s, V t, int flow){\n\t\tint res=0;\n\t\twhile(flow>0){\n\t\t\tfor(V v : vs)\n\t\t\t\tv.min=INF;\n\t\t\tPriorityQueue<E> que=new PriorityQueue<E>();\n\t\t\ts.min=0;\n\t\t\tque.offer(new E(s, 0, 0));\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tE crt=que.poll();\n\t\t\t\tif(crt.cost==crt.to.min){\n\t\t\t\t\tfor(E e : crt.to.es){\n\t\t\t\t\t\tint tmp=crt.cost+e.cost+crt.to.h-e.to.h;\n\t\t\t\t\t\tif(e.cap>0&&e.to.min>tmp){\n\t\t\t\t\t\t\te.to.min=tmp;\n\t\t\t\t\t\t\te.to.prev=e;\n\t\t\t\t\t\t\tque.offer(new E(e.to, 0, e.to.min));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.min==INF)\n\t\t\t\treturn -1;\n\t\t\tint d=flow;\n\t\t\tfor(E e=t.prev; e!=null; e=e.rev.to.prev){\n\t\t\t\td=min(d, e.cap);\n\t\t\t}\n\t\t\tfor(E e=t.prev; e!=null; e=e.rev.to.prev){\n\t\t\t\tres+=d*e.cost;\n\t\t\t\te.cap-=d;\n\t\t\t\te.rev.cap+=d;\n\t\t\t}\n\t\t\tflow-=d;\n\t\t\tfor(V v : vs)\n\t\t\t\tv.h+=v.min;\n\t\t}\n\t\treturn res;\n\t}\n\n\tclass V{\n\t\tArrayList<E> es=new ArrayList<E>();\n\t\tE prev;\n\t\tint min, h;\n\t\tint id;\n\n\t\tV(int id){\n\t\t\tthis.id=id;\n\t\t}\n\n\t\tvoid add(V to, int cap, int cost){\n\t\t\tE e=new E(to, cap, cost), rev=new E(this, 0, -cost);\n\t\t\te.rev=rev;\n\t\t\trev.rev=e;\n\t\t\tes.add(e);\n\t\t\tto.es.add(rev);\n\t\t}\n\t}\n\n\tclass E implements Comparable<E>{\n\t\tV to;\n\t\tE rev;\n\t\tint cap, cost;\n\n\t\tE(V to, int cap, int cost){\n\t\t\tthis.to=to;\n\t\t\tthis.cap=cap;\n\t\t\tthis.cost=cost;\n\t\t}\n\n\t\tpublic int compareTo(E o){\n\t\t\treturn cost-o.cost;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar n=sc.I;\n\t\tvar a=sc.Arr(n,()=>sc.Ia);\n\t\tvar b=sc.Arr(n,()=>sc.Ia);\n\t\tvar t=sc.Arr(n,()=>sc.S);\n\t\tint ans=0;\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tfor(int j = 0;j<n;j++) {\n\t\t\t\tif(t[i][j]=='o'){ans+=b[i][j];}\n\t\t\t}\n\t\t}\n\t\tint g=n*2+1;\n\t\tvar fl=new Mcfp(g+1,n*n+n*2);\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tfl.Edge(g-1,i,1,0);\n\t\t\tfl.Edge(n+i,g,1,0);\n\t\t\tfor(int j = 0;j<n;j++) {\n\t\t\t\tint c=t[i][j]!='o'?a[i][j]:-b[i][j];\n\t\t\t\tfl.Edge(i,n+j,1,c);\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",ans+fl.Pd2(g-1,g,n));\n\t\tint z=0;\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfl.Th((v1,v2)=>{\n\t\t\tif(v1!=g-1&&v2!=g){\n\t\t\t\tif(t[v1][v2-n]!='o'){\n\t\t\t\t\tz++;\n\t\t\t\t\tsb.Append(v1+1).Append(\" \").Append(v2-n+1).Append(\" write\\n\");\n\t\t\t\t}\n\t\t\t\ta[v1][v2-n]=-1;\n\t\t\t}\n\t\t});\n\t\tfor(int i = 0;i<n;i++) {\n\t\t\tfor(int j = 0;j<n;j++) {\n\t\t\t\tif(t[i][j]=='o'&&a[i][j]!=-1){\n\t\t\t\t\tz++;\n\t\t\t\t\tsb.Append(i+1).Append(\" \").Append(j+1).Append(\" erase\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",z);\n\t\tConsole.Write(sb);\n\t}\n}\npublic class Mcfp{\n\tprivate List<int>[] li;\n\tprivate int[][] h,pt;\n\tprivate int[] z,l,r,u;\n\tprivate bool[] b1,b2;\n\tprivate int n,p=0;\n\tprivate const int inf=int.MaxValue;\n\tpublic Mcfp(int n,int m){\n\t\tthis.n=n;\n\t\tm<<=1;\n\t\tli=new List<int>[n];\n\t\tz=new int[n];\n\t\tl=new int[n];\n\t\tr=new int[n];\n\t\tu=new int[n];\n\t\th=new int[m][];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\tz[i]=int.MaxValue;\n\t\t}\n\t}\n\tpublic void Edge(int a,int b,int e,int c){\n\t\tif(a==b){return;}\n\t\tli[a].Add(p);\n\t\tli[b].Add(p+1);\n\t\th[p]=new int[]{b,e,c};\n\t\th[p+1]=new int[]{a,0,-c};\n\t\tp+=2;\n\t}\n\tpublic void Th(Action<int,int> f){\n\t\tfor(int i = 0;i<h.Length;i+=2) {\n\t\t\tif(h[i+1][1]!=0){f(h[i+1][0],h[i][0]);}\n\t\t}\n\t}\n\tpublic long Pd2(int s,int t,int c){\n\t\tlong ans=0,d=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tz[i]=int.MaxValue;\n\t\t\tu[i]=int.MaxValue;\n\t\t}\n\t\tz[s]=0;\n\t\tl[s]=-1;\n\t\tb1=new bool[n];\n\t\tpt=new int[][]{new int[n],new int[n]};\n\t\tint m=h.Length;\n\t\tbool bo=true;\n\t\tfor(int i=0;bo&&i<n;i++){\n\t\t\tbo=false;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(h[j][1]!=0&&z[h[j^1][0]]!=int.MaxValue&&z[h[j][0]]>z[h[j^1][0]]+h[j][2]){\n\t\t\t\t\tz[h[j][0]]=z[h[j^1][0]]+h[j][2];\n\t\t\t\t\tpt[0][h[j][0]]=z[h[j][0]];\n\t\t\t\t\tl[h[j][0]]=h[j^1][0];\n\t\t\t\t\tr[h[j][0]]=j;\n\t\t\t\t\tu[h[j][0]]=Min(u[h[j^1][0]],h[j][1]);\n\t\t\t\t\tbo=true;\n\t\t\t\t\tif(i==n){b1[h[j][0]]=true;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tu[t]=(int)Min(c-d,u[t]);\n\t\tfor(int i = t;i!=s;i=l[i]) {\n\t\t\tans+=u[t]*h[r[i]][2];\n\t\t\th[r[i]][1]-=u[t];\n\t\t\th[r[i]^1][1]+=u[t];\n\t\t}\n\t\td+=u[t];\n\t\tint k=1;\n\t\tif(c==d){return ans;}\n\t\twhile(c>d){\n\t\t\tb1=new bool[n];\n\t\t\tb2=new bool[n];\n\t\t\tu=new int[n];\n\t\t\tvar pq=new Pq<Mo<int>>(32,true);\n\t\t\tz[s]=0;\n\t\t\tl[s]=-1;\n\t\t\tu[s]=int.MaxValue;\n\t\t\tb2[s]=true;\n\t\t\tpq.Push(new Mo<int>(0,s));\n\t\t\tbo=false;\n\t\t\twhile(pq.cnt>0){\n\t\t\t\tvar e=pq.Top;\n\t\t\t\tpq.Pop();\n\t\t\t\tif(b1[e.d]){continue;}\n\t\t\t\tb1[e.d]=true;\n\t\t\t\tif(e.d==t){bo=true;}\n\t\t\t\tfor(int i=0;i<li[e.d].Count;i++){\n\t\t\t\t\tif(h[li[e.d][i]][1]==0){continue;}\n\t\t\t\t\tint co=e.n+h[li[e.d][i]][2]-pt[k^1][h[li[e.d][i]][0]]+pt[k^1][e.d];\n\t\t\t\t\tif(!b2[h[li[e.d][i]][0]]||z[h[li[e.d][i]][0]]>co){\n\t\t\t\t\t\tb2[h[li[e.d][i]][0]]=true;\n\t\t\t\t\t\tz[h[li[e.d][i]][0]]=co;\n\t\t\t\t\t\tpt[k][h[li[e.d][i]][0]]=pt[k^1][h[li[e.d][i]][0]]+co;\n\t\t\t\t\t\tl[h[li[e.d][i]][0]]=e.d;\n\t\t\t\t\t\tr[h[li[e.d][i]][0]]=li[e.d][i];\n\t\t\t\t\t\tu[h[li[e.d][i]][0]]=Min(u[e.d],h[li[e.d][i]][1]);\n\t\t\t\t\t\tpq.Push(new Mo<int>(z[h[li[e.d][i]][0]],h[li[e.d][i]][0]));\n\t\t\t\t\t}\n\t\t\t\t\telse if(z[h[li[e.d][i]][0]]==co){\n\t\t\t\t\t\tvar o=Min(u[e.d],h[li[e.d][i]][1]);\n\t\t\t\t\t\tif(u[h[li[e.d][i]][0]]<o){\n\t\t\t\t\t\t\tu[h[li[e.d][i]][0]]=o;\n\t\t\t\t\t\t\tl[h[li[e.d][i]][0]]=e.d;\n\t\t\t\t\t\t\tr[h[li[e.d][i]][0]]=li[e.d][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!bo){break;}\n\t\t\tu[t]=(int)Min(c-d,u[t]);\n\t\t\tfor(int i = t;i!=s;i=l[i]) {\n\t\t\t\tans+=u[t]*h[r[i]][2];\n\t\t\t\th[r[i]][1]-=u[t];\n\t\t\t\th[r[i]^1][1]+=u[t];\n\t\t\t}\n\t\t\tk^=1;\n\t\t\td+=u[t];\n\t\t}\n\t\treturn c==d?ans:-1;\n\t}\n\tpublic long Pd(int s,int t,int c){\n\t\tlong ans=0,d=0;\n\t\tpt=new int[][]{new int[n],new int[n]};\n\t\tint k=0;\n\t\twhile(c>d){\n\t\t\tb1=new bool[n];\n\t\t\tb2=new bool[n];\n\t\t\tu=new int[n];\n\t\t\tvar pq=new Pq<Mo<int>>(32,true);\n\t\t\tz[s]=0;\n\t\t\tl[s]=-1;\n\t\t\tu[s]=int.MaxValue;\n\t\t\tb2[s]=true;\n\t\t\tpq.Push(new Mo<int>(0,s));\n\t\t\tbool bo=false;\n\t\t\twhile(pq.cnt>0){\n\t\t\t\tvar e=pq.Top;\n\t\t\t\tpq.Pop();\n\t\t\t\tif(b1[e.d]){continue;}\n\t\t\t\tb1[e.d]=true;\n\t\t\t\tif(e.d==t){bo=true;}\n\t\t\t\tfor(int i=0;i<li[e.d].Count;i++){\n\t\t\t\t\tif(h[li[e.d][i]][1]==0){continue;}\n\t\t\t\t\tint co=e.n+h[li[e.d][i]][2]-pt[k^1][h[li[e.d][i]][0]]+pt[k^1][e.d];\n\t\t\t\t\tif(!b2[h[li[e.d][i]][0]]||z[h[li[e.d][i]][0]]>co){\n\t\t\t\t\t\tb2[h[li[e.d][i]][0]]=true;\n\t\t\t\t\t\tz[h[li[e.d][i]][0]]=co;\n\t\t\t\t\t\tpt[k][h[li[e.d][i]][0]]=pt[k^1][h[li[e.d][i]][0]]+co;\n\t\t\t\t\t\tl[h[li[e.d][i]][0]]=e.d;\n\t\t\t\t\t\tr[h[li[e.d][i]][0]]=li[e.d][i];\n\t\t\t\t\t\tu[h[li[e.d][i]][0]]=Min(u[e.d],h[li[e.d][i]][1]);\n\t\t\t\t\t\tpq.Push(new Mo<int>(z[h[li[e.d][i]][0]],h[li[e.d][i]][0]));\n\t\t\t\t\t}\n\t\t\t\t\telse if(z[h[li[e.d][i]][0]]==co){\n\t\t\t\t\t\tvar o=Min(u[e.d],h[li[e.d][i]][1]);\n\t\t\t\t\t\tif(u[h[li[e.d][i]][0]]<o){\n\t\t\t\t\t\t\tu[h[li[e.d][i]][0]]=o;\n\t\t\t\t\t\t\tl[h[li[e.d][i]][0]]=e.d;\n\t\t\t\t\t\t\tr[h[li[e.d][i]][0]]=li[e.d][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!bo){break;}\n\t\t\tu[t]=(int)Min(c-d,u[t]);\n\t\t\tfor(int i = t;i!=s;i=l[i]) {\n\t\t\t\tans+=u[t]*h[r[i]][2];\n\t\t\t\th[r[i]][1]-=u[t];\n\t\t\t\th[r[i]^1][1]+=u[t];\n\t\t\t}\n\t\t\tk^=1;\n\t\t\td+=u[t];\n\t\t}\n\t\treturn c==d?ans:-1;\n\t}\n}\npublic class Mo<T>:IComparable{\n\tpublic int n;\n\tpublic T d;\n\tpublic Mo(int n,T d){this.n=n;this.d=d;}\n\tpublic int CompareTo(object obj){\n\t\tMo<T> mymo=(Mo<T>)obj;\n\t\tif(mymo.n>n){return -1;}\n\t\telse if(mymo.n<n){return 1;}\n\t\telse{return 0;}\n\t}\n}\npublic class Pq<T> where T:IComparable{\n\tprivate T[] he;\n\tpublic int cnt=0,max=0;\n\tprivate Func<T,T,int> compare;\n\tpublic Pq(int max,bool mm){\n\t\tthis.max=max;\n\t\the=new T[max];\n\t\tif(mm){compare=Ao;}\n\t\telse{compare=Do;}\n\t}\n\tpublic void Push(T x){\n\t\tif(cnt==max){Extend();}\n\t\tint j=cnt;\n\t\twhile(j!=0&&compare(x,he[(j-1)>>1])>0){he[j]=he[(j-1)>>1];j=(j-1)>>1;}\n\t\the[j]=x;\n\t\tcnt++;\n\t}\n\tpublic void Pop(){\n\t\tcnt--;\n\t\tT r=he[cnt];\n\t\tint j=0;\n\t\twhile(true){\n\t\t\tif(j*2+1<cnt){\n\t\t\t\tif(compare(he[j*2+1],he[j*2+2])>0){j=j*2+1;}\n\t\t\t\telse{j=j*2+2;}\n\t\t\t}\n\t\t\telse if(j*2<cnt){j=j*2+1;}\n\t\t\telse{break;}\n\t\t\tif(compare(he[j],r)<=0){j=(j-1)>>1;break;}\n\t\t\the[(j-1)>>1]=he[j];\n\t\t}\n\t\the[j]=r;\n\t}\n\tprivate int Ao(T x,T y){return y.CompareTo(x);}\n\tprivate int Do(T x,T y){return x.CompareTo(y);}\n\tpublic T Top{get{return he[0];}}\n\tprivate void Extend(){\n\t\tT[] nhe=new T[max<<1];\n\t\tArray.Copy(he,nhe,max);\n\t\the=nhe;\n\t\tmax<<=1;\n\t}\n}\n\npublic class Sc{\n\tprivate string[] a;\n\tprivate int n=-1,m=0;\n\tpublic int I{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries);}n++;return int.Parse(a[n]);}}\n\tpublic long L{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries);}n++;return long.Parse(a[n]);}}\n\tpublic double D{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries);}n++;return double.Parse(a[n]);}}\n\tpublic string S{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries);}n++;return a[n];}}\n\tpublic int[] Ia{get{if(n!=-1&&n!=a.Length-1){m=n;n=-1;return Array.ConvertAll(a.Skip(m+1).ToArray(),int.Parse);}return Array.ConvertAll(Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries),int.Parse);}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries),long.Parse);}}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split(new string[]{\" \",\"　\",\"\t\"},StringSplitOptions.RemoveEmptyEntries);}}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Digraph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :property, :in_edges, :out_edges\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\nend\n\ndef min_assign(cost_mat)\n\tn = cost_mat.size\n\tg = Digraph.new\n\ts = g.add_node\n\tt = g.add_node\n\tl_nodes = (0..n-1).map{|i| g.add_node({:index => i}) }\n\tl_nodes.each {|v| g.add_edge(s, v, {:length => 0}) }\n\tr_nodes = (0..n-1).map{|i| g.add_node({:index => i})}\n\tr_nodes.each {|v| g.add_edge(v, t, {:length => 0}) }\n\t(0..n-1).each{|i|\n\t\t(0..n-1).each{|j|\n\t\t\tg.add_edge(l_nodes[i], r_nodes[j], {:length => cost_mat[i][j]})\n\t\t}\n\t}\n\n\tn.times {\n\t\tqueue = l_nodes + r_nodes + [s, t]\n\t\tdist = Hash.new(Float::INFINITY)\n\t\tdist[s] = 0\n\t\tpath_edge = {}\n\n\t\tloop {\n\t\t\tu = queue.min_by{|v| dist[v]}\n\t\t\tif u == t\n\t\t\t\tloop {\n\t\t\t\t\te = path_edge[u] || break\n\t\t\t\t\tg.del_edge(e)\n\t\t\t\t\tg.add_edge(e.to, e.from, {:length => e.length})\n\t\t\t\t\tu = e.from\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tqueue.delete(u)\t \n\t\t\tu.out_edges.each{|e|\n\t\t\t\td = dist[u] + e.length\n\t\t\t\tv = e.to\n\t\t\t\tif d < dist[v] \n\t\t\t\t\tdist[v] = d\n\t\t\t\t\tpath_edge[v] = e\n\t\t\t\tend\n\t\t\t}\t\n\t\t}\n\t}\n\n\tl_nodes.map{|u|\n\t\tu.in_edges.to_a[0].from.property[:index]\n\t}\nend\n\nn = gets.to_i\nwrite_cost = (1..n).map{gets.split.map &:to_i}\nerase_cost = (1..n).map{gets.split.map &:to_i}\nwritten = (1..n).map{gets.chomp.each_char.map{|c| c == ?o ? 1 : 0}}\n\ncleanup_cost = (0..n-1).map{|i|\n\t(0..n-1).map{|j| erase_cost[i][j] * written[i][j]}.inject(:+)\n}\n\nselect_cost = (1..n).map{[]}\n(0..n-1).each{|i|\n\t(0..n-1).each{|j|\n\t\tselect_cost[i][j] = cleanup_cost[i]\n\t\tif written[i][j] == 1\n\t\t\tselect_cost[i][j] -= erase_cost[i][j]\n\t\telse\n\t\t\tselect_cost[i][j] += write_cost[i][j]\n\t\tend\n\t}\n}\n\nassign = min_assign(select_cost)\n\nmin_cost = 0\noperation = []\n(0..n-1).each{|i|\n\t(0..n-1).each{|j|\n\t\tif written[i][j] == 1 && assign[i] != j\n\t\t\toperation << \"#{i+1} #{j+1} erase\"\n\t\telsif assign[i] == j\n\t\t\tmin_cost += select_cost[i][j]\t\n\t\t\tif written[i][j] == 0\n\t\t\t\toperation << \"#{i+1} #{j+1} write\"\n\t\t\tend\n\t\tend\n\t}\n}\n\np min_cost\np operation.size\nputs operation"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Digraph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:index]\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :property, :in_edges, :out_edges\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\nend\n\ndef min_assign(cost_mat)\n\tn = cost_mat.size\n\tg = Digraph.new\n\ts = g.add_node({:index => \"s\"})\n\tt = g.add_node({:index => \"t\"})\n\tl_nodes = (0..n-1).map{|i| g.add_node({:index => i}) }\n\tl_nodes.each {|v| g.add_edge(s, v, {:length => 0}) }\n\tr_nodes = (0..n-1).map{|i| g.add_node({:index => i})}\n\tr_nodes.each {|v| g.add_edge(v, t, {:length => 0}) }\n\t(0..n-1).each{|i|\n\t\t(0..n-1).each{|j|\n\t\t\tg.add_edge(l_nodes[i], r_nodes[j], {:length => cost_mat[i][j]})\n\t\t}\n\t}\n\n\tpotential = Hash.new(0)\n\tn.times {\n\t\tqueue = l_nodes + r_nodes + [s, t]\n\t\tdist = Hash.new(Float::INFINITY)\n\t\tdist[s] = 0\n\t\tpath_edge = {}\n\n\t\tuntil queue.empty?\n\t\t\tu = queue.min_by{|v| dist[v]}\n\t\t\tqueue.delete(u)\t \n\t\t\tu.out_edges.each{|e|\n\t\t\t\td = dist[u] + e.length - (potential[e.to] - potential[e.from])\n\t\t\t\tv = e.to\n\t\t\t\tif d < dist[v] \n\t\t\t\t\tdist[v] = d\n\t\t\t\t\tpath_edge[v] = e\n\t\t\t\tend\n\t\t\t}\t\n\t\tend\n\n\t\tu = t\n\t\twhile e = path_edge[u]\n\t\t\tg.del_edge(e)\n\t\t\tg.add_edge(e.to, e.from, {:length => -e.length})\n\t\t\tu = e.from\n\t\tend\n\n\t\tdist.each_key{|v| potential[v] += dist[v]}\n\t}\n\n\tl_nodes.map{|u|\n\t\tu.in_edges.to_a[0].from.property[:index]\n\t}\nend\n\nn = gets.to_i\nwrite_cost = (1..n).map{gets.split.map &:to_i}\nerase_cost = (1..n).map{gets.split.map &:to_i}\nwritten = (1..n).map{gets.chomp.each_char.map{|c| c == ?o ? 1 : 0}}\n\ncleanup_cost = (0..n-1).map{|i|\n\t(0..n-1).map{|j| erase_cost[i][j] * written[i][j]}.inject(:+)\n}\n\nselect_cost = (1..n).map{[]}\n(0..n-1).each{|i|\n\t(0..n-1).each{|j|\n\t\tselect_cost[i][j] = cleanup_cost[i]\n\t\tif written[i][j] == 1\n\t\t\tselect_cost[i][j] -= erase_cost[i][j]\n\t\telse\n\t\t\tselect_cost[i][j] += write_cost[i][j]\n\t\tend\n\t}\n}\n\nassign = min_assign(select_cost)\n\nmin_cost = 0\noperation = []\n(0..n-1).each{|i|\n\t(0..n-1).each{|j|\n\t\tif written[i][j] == 1\n\t\t\tif assign[i] == j\n\t\t\t\tmin_cost += select_cost[i][j]\t\n\t\t\telse\n\t\t\t\toperation << \"#{i+1} #{j+1} erase\"\n\t\t\tend\n\t\telse\n\t\t\tif assign[i] == j\n\t\t\t\tmin_cost += select_cost[i][j]\t\n\t\t\t\toperation << \"#{i+1} #{j+1} write\"\n\t\t\telse\n\t\t\tend\n\t\tend\n\t}\n}\n\np min_cost\np operation.size\nputs operation"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass MinCostFlow:\n    INF = 10 ** 18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        prv_v = [0]*N\n        prv_e = [0]*N\n\n        while f:\n            dist = [INF]*N\n            dist[s] = 0\n            update = True\n\n            while update:\n                update = False\n                for v in range(N):\n                    if dist[v] == INF:\n                        continue\n                    for i, (to, cap, cost, _) in enumerate(G[v]):\n                        if cap > 0 and dist[to] > dist[v] + cost:\n                            dist[to] = dist[v] + cost\n                            prv_v[to] = v; prv_e[to] = i\n                            update = True\n            if dist[t] == INF:\n                return -1\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * dist[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\ndef build_grid(H, W, intv, _type, space=True, padding=False):\n    # 入力がスペース区切りかどうか\n    if space:\n        _input = lambda: input().split()\n    else:\n        _input = lambda: input()\n    _list = lambda: list(map(_type, _input()))\n    # 余白の有無\n    if padding:\n        offset = 1\n    else:\n        offset = 0\n    grid = list2d(H+offset*2, W+offset*2, intv)\n    for i in range(offset, H+offset):\n        row = _list()\n        for j in range(offset, W+offset):\n            grid[i][j] = row[j-offset]\n    return grid\n\nN = INT()\nwrite = build_grid(N, N, 0, int)\nerase = build_grid(N, N, 0, int)\ngrid = build_grid(N, N, '', str, space=0)\n\n# 負のコストを扱うのでベルマンフォード版の最小費用流を使う\nmcf = MinCostFlow(N*2+2)\ns = N * 2\nt = N * 2 + 1\nerasesm = 0\nfor i in range(N):\n    mcf.add_edge(s, i, 1, 0)\n    mcf.add_edge(N+i, t, 1, 0)\n    for j in range(N):\n        if grid[i][j] == 'o':\n            # 元々oの所は予め消したものとして、後で帳尻を合わせる\n            erasesm += erase[i][j]\n            mcf.add_edge(i, N+j, 1, -erase[i][j])\n        else:\n            mcf.add_edge(i, N+j, 1, write[i][j])\n\nres = erasesm + mcf.flow(s, t, N)\nwritten = set()\nfor fr in range(N):\n    # fr(0~N-1)からto(N~N*2-1)を繋ぐ辺で、容量が0だったら使っているマスとみなせる\n    for to, cap, cost, _ in mcf.G[fr]:\n        if cap == 0 and N <= to < N*2:\n            written.add((fr, to-N))\n            break\n\nans = []\nfor i in range(N):\n    for j in range(N):\n        # 元々が書き込み済で結果が未記入なら消す操作\n        if grid[i][j] == 'o' and (i, j) not in written:\n            ans.append((i+1, j+1, 'erase'))\n        # 元々が未記入で結果が書き込み済なら書く操作\n        if grid[i][j] == '.' and (i, j) in written:\n            ans.append((i+1, j+1, 'write'))\nprint(res)\nprint(len(ans))\nfor i, j, s in ans:\n    print(i, j, s)\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\nclass Edge():\n    def __init__(self,t,f,r,ca,co):\n        self.to = t\n        self.fron = f\n        self.rev = r\n        self.cap = ca\n        self.cost = co\n\n    def __str__(self):\n        return f\"Edge[{self.fron}, {self.to}, {self.rev}, {self.cap}, {self.cost}]\"\n\nclass MinCostFlow():\n    size = 0\n    graph = []\n\n    def __init__(self, s):\n        self.size = s\n        self.graph = [[] for _ in range(s)]\n\n    def add_edge(self, f, t, ca, co):\n        self.graph[f].append(Edge(t, f, len(self.graph[t]), ca, co))\n        self.graph[t].append(Edge(f, t, len(self.graph[f])-1, 0, -co))\n\n    def min_path(self, s, t):\n        dist = [inf] * self.size\n        route = [None] * self.size\n        que = collections.deque()\n        inq = [False] * self.size\n        dist[s] = 0\n        que.append(s)\n        inq[s] = True\n        while que:\n            u = que.popleft()\n            inq[u] = False\n            for e in self.graph[u]:\n                if e.cap == 0:\n                    continue\n                v = e.to\n                if dist[v] > dist[u] + e.cost:\n                    dist[v] = dist[u] + e.cost\n                    route[v] = e\n                    if not inq[v]:\n                        que.append(v)\n                        inq[v] = True\n\n        if dist[t] == inf:\n            return inf, 0\n\n        flow = inf\n        v = t\n        while v != s:\n            e = route[v]\n            if flow > e.cap:\n                flow = e.cap\n            v = e.fron\n\n        c = 0\n        v = t\n        while v != s:\n            e = route[v]\n            e.cap -= flow\n            self.graph[e.to][e.rev].cap += flow\n            c += e.cost * flow\n            v = e.fron\n\n        return dist[t], flow\n\n    def calc_min_cost_flow(self, s, t, flow):\n        total_cost = 0\n        while flow > 0:\n            c,f = self.min_path(s, t)\n            if f == 0:\n                return inf\n            f = min(flow, f)\n            total_cost += c * f\n            flow -= f\n\n        return total_cost\n\n\ndef main():\n    n = I()\n    wa = [LI() for _ in range(n)]\n    ea = [LI() for _ in range(n)]\n    fa = [[c == 'o' for c in S()] for _ in range(n)]\n\n    s = n*2\n    t = n*2 + 1\n    mf = MinCostFlow(n*2+2)\n    for i in range(n):\n        mf.add_edge(s,i,1,0)\n        mf.add_edge(i+n,t,1,0)\n        fs = set([j for j in range(n) if fa[i][j]])\n        fc = sum([ea[i][j] for j in fs])\n        for j in range(n):\n            if j in fs:\n                mf.add_edge(i,j+n,1,fc-ea[i][j])\n            else:\n                mf.add_edge(i,j+n,1,fc+wa[i][j])\n\n    r = mf.calc_min_cost_flow(s,t,n)\n    ra = [[False]*n for _ in range(n)]\n    for gr in mf.graph:\n        for g in gr:\n            if g.fron >= n or g.cap > 0:\n                continue\n            ra[g.fron][g.to-n] = True\n\n    rr = []\n    for i in range(n):\n        for j in range(n):\n            if fa[i][j] == ra[i][j]:\n                continue\n            if fa[i][j]:\n                rr.append(\"{} {} erase\".format(i+1, j+1))\n            else:\n                rr.append(\"{} {} write\".format(i+1, j+1))\n\n    return JA([r, len(rr)] + rr, \"\\n\")\n\n# start = time.time()\nprint(main())\n# pe(time.time() - start)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [0]*N\n\n        while f:\n            dist = [INF]*N\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                for i, (w, cap, cost, _) in enumerate(G[v]):\n                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:\n                        dist[w] = r = dist[v] + cost + H[v] - H[w]\n                        prv_v[w] = v; prv_e[w] = i\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return -1\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n\n    N = int(readline())\n    W = [list(map(int, readline().split())) for i in range(N)]\n    E = [list(map(int, readline().split())) for i in range(N)]\n    F = [readline() for i in range(N)]\n    mcf = MinCostFlow(2*N+2)\n    for i in range(N):\n        Wi = W[i]; Ei = E[i]; Fi = F[i]\n        s0 = sum(Ei[j] for j in range(N) if Fi[j] == \"o\")\n        for j in range(N):\n            s = (s0 - Ei[j] if Fi[j] == \"o\" else s0 + Wi[j])\n            mcf.add_edge(i, N+j, 1, s)\n        mcf.add_edge(2*N, i, 1, 0)\n        mcf.add_edge(N+i, 2*N+1, 1, 0)\n    res = mcf.flow(2*N, 2*N+1, N)\n    write(\"%d\\n\" % res)\n    ans = []\n    for i in range(N):\n        Gi = mcf.G[i]\n        Wi = W[i]; Ei = E[i]; Fi = F[i]\n        for j in range(N):\n            if Gi[j][1] == 0:\n                for k in range(N):\n                    if j == k or Fi[k] == \".\":\n                        continue\n                    ans.append(\"%d %d erase\" % (i+1, k+1))\n                if Fi[j] == \".\":\n                    ans.append(\"%d %d write\" % (i+1, j+1))\n                break\n    write(\"%d\\n\" % len(ans))\n    if ans:\n        write(\"\\n\".join(ans))\n        write(\"\\n\")\nsolve()\n"
  }
]