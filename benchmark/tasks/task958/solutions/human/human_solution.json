[
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int K = 30;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int>> a(K, vector<int>(n + 1));\n  int sum = 0, maxk = 0;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    sum ^= x;\n    int k = 1;\n    while (x % 2 == 0) x /= 2, k += 1;\n    maxk = max(maxk, k);\n    trace(i, k);\n    for (int j = 0; j < k; ++j) a[j][i] = 1;\n  }\n  for (int i = maxk; i < K; ++i) {\n    if ((sum >> i) & 1) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < maxk; ++i) a[i][n] = (sum >> i) & 1;\n  trace(K, n, a);\n  for (int i = 0; i < K; ++i) {\n    int u, v;\n    for (u = i; u < K; ++u) {\n      for (v = i; v < n && a[u][v] == 0; ++v);\n      if (v < n) break;\n    }\n    if (u == K) {\n      int j;\n      for (j = u; j < K && a[j][n] == 0; ++j);\n      if (j != K) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      break;\n    }\n    if (i != u) swap(a[i], a[u]);\n    if (i != v) {\n      for (u = i; u < K; ++u) swap(a[u][i], a[u][v]);\n    }\n    for (u = 0; u < K; ++u) {\n      if (u != i && a[u][i]) {\n        for (v = i; v <= n; ++v) a[u][v] ^= a[i][v];\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < K; ++i) ret += a[i][n];\n  cout << ret << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<int> a(n + 1);\n        int x = 0;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tx ^= a[i];\n                a[i] ^= a[i] - 1;\n\t}\n        vector<bool> ok(100);\n\tfor (int i = 1; i <= n; i ++) {\n\t\tfor (int j = 1; j < 31; j ++) {\n\t\t\tif ((1 << j) - 1 == a[i]) ok[j - 1] = true;\n                }\n\t}\n\tint ans = 0;\n\tfor (int i = 30; i >= 0; i --) {\n\t\tif (x & (1 << i)) {\n\t\t\tif (!ok[i]) {\n\t\t\t\treturn !printf(\"-1\\n\");\n\t\t\t} else {\n\t\t\t\tx ^= (1 << (i + 1)) - 1;\n\t\t\t\tans ++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_N = 1e5 + 5, MAX_M = 40;\nlong long n, x, ans, p;\nlong long a[MAX_N];\nlong long l[MAX_N];\nlong long cnt[MAX_M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (long long i = 32; ~i; i--)\n\t\tif (((x >> i) & 1) & p) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tp++;\n\t\t\tcnt[i]--;\n\t\t\tans++;\n\t\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nbool check[35];\nint res;\nint grundy;\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x; cin >> x;\n\t\tgrundy ^= x;\n\t\tint last = (x & -x);\n\t\tlast = (int)log2(last);\n\t\tcheck[last] = 1;\n\t}\n\n\tfor (int i = 30; i >= 0; --i) {\n\t\tint b = (grundy >> i) & 1;\n\t\tif (b) {\n\t\t\tif (!check[i]) return printf(\"-1\\n\"), 0;\n\t\t\telse {\n\t\t\t\t++res; grundy ^= ((1 << i) - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/03/03  Problem: code-festival-2016-ex-final_c / Link: https://cf16-exhibition-final.contest.atcoder.jp/tasks/cf16_exhibition_final_c?lang=en  ----- */\n/* ------問題------\n\nチーターと不正者がニムをすることになりました。 このゲームでは、N 個の石の山を使います。 最初に i 番目の山には ai 個の石があります。 チーターが先手で、交互にターンを取ります。 それぞれのターンでは、プレイヤーは一つの山を選び、その山から一個以上の石を取り除きます。 ターンが回ってきたときに操作ができなくなったプレイヤーの負けです。\nしかし、ゲームが始まる前に、不正者はチーターがどのような動きをしても必ず勝つことができるように少し不正をすることにしました。 それぞれの山から、不正者は 0 個または 1 個の石を取り除き、ゲームが始まる前に食べます。 不正者が必ず勝てるようにする方法が複数通りある場合は、食べる石の個数を最小にするようにしたいです。\n不正者が食べる石の個数を求めてください。 不正をしても不正者が必ず勝つようにできない場合は、-1 を出力してください。\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\nLL N;\n\nLL ans = 0LL;\n\n\n\nint popcount2(int x) {//二進数中のbitが1の数\n\tint ret = 0;\n\twhile (x) {\n\t\tx &= x - 1;\n\t\t++ret;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tcin >> N;\n\tVI a(N);\n\tVI cnt(31, 0);\n\tLL res = 0;\n\n\tFOR(i, 0, N) {\n\t\tcin >> a[i];\n\t\tres ^= a[i];\n\t\tcnt[popcount2((a[i] & -a[i]) - 1)]++;\n\t}\n\n\tdebug(res);\n\tFORR(i, 30, 0 - 1) {\n\t\tif (res &(1 << i)) {\n\t\t\tif (cnt[i]) {\n\t\t\t\tres ^= (1 << (i + 1)) - 1;\n\t\t\t\t//debug(res);\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (res)ans = -1;\n\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_set>\n\nint a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    xor_sum ^= a[i];\n  }\n\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++)\n    s.insert(a[i] ^ (a[i] - 1));\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.find(x) != s.end()) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 32;\nint n, x, ans, a, cnt[L];\nbool t = 1;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> a;\n\t\tcnt[__builtin_ctz(a)]++;\n\t\tx ^= a;\n\t}\n\t\n\tfor (int i = L - 1; i >= 0; i--){\n\t\tif((x >> i) % 2 == t){\n\t\t\tif(cnt[i] == 0)\n\t\t\t\treturn cout << -1, 0;\n\t\t\tt = 1 - t;\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main(){\n\tint n; cin >> n; std::vector<long> a(n);\n\tlong x = 0;\n\tstd::set<int> st;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\t\n\t\tx ^= a[i];\n\t\tst.insert(-__builtin_ctzll(a[i]));\n\t}\n\t\n\tint ans = 0;\n\tfor(auto s : st){\n\t\tint k = -s;\n\t\t\n\t\tif((x >> k) & 1){\n\t\t\tx ^= (1 << (k + 1)) - 1;\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tif(x) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nvoid NO()\n{\n    puts(\"-1\");\n    exit(0);\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<int> a(N);\n    cin >> a;\n    int ret = 0;\n    int D = 31;\n    IREP(d, D)\n    {\n        int xo = 0;\n        for (auto v : a)\n        {\n            xo = xo xor ((v >> d) & 1);\n        }\n        if (xo)\n        {\n            bool flg = false;\n            for (auto &v : a) if ((v & (POW2(d + 1) - 1)) == POW2(d))\n            {\n                ret++;\n                v -= 1;\n                flg = true;\n                break;\n            }\n            if (!flg) NO();\n        }\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10, lg = 30;\nint n, a[MAXN], X, ans;\nbool r[MAXN];\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tX ^= a[i];\n\t\tr[__builtin_ctz(a[i])] = 1;\n\t}\n\tfor (int i = lg - 1; i >= 0; i--) {\n\t\tif ((X & (1 << i)) != 0) {\n\t\t\tans++;\n\t\t\tX ^= (1 << (i + 1)) - 1;\n\t\t\tif (!r[i])\n\t\t\t\treturn cout << -1, 0;\n\t\t}\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int N; cin >> N;\n  int x {};\n  set<int> s;\n  for (int i = 0; i < N; i++) {\n    int a; cin >> a;\n    x ^= a;\n    int m {};\n    while ((a >> m & 1) == 0) m++;\n    s.insert(m);\n  }\n  int c {};\n  while (x >> c) c++;\n  int ans {};\n  for (int i = c - 1; i >= 0; i--) {\n    if (x >> i & 1) {\n      if (!s.count(i)) {\n        ans = -1;\n        break;\n      }\n      x ^= ((1 << (i + 1)) - 1);\n      ans++;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    V<ll> alist; llina(alist, n);\n\n    ll xsum = 0LL;\n    for (auto a : alist) xsum ^= a;\n\n    S bool enables[70];\n    memset(enables, 0, sizeof(enables));\n\n    for (auto a : alist) {\n        rep (pos, 70) {\n            if (a & 1LL) {\n                enables[pos] = true;\n                break;\n            }\n            a >>= 1LL;\n        }\n    }\n\n    debug_printf(\"---- enables\\n\");\n    debug_print(enables, 10);\n\n    ll prev = 0LL;\n    ll cnt = 0LL;\n    rrep (pos, 63) {\n        ll flag = ((xsum>>pos) & 1LL);\n        debug_printf(\"pos=%lld flag=%lld\\n\", pos, flag);\n        if (flag != prev) {\n            if (!enables[pos]) {\n                cout << -1 << endl;\n                return;\n            }\n            cnt++;\n        }\n        prev = flag;\n    }\n\n    cout << cnt << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint check[30];\n\nint main() {\n\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  int a;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n  return 0;\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n#define lb(x) ((x)&(-(x)))\n#define xx first\n#define yy second\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int> \n#define dalao 1000000007\n#define inf 0x3f3f3f3f\n#define N 305\nusing namespace std;\ntypedef long long ll;\nint n,a[N],s,ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),s^=a[i];\n\tfor(int i=29;~i;i--)if(s>>i&1)\n\t\tfor(int j=1;j<=n;j++)if(lb(a[j])==1<<i){ans++,s^=(1<<i+1)-1;break;}\n\tif(s)puts(\"-1\");else cout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<\"\\n\";\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\n\";\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<\"\\n\";\n#define br cout<<endl;\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MAX = 100005;\nconst int INF = 1e9+7;\nconst ll LINF = 1e18 + 7;\n\n/***************************************************************************/\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    int n;\n    cin>>n;\n    ll ar[n+5],ans=0;\n    map<int, int>m;\n    for(int i=0;i<n;i++)\n    {\n        ll a,r=0;\n        cin>>a;\n        ans^=a;\n        while(a%2==0)\n        {\n            r++;\n            a=a/2;\n        }\n        m[r]++;\n    }\n    ll x=1>>32,f=0,res=0;\n    for(int i=32;i>=0;i++)\n    {\n        if(ans & x)\n        {\n            if(m[i])\n            {\n                ans^=1;\n            }\n            else\n            {\n                f=1;\n                break;\n            }\n            res++;\n        }\n    }\n    if(f)\n    {\n        cout<<-1<<endl;\n    }\n    else\n    {\n        cout<<res<<endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_N = 1e5 + 5, MAX_M = 40;\nlong long n, x, ans, p;\nlong long a[MAX_N];\nlong long l[MAX_N];\nlong long cnt[MAX_M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (long long i = 32; ~i; i--)\n\t\tif (((x >> i) & 1) ^ p) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tp = !p;\n\t\t\tcnt[i]--;\n\t\t\tans++;\n\t\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/03/03  Problem: code-festival-2016-ex-final_c / Link: https://cf16-exhibition-final.contest.atcoder.jp/tasks/cf16_exhibition_final_c?lang=en  ----- */\n/* ------問題------\n\nチーターと不正者がニムをすることになりました。 このゲームでは、N 個の石の山を使います。 最初に i 番目の山には ai 個の石があります。 チーターが先手で、交互にターンを取ります。 それぞれのターンでは、プレイヤーは一つの山を選び、その山から一個以上の石を取り除きます。 ターンが回ってきたときに操作ができなくなったプレイヤーの負けです。\nしかし、ゲームが始まる前に、不正者はチーターがどのような動きをしても必ず勝つことができるように少し不正をすることにしました。 それぞれの山から、不正者は 0 個または 1 個の石を取り除き、ゲームが始まる前に食べます。 不正者が必ず勝てるようにする方法が複数通りある場合は、食べる石の個数を最小にするようにしたいです。\n不正者が食べる石の個数を求めてください。 不正をしても不正者が必ず勝つようにできない場合は、-1 を出力してください。\n\n-----問題ここまで----- */\n/* -----解説等-----\n\nすごい時間がかかった\nまず可能な操作は現在の数字に対して 何もしないあるいは (ゲーム値)^(a[i])^(a[i]-1)である。\n何も考えないとより良い方法としてゲーム値の2進数表現でのビットが立っている場所をたくさん0にできそうだが、それは嘘。\nというのはこの操作は最下位ビットを0にする操作だからである。\nしたがってa[i]の最下位bitを0にできるようになったので各桁について愚直にやっていけばよい\n\n----解説ここまで---- */\n\nLL N;\n\nLL ans = 0LL;\n\n\n\nint popcount2(int x) {//二進数中のbitが1の数\n\tint ret = 0;\n\twhile (x) {\n\t\tx &= x - 1;\n\t\t++ret;\n\t}\n\treturn ret;\n}\n\nstring to_binString(unsigned int val) //二進数表示\n{\n\tconst int size = 30;\n\tint index = size - 1;\n\tstring str(size, '0');\n\twhile (val != 0) {\n\t\tif ((val & 1) == 0)  // val は偶数か？\n\t\t\tstr[index] = '0';  //  偶数の場合\n\t\telse\n\t\t\tstr[index] = '1';  //  奇数の場合\n\t\tval >>= 1, index--;\n\t}\n\treturn str;\n}\nvoid print_bin(int a) {\n\tcout << to_binString(a) << endl;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\n\n\tcin >> N;\n\tVI a(N);\n\tVI cnt(31, 0);\n\tLL res = 0;\n\n\tFOR(i, 0, N) {\n\t\tcin >> a[i];\n\t\tres ^= a[i];\n\t\tcnt[popcount2((a[i] & -a[i]) - 1)]++;\n\t}\n\n\tdebug(res);\n\tFORR(i, 30, 0 - 1) {\n\t\tif (res &(1 << i)) {\n\t\t\tif (cnt[i]) {\n\t\t\t\tres ^= (1 << (i + 1)) - 1;\n\t\t\t\t//debug(res);\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (res)ans = -1;\n\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    vec a(N); cin >> a;\n\n    set<int> s;\n    REP(i, N){\n        int d = __builtin_ffsll(a[i]);\n        s.insert(bit(d) - 1);\n    }\n    vec v;\n    for(int i: s) v.pb(i);\n    //vdebug(v);\n    int n = SZ(v);\n\n    int X = 0;\n    REP(i, N) X ^= a[i];\n\n    int ans = INF;\n    REP(i, bit(n)){\n        int mask = 0;\n        REP(j, n) if(bit_exist(i, j)) mask ^= v[j];\n        if((X ^ mask) == 0) Min(ans, (int)__builtin_popcountll(i));\n    }\n    Ans(ans < INF, ans, -1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                 \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint keta(int u){\n\tint r=1;\n\tfor(int i=0;i<40;i++){\n\t\tif(u==r) return i;\n\t\tr*=2;\n\t}\n}\n\nint u[40]={0};\n\n      signed main(){\n    int n;\n      \tint noko=0;\n      \tcin>>n;\n      \t\n      \tfor(int i=0;i<n;i++){\n      \t\tint uu;\n      \t\tcin>>uu;\n      \t\tint er=(uu&(-uu));\n      \t\tnoko^=uu-er;\n      \t\tu[keta(er)]^=1;\n      \t\n      \t}\n     // \tcout<<noko<<endl;\n      \tint ans=0;\n      \tfor(int i=30;i>=0;i--){\n      \t\tif(u[i]==0 && (noko&(1<<i))!=0){\n      \t\tcout<<-1<<endl;\n      \t\t\treturn 0;\n      \t\t}\n      \t\tif(u[i]==0) continue;\n      \t\t\n      \t\tif((noko&(1<<i))){\n      \t\t\tnoko -= (1<<i);\n      \t\t}\n      \t\telse{\n      \t\t\tans++;\n      \t\t\tnoko ^= (1<<i)-1;\n      \t\t}\n      \t}\n      \t\n      \tif(noko){\n      \t\tcout<<-1<<endl;\n      \t}\n      \telse cout<<ans<<endl;\n      \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                 \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint keta(int u){\n\tint r=1;\n\tfor(int i=0;i<40;i++){\n\t\tif(u==r) return i;\n\t\tr*=2;\n\t}\n\texit(1);\n}\n\nint u[40]={0};\n\n      signed main(){\n    int n;\n      \tint noko=0;\n      \tcin>>n;\n      \t\n      \tfor(int i=0;i<n;i++){\n      \t\tint uu;\n      \t\tcin>>uu;\n      \t\tint er=(uu&(-uu));\n      \t\tnoko^=uu-er;\n      \t\tu[keta(er)]^=1;\n      //\tcout<<keta(er)<<endl;\n      \t}\n     // \tcout<<noko<<endl;\n      \tint ans=0;\n      \tfor(int i=35;i>=0;i--){\n     // \t\tcout<<noko<<endl;\n      \t\tif(u[i]==0 && (noko&(1ll<<i))!=0ll){\n      //\t\t\tcout<<i<<endl;\n      \t\tcout<<\"-1\"<<endl;\n      \t\t\treturn 0;\n      \t\t}\n      \t\tif(u[i]==0ll) {\n      \t\t\tif(noko >(1ll<<i)) exit(1);\n      \t\t\tcontinue;\n      \t\t}\n      \t\tif((noko&(1ll<<i))){\n      \t\t\tnoko -= (1ll<<i);\n      \t\t}\n      \t\telse{\n      \t\t\tans++;\n      \t\t\tnoko ^= (1ll<<i)-1;\n      \t\t}\n      \t}\n      \t\n      \tif(noko){\n      \t\tcout<<-1<<endl;\n      \t}\n      \telse cout<<ans<<endl;\n      \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N, Xor;\nvector<int> arr, low;\n\nint main() {\n    scanf(\"%d\", &N);\n\n    arr.resize(N);\n    Xor = 0;\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d\", &arr[i]);\n        Xor ^= arr[i];\n    }\n\n    low = vector<int>(31, 0);\n\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < 31; j++) {\n            if(arr[i] & (1<<j)) {\n                low[j] = 1;\n                break;\n            }\n        }\n    }\n\n    bool ok = false;\n    int bf = 0;\n    int ans = 0;\n    for(int i = 31; i >= 0; i--) {\n        if(Xor & (1<<i)) ok = true;\n        if(ok) {\n            if(bf != ((Xor & (1<<i))? 1 : 0)) {\n                if(!low[i]) {\n                    printf(\"-1\");\n                    return 0;\n                }\n                ans++;\n            }\n            bf = ((Xor & (1<<i))? 1 : 0);\n        }\n    }\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n);\n\tmap<int,int> m;\n\tint s = 0;\n\trep(i,n){\n\t\tcin >> a[i];\n\t\tm[ a[i] ]++;\n\t\ts ^= a[i];\n\t}\n\n\tbitset<31> b(s);\n\tint ans = 0;\n\tfor(int i = 30; i >= 0; i--){\n\t\tif(b[i]){\n\t\t\tint tmp = 1 << i;\n\t\t\t//show(tmp)\n\t\t\tif(m[tmp] > 0){\n\t\t\t\tm[tmp]--;\n\t\t\t\ts ^=  tmp;\n\t\t\t\ttmp--;\n\t\t\t\ts ^= tmp;\n\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tb = bitset<31>(s);\n\t}\n\n\tfor(auto i : m){\n\t\tif(i.second > 0 && i.first % 2 == 1){\n\t\t\tans++;\n\t\t\ts ^= 1;\n\t\t}\n\t}\n\n\tcout << (s == 0 ? ans : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,a,x,c,k[30];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a;\n\t\tx^=a;\n\t\ta^=a-1;\n\t\tfor(int j=1;j<=30;j++)if(a==(1<<j)-1)k[j-1]=1;\n\t}\n\tfor(int i=29;i>0;i--)\n\t{\n\t\tif(x&(1<<(i-1))&&k[i-1])c++,x^=(1<<i)-1;\n\t}\n\tcout<<(x?-1:c)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n\nint a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &a[i]);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++)\n    xor_sum ^= a[i];\n  std::set<int> s;\n  for (int i = 0; i < n; i++)\n    s.insert(a[i] ^ (a[i] - 1));\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.count(x)) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main(){\n\tint n; cin >> n; std::vector<int> a(n);\n\tint x = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\t\n\t\tx ^= a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor(int k = 32; k >= 0; k--){\n\t\tif(!((x >> k) & 1)) continue;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((a[i] ^ (a[i] - 1)) != (1 << (k + 1)) - 1) continue;\n\t\t\t\n\t\t\tx ^= a[i] ^ (a[i] - 1);\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(x) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 1e5 + 5;\n\nint n, sum, cnt;\narray<int, MAXN> a, f;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i], sum ^= a[i], a[i] ^= a[i] - 1;\n        for (int j = 30; ~j; j--) {\n            if ((a[i] >> j) & 1) {\n                f[j] = 1;\n                break;\n            }\n        }\n    }\n    for (int j = 30; ~j; j--)\n        if (((sum >> j) & 1) && f[j])\n            sum ^= (1 << (j + 1)) - 1, cnt++;\n    cout << (sum ? -1 : cnt) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nvoid NO()\n{\n    puts(\"-1\");\n    exit(0);\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<int> a(N);\n    cin >> a;\n    if (N == 1 and a[0] > 1) NO();\n    int ret = 0;\n    int D = 31;\n    IREP(d, D)\n    {\n        int xo = 0;\n        for (auto v : a)\n        {\n            xo = xo xor ((v >> d) & 1);\n        }\n        if (xo)\n        {\n            bool flg = false;\n            for (auto &v : a) if ((v & (POW2(d + 1) - 1)) == POW2(d))\n            {\n                ret++;\n                v -= 1;\n                flg = true;\n                break;\n            }\n            if (!flg) NO();\n        }\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 1e5 + 20 , LG = 30 ;\nint n , a[N] , X , cnt[LG] , ans ;\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\t\tX ^= a[i] ;\n\t\n\t\ta[i] ^= a[i] - 1 ;\n\n\t\tcnt[__builtin_popcount(a[i])] ++ ;\n\t}\n\n\tfor (int i = 1 ; i < LG ; i ++) {\n\t\tif ((X >> i & 1) != (X >> (i - 1) & 1)) {\n\t\t\tif (!cnt[i]) return cout << \"-1\\n\" , 0 ;\n\t\t\tans ++ ;\n\t\t}\n\t}\n\n\tcout << ans << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:https://cf16-exhibition-final-open.contest.atcoder.jp/tasks/cf16_exhibition_final_c>\n問題文============================================================\n チーターと不正者がニムをすることになりました。 このゲームでは、N 個の石の山を使います。\n 最初に i 番目の山には ai 個の石があります。 チーターが先手で、交互にターンを取ります。\n それぞれのターンでは、プレイヤーは一つの山を選び、その山から一個以上の石を取り除きます。\n ターンが回ってきたときに操作ができなくなったプレイヤーの負けです。\n \n しかし、ゲームが始まる前に、\n 不正者はチーターがどのような動きをしても必ず勝つことができるように少し不正をすることにしました。\n それぞれの山から、不正者は 0 個または 1 個の石を取り除き、ゲームが始まる前に食べます。\n 不正者が必ず勝てるようにする方法が複数通りある場合は、食べる石の個数を最小にするようにしたいです。\n \n 不正者が食べる石の個数を求めてください。 不正をしても不正者が必ず勝つようにできない場合は、-1 を出力してください。\n=================================================================\n\n解説=============================================================\n\n ゲーム理論より 全ての山の xor を 0 にしたい\n ここで、初期状態のxor を x とし　ある値 a[i] を a[i]-1 にすると\n \n x = x^(a[i]^(a[i]-1))\n \n となる\n さて、　a[i]^(a[i]-1) は　必ず　2^k-1 の形になることに注目する\n \n  サンプル1では\n   2^3^4 = (101)_2\n     3^2 = (1)_2\n     2^1 = (11)_2\n     4^3 = (111)_2\n \n である\n \n この(101)_2を 0 にするには　、　まず\n \n 3桁目の最上位１に注目して\n 4=>3にして\n (101)^(111) = (10)\n 次に2桁目の最上位１に注目して\n (10)^(11) = (1)\n 同様に\n (1)^(1) = (0) = 0\n \n このように最上位から順番に見て行くことによって確実かつ最適に値を0に近づけることができる\n \n よって、先に a[i] によって作れる 2^k-1 の値を確認しておき\n x に関して最上位から順番に見て行き 変化させていけば良い\n \n================================================================\n*/\n\nll solve(){\n    ll N; cin >> N;\n    vector<ll> a(N);\n    for(auto &in:a) cin >> in;\n    ll x = 0;\n    for(int i = 0; i < N;i++) x ^= a[i];\n\n    // a[i] -> a[i] - 1 := x^(a[i]^(a[i]-1)) = x^(2^k - 1)\n    bool f[31] = {false};\n    for(int i = 0; i < N;i++){\n        ll t = a[i]^(a[i]-1);\n        ll cnt = 0, n = 1;\n        while(n <= t){cnt++; n<<=1;}\n        f[cnt] = true;\n    }\n    ll ret = 0;\n    for(int i = 30; i >= 0; i--){\n        if((x>>i)&1){\n            if(f[i+1] == false) return ret = -1;\n            x^=((1<<(i+1)) - 1); ret++;\n        }\n    }\n    return ret;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cout << solve() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n\nusing ll = long long int;\nusing P = std::pair<int, int>;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nint cnt[50];\nbool sw[50];\n\nint main(void){\n\tint n,i,j,ans=0;\n\tll a;\n\tstd::cin >> n;\n\tfor(i=0; i<n; ++i){\n\t\tstd::cin >> a;\n\t\tfor(j=0; j<50; ++j){\n\t\t\tcnt[j] += (a>>j)&(1ll);\n\t\t}\n\t\tj = 0;\n\t\twhile(!(a%2)){\n\t\t\t++j; a /= 2;\n\t\t}\n\t\tsw[j] = true;\n\t}\n\tfor(j=49; j>=0; --j){\n\t\tif((cnt[j]+ans)%2){\n\t\t\tif(!sw[j]){\n\t\t\t\tstd::cout << \"-1\" << std::endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t++ans;\n\t\t}\n\t}\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint a[MAX_N];\nint b[MAX_N];\n\nint main()\n{\n\tint n,x=0,ans=0;\n\tcin >> n;\n\trep(i,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tx ^= a[i];\n\t\tb[i] = a[i]^(a[i]-1);\n\t}\n\tfor(int k=29;k>0;k--){\n\t\trep(i,n){\n\t\t\tif(b[i] == pow(2,k)-1){\n\t\t\t\tif(x & (1 << (k-1))){\n\t\t\t\t\tx ^= b[i];\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(x==0){\n\t\tcout << ans << \"\\n\";\n\t}else{\n\t\tcout << \"-1\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/03/03  Problem: code-festival-2016-ex-final_c / Link: https://cf16-exhibition-final.contest.atcoder.jp/tasks/cf16_exhibition_final_c?lang=en  ----- */\n/* ------問題------\n\nチーターと不正者がニムをすることになりました。 このゲームでは、N 個の石の山を使います。 最初に i 番目の山には ai 個の石があります。 チーターが先手で、交互にターンを取ります。 それぞれのターンでは、プレイヤーは一つの山を選び、その山から一個以上の石を取り除きます。 ターンが回ってきたときに操作ができなくなったプレイヤーの負けです。\nしかし、ゲームが始まる前に、不正者はチーターがどのような動きをしても必ず勝つことができるように少し不正をすることにしました。 それぞれの山から、不正者は 0 個または 1 個の石を取り除き、ゲームが始まる前に食べます。 不正者が必ず勝てるようにする方法が複数通りある場合は、食べる石の個数を最小にするようにしたいです。\n不正者が食べる石の個数を求めてください。 不正をしても不正者が必ず勝つようにできない場合は、-1 を出力してください。\n\n-----問題ここまで----- */\n/* -----解説等-----\n\nすごい時間がかかった\nまず可能な操作は現在の数字に対して 何もしないあるいは (ゲーム値)^(a[i])^(a[i]-1)である。\n何も考えないとより良い方法としてゲーム値の2進数表現でのビットが立っている場所をたくさん0にできそうだが、それは嘘。\nというのはこの操作は最下位ビットを0にする操作だからである。\nしたがってa[i]の最下位bitを0にできるようになったので各桁について愚直にやっていけばよい\n\n----解説ここまで---- */\n\nLL N;\n\nLL ans = 0LL;\n\n\n\nint popcount2(int x) {//二進数中のbitが1の数\n\tint ret = 0;\n\twhile (x) {\n\t\tx &= x - 1;\n\t\t++ret;\n\t}\n\treturn ret;\n}\n\nstring to_binString(unsigned int val) //二進数表示\n{\n\tconst int size = 30;\n\tint index = size - 1;\n\tstring str(size, '0');\n\twhile (val != 0) {\n\t\tif ((val & 1) == 0)  // val は偶数か？\n\t\t\tstr[index] = '0';  //  偶数の場合\n\t\telse\n\t\t\tstr[index] = '1';  //  奇数の場合\n\t\tval >>= 1, index--;\n\t}\n\treturn str;\n}\nvoid print_bin(int a) {\n\tcout << to_binString(a) << endl;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\n\t{\n\t\tFOR(i, 0, 100) {\n\t\t\tcout << i << \": \"; debug((i&(i - 1)));\n\t\t\tcout << to_binString(i) << endl;\n\t\t\tcout << to_binString(i&(i - 1)) << endl;\n\t\t}\n\n\t\treturn 0;\n\t}\n\tcin >> N;\n\tVI a(N);\n\tVI cnt(31, 0);\n\tLL res = 0;\n\n\tFOR(i, 0, N) {\n\t\tcin >> a[i];\n\t\tres ^= a[i];\n\t\tcnt[popcount2((a[i] & -a[i]) - 1)]++;\n\t}\n\n\tdebug(res);\n\tFORR(i, 30, 0 - 1) {\n\t\tif (res &(1 << i)) {\n\t\t\tif (cnt[i]) {\n\t\t\t\tres ^= (1 << (i + 1)) - 1;\n\t\t\t\t//debug(res);\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (res)ans = -1;\n\n\tcout << ans << \"\\n\";\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5, MAX_M = 40;\nint n, x, ans, p;\nint a[MAX_N];\nint l[MAX_N];\nbool cnt[MAX_M];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\t\t\n\tfor (int i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (int i = 31; ~i; i--)\n\t\tif (((x >> i) & 1) ^ p) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tp = !p;\n\t\t\tcnt[i] = false;\n\t\t\tans++;\n\t\t}\n\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define pdd pair < db , db >\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int s[1 << 20];\n    int n;\n    fi>>n;\n    int cnt = 0;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i],cnt ^= s[i],s[i] ^= (s[i] - 1);\n    sort(s + 1,s + 1 + n,greater < int > ());\n    auto lg = [&](int x)\n    {\n        int ans = 0;\n        while ((++ans) && (x /= 2));\n        return ans;\n    };\n    int ans = 0;\n    for (int i = 1;cnt && i <= n;++i)\n        if (lg(cnt) == lg(s[i]))\n            cnt ^= s[i],++ans;\n    if (!cnt)\n        ans = -1;\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 13;\nint n, ans, x;\nbool mark[maxN];\nvector<int> vec;\nint main () {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n\tint a;\n\tcin >> a;\n\tx ^= a;\n\ta = __builtin_ctz(a);\n\tmark[a] = 1;\n    }\n\n    while (x) {\n\tvec.push_back(x % 2);\n\tx /= 2;\n    }\n    int indx = vec.size() - 1;\n    int lst = 0;\n    while (vec.size()) {\n\tint u = vec.back();\n\tvec.pop_back();\n\tif (u != lst) {\n\t    if (!mark[indx])\n\t\treturn cout << -1 << endl, 0;\n\t    else\n\t\tans++;\n\t}\n\tindx--;\n\tlst = u;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n#include \"cmath\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tM ^= v[i];\n\t}\n\tfor (int i = 31; i >=0; i--) {\n\t\tif (M >> i & 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (v[j] % (int)pow(2, i) == 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tM ^= (int)(pow(2, i) - 1);\n\t\t\tK++;\n\t\t}\n\t}\n\tcout << K << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\nint n; cin >> n; vector<int>v(n); for(int &b : v) cin >> b; int s = 0; for(int b : v) s ^= b; int sc = 0; for(int b : v) sc ^= (b - 1); if(s == 0) { cout << \"0\" << endl; } else if(sc == 0) { cout << n << endl; } else cout << \"-1\" << endl; }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 100010\nint n, a[N];\nint b[N];\n\nint main () {\n\tcin >> n;\n\tint S = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tcin >> a[i];\n\t\tS ^= a[i];\n\t\tb[i] = a[i] ^ (a[i]-1);\n\t}\n\tsort(b, b+n);\n\tint m = unique(b, b+n)-b;\n\tassert(m <= 20);\n\tint T = -1;\n\tfor (int p = 0; p < (1<<m); p++) {\n\t\tint SS = S;\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\tif ((p>>i)&1) SS ^= b[i];\n\t\tif (!SS) {\n\t\t\tint c = pct(p);\n\t\t\tif (T == -1 || T > c) T = c;\n\t\t}\n\t}\n\tcout << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                 \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint keta(int u){\n\tint r=1;\n\tfor(int i=0;i<40;i++){\n\t\tif(u==r) return i;\n\t\tr*=2;\n\t}\n\texit(1);\n}\n\nint u[40]={0};\n\n      signed main(){\n    int n;\n      \tint noko=0;\n      \tcin>>n;\n      \t\n      \tfor(int i=0;i<n;i++){\n      \t\tint uu;\n      \t\tcin>>uu;\n      \t\tint er=(uu&(-uu));\n      \t\tnoko^=uu-er;\n      \t\tu[keta(er)]^=1;\n      \t\n      \t}\n     // \tcout<<noko<<endl;\n      \tint ans=0;\n      \tfor(int i=35;i>=0;i--){\n      \t\tif(u[i]==0 && (noko&(1<<i))!=0){\n      \t\tcout<<-1<<endl;\n      \t\t\treturn 0;\n      \t\t}\n      \t\tif(u[i]==0) {\n      \t\t\tif(noko >(1<<i)) exit(1);\n      \t\t\tcontinue;\n      \t\t}\n      \t\tif((noko&(1<<i))){\n      \t\t\tnoko -= (1<<i);\n      \t\t}\n      \t\telse{\n      \t\t\tans++;\n      \t\t\tnoko ^= (1<<i)-1;\n      \t\t}\n      \t}\n      \t\n      \tif(noko){\n      \t\tcout<<-1<<endl;\n      \t}\n      \telse cout<<ans<<endl;\n      \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint pw[(1<<16)+3];\nvoid pre(){\n\tfor(int i=0;i<16;i++) pw[1<<i]=i;\n}\nint pos(int val){\n\tval=val&(-val);\n\tif((val>>16)==0) return pw[val];\n\telse return 16+pw[val>>16];\n}\nint n,tot;\nvector<int> v[35];\nint main(){\n\tscanf(\"%d\",&n);pre();\n\tfor(int i=1,t;i<=n;i++){\n\t\tscanf(\"%d\",&t);\n\t\ttot^=t;v[pos(t)].push_back(t);\n\t}\n\tint ans=0;\n\tfor(int i=30;i>=0;i--){\n\t\tif((tot>>i)&1){\n\t\t\tif(v[i].size()==0) return puts(\"-1\"),0;\n\t\t\tint t=v[i][0]-1;tot=tot^(t+1)^t;\n\t\t\tans++;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pi;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nint a[100010];\nint d[32];\n\nvoid solve(){\n\tint n; scanf(\"%d\", &n);\n\tint X = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\", a+i);\n\t\tint x = (a[i] ^ (a[i]-1));\n\t\tfor(int j=1;j<=30;j++){\n\t\t\tif((1<<j) - 1 == x)d[j-1]++;\n\t\t}\n\t\tX ^= a[i];\n\t}\n\tint ans = 0;\n\tfor(int i=29;i>=0;i--){\n\t\tif((X & 1<<i) && d[i] == 0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tif((X & 1<<i)){\n\t\t\tX ^= ((1<<(i+1))-1);\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\", ans);\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\\n\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nint main(){\n\tLL n;\n\tcin >> n;\n\tLL a[n];\n\tLL sum = 0;\n\tvector<int> d;\n\tvector<int> e;\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tfor(int i = 0; i < n; i++){\n\t\tsum ^= a[i];\n\t\t//cout << (a[i] & -a[i]) << endl;\n\t\td.push_back(2*(a[i] & -a[i]) - 1);\n\t\te.push_back((a[i] & -a[i]));\n\t\t//cout << (2*(a[i] & -a[i]) - 1) << endl;\n\t}\n\tLL ans = 0;\n\tsort(d.begin(), d.end());\n\treverse(d.begin(), d.end());\n\tsort(e.begin(), e.end());\n\treverse(e.begin(), e.end());\n\t//cout << sum << endl;\n\tfor(int i = 0; i < d.size(); i++){\n\t\t//cout << d[i] << \" \" << e[i] << endl;\n\t\tif(sum & e[i]){\n\t\t\tsum ^= d[i];\n\t\t\tans++;\n\t\t}\n\t}\n\tif(sum != 0){\n\t\tcout << -1 << endl;\n\t} else {\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint check[30];\n\nint main() {\n\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  int a;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n  return;\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconstexpr int MAXN = 1e5 + 5;\n\nint n, sum, cnt;\narray<int, MAXN> a, f;\n\nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i], sum^= a[i], a[i] ^= a[i -1];\n        for (int j = 30; ~j; j--) {\n            if ((a[i] >> j) & 1) {\n                f[j] = 1;\n                break;\n            }\n        }\n    }\n    for (int j = 30; ~j; j--)\n        if (((sum >> j) & 1) && f[j])\n            sum ^= (1 << (j + 1)) - 1, cnt++;\n    cout << (sum ? -1 : cnt) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ by shik\n#include <bits/stdc++.h>\n#include <unistd.h>\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x),end(x)\n#define REP(i,n) for ( int i=0; i<int(n); i++ )\n#define REP1(i,a,b) for ( int i=(a); i<=int(b); i++ )\n#define FOR(it,c) for ( auto it=(c).begin(); it!=(c).end(); it++ )\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\n\n#ifdef SHIK\ntemplate<typename T>\nvoid _dump( const char* s, T&& head ) { cerr<<s<<\"=\"<<head<<endl; }\n\ntemplate<typename T, typename... Args>\nvoid _dump( const char* s, T&& head, Args&&... tail ) {\n    int c=0;\n    while ( *s!=',' || c!=0 ) {\n        if ( *s=='(' || *s=='[' || *s=='{' ) c++;\n        if ( *s==')' || *s==']' || *s=='}' ) c--;\n        cerr<<*s++;\n    }\n    cerr<<\"=\"<<head<<\", \";\n    _dump(s+1,tail...);\n}\n\n#define dump(...) do { \\\n    fprintf(stderr, \"%s:%d - \", __PRETTY_FUNCTION__, __LINE__); \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n} while (0)\n\ntemplate<typename Iter>\nostream& _out( ostream &s, Iter b, Iter e ) {\n    s<<\"[\";\n    for ( auto it=b; it!=e; it++ ) s<<(it==b?\"\":\" \")<<*it;\n    s<<\"]\";\n    return s;\n}\n\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const pair<A,B> &p ) { return s<<\"(\"<<p.first<<\",\"<<p.second<<\")\"; }\ntemplate<typename T>\nostream& operator <<( ostream &s, const vector<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T, size_t N>\nostream& operator <<( ostream &s, const array<T,N> &c ) { return _out(s,ALL(c)); }\ntemplate<typename T>\nostream& operator <<( ostream &s, const set<T> &c ) { return _out(s,ALL(c)); }\ntemplate<typename A, typename B>\nostream& operator <<( ostream &s, const map<A,B> &c ) { return _out(s,ALL(c)); }\n#else\n#define dump(...)\n#endif\n\ntemplate<typename T>\nvoid _R( T &x ) { cin>>x; }\nvoid _R( int &x ) { scanf(\"%d\",&x); }\nvoid _R( long long &x ) { scanf(\"%\" PRId64,&x); }\nvoid _R( double &x ) { scanf(\"%lf\",&x); }\nvoid _R( char &x ) { scanf(\" %c\",&x); }\nvoid _R( char *x ) { scanf(\"%s\",x); }\n\nvoid R() {}\ntemplate<typename T, typename... U>\nvoid R( T& head, U&... tail ) {\n    _R(head);\n    R(tail...);\n}\n\ntemplate<typename T>\nvoid _W( const T &x ) { cout<<x; }\nvoid _W( const int &x ) { printf(\"%d\",x); }\ntemplate<typename T>\nvoid _W( const vector<T> &x ) {\n    for ( auto i=x.cbegin(); i!=x.cend(); i++ ) {\n        if ( i!=x.cbegin() ) putchar(' ');\n        _W(*i);\n    }\n}\n\nvoid W() {}\ntemplate<typename T, typename... U>\nvoid W( const T& head, const U&... tail ) {\n    _W(head);\n    putchar(sizeof...(tail)?' ':'\\n');\n    W(tail...);\n}\n\n#ifdef SHIK\n#define FILEIO(...)\n#else\n#define FILEIO(name) do {\\\n    freopen(name \".in\",\"r\",stdin); \\\n    freopen(name \".out\",\"w\",stdout); \\\n} while (0)\n#endif\n\n// }}}\n\ninline int bit( int x, int i ) {\n    return (x>>i)&1;\n}\n\nconst int N=1e5+10;\nint n,a[N],b[N];\nint main() {\n    R(n);\n    REP(i,n) R(a[i]);\n    int s=0;\n    REP(i,n) s^=a[i];\n    REP(i,n) b[i]=a[i]^(a[i]-1);\n    dump(s);\n    REP(i,n) dump(i,b[i]);\n    int ans=0;\n    for ( int i=30; i>=0; i-- ) if ( bit(s,i) ) {\n        ans++;\n        bool ok=0;\n        REP(j,n) if ( bit(b[j],i) && (s^b[j])<s ) {\n            ok=1;\n            s^=b[j];\n            break;\n        }\n        if ( !ok ) {\n            W(-1);\n            return 0;\n        }\n    }\n    W(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define rep(i,a,b) for (rint i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (rint i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (rint i=0,_E=(n); i<_E; ++i)\n#define pb push_back\n#define cmin(x,y) (y<x?x=y:0)\n#define cmax(x,y) (y>x?x=y:0)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 100005;\nint c[32], x, n, res, cnt, ans;\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) {\n\t\tscanf(\"%d\", &x);\n\t\tres ^= x;\n\t\tcnt = 0;\n\t\twhile (x && (x % 2 == 0))\n\t\t\tx >>= 1, ++ cnt;\n\t\tc[cnt] = 1;\n\t}\n\tper (i, 30, 0)\n\t\tif (res >> i & 1) {\n\t\t\tres ^= (1 << (i + 1)) - 1;\n\t\t\t++ ans;\n\t\t\tif (!c[i]) return puts(\"-1\"), 0;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                 \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint keta(int u){\n\tint r=1;\n\tfor(int i=0;i<40;i++){\n\t\tif(u==r) return i;\n\t\tr*=2;\n\t}\n\texit(1);\n}\n\nint u[40]={0};\n\n      signed main(){\n    int n;\n      \tint noko=0;\n      \tcin>>n;\n      \t\n      \tfor(int i=0;i<n;i++){\n      \t\tint uu;\n      \t\tcin>>uu;\n      \t\tint er=(uu&(-uu));\n      \t\tnoko^=uu-er;\n      \t\tu[keta(er)]^=1;\n      \t\n      \t}\n     // \tcout<<noko<<endl;\n      \tint ans=0;\n      \tfor(int i=31;i>=0;i--){\n      \t\tif(u[i]==0 && (noko&(1<<i))!=0){\n      \t\tcout<<-1<<endl;\n      \t\t\treturn 0;\n      \t\t}\n      \t\tif(u[i]==0) {\n      \t\t\tif(noko >(1<<i)) exit(1);\n      \t\t\tcontinue;\n      \t\t}\n      \t\tif((noko&(1<<i))){\n      \t\t\tnoko -= (1<<i);\n      \t\t}\n      \t\telse{\n      \t\t\tans++;\n      \t\t\tnoko ^= (1<<i)-1;\n      \t\t}\n      \t}\n      \t\n      \tif(noko){\n      \t\tcout<<-1<<endl;\n      \t}\n      \telse cout<<ans<<endl;\n      \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tvector<ll> v(n);\n\tll s = 0;\n\trep(i, n){\n\t\tll a;\n\t\tcin>>a;\n\t\tv[i] = a^(a-1);\n\t\ts ^= a;\n\t}\n\tsort(all(v)); UNIQUE(v); reverse(all(v));\n\tcerr<<v.size()<<endl;\n\tcerr<<v<<endl;\n\tll res = 0;\n\trep(i, v.size()){\n\n\t\tif(s^v[i]<s){\n\t\t\ts ^= v[i];\n\t\t\tres++;\n\t\t}\n\t}\n\tcout<<(s?-1:res)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,s,ans;\nint a[N];\nbool tag[N];\n\nint main(){\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]),s^=a[i];\n\t\ta[i]=a[i]^(a[i]-1);\n\t\tfor (j=0;j<=30&&((a[i]>>j)&1);j++);\n\t\ttag[j-1]=1;\n\t}\n\tfor (i=30;i>=0;i=j){\n\t\tj=i;\n\t\tif (((s>>i)&1)==0){\n\t\t\tj--;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (j>=0&&((s>>j)&1)) j--;\n\t\tif (tag[i]) ans++;\n\t\telse{\n\t\t\tans=-1;\n\t\t\tbreak;\n\t\t}\n\t\tif (j>=0&&tag[j]) ans++;\n\t\telse if (j>=0&&!tag[j]){\n\t\t\tans=-1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nconst long long MOD = 1000000007;\n\nint main(){\n    int N;\n    cin >> N;\n\n    vector<ll> a(N);\n    vector<ll> can_change(33, 0);\n    ll x = 0;\n    for(int i=0;i<N;i++){\n        cin >> a[i];\n        x ^= a[i];\n        ll diff = (a[i] - 1) ^ a[i];\n        for(int bit=32;bit>=0;bit--){\n            if((diff>>bit)&1){\n                can_change[bit] = a[i];\n                break;\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int bit=32;bit>=0;bit--){\n        if (((x >> bit)&1)==0) continue;\n        if(can_change[bit] == 0){\n            cout << -1 << endl;\n            return 0;\n        }else{\n            x ^= can_change[bit];\n            x ^= can_change[bit] - 1;\n            ans++;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int N;\n  cin >> N;\n\n  vector<int> a(N);\n  for (auto &i : a) cin >> i;\n\n  int nim = 0;\n  for (auto &i : a) {\n    nim ^= i;\n    i = i & -i;\n  }\n\n  sort(a.rbegin(), a.rend());\n  int ans = 0;\n  for (int i = 0; i < N; ++i) {\n    if (nim & a[i]) {\n      nim ^= a[i] + a[i] - 1;\n      ans++;\n    }\n  }\n\n  if (nim) ans = -1;\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_set>\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    xor_sum ^= x;\n    s.insert(x ^ (x - 1));\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.find(x) != s.end()) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint a[MAX_N];\nint b[MAX_N];\n\nint main()\n{\n\tint n,x=0,ans=0;\n\tcin >> n;\n\trep(i,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tx ^= a[i];\n\t\tb[i] = a[i]^(a[i]-1);\n\t}\n\tfor(int k=29;k>0;k--){\n\t\trep(i,n){\n\t\t\tif(b[i] == pow(2,k)-1){\n\t\t\t\tif(x & (1 << (k-1))){\n\t\t\t\t\tx ^= b[i];\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(x==0){\n\t\tcout << ans << \"\\n\";\n\t}else{\n\t\tcout << \"-1\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N; cin >> N;\n\tvector<int> a(N);\n\tint x = 0;\n\trep(i, N) cin >> a[i], x ^= a[i];\n\tvector<int> d(N);\n\trep(i, N) d[i] = a[i] ^ (a[i] - 1);\n\tvector<bool> c(31);\n\trep(i, N) {\n\t\tint k = 0;\n\t\tfor (; d[i]; d[i] /= 2) k++;\n\t\tc[k - 1] = true;\n\t}\n\tint ans = 0;\n\tfor (int k = 30; k >= 0; k--)\n\t\tif (x>>k & 1) {\n\t\t\tif (!c[k]) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tx ^= (1<<(k + 1)) - 1;\n\t\t\tans++;\n\t\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define YES(condition) if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl\n#define Yes(condition) if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl\n#define POSS(condition) if(condition) cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl\n#define Poss(condition) if(condition)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl\n#define First(condition) if(condition)cout << \"First\" << endl; else cout << \"Second\" << endl\n#define negative(condition, num) if(condition)cout << -1 << endl; else cout << num << endl\nlong power(long base, long exponent, long mod){ if(exponent % 2){ return power(base, exponent - 1, mod) * base % mod; }else if(exponent){ long root_ans = power(base, exponent / 2, mod); return root_ans * root_ans % mod; }else{ return 1; }}\n\nint main(){\n    int N;\n    cin >> N;\n    long grundy_xor = 0;\n    set<long, greater<long>> nums_standing_lsb;\n    for(int i = 0; i < N; i++){\n        long num;\n        cin >> num;\n        grundy_xor ^= num;\n        nums_standing_lsb.insert(num & -num);\n    }\n    int ans = 0;\n    while(!nums_standing_lsb.empty()){\n        if(grundy_xor & *(nums_standing_lsb.begin())){\n            grundy_xor ^= *(nums_standing_lsb.begin()) * 2 - 1;\n            ans++;\n            nums_standing_lsb.erase(nums_standing_lsb.begin());\n        }\n    }\n    negative(grundy_xor, ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define IN freopen(\"nocross.in\",\"r\",stdin)\n#define OUT freopen(\"nocross.out\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 2000000000000000000LL\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define LOG 19\n#define off 2\n\n#define mod 1000000007LL\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less< i64 >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\n#define maxn 100005\n\nint yes[35] ;\nint a[maxn] ;\n\nint main()\n{\n    int n ;\n\n    scanf(\"%d\",&n) ;\n\n    for(int i=1 ; i<=n ; i++) scanf(\"%d\",&a[i]) ;\n\n    int x = 0 ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        x ^= a[i] ;\n        int c = 0 ;\n        while( a[i]%2 == 0 )\n        {\n            a[i] /= 2 ;\n            c++ ;\n        }\n        yes[c] = 1 ;\n    }\n\n    int ans = 0 ;\n\n    for(int i=29 ; i>=0 ; i--)\n    {\n        if( (x&(1<<i)) )\n        {\n            if( yes[i] ) x ^= ( (1<<(i+1)) - 1 ) ;\n            ans++ ;\n        }\n    }\n\n    if(x!=0)\n    {\n        printf(\"-1\\n\") ;\n    }\n    else printf(\"%d\\n\",ans) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N = 100000;\nint n, a[N];\nbool cmp(int a, int b) {\n\treturn (a & -a) > (b & -b);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tsort(a, a + n, cmp);\n\tint Xor = 0, ans = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tXor ^= a[i];\n\tfor (int i = 0; i < n; ++i)\n\t\tif (Xor & (a[i] & -a[i]))\n\t\t\tXor ^= 2 * (a[i] & -a[i]) - 1, ++ans;\n\tprintf(\"%d\", Xor == 0 ? ans : -1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=500000004;\nconst double EPS=1e-6;\nconst double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nint p[110000];\nint ct[110];\nmap<int,int>L;\n\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tint val=0;\n\tfor(int i=0;i<a;i++){\n\t\tval^=p[i];\n\t\tint tmp=p[i];\n\t\tint t=0;\n\t\twhile(tmp%2==0){t++;tmp/=2;}\n\t\tct[t]++;\n\t}\n\tint sz=0;\n\tint H=15;\n\tfor(int i=0;i<(1<<H);i++){\n\t\tbool ok=true;\n\t\tint now=0;\n\t\tint cnt=0;\n\t\tfor(int j=0;j<H;j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tcnt++;\n\t\t\t\tif(ct[j]==0)ok=false;\n\t\t\t\tnow^=(1<<(j+1))-1;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tif(L.count(now)){\n\t\t//\t\tprintf(\"%d: %d\\n\",now,cnt);\n\t\t\t\tL[now]=min(L[now],cnt);\n\t\t\t}else{\n\t\t\t\tL[now]=cnt;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=mod;\n\tfor(int i=0;i<(1<<H);i++){\n\t\tbool ok=true;\n\t\tint now=0;\n\t\tint cnt=0;\n\t\tfor(int j=0;j<H;j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tcnt++;\n\t\t\t\tif(ct[j+H]==0)ok=false;\n\t\t\t\tnow^=(1<<(j+H+1))-1;\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tif(L.count(val^now)){\n\t\t\t\tret=min(ret,cnt+L[val^now]);\n\t\t\t}\n\t\t}\n\t}\n\tif(ret==mod)ret=-1;\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define pdd pair < db , db >\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int s[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    int cnt = 0;\n    static int was[1 << 20];\n    for (int i = 1;i <= n;++i)\n        cnt ^= s[i];\n    for (int i = 30;i + 1;--i)\n        if ((cnt >> i) & 1)\n        {\n            for (int j = 1;j <= n;++j)\n            if (!was[j])\n            {\n                int nxt = cnt ^ s[j] ^ (s[j] - 1);\n                if (!((nxt >> i) & 1))\n                {\n                    was[j] = 1;\n                    cnt = nxt;\n                    break;\n                }\n            }\n            if ((cnt >> i) & 1)\n                return puts(\"-1\") * 0;\n        }\n    fo << accumulate(was + 1,was + 1 + n,0) << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nint tab[1000007];\nint x;\n\nint wyn;\n\nint naj(int v)\n{\n\tint ret=0;\n\twhile(v)\n\t{\n\t\tret++;\n\t\tv>>=1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &tab[i]);\n\t\tx^=tab[i];\n\t\ttab[i]^=tab[i]-1;\n\t}\n\tsort(tab+1, tab+1+n);\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (naj(x)==naj(tab[i]))\n\t\t{\n\t\t\twyn++;\n\t\t\tx^=tab[i];\n\t\t}\n\t}\n\tif (x)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tprintf(\"%d\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 20)\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\n\nint main() {\n    int N;\n    cin >> N;\n    int x = 0;\n    bool div[32] = {};\n\n    rep(i,0,N){\n        int tmp;\n        cin >> tmp;\n        x ^= tmp;\n        for(int j = 0; ;j++){\n            if(tmp >> j & 1){\n                div[j] = true;\n                break;\n            }\n        }\n    }\n    int cnt = 0;\n    while(x != 0){\n        int j;\n        for(j = 0; x >> j > 0; j++){\n\n        }\n        x ^= ((1 << j) - 1);\n        cnt++;\n        if(!div[j-1]){\n            cnt = -1;\n            break;\n        }\n\n    }\n    cout << cnt << endl;\n\n\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n#include <vector>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n\n\n#include <algorithm>\n\n\n\ntemplate <typename R>\nvoid sort(R& range) {\n\tstd::sort(range.begin(), range.end());\n}\n\ntemplate <typename R, typename Comp>\nvoid sort(R& range, Comp comp) {\n\tstd::sort(range.begin(), range.end(), comp);\n}\n\ntemplate <typename R>\nvoid reverse(R& range) {\n\tstd::reverse(range.begin(), range.end());\n}\n\ntemplate <typename R, typename T>\nauto lower_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto lower_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::lower_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R, typename T>\nauto upper_bound(const R& range, const T& value) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value);\n}\n\ntemplate <typename R, typename T, typename Comp>\nauto upper_bound(const R& range, const T& value, Comp comp) -> decltype(range.begin()) {\n\treturn std::upper_bound(range.begin(), range.end(), value, comp);\n}\n\ntemplate <typename R>\nauto min_element(const R& range) -> decltype(range.begin()) {\n\treturn std::min_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nauto max_element(const R& range) -> decltype(range.begin()) {\n\treturn std::max_element(range.begin(), range.end());\n}\n\ntemplate <typename R>\nbool next_permutation(R& range) {\n\treturn std::next_permutation(range.begin(), range.end());\n}\n\ntemplate <typename T>\nvoid unique(std::vector<T>& range) {\n\trange.erase(std::unique(range.begin(), range.end()), range.end());\n}\n\ntemplate <typename R>\nR sorted(R range) {\n\tsort(range);\n\treturn range;\n}\n\ntemplate <typename R, typename Comp>\nR sorted(R range, Comp comp) {\n\tsort(range, comp);\n\treturn range;\n}\n\ntemplate <typename R>\nR reversed(R range) {\n\treverse(range);\n\treturn range;\n}\n\n\nusing namespace std;\n\nclass TaskC {\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\tint n;\n\t\tin >> n;\n\t\tvector<int> a(n);\n\t\tvector<int> pos(n);\n\t\tint x = 0;\n\t\tfor (int i: range(n)) {\n\t\t\tin >> a[i];\n\t\t\tx ^= a[i];\n\t\t\tpos[i] = a[i] ^ (a[i] - 1);\n\t\t}\n\n\t\tsort(pos);\n\t\tunique(pos);\n\n\n\t\tint ans = 0;\n\t\tfor (int y: reversed(pos)) {\n\t\t\tif ((x ^ y) < x) {\n\t\t\t\tx ^= y;\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tif (x == 0) {\n\t\t\tout << ans << \"\\n\";\n\t\t} else {\n\t\t\tout << -1;\n\t\t}\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskC solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin p2(in a){\n  return 1LL<<a;\n}\nVI hs;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  hs.resize(32);\n  in xr=0;\n  in a;\n  forn(z,n){\n    cin>>a;\n    in cv;\n    for(in i=0;i<32;++i){\n      if(a&p2(i)){\n\tcv=i;\n\tbreak;\n      }\n    }\n    hs[cv]=1;\n    xr^=a;\n  }\n  in eat=0;\n  for(in i=31;i>=0;--i){\n    if(xr&p2(i)){\n      if(hs[i]){\n\t++eat;\n\txr^=(p2(i+1)-1);\n      }\n    }\n  }\n  if(xr)\n    cout<<-1<<endl;\n  else\n    cout<<eat<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint main(){\n\tint n;\n\tcin >> n;\n\n\tvector<int> a(n);\n\tmap<int,int> m;\n\tint s = 0;\n\trep(i,n){\n\t\tcin >> a[i];\n\t\tm[ a[i] ]++;\n\t\ts ^= a[i];\n\t}\n\n\tbitset<30> b(s);\n\tint ans = 0;\n\tfor(int i = 30 - 1; i >= 0; i--){\n\t\t//show(s)\n\t\tif(b[i]){\n\t\t\tint tmp = 1 << i;\n\t\t\t//show(tmp)\n\t\t\tif(m[tmp] > 0){\n\t\t\t\tm[tmp]--;\n\t\t\t\ts ^=  tmp;\n\t\t\t\ttmp--;\n\t\t\t\ts ^= tmp;\n\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tb = bitset<30>(s);\n\t}\n\n\tfor(auto i : m){\n\t\tif(i.second > 0 && i.first % 2 == 1){\n\t\t\tans++;\n\t\t\ts ^= 1;\n\t\t}\n\t}\n\n\tcout << (s == 0 ? ans : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 100, C = 29;\n\nint a[N], cnt[N];\nint n, ans, tmp;\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tfor (int j = 0; j <= C; j++)\n\t\t\tif ((a[i] >> j) & 1) {\n\t\t\t\tcnt[j]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\ttmp ^= a[i];\n\t}\n\tfor (int i = C; i >= 0; i--) {\n\t\tif ((tmp >> i) & 1) {\n\t\t\tif (!cnt[i])\n\t\t\t\treturn cout << -1, 0;\n\t\t\tans++;\n\t\t\ttmp ^= (1 << (i + 1)) - 1;\n\t\t}\n\t}\n\treturn cout << ans, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n#define lb(x) ((x)&(-(x)))\n#define xx first\n#define yy second\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int> \n#define dalao 1000000007\n#define inf 0x3f3f3f3f\n#define N 100010\nusing namespace std;\ntypedef long long ll;\nint n,a[N],s,ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),s^=a[i];\n\tfor(int i=29;~i;i--)if(s>>i&1)\n\t\tfor(int j=1;j<=n;j++)if(lb(a[j])==1<<i){ans++,s^=(1<<i+1)-1;break;}\n\tif(s)puts(\"-1\");else cout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define inf 100000000000000000\n#define rep(i,a) for(ll i=0; i<a; ++i)\n#define pb push_back\n\nll n;\nll a[100005];\nll cnt[20];\nll x=0;\n\nll getLastOneIndex(ll p) {\n  if (p%2==1) {\n    return 0;\n  } else {\n    return 1+getLastOneIndex(p/2);\n  }\n}\n\nvector<ll> reversedBitVector(ll p) {\n  vector<ll> ret;\n  for (ll i=0; i<20; ++i) {\n    ret.pb(p&1);\n    p = p>>1;\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin>>n;\n  rep(i,n) {\n    cin>>a[i];\n  }\n  rep(i,n) {\n    ll lastOneIndex = getLastOneIndex(a[i]);\n    x ^= (a[i]-(1<<lastOneIndex));\n    cnt[lastOneIndex]++;\n  }\n\n  ll ans=0;\n  vector<ll> revBit = reversedBitVector(x);\n  for (ll i=revBit.size()-1; i>=0; --i) {\n    if (revBit[i]==1) {\n      if (cnt[i]==0) {\n        cout<<-1<<endl;\n        return 0;\n      }\n      if (cnt[i]%2==0) {\n        ans++;\n        for (ll j=i-1; j>=0; --j) {\n          revBit[j] = 1-revBit[j];\n        }\n      }\n    } else {\n      if (cnt[i]%2==1) {\n        ans++;\n        for (ll j=i-1; j>=0; --j) {\n          revBit[j] = 1-revBit[j];\n        }\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,a,x,c,k[30];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a;\n\t\tx^=a;\n\t\ta^=a-1;\n\t\tfor(int j=1;j<30;j++)if(a==(1<<j)-1)k[j]=1;\n\t}\n\tfor(int i=29;i>0;i--)\n\t{\n\t\tif(x&(1<<(i-1))&&k[i])c++,x^=(1<<i)-1;\n\t}\n\tcout<<(x?-1:c)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\nusing namespace std;\n\nint n, s, a[110000], b[110000], ans;\n\nint main() {\n\tscanf(\"%d\", &n);\n\ts = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]), s ^= a[i];\n\tfor (int j = 1; j <= n; j++) {\n\t\tfor (int i = 31; i >= 0; i--)\n\t\t\tif (a[j] % (1 << i) == 0) {\n\t\t\t\tb[i] += 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tfor (int i = 31; i >= 0; i--)\n\t\tif (s & (1 << i)) {\n\t\t\tif (!b[i]) {\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts ^= (1 << i) - 1;\n\t\t\tans += 1;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\t// for (int i = 0; i <= 31; i++) {\n\t// \tfor (int j = 1; j <= n; j++)\n\t// \t\tif (a[j] % (1 << i) == 0)\n\t// \t\t\tb[i][j] = 1;\n\t// \tif (s & (1 << i))\n\t// \t\tb[i][0] = 1;\n\t// \telse\n\t// \t\tb[i][0] = 0;\n\t// }\n\n\t// for (int i = 1; i <= n; i++)\n\t// \tfor (int j = 0; j <= 31; j++)\n\t// \t\tif (b[j][i]) {\n\t// \t\t\tfor (int p = j + 1; p <= 31; p++)\n\t// \t\t\t\tif (b[p][i]) {\n\t// \t\t\t\t\tfor (int q = 0; q <= n; q++)\n\t// \t\t\t\t\t\tb[p][q] ^= b[j][q];\n\t// \t\t\t\t}\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// for (int i = 0; i <= 30; i++) {\n\t// \tint cur = 0;\n\t// \tfor (int j = 1; j <= n; j++)\n\t// \t\tcur += b[i][j];\n\t// \tif (!cur && b[i][0]) {\n\t// \t\tprintf(\"-1\\n\");\n\t// \t\treturn 0;\n\t// \t}\n\t// }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 1000100\nint n, a[N];\nint b[N];\n\nint main () {\n\tcin >> n;\n\tint S = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tcin >> a[i];\n\t\tS ^= a[i];\n\t\tb[i] = a[i] ^ (a[i]-1);\n\t}\n\tsort(b, b+n);\n\tint m = unique(b, b+n)-b;\n\tint T = -1;\n\tfor (int p = 0; p < (1<<m); p++) {\n\t\tint SS = S;\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\tif ((p>>i)&1) SS ^= b[i];\n\t\tif (!SS) {\n\t\t\tint c = pct(p);\n\t\t\tif (T == -1 || T > c) T = c;\n\t\t}\n\t}\n\tcout << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_reverse(i, n) for (int i = (n)-1; (i) >= 0; --(i))\nusing namespace std;\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<int> a(n); repeat (i, n) scanf(\"%d\", &a[i]);\n    // solve\n    int sum_a = 0;\n    vector<bool> cnt(30);\n    for (int a_i : a) {\n        sum_a ^= a_i;\n        cnt[__builtin_ctz(a_i)] = true;\n    }\n    int result = 0;\n    repeat_reverse (i, 30) {\n        if (sum_a & (1 << i)) {\n            if (not cnt[i]) {\n                result = -1;\n                break;\n            } else {\n                result += 1;\n                sum_a ^= (1 << (i + 1)) - 1;\n            }\n        }\n    }\n    // output\n    printf(\"%d\\n\", result);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nint sum;\nint as[114514];\nint ans = 0;\nmap<int, int> cnt;\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", &as[i]);\n    sum ^= as[i];\n    cnt[as[i]]++;\n  }\n\n  for (int i=30; i>=0; i--) {\n    if (sum >> i & 1) {\n      if (!cnt.count(1 << i)) {\n        puts(\"-1\");\n        return 0;\n      }\n\n      int t = 1 << i;\n      sum ^= t;\n      --t;\n      sum ^= t;\n      cnt[t]++;\n      ans++;\n    }\n  }\n\n  if (sum == 0) {\n    printf(\"%d\\n\", ans);\n  } else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\nint n; cin >> n; vector<int>v(n); for(int &b : v) cin >> b; int s = 0; for(int b : v) s ^= b; int sc = 0; for(int b : v) sc ^= (b - 1); if(s == 0) { cout << \"0\" << endl; } else if(sc == 0) { cout << n << endl; } else cout << \"-1\" << endl; }"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <iostream>\n\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int L = 32;\n\nint n, cnt[L + 10];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n;\n\tint grand = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tgrand ^= a;\n\t\tint lb = __builtin_popcount(a ^ (a - 1)) - 1;\n\t\tif (lb >= 0)\n\t\t\tcnt[lb]++;\n\t}\n\n\tint ans = 0;\n\tfor (int i = L; ~i; i--) \n\t\tif (((grand * 1LL) >> i) & 1LL) {\n\t\t\tif (cnt[i] == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tgrand ^= (1LL << (i + 1)) - 1;\n\t\t\t\tans ++;\n\t\t\t}\n\t\t}\n\tcout << ans << endl;\n}\n\n// SamMHD :: Apr10-2019 :: Another Code BEFORE Marhale2!!..."
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 32, N = 1e5 + 10;\nint n, x, ans, t, a, cnt[N];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> a;\n\t\tcnt[__builtin_ctz(a)]++;\n\t\tx ^= a;\n\t}\n\t\n\tbool t = 1;\n\tfor (int i = L - 1; i >= 0; i--){\n\t\tif((x >> i) % 2 == t){\n\t\t\tif(cnt[i] == 0)\n\t\t\t\treturn cout << -1, 0;\n\t\t\tt = 1 - t;\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                 \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint keta(int u){\n\tint r=1;\n\tfor(int i=0;i<40;i++){\n\t\tif(u==r) return i;\n\t\tr*=2;\n\t}\n\texit(1);\n}\n\nint u[40]={0};\n\n      signed main(){\n    int n;\n      \tint noko=0;\n      \tcin>>n;\n      \t\n      \tfor(int i=0;i<n;i++){\n      \t\tint uu;\n      \t\tcin>>uu;\n      \t\tint er=(uu&(-uu));\n      \t\tnoko^=uu-er;\n      \t\tu[keta(er)]^=1;\n      \t\n      \t}\n     // \tcout<<noko<<endl;\n      \tint ans=0;\n      \tfor(int i=31;i>=0;i--){\n      \t\tif(u[i]==0 && (noko&(1<<i))!=0){\n      \t\tcout<<-1<<endl;\n      \t\t\treturn 0;\n      \t\t}\n      \t\tif(u[i]==0) continue;\n      \t\t\n      \t\tif((noko&(1<<i))){\n      \t\t\tnoko -= (1<<i);\n      \t\t}\n      \t\telse{\n      \t\t\tans++;\n      \t\t\tnoko ^= (1<<i)-1;\n      \t\t}\n      \t}\n      \t\n      \tif(noko){\n      \t\tcout<<-1<<endl;\n      \t}\n      \telse cout<<ans<<endl;\n      \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define pdd pair < db , db >\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int s[1 << 20];\n    int n;\n    fi>>n;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i];\n    int cnt = 0;\n    static int was[1 << 20];\n    for (int i = 1;i <= n;++i)\n        cnt ^= s[i];\n    for (int i = 0;i < 31;++i)\n        if ((cnt >> i) & 1)\n        {\n            for (int j = 1;j <= n;++j)\n            if (!was[j])\n            {\n                int nxt = cnt ^ s[j] ^ (s[j] - 1);\n                if (!((nxt >> i) & 1))\n                {\n                    was[j] = 1;\n                    cnt = nxt;\n                    break;\n                }\n            }\n            if ((cnt >> i) & 1)\n                return puts(\"-1\") * 0;\n        }\n    fo << accumulate(was + 1,was + 1 + n,0) << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n#include \"cmath\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tM ^= v[i];\n\t}\n\tfor (int i = 31; i >=0; i--) {\n\t\tif (M >> i & 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (v[j] % (int)pow(2, i) == 0) {\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tM ^= (int)pow(2, i);\n\t\t\tM ^= (int)(pow(2, i) - 1);\n\t\t\tK++;\n\t\t}\n\t}\n\tif (!M) {\n\t\tcout << K << endl;\n\t}\n\telse {\n\t\tcout << \"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int LLI;\n\nint N;\nint ans;\nLLI sum;\nint cnt[32];\nLLI as[114514];\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i=0; i<N; i++) {\n    scanf(\"%lld\", &as[i]);\n    sum ^= as[i];\n    for (int j=0; j<32; j++) {\n      if (as[i] >> j & 1) {\n        cnt[j]++;\n        break;\n      }\n    }\n  }\n\n  for (int i=31; i>=0; i--) {\n    if (sum >> i & 1) {\n      LLI t = 1LL << i;\n      if (cnt[i] <= 0) {\n        puts(\"-1\");\n        return 0;\n      }\n\n      sum ^= t;\n      --t;\n      sum ^= t;\n      ans++;\n    }\n  }\n\n  if (sum == 0) {\n    printf(\"%d\\n\", ans);\n  } else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10, M = 32;\nint n, ans, x, ar[N], cnt[N], mark[M];\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ar[i];\n\t\tx ^= ar[i];\n\t\t\n\t\tint tmp = ar[i];\n\t\twhile (tmp % 2 == 0) {\n\t\t\tcnt[i]++;\n\t\t\ttmp /= 2;\n\t\t}\n\t\tmark[++cnt[i]]++;\n\t}\n\t\n\tfor (int i = M - 2; i >= 0; i--)\n\t\tif (x & (1LL << i)) {\n\t\t\tif (!mark[i + 1])\n\t\t\t\treturn cout << -1, 0;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*/Saya-Javelin/*/\n#include <cstdio>\n//#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#define Fo freopen (\"file.in\", \"r\", stdin), freopen (\"file.out\", \"w\", stdout)\n#define Fc fclose (stdin), fclose (stdout)\n#define iln inline\n#define rgt register\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Abs(a) ((a)>0?(a):-(a))\n#define Swap(a,b) (a)^=(b)^=(a)^=(b)\n#define Sqr(x) ((x)*(x))\n//#define int long long\n#define ll long long\n#define ld double\n\nconst int S=1000000;\nchar RRR[S];\nchar *SSR, *UR;\n\niln char fgc () {\n\tif (SSR==UR) UR=(SSR=RRR)+fread (RRR, 1, S, stdin);\n\treturn *SSR++;\n}\n\n//#define gc rrr=fgc()\n#define gc rrr=getchar()\niln void read (int &ur) {\n\tint ssr=1; char rrr; ur=0;\n\twhile (gc, rrr>'9' || rrr<'0')\n\tif (rrr=='-') ssr=-1;\n\twhile (rrr>='0' && rrr<='9')\n\tur=ur*10+rrr-'0', gc;\n\treturn (void) (ur*=ssr);\n}\n#undef gc\n\niln void write (int ur) {\n\tif (ur<0) putchar ('-'), ur*=-1;\n\tif (ur>=10) write (ur/10);\n\treturn (void) putchar (ur%10+'0');\n}\n\niln void wtn (int ur) {\n\twrite (ur);\n\treturn (void) putchar ('\\n');\n}\n\niln void wts (int ur) {\n\twrite (ur);\n\treturn (void) putchar (' ');\n}\n\nint n, in;\nint a[100001];\nint ans=0, k=0;\nbool wei[33]={0};\n\nsigned main (void) {\n\tread (n);\n\tfor (rgt int i=1; i<=n; ++i) {\n\t\tread (a[i]); ans^=a[i];\n\t\tfor (rgt int j=0; j<=30; ++j) {\n\t\t\tif (a[i]&(1<<j)) {\n\t\t\t\twei[j]=1; \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (rgt int i=30; i>=0; --i) {\n\t\tif (ans&(1<<i)) {\n\t\t\tif (!wei[i]) return wtn (-1), 0;\n\t\t\tans^=(1<<(i+1))-1;\n\t\t\tk++;\n\t\t}\n\t}\n\twtn (k);\n}//hyj ak ioi"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <map>\nusing namespace std;\n\ntypedef long long lint;\ntypedef unsigned long long ulint;\n\nint main(){\n    lint N;\n    cin >> N;\n    ulint *A,*D;\n    A=new ulint[N];\n    D=new ulint[N];\n    ulint X=0,E=0;\n    for(lint i=0;i<N;i++){\n        cin >> A[i];\n        D[i]=A[i]^(A[i]-1);\n        X^=A[i];\n        E|=D[i]+1;\n    }\n\n    bool one=false;\n    lint cnt=0;\n    for(int i=31;i>=0;i--){\n        if((X&(1<<i))!=one){\n            if((E&(1<<(i+1)))==0){\n                cout << \"-1\" << endl;\n                return 0;\n            }\n            cnt++;\n            one=!one;\n        }\n    }\n    cout << cnt << endl;\n\n\n    delete[] A,D;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<iomanip>\n#include<set>\n#define rep(index,num) for(int index=0;index<num;index++)\n#define rep1(index,num) for(int index=1;index<=num;index++)\n#define brep(index,num) for(int index=num-1;index>=0;index--)\n#define brep1(index,num) for(int index=num;index>0;index--)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-7\n#define mp(a1,a2) make_pair(a1,a2)\n#define ALL(a) (a).begin(),(a).end()\n#define rALL(a) (a).rbegin(),(a).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=1e+18+1;\nint INF=1e+9+1;\nint main(){\n\tll N,a[100001],axor=0;\n\tmap<ll,bool> sax;\n\tscan(N);\n\trep(i,N){\n\t\tscan(a[i]);\n\t\taxor^=a[i];\n\t\tsax[a[i]^(a[i]-1)]=1;\n\t}\n\tint nowbit=0;\n\tint ans=0;\n\tbrep(i,35){\n\t\tif(((axor>>i)&1)!=nowbit){\n\t\t\tnowbit^=1;\n\t\t\tif(sax[(1LL<<(i+1))-1]==0){\n\t\t\t\tprin(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tprin(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, x, ans;\nlong long a[MAX_N];\nlong long l[MAX_N];\nlong long cnt[MAX_N];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (long long i = 32; ~i; i--)\n\t\tif ((x >> i) & 1) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tcnt[i]--;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5, MAX_M = 40;\nint n, x, ans, p;\nint a[MAX_N];\nint l[MAX_N];\nint cnt[MAX_M];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\t\n\tfor (int i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (int i = 31; ~i; i--)\n\t\tif (((x >> i) & 1) ^ p) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tp = !p;\n\t\t\tcnt[i]--;\n\t\t\tans++;\n\t\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*/Saya-Javelin/*/\n#include <cstdio>\n//#pragma GCC optimize(\"O2\")\n//#pragma GCC optimize(\"O3\")\n#define Fo freopen (\"file.in\", \"r\", stdin), freopen (\"file.out\", \"w\", stdout)\n#define Fc fclose (stdin), fclose (stdout)\n#define iln inline\n#define rgt register\n#define Max(a,b) ((a)>(b)?(a):(b))\n#define Min(a,b) ((a)<(b)?(a):(b))\n#define Abs(a) ((a)>0?(a):-(a))\n#define Swap(a,b) (a)^=(b)^=(a)^=(b)\n#define Sqr(x) ((x)*(x))\n//#define int long long\n#define ll long long\n#define ld double\n\nconst int S=1000000;\nchar RRR[S];\nchar *SSR, *UR;\n\niln char fgc () {\n\tif (SSR==UR) UR=(SSR=RRR)+fread (RRR, 1, S, stdin);\n\treturn *SSR++;\n}\n\n//#define gc rrr=fgc()\n#define gc rrr=getchar()\niln void read (int &ur) {\n\tint ssr=1; char rrr; ur=0;\n\twhile (gc, rrr>'9' || rrr<'0')\n\tif (rrr=='-') ssr=-1;\n\twhile (rrr>='0' && rrr<='9')\n\tur=ur*10+rrr-'0', gc;\n\treturn (void) (ur*=ssr);\n}\n#undef gc\n\niln void write (int ur) {\n\tif (ur<0) putchar ('-'), ur*=-1;\n\tif (ur>=10) write (ur/10);\n\treturn (void) putchar (ur%10+'0');\n}\n\niln void wtn (int ur) {\n\twrite (ur);\n\treturn (void) putchar ('\\n');\n}\n\niln void wts (int ur) {\n\twrite (ur);\n\treturn (void) putchar (' ');\n}\n\nint n, in;\nint a[100001];\nint ans=0, k=0;\nbool wei[33]={0};\n\nsigned main (void) {\n\tread (n);\n\tfor (rgt int i=1; i<=n; ++i) {\n\t\tread (a[i]); ans^=a[i];\n\t\tfor (rgt int j=0; j<=30; ++j) {\n\t\t\tif (a[i]&(1<<j)) {\n\t\t\t\twei[j]=1; \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (rgt int i=30; i>=0; --i) {\n\t\tif (ans&(1<<i)) {\n\t\t\tif (!wei[i]) return wtn (-1), 0;\n\t\t\tans^=(1<<(i+1))-1;\n\t\t\tk++;\n\t\t}\n\t}\n\twtn (k);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nint should[50], can[50];\nint n;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    int ttxor = 0;\n    for (int i = 0; i < n; i++)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        ttxor ^= x;\n        int cur = 0;\n        while (x % 2 == 0)\n        {\n            cur++;\n            x /= 2;\n        }\n        can[cur] = true;\n    }\n    for (int i = 0; i < 40; i++)\n    {\n        should[i] = (ttxor & 1);\n        ttxor /= 2;\n    }\n    int curxor = 0;\n    int ans = 0;\n    for (int i = 39; i >= 0; i--) if (should[i] != curxor)\n    {\n        if (!can[i])\n        {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        ans++;\n        curxor ^= 1;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5;\nint a[N],cnt[25],n,res,sum;\ninline int calc(R int x){R int res=0;while(x)x>>=1,++res;return res;}\nint main(){\n\tscanf(\"%d\",&n);\n\tfp(i,1,n)scanf(\"%d\",&a[i]),res^=a[i],++cnt[calc(a[i]^(a[i]-1))];\n\tfd(i,29,0)if(res>>i&1)\n\t\tif(cnt[i+1])res^=(1<<(i+1))-1,++sum;\n\tprintf(\"%d\\n\",res?-1:sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_set>\n#include <vector>\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  std::vector<int> a(n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &a[i]);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++)\n    xor_sum ^= a[i];\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++)\n    s.insert(a[i] ^ (a[i] - 1));\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.find(x) != s.end()) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int K = 30;\nint x;\nint n;\nbool a[K + 3];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tx = 0;\n\tscanf(\"%d\", &n);\n\twhile(n--)\n\t{\n\t\tint y;\n\t\tscanf(\"%d\", &y);\n\t\tx ^= y;\n\t\tint q = 0;\n\t\twhile(((1 << q) & y) == 0) q++;\n\t\ta[q] = 1;\n\t}\n\tint ans = 0;\n\tfor (int i = K; i >= 0; i--)\n\t{\n\t\tif (((x >> i) & 1) == 0) continue;\n\t\tif (!a[i])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tans++;\n\t\tfor (int j = 0; j <= i; j++)\n\t\t\tx ^= 1 << j;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 1000100\nint n, a[N];\nint b[N];\n\nint main () {\n\tcin >> n;\n\tint S = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tcin >> a[i];\n\t\tassert(a[i] <= 1000000000);\n\t\tassert(a[i] >= 2);\n\t\tS ^= a[i];\n\t\tb[i] = a[i] ^ (a[i]-1);\n\t}\n\tsort(b, b+n);\n\tint m = unique(b, b+n)-b;\n\tassert (m <= 20);\n\tint T = -1;\n\tfor (int p = 0; p < (1<<m); p++) {\n\t\tint SS = S;\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\tif ((p>>i)&1) SS ^= b[i];\n\t\tif (!SS) {\n\t\t\tint c = pct(p);\n\t\t\tif (T == -1 || T > c) T = c;\n\t\t}\n\t}\n\tcout << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 1e5 + 100;\n\nll n, res, a;\nbool have[N];\n\nint f(int a) {\n\treturn (a & 1? 0: f(a >> 1) + 1);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\twhile(n--) {\n\t\tcin >> a;\n\t\tres ^= a;\n\t\thave[f(a)] = true;\n\t}\n\tint ans = 0;\n\tfor (int i = 31; ~i; i--)\n\t\tif((res & (1 << i)) && have[i] == false) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\telse if(res & (1 << i))\n\t\t\tres ^= ((1 << (i + 1)) - 1), ans++;\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint a[100001],b[31];\nint main(){\n    int n;\n    cin>>n;\n    int x=0;\n    rep(i,n){\n        cin>>a[i];\n        x^=a[i];\n        int y=a[i]^(a[i]-1);\n        int pc=__builtin_popcount(y);\n        b[pc]=y;\n    }\n    int cnt=0;\n    for(int i=29;i>=0;--i){\n        if((x>>i)&1){\n            if(b[i+1]==0){\n                cout<<-1<<endl;\n                return 0;\n            }\n            else x^=b[i+1],++cnt;\n        }\n    }\n    if(x==0)cout<<cnt<<endl;\n    else cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 100100;\n\nint n, a[M];\nint sum = 0;\nint b[M];\n\nvoid read() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    sum ^= a[i];\n    b[i] = a[i] ^ (a[i] - 1);\n  }\n}\n\nvoid kill() {\n  int ans = 0;\n  for (int i = 30; i >= 0; --i)\n    if ((sum >> i) & 1) {\n      bool found = false;\n      for (int j = 0; j < n; ++j)\n        if (b[j] == (1 << (i + 1)) - 1) {\n          sum ^= b[i];\n          ++ans;\n          found = true;\n          break;\n        }\n\n      if (!found) {\n        cout << \"-1\" << endl;\n        exit(0);\n      }\n    }\n\n  cout << ans << endl;\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"c.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  kill();\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define pdd pair < db , db >\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int s[1 << 20];\n    int n;\n    fi>>n;\n    int cnt = 0;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i],cnt ^= s[i],s[i] ^= (s[i] - 1);\n    sort(s + 1,s + 1 + n,greater < int > ());\n    auto lg = [&](int x)\n    {\n        int ans = 0;\n        while ((++ans) && (x /= 2));\n        return ans;\n    };\n    int ans = 0;\n    for (int i = 1;cnt && i <= n;++i)\n        if (lg(cnt) == lg(s[i]))\n            cnt ^= s[i],++ans;\n    if (!cnt)\n        ans = -1;\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 10;\nint a[maxn];\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  return 1;\n}\n\nconst int maxl = 31;\nint cnts[31];\n\nvoid solve() {\n  memset(cnts, 0, sizeof(cnts));\n  int whole = 0;\n  for (int i = 0; i < n; ++i) {\n    whole ^= a[i];\n    int got = (a[i] ^ (a[i] - 1));\n    cnts[__builtin_popcount(got)] += 1;\n  }\n  int res = 0;\n  while (whole) {\n    int high = 31 - __builtin_clz(whole);\n    ++high;\n    if (!cnts[high]) {\n      printf(\"-1\\n\");\n      return;\n    }\n    ++res;\n    whole ^= (1 << high) - 1;\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define NR 101000\n\nbool vis[100];\nint n, a[NR];\n\nint main() {\n\tscanf(\"%d\", &n);\n\n\tint sum = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsum ^= a[i];\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint w = a[i] ^ (a[i] - 1);\n\t\tfor (int d = 1; d < 31; ++d)\n\t\t\tif ((1 << d) - 1 == w)\n\t\t\t\tvis[d - 1] = true;\n\t}\n\n\tint ans = 0;\n\tfor (int d = 30; d >= 0; --d) {\n\t\tif (sum >> d & 1) {\n\t\t\tif (!vis[d]) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tsum ^= (1 << (d + 1)) - 1;\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[44];\n\nint func(int x) {\n\tint y = x - 1;\n\tfor(int i = 31; i >= 0; i--) {\n\t\tif(((x >> i) & 1) != ((y >> i) & 1)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tcin >> n;\n\tint sum = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta[func(x)] = 1;\n\t\tsum ^= x;\n\t}\n\tint ans = 0;\n\tfor(int i = 31; i >= 0; i--) {\n\t\tif((sum >> i) & 1) {\n\t\t\tif(a[i] == 0) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tsum ^= (1 << (i + 1)) - 1;\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <map>\nusing namespace std;\n\ntypedef long long lint;\ntypedef unsigned long long ulint;\n\nint main(){\n    lint N;\n    cin >> N;\n    ulint X=0,E=0;\n    for(lint i=0;i<N;i++){\n        ulint A;\n        cin >> A;\n        X^=A;\n        E|=(A^(A-1))+1;\n    }\n\n    lint cnt=0;\n    for(int i=31;i>=0;i--){\n        if(X&(1<<i)){\n            if((E&(1<<(i+1)))==0){\n                cout << \"-1\" << endl;\n                return 0;\n            }\n            cnt++;\n            X^=(1<<(i+1))-1;\n        }\n    }\n    cout << cnt << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<\"\\n\";\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\n\";\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<\"\\n\";\n#define br cout<<endl;\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define mem(a,b) memset(a,b,sizeof(a))\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int MAX = 100005;\nconst int INF = 1e9+7;\nconst ll LINF = 1e18 + 7;\n\n/***************************************************************************/\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    int n;\n    cin>>n;\n    ll ar[n+5],ans=0;\n    map<int, int>m;\n    for(int i=0;i<n;i++)\n    {\n        ll a,r=0;\n        cin>>a;\n        ans^=a;\n        while(a%2==0)\n        {\n            r++;\n            a=a/2;\n        }\n        m[r]++;\n    }\n    ll x=1<<30,f=0,res=0;\n    for(int i=30;i>=0;i--)\n    {\n        if(ans & x)\n        {\n            if(m[i])\n            {\n                ll c=x-1;\n                ans^=c;\n            }\n            else\n            {\n                f=1;\n                break;\n            }\n            res++;\n        }\n        x/=2;\n    }\n    if(f)\n    {\n        cout<<-1<<endl;\n    }\n    else\n    {\n        cout<<res<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define YES(condition) if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl\n#define Yes(condition) if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl\n#define POSS(condition) if(condition) cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl\n#define Poss(condition) if(condition)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl\n#define First(condition) if(condition)cout << \"First\" << endl; else cout << \"Second\" << endl\n#define negative(condition, num) if(condition)cout << -1 << endl; else cout << num << endl\nlong power(long base, long exponent, long mod){ if(exponent % 2){ return power(base, exponent - 1, mod) * base % mod; }else if(exponent){ long root_ans = power(base, exponent / 2, mod); return root_ans * root_ans % mod; }else{ return 1; }}\n\nint main(){\n    int N;\n    cin >> N;\n    long grundy_xor = 0;\n    set<long, greater<long>> nums_standing_lsb;\n    for(int i = 0; i < N; i++){\n        long num;\n        cin >> num;\n        grundy_xor ^= num;\n        nums_standing_lsb.insert(num & -num);\n    }\n    int ans = 0;\n    while(!nums_standing_lsb.empty()){\n        if(grundy_xor & *(nums_standing_lsb.begin())){\n            grundy_xor ^= *(nums_standing_lsb.begin()) * 2 - 1;\n            ans++;\n        }\n        nums_standing_lsb.erase(nums_standing_lsb.begin());\n    }\n    negative(grundy_xor, ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint check[30];\n\nint main() {\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n    for (int bit = 29; bit >= 0; bit--) {\n      int x = (1 << (bit + 1)) - 1;\n      if (a == x) {\n        check[bit] = 1;\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define rep(i,a,b) for (rint i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (rint i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (rint i=0,_E=(n); i<_E; ++i)\n#define pb push_back\n#define cmin(x,y) (y<x?x=y:0)\n#define cmax(x,y) (y>x?x=y:0)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 100005;\nint c[32], x, n, res, cnt, ans;\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) {\n\t\tscanf(\"%d\", &x);\n\t\tres ^= x;\n\t\tcnt = 0;\n\t\twhile (x && (x % 2 == 0))\n\t\t\tx >>= 1, ++ cnt;\n\t\tc[cnt] = 1;\n\t}\n\tper (i, 30, 0)\n\t\tif (res >> i & 1) {\n\t\t\tres ^= (1 << (i + 1)) - 1;\n\t\t\t++ ans;\n\t\t\tif (!c[i]) return puts(\"-1\"), 0;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   (1000000007LL)\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    S V<ll> alist; llinl1(alist, n);\n    S V<ll> blist; llinl1(blist, n);\n\n    ll perms[100005];\n    ll perm_invs[100005];\n    make_perms(perms, perm_invs, 100005, MOD);\n\n    priority_queue<t2> q;\n    for (auto a : alist) q.push(t2(a, 1));\n    for (auto b : blist) q.push(t2(b, -1));\n    q.push(t2(-1e18, 2));\n\n    ll prev_m = 0;\n    ll cnt = 0;\n    V<ll> cntlist;\n\n    while (!q.empty()) {\n        auto posm = q.top(); q.pop();\n        ll m = get<1>(posm);\n        if (prev_m == m) {\n            cnt++;\n        }\n        else {\n            cntlist.pb(cnt);\n            cnt = 1;\n        }\n        prev_m = m;\n    }\n\n    cntlist.erase(cntlist.begin());\n    debug_printf(\"--- cntlist\\n\");\n    debug_print(cntlist);\n\n    ll ans = 1LL;\n\n    rep (i, cntlist.size()-1) {\n\n        if (cntlist[i] <= cntlist[i+1]) {\n            ans *= perms[cntlist[i]];\n            ans %= MOD;\n            cntlist[i+1] -= cntlist[i];\n        }\n\n        else {\n            ll incr = 1LL;\n            incr *= perms[cntlist[i]];\n            incr *= perm_invs[cntlist[i+1]];\n            incr %= MOD;\n            ans *= incr;\n            ans %= MOD;\n            cntlist[i] -= cntlist[i+1];\n            cntlist[i+2] += cntlist[i];\n        }\n\n    }\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_set>\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n    for (int bit = 29; bit >= 0; bit--) {\n      int x = (1 << (bit + 1)) - 1;\n      if (a == x) {\n        s.insert(bit);\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.find(bit) != s.end()) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "int check[30];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 0; i < 30; i++)\n    check[i] = 0;\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    switch (x) {\n    case 1:\n      check[0] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 1073741823:\n      check[29] = 1;\n      break;\n    default:\n      break;\n    }\n    xor_sum ^= x;\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit]) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 32;\nint n, x, ans, a, cnt[L];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> a;\n\t\tcnt[__builtin_ctz(a)]++;\n\t\tx ^= a;\n\t}\n\t\n\tbool t = 1;\n\tfor (int i = L - 1; i >= 0; i--){\n\t\tif((x >> i) % 2 == t){\n\t\t\tif(cnt[i] == 0)\n\t\t\t\treturn cout << -1, 0;\n\t\t\tt = 1 - t;\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint B[33];\nint C[33];\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tint a;cin >> a;\n\n\t\tint cnt = 0;\n\t\tbool f = true;\n\t\twhile (a) {\n\t\t\tif (a & 1) {\n\t\t\t\tif (f) {\n\t\t\t\t\tB[cnt]++;\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t\tC[cnt]++;\n\t\t\t}\n\t\t\ta >>= 1;\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tbool flag = true;\n\tint ans = 0;\n\tfor (int i = 32; i >= 0; i--) {\n\t\tif (C[i] % 2) {\n\t\t\tif (B[i]) {\n\t\t\t\tfor (int j = i - 1; j >= 0; j--)C[j]++;\n\t\t\t\tans++;\n\t\t\t}\n\t\t\telse flag = false;\n\t\t}\n\t}\n\n\tcout << (flag ? ans : -1) << endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<cstdlib>\n#include<sstream>\n#include<climits>\n#include<cassert>\n#include<time.h>\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define pb push_back\n#define ss second\n#define ff first\n#define vi vector<int>\n#define vl vector<ll>\n#define s(n) scanf(\"%d\",&n)\n#define ll long long\n#define mp make_pair\n#define PII pair <int ,int >\n#define PLL pair<ll,ll>\n#define inf 1000*1000*1000+5\n#define v(a,size,value) vi a(size,value)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define tri pair < int , PII >\n#define TRI(a,b,c) mp(a,mp(b,c))\n#define xx ff\n#define yy ss.ff\n#define zz ss.ss\n#define in(n) n = inp()\n#define vii vector < PII >\n#define vll vector< PLL >\n#define viii vector < tri >\n#define vs vector<string>\n#define DREP(a) sort(all(a)); a.erase(unique(all(a)),a.end());\n#define INDEX(arr,ind) (lower_bound(all(arr),ind)-arr.begin())\n#define ok if(debug)\n#define trace1(x) ok cerr << #x << \": \" << x << endl;\n#define trace2(x, y) ok cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << endl;\n#define trace3(x, y, z)    ok      cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << \" | \" << #z << \": \" << z << endl;\n#define trace4(a, b, c, d)  ok cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" \\\n                                << #d << \": \" << d << endl;\n#define trace5(a, b, c, d, e) ok cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" \\\n                                     << #d << \": \" << d << \" | \" << #e << \": \" << e << endl;\n#define trace6(a, b, c, d, e, f) ok cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" \\\n                                    << #d << \": \" << d << \" | \" << #e << \": \" << e << \" | \" << #f << \": \" << f << endl;\n\n#define read(a) freopen(a,\"r\",stdin)\n#define write(a) freopen(a,\"w\",stdout)\nll MOD = int(1e9) + 7;\n\nint debug = 1;\nconst int N = int(1e6) + 5;\nusing namespace std;\nint a[N];\nint b[N];\nmap < int , int > freq;\nint main()\n{\n        int i,j,n,t;\n        ios::sync_with_stdio(false);\n        cin>>n;\n        rep(i,n)cin>>a[i];\n        int x = 0;\n        rep(i,n)\n        {\n                freq[a[i]&(-a[i])]++;\n                x ^= (a[i]&(a[i]-1));\n        }\n        int cur = (1<<30);\n        int flag = 0;\n        int ans = 0;\n        while(cur)\n        {\n                if(x&cur)\n                {\n                        if(freq[cur] == 0)flag = 1;\n                        else if(freq[cur] % 2 == 0)\n                        {\n                                ans++;\n                                x ^= (cur-1);\n                        }\n                }\n                else\n                {\n                        if(freq[cur]&1)\n                        {\n                                ans++;\n                                x ^= (cur-1);\n                        }\n                }\n                cur >>= 1;\n        }\n        if(flag)cout<<-1;\n        else cout<<ans;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_set>\n\nint a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &a[i]);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++)\n    xor_sum ^= a[i];\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++)\n    s.insert(a[i] ^ (a[i] - 1));\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.count(x)) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 1e5 + 100;\nconst int LOG = 40;\nint a[N];\nint cnt[LOG];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i] );\n\tint x = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tx ^= a[i];\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint cur = 1;\n\t\tint id = 0;\n\t\twhile (a[i] % (2 * cur) == 0)\n\t\t{\n\t\t\tid++;\n\t\t\tcur *= 2;\n\t\t}\n\t\tcnt[id] = 1;\n\t}\n\tint ans = 0;\n\tfor (int i = 30; i >= 0; i--)\n\t{\n\t\tif (x & (1 << i) )\n\t\t{\n\t\t\tif (cnt[i] == 0)\n\t\t\t{\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tx ^= (1 << (i + 1) ) - 1;\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\t\n\t\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tvector<ll> v(n);\n\tll s = 0;\n\trep(i, n){\n\t\tll a;\n\t\tcin>>a;\n\t\tv[i] = a^(a-1);\n\t\ts ^= a;\n\t}\n\tsort(all(v)); UNIQUE(v); reverse(all(v));\n\tcerr<<v.size()<<endl;\n\tcerr<<v<<endl;\n\tll res = 0;\n\trep(i, v.size()){\n\t\tif((s^v[i])<s){\n\t\t\ts ^= v[i];\n\t\t\tres++;\n\t\t}\n\t}\n\tcout<<(s?-1:res)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  Int g=0;\n  for(Int i=0;i<n;i++) g^=a[i];\n\n  Int ans=0;\n  set<Int> s;\n  for(Int i=0;i<n;i++) s.emplace(-__builtin_ctzll(a[i]));\n  for(Int x:s){\n    Int y=-x;\n    if((g>>y)&1){\n      g^=(1<<(y+1))-1;\n      ans++;\n    }\n  }\n  \n  if(g) ans=-1;\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 13;\nint n, ans, x;\nbool mark[maxN];\nvector<int> vec;\nint main () {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n\tint a;\n\tcin >> a;\n\tx ^= a;\n\ta = __builtin_ctz(a);\n\tmark[a] = 1;\n    }\n\n    while (x) {\n\tvec.push_back(x % 2);\n\tx /= 2;\n    }\n    int indx = vec.size() - 1;\n    int lst = 0;\n    while (vec.size()) {\n\tint u = vec.back();\n\tvec.pop_back();\n\tif (u != lst) {\n\t    if (!mark[indx])\n\t\treturn cout << -1 << endl, 0;\n\t    else\n\t\tans++;\n\t}\n\tindx--;\n\tlst = u;\n    }\n    cout << ans << endl;\n}\n\n    \n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 13;\nint n, ans, x;\nbool mark[maxN];\nvector<int> vec;\nint main () {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n\tint a;\n\tcin >> a;\n\tx ^= a;\n\ta = __builtin_ctz(a);\n\tmark[a] = 1;\n    }\n\n    while (x) {\n\tvec.push_back(x % 2);\n\tx /= 2;\n    }\n    int indx = vec.size() - 1;\n    int lst = 0;\n    while (vec.size()) {\n\tint u = vec.back();\n\tvec.pop_back();\n\tif (u != lst) {\n\t    if (!mark[indx])\n\t\treturn cout << -1 << endl, 0;\n\t    else\n\t\tans++;\n\t}\n\tindx--;\n\tlst = u;\n    }\n    cout << ans << endl;\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5, MAX_M = 40;\nint n, x, ans, p;\nint a[MAX_N];\nint l[MAX_N];\nbool cnt[MAX_M];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\t\t\n\tfor (int i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (int i = 31; ~i; i--)\n\t\tif (((x >> i) & 1) ^ p) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tp = !p;\n\t\t\tcnt[i]--;\n\t\t\tans++;\n\t\t}\n\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<stack>\n#include<cmath>\n#include<iomanip>\n#include<cstdlib>\n#include<sstream>\n#include<climits>\n#include<cassert>\n#include<time.h>\n\nusing namespace std;\n#define f(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) f(i,0,n)\n#define pb push_back\n#define ss second\n#define ff first\n#define vi vector<int>\n#define vl vector<ll>\n#define s(n) scanf(\"%d\",&n)\n#define ll long long\n#define mp make_pair\n#define PII pair <int ,int >\n#define PLL pair<ll,ll>\n#define inf 1000*1000*1000+5\n#define v(a,size,value) vi a(size,value)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define tri pair < int , PII >\n#define TRI(a,b,c) mp(a,mp(b,c))\n#define xx ff\n#define yy ss.ff\n#define zz ss.ss\n#define in(n) n = inp()\n#define vii vector < PII >\n#define vll vector< PLL >\n#define viii vector < tri >\n#define vs vector<string>\n#define DREP(a) sort(all(a)); a.erase(unique(all(a)),a.end());\n#define INDEX(arr,ind) (lower_bound(all(arr),ind)-arr.begin())\n#define ok if(debug)\n#define trace1(x) ok cerr << #x << \": \" << x << endl;\n#define trace2(x, y) ok cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << endl;\n#define trace3(x, y, z)    ok      cerr << #x << \": \" << x << \" | \" << #y << \": \" << y << \" | \" << #z << \": \" << z << endl;\n#define trace4(a, b, c, d)  ok cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" \\\n                                << #d << \": \" << d << endl;\n#define trace5(a, b, c, d, e) ok cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" \\\n                                     << #d << \": \" << d << \" | \" << #e << \": \" << e << endl;\n#define trace6(a, b, c, d, e, f) ok cerr << #a << \": \" << a << \" | \" << #b << \": \" << b << \" | \" << #c << \": \" << c << \" | \" \\\n                                    << #d << \": \" << d << \" | \" << #e << \": \" << e << \" | \" << #f << \": \" << f << endl;\n\n#define read(a) freopen(a,\"r\",stdin)\n#define write(a) freopen(a,\"w\",stdout)\nll MOD = int(1e9) + 7;\n\nint debug = 1;\nconst int N = int(1e6) + 5;\nusing namespace std;\nint a[N];\nint b[N];\nmap < int , int > freq;\nint main()\n{\n        int i,j,n,t;\n        ios::sync_with_stdio(false);\n        cin>>n;\n        rep(i,n)cin>>a[i];\n        int x;\n        rep(i,n)\n        {\n                freq[a[i]&(-a[i])]++;\n                x ^= (a[i]&(a[i]-1));\n        }\n        int cur = (1<<30);\n        int flag = 0;\n        int ans = 0;\n        while(cur)\n        {\n                if(x&cur)\n                {\n                        if(freq[cur] == 0)flag = 1;\n                        else if(freq[cur] % 2 == 0)\n                        {\n                                ans++;\n                                x ^= (cur-1);\n                        }\n                }\n                else\n                {\n                        if(freq[cur]&1)\n                        {\n                                ans++;\n                                x ^= (cur-1);\n                        }\n                }\n                cur >>= 1;\n        }\n        if(flag)cout<<-1;\n        else cout<<ans;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define rep(i,a,b) for (rint i=(a),_E=(b); i<=_E; ++i)\n#define per(i,a,b) for (rint i=(a),_E=(b); i>=_E; --i)\n#define REP(i,n) for (rint i=0,_E=(n); i<_E; ++i)\n#define pb push_back\n#define cmin(x,y) (y<x?x=y:0)\n#define cmax(x,y) (y>x?x=y:0)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\nconst int N = 100005;\nint c[32], x, n, res, cnt, ans;\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep (i, 1, n) {\n\t\tscanf(\"%d\", &x);\n\t\tres ^= x;\n\t\tcnt = 0;\n\t\twhile (x && (x % 2 == 0))\n\t\t\tx >>= 1, ++ cnt;\n\t\tc[cnt] = 1;\n\t}\n\tper (i, 30, 0)\n\t\tif (res >> i & 1) {\n\t\t\tres ^= (1 << (i + 1)) - 1;\n\t\t\t++ ans;\n\t\t\tif (!c[i]) return puts(\"-1\"), 0;\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main(){\n\tint n; cin >> n; std::vector<long> a(n);\n\tlong x = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\t\n\t\tx ^= a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 30; i >= 0; i--){\n\t\tif((x >> i) & 1 == 0) continue;\n\t\t\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((a[j] ^ (a[j] - 1)) == (1 << (i + 1)) - 1){\n\t\t\t\tx ^= a[j] ^ (a[j] - 1); ans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(x) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int K = 30;\n\nint main() {\n  int n;\n  cin >> n;\n  int sum = 0;\n  vector<bool> visit(K);\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    sum ^= x;\n    int k = 0;\n    while (x % 2 == 0) x /= 2, k += 1;\n    visit[k] = true;\n  }\n\n  int ret = 0;\n  for (int k = K - 1; k >= 0; --k) {\n    if ((sum >> k) & 1) {\n      if (!visit[k]) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      sum ^= (1 << (k + 1)) - 1;\n      ++ret;\n    }\n  }\n  cout << ret << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvoid dfs(int i, int g, int cost, vector<int> &seq, vector<P> &ret) {\n  if (i == seq.size()) {\n    ret.pb(P(g, cost));\n    return;\n  }\n  dfs(i+1, g, cost, seq, ret);\n  dfs(i+1, g^seq[i], cost+1, seq, ret);\n}\nvector<P> enumerate(vector<int> &seq) {\n  vector<P> ret;\n  dfs(0, 0, 0, seq, ret);\n  sort(all(ret));\n  return ret;\n}\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  int g = 0;\n  vector<int> vs;\n  rep(i, N) {\n    int a;\n    cin >> a;\n    g ^= a;\n    vs.pb(((a&-a)<<1)-1);\n  }\n  sort(all(vs)); uniq(vs);\n  //cout<<\"{\"; for (int x:vs)cout<<x<<\",\";cout<<\"} -> \"<<g<<\"\\n\";\n  vector<int> left, right;\n  rep(i, vs.size()) {\n    if (i%2 == 0) left.pb(vs[i]);\n    else right.pb(vs[i]);\n  }\n  vector<P> ls = enumerate(left);\n  vector<P> rs = enumerate(right);\n  int m = INF;\n  for (P l : ls) {\n    int f = g^l._1;\n    auto it = lower_bound(all(rs), P(f, -1));\n    if (it == rs.end() || it->_1 != f) continue;\n    m = min(m, l._2 + it->_2);\n  }\n  if (m == INF) m = -1;\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false); cin.tie(0);\n\n    int n;\n    vector<int> ap(31, 0);\n    cin >> n;\n\n    int i, val = 0;\n    for(i=1; i<=n; ++i)\n    {\n        int x;\n        cin >> x;\n        val ^= x;\n\n        int cnt = 0;\n        while(x%2==0) x/=2, ++cnt;\n        ++ap[cnt];\n    }\n\n    int ans = 0;\n\n    for(i=29; i>=0; --i)\n        if( ((val>>i)&1) ^ ((val>>(i+1))&1) )\n        {\n            ++ans;\n            if(!ap[i])\n            {\n                cout << -1 << '\\n';\n                return 0;\n            }\n        }\n\n    cout << ans << '\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 100005\n#define M 200005\n#define seed 23333\n\nusing namespace std;\nint i,j,m,n,p,k,a[N],b[N],cnt,sum;\nmap<int,int>mp;\nmap<int,int>::iterator it;\nint lowbit(int x)\n{\n\t\treturn x&-x;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;++i) scanf(\"%d\",&a[i]),mp[lowbit(a[i])*2-1]=1,sum^=a[i];\n\tfor (i=30;i>=0;--i)\n\t\tif (sum&(1<<i))\n\t{\n\t\t\tfor (it=mp.begin();it!=mp.end();++it)\n\t\t\t\tif ((it->fi<(1<<(i+1)))&&((it->fi)&(1<<i)))\n\t\t\t\t{\n\t\t\t\t\t\tsum^=it->fi;\n\t\t\t\t\t\t++cnt;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (sum&(1<<i)) break;\n\t}\n\tif (i<0) printf(\"%d\\n\",cnt);\n\telse puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <complex>\n#include <deque>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <tuple>\n#include <cstring>\nusing namespace std;\n\n#define forr(x,arr) for(auto&& x:arr)\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep2(i,n) _rep3(i,0,n)\n#define _rep3(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,_rep3,_rep2,)(__VA_ARGS__)\n#define _rrep2(i,n) _rrep3(i,0,n)\n#define _rrep3(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define rrep(...) _overload3(__VA_ARGS__,_rrep3,_rrep2,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define bit(n) (1LL<<(n))\n#define sz(x) ((int)(x).size())\n#define TEN(n) ((ll)(1e##n))\n#define fst first\n#define snd second\n\nstring DBG_DLM(int &i){return(i++==0?\"\":\", \");}\n#define DBG_B(exp){int i=0;os<<\"{\";{exp;}os<<\"}\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,set<T>v);\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q);\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q);\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p);\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>mp);\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>mp);\ntemplate<int I,class TPL>void DBG(ostream&os,TPL t){}\ntemplate<int I,class TPL,class H,class...Ts>void DBG(ostream&os,TPL t){os<<(I==0?\"\":\", \")<<get<I>(t);DBG<I+1,TPL,Ts...>(os,t);}\ntemplate<class T,class K>void DBG(ostream&os,pair<T,K>p,string delim){os<<\"(\"<<p.first<<delim<<p.second<<\")\";}\ntemplate<class...Ts>ostream&operator<<(ostream&os,tuple<Ts...>t){os<<\"(\";DBG<0,tuple<Ts...>,Ts...>(os,t);os<<\")\";return os;}\ntemplate<class T,class K>ostream&operator<<(ostream&os,pair<T,K>p){DBG(os,p,\", \");return os;}\ntemplate<class T>ostream&operator<<(ostream&os,vector<T>v){DBG_B(forr(t,v){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,set<T>s){DBG_B(forr(t,s){os<<DBG_DLM(i)<<t;});}\ntemplate<class T>ostream&operator<<(ostream&os,queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.front();});}\ntemplate<class T>ostream&operator<<(ostream&os,priority_queue<T>q){DBG_B(for(;q.size();q.pop()){os<<DBG_DLM(i)<<q.top();});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\ntemplate<class T,class K>ostream&operator<<(ostream&os,unordered_map<T,K>m){DBG_B(forr(p,m){os<<DBG_DLM(i);DBG(os,p,\"->\");});}\n#define DBG_OVERLOAD(_1,_2,_3,_4,_5,_6,macro_name,...)macro_name\n#define DBG_LINE(){char s[99];sprintf(s,\"line:%3d | \",__LINE__);cerr<<s;}\n#define DBG_OUTPUT(v){cerr<<(#v)<<\"=\"<<(v);}\n#define DBG1(v,...){DBG_OUTPUT(v);}\n#define DBG2(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG1(__VA_ARGS__);}\n#define DBG3(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG2(__VA_ARGS__);}\n#define DBG4(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG3(__VA_ARGS__);}\n#define DBG5(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG4(__VA_ARGS__);}\n#define DBG6(v,...){DBG_OUTPUT(v);cerr<<\", \";DBG5(__VA_ARGS__);}\n#define DEBUG0(){DBG_LINE();cerr<<endl;}\n#ifdef LOCAL\n#define out(...){DBG_LINE();DBG_OVERLOAD(__VA_ARGS__,DBG6,DBG5,DBG4,DBG3,DBG2,DBG1)(__VA_ARGS__);cerr<<endl;}\n#else\n#define out(...)\n#endif\n\nusing ll=long long;\nusing pii=pair<int,int>;using pll=pair<ll,ll>;using pil=pair<int,ll>;using pli=pair<ll,int>;\nusing vs=vector<string>;using vvs=vector<vs>;using vvvs=vector<vvs>;\nusing vb=vector<bool>;using vvb=vector<vb>;using vvvb=vector<vvb>;\nusing vi=vector<int>;using vvi=vector<vi>;using vvvi=vector<vvi>;\nusing vl=vector<ll>;using vvl=vector<vl>;using vvvl=vector<vvl>;\nusing vd=vector<double>;using vvd=vector<vd>;using vvvd=vector<vvd>;\nusing vpii=vector<pii>;using vvpii=vector<vpii>;using vvvpii=vector<vvpii>;\ntemplate<class A,class B>bool amax(A&a,const B&b){return b>a?a=b,1:0;}\ntemplate<class A,class B>bool amin(A&a,const B&b){return b<a?a=b,1:0;}\nll ri(){ll l;cin>>l;return l;} string rs(){string s;cin>>s;return s;}\n\nll solve() {\n\tint n = ri();\n\n\tint x = 0;\n\tvi C(32);\n\n\trep(i, n) {\n\t\tint a = ri();\n\t\tx ^= a;\n\t\tC[__builtin_ctz(a)]++;\n\t}\n\n\tout(x);\n\tout(C);\n\n\tint flip = 0;\n\trrep(i, 32) {\n\t\tint b = (x >> i) & 1;\n\t\tout(i, b, flip);\n\t\tif ((b+flip) & 1) {\n\t\t\tif (C[i]) flip++;\n\t\t\telse return -1;\n\t\t}\n\t}\n\treturn flip;\n}\n\nvoid Main() {\n\tcout << solve() << endl;\n}\nsigned main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tMain();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 1000100\nint n, a[N];\nint b[N];\nmap<int, int> F;\n\nint main () {\n\tcin >> n;\n\tint S = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tcin >> a[i];\n\t\tS ^= a[i];\n\t\tb[i] = a[i] ^ (a[i]-1);\n\t}\n\tsort(b, b+n);\n\tint m = unique(b, b+n)-b;\n\tint T = -1;\n\tint m2 = m/2;\n\tfor (int p = 0; p < (1<<m2); p ++) {\n\t\tint SS = S;\n\t\tfor (int i = 0; i < m2; i ++)\n\t\t\tif ((p>>i)&1) SS ^= b[i];\n\t\tif (F.find(SS) == F.end()) F[SS] = pct(p);\n\t\telse F[SS] = min(F[SS], pct(p));\n\t}\n\tfor (int p = 0; p < (1<<m-m2); p++) {\n\t\tint SS = 0;\n\t\tfor (int i = 0; i < m-m2; i ++)\n\t\t\tif ((p>>i)&1) SS ^= b[i+m2];\n\t\tif (F.find(SS) != F.end()) {\n\t\t\tint c = F[SS] + pct(p);\n\t\t\tif (T == -1 || T > c) T = c;\n\t\t}\n\t}\n\tcout << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, x, ans;\nlong long a[MAX_N];\nlong long l[MAX_N];\nlong long cnt[MAX_N];\n\nlong long main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (long long i = 20; ~i; i--)\n\t\tif ((x >> i) & 1) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tcnt[i]--;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int K = 30;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int>> a(K, vector<int>(n + 1));\n  int sum = 0, maxk = 0;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    sum ^= x;\n    int k = 1;\n    while (x % 2 == 0) x /= 2, k += 1;\n    maxk = max(maxk, k);\n    trace(i, k);\n    for (int j = 0; j < k; ++j) a[j][i] = 1;\n  }\n  for (int i = maxk; i < K; ++i) {\n    if ((sum >> i) & 1) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < K; ++i) a[i][n] = (sum >> i) & 1;\n  trace(K, n, a);\n  for (int i = 0; i < K; ++i) {\n    int u, v;\n    for (u = i; u < K; ++u) {\n      for (v = i; v < n && a[u][v] == 0; ++v);\n      if (v < n) break;\n    }\n    if (u == K) {\n      int j;\n      for (j = u; j < K && a[j][n] == 0; ++j);\n      if (j == n) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      break;\n    }\n    if (i != u) swap(a[i], a[u]);\n    if (i != v) {\n      for (u = i; u < K; ++u) swap(a[u][i], a[u][v]);\n    }\n    for (u = 0; u < K; ++u) {\n      if (u != i && a[u][i]) {\n        for (v = i; v <= n; ++v) a[u][v] ^= a[i][v];\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < K; ++i) ret += a[i][n];\n  cout << ret << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main(){\n\tint n; cin >> n; std::vector<int> a(n);\n\tint x = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\t\n\t\tx ^= a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor(int k = 29; k >= 1; k--){\n\t\tif(!((x >> k - 1) & 1)) continue;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((a[i] ^ (a[i] - 1)) != ((1 << k) - 1)) continue;\n\t\t\t\n\t\t\tx ^= a[i] ^ (a[i] - 1);\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tif(x) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_set>\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n    s.insert(a);\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.find(x) != s.end()) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main(){\n\tint n; cin >> n; std::vector<int> a(n);\n\tint x = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\t\n\t\tx ^= a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor(int k = 29; k >= 1; k--){\n\t\tif(!((x >> (k - 1)) & 1)) continue;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((a[i] ^ (a[i] - 1)) == ((1 << k) - 1)){\n\t\t\t\n\t\t\t\tx ^= a[i] ^ (a[i] - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(x) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int K = 30;\n\nint main() {\n  int n;\n  cin >> n;\n  // n = 100;\n  // vector<int> b(n);\n  // int xsum = 0;\n  // for (int i = 0; i < n; ++i) {\n  //   if (i != n - 1) {\n  //     b[i] = 2 + rnd(1e9);\n  //     xsum ^= b[i];\n  //   } else {\n  //     b[i] = xsum;\n  //   }\n  // }\n  vector<vector<int>> a(K, vector<int>(n + 1));\n  int sum = 0, maxk = 0;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    // x = b[i];\n    sum ^= x;\n    int k = 1;\n    while (x % 2 == 0) x /= 2, k += 1;\n    maxk = max(maxk, k);\n    for (int j = 0; j < k; ++j) a[j][i] = 1;\n  }\n  for (int i = maxk; i < K; ++i) {\n    if ((sum >> i) & 1) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < maxk; ++i) a[i][n] = (sum >> i) & 1;\n  // trace(K, n, a);\n  for (int i = 0; i < K; ++i) {\n    int u, v;\n    for (u = i; u < K; ++u) {\n      for (v = i; v < n && a[u][v] == 0; ++v);\n      if (v < n) break;\n    }\n    if (u == K) {\n      int j;\n      for (j = u; j < K && a[j][n] == 0; ++j);\n      if (j != K) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      break;\n    }\n    if (i != u) swap(a[i], a[u]);\n    if (i != v) {\n      for (u = i; u < K; ++u) swap(a[u][i], a[u][v]);\n    }\n    for (u = 0; u < K; ++u) {\n      if (u != i && a[u][i]) {\n        for (v = i; v <= n; ++v) a[u][v] ^= a[i][v];\n      }\n    }\n  }\n  int len = min(maxk, n), L = len / 2, R = len - L;\n  // trace(len, L, R);\n  // for (int i = 0; i < len; ++i) {\n  //   for (int j = 0; j < len; ++j) {\n  //     cout << a[i][j];\n  //   }\n  //   cout << \" \" << a[i][n] << endl;\n  // }\n\n  map<int, int> best;\n  for (int k = 0; k < (1 << L); ++k) {\n    int sum = 0;\n    for (int i = 0; i < len; ++i) {\n      int cur = 0;\n      for (int j = 0; j < L; ++j) {\n        cur ^= a[i][j] & ((k >> j) & 1);\n      }\n      sum |= cur << i;\n    }\n    // trace(k, sum);\n    if (best.count(sum)) {\n      best[sum] = min(best[sum], __builtin_popcount(k));\n    } else {\n      best[sum] = __builtin_popcount(k);\n    }\n  }\n  // trace(best);\n  int ret = INF;\n  for (int k = 0; k < (1 << R); ++k) {\n    int sum = 0;\n    for (int i = 0; i < len; ++i) {\n      int cur = a[i][n];\n      for (int j = 0; j < R; ++j) {\n        cur ^= a[i][j + L] & ((k >> j) & 1);\n      }\n      sum |= cur << i;\n    }\n    if (best.count(sum)) {\n      ret = min(ret, best[sum] + __builtin_popcount(k));\n    }\n  }\n  cout << ret << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tvector<ll> v(n);\n\tll s = 0;\n\trep(i, n){\n\t\tll a;\n\t\tcin>>a;\n\t\tv[i] = a^(a-1);\n\t\ts ^= a;\n\t}\n\tsort(all(v)); UNIQUE(v); reverse(all(v));\n\tcerr<<v.size()<<endl;\n\tcerr<<v<<endl;\n\tll res = 0;\n\trep(i, n){\n\n\t\tif(s^v[i]<s){\n\t\t\ts ^= v[i];\n\t\t\tres++;\n\t\t}\n\t}\n\tcout<<(s?-1:res)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10, MAXlg = 32;\nint  n, ar[MAXn], have[MAXn], cnt;\nlong long hp;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> ar[i];\n\t\n\tfor (int i = 0; i < n; i++)\n\t\thp ^= ar[i];\n\t\n\tfor (int i = 0; i < n; i++)\n\t\thave[__builtin_ctz(ar[i])]++;\n\t\n\tfor (int i = MAXlg; i >= 0; i--) {\n\t\tif ((hp>>i) & 1) {\n\t\t\tif (!have[i])\n\t\t\t\treturn cout << -1,0;\n\t\t\thp ^= (1<<(i+1)) - 1;\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t}\n\tcout << cnt;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\nint bsr(int x) { return 31 - __builtin_clz(x); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    cout << setprecision(20);\n    int n;\n    cin >> n;\n    int sm = 0;\n    vector<int> v;\n    for (int i = 0; i < n; i++) {\n        int a;\n        cin >> a;\n        sm ^= a;\n        v.push_back(a^(a-1));\n    }\n    sort(v.begin(), v.end(), greater<int>());\n    int co = 0;\n    for (int d: v) {\n        if (bsr(d) == bsr(sm)) {\n            co++;\n            sm ^= d;\n        }\n    }\n    if (sm) {\n        cout << -1 << endl;\n    } else {\n        cout << co << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int mod = 1e9 + 7;\n\nint cnt[30];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tint xs = 0;\n\tfor(int i=0; i<n; i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\txs ^= x;\n\t\tx ^= (x - 1);\n\t\tfor(int j=0; j<=30; j++){\n\t\t\tif(x + 1 == (1 << j)){\n\t\t\t\tcnt[j]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i=30; i; i--){\n\t\tif((xs >> i) % 2 != (xs >> (i - 1)) % 2){\n\t\t\tif(!cnt[i]){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint dat[50];\nint main()\n{\n\tint num;\n\tscanf(\"%d\",&num);\n\tint now=0;\n\tfor(int i=0;i<num;i++)\n\t{\n\t\tint z;\n\t\tscanf(\"%d\",&z);\n\t\tnow^=z;\n\t\tfor(int j=0;;j++)\n\t\t{\n\t\t\tif(z%2!=0)\n\t\t\t{\n\t\t\t\tdat[j]++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tz/=2;\n\t\t}\n\t}\n\tint r=0;\n\tfor(int i=30;i>=0;i--)\n\t{\n\t\tif(now&(1<<i))\n\t\t{\n\t\t\tr++;\n\t\t\tif(dat[i]==0)\n\t\t\t{\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tnow^=(1<<i)-1;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\nint bsr(int x) { return 31 - __builtin_clz(x); }\n\nint main() {\n    ios::sync_with_stdio(0);\n    cout << setprecision(20);\n    int n;\n    cin >> n;\n    int sm = 0;\n    vector<int> v;\n    for (int i = 0; i < n; i++) {\n        int a;\n        cin >> a;\n        sm ^= a;\n        v.push_back(a^(a-1));\n    }\n    sort(v.begin(), v.end(), greater<int>());\n    int co = 0;\n    for (int d: v) {\n        if (sm && bsr(d) == bsr(sm)) {\n            co++;\n            sm ^= d;\n        }\n    }\n    if (sm) {\n        cout << -1 << endl;\n    } else {\n        cout << co << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int INF = 1e9;\n\nint N;\nlong long A[MAXN + 10];\n\n\nlong long lg(long long x) {\n   int cc = 0;\n   while(x > 1) {\n      x >>= 1;\n      cc++;\n   }\n   return cc;\n}\n\nbool cnt[40];\n\nint main() {\n   scanf(\"%d\", &N);\n   for(int i = 0; i < N; i++) {\n      scanf(\"%lld\", &A[i]);\n      if((A[i] & (A[i] - 1LL)) == 0LL) {\n         cnt[lg(A[i])] = true;\n      }\n   }\n   int cc = N;\n   for(int i = 0; i < N; i++) {\n      if(A[i] % 2 == 0) cc--;\n   }\n   long long xr = 0;\n   for(int i = 0; i < N; i++) {\n      xr ^= A[i];\n   }\n   int res = 0;\n   for(long long i = 30; i > 0; i--) {\n      if(xr & (1LL << i)) {\n         if(!cnt[i]) {\n            printf(\"-1\\n\");\n            exit(0);\n         }\n         xr ^= 1LL << i;\n         xr ^= (1LL << i) - 1LL;\n         res++;\n      }\n      for(int j = 0; j < N; j++) {\n         A[j] &= ~(1 << i);\n         if(A[j] > 1 && (A[j] & (A[j] - 1LL)) == 0LL) {\n            cnt[lg(A[j])] = true;\n         }\n      }\n   }\n   if(xr == 0LL) printf(\"%d\\n\", res);\n   else if(xr == 1LL && cc > 0LL) printf(\"%d\\n\", res+1);\n   else printf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main(){\n\tint n; cin >> n; std::vector<int> a(n);\n\tint x = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\t\n\t\tx ^= a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor(int k = 29; k >= 1; k--){\n\t\tif(!((x >> k - 1) & 1)) continue;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((a[i] ^ (a[i] - 1)) != ((1 << k) - 1)) continue;\n\t\t\t\n\t\t\tx ^= a[i] ^ (a[i] - 1);\n\t\t\tans++; \n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(x) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, A[101010];\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) scanf(\"%d\", A + i);\n\n\tset<int> dif;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint waf = A[i] ^ (A[i] - 1);\n\t\tdif.insert(waf);\n\t}\n\tint tt = 0;\n\tfor (int i = 0; i < N; ++i) tt ^= A[i];\n\n\tvector<int> cand;\n\tfor (auto a : dif) cand.push_back(a);\n\treverse(cand.begin(), cand.end());\n\n\tint ret = 0;\n\tfor (auto a : cand) {\n\t\tif ((tt ^ a) < tt) {\n\t\t\t++ret;\n\t\t\ttt ^= a;\n\t\t}\n\t}\n\tif (tt) ret = -1;\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                 \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint keta(int u){\n\tint r=1;\n\tfor(int i=0;i<40;i++){\n\t\tif(u==r) return i;\n\t\tr*=2;\n\t}\n\texit(1);\n}\n\nint u[40]={0};\n\n      signed main(){\n    int n;\n      \tint noko=0;\n      \tcin>>n;\n      \t\n      \tfor(int i=0;i<n;i++){\n      \t\tint uu;\n      \t\tcin>>uu;\n      \t\tint er=(uu&(-uu));\n      \t\tnoko^=uu-er;\n      \t\tu[keta(er)]+=1;\n      //\tcout<<keta(er)<<endl;\n      \t}\n     // \tcout<<noko<<endl;\n      \tint ans=0;\n      \tfor(int i=35;i>=0;i--){\n      \t//\tcout<<noko<<endl;\n      \t\tif(u[i]==0 && (noko&(1ll<<i))!=0ll){\n      //\t\t\tcout<<i<<endl;\n      \t\tcout<<\"-1\"<<endl;\n      \t\t\treturn 0;\n      \t\t}\n      \t\tif(u[i]==0) continue;\n      \t\tif(u[i]%2==0 && (noko&(1ll<<i))!=0ll){\n      //\t\t\tcout<<i<<endl;\n      //\t\tcout<<\"-1\"<<endl;\n      \t\t\tans++;\n      \t\t\tnoko ^= (1ll<<(i+1))-1;\n      \t\t\tcontinue ;\n      \t\t}\n      \t\tif(u[i]%2==0ll) {\n      \t\t\tif(noko >(1ll<<i)) exit(1);\n      \t\t\tcontinue;\n      \t\t}\n      \t\tif((noko&(1ll<<i))){\n      \t\t\tnoko -= (1ll<<i);\n      \t\t}\n      \t\telse{\n      \t\t\tans++;\n      \t\t\tnoko ^= (1ll<<i)-1;\n      \t\t}\n      \t}\n      \t\n      \tif(noko){\n      \t\tcout<<-1<<endl;\n      \t}\n      \telse cout<<ans<<endl;\n      \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tvector<ll> v(n);\n\tll s = 0;\n\trep(i, n){\n\t\tll a;\n\t\tcin>>a;\n\t\tv[i] = a^(a-1);\n\t\ts ^= a;\n\t}\n\tsort(all(v)); UNIQUE(v); reverse(all(v));\n\tcerr<<v.size()<<endl;\n\tcerr<<v<<endl;\n\tll res = 0;\n\trep(i, v.size()){\n\n\t\tif(s^v[i]<s){\n\t\t\ts ^= v[i];\n\t\t\tres++;\n\t\t}\n\t}\n\tif(s) return -1;\n\tcout<<(s?-1:res)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, x, ans;\nlong long a[MAX_N];\nlong long l[MAX_N];\nlong long cnt[MAX_N];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (long long i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (long long i = 20; ~i; i--)\n\t\tif ((x >> i) & 1) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tcnt[i]--;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10, M = 32;\nint n, ans, x, mark[M];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint y, cnt = 0;\n\t\tcin >> y;\n\t\tx ^= y;\n\t\t\n\t\twhile (y % 2 == 0) {\n\t\t\tcnt++;\n\t\t\ty /= 2;\n\t\t}\n\t\tmark[++cnt]++;\n\t}\n\t\n\tfor (int i = M - 2; i >= 0; i--)\n\t\tif (x & (1LL << i)) {\n\t\t\tif (!mark[i + 1])\n\t\t\t\treturn cout << -1, 0;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nconst int CN = 1e5 + 5;\n\nint read(){\n    int s = 0,ne = 1; char c = getchar();\n    while(c < '0' || c > '9') ne = c == '-' ? -1 : 1, c = getchar();\n    while(c >= '0' && c <= '9') s = (s << 1) + (s << 3) + c - '0', c = getchar();\n    return s * ne;\n}\n\nint n, a[CN], sum = 0, ans = 0; map<int, bool> ext;\n\nint main()\n{\n    // freopen(\"_in.in\", \"r\", stdin);\n\n    n = read(); for(int i = 1; i <= n; i++) a[i] = read(), sum ^= a[i];\n    for(int i = 1; i <= n; i++) ext[ a[i] ^ (a[i] - 1) ] = true;\n\n    bool flag = true;\n    for(int k = 29; k + 1; k--)\n        if(sum & (1 << k)){\n            int u = (1 << (k + 1)) - 1;\n            if(!ext.count(u)) {flag = false; break;}\n            sum ^= u, ans++;\n        }\n    if(!flag) puts(\"-1\");\n    else printf(\"%d \", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10, M = 32;\nint n, ans, x, ar[N], cnt[N], mark[M];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ar[i];\n\t\tx ^= ar[i];\n\t\t\n\t\tint tmp = ar[i];\n\t\twhile (tmp % 2 == 0) {\n\t\t\tcnt[i]++;\n\t\t\ttmp /= 2;\n\t\t}\n\t\tmark[++cnt[i]]++;\n\t}\n\t\n\tfor (int i = M - 2; i >= 0; i--)\n\t\tif (x & (1LL << i)) {\n\t\t\tif (!mark[i + 1])\n\t\t\t\treturn cout << -1, 0;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint check[30];\n\nint main() {\n\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    int a;\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E5 + 5;\nint n, a[MAXN], sum, f[31], cnt;\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nint main() {\n    read(n);\n    for (int i = 1; i <= n; i++) {\n        read(a[i]);\n        sum ^= a[i];\n        a[i] ^= a[i] - 1;\n        for (int j = 30; ~j; j--)\n            if ((a[i] >> j) & 1) {\n                f[j] = 1;\n                break;\n            }\n    }\n    for (int i = 30; ~i; i--)\n        if ((sum >> i) & 1)\n            if (f[i]) sum ^= (1 << (i + 1)) - 1, cnt++;\n    printf(\"%d\\n\", sum ? -1 : cnt);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nbool B(int a,int i){return (a>>i)&1;}\nbool b[32];\nint main(){\n\tint N;\n\tcin>>N;\n\tint x=0;\n\trep(i,N){\n\t\tint a;\n\t\tcin>>a;\n\t\tx^=a;\n\t\tint j=0;\n\t\twhile(!B(a,j)) j++;\n\t\tb[j]=1;\n\t}\n\tint a=0;\n\tfor(int i=30;i>=0;i--){\n\t\tif(B(x,i+1)!=B(x,i)){\n\t\t\tif(!b[i]){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ta++;\n\t\t}\n\t}\n\tcout<<a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\n#define SZ(x) (int)((x).size())\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int K = 30;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int>> a(K, vector<int>(n + 1));\n  int sum = 0, maxk = 0;\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    sum ^= x;\n    int k = 1;\n    while (x % 2 == 0) x /= 2, k += 1;\n    maxk = max(maxk, k);\n    trace(i, k);\n    for (int j = 0; j < k; ++j) a[j][i] = 1;\n  }\n  for (int i = maxk; i < K; ++i) {\n    if ((sum >> i) & 1) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < K; ++i) a[i][n] = (sum >> i) & 1;\n  trace(K, n, a);\n  for (int i = 0; i < K; ++i) {\n    int u, v;\n    for (u = i; u < K; ++u) {\n      for (v = i; v < n && a[u][v] == 0; ++v);\n      if (v < n) break;\n    }\n    if (u == K) {\n      int j;\n      for (j = u; j < K && a[j][n] == 0; ++j);\n      if (j != K) {\n        cout << -1 << '\\n';\n        return 0;\n      }\n      break;\n    }\n    if (i != u) swap(a[i], a[u]);\n    if (i != v) {\n      for (u = i; u < K; ++u) swap(a[u][i], a[u][v]);\n    }\n    for (u = 0; u < K; ++u) {\n      if (u != i && a[u][i]) {\n        for (v = i; v <= n; ++v) a[u][v] ^= a[i][v];\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < K; ++i) ret += a[i][n];\n  cout << ret << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n \ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define pb push_back\nint n, x, ban[2333];\nint main(void) {\n  read(n);\n  rep (i, n) {\n    int t; read(t); x ^= t;\n    re0 (k, 31) if (t >> k & 1) {\n      ban[k] = true;\n      break;\n    }\n  }\n  int ans = 0;\n  for (int k = 31; ~k; k --)\n    if (x >> k & 1) {\n      if (!ban[k]) return puts(\"-1\"), 0;\n      ++ ans;\n      for (int i = k; ~i; i --)\n        x ^= 1<< i;\n    }\n  cout << ans << \"\\n\";\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nint a[MAX_N];\nint b[MAX_N];\n\nint main()\n{\n\tint n,x=0,ans=0;\n\tcin >> n;\n\trep(i,n){\n\t\tscanf(\"%d\",&a[i]);\n\t\tx ^= a[i];\n\t\tb[i] = a[i]^(a[i]-1);\n\t}\n\tfor(int k=29;k>0;k--){\n\t\trep(i,n){\n\t\t\tif(x & (1 << (k-1))){\n\t\t\t\tif(b[i] == pow(2,k)-1){\n\t\t\t\t\tx ^= (1<<(k-1)) - 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(x==0){\n\t\tcout << ans << \"\\n\";\n\t}else{\n\t\tcout << \"-1\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                 \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpas(int x=0,int y=0):x(x),y(y) {}\n                                        \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                        \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                        \tpas operator * (int a) {return pas(x*a,y*a);}\n                                        \tpas operator / (int a) {return pas(x/a,y/a);}\n                                        \t\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        };\n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 \n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n            int pr[2000010];\n            int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             \n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n            \n           \nint par[200100],ranks[200100],kosuu[200100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\nint keta(int u){\n\tint r=1;\n\tfor(int i=0;i<40;i++){\n\t\tif(u==r) return i;\n\t\tr*=2;\n\t}\n}\n\nint u[40]={0};\n\n      signed main(){\n    int n;\n      \tint noko=0;\n      \tcin>>n;\n      \t\n      \tfor(int i=0;i<n;i++){\n      \t\tint uu;\n      \t\tcin>>uu;\n      \t\tint er=(uu&(-uu));\n      \t\tnoko^=uu-er;\n      \t\tu[keta(er)]^=1;\n      \t\n      \t}\n     // \tcout<<noko<<endl;\n      \tint ans=0;\n      \tfor(int i=31;i>=0;i--){\n      \t\tif(u[i]==0 && (noko&(1<<i))!=0){\n      \t\tcout<<-1<<endl;\n      \t\t\treturn 0;\n      \t\t}\n      \t\tif(u[i]==0) continue;\n      \t\t\n      \t\tif((noko&(1<<i))){\n      \t\t\tnoko -= (1<<i);\n      \t\t}\n      \t\telse{\n      \t\t\tans++;\n      \t\t\tnoko ^= (1<<i)-1;\n      \t\t}\n      \t}\n      \t\n      \tif(noko){\n      \t\tcout<<-1<<endl;\n      \t}\n      \telse cout<<ans<<endl;\n      \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define inf 100000000000000000\n#define rep(i,a) for(ll i=0; i<a; ++i)\n#define pb push_back\n\nll n;\nll a[100005];\nll cnt[40];\nll x=0;\n\nll getLastOneIndex(ll p) {\n  if (p%2==1) {\n    return 0;\n  } else {\n    return 1+getLastOneIndex(p/2);\n  }\n}\n\nvector<ll> reversedBitVector(ll p) {\n  vector<ll> ret;\n  for (ll i=0; i<40; ++i) {\n    ret.pb(p&1);\n    p = p>>1;\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin>>n;\n  rep(i,n) {\n    cin>>a[i];\n  }\n  rep(i,n) {\n    ll lastOneIndex = getLastOneIndex(a[i]);\n    x ^= (a[i]-(1<<lastOneIndex));\n    cnt[lastOneIndex]++;\n  }\n\n  ll ans=0;\n  vector<ll> revBit = reversedBitVector(x);\n  for (ll i=revBit.size()-1; i>=0; --i) {\n    if (revBit[i]==1) {\n      if (cnt[i]==0) {\n        cout<<-1<<endl;\n        return 0;\n      }\n      if (cnt[i]%2==0) {\n        ans++;\n        for (ll j=i-1; j>=0; --j) {\n          revBit[j] = 1-revBit[j];\n        }\n      }\n    } else {\n      if (cnt[i]%2==1) {\n        ans++;\n        for (ll j=i-1; j>=0; --j) {\n          revBit[j] = 1-revBit[j];\n        }\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\nconst int M = 100100;\n\nint n, a[M];\nint sum = 0;\nint b[M];\n\nvoid read() {\n  cin >> n;\n  for (int i = 0; i < n; ++i) {\n    cin >> a[i];\n    sum ^= a[i];\n    b[i] = a[i] ^ (a[i] - 1);\n  }\n}\n\nvoid kill() {\n  //cout << ((1 << 31) - 1) << endl;\n  int ans = 0;\n  for (int i = 30; i >= 0; --i)\n    if ((sum >> i) & 1) {\n      bool found = false;\n      for (int j = 0; j < n; ++j)\n        if (b[j] == (1 << (i + 1)) - 1) {\n          sum ^= b[j];\n          ++ans;\n          found = true;\n          break;\n        }\n\n      if (!found) {\n        cout << \"-1\" << endl;\n        exit(0);\n      }\n    }\n\n  assert(sum == 0);\n\n  cout << ans << endl;\n}\n\nint main() {\n#ifdef LOCAL\n  assert(freopen(\"c.in\", \"r\", stdin));\n#endif\n\n  ios_base::sync_with_stdio(false);\n\n  read();\n  kill();\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[1234567];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int x = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n    x ^= a[i];\n  }\n  int ans = 0;\n  for (int j = 30; j >= 0; j--) {\n    if (x & (1 << j)) {\n      for (int i = 0; i < n; i++) {\n        if (a[i] & (1 << j)) {\n          if (!(a[i] & ((1 << j) - 1))) {\n            x ^= a[i];\n            x ^= a[i] - 1;\n            ans++;\n            break;\n          }\n        }\n      }\n    }\n  }\n  printf(\"%d\\n\", x == 0 ? ans : -1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5;\nconst int INF = 1e9;\n\nint N;\nint A[MAXN + 10];\n\nvoid done(int xr) {\n   printf(\"%d\\n\", xr);\n   exit(0);\n}\n\nint lg(int x) {\n   int cc = 0;\n   while(x > 1) {\n      x >>= 1;\n      cc++;\n   }\n   return cc;\n}\n\nbool cnt[40];\n\nint main() {\n   scanf(\"%d\", &N);\n   for(int i = 0; i < N; i++) {\n      scanf(\"%d\", &A[i]);\n      if((A[i] & (A[i] - 1)) == 0) cnt[lg(A[i])] = true;\n   }\n   int xr = 0;\n   for(int i = 0; i < N; i++) {\n      xr ^= A[i];\n   }\n   int res = 0;\n   for(int i = 30-1; i > 0; i--) {\n      if(xr & (1 << i)) {\n         if(!cnt[i]) continue;\n         xr ^= 1 << i;\n         xr ^= (1 << i) - 1;\n         res++;\n      }\n   }\n   int cc = N;\n   for(int i = 0; i < N; i++) {\n      if((A[i] & (A[i] - 1)) == 0) cc--;\n   }\n   if(xr == 0) printf(\"%d\\n\", res);\n   else if(xr == 1 && cc > 0) printf(\"%d\\n\", res+1);\n   else printf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n \ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define pb push_back\nint n, x, ban[2333];\nint main(void) {\n  read(n);\n  rep (i, n) {\n    int t; read(t); x ^= t;\n    re0 (k, 31) if (t >> k & 1) {\n      ban[k] = true;\n      break;\n    }\n  }\n  int ans = 0;\n  for (int k = 31; ~k; k --)\n    if (x >> k & 1) {\n      if (!ban[k]) return puts(\"-1\"), 0;\n      ++ ans;\n      for (int i = k; ~i; i --)\n        x ^= 1<< i;\n    }\n  cout << ans << \"\\n\";\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <unordered_set>\n\nint a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &a[i]);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++)\n    xor_sum ^= a[i];\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++)\n    s.insert(a[i] ^ (a[i] - 1));\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.find(x) != s.end()) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nbool canUse(bitset<31> b, int lim){\n\trep(i,lim){\n\t\tif(b[i]) return false;\n\t}\n\tif(not b[lim]) return false;\n\treturn true;\n}\n\nsigned main(){\n\tint n;\n\tcin >> n;\n\n\tvector<bitset<31>> a(n);\n\tvector<bool> used(n,0);\n\tbitset<31> b(0);\n\trep(i,n){\n\t\tint in;\n\t\tcin >> in;\n\t\ta[i] = bitset<31>(in);\n\t\tb ^= a[i];\n\t}\n\n\tint ans = 0;\n\tfor(int i = 30; i >= 0; i--){\n\t\tif(b[i]){\n\t\t\tint tmp = (1 << (i + 1)) - 1;\n\n\t\t\trep(j,n){\n\t\t\t\tif(used[j]) continue;\n\t\t\t\tif(not canUse(a[j], i)) continue;\n\t\t\t\tb ^= tmp;\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (b == 0 ? ans : -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <map>\nusing namespace std;\n\ntypedef long long lint;\ntypedef unsigned long long ulint;\n\nint main(){\n    lint N;\n    cin >> N;\n    ulint *A,*D;\n    A=new ulint[N];\n    D=new ulint[N];\n    ulint X=0;\n    for(lint i=0;i<N;i++){\n        cin >> A[i];\n        D[i]=A[i]^(A[i]-1);\n        X^=A[i];\n    }\n\n    if(X==0){\n        cout << \"0\" << endl;\n        return 0;\n    }\n\n    queue<ulint> Q;\n    map<ulint,int> dist;\n    for(int i=0;i<N;i++){\n        Q.push(D[i]);\n        dist[D[i]]=1;\n    }\n\n    while(!Q.empty()){\n        ulint t=Q.front();\n        Q.pop();\n        if(t==X){\n            cout << dist[t] << endl;\n            return 0;\n        }\n        for(int i=0;i<N;i++){\n            if(dist[t^D[i]]==0){\n                Q.push(t^D[i]);\n                dist[t^D[i]]=dist[t]+1;\n            }\n        }\n    }\n\n    cout << \"-1\" << endl;\n\n    delete[] A,D;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint b[45];\nint N;\nint A[MAXN],t;\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {read(A[i]);t ^= A[i];}\n    for(int i = 1 ; i <= N ; ++i) {\n\tint a = (A[i] - 1) ^ A[i];\n\tfor(int j = 30 ; j >= 0 ; --j) {\n\t    if(a >> j & 1) {b[j] = a;break;}\n\t}\n    }\n    int cnt = 0;\n    for(int i = 30 ; i >= 0 ; --i) {\n\tif(t >> i & 1) {\n\t    if(b[i]) t ^= b[i];\n\t    else {puts(\"-1\");return;}\n\t    ++cnt;\n\t}\n    }\n    out(cnt);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nusing namespace std;\nbool vis[35]; int n;\nvoid calc(int x) {\n\trep(i, 0, 29) if (x == ((1 << (i + 1)) - 1)) vis[i] = true;\n}\nint main() {\n\tscanf(\"%d\", &n); int tmp = 0, x;\n\trep(i, 1, n) scanf(\"%d\", &x), tmp ^= x, calc(x ^ (x - 1));\n\tint now = 0, ans = 0;\n\tfor (int i = 29; i >= 0; -- i) if (vis[i]) {\n\t\tif (((tmp >> i) & 1) ^ ((now >> i) & 1))\n\t\t\t++ ans, now ^= ((1 << (i + 1)) - 1);\n\t}\n\tif (now == tmp) printf(\"%d\\n\", ans); else printf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing uint=unsigned int;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nll readLL(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nint main(){\n\tint n=read(),p=0;\n\tvi s;\n\tREP(i,n){\n\t\tint x=read();\n\t\tp^=x;\n\t\ts.PB(x^(x-1));\n\t}\n\tsort(ALL(s));\n\treverse(ALL(s));\n\tint ans=0;\n\tfor(auto v:s)if(p){\n\t\tif(__builtin_clz(p)==__builtin_clz(v)){\n\t\t\tp^=v;\n\t\t\tans++;\n\t\t}\n\t}\n\tif(p==0)\n\t\tcout<<ans<<endl;\n\telse\n\t\tcout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <map>\nusing namespace std;\n\ntypedef long long lint;\ntypedef unsigned long long ulint;\n\nint main(){\n    lint N;\n    cin >> N;\n    ulint *A,*D;\n    A=new ulint[N];\n    D=new ulint[N];\n    ulint X=0;\n    for(lint i=0;i<N;i++){\n        cin >> A[i];\n        D[i]=A[i]^(A[i]-1);\n        X^=A[i];\n    }\n\n    if(X==0){\n        cout << \"0\" << endl;\n        return 0;\n    }\n\n    queue<ulint> Q;\n    map<ulint,int> dist;\n    for(int i=0;i<N;i++){\n        Q.push(D[i]);\n        dist[D[i]]=1;\n    }\n\n    while(!Q.empty()){\n        ulint t=Q.front();\n        Q.pop();\n        if(t==X){\n            cout << dist[t] << endl;\n            return 0;\n        }\n        for(int i=0;i<N;i++){\n            if(dist[t^D[i]]==0 && ((X^t)&D[i])!=0){\n                Q.push(t^D[i]);\n                dist[t^D[i]]=dist[t]+1;\n            }\n        }\n    }\n\n    cout << \"-1\" << endl;\n\n    delete[] A,D;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\n\nvector<int> v;\n\nlong long int ans=0;\n\nset<int> mp;\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tv.push_back(a);\n\t\tans^=a;\n\t\tmp.insert(a);\n\t}\n\t//cout<<ans<<endl;\n\tint turn=0;\n\tint ans2=0;\n\tfor(int i=31;i>=0;i--){\n\t\t//cout<<i<<\" \"<<(ans>>i)<<endl;\n\t\tint used=-1;\n\t\tif((turn^(ans>>i))&1){\n\t\t\t//cout<<\"!! \"<<i<<endl;\n\t\t\tif(mp.count(1<<i)==0){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans2++;\n\t\t\tturn^=true;\n\t\t\tused=(1<<i);\n\t\t}\n\t\tmp.clear();\n\t\tint z=(1<<i)-1;\n\t\tvector<int> nex;\n\t\tfor(auto el:v){\n\t\t\tif(used!=el){\n\t\t\t\tnex.push_back(el&z);\n\t\t\t\tmp.insert(el&z);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused=-1;\n\t\t}\n\t\tv=nex;\n\t}\n\tcout<<ans2<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\n#define int long long \nusing namespace std;\n\ninline void read(int &x)\n{\n\tx=0;char ch=getchar();int pd=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')pd=-pd;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=pd;\n}\ninline void write(const int &x)\n{\n\tchar ggg[10001];int s=0;int tmp=x;\n\tif(tmp==0){putchar('0');return;}\n\tif(tmp<0){tmp=-tmp;putchar('-');}\n\twhile(tmp>0){ggg[s++]=tmp%10+'0';tmp/=10;}\n\twhile(s>0){putchar(ggg[--s]);}\n}\n\nint n,ans,a[100010];\nint cnt;\nbool can[100010];\nsigned main()\n{\n\tread(n);\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tans^=a[i];\n\t}\n    // puts(\"\");\n    // cout<<ans<<endl;\n\tfor(register int i=1;i<=n;++i)\n\t{\n    \tfor(register int j=0;j<=30;++j)\n\t\t{\n\t\t\tif(a[i]&(1<<j))\n\t\t\t{\n                // cout<<j<<endl;\n\t\t\t\tcan[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    // puts(\"\");\n    // cout<<ans<<endl;\n\tfor(register int i=30;i>=0;--i)\n\t{\n        // cout<<ans<<\"   \"  <<(1<<i)<<\"  \"<<(ans&(1<<i))<<endl;\n\t\tif(ans&(1<<i))\n        {\n            // cout<<i<<endl;\n            if(!can[i])\n            {\n                \n                puts(\"-1\");\n                return 0;\n            }\n            else \n            {\n                cnt++;\n                ans^=(1<<i)-1;\n            }\n        }\n        \n\t}\n    write(cnt);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\nint n, x, ans;\nint a[MAX_N];\nint l[MAX_N];\nint cnt[MAX_N];\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\t\t\n\tfor (int i = 0; i < n; i++)\n\t\tx ^= a[i];\n\t\t\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = __builtin_ctz(a[i]);\n\t\tcnt[l[i]]++;\n\t}\n\t\t\n\t\n\tfor (int i = 16; ~i; i--)\n\t\tif ((x >> i) & 1) {\n\t\t\tif (!cnt[i]) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tcnt[i]--;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &a[i]);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++)\n    xor_sum ^= a[i];\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    for (int i = 0; i < n; i++) {\n      int y = a[i] ^ (a[i] - 1);\n      if (y == x) {\n        xor_sum ^= y;\n        ans += 1;\n        break;\n      }\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint pw[(1<<15)+3];\nvoid pre(){\n\tfor(int i=0;i<16;i++) pw[1<<i]=i;\n}\nint pos(int val){\n\tval=val&(-val);\n\tif((val>>16)==0) return pw[val];\n\telse return 16+pw[val];\n}\nint n,tot;\nvector<int> v[35];\nint main(){\n\tscanf(\"%d\",&n);pre();\n\tfor(int i=1,t;i<=n;i++){\n\t\tscanf(\"%d\",&t);\n\t\ttot^=t;v[pos(t)].push_back(t);\n\t}\n\tint ans=0;\n\tfor(int i=30;i>=0;i--){\n\t\tif((tot>>i)&1){\n\t\t\tif(v[i].size()==0) return puts(\"-1\"),0;\n\t\t\tint t=v[i][0]-1;tot=tot^(t+1)^t;\n\t\t\tans++;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 13;\nint n, ans, x;\nbool mark[maxN];\nvector<int> vec;\nint main () {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n\tint a;\n\tcin >> a;\n\tx ^= a;\n\ta = __builtin_ctz(a);\n\tmark[a] = 1;\n    }\n\n    while (x) {\n\tvec.push_back(x % 2);\n\tx /= 2;\n    }\n    int indx = vec.size() - 1;\n    int lst = 0;\n    while (vec.size()) {\n\tint u = vec.back();\n\tvec.pop_back();\n\tif (u != lst) {\n\t    if (!mark[indx])\n\t\treturn cout << -1 << endl, 0;\n\t    else\n\t\tans++;\n\t}\n\tindx--;\n\tlst = u;\n    }\n    cout << ans << endl;\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 2000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define seg_size 524288\nint main() {\n\tint n;\n\tcin >> n;\n\tint xoring = 0;\n\tvector<int> wow;\n\tREP(i, n) {\n\t\tint a;\n\t\tcin >> a;\n\t\twow.push_back((a ^ (a-1)));\n\t\txoring ^= a;\n\t}\n\tsort(wow.begin(), wow.end(), greater<int>());\n\tint ans = 0;\n\tfor (int i = 0;i < n;++i) {\n\t\tint now = wow[i];\n\t\tif ((now ^ xoring) < xoring) {\n\t\t\tans++;\n\t\t\txoring ^= now;\n\t\t}\n\t}\n\tif (xoring == 0) {\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\t\nreturn\t\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\n\nint main(){\n    int N,total=0;cin>>N;\n    vector<int> A(N),B(31,0);\n    for(int i=0;i<N;i++){\n        cin>>A[i];\n        for(int j=0;j<31;j++){\n            if(A[i]&(1<<j)){ B[j]++;\n            break;\n            }\n        }\n        total=total^A[i];\n    }\n\n    int ans=0;\n\n    for(int j=30;j>=0;j--){\n        if(total&(1<<j)){\n            if(B[j]){\n                ans++;\n                total=(total^(1<<j))^((1<<j)-1);\n            }else ans-=1000;\n        }\n    }\n\n    if(ans>=0) cout<<ans<<endl;\n    else cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nint n;\nint a[120000];\nint fl[100];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tint xr = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\txr ^= a[i];\n\t\tint c = 0;\n\t\tint x = a[i];\n\t\twhile (x % 2 == 0)\n\t\t\tx /= 2, ++c;\n\t\tfl[c] = 1;\n\t}\n\tint ans = 0;\n\tfor (int i = 30; i >= 0; --i) {\n\t\tif ((xr >> i) & 1) {\n\t\t\tif (!fl[i]) {\n\t\t\t\tcout << -1 << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\txr ^= (1ll << (i + 1)) - 1;\n\t\t\t++ans;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  static int a[100000];\n  for(int i=0;i<n;i++){\n    scanf(\"%d\",a+i);\n  }\n  int C=0;\n  static bool B[100000]={0};\n  for(int t=29;t>=0;t--){\n    bool b=0;\n    for(int i=0;i<n;i++){\n      b^=(a[i]>>t)&1;\n    }\n    if(b==0){\n      continue;\n    }\n    bool F=0;\n    for(int i=0;i<n;i++){\n      if(((a[i]>>t)&1)&&((a[i]&((1<<t)-1))==0)&&!B[i]){\n\tF=1;\n\ta[i]--;\n\tC++;\n\tB[i]=1;\n\tbreak;\n      }\n    }\n    if(!F){\n      C=-1;\n      break;\n    }\n  }\n  printf(\"%d\\n\",C);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define inf 100000000000000000\n#define rep(i,a) for(ll i=0; i<a; ++i)\n#define pb push_back\n\nll n;\nll a[100005];\nll cnt[20];\nll x=0;\n\nll getLastOneIndex(ll p) {\n  return log2(p & (~p+1));\n}\n\nvector<ll> reversedBitVector(ll p) {\n  vector<ll> ret;\n  for (ll i=0; i<20; ++i) {\n    ret.pb(p&1);\n    p = p>>1;\n  }\n  return ret;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin>>n;\n  rep(i,n) {\n    cin>>a[i];\n  }\n  rep(i,n) {\n    ll lastOneIndex = getLastOneIndex(a[i]);\n    x ^= (a[i]-(1<<lastOneIndex));\n    cnt[lastOneIndex]++;\n  }\n\n  ll ans=0;\n  vector<ll> revBit = reversedBitVector(x);\n  for (ll i=revBit.size()-1; i>=0; --i) {\n    if (revBit[i]==1) {\n      if (cnt[i]==0) {\n        cout<<-1<<endl;\n        return 0;\n      }\n      if (cnt[i]%2==0) {\n        ans++;\n        for (ll j=i-1; j>=0; --j) {\n          revBit[j] = 1-revBit[j];\n        }\n      }\n    } else {\n      if (cnt[i]%2==1) {\n        ans++;\n        for (ll j=i-1; j>=0; --j) {\n          revBit[j] = 1-revBit[j];\n        }\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nint f(int a) {\n    if(a & 1) return 1;\n    return 2 * (f(a /2));\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    vector<int> v(N);\n    int Grundy = 0;\n    for(int i = 0; i < N; i++) {\n        int a;\n        cin >> a;\n        Grundy ^= a;\n        v[i] = f(a);\n        v[i] <<= 1;\n        v[i]--;\n    }\n    sort(v.begin(), v.end(), greater<int>());\n    int ans = 0;\n    for(int i = 0; i < v.size(); i++) {\n        if(chmin(Grundy, Grundy ^ v[i])) ans++;\n    }\n    if(Grundy != 0) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n;\n\tcin>>n;\n\tvector<int> v(n);\n\tll s = 0;\n\trep(i, n){\n\t\tint a;\n\t\tcin>>a;\n\t\tv[i] = a^(a-1);\n\t\ts ^= a;\n\t}\n\tsort(all(v)); UNIQUE(v); reverse(all(v));\n\t//cerr<<v.size()<<endl;\n\tll res = 0;\n\trep(i, n){\n\t\tif(s^v[i]<s){\n\t\t\ts ^= v[i];\n\t\t\tres++;\n\t\t}\n\t}\n\tcout<<(s?-1:res)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <map>\nusing namespace std;\n\ntypedef long long lint;\ntypedef unsigned long long ulint;\n\nint main(){\n    lint N;\n    cin >> N;\n    ulint X=0,E=0;\n    for(lint i=0;i<N;i++){\n        ulint A;\n        cin >> A;\n        X^=A;\n        E|=(A^(A-1))+1;\n    }\n\n    lint cnt=0;\n    for(int i=31;i>=0;i--){\n        if(X&(1<<i)){\n            if((E&(1<<(i+1)))==0){\n                cout << \"-1\" << endl;\n                return 0;\n            }\n            cnt++;\n            X^=(1<<(i+1))-1;\n        }\n    }\n    cout << cnt << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 1000100\nint n, a[N];\nint b[N];\n\nint main () {\n\tcin >> n;\n\tint S = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tcin >> a[i];\n\t\tassert(a[i] <= 1000000000);\n\t\tassert(a[i] >= 2);\n\t\tS ^= a[i];\n\t\tb[i] = a[i] ^ (a[i]-1);\n\t}\n\tsort(b, b+n);\n\tint m = unique(b, b+n)-b;\n\tint T = -1;\n\tfor (int p = 0; p < (1<<m); p++) {\n\t\tint SS = S;\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\tif ((p>>i)&1) SS ^= b[i];\n\t\tif (!SS) {\n\t\t\tint c = pct(p);\n\t\t\tif (T == -1 || T > c) T = c;\n\t\t}\n\t}\n\tcout << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n \n#include <iostream>\n#include <algorithm>\n \n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstring>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n \n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n \n \nusing namespace std;\n#define int long long\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n \n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n \nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll INFLL = 1LL<<62;\nconst double EPS = 1e-12;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n \n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n \n//debug\n#define DEBUG \n \n#define DUMPOUT cout\n \n#ifdef DEBUG\n#define dump(...) DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__FUNCTION__<<\":\"<<__LINE__<<\"]\"<<endl; DUMPOUT<<\"    \"; dump_func(__VA_ARGS__)\n#else\n#define dump(...) \n#endif\n \nvoid dump_func() {DUMPOUT << endl;};\n \ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) == 0) DUMPOUT << \" \";\n    else DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n \n//ostream \ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n    os << \"[\"; for (int i = 0; i<vec.size(); i++) os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); os << \"]\";\n    return os;\n}\n \ntemplate<typename T, typename U> ostream& operator << (ostream& os, pair<T, U>& pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n \ntemplate<typename T, typename U> ostream& operator << (ostream& os, map<T, U>& map_var) {\n    os << \"[\";\n    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {\n        os << \"(\" << itr->first << \", \" << itr->second << \")\"; itr++;  if(itr != map_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n \ntemplate<typename T> ostream& operator << (ostream& os, set<T>& set_var) {\n    os << \"[\";\n    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {\n        os << *itr; ++itr; if(itr != set_var.end()) os << \", \"; itr--;\n    }\n    os << \"]\";\n    return os;\n}\n\nint n;\nint a[100000 + 5];\nbool bit[35];\n\nsigned main() {\t\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    int xors = 0;\n    rep(i, n) {\n        cin >> a[i];\n        xors ^= a[i];\n        rep(j, 31) {\n            if (a[i]>>j & 1) {\n                bit[j] = true;\n                break;\n            }\n        }\n    }\n    int ans = 0;\n    rrep2(i, 33, -1) {\n        if (xors>>i & 1) {\n            if (!bit[i]) {\n                cout << -1 << endl;\n                return 0;\n            }\n            xors ^= (1<<i) - 1;\n            ans++;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 13;\nint n, ans, x;\nbool mark[maxN];\nvector<int> vec;\nint main () {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n\tint a;\n\tcin >> a;\n\tx ^= a;\n\ta = __builtin_ctz(a);\n\tmark[a] = 1;\n    }\n\n    while (x) {\n\tvec.push_back(x % 2);\n\tx /= 2;\n    }\n    int indx = vec.size() - 1;\n    int lst = 0;\n    while (vec.size()) {\n\tint u = vec.back();\n\tvec.pop_back();\n\tif (u != lst) {\n\t    if (!mark[indx])\n\t\treturn cout << -1 << endl, 0;\n\t    else\n\t\tans++;\n\t}\n\tindx--;\n\tlst = u;\n    }\n    cout << ans << endl;\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <map>\nusing namespace std;\n\ntypedef long long lint;\ntypedef unsigned long long ulint;\n\nint main(){\n    lint N;\n    cin >> N;\n    ulint *A,*D;\n    A=new ulint[N];\n    D=new ulint[N];\n    ulint X=0,E=0;\n    for(lint i=0;i<N;i++){\n        cin >> A[i];\n        D[i]=A[i]^(A[i]-1);\n        X^=A[i];\n        E|=D[i]+1;\n    }\n\n    bool one=false;\n    lint cnt=0;\n    for(int i=30;i>=0;i--){\n        if((X&(1<<i))!=one){\n            if((E&(1<<(i+1)))==0){\n                cout << \"-1\" << endl;\n                return 0;\n            }\n            cnt++;\n            one=!one;\n        }\n    }\n    cout << cnt << endl;\n\n\n    delete[] A,D;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    vec a(N); cin >> a;\n\n    bools f(60, false);\n    REP(i, N){\n        int d = __builtin_ffsll(a[i]);\n        f[d - 1] = true;\n    }\n\n    int X = 0;\n    REP(i, N) X ^= a[i];\n\n    int ans = 0;\n    IREP(i, 60) if(bit_exist(X, i)){\n        if(!f[i]){\n            Out(-1);\n            return 0;\n        }else{\n            ans++;\n            X ^= bit(i + 1) - 1;\n        }\n    }\n    Out(ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10, M = 31;\nint n, ans, x, mark[M];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint y, cnt = 0;\n\t\tcin >> y;\n\t\tx ^= y;\n\t\t\n\t\twhile (y % 2 == 0) {\n\t\t\tcnt++;\n\t\t\ty /= 2;\n\t\t}\n\t\tmark[++cnt]++;\n\t}\n\t\n\tfor (int i = M - 1; i >= 0; i--)\n\t\tif (x & (1LL << i)) {\n\t\t\tif (!mark[i + 1])\n\t\t\t\treturn cout << -1, 0;\n\t\t\tx = ~x;\n\t\t\tans++;\n\t\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n, a, C[30], r;\nint main(){\n    int i, t, c;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&a);\n        r ^= a;\n        t = (a&-a);\n        c=0;\n        while(t){\n            t>>=1;\n            c++;\n        }\n        C[c]++;\n    }\n    c = 0;\n    for(i=30;i>=0;i--){\n        if((r>>i)&1){\n            c++;\n            if(!C[i+1]){\n                printf(\"-1\\n\");\n                return 0;\n            }\n            r ^= (1<<(i+1))-1;\n        }\n    }\n    printf(\"%d\\n\",c);\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 1e5 + 20 , LG = 32 ;\nint n , a[N] , X , cnt[LG] , ans ;\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\t\tX ^= a[i] ;\n\t\n\t\ta[i] ^= a[i] - 1 ;\n\n\t\tcnt[__builtin_popcount(a[i])] ++ ;\n\t}\n\n\tfor (int i = 1 ; i < LG ; i ++) {\n\t\tif ((X >> i & 1) != (X >> (i - 1) & 1)) {\n\t\t\tif (!cnt[i]) return cout << \"-1\\n\" , 0 ;\n\t\t\tans ++ ;\n\t\t}\n\t}\n\n\tcout << ans << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\n\nint main(){\n    int n; sd(n);\n    vector<int> a(n);\n    vector<int> there(30);\n    int x = 0;\n    for(int i = 0; i < n; i++){\n        sd(a[i]); x ^= a[i];\n        for(int j = 0; j < 30; j++) if(a[i] >> j & 1){\n            there[j] = 1;\n            break;\n        }\n    }\n    int ans = 0;\n    for(int i = 29; i >= 0; i--){\n        if(x >> i & 1){\n            if(!there[i]){\n                printf(\"-1\\n\");\n                return 0;\n            }\n            x ^= (1 << (i + 1)) - 1;\n            ans++;\n        }\n    }\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\n#define int long long \nusing namespace std;\n\ninline void read(int &x)\n{\n\tx=0;char ch=getchar();int pd=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')pd=-pd;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=pd;\n}\ninline void write(const int &x)\n{\n\tchar ggg[10001];int s=0;int tmp=x;\n\tif(tmp==0){putchar('0');return;}\n\tif(tmp<0){tmp=-tmp;putchar('-');}\n\twhile(tmp>0){ggg[s++]=tmp%10+'0';tmp/=10;}\n\twhile(s>0){putchar(ggg[--s]);}\n}\n\nint n,ans,a[100010];\nint cnt;\nbool can[100010];\nsigned main()\n{\n\tread(n);\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tread(a[i]);\n\t\tans^=a[i];\n\t}\n    // puts(\"\");\n    // cout<<ans<<endl;\n\tfor(register int i=1;i<=n;++i)\n\t{\n    \tfor(register int j=0;j<=30;++j)\n\t\t{\n\t\t\tif(a[i]&(1<<j))\n\t\t\t{\n                // cout<<j<<endl;\n\t\t\t\tcan[j]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    // puts(\"\");\n    // cout<<ans<<endl;\n\tfor(register int i=30;i>=0;--i)\n\t{\n        // cout<<ans<<\"   \"  <<(1<<i)<<\"  \"<<(ans&(1<<i))<<endl;\n\t\tif(ans&(1<<i))\n        {\n            // cout<<i<<endl;\n            if(!can[i])\n            {\n                \n                puts(\"-1\");\n                return 0;\n            }\n            else \n            {\n                cnt++;\n                ans^=(1<<i)-1;\n            }\n        }\n        \n\t}\n    write(cnt);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define pdd pair < db , db >\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int s[1 << 20];\n    int n;\n    fi>>n;\n    int cnt = 0;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i],cnt ^= s[i],s[i] ^= (s[i] - 1);\n    sort(s + 1,s + 1 + n,greater < int > ());\n    auto lg = [&](int x)\n    {\n        int ans = 0;\n        while ((++ans) && (x /= 2));\n        return ans;\n    };\n    int ans = 0;\n    for (int i = 1;cnt && i <= n;++i)\n        if (lg(cnt) == lg(s[i]))\n            cnt ^= s[i],++ans;\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fio() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pi;\ntypedef pair<pi, ll> pii;\n\nconst ll mod = 1e9 + 7;\nconst ll maxn = 1e5 + 6;\nconst ll N = 1e2 + 2;\nconst ll inf = 1e12;\nconst ld eps = 1e-6;\n\nll n, a[maxn], cnt[maxn], x, ans;\n\nint main() {\n\tfio();\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tx = x ^ a[i];\n\t\tll tmp = a[i], t = 0;\n\t\twhile (!(tmp & 1)) {\n\t\t\tt++;\n\t\t\ttmp /= 2;\t\n\t\t}\n\t\tcnt[t]++;\n\t}\n\tfor (int b = 31; b >= 0; b--) {\n\t\tll p = 1LL << b;\n\t//\tcout << x << \" \" << p << endl;\n\t\tif (x & p) {\n\t\t\tif (cnt[b] < 1) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tp = p * 2;\n\t\t\tx ^= (p - 1);\n\t\t\tans++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e3 + 13;\nint n, ans, x;\nbool mark[maxN];\nvector<int> vec;\nint main () {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n\tint a;\n\tcin >> a;\n\tx ^= a;\n\ta = __builtin_ctz(a);\n\tmark[a] = 1;\n    }\n\n    while (x) {\n\tvec.push_back(x % 2);\n\tx /= 2;\n    }\n    int indx = vec.size() - 1;\n    int lst = 0;\n    while (vec.size()) {\n\tint u = vec.back();\n\tvec.pop_back();\n\tif (u != lst) {\n\t    if (!mark[indx])\n\t\treturn cout << -1 << endl, 0;\n\t    else\n\t\tans++;\n\t}\n\tindx--;\n\tlst = u;\n    }\n    cout << ans << endl;\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint N;\n\tcin >> N;\n\tint xors = 0;\n\t\n\tint bit[32] = {};\n\tfor(int i = 0 ; i < N ; i++){\n\t\tint z = 0;\n\t\tint n;\n\t\tcin >> n;\n\t\txors ^= n;\n\t\twhile( n % 2 == 0 ) z++, n /= 2;\n\t\tbit[z]++;\n\t\t//cout << z << endl;\n\t}\n\tint ans = 0;\n\tfor(int i = 31 ; i >= 0 ; i--){\n\t\tif( xors >> i & 1 ){\n\t\t\tif( !bit[i] ){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans++;\n\t\t\txors ^= ((1ll<<i)-1);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cout;\nusing std::endl;\nusing std::cin;\n\nint main(){\n\tint n; cin >> n; std::vector<long> a(n);\n\tlong x = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t\t\n\t\tx ^= a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor(int k = 30; k >= 1; k--){\n\t\tif((x >> k) & 1){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif((a[i] ^ (a[i] - 1)) == ((1LL << k) - 1)){\n\t\t\t\t\n\t\t\t\t\tx ^= (1LL << k) - 1;\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(x) cout << -1 << endl;\n\telse cout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector<int> v;\n  auto add = [&](int a) {\n    for (int e : v) {\n      a = min(a, a ^ e);\n    }\n    if (a) {\n      v.push_back(a);\n      return true;\n    }\n    return false;\n  };\n  int x = 0;\n  while (n--) {\n    int a;\n    cin >> a;\n    x ^= a;\n    add(a ^ (a - 1));\n  }\n  if (add(x)) {\n    cout << \"-1\\n\";\n    exit(0);\n  }\n  cout << __builtin_popcount(x ^ x >> 1) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef long long lint;\ntypedef unsigned long long ulint;\n\nint main(){\n    lint N;\n    cin >> N;\n    ulint *A,*D;\n    A=new ulint[N];\n    D=new ulint[N];\n    ulint X=0;\n    for(lint i=0;i<N;i++){\n        cin >> A[i];\n        D[i]=A[i]^(A[i]-1);\n        X^=A[i];\n    }\n\n    if(X==0){\n        cout << \"0\" << endl;\n        return 0;\n    }\n\n    bool *chk;\n    chk=new bool[1024*1024*1024];\n    for(lint i=0;i<1024*1024*1024;i++) chk[i]=false;\n    queue<pair<ulint,int>> Q;\n    for(int i=0;i<N;i++) Q.push(make_pair(D[i],1));\n\n    while(!Q.empty()){\n        auto t=Q.front();\n        Q.pop();\n        if(chk[t.first]) continue;\n        chk[t.first]=true;\n        if(t.first==X){\n            cout << t.second << endl;\n            return 0;\n        }\n        for(int i=0;i<N;i++){\n            Q.push(make_pair(t.first^D[i],t.second+1));\n        }\n    }\n\n    cout << \"-1\" << endl;\n\n    delete[] A,D,chk;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\nusing namespace std;\n# define fi cin\n# define fo cout\n# define x first\n# define y second\n# define ll long long\n# define IOS ios_base :: sync_with_stdio(0);cin.tie(0)\n# define p(v) cerr << #v << \" = \" << v << '\\n'\n# define p2(v) cerr << #v << \" = \" << (complex < int > (v.x,v.y)) << '\\n'\n# define vi vector < int >\n# define vll vector < ll >\n# define pii pair < int , int >\n# define mp make_pair\n# define db long double\n# define pdd pair < db , db >\nint main(void)\n{\n    #ifdef CF\n    freopen(\"input\",\"r\",stdin);\n    #endif // CF\n    srand(time(0));\n    fo << fixed << setprecision(7);\n    cerr << fixed << setprecision(7);\n    static int s[1 << 20];\n    int n;\n    fi>>n;\n    int cnt = 0;\n    for (int i = 1;i <= n;++i)\n        fi>>s[i],cnt ^= s[i],s[i] ^= (s[i] - 1);\n    sort(s + 1,s + 1 + n,greater < int > ());\n    auto lg = [&](int x)\n    {\n        int ans = 0;\n        while ((++ans) && (x /= 2));\n        return ans;\n    };\n    int ans = 0;\n    for (int i = 1;cnt && i <= n;++i)\n        if (lg(cnt) == lg(s[i]))\n            cnt ^= s[i],++ans;\n    if (cnt)\n        ans = -1;\n    fo << ans << '\\n';\n    cerr << \"Time elapsed :\" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\" << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,a,x,c,k[35];\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a;\n\t\tx^=a;\n\t\ta^=a-1;\n\t\tfor(int j=1;j<31;j++)if(a==(1<<j)-1)k[j]=1;\n\t}\n\tfor(int i=30;i>0;i--)\n\t{\n\t\tif(x&(1<<(i-1))&&k[i])c++,x^=(1<<i)-1;\n\t}\n\tcout<<(x?-1:c)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 1e5 + 5;\n\nint n, sum, cnt;\narray<int, MAXN> a, f;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i], sum^= a[i], a[i] ^= a[i -1];\n        for (int j = 30; ~j; j--) {\n            if ((a[i] >> j) & 1) {\n                f[j] = 1;\n                break;\n            }\n        }\n    }\n    for (int j = 30; ~j; j--)\n        if (((sum >> j) & 1) && f[j])\n            sum ^= (1 << (j + 1)) - 1, cnt++;\n    cout << (sum ? -1 : cnt) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<functional>\n#include<stack>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<deque>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\nusing namespace std;\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(10)\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\nbool ok[100];\n\nint main()\n{\n\tint n;cin >> n;\n\tll now = 0;\n\tREP(i,n)\n\t{\n\t\tll tmp;cin >> tmp;\n\t\tnow ^= tmp;\n\t\tREP(j,60)\n\t\t{\n\t\t\tif(tmp & (1LL<<j))\n\t\t\t{\n\t\t\t\tok[j] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//SHOW1d(ok,10);\n\t\n\tint ans = 0;\n\tfor(int i = 60; i >= 0;i--)\n\t{\n\t\tif(now & (1LL<<i))\n\t\t{\n\t\t\tif(!ok[i])\n\t\t\t{\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans++;\n\t\t\t\tnow ^= ((1LL<<i)-1);\n\t\t\t}\n\t\t\t\n\t\t}\n\t//\tcout << now << endl;\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n#include \"cmath\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tM ^= v[i];\n\t}\n\tfor (int i = 30; i >=0; i--) {\n\t\tif (M >> i & 1) {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (v[j] % (int)pow(2, i) == 0 && v[j] % (int)pow(2, i + 1)) {\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tM ^= (int)pow(2, i);\n\t\t\tM ^= (int)(pow(2, i) - 1);\n\t\t\tK++;\n\t\t}\n\t}\n\tif (!M) {\n\t\tcout << K << endl;\n\t}\n\telse {\n\t\tcout << \"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define N 100010\nint n, a[N];\nint b[N];\n\nint main () {\n\tcin >> n;\n\tint S = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tcin >> a[i];\n\t\tS ^= a[i];\n\t\tb[i] = a[i] ^ (a[i]-1);\n\t}\n\tsort(b, b+n);\n\tint m = unique(b, b+n)-b;\n\tint T = -1;\n\tfor (int p = 0; p < (1<<m); p++) {\n\t\tint SS = S;\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\tif ((p>>i)&1) SS ^= b[i];\n\t\tif (!SS) {\n\t\t\tint c = pct(p);\n\t\t\tif (T == -1 || T > c) T = c;\n\t\t\t\n\t\t}\n\t}\n\tcout << T << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "check[30], c, n, a, xor_sum, ans, bit, i;\nmain() {\n  while (1) {\n    c = getchar_unlocked();\n    if (48 <= c && c <= 57)\n      n = n * 10 + c - 48;\n    else\n      break;\n  }\n\n  for (i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if (48 <= c && c <= 57)\n        a = a * 10 + c - 48;\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    check[__builtin_popcount(a) - 1] = 1;\n  }\n\n  for (bit = 29; bit >= 0; bit--) {\n    if (check[bit] && ((1 << bit) & xor_sum)) {\n      xor_sum ^= (1 << (bit + 1)) - 1;\n      ans += 1;\n    }\n  }\n\n  printf(\"%d\\n\", xor_sum ? -1 : ans);\n}"
  },
  {
    "language": "C",
    "code": "c,i,k[30],x;main(n){for(;~scanf(\"%d\",&i);)k[__builtin_ctz(i)]=--n&&(x^=i);for(i=30;i--;)x&k[i]<<i&&(c++,x^=(1<<i+1)-1);printf(\"%d\",x?-1:c);}"
  },
  {
    "language": "C",
    "code": "c,i,k[30],x;main(n){for(;~scanf(\"%d\",&i);)k[__builtin_ctz(i)]=--n&&(x^=i);for(i=30;i--;x&n&&(c++,x^=n*2-1))n=k[i]<<i;printf(\"%d\",x?-1:c);}"
  },
  {
    "language": "C",
    "code": "int check[30];\n\nint main() {\n\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  int a;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "int check[30];\n\nint c, n, a;\n\nint main() {\n  n = 0;\n  while (1) {\n    c = getchar_unlocked();\n    if ('0' <= c && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      break;\n  }\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if ('0' <= c && c <= '9')\n        a = a * 10 + c - '0';\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    check[__builtin_popcount(a) - 1] = 1;\n\n    // switch (a) {\n    // case 1073741823:\n    //   check[29] = 1;\n    //   break;\n    // case 536870911:\n    //   check[28] = 1;\n    //   break;\n    // case 268435455:\n    //   check[27] = 1;\n    //   break;\n    // case 134217727:\n    //   check[26] = 1;\n    //   break;\n    // case 67108863:\n    //   check[25] = 1;\n    //   break;\n    // case 33554431:\n    //   check[24] = 1;\n    //   break;\n    // case 16777215:\n    //   check[23] = 1;\n    //   break;\n    // case 8388607:\n    //   check[22] = 1;\n    //   break;\n    // case 4194303:\n    //   check[21] = 1;\n    //   break;\n    // case 2097151:\n    //   check[20] = 1;\n    //   break;\n    // case 1048575:\n    //   check[19] = 1;\n    //   break;\n    // case 524287:\n    //   check[18] = 1;\n    //   break;\n    // case 262143:\n    //   check[17] = 1;\n    //   break;\n    // case 131071:\n    //   check[16] = 1;\n    //   break;\n    // case 65535:\n    //   check[15] = 1;\n    //   break;\n    // case 32767:\n    //   check[14] = 1;\n    //   break;\n    // case 16383:\n    //   check[13] = 1;\n    //   break;\n    // case 8191:\n    //   check[12] = 1;\n    //   break;\n    // case 4095:\n    //   check[11] = 1;\n    //   break;\n    // case 2047:\n    //   check[10] = 1;\n    //   break;\n    // case 1023:\n    //   check[9] = 1;\n    //   break;\n    // case 511:\n    //   check[8] = 1;\n    //   break;\n    // case 255:\n    //   check[7] = 1;\n    //   break;\n    // case 127:\n    //   check[6] = 1;\n    //   break;\n    // case 63:\n    //   check[5] = 1;\n    //   break;\n    // case 31:\n    //   check[4] = 1;\n    //   break;\n    // case 15:\n    //   check[3] = 1;\n    //   break;\n    // case 7:\n    //   check[2] = 1;\n    //   break;\n    // case 3:\n    //   check[1] = 1;\n    //   break;\n    // case 1:\n    //   check[0] = 1;\n    //   break;\n    // }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "check[30], c, n, a, X, A, B, i;\nmain() {\n  while (1) {\n    c = getchar_unlocked();\n    if (48 <= c && c <= 57)\n      n = n * 10 + c - 48;\n    else\n      break;\n  }\n\n  for (i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if (48 <= c && c <= 57)\n        a = a * 10 + c - 48;\n      else\n        break;\n    }\n    X ^= a;\n    // check[__builtin_popcount(a ^ (a - 1)) - 1] = 1;\n  }\n\n  for (B = 29; B >= 0; B--)\n    if (check[B] && ((1 << B) & X))\n      X ^= (1 << (B + 1)) - 1, A++;\n\n  printf(\"%d\\n\", X ? -1 : A);\n}"
  },
  {
    "language": "C",
    "code": "c,i,k[30],x;main(n){for(;~scanf(\"%d\",&i);)k[__builtin_ctz(i)]=--n&&(x^=i);for(i=30;i--;x&n&&(c++,x=~x&n-1))n=k[i]<<i;printf(\"%d\",x?-1:c);}"
  },
  {
    "language": "C",
    "code": "c,i,k[30],x;main(n){for(;~scanf(\"%d\",&i);)k[__builtin_popcount(i^i-1)]=--n&&(x^=i);for(i=30;i;i--)x&k[i]<<i-1&&(c++,x^=(1<<i)-1);printf(\"%d\",x?-1:c);}"
  },
  {
    "language": "C",
    "code": "int a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++)\n    scanf(\"%d\", &a[i]);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++)\n    xor_sum ^= a[i];\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    for (int i = 0; i < n; i++) {\n      int y = a[i] ^ (a[i] - 1);\n      if (y == x) {\n        xor_sum ^= y;\n        ans += 1;\n        break;\n      }\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <unordered_set>\n\nint a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    xor_sum ^= a[i];\n  }\n\n  std::unordered_set<int> s;\n  for (int i = 0; i < n; i++)\n    s.insert(a[i] ^ (a[i] - 1));\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (s.find(x) != s.end()) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "int a[100000];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    xor_sum ^= a[i];\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    for (int i = 0; i < n; i++) {\n      int y = a[i] ^ (a[i] - 1);\n      if (y == x) {\n        xor_sum ^= y;\n        ans += 1;\n        break;\n      }\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "int check[30];\n\nint c, n, a;\n\nint main() {\n  n = 0;\n  while (1) {\n    c = getchar_unlocked();\n    if ('0' <= c && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      break;\n  }\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if ('0' <= c && c <= '9')\n        a = a * 10 + c - '0';\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    check[__builtin_popcount(a) - 1] = 1;\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit]) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "check[30], c, n, a;\nint main() {\n  while (1) {\n    c = getchar_unlocked();\n    if ('0' <= c && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      break;\n  }\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if ('0' <= c && c <= '9')\n        a = a * 10 + c - '0';\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    check[__builtin_popcount(a) - 1] = 1;\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (check[bit] && ((1 << bit) & xor_sum)) {\n      int x = (1 << (bit + 1)) - 1;\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "int check[30];\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 0; i < 30; i++)\n    check[i] = 0;\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    int x;\n    scanf(\"%d\", &x);\n    switch (x) {\n    case 1:\n      check[0] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 1073741823:\n      check[29] = 1;\n      break;\n    default:\n      break;\n    }\n    xor_sum ^= x;\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit]) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "check[30], c, n, a;\nint main() {\n  n = 0;\n  while (1) {\n    c = getchar_unlocked();\n    if ('0' <= c && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      break;\n  }\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if ('0' <= c && c <= '9')\n        a = a * 10 + c - '0';\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    check[__builtin_popcount(a) - 1] = 1;\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit]) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define BIG 2000000007\n#define VERYBIG 200000000000007LL\n\n#define MOD 1000000007\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 100000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n\nusing namespace std; // I'm NOT gonna use C++ without compro. shit\n\ntypedef priority_queue<ull, vector<ull>, greater<ull> > upque123;\ntypedef priority_queue<ull, vector<ull> > upque321;\ntypedef priority_queue<sll, vector<sll>, greater<sll> > spque123;\ntypedef priority_queue<sll, vector<sll> > spque321;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\n\ntypedef struct {\n\tull s;\n\tull t;\n\tint32_t c;\n} struct_a;\n\ntypedef struct {\n\tint32_t from;\n\tint32_t to;\n\tsll cost;\n} struct_b;\n\n\n\nconst hw vector8[8] = {\n\t{-1, -1},\n\t{-1,  0},\n\t{-1, +1},\n\t{ 0, -1},\n\t{ 0, +1},\n\t{+1, -1},\n\t{+1,  0},\n\t{+1, +1}\n};\n\null n, m;\null h, w;\null k;\null q;\null vua, vub, vuc, vud, vue, vuf;\nsll vsa, vsb, vsc, vsd, vse, vsf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nsize_t slen;\nsize_t tlen;\nchar ch, dh;\n\nvoid swap_adj (ull *a, ull *b) {\n\tif (*a != *b) {\n\t\tull tmp = *b;\n\t\t*b = *a;\n\t\t*a = tmp;\n\t}\n\treturn;\n}\n\nint32_t digits (ull x) {\n\tint32_t i = 1;\n\twhile (x >= 10) {\n\t\tx /= 10;\n\t\ti++;\n\t}\n\treturn i;\n}\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null ullabs (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sllabs (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll nibutanlobo (bool (*func)(sll arg), sll ok, sll ng) {\n\twhile (sllabs(ok, ng) > 1) {\n\t\tsll med = (ok + ng) / 2;\n\t\tif (func(med)) {\n\t\t\tok = med;\n\t\t} else {\n\t\t\tng = med;\n\t\t}\n\n\t\t// printf(\"debug: [%lld %lld)\\n\", ok, ng);\n\t}\n\n\tif (!func(ok)) return ok * 2 - ng;\n\treturn ok;\n}\n\nvoid printUquotient (ull left, ull right) {\n\tconst int32_t digits = 20;\n\n\tprintf(\"%llu.\", left / right);\n\tleft %= right;\n\tfor (int32_t i = 0; i < digits; i++) {\n\t\tleft *= 10;\n\t\tprintf(\"%1d\", left / right);\n\t\tleft %= right;\n\t}\n\tputs(\"\");\n\n\treturn;\n}\n\nvoid printSquotient (sll left, sll right) {\n\tif (left * right < 0) putchar('-');\n\tprintUquotient(sllabs(left, 0), sllabs(right, 0));\n\n\treturn;\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#ifdef __cplusplus\n\ntypedef struct {\n\tint32_t to;\n\tsll cost;\n} edge;\ntypedef pair<sll, int32_t> P;\n\nstd::vector<edge> g[N_MAX];\nvoid dijk_init (ull n, struct_b arr[]) {\n\tedge x;\n\tfor (int32_t i = 0; i < n; i++) {\n\t\tx.to = arr[i].to;\n\t\tx.cost = arr[i].cost;\n\t\tg[arr[i].from].push_back(x);\n\t}\n}\n\nvoid dijk_distinit (int s, sll distance[], ull n) {\n\tfor (int32_t i = 0; i < n; i++) {\n\t\tdistance[i] = VERYBIG;\n\t}\n\tdistance[s] = 0;\n\treturn;\n}\n\nbool dijkstra (int s, sll distance[]) {\n\tpriority_queue<P, std::vector<P>, greater<P> > que; // (最短距離, 頂点番号)\n\tque.push(P(distance[s], s));\n\n\tbool ischanged = false;\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tsll v = p.second;\n\t\tif (distance[v] < p.first) continue;\n\n\t\tint32_t maxsize = g[v].size();\n\t\tfor (int32_t i = 0; i < maxsize; i++) {\n\t\t\tedge e = g[v][i];\n\t\t\tif (distance[e.to] > distance[v] + e.cost) {\n\t\t\t\tdistance[e.to] = distance[v] + e.cost;\n\t\t\t\tischanged = true;\n\t\t\t\tque.push(P(distance[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ischanged;\n}\n\n#endif\n\n// sll dist[N_MAX];\n// struct_b path[M_MAX * 2];\n\null a[N_MAX];\n// ull a[M_MAX];\n// sll a[N_MAX];\n// ull a[N_MAX][N_MAX];\n// sll a[N_MAX][N_MAX];\n// ull b[N_MAX];\n// ull b[M_MAX];\nsll b[N_MAX];\n// ull c[N_MAX];\n// sll c[M_MAX];\n// char c[N_MAX];\n// char s[N_MAX + 1];\n// char s[N_MAX + 1][N_MAX + 1];\n// char s[N_MAX + 1][M_MAX + 1];\n// char t[N_MAX + 1];\n\n// ull alphabets[26];\n// char alphabets[26];\n\n// ull dp[N_MAX + 1];\n// sll dp[N_MAX + 1];\n// ull dp[N_MAX + 1][N_MAX + 1];\n// sll dp[N_MAX + 1][N_MAX + 1];\n// bool dp[N_MAX + 1];\n// bool dp[N_MAX + 1][N_MAX + 1];\n// hwll arr[N_MAX];\n// hwll arr[M_MAX];\n\n// typedef tuple<sll, int32_t, int32_t> P2d;\n\n// sll dist1[N_MAX];\n// sll dist2[N_MAX];\n// ull ways1[N_MAX];\n// ull ways2[N_MAX];\n\n\n\ndouble distance (sll x1, sll y1, sll x2, sll y2) {\n\tdouble xdist2, ydist2, origindist, dist;\n\n\txdist2 = (x1 - x2) * (x1 - x2);\n\tydist2 = (y1 - y2) * (y1 - y2);\n\treturn sqrt(xdist2 + ydist2);\n}\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\null solve () {\n\tsll i, j, ki, l;\n\t// ull result = 0;\n\tsll result = 0;\n\t// double result = 0;\n\tull maybe = 0;\n\t// sll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tull item;\n\tull *dpcell;\n\t// 比較関数ぐらい即席で書け\n\n\tull fixednim = 0;\n\n\tull allbit = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tallbit |= a[i];\n\t}\n\t\n\tull nowbit = 1;\n\twhile (nowbit * 2 <= allbit) nowbit *= 2;\n\n\twhile (nowbit) {\n\t\tqsort(a, n - result, sizeof(ull), pullcomp);\n\n\t\tull xorsum = 0;\n\t\tsll justindex = -1;\n\t\tfor (i = (n - result) - 1; i >= 0; i--) {\n\t\t\tif (a[i] < nowbit) break;\n\t\t\txorsum++;\n\t\t\tif (a[i] == nowbit) justindex = i;\n\t\t}\n\t\tif (fixednim & nowbit) xorsum++;\n\n\t\tif (xorsum % 2) {\n\t\t\tif (justindex < 0) goto fail;\n\n\t\t\tfixednim ^= (a[justindex] - 1);\n\t\t\tresult++;\n\n\t\t\ta[justindex] = a[n - result];\n\t\t}\n\n\t\tfor (i = (n - result) - 1; i >= 0; i--) {\n\t\t\tif (a[i] < nowbit) break;\n\t\t\ta[i] %= nowbit;\n\t\t}\n\n\t\tnowbit /= 2;\n\t}\n\n\tprintf(\"%llu\\n\", result);\n\t// printf(\"%.12lf\\n\", (double)result);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\tputs(\"CONTINUE\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"GAMEOVER\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\t// scanf(\"%lf%lf\", &vda, &vdb);\n\t// scanf(\"%lld%lld%lld%lld\", &vsa, &vsb, &vsc, &vsd);\n\t// scanf(\"%llu%llu\", &vua, &vub, &vuc, &vud);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%*llu\");\n\t// scanf(\"%llu\", &k, &m, &n);\n\t// scanf(\"%llu%llu\", &vua, &vub, &vuc, &vud, &vue, &vuf);\n\t// scanf(\"%lld\", &vsa, &vsb, &vsc);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%llu\", &k);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%llu\", &a[i]);\n\t\t// a[i]--;\n\t}\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &b[i]);\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%llu\", &a[i]);\n\t// }\n\n\t// for (i = 0; i < w; i++) {\n\t// \tscanf(\"%llu\", &b[i]);\n\t// }\t\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%llu\", &b[i]);\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// scanf(\"%llu\", &c[i]);\n\t// \t// arr[i].a--;\n\t// \t// arr[i].b--;\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu%llu\", &arr[i].a, &arr[i].b);\n\t// \t// arr[i].a--;\n\t// \t// arr[i].b--;\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < n; j++) {\n\t// \t\tscanf(\"%lld\", &a[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu%llu%llu\", &a[i], &b[i], &c[i]);\n\t// }\n\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%llu\", &k);\n\t// k--;\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%llu%llu\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// \t// solve();\n\t// }\n\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%llu%llu\", &arr[i].a, &arr[i].b);\n\t// \tarr[i].a--;\n\t// \tarr[i].b--;\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%llu\", &a[i][j]);\n\t// \t\ta[i][j]--;\n\t// \t}\n\t// }\n\n\tsolve();\n\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%llu%llu%llu\", &vua, &vub, &vuc);\n\t// \t// scanf(\"%s%s\", s, t);\n\t// \t// scanf(\"%f%f%f\", &vda, &vdb, &vdc);\n\t// \t// scanf(\"%s\", s);\n\t// \tsolve();\n\t// }\n\n\t// while (scanf(\"%llu%llu\", &n, &k), n + k) {\n\t// \tfor (i = 0; i < n; i++) {\n\t// \t\tscanf(\"%llu\", &a[i]);\n\t// \t}\n\t// \tsolve();\n\t// }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "int check[30];\n\nint c, n, a;\n\nint main() {\n  n = 0;\n  while (1) {\n    c = getchar_unlocked();\n    if ('0' <= c && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      break;\n  }\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if ('0' <= c && c <= '9')\n        a = a * 10 + c - '0';\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "int check[30];\n\nint c, n, a;\n\nint main() {\n\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  n = 0;\n  while (1) {\n    c = getchar_unlocked();\n    if ('0' <= c && c <= '9')\n      n = n * 10 + c - '0';\n    else\n      break;\n  }\n\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if ('0' <= c && c <= '9')\n        a = a * 10 + c - '0';\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "int check[30];\n\nint c, n, a;\n\nint main() {\n\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  for (int i = 0; i < n; i++) {\n    while (1) {\n      c = getchar_unlocked();\n      if ('0' <= c && c <= '9')\n        a = a * 10 + c - '0';\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "c,i=30,k[30],x;main(n,a)\n{\n\tfor(;~scanf(\"%d\",&a);)\n\t{\n\t\tk[__builtin_popcount(a^a-1)]=--n&&(x^=a);\n\t}\n\tfor(;i--;)x&1<<i&&k[i+1]&&(c++,x^=(1<<i+1)-1);\n\tprintf(\"%d\",x?-1:c);\n}"
  },
  {
    "language": "C",
    "code": "c,i=30,k[30],x;main(n,a)\n{\n\tfor(;~scanf(\"%d\",&a);)\n\t{\n\t\tk[__builtin_popcount(a^a-1)]=--n&&(x^=a);\n\t}\n\tfor(;i;i--)x&1<<i-1&&k[i]&&(c++,x^=(1<<i)-1);\n\tprintf(\"%d\",x?-1:c);\n}"
  },
  {
    "language": "C",
    "code": "int check[30];\n\nint main() {\n\n  for (int bit = 29; bit >= 0; bit--) {\n    check[bit] = 0;\n  }\n\n  int n;\n  scanf(\"%d\", &n);\n  int xor_sum = 0;\n  int a;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a);\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    switch (a) {\n    case 1073741823:\n      check[29] = 1;\n      break;\n    case 536870911:\n      check[28] = 1;\n      break;\n    case 268435455:\n      check[27] = 1;\n      break;\n    case 134217727:\n      check[26] = 1;\n      break;\n    case 67108863:\n      check[25] = 1;\n      break;\n    case 33554431:\n      check[24] = 1;\n      break;\n    case 16777215:\n      check[23] = 1;\n      break;\n    case 8388607:\n      check[22] = 1;\n      break;\n    case 4194303:\n      check[21] = 1;\n      break;\n    case 2097151:\n      check[20] = 1;\n      break;\n    case 1048575:\n      check[19] = 1;\n      break;\n    case 524287:\n      check[18] = 1;\n      break;\n    case 262143:\n      check[17] = 1;\n      break;\n    case 131071:\n      check[16] = 1;\n      break;\n    case 65535:\n      check[15] = 1;\n      break;\n    case 32767:\n      check[14] = 1;\n      break;\n    case 16383:\n      check[13] = 1;\n      break;\n    case 8191:\n      check[12] = 1;\n      break;\n    case 4095:\n      check[11] = 1;\n      break;\n    case 2047:\n      check[10] = 1;\n      break;\n    case 1023:\n      check[9] = 1;\n      break;\n    case 511:\n      check[8] = 1;\n      break;\n    case 255:\n      check[7] = 1;\n      break;\n    case 127:\n      check[6] = 1;\n      break;\n    case 63:\n      check[5] = 1;\n      break;\n    case 31:\n      check[4] = 1;\n      break;\n    case 15:\n      check[3] = 1;\n      break;\n    case 7:\n      check[2] = 1;\n      break;\n    case 3:\n      check[1] = 1;\n      break;\n    case 1:\n      check[0] = 1;\n      break;\n    }\n  }\n\n  int ans = 0;\n  for (int bit = 29; bit >= 0; bit--) {\n    if (((1 << bit) & xor_sum) == 0) {\n      continue;\n    }\n    int x = (1 << (bit + 1)) - 1;\n\n    if (check[bit] > 0) {\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  if (xor_sum != 0) {\n    printf(\"-1\\n\");\n  } else {\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C",
    "code": "check[30], c, n, a, xor_sum, A, B, i;\nmain() {\n  while (1) {\n    c = getchar_unlocked();\n    if (48 <= c && c <= 57)\n      n = n * 10 + c - 48;\n    else\n      break;\n  }\n\n  for (i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if (48 <= c && c <= 57)\n        a = a * 10 + c - 48;\n      else\n        break;\n    }\n    xor_sum ^= a;\n    check[__builtin_popcount(a ^ (a - 1)) - 1] = 1;\n  }\n\n  for (B = 29; B >= 0; B--)\n    if (check[B] && ((1 << B) & xor_sum))\n      xor_sum ^= (1 << (B + 1)) - 1, A++;\n\n  printf(\"%d\\n\", xor_sum ? -1 : A);\n}"
  },
  {
    "language": "C",
    "code": "c,i=30,k[30],x;main(n,a)\n{\n\tfor(;~scanf(\"%d\",&a);)\n\t{\n\t\t--n&&(x^=a,k[__builtin_popcount(a^a-1)]=1);\n\t}\n\tfor(;i--;)x&1<<i&&k[i+1]&&(c++,x^=(1<<i+1)-1);\n\tprintf(\"%d\",x?-1:c);\n}"
  },
  {
    "language": "C",
    "code": "check[30], c, n, a, xor_sum, ans, bit, i;\nint main() {\n  while (1) {\n    c = getchar_unlocked();\n    if (48 <= c && c <= 57)\n      n = n * 10 + c - 48;\n    else\n      break;\n  }\n\n  for (i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if (48 <= c && c <= 57)\n        a = a * 10 + c - 48;\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    check[__builtin_popcount(a) - 1] = 1;\n  }\n\n  for (bit = 29; bit >= 0; bit--) {\n    if (check[bit] && ((1 << bit) & xor_sum)) {\n      xor_sum ^= (1 << (bit + 1)) - 1;\n      ans += 1;\n    }\n  }\n\n  printf(\"%d\\n\", xor_sum ? -1 : ans);\n}"
  },
  {
    "language": "C",
    "code": "check[30], c, n, a, xor_sum, ans;\nint main() {\n  while (1) {\n    c = getchar_unlocked();\n    if (48 <= c && c <= 57)\n      n = n * 10 + c - 48;\n    else\n      break;\n  }\n\n  for (int i = 0; i < n; i++) {\n    a = 0;\n    while (1) {\n      c = getchar_unlocked();\n      if (48 <= c && c <= 57)\n        a = a * 10 + c - 48;\n      else\n        break;\n    }\n    xor_sum ^= a;\n    a = a ^ (a - 1);\n\n    check[__builtin_popcount(a) - 1] = 1;\n  }\n\n  for (int bit = 29; bit >= 0; bit--) {\n    if (check[bit] && ((1 << bit) & xor_sum)) {\n      int x = (1 << (bit + 1)) - 1;\n      xor_sum ^= x;\n      ans += 1;\n    }\n  }\n\n  printf(\"%d\\n\", xor_sum ? -1 : ans);\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\n\t\tList<Integer> a = new ArrayList<>(n);\n\t\tint xor = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmp = sc.nextInt();\n\t\t\ta.add(tmp);\n\t\t\txor ^= tmp;\n\t\t}\n\n\t\tint ans = 0;\n\t\tout:\n\t\twhile (Integer.highestOneBit(xor) > 0) {\n\t\t\tint tmp = Integer.highestOneBit(xor);\n\t\t\tint mask = (tmp << 1) - 1;\n\n\t\t\tfor (int i = 0, size = a.size(); i < size; i++) {\n\t\t\t\tif ((a.get(i) & mask) == tmp) {\n\t\t\t\t\ta.remove(i);\n\t\t\t\t\txor ^= mask;\n\t\t\t\t\tans++;\n\t\t\t\t\tcontinue out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpr.println(-1);\n\t\t\treturn;\n\t\t}\n\n\t\tpr.println(ans);\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\n\t\tsolve();\n\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Printer extends PrintWriter {\n\t\tPrinter(PrintStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long MOD = 1_000_000_007;\n    int inf = Integer.MAX_VALUE;\n\n    void solve(){\n        int n = ni();\n        int[] d = new int[50];\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            long a = nl();\n            ans ^= a;\n            int res = 0;\n            while(a>0){\n                if(a%2==1) break;\n                a = a/2;\n                res++;\n            }\n            d[res]++;\n        }\n        int[] m = new int[50];\n        int r = 0;\n        while(ans>0){\n            if(ans%2==1) m[r] = 1;\n            else m[r] = 0;\n            ans /= 2;\n            r++;\n        }\n        int target = 1;\n        int count = 0;\n        for(int i = 0; i < r; i++){\n            // out.println(m[i]);\n            if(m[i]==target){\n                count++;\n                if(d[r-1-i]>0) d[r-1-i]--;\n                else{\n                    out.println(-1);\n                    return;\n                }\n                target = 1 - target;\n            }\n        }\n        out.println(count);\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\nclass Main {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n=sc.nextInt();\n        long[]a=new long[n];\n        long x=0;\n        int[]c=new int[31];\n        for(int i=0;i<n;++i){\n            a[i]=sc.nextLong();\n            x^=a[i];\n            c[Long.bitCount((a[i]&-a[i])-1)]++;\n        }\n        int ans=0;\n        for(int i=30;i>=0;--i)\n            if((x&1<<i)!=0)\n                if(c[i]>0){\n                    x^=(1<<(i+1))-1;\n                    ans++;\n                }else\n                    break;\n        out.println(x==0?ans:-1);\n        out.close();\n    }\n    // http://codeforces.com/blog/entry/7018\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package other2016.codefestival2016.grandfinal;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n\n        int n = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n ; i++) {\n            a[i] = in.nextInt();\n        }\n\n\n        int xor = 0;\n        int mask = (1<<30)-1;\n\n        int[] s = new int[n];\n        int[] cnt = new int[35];\n        for (int i = 0; i < n ; i++) {\n            int L = a[i] ^ (a[i]-1);\n            int ma = (mask&(~L)) & a[i];\n            xor ^= ma;\n            s[i] = a[i] & L;\n            int ss = s[i];\n            int co = 0;\n            while (ss >= 2) {\n                ss /= 2;\n                co++;\n            }\n            cnt[co]++;\n        }\n\n        // debug(xor, cnt);\n\n        long cost = 0;\n        int flg = 0;\n        for (int i = 30 ; i >= 0 ; i--) {\n            int f = ((1<<i) & xor) >= 1 ? 1 : 0;\n            f ^= flg;\n            if (f == 0) {\n                if (cnt[i] % 2 == 0) {\n                } else {\n                    cost++;\n                    flg ^= 1;\n                }\n            } else {\n                if (cnt[i] == 0) {\n                    cost += n+10;\n                } else {\n                    cnt[i]--;\n                    if (cnt[i] % 2 == 0) {\n                    } else {\n                        cost++;\n                        flg ^= 1;\n                    }\n                }\n            }\n        }\n\n        out.println(cost >= n+1 ? -1 : cost);\n        out.flush();\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint xor = 0;\n\t\tboolean[] have = new boolean[1 << 20];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = in.nextInt();\n\t\t\txor ^= x;\n\t\t\thave[x ^ (x - 1)] = true;\n\t\t}\n\t\tArrayList<Integer> all = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < have.length; i++) {\n\t\t\tif (have[i]) {\n\t\t\t\tall.add(i);\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor (int mask = 0; mask < 1 << all.size(); mask++) {\n\t\t\tint nxor = 0;\n\t\t\tfor (int i = 0; i < all.size(); i++) {\n\t\t\t\tif (((1 << i) & mask) != 0) {\n\t\t\t\t\tnxor ^= all.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nxor == xor) {\n\t\t\t\tint tmp = Integer.bitCount(mask);\n\t\t\t\tif (tmp < res) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(res == Integer.MAX_VALUE ? -1 : res);\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"object.in\"));\n\t\t\tout = new PrintWriter(new File(\"object.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew Main().runIO();\n\t\t\t}\n\t\t}, \"1\", 1 << 26).start();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long MOD = 1_000_000_007;\n    int inf = Integer.MAX_VALUE;\n\n    void solve(){\n        int n = ni();\n        int[] d = new int[50];\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            long a = nl();\n            ans ^= a;\n            int res = 0;\n            while(a>0){\n                if(a%2==1) break;\n                a = a/2;\n                res++;\n            }\n            d[res]++;\n            // out.println(res);\n        }\n        int[] m = new int[50];\n        int r = 0;\n        while(ans>0){\n            if(ans%2==1) m[r] = 1;\n            else m[r] = 0;\n            ans /= 2;\n            r++;\n        }\n        int target = 1;\n        int count = 0;\n        for(int i = 0; i < r; i++){\n            // out.println(m[r-1-i]);\n            if(m[r-1-i]==target){\n                count++;\n                if(d[r-1-i]>0) d[r-1-i]--;\n                else{\n                    out.println(-1);\n                    return;\n                }\n                target = 1 - target;\n            }\n        }\n        out.println(count);\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    long MOD = 1_000_000_007;\n    int inf = Integer.MAX_VALUE;\n\n    void solve(){\n        int n = ni();\n        int[] d = new int[50];\n        long ans = 0;\n        for(int i = 0; i < n; i++){\n            long a = nl();\n            ans ^= a;\n            a ^= a-1;\n            int res = Long.bitCount(a)-1;\n            d[res]++;\n            // out.println(res);\n        }\n        int[] m = new int[50];\n        int r = 0;\n        while(ans>0){\n            if(ans%2==1) m[r] = 1;\n            else m[r] = 0;\n            ans /= 2;\n            r++;\n        }\n        int target = 1;\n        int count = 0;\n        for(int i = 0; i < r; i++){\n            // out.println(m[r-1-i]);\n            if(m[r-1-i]==target){\n                count++;\n                if(d[r-1-i]>0) d[r-1-i]--;\n                else{\n                    out.println(-1);\n                    return;\n                }\n                target = 1 - target;\n            }\n        }\n        out.println(count);\n    }\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        \n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint xor = 0;\n\t\tTreeSet<Integer> hs = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = in.nextInt();\n\t\t\txor ^= x;\n\t\t\ths.add(x ^ (x - 1));\n\t\t}\n\t\tArrayList<Integer> all = new ArrayList<Integer>();\n\t\tfor (int x : hs) {\n\t\t\tall.add(x);\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = all.size() - 1; i >= 0; i--) {\n\t\t\tint cur = all.get(i);\n\t\t\tint maxBit = (cur + 1) >> 1;\n\t\t\tif (0 != (xor & maxBit)) {\n\t\t\t\tres++;\n\t\t\t\txor ^= cur;\n\t\t\t}\n\t\t}\n\t\tout.println(xor != 0 ? -1 : res);\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"object.in\"));\n\t\t\tout = new PrintWriter(new File(\"object.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tnew Main().runIO();\n\t\t\t}\n\t\t}, \"1\", 1 << 26).start();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Globalization;\nusing System.Diagnostics;\n\n\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n    \n\n    Scanner cin;\n\n\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        int[] A = cin.ArrayInt(N);\n\n        int xor = 0;\n        foreach (var item in A)\n        {\n            xor ^= item;\n        }\n\n        int[] num = new int[40];\n        foreach (var item in A)\n        {\n            num[getLeftPos(item)]++;\n        }\n\n        int ans = 0;\n        for (int i = 31 - 1; i >= 0; i--)\n        {\n            if ((xor >> i) % 2 == 0) continue;\n            ans++;\n            if(num[i] == 0)\n            {\n                Console.WriteLine(-1);\n                return;\n            }\n            xor ^= (1 << (i + 1)) - 1;\n        }\n        Console.WriteLine(ans);\n    }\n\n    int getLeftPos(int a)\n    {\n        for (int i = 0; i < 40; i++)\n        {\n            if ((a >> i) % 2 == 1) return i;\n        }\n        return -1;\n    }\n}\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}"
  },
  {
    "language": "Perl",
    "code": "<>;$x&$_ and$x^=$_,$%++for sort{$b-$a}map{$x^=0+$_;$_^$_-1}<>;print$x?-1:$%"
  },
  {
    "language": "Perl",
    "code": "<>;\n!$h{$_}++&&$x&$_+1>>1&&($c++,$x^=$_)for sort{$b-$a}map{$x^=$_;$_^$_-1}<>;\nprint$x>0?-1:$c"
  },
  {
    "language": "Perl",
    "code": "<>;$%&$_+1>>1and$%^=$_,$-++for sort{$b-$a}map{$%^=$_;$_^$_-1}<>;print$%?-1:$-"
  },
  {
    "language": "Perl",
    "code": "<>;$%&$_+1>>1and$%^=$_,$c++for sort{$b-$a}map{$%^=$_;$_^$_-1}<>;print$%?-1:$c"
  },
  {
    "language": "Perl",
    "code": "<>;\n!$h{$_}++&&$x&($_+1>>1)&&($%++,$x^=$_)for sort{$b-$a}map{$x^=$_;$_^$_-1}<>;\nprint$x?-1:$%"
  },
  {
    "language": "Perl",
    "code": "<>;\n!$h{$_}++&&$x&$_+1>>1&&($%++,$x^=$_)for sort{$b-$a}map{$x^=$_;$_^$_-1}<>;\nprint$x?-1:$%"
  },
  {
    "language": "Perl",
    "code": "<>;\n$x&$_+1>>1&&($%++,$x^=$_)for sort{$b-$a}map{$x^=0+$_;$_^$_-1}<>;\nprint$x?-1:$%"
  },
  {
    "language": "Perl",
    "code": "<>;\n$x&$_+1>>1&&($c++,$x^=$_)for sort{$b-$a}map{$x^=$_;$_^$_-1}<>;\nprint$x?-1:$c"
  },
  {
    "language": "Perl",
    "code": "<>;\n!$h{$_}++&&$x&$_+1>>1&&($%++,$x^=$_)for sort{$b-$a}map{$x^=0+$_;$_^$_-1}<>;\nprint$x?-1:$%"
  },
  {
    "language": "Perl",
    "code": "<>;$x&$_+1>>1and$x^=$_,$%++for sort{$b-$a}map{$x^=0+$_;$_^$_-1}<>;print$x?-1:$%"
  },
  {
    "language": "Perl",
    "code": "<>;\n!$h{$_}++&&$x&$_+1>>1&&($c++,$x^=$_)for sort{$b-$a}map{$x^=$_;$_^$_-1}<>;\nprint$x?-1:$c"
  },
  {
    "language": "Perl",
    "code": "<>;$x^=$_ for@_=<>;for$i(sort{1}1..30){$x^=2**$i-1,$c++if$x>>$i-1&1&&grep+($_^$_-1)==2**$i-1,@_}print$x?-1:$c"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\nint n; cin >> n; vector<int>v(n); for(int &b : v) cin >> b; int s = 0; for(int b : v) s ^= b; int sc = 0; for(int b : v) sc ^= (b - 1); if(s == 0) { cout << \"0\" << endl; } else if(sc == 0) { cout << n << endl; } else cout << \"-1\" << endl; }"
  },
  {
    "language": "Python",
    "code": "from collections import Counter, defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10)\ninput = sys.stdin.readline\nfrom math import factorial\nimport heapq, bisect\nimport math\nimport itertools\n\n\nimport queue\nfrom collections import deque\n\n\ndef main():\n    num = int(input())\n    now_num = 0\n    for i in range(num):\n        a = int(input())\n        now_num ^= a\n\n    now_num = bin(now_num)[2:]\n    now_num = list(now_num)\n    now_num = list(map(int, now_num))\n\n    # print(now_num)\n\n    ans = 0\n    taberu = 0\n    for ele in now_num:\n        if ele ^ taberu:\n            taberu ^= 1\n            ans += 1\n\n    if ans > num:\n        print(-1)\n    else:\n        print(ans)\n\n\n\n\nif __name__ == '__main__':\n    main()\n    # test()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter, defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10)\n# input = sys.stdin.readline\nfrom math import factorial\nimport heapq, bisect\nimport math\nimport itertools\n\n\nimport queue\nfrom collections import deque\n\n\ndef main():\n    num = int(input())\n    now_num = 0\n    for i in range(num):\n        a = int(input())\n        now_num ^= a\n\n    now_num = bin(now_num)[2:]\n    now_num = list(now_num)\n    now_num = list(map(int, now_num))\n\n    # print(now_num)\n\n    ans = 0\n    taberu = 0\n    for ele in now_num:\n        if ele ^ taberu:\n            taberu ^= 1\n            ans += 1\n\n    if num == 1:\n        print(0)\n    elif ans > num:\n        print(-1)\n    else:\n        print(ans)\n\n\n\n\nif __name__ == '__main__':\n    main()\n    # test()\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    a = sorted([I() for _ in range(n)])\n    d = collections.defaultdict(lambda: inf)\n    x = 0\n    for c in a:\n        x ^= c\n    d[x] = 0\n    for c in a:\n        c1 = c ^ (c-1)\n        e = {}\n        for k,v in list(d.items()):\n            if d[k^c1] > v + 1:\n                e[k^c1] = v + 1\n        for k,v in e.items():\n            d[k] = v\n\n    if d[0] == inf:\n        return -1\n\n    return d[0]\n\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nn = int(stdin.readline())\na = map(int,stdin.readline().split(' '))\nxs = 0\noc = 0\nfor x in a:\n   xs ^= x >> 1\n   oc ^= x & 1\n\nif xs:\n   print -1\nelse:\n   print oc"
  },
  {
    "language": "Python",
    "code": "from collections import Counter, defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 5 + 10)\ninput = sys.stdin.readline\nfrom math import factorial\nimport heapq, bisect\nimport math\nimport itertools\n\n\nimport queue\nfrom collections import deque\n\n\ndef main():\n    num = int(input())\n    data = [int(input()) for i in range(num)]\n    now_num = 0\n    for i in range(num):\n        a = data[i]\n        now_num ^= a\n\n    now_num = bin(now_num)[2:]\n    now_num = list(now_num)\n    now_num = list(map(int, now_num))\n\n    # print(now_num)\n\n    delete_list = [0 for i in range(len(now_num))]\n    for i in range(num):\n        bin_data = bin(data[i])[2:][::-1]\n\n        for j in range(min(len(bin_data), len(now_num))):\n            # print(data[j])\n            if bin_data[j] == '1':\n                delete_list[j] = 1\n                break\n\n    delete_list = delete_list[::-1]\n\n    # print(now_num)\n    # print(delete_list)\n\n    ans = 0\n    taberu = 0\n    for i in range(len(now_num)):\n        ele = now_num[i]\n        if ele ^ taberu:\n            if delete_list[i]:\n                taberu ^= 1\n                ans += 1\n            else:\n                print(-1)\n                sys.exit()\n\n\n    if ans > num or num == 1:\n        print(-1)\n    else:\n        print(ans)\n\n\n\n\nif __name__ == '__main__':\n    main()\n    # test()\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    a = sorted([I() for _ in range(n)])\n    x = 0\n    for c in a:\n        x ^= c\n    s = set()\n    for c in a:\n        s.add(c ^ (c-1))\n\n    r = 0\n    for c in sorted(s, reverse=True):\n        cb = bin(c)\n        xb = bin(x)\n        if len(cb) == len(xb) and x > 0:\n            x ^= c\n            r += 1\n\n    if x != 0:\n        return -1\n\n    return r\n\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let mut sc = Scanner::new();\n    let n: usize = sc.read();\n    let a: Vec<u32> = (0..n).map(|_| sc.read()).collect();\n\n\n    let mut xor_sum = 0;\n    for &a in &a {\n        xor_sum ^= a;\n    }\n\n    let mut ans = 0;\n    for bit in (0..30).rev() {\n        if ((1 << bit) & xor_sum) == 0 { continue; }\n        let x = (1 << (bit + 1)) - 1;\n        for &a in &a {\n            let y = a ^ (a - 1);\n            if y == x {\n                xor_sum ^= y;\n                ans += 1;\n                break;\n            }\n        }\n    }\n\n    if xor_sum != 0 {\n        println!(\"-1\");\n    } else {\n        println!(\"{}\", ans);\n    }\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner { ptr: 0, length: 0, buf: vec![0; 1024], small_cache: vec![0; 1024] }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool { b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' ' }\n\n    fn read<T>(&mut self) -> T where T: std::str::FromStr, T::Err: std::fmt::Debug, {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)]).parse().unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn solve() {\n    let n = get();\n    let a: Vec<i64> = (0 .. n).map(|_| get()).collect();\n    let mut goal = a.iter().fold(0, |x, &y| x ^ y);\n    const B: usize = 32;\n    let mut cnt = [0; B];\n    for v in a {\n        if v == 0 { continue; }\n        let diff = (v ^ (v - 1)).count_ones() as usize - 1;\n        cnt[diff] += 1;\n    }\n    let mut tot = 0;\n    for i in (0 .. B).rev() {\n        if (goal & 1 << i) == 0 { continue; }\n        if cnt[i] == 0 { // impossible\n            println!(\"-1\");\n            return;\n        }\n        goal ^= (1 << (i + 1)) - 1;\n        tot += 1;\n    }\n    println!(\"{}\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_macros, unknown_lints)]\n\nuse std::collections::*;\nuse std::cmp::Ordering::*;\n\nmacro_rules! dump {($($e:expr), +) => {print!(concat!($(stringify!($e), \" = {:?}\\n\"), +), $($e), +)}}\nmacro_rules! max {($e0:expr, $($e:expr), +) => {{let mut r = $e0; $(r = std::cmp::max(r, $e);)+ r}}}\nmacro_rules! min {($e0:expr, $($e:expr), +) => {{let mut r = $e0; $(r = std::cmp::min(r, $e);)+ r}}}\n\nfn main() {\n  let n = get::val::<usize>();\n  let xs = get::vals::<usize>(n);\n\n  let mut xor = xs.iter().fold(0,|a,&x|a^x);\n  let mut ds = vec![0;29+1];\n  \n  for x in xs {\n    for k in 1 .. 29+1 {\n      if x^(x-1) == (1<<k)-1 {\n        ds[k] += 1\n      }\n    }\n  }\n  \n  let mut ans = 0;\n  for k in (1..29+1).rev() {\n    if (1<<(k-1)) & xor != 0 && ds[k] != 0 {\n      ans += 1;\n      xor ^= (1<<k)-1;\n      ds[k] -= 1\n    }\n  }\n  \n  if xor == 0 {\n    println!(\"{}\", ans)\n  } else {\n    println!(\"-1\")\n  }\n}\n\n#[allow(dead_code)]\nmod get {\n  use std::io::*;\n  use std::str::*;\n  use std::process::*;\n\n  pub fn val<T: FromStr>() -> T {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().parse::<T>().ok().unwrap()\n  }\n\n  pub fn vals<T: FromStr>(n: usize) -> Vec<T> {\n    let mut vec: Vec<T> = vec![];\n    for _ in 0 .. n {\n      vec.push(val());\n    }\n    vec\n  }\n\n  pub fn tuple<T1: FromStr, T2: FromStr>() -> (T1, T2) {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    let mut it = buf.trim_right().split_whitespace();\n    let x = it.next().unwrap().parse::<T1>().ok().unwrap();\n    let y = it.next().unwrap().parse::<T2>().ok().unwrap();\n    (x, y)\n  }\n\n  pub fn tuples<T1: FromStr, T2: FromStr>(n: usize) -> Vec<(T1, T2)> {\n    let mut vec: Vec<(T1, T2)> = vec![];\n    for _ in 0 .. n {\n      vec.push(tuple());\n    }\n    vec\n  }\n\n  pub fn tuple3<T1: FromStr, T2: FromStr, T3: FromStr>() -> (T1, T2, T3) {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    let mut it = buf.trim_right().split_whitespace();\n    let x = it.next().unwrap().parse::<T1>().ok().unwrap();\n    let y = it.next().unwrap().parse::<T2>().ok().unwrap();\n    let z = it.next().unwrap().parse::<T3>().ok().unwrap();\n    (x, y, z)\n  }\n\n  pub fn tuple3s<T1: FromStr, T2: FromStr, T3: FromStr>(n: usize) -> Vec<(T1, T2, T3)> {\n    let mut vec: Vec<(T1, T2, T3)> = vec![];\n    for _ in 0 .. n {\n      vec.push(tuple3());\n    }\n    vec\n  }\n\n  pub fn vec<T: FromStr>() -> Vec<T> {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().split_whitespace().map(|t| t.parse::<T>().ok().unwrap()).collect()\n  }\n\n  pub fn mat<T: FromStr>(h: usize) -> Vec<Vec<T>> {\n    let mut mat = vec![];\n    for _ in 0 .. h {\n      mat.push(vec());\n    }\n    mat\n  }\n\n  pub fn chars() -> Vec<char> {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().chars().collect()\n  }\n}\n\n#[allow(dead_code)]\nmod put {\n  use std::string::*;\n\n  pub fn vec<T: ToString>(vec: &[T], sep: &str) {\n    let out = vec.iter().map(|e| e.to_string()).collect::<Vec<_>>().as_slice().join(sep);\n    println!(\"{}\", out);\n  }\n\n  pub fn mat<T: ToString>(mat: &Vec<Vec<T>>, sep: &str) {\n    for v in mat {\n      vec(v, sep);\n    }\n  }\n}"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let mut sc = Scanner::new();\n    let n: usize = sc.read();\n    let a: Vec<u64> = (0..n).map(|_| sc.read()).collect();\n\n    let mut grundy = 0;\n    for &a in &a {\n        grundy ^= a;\n    }\n\n    let mut used = vec![false; n];\n    for pos in (0..32).rev() {\n        if grundy & (1 << pos) == 0 {\n            continue;\n        }\n        for i in 0..n {\n            if used[i] {\n                continue;\n            }\n\n            let tmp = a[i] ^ (a[i] - 1);\n            let check = (1 << (pos + 1)) - 1;\n            if tmp == check {\n                grundy ^= tmp;\n                used[i] = true;\n                break;\n            }\n        }\n    }\n\n    if grundy == 0 {\n        println!(\n            \"{}\",\n            used.iter().map(|&b| if b { 1 } else { 0 }).sum::<usize>()\n        );\n    } else {\n        println!(\"-1\");\n    }\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_macros, unknown_lints)]\n\nuse std::collections::*;\nuse std::cmp::Ordering::*;\n\nmacro_rules! dump {($($e:expr), +) => {print!(concat!($(stringify!($e), \" = {:?}\\n\"), +), $($e), +)}}\nmacro_rules! max {($e0:expr, $($e:expr), +) => {{let mut r = $e0; $(r = std::cmp::max(r, $e);)+ r}}}\nmacro_rules! min {($e0:expr, $($e:expr), +) => {{let mut r = $e0; $(r = std::cmp::min(r, $e);)+ r}}}\n\nfn main() {\n  let n = get::val::<usize>();\n  let xs = get::vals::<usize>(n);\n\n  let mut xor = xs.iter().fold(0,|a,&x|a^x);\n  let mut ds = vec![false; 29+1];\n  \n  for x in xs {\n    for k in 1 .. 29+1 {\n      if x^(x-1) == (1<<k)-1 {\n        ds[k] = true\n      }\n    }\n  }\n  \n  // dump!(xor,ds);\n  \n  let mut ans = 0;\n  for k in (1..29+1).rev() {\n    if (1<<(k-1)) & xor != 0 && ds[k] {\n      ans += 1;\n      xor ^= (1<<k)-1;\n    }\n  }\n  \n  if xor == 0 {\n    println!(\"{}\", ans)\n  } else {\n    println!(\"-1\")\n  }\n}\n\n#[allow(dead_code)]\nmod get {\n  use std::io::*;\n  use std::str::*;\n  use std::process::*;\n\n  pub fn val<T: FromStr>() -> T {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().parse::<T>().ok().unwrap()\n  }\n\n  pub fn vals<T: FromStr>(n: usize) -> Vec<T> {\n    let mut vec: Vec<T> = vec![];\n    for _ in 0 .. n {\n      vec.push(val());\n    }\n    vec\n  }\n\n  pub fn tuple<T1: FromStr, T2: FromStr>() -> (T1, T2) {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    let mut it = buf.trim_right().split_whitespace();\n    let x = it.next().unwrap().parse::<T1>().ok().unwrap();\n    let y = it.next().unwrap().parse::<T2>().ok().unwrap();\n    (x, y)\n  }\n\n  pub fn tuples<T1: FromStr, T2: FromStr>(n: usize) -> Vec<(T1, T2)> {\n    let mut vec: Vec<(T1, T2)> = vec![];\n    for _ in 0 .. n {\n      vec.push(tuple());\n    }\n    vec\n  }\n\n  pub fn tuple3<T1: FromStr, T2: FromStr, T3: FromStr>() -> (T1, T2, T3) {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    let mut it = buf.trim_right().split_whitespace();\n    let x = it.next().unwrap().parse::<T1>().ok().unwrap();\n    let y = it.next().unwrap().parse::<T2>().ok().unwrap();\n    let z = it.next().unwrap().parse::<T3>().ok().unwrap();\n    (x, y, z)\n  }\n\n  pub fn tuple3s<T1: FromStr, T2: FromStr, T3: FromStr>(n: usize) -> Vec<(T1, T2, T3)> {\n    let mut vec: Vec<(T1, T2, T3)> = vec![];\n    for _ in 0 .. n {\n      vec.push(tuple3());\n    }\n    vec\n  }\n\n  pub fn vec<T: FromStr>() -> Vec<T> {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().split_whitespace().map(|t| t.parse::<T>().ok().unwrap()).collect()\n  }\n\n  pub fn mat<T: FromStr>(h: usize) -> Vec<Vec<T>> {\n    let mut mat = vec![];\n    for _ in 0 .. h {\n      mat.push(vec());\n    }\n    mat\n  }\n\n  pub fn chars() -> Vec<char> {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().chars().collect()\n  }\n}\n\n#[allow(dead_code)]\nmod put {\n  use std::string::*;\n\n  pub fn vec<T: ToString>(vec: &[T], sep: &str) {\n    let out = vec.iter().map(|e| e.to_string()).collect::<Vec<_>>().as_slice().join(sep);\n    println!(\"{}\", out);\n  }\n\n  pub fn mat<T: ToString>(mat: &Vec<Vec<T>>, sep: &str) {\n    for v in mat {\n      vec(v, sep);\n    }\n  }\n}"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_macros, unknown_lints)]\n\nuse std::collections::*;\nuse std::cmp::Ordering::*;\n\nmacro_rules! dump {($($e:expr), +) => {print!(concat!($(stringify!($e), \" = {:?}\\n\"), +), $($e), +)}}\nmacro_rules! max {($e0:expr, $($e:expr), +) => {{let mut r = $e0; $(r = std::cmp::max(r, $e);)+ r}}}\nmacro_rules! min {($e0:expr, $($e:expr), +) => {{let mut r = $e0; $(r = std::cmp::min(r, $e);)+ r}}}\n\nfn main() {\n  let n = get::val::<usize>();\n  let xs = get::vals::<usize>(n);\n\n  let mut xor = xs.iter().fold(0,|a,&x|a^x);\n  let mut ds = vec![false; 30+1];\n  \n  for x in xs {\n    for k in 1 .. 30+1 {\n      if x^(x-1) == (1<<k)-1 {\n        ds[k] = true\n      }\n    }\n  }\n  \n  // dump!(xor,ds);\n  \n  let mut ans = 0;\n  for k in (1..30+1).rev() {\n    if (1<<(k-1)) & xor != 0 && ds[k] {\n      ans += 1;\n      xor ^= (1<<k)-1;\n    }\n  }\n  \n  if xor == 0 {\n    println!(\"{}\", ans)\n  } else {\n    println!(\"-1\")\n  }\n}\n\n#[allow(dead_code)]\nmod get {\n  use std::io::*;\n  use std::str::*;\n  use std::process::*;\n\n  pub fn val<T: FromStr>() -> T {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().parse::<T>().ok().unwrap()\n  }\n\n  pub fn vals<T: FromStr>(n: usize) -> Vec<T> {\n    let mut vec: Vec<T> = vec![];\n    for _ in 0 .. n {\n      vec.push(val());\n    }\n    vec\n  }\n\n  pub fn tuple<T1: FromStr, T2: FromStr>() -> (T1, T2) {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    let mut it = buf.trim_right().split_whitespace();\n    let x = it.next().unwrap().parse::<T1>().ok().unwrap();\n    let y = it.next().unwrap().parse::<T2>().ok().unwrap();\n    (x, y)\n  }\n\n  pub fn tuples<T1: FromStr, T2: FromStr>(n: usize) -> Vec<(T1, T2)> {\n    let mut vec: Vec<(T1, T2)> = vec![];\n    for _ in 0 .. n {\n      vec.push(tuple());\n    }\n    vec\n  }\n\n  pub fn tuple3<T1: FromStr, T2: FromStr, T3: FromStr>() -> (T1, T2, T3) {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    let mut it = buf.trim_right().split_whitespace();\n    let x = it.next().unwrap().parse::<T1>().ok().unwrap();\n    let y = it.next().unwrap().parse::<T2>().ok().unwrap();\n    let z = it.next().unwrap().parse::<T3>().ok().unwrap();\n    (x, y, z)\n  }\n\n  pub fn tuple3s<T1: FromStr, T2: FromStr, T3: FromStr>(n: usize) -> Vec<(T1, T2, T3)> {\n    let mut vec: Vec<(T1, T2, T3)> = vec![];\n    for _ in 0 .. n {\n      vec.push(tuple3());\n    }\n    vec\n  }\n\n  pub fn vec<T: FromStr>() -> Vec<T> {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().split_whitespace().map(|t| t.parse::<T>().ok().unwrap()).collect()\n  }\n\n  pub fn mat<T: FromStr>(h: usize) -> Vec<Vec<T>> {\n    let mut mat = vec![];\n    for _ in 0 .. h {\n      mat.push(vec());\n    }\n    mat\n  }\n\n  pub fn chars() -> Vec<char> {\n    let mut buf = String::new();\n    let s = stdin();\n    s.lock().read_line(&mut buf).ok();\n    if buf.is_empty() {println!(\"No input\"); exit(0)}\n    buf.trim_right().chars().collect()\n  }\n}\n\n#[allow(dead_code)]\nmod put {\n  use std::string::*;\n\n  pub fn vec<T: ToString>(vec: &[T], sep: &str) {\n    let out = vec.iter().map(|e| e.to_string()).collect::<Vec<_>>().as_slice().join(sep);\n    println!(\"{}\", out);\n  }\n\n  pub fn mat<T: ToString>(mat: &Vec<Vec<T>>, sep: &str) {\n    for v in mat {\n      vec(v, sep);\n    }\n  }\n}"
  }
]