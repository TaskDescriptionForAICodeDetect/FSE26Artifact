[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point a, b;\n} Line;\n\ndouble distance(Point p, Line l) {\n    double A = l.b.y - l.a.y;\n    double B = l.a.x - l.b.x;\n    double C = l.b.x * l.a.y - l.a.x * l.b.y;\n    return fabs(A * p.x + B * p.y + C) / sqrt(A * A + B * B);\n}\n\nPoint intersection(Line l1, Line l2) {\n    double A1 = l1.b.y - l1.a.y;\n    double B1 = l1.a.x - l1.b.x;\n    double C1 = l1.b.x * l1.a.y - l1.a.x * l1.b.y;\n\n    double A2 = l2.b.y - l2.a.y;\n    double B2 = l2.a.x - l2.b.x;\n    double C2 = l2.b.x * l2.a.y - l2.a.x * l2.b.y;\n\n    double det = A1 * B2 - A2 * B1;\n    Point p;\n    p.x = (B2 * C1 - B1 * C2) / det;\n    p.y = (A1 * C2 - A2 * C1) / det;\n    return p;\n}\n\nbool inside(Point p, Point* polygon, int n) {\n    for (int i = 0; i < n; i++) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % n];\n        double cross = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);\n        if (cross < 0) return false;\n    }\n    return true;\n}\n\ndouble find_max_distance(Point* polygon, int n) {\n    double low = 0.0, high = 1e9;\n    double best = 0.0;\n\n    while (high - low > 1e-8) {\n        double mid = (low + high) / 2;\n        bool found = false;\n        Point* new_polygon = malloc(n * sizeof(Point));\n\n        for (int i = 0; i < n; i++) {\n            Point a = polygon[i];\n            Point b = polygon[(i + 1) % n];\n            double dx = b.y - a.y;\n            double dy = a.x - b.x;\n            double len = sqrt(dx * dx + dy * dy);\n            dx = dx / len * mid;\n            dy = dy / len * mid;\n            new_polygon[i].x = a.x + dx;\n            new_polygon[i].y = a.y + dy;\n        }\n\n        for (int i = 0; i < n; i++) {\n            Line l1 = {new_polygon[i], new_polygon[(i + 1) % n]};\n            for (int j = i + 1; j < n; j++) {\n                Line l2 = {new_polygon[j], new_polygon[(j + 1) % n]};\n                Point p = intersection(l1, l2);\n                if (inside(p, new_polygon, n)) {\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n\n        if (found) {\n            best = mid;\n            low = mid;\n        } else {\n            high = mid;\n        }\n        free(new_polygon);\n    }\n    return best;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point* polygon = malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n    double max_distance = find_max_distance(polygon, n);\n    printf(\"%.6lf\\n\", max_distance);\n    free(polygon);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:48:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ntypedef Point Vector;\n\nVector operator-(const Point& a, const Point& b) {\n    return Vector(a.x - b.x, a.y - b.y);\n}\n\ndouble cross(const Vector& a, const Vector& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble dot(const Vector& a, const Vector& b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble length(const Vector& a) {\n    return sqrt(dot(a, a));\n}\n\ndouble distanceToLine(const Point& p, const Point& a, const Point& b) {\n    Vector v1 = b - a;\n    Vector v2 = p - a;\n    return fabs(cross(v1, v2)) / length(v1);\n}\n\ndouble findMaxDistance(const vector<Point>& polygon) {\n    double maxDist = 0.0;\n    int n = polygon.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % n];\n        double minDist = numeric_limits<double>::max();\n        for (int j = 0; j < n; ++j) {\n            if (j == i || j == (i + 1) % n) continue;\n            Point p = polygon[j];\n            double dist = distanceToLine(p, a, b);\n            if (dist < minDist) minDist = dist;\n        }\n        if (minDist > maxDist) maxDist = minDist;\n    }\n    return maxDist;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> polygon(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n    double result = findMaxDistance(polygon);\n    cout << fixed << setprecision(10) << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:49:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    double x, y;\n    Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class DistantPointFromSea {\n    private static final double EPS = 1e-8;\n\n    private static int compare(double a, double b) {\n        if (Math.abs(a - b) < EPS) return 0;\n        return a < b ? -1 : 1;\n    }\n\n    private static double cross(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    private static boolean cw(Point a, Point b, Point c) {\n        return compare(cross(a, b, c), 0) < 0;\n    }\n\n    private static boolean ccw(Point a, Point b, Point c) {\n        return compare(cross(a, b, c), 0) > 0;\n    }\n\n    private static double distance(Point a, Point b) {\n        return Math.hypot(a.x - b.x, a.y - b.y);\n    }\n\n    private static double distanceToLine(Point p, Point a, Point b) {\n        double A = p.x - a.x;\n        double B = p.y - a.y;\n        double C = b.x - a.x;\n        double D = b.y - a.y;\n        double dot = A * C + B * D;\n        double len_sq = C * C + D * D;\n        double param = -1;\n        if (len_sq != 0) param = dot / len_sq;\n        double xx, yy;\n        if (param < 0) {\n            xx = a.x;\n            yy = a.y;\n        } else if (param > 1) {\n            xx = b.x;\n            yy = b.y;\n        } else {\n            xx = a.x + param * C;\n            yy = a.y + param * D;\n        }\n        return Math.hypot(p.x - xx, p.y - yy);\n    }\n\n    private static double findMaxDistance(Point[] polygon, int n) {\n        double low = 0, high = 1e6;\n        for (int iter = 0; iter < 100; iter++) {\n            double mid = (low + high) / 2;\n            Point[] offset = new Point[n];\n            for (int i = 0; i < n; i++) {\n                Point prev = polygon[(i - 1 + n) % n];\n                Point curr = polygon[i];\n                Point next = polygon[(i + 1) % n];\n                double dx1 = curr.x - prev.x;\n                double dy1 = curr.y - prev.y;\n                double len1 = Math.hypot(dx1, dy1);\n                dx1 /= len1;\n                dy1 /= len1;\n                double nx1 = -dy1;\n                double ny1 = dx1;\n                double dx2 = next.x - curr.x;\n                double dy2 = next.y - curr.y;\n                double len2 = Math.hypot(dx2, dy2);\n                dx2 /= len2;\n                dy2 /= len2;\n                double nx2 = -dy2;\n                double ny2 = dx2;\n                double nx = (nx1 + nx2);\n                double ny = (ny1 + ny2);\n                double len = Math.hypot(nx, ny);\n                nx /= len;\n                ny /= len;\n                offset[i] = new Point(curr.x + nx * mid, curr.y + ny * mid);\n            }\n            boolean isValid = true;\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    Point a = offset[i];\n                    Point b = offset[(i + 1) % n];\n                    Point c = offset[j];\n                    Point d = offset[(j + 1) % n];\n                    double den = (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x);\n                    if (compare(den, 0) == 0) continue;\n                    double t = ((a.x - c.x) * (c.y - d.y) - (a.y - c.y) * (c.x - d.x)) / den;\n                    double u = -((a.x - b.x) * (a.y - c.y) - (a.y - b.y) * (a.x - c.x)) / den;\n                    if (compare(t, 0) >= 0 && compare(t, 1) <= 0 && compare(u, 0) >= 0 && compare(u, 1) <= 0) {\n                        isValid = false;\n                        break;\n                    }\n                }\n                if (!isValid) break;\n            }\n            if (isValid) {\n                low = mid;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        Point[] polygon = new Point[n];\n        for (int i = 0; i < n; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            polygon[i] = new Point(x, y);\n        }\n        double maxDistance = findMaxDistance(polygon, n);\n        System.out.printf(\"%.6f\\n\", maxDistance);\n    }\n}",
    "timestamp": "2025-08-05 20:49:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class MostDistantPoint {\n    public static double findMostDistantPoint(Point2D[] polygon) {\n        // Compute the polygon's centroid\n        Point2D centroid = computeCentroid(polygon);\n        \n        // Find the maximum distance from the centroid to any vertex\n        double maxDistance = 0;\n        for (Point2D vertex : polygon) {\n            double distance = centroid.distance(vertex);\n            maxDistance = Math.max(maxDistance, distance);\n        }\n        \n        return maxDistance;\n    }\n    \n    private static Point2D computeCentroid(Point2D[] polygon) {\n        double sumX = 0, sumY = 0;\n        for (Point2D point : polygon) {\n            sumX += point.getX();\n            sumY += point.getY();\n        }\n        return new Point2D.Double(sumX / polygon.length, sumY / polygon.length);\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        Point2D[] islandPolygon = {\n            new Point2D.Double(0, 0),\n            new Point2D.Double(0, 10),\n            new Point2D.Double(10, 10),\n            new Point2D.Double(10, 0)\n        };\n        \n        double result = findMostDistantPoint(islandPolygon);\n        System.out.printf(\"%.5f%n\", result);\n    }\n}",
    "timestamp": "2025-08-05 20:50:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_POINTS 1000\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint is_inside_polygon(Point point, Point* polygon, int n) {\n    for (int i = 0; i < n; i++) {\n        if (cross_product(polygon[i], polygon[(i + 1) % n], point) > 0)\n            return 0;\n    }\n    return 1;\n}\n\ndouble point_line_distance(Point point, Point a, Point b) {\n    double numerator = fabs((b.x - a.x) * (a.y - point.y) - (a.x - point.x) * (b.y - a.y));\n    double denominator = sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\n    return numerator / denominator;\n}\n\ndouble find_max_distance(Point* polygon, int n) {\n    double max_distance = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            Point current_point = {(polygon[i].x + polygon[j].x) / 2, \n                                   (polygon[i].y + polygon[j].y) / 2};\n            \n            if (is_inside_polygon(current_point, polygon, n)) {\n                double min_distance = DBL_MAX;\n                \n                for (int k = 0; k < n; k++) {\n                    double dist = point_line_distance(current_point, polygon[k], polygon[(k + 1) % n]);\n                    min_distance = fmin(min_distance, dist);\n                }\n                \n                max_distance = fmax(max_distance, min_distance);\n            }\n        }\n    }\n    \n    return max_distance;\n}\n\nint main() {\n    int n;\n    Point polygon[MAX_POINTS];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n    \n    printf(\"%.5f\\n\", find_max_distance(polygon, n));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble cross_product(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble point_to_line_distance(const Point& p, const Point& a, const Point& b) {\n    double area = abs(cross_product(b - a, p - a)) / distance(a, b);\n    return area;\n}\n\ndouble find_max_distance(const vector<Point>& polygon) {\n    int n = polygon.size();\n    double max_dist = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        for (int k = 0; k < n; k++) {\n            max_dist = max(max_dist, point_to_line_distance(polygon[k], polygon[i], polygon[j]));\n        }\n    }\n    \n    return max_dist;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n    \n    cout << fixed << setprecision(5) << find_max_distance(polygon) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from scipy.spatial import ConvexHull\nimport numpy as np\n\ndef most_distant_point_from_sea(vertices):\n    hull = ConvexHull(vertices)\n    max_distance = 0\n\n    for i in range(hull.nsimplex):\n        p1, p2 = vertices[hull.simplices[i]]\n        normal_vector = np.array([p2[1] - p1[1], p1[0] - p2[0]])\n        norm = np.linalg.norm(normal_vector)\n        \n        # normalize vector\n        normal_vector /= norm\n\n        # maximum distance from this edge\n        max_dist_from_edge = max(np.dot(vertices, normal_vector)) / np.linalg.norm(normal_vector)\n        max_distance = max(max_distance, max_dist_from_edge)\n\n    return round(max_distance, 5)\n\n# Example Usage\nvertices = np.array([[0,0], [4,0], [4,3], [0,4]])\nprint(most_distant_point_from_sea(vertices))",
    "timestamp": "2025-08-13 03:35:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class DistantPointFromSea {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        Point2D.Double[] vertices = new Point2D.Double[n];\n        for (int i = 0; i < n; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            vertices[i] = new Point2D.Double(x, y);\n        }\n        double maxDistance = 0.0;\n        for (int i = 0, j = n - 1; i < n; j = i++) {\n            Point2D.Double a = vertices[j];\n            Point2D.Double b = vertices[i];\n            for (Point2D.Double p : vertices) {\n                double distance = distancePointToLine(p, a, b);\n                maxDistance = Math.max(maxDistance, distance);\n            }\n        }\n        System.out.printf(\"%.5f%n\", maxDistance);\n        scanner.close();\n    }\n    \n    private static double distancePointToLine(Point2D.Double p, Point2D.Double a, Point2D.Double b) {\n        double A = p.x - a.x;\n        double B = p.y - a.y;\n        double C = b.x - a.x;\n        double D = b.y - a.y;\n        double dot = A * C + B * D;\n        double lenSq = C * C + D * D;\n        double param = -1.0;\n        if (lenSq != 0.0) { // in case of 0 length line\n            param = dot / lenSq;\n        }\n        double xx, yy;\n        if (param < 0) {\n            xx = a.x;\n            yy = a.y;\n        } else if (param > 1) {\n            xx = b.x;\n            yy = b.y;\n        } else {\n            xx = a.x + param * C;\n            yy = a.y + param * D;\n        }\n        double dx = p.x - xx;\n        double dy = p.y - yy;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
    "timestamp": "2025-08-13 03:35:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x;\n    double y;\n} Point;\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distance(Point a, Point b) {\n    return sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\n}\n\ndouble pointToLineDistance(Point a, Point b, Point p) {\n    double area = fabs(cross(a, b, p));\n    double base = distance(a, b);\n    return area / base;\n}\n\ndouble maxDistance(Point points[], int n) {\n    double maxDist = 0.0;\n    for (int i = 0; i < n; i++) {\n        Point a = points[i];\n        Point b = points[(i + 1) % n];\n        for (int j = 0; j < n; j++) {\n            Point c = points[j];\n            double dist = pointToLineDistance(a, b, c);\n            if (dist > maxDist) {\n                maxDist = dist;\n            }\n        }\n    }\n    return maxDist;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point points[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    printf(\"%.5lf\\n\", maxDistance(points, n));\n    return 0;\n}",
    "timestamp": "2025-08-13 03:35:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport math\n\ndef distance_to_line(point: Tuple[float, float], line_start: Tuple[float, float], line_end: Tuple[float, float]) -> float:\n    x, y = point\n    x1, y1 = line_start\n    x2, y2 = line_end\n    \n    # Calculate line segment length\n    line_length = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    \n    # Handle zero-length line segment\n    if line_length == 0:\n        return math.sqrt((x - x1)**2 + (y - y1)**2)\n    \n    # Calculate projection\n    t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / (line_length ** 2)\n    \n    # Clamp t to line segment\n    t = max(0, min(1, t))\n    \n    # Closest point on line segment\n    closest_x = x1 + t * (x2 - x1)\n    closest_y = y1 + t * (y2 - y1)\n    \n    return math.sqrt((x - closest_x)**2 + (y - closest_y)**2)\n\ndef point_inside_polygon(point: Tuple[float, float], polygon: List[Tuple[float, float]]) -> bool:\n    inside = False\n    x, y = point\n    n = len(polygon)\n    \n    for i in range(n):\n        j = (i + 1) % n\n        xi, yi = polygon[i]\n        xj, yj = polygon[j]\n        \n        intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n        \n        if intersect:\n            inside = not inside\n    \n    return inside\n\ndef find_most_distant_point(polygon: List[Tuple[float, float]]) -> float:\n    # Find polygon bounds\n    min_x = min(p[0] for p in polygon)\n    max_x = max(p[0] for p in polygon)\n    min_y = min(p[1] for p in polygon)\n    max_y = max(p[1] for p in polygon)\n    \n    # Generate points to check\n    step = min((max_x - min_x), (max_y - min_y)) / 100\n    max_distance = 0\n    \n    for x in range(int((max_x - min_x) / step) + 1):\n        for y in range(int((max_y - min_y) / step) + 1):\n            point = (min_x + x * step, min_y + y * step)\n            \n            if point_inside_polygon(point, polygon):\n                # Find minimum distance to polygon edges\n                min_edge_dist = float('inf')\n                for i in range(len(polygon)):\n                    min_edge_dist = min(min_edge_dist, \n                        distance_to_line(point, polygon[i], polygon[(i+1) % len(polygon)]))\n                \n                max_distance = max(max_distance, min_edge_dist)\n    \n    return max_distance\n\n# Example usage\npolygon = [(0, 0), (0, 10), (10, 10), (10, 0)]\nresult = find_most_distant_point(polygon)\nprint(f\"{result:.5f}\")",
    "timestamp": "2025-08-13 03:36:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef point_to_line_distance(point, line_start, line_end):\n    x0, y0 = point\n    x1, y1 = line_start\n    x2, y2 = line_end\n    \n    numerator = abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1)\n    denominator = math.sqrt((y2 - y1)**2 + (x2 - x1)**2)\n    if denominator == 0:\n        return math.sqrt((x0 - x1)**2 + (y0 - y1)**2)\n    return numerator / denominator\n\ndef find_max_distance(polygon):\n    max_distance = float('inf')\n    n = len(polygon)\n    \n    for i in range(n):\n        line_start = polygon[i]\n        line_end = polygon[(i + 1) % n]\n        \n        current_max = 0\n        for point in polygon:\n            distance = point_to_line_distance(point, line_start, line_end)\n            if distance > current_max:\n                current_max = distance\n        \n        if current_max < max_distance:\n            max_distance = current_max\n    \n    return max_distance\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    polygon = []\n    index = 1\n    for _ in range(n):\n        x = float(input[index])\n        y = float(input[index + 1])\n        polygon.append((x, y))\n        index += 2\n    max_distance = find_max_distance(polygon)\n    print(\"{0:.6f}\".format(max_distance))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:36:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point &a, const Point &b) {\n    return std::hypot(a.x - b.x, a.y - b.y);\n}\n\ndouble point_to_line_distance(const Point &p, const Point &a, const Point &b) {\n    double A = b.y - a.y;\n    double B = a.x - b.x;\n    double C = b.x * a.y - a.x * b.y;\n    return std::abs(A * p.x + B * p.y + C) / std::hypot(A, B);\n}\n\nPoint farthest_point_from_sea(const std::vector<Point> &polygon) {\n    double max_distance = 0;\n    Point farthest_point = {0, 0};\n\n    for (const Point &vertex : polygon) {\n        double min_distance = std::numeric_limits<double>::max();\n\n        for (size_t i = 0; i < polygon.size(); ++i) {\n            const Point &a = polygon[i];\n            const Point &b = polygon[(i + 1) % polygon.size()];\n            double dist_to_edge = point_to_line_distance(vertex, a, b);\n            min_distance = std::min(min_distance, dist_to_edge);\n        }\n\n        if (min_distance > max_distance) {\n            max_distance = min_distance;\n            farthest_point = vertex;\n        }\n    }\n\n    return farthest_point;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Point> polygon(n);\n\n    for (int i = 0; i < n; ++i) {\n        std::cin >> polygon[i].x >> polygon[i].y;\n    }\n\n    Point farthest_point = farthest_point_from_sea(polygon);\n\n    std::cout << std::fixed << std::setprecision(5) << distance(farthest_point, {0, 0}) << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:13:43"
  }
]